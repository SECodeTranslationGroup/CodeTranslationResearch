function calculate ( $ a , $ n ) { sort ( $ a ) ; $ s = array ( ) ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ j ; $ i ++ , $ j -- ) array_push ( $ s , ( $ a [ $ i ] + $ a [ $ j ] ) ) ; $ mini = min ( $ s ) ; $ maxi = max ( $ s ) ; return abs ( $ maxi - $ mini ) ; }
function cyl ( $ r , $ h ) { if ( $ r < 0 && $ h < 0 ) return -1 ; $ R = ( int ) ( 2 * $ r ) / 3 ; $ H = ( int ) ( 2 * $ h ) / 3 ; $ V = 3.14 * pow ( $ R , 2 ) * $ H ; return $ V ; }
function printTwoSetBitNums ( $ n ) { $ x = 1 ; while ( $ n > 0 ) { $ y = 0 ; while ( $ y < $ x ) { echo ( 1 << $ x ) + ( 1 << $ y ) , " ▁ " ; $ n -- ; if ( $ n == 0 ) return ; $ y ++ ; } $ x ++ ; } }
function minNumber ( $ a , $ n , $ x ) { $ l = 0 ; $ h = 0 ; $ e = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ x ) $ e ++ ; else if ( $ a [ $ i ] > $ x ) $ h ++ ; else if ( $ a [ $ i ] < $ x ) $ l ++ ; } $ ans = 0 ; if ( $ l > $ h ) $ ans = $ l - $ h ; else if ( $ l < $ h ) $ ans = $ h - $ l - 1 ; return $ ans + 1 - $ e ; }
function printKthBit ( $ n , $ k ) { echo ( $ n & ( 1 << ( $ k - 1 ) ) ) ; }
function equilibrium ( $ arr , $ n ) { $ sum = 0 ; $ leftsum = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ sum -= $ arr [ $ i ] ; if ( $ leftsum == $ sum ) return $ i ; $ leftsum += $ arr [ $ i ] ; } return -1 ; }
function countRhombi ( $ h , $ w ) { $ ct = 0 ; for ( $ i = 2 ; $ i <= $ h ; $ i += 2 ) for ( $ j = 2 ; $ j <= $ w ; $ j += 2 ) $ ct += ( $ h - $ i + 1 ) * ( $ w - $ j + 1 ) ; return $ ct ; }
function sumofoddFactors ( $ n ) { $ res = 1 ; while ( $ n % 2 == 0 ) $ n = $ n / 2 ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = $ n / $ i ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; }
function isPower ( $ n ) { for ( $ x = 2 ; $ x <= sqrt ( $ n ) ; $ x ++ ) { $ f = log ( $ n ) / log ( $ x ) ; if ( ( $ f - ( int ) $ f ) == 0.0 ) return true ; } return false ; }
function sumOfSeries ( $ n ) { return $ n * ( $ n + 1 ) * ( 6 * $ n * $ n * $ n + 9 * $ n * $ n + $ n - 1 ) / 30 ; }
function sum ( $ n ) { $ i ; $ s = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ s = $ s + 1 / $ i ; return $ s ; }
function countRect ( $ n ) { $ ans = 0 ; for ( $ length = 1 ; $ length <= sqrt ( $ n ) ; $ length ++ ) for ( $ height = $ length ; $ height * $ length <= $ n ; $ height ++ ) $ ans ++ ; return $ ans ; }
function isSquareFree ( $ n ) { if ( $ n % 2 == 0 ) $ n = $ n / 2 ; if ( $ n % 2 == 0 ) return false ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ n = $ n / $ i ; if ( $ n % $ i == 0 ) return false ; } } return true ; }
function constructXOR ( & $ A , $ n ) { $ XOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ XOR ^= $ A [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ A [ $ i ] = $ XOR ^ $ A [ $ i ] ; }
function maxArea ( $ perimeter ) { $ length = ( int ) ceil ( $ perimeter / 4 ) ; $ breadth = ( int ) floor ( $ perimeter / 4 ) ; return ( $ length * $ breadth ) ; }
function isPowerOfK ( $ n , $ k ) { $ oneSeen = false ; while ( $ n > 0 ) { $ digit = $ n % $ k ; if ( $ digit > 1 ) return false ; if ( $ digit == 1 ) { if ( $ oneSeen ) return false ; $ oneSeen = true ; } $ n = ( int ) $ n / $ k ; } return true ; }
function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; }
function squareArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = pow ( 1.268 , 2 ) * pow ( $ a , 2 ) ; return $ area ; }
function cal_cos ( $ n ) { $ accuracy = 0.0001 ; $ n = $ n * ( 3.142 / 180.0 ) ; $ x1 = 1 ; $ cosx = $ x1 ; $ cosval = cos ( $ n ) ; $ i = 1 ; do { $ denominator = 2 * $ i * ( 2 * $ i - 1 ) ; $ x1 = - $ x1 * $ n * $ n / $ denominator ; $ cosx = $ cosx + $ x1 ; $ i = $ i + 1 ; } while ( $ accuracy <= abs ( $ cosval - $ cosx ) ) ; echo round ( $ cosx , 6 ) ; }
function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j * $ j <= $ i ; ++ $ j ) { if ( $ i % $ j == 0 ) { if ( $ i / $ j == $ j ) $ sum += $ j ; else $ sum += $ j + $ i / $ j ; } } } return $ sum ; }
function hexadecagonalNum ( $ n ) { return ( ( 14 * $ n * $ n ) - 12 * $ n ) / 2 ; }
function minValue ( $ n , $ x , $ y ) { $ val = ( $ y * $ n ) / 100 ; if ( $ x >= $ val ) return 0 ; else return ( ceil ( $ val ) - $ x ) ; } { $ n = 10 ; $ x = 2 ; $ y = 40 ; echo ( minValue ( $ n , $ x , $ y ) ) ; }
function middlesum ( $ mat , $ n ) { $ row_sum = 0 ; $ col_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ row_sum += $ mat [ $ n / 2 ] [ $ i ] ; echo " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , $ row_sum , " STRNEWLINE " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ col_sum += $ mat [ $ i ] [ $ n / 2 ] ; echo " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " , $ col_sum ; }
function printBalancedExpression ( $ a , $ b , $ c , $ d ) { if ( ( $ a == $ d && $ a ) || ( $ a == 0 && $ c == 0 && $ d == 0 ) ) { for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) echo " ( ( " ; for ( $ i = 1 ; $ i <= $ c ; $ i ++ ) echo " ) ( " ; for ( $ i = 1 ; $ i <= $ d ; $ i ++ ) echo " ) ) " ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) echo " ( ) " ; } else echo - 1 ; }
function judgeSquareSum ( $ n ) { for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { $ count = 0 ; if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) { $ count ++ ; $ n = ( int ) $ n / $ i ; } if ( $ i % 4 == 3 && $ count % 2 != 0 ) return false ; } } return $ n % 4 != 3 ; }
function highestPowerOf2 ( $ n ) { return ( $ n & ( ~ ( $ n - 1 ) ) ) ; }
function printMaxSum ( $ arr , $ n ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = $ arr [ $ i ] ; $ maxi = 0 ; for ( $ j = 1 ; $ j <= sqrt ( $ i + 1 ) ; $ j ++ ) { if ( ( ( $ i + 1 ) % $ j == 0 ) && ( $ i + 1 ) != $ j ) { if ( $ dp [ $ j - 1 ] > $ maxi ) $ maxi = $ dp [ $ j - 1 ] ; if ( $ dp [ ( $ i + 1 ) / $ j - 1 ] > $ maxi && $ j != 1 ) $ maxi = $ dp [ ( $ i + 1 ) / $ j - 1 ] ; } } $ dp [ $ i ] += $ maxi ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ dp [ $ i ] , " ▁ " ; }
function isInGivenBase ( $ str , $ base ) { if ( $ base > 16 ) return false ; else if ( $ base <= 10 ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ! ( $ str [ $ i ] >= '0' and $ str [ $ i ] < ( '0' + $ base ) ) ) return false ; } else { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ! ( ( $ str [ $ i ] >= '0' && $ str [ $ i ] < ( '0' + $ base ) ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] < ( ' A ' + $ base - 10 ) ) ) ) return false ; } return true ; }
function convert ( $ str ) { $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ▁ ' ) $ str [ $ i ] = ' _ ' ; else $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; } echo $ str ; }
function hammingDistance ( $ n1 , $ n2 ) { $ x = $ n1 ^ $ n2 ; $ setBits = 0 ; while ( $ x > 0 ) { $ setBits += $ x & 1 ; $ x >>= 1 ; } return $ setBits ; }
function roundFunation ( $ n ) { $ a = ( int ) ( $ n / 10 ) * 10 ; $ b = ( $ a + 10 ) ; return ( $ n - $ a > $ b - $ n ) ? $ b : $ a ; }
function absSumDidd ( $ a , $ n ) { sort ( $ a ) ; $ midValue = $ a [ ( $ n / 2 ) ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + abs ( $ a [ $ i ] - $ midValue ) ; } return $ sum ; }
function sumN ( $ n ) { $ n = ( int ) ( ( $ n + 1 ) / 2 ) ; return ( $ n * $ n ) ; }
function getPairsCount ( $ arr , $ n , $ sum ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) $ count ++ ; return $ count ; }
function bin ( $ n ) { if ( $ n > 1 ) bin ( $ n >> 1 ) ; echo ( $ n & 1 ) ; }
function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; }
function findNature ( $ a , $ b , $ n ) { if ( $ n == 0 ) return ( $ a & 1 ) ; if ( $ n == 1 ) return ( $ b & 1 ) ; if ( ! ( $ a & 1 ) ) { if ( ! ( $ b & 1 ) ) return false ; else return ( $ n % 3 != 0 ) ; } else { if ( ! ( $ b & 1 ) ) return ( ( $ n - 1 ) % 3 != 0 ) ; else return ( ( $ n + 1 ) % 3 != 0 ) ; } }
function getCount ( $ N ) { if ( $ N % 2 == 1 ) return 0 ; $ result = "9" ; for ( $ i = 1 ; $ i <= $ N / 2 - 1 ; $ i ++ ) $ result . = "0" ; return $ result ; }
function longOddEvenIncSeq ( & $ arr , $ n ) { $ lioes = array_fill ( 0 , $ n , NULL ) ; $ maxLen = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lioes [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && ( $ arr [ $ i ] + $ arr [ $ j ] ) % 2 != 0 && $ lioes [ $ i ] < $ lioes [ $ j ] + 1 ) $ lioes [ $ i ] = $ lioes [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ maxLen < $ lioes [ $ i ] ) $ maxLen = $ lioes [ $ i ] ; return $ maxLen ; }
function rad ( $ d , $ h ) { echo " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " , ( ( $ d * $ d ) / ( 8 * $ h ) + $ h / 2 ) , " STRNEWLINE " ; }
function printAllAPTriplets ( $ arr , $ n ) { $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; if ( in_array ( $ arr [ $ i ] - $ diff , $ arr ) ) echo ( ( $ arr [ $ i ] - $ diff ) . " " ▁ . ▁ $ arr [ $ i ] ▁ . ▁ " " ▁ . ▁ $ arr [ $ j ] ▁ . ▁ " " } array_push ( $ s , $ arr [ $ i ] ) ; } }
function sumOfSeries ( $ x , $ k ) { return ( ( $ x ) / 81 ) * ( 9 * $ k - 1 + pow ( 10 , ( -1 ) * $ k ) ) ; }
function binaryToDecimal ( $ n ) { $ num = $ n ; $ dec_value = 0 ; $ base = 1 ; $ temp = $ num ; while ( $ temp ) { $ last_digit = $ temp % 10 ; $ temp = $ temp / 10 ; $ dec_value += $ last_digit * $ base ; $ base = $ base * 2 ; } return $ dec_value ; }
function nobleInteger ( $ arr ) { sort ( $ arr ) ; $ n = count ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) continue ; if ( $ arr [ $ i ] == $ n - $ i - 1 ) return $ arr [ $ i ] ; } if ( $ arr [ $ n - 1 ] == 0 ) return $ arr [ $ n - 1 ] ; return -1 ; }
function pad ( $ n ) { $ pPrevPrev = 1 ; $ pPrev = 1 ; $ pCurr = 1 ; $ pNext = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ pNext = $ pPrevPrev + $ pPrev ; $ pPrevPrev = $ pPrev ; $ pPrev = $ pCurr ; $ pCurr = $ pNext ; } return $ pNext ; }
function findSubsequence ( $ str , $ k ) { $ a = array ( 1024 ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ a [ $ i ] = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ temp = ord ( $ str [ $ i ] ) - ord ( ' a ' ) ; $ a [ $ temp ] += 1 ; } for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ a [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] >= $ k ) echo $ str [ $ i ] ; }
function count_square ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i = $ i + 2 ) { $ k = $ n - $ i + 1 ; $ count += ( $ k * $ k ) ; } return $ count ; }
function countTriplets ( $ arr , $ n , $ m ) { $ count = 0 ; sort ( $ arr ) ; $ end ; $ start ; $ mid ; for ( $ end = $ n - 1 ; $ end >= 2 ; $ end -- ) { $ start = 0 ; $ mid = $ end - 1 ; while ( $ start < $ mid ) { $ prod = $ arr [ $ end ] * $ arr [ $ start ] * $ arr [ $ mid ] ; if ( $ prod > $ m ) $ mid -- ; else if ( $ prod < $ m ) $ start ++ ; else if ( $ prod == $ m ) { $ count ++ ; $ mid -- ; $ start ++ ; } } } return $ count ; }
function calculateArea ( $ x , $ y ) { $ pi = 3.1415926536 ; $ arx = $ pi * $ x * $ x ; $ ary = $ pi * $ y * $ y ; return ( $ arx - $ ary ) ; }
function maxMin ( $ arr , $ n ) { $ min = PHP_INT_MAX ; $ max = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n / 2 ; $ j ++ ) { if ( $ arr [ $ i ] [ $ j ] > $ arr [ $ i ] [ $ n - $ j - 1 ] ) { if ( $ min > $ arr [ $ i ] [ $ n - $ j - 1 ] ) $ min = $ arr [ $ i ] [ $ n - $ j - 1 ] ; if ( $ max < $ arr [ $ i ] [ $ j ] ) $ max = $ arr [ $ i ] [ $ j ] ; } else { if ( $ min > $ arr [ $ i ] [ $ j ] ) $ min = $ arr [ $ i ] [ $ j ] ; if ( $ max < $ arr [ $ i ] [ $ n - $ j - 1 ] ) $ max = $ arr [ $ i ] [ $ n - $ j - 1 ] ; } } } echo " Maximum = " ▁ , ▁ $ max STRNEWLINE TABSYMBOL TABSYMBOL , " , Minimum = " }
function checkFittingArrays ( $ A , $ B , $ N ) { sort ( $ A ) ; sort ( $ B ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] > $ B [ $ i ] ) return false ; return true ; }
function printTrib ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 0 ; $ dp [ 2 ] = 1 ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + $ dp [ $ i - 3 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ dp [ $ i ] , " ▁ " ; }
function isUnique ( $ a , $ n , $ k ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; $ sum += $ n - 1 ; return ( $ sum == $ k ) ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 4 * $ n - 2 ; }
function printSquares ( $ n ) { $ square = 0 ; $ odd = 1 ; for ( $ x = 0 ; $ x < $ n ; $ x ++ ) { echo $ square , " " ; $ square = $ square + $ odd ; $ odd = $ odd + 2 ; } }
function pentagon_pyramidal ( $ n ) { return $ n * $ n * ( $ n + 1 ) / 2 ; }
function oddEquivalent ( $ s , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ count ++ ; } return $ count ; }
function countWays ( $ index , $ cnt , $ dp , $ n , $ m , $ k ) { if ( $ index == $ n ) { if ( $ cnt == $ k ) return 1 ; else return 0 ; } if ( $ dp [ $ index ] [ $ cnt ] != -1 ) return $ dp [ $ index ] [ $ cnt ] ; $ ans = 0 ; $ ans += countWays ( $ index + 1 , $ cnt , $ dp , $ n , $ m , $ k ) ; $ ans += ( $ m - 1 ) * countWays ( $ index + 1 , $ cnt + 1 , $ dp , $ n , $ m , $ k ) ; $ dp [ $ index ] [ $ cnt ] = $ ans ; return $ dp [ $ index ] [ $ cnt ] ; }
function polyarea ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; $ A = ( $ a * $ a * $ n ) / ( 4 * tan ( ( 180 / $ n ) * 3.14159 / 180 ) ) ; return $ A ; }
function countSol ( $ coeff , $ start , $ end , $ rhs ) { if ( $ rhs == 0 ) return 1 ; $ result = 0 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) if ( $ coeff [ $ i ] <= $ rhs ) $ result += countSol ( $ coeff , $ i , $ end , $ rhs - $ coeff [ $ i ] ) ; return $ result ; }
function findMaximumPieces ( $ n ) { $ x = ( int ) ( $ n / 2 ) ; return ( ( $ x + 1 ) * ( $ n - $ x + 1 ) ) ; }
function nthTerm ( $ n ) { return 6 * pow ( $ n , 2 ) - 4 * $ n - 2 ; }
function isSurd ( $ n ) { for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { $ j = $ i ; while ( $ j < $ n ) $ j = $ j * $ i ; if ( $ j == $ n ) return false ; } return true ; }
function swap ( $ a , $ b , $ c , $ d ) { $ a = $ a + $ b ; $ b = $ a - $ b ; $ a = $ a - $ b ; $ b = $ b + $ c ; $ c = $ b - $ c ; $ b = $ b - $ c ; $ c = $ c + $ d ; $ d = $ c - $ d ; $ c = $ c - $ d ; echo " values ▁ after ▁ swapping ▁ are ▁ : ▁ " , " STRNEWLINE " ; echo " a = " ▁ , ▁ $ a ▁ , " " ; STRNEWLINE TABSYMBOL echo ▁ " b = " ▁ , ▁ $ b ▁ , " " ; STRNEWLINE TABSYMBOL echo ▁ " c = " ▁ , $ c ▁ , " " ; STRNEWLINE TABSYMBOL echo ▁ " d = " ▁ , ▁ $ d ▁ , " " }
function checkPronic ( $ x ) { for ( $ i = 0 ; $ i <= ( sqrt ( $ x ) ) ; $ i ++ ) if ( $ x == $ i * ( $ i + 1 ) ) return true ; return false ; }
function FindMaxSum ( $ arr , $ n ) { $ incl = $ arr [ 0 ] ; $ excl = 0 ; $ excl_new ; $ i ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = ( $ incl > $ excl ) ? $ incl : $ excl ; $ incl = $ excl + $ arr [ $ i ] ; $ excl = $ excl_new ; } return ( ( $ incl > $ excl ) ? $ incl : $ excl ) ; }
function maxGameByWinner ( $ N ) { $ dp [ $ N ] = 0 ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 2 ; $ i = 2 ; do { $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] ; } while ( $ dp [ $ i ++ ] <= $ N ) ; return ( $ i - 2 ) ; }
function Area ( $ r ) { if ( $ r < 0 ) return -1 ; $ x = ( 2 * $ r ) / sqrt ( 5 ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; }
function findAnswer ( $ X , $ N ) { return ( $ N - 1 ) * 9 + $ X ; }
function checkPandigital ( $ b , $ n ) { if ( strlen ( $ n ) < $ b ) return 0 ; $ hash = array ( ) ; for ( $ i = 0 ; $ i < $ b ; $ i ++ ) $ hash [ $ i ] = 0 ; for ( $ i = 0 ; $ i < strlen ( $ n ) ; $ i ++ ) { if ( $ n [ $ i ] >= '0' && $ n [ $ i ] <= '9' ) $ hash [ $ n [ $ i ] - '0' ] = 1 ; else if ( ord ( $ n [ $ i ] ) - ord ( ' A ' ) <= $ b - 11 ) $ hash [ ord ( $ n [ $ i ] ) - ord ( ' A ' ) + 10 ] = 1 ; } for ( $ i = 0 ; $ i < $ b ; $ i ++ ) if ( $ hash [ $ i ] == 0 ) return 0 ; return 1 ; }
function maxSumIS ( $ arr , $ n ) { $ max = 0 ; $ msis = array ( $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ msis [ $ i ] = $ arr [ $ i ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ msis [ $ i ] < $ msis [ $ j ] + $ arr [ $ i ] ) $ msis [ $ i ] = $ msis [ $ j ] + $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ msis [ $ i ] ) $ max = $ msis [ $ i ] ; return $ max ; }
function findCommon ( $ ar1 , $ ar2 , $ ar3 , $ n1 , $ n2 , $ n3 ) { $ i = 0 ; $ j = 0 ; $ k = 0 ; while ( $ i < $ n1 && $ j < $ n2 && $ k < $ n3 ) { if ( $ ar1 [ $ i ] == $ ar2 [ $ j ] && $ ar2 [ $ j ] == $ ar3 [ $ k ] ) { echo $ ar1 [ $ i ] , " " ; $ i ++ ; $ j ++ ; $ k ++ ; } else if ( $ ar1 [ $ i ] < $ ar2 [ $ j ] ) $ i ++ ; else if ( $ ar2 [ $ j ] < $ ar3 [ $ k ] ) $ j ++ ; else $ k ++ ; } }
function answerQuery ( $ a , $ n , $ l , $ r ) { $ count = 0 ; $ l = $ l - 1 ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) { $ element = $ a [ $ i ] ; $ divisors = 0 ; for ( $ j = $ l ; $ j < $ r ; $ j ++ ) { if ( $ a [ $ j ] % $ a [ $ i ] == 0 ) $ divisors ++ ; else break ; } if ( $ divisors == ( $ r - $ l ) ) $ count ++ ; } return $ count ; }
function productAtKthLevel ( $ tree , $ k ) { $ level = -1 ; $ n = strlen ( $ tree ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ tree [ $ i ] == ' ( ' ) $ level ++ ; else if ( $ tree [ $ i ] == ' ) ' ) $ level -- ; else { if ( $ level == $ k ) $ product *= ( ord ( $ tree [ $ i ] ) - ord ( '0' ) ) ; } } return $ product ; }
function Cycles ( $ N ) { $ fact = 1 ; $ result = 0 ; $ result = $ N - 1 ; $ i = $ result ; while ( $ i > 0 ) { $ fact = $ fact * $ i ; $ i -- ; } return floor ( $ fact / 2 ) ; }
function findFourElements ( $ A , $ n , $ X ) { for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) { for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] + $ A [ $ l ] == $ X ) echo $ A [ $ i ] , " , ▁ " , $ A [ $ j ] , " , ▁ " , $ A [ $ k ] , " , ▁ " , $ A [ $ l ] ; } } } }
function minOperations ( $ s , $ t , $ n ) { $ ct0 = 0 ; $ ct1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ t [ $ i ] ) continue ; if ( $ s [ $ i ] == '0' ) $ ct0 ++ ; else $ ct1 ++ ; } return max ( $ ct0 , $ ct1 ) ; }
function countOfBinaryNumberLessThanN ( $ N ) { $ q = array ( ) ; array_push ( $ q , 1 ) ; $ cnt = 0 ; $ t = 0 ; while ( ! empty ( $ q ) ) { $ t = array_pop ( $ q ) ; if ( $ t <= $ N ) { $ cnt ++ ; array_push ( $ q , $ t * 10 ) ; array_push ( $ q , ( $ t * 10 + 1 ) ) ; } } return $ cnt ; }
function countPairs ( $ a , $ n , $ k ) { sort ( $ a ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j = $ i + 1 ; while ( $ j < $ n and $ a [ $ j ] - $ a [ $ i ] < $ k ) { $ res ++ ; $ j ++ ; } } return $ res ; }
function findMinRooms ( $ slots , $ n , $ m ) { $ counts = array_fill ( 0 , $ m , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ slots [ $ i ] [ $ j ] == '1' ) $ counts [ $ j ] ++ ; return max ( $ counts ) ; }
function minimumLength ( $ x , $ y , $ z ) { return 1 + abs ( $ x - $ y ) + abs ( $ y - $ z ) ; }
function find_greatest_divisor ( $ l , $ r ) { if ( $ l == $ r ) return $ l ; return 1 ; }
function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; }
function countWays ( $ n , $ m ) { $ count [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i > $ m ) $ count [ $ i ] = $ count [ $ i - 1 ] + $ count [ $ i - $ m ] ; else if ( $ i < $ m or $ i == 1 ) $ count [ $ i ] = 1 ; else $ count [ $ i ] = 2 ; } return $ count [ $ n ] ; }
function catalanDP ( $ n ) { $ catalan = array ( ) ; $ catalan [ 0 ] = $ catalan [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ catalan [ $ i ] = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ catalan [ $ i ] += $ catalan [ $ j ] * $ catalan [ $ i - $ j - 1 ] ; } return $ catalan [ $ n ] ; }
function getQuadrant ( $ X , $ Y , $ R , $ PX , $ PY ) { if ( $ PX == $ X and $ PY == $ Y ) return 0 ; $ val = pow ( ( $ PX - $ X ) , 2 ) + pow ( ( $ PY - $ Y ) , 2 ) ; if ( $ val > pow ( $ R , 2 ) ) return -1 ; if ( $ PX > $ X and $ PY >= $ Y ) return 1 ; if ( $ PX <= $ X and $ PY > $ Y ) return 2 ; if ( $ PX < $ X and $ PY <= $ Y ) return 3 ; if ( $ PX >= $ X and $ PY < $ Y ) return 4 ; }
function decdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.902 * $ a ; return $ d ; }
function shortest_distance ( $ x1 , $ y1 , $ z1 , $ a , $ b , $ c , $ d ) { $ d = abs ( ( $ a * $ x1 + $ b * $ y1 + $ c * $ z1 + $ d ) ) ; $ e = sqrt ( $ a * $ a + $ b * $ b + $ c * $ c ) ; echo " Perpendicular ▁ distance ▁ is ▁ " . $ d / $ e ; }
function findGreatest ( $ arr , $ n ) { $ result = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ j ] * $ arr [ $ k ] == $ arr [ $ i ] ) $ result = max ( $ result , $ arr [ $ i ] ) ; return $ result ; }
function findCount ( $ str1 , $ str2 ) { $ len = strlen ( $ str1 ) ; $ len2 = strlen ( $ str1 ) ; $ ans = PHP_INT_MAX ; $ hash1 = array_fill ( 0 , 26 , 0 ) ; $ hash2 = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ hash1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ len2 ; $ i ++ ) $ hash2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ hash2 [ $ i ] ) $ ans = min ( $ ans , $ hash1 [ $ i ] / $ hash2 [ $ i ] ) ; return $ ans ; }
function difference ( $ arr , $ n ) { $ d1 = 0 ; $ d2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ d1 += $ arr [ $ i ] [ $ i ] ; $ d2 += $ arr [ $ i ] [ $ n - $ i - 1 ] ; } return abs ( $ d1 - $ d2 ) ; } { $ n = 3 ; $ arr = array ( array ( 11 , 2 , 4 ) , array ( 4 , 5 , 6 ) , array ( 10 , 8 , -12 ) ) ; echo difference ( $ arr , $ n ) ; return 0 ; }
function minimumLectures ( $ m , $ n ) { $ ans = 0 ; if ( $ n < ceil ( 0.75 * $ m ) ) $ ans = ( int ) ceil ( ( ( 0.75 * $ m ) - $ n ) / 0.25 ) ; else $ ans = 0 ; return $ ans ; }
function func ( $ a , $ k , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] % $ k == 0 ) return true ; return false ; }
function circlearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ A = ( 3.14 * pow ( $ a , 2 ) * pow ( $ b , 2 ) ) / ( 4 * ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) ) ; return $ A ; }
function minDiff ( $ arr , $ n , $ k ) { $ INT_MAX = 2147483647 ; $ result = $ INT_MAX ; sort ( $ arr , $ n ) ; sort ( $ arr ) ; for ( $ i = 0 ; $ i <= $ n - $ k ; $ i ++ ) $ result = min ( $ result , $ arr [ $ i + $ k - 1 ] - $ arr [ $ i ] ) ; return $ result ; }
function Square ( $ row , $ column , $ moves ) { $ a = 0 ; $ b = 0 ; $ c = 0 ; $ d = 0 ; $ total = 0 ; $ a = $ row - $ moves ; $ b = $ row + $ moves ; $ c = $ column - $ moves ; $ d = $ column + $ moves ; if ( $ a < 1 ) $ a = 1 ; if ( $ c < 1 ) $ c = 1 ; if ( $ b > 8 ) $ b = 8 ; if ( $ d > 8 ) $ d = 8 ; $ total = ( $ b - $ a + 1 ) * ( $ d - $ c + 1 ) - 1 ; return $ total ; }
function findOccurrences ( $ str , $ substr ) { $ counter = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == $ substr [ 0 ] ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) { if ( $ str [ $ j ] == $ substr [ 1 ] ) { for ( $ k = $ j + 1 ; $ k < strlen ( $ str ) ; $ k ++ ) { if ( $ str [ $ k ] == $ substr [ 2 ] ) $ counter ++ ; } } } } } return $ counter ; }
function nswp ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = 2 * $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] ; return $ dp [ $ n ] ; }
function divide ( $ a , $ b ) { for ( $ i = 2 ; $ i <= min ( $ a , $ b ) ; $ i ++ ) { while ( $ a % $ i == 0 && $ b % $ i == 0 ) { $ a = $ a / $ i ; $ b = $ b / $ i ; } } echo " A = " , ▁ $ a , ▁ " , B = " , ▁ $ b , ▁ " " }
function SubArraySum ( $ arr , $ n ) { $ result = 0 ; $ temp = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ temp += $ arr [ $ j ] $ result += $ temp ; } } return $ result ; }
function countReduce ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) $ res += abs ( ord ( $ str [ $ i ] ) - ord ( $ str [ ( $ n - $ i - 1 ) ] ) ) ; return $ res ; }
function numberOfWays ( $ x ) { $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ x ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; return $ dp [ $ x ] ; }
function countNonDecreasing ( $ n ) { $ dp = array_fill ( 0 , 10 , array_fill ( 0 , $ n + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ dp [ $ i ] [ 1 ] = 1 ; for ( $ digit = 0 ; $ digit <= 9 ; $ digit ++ ) { for ( $ len = 2 ; $ len <= $ n ; $ len ++ ) { for ( $ x = 0 ; $ x <= $ digit ; $ x ++ ) $ dp [ $ digit ] [ $ len ] += $ dp [ $ x ] [ $ len - 1 ] ; } } $ count = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ count += $ dp [ $ i ] [ $ n ] ; return $ count ; }
function countOddRotations ( $ n ) { $ odd_count = 0 ; $ even_count = 0 ; do { $ digit = $ n % 10 ; if ( $ digit % 2 == 1 ) $ odd_count ++ ; else $ even_count ++ ; $ n = ( int ) ( $ n / 10 ) ; } while ( $ n != 0 ) ; echo " Odd = " , ▁ $ odd _ count , ▁ " " ; STRNEWLINE TABSYMBOL echo ▁ " Even = " , ▁ $ even _ count , ▁ " " }
function check ( $ n ) { $ sum = 0 ; while ( $ n != 0 ) { $ sum += $ n % 10 ; $ n = ( int ) ( $ n / 10 ) ; } if ( $ sum % 7 == 0 ) return 1 ; else return 0 ; }
function search ( $ arr , $ n , $ x ) { $ front = 0 ; $ back = $ n - 1 ; while ( $ front <= $ back ) { if ( $ arr [ $ front ] == $ x $ arr [ $ back ] == $ x ) return true ; $ front ++ ; $ back -- ; } return false ; }
function countNumbers ( $ x , $ n ) { if ( $ x > $ n ) return 0 ; return 1 + countNumbers ( $ x * 10 , $ n ) + countNumbers ( $ x * 10 + 1 , $ n ) ; }
function LastTwoDigit ( $ num ) { $ one = $ num % 10 ; $ num /= 10 ; $ tens = $ num % 10 ; $ tens *= 10 ; $ num = $ tens + $ one ; return $ num ; }
function checkOrigin ( $ x1 , $ y1 , $ x2 , $ y2 ) { return ( $ x1 * ( $ y2 - $ y1 ) == $ y1 * ( $ x2 - $ x1 ) ) ; }
function calculateSum ( $ n ) { $ a1 = 1 ; $ a2 = 2 ; $ r = 2 ; $ d = 1 ; return ( $ n ) * ( 2 * $ a1 + ( $ n - 1 ) * $ d ) / 2 + $ a2 * ( pow ( $ r , $ n ) - 1 ) / ( $ r - 1 ) ; }
function highestPowerof2 ( $ n ) { $ res = 0 ; for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { if ( ( $ i & ( $ i - 1 ) ) == 0 ) { $ res = $ i ; break ; } } return $ res ; }
function countDecreasing ( $ A , $ n ) { $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ A [ $ i + 1 ] < $ A [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; return $ cnt ; }
function divide ( $ n , $ m ) { echo " Remainder = " . ▁ ( ( $ n ) ▁ & ( $ m ▁ - ▁ 1 ) ) ; STRNEWLINE TABSYMBOL echo ▁ " Quotient = " }
function checkCollision ( $ a , $ b , $ c , $ x , $ y , $ radius ) { $ dist = ( abs ( $ a * $ x + $ b * $ y + $ c ) ) / sqrt ( $ a * $ a + $ b * $ b ) ; if ( $ radius == $ dist ) echo " Touch " ; else if ( $ radius > $ dist ) echo " Intersect " ; else echo " Outside " ; }
function nthTerm ( $ N ) { return ( ( 3 * $ N * $ N ) - ( 6 * $ N ) + 2 ) ; }
function solve ( $ s , $ k ) { $ count = 0 ; $ length = 0 ; $ pos = 0 ; $ m = array ( ) ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ m [ $ s [ $ i ] ] ++ ; $ length ++ ; if ( $ length > $ k ) { $ m [ $ s [ $ pos ++ ] ] -- ; $ length -- ; } if ( $ length == $ k && $ m [ $ s [ $ i ] ] == $ length ) $ count ++ ; } echo $ count . " STRNEWLINE " ; }
function sumofseries ( $ n ) { $ res = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ res += ( $ i ) * ( $ i + 1 ) * ( $ i + 2 ) ; return $ res ; }
function isPossible ( $ n , $ k , $ arr ) { $ sum = $ arr [ 0 ] ; $ maxVal = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ maxVal = max ( $ maxVal , $ arr [ $ i ] ) ; } if ( ( float ) $ maxVal > ( float ) ( $ sum + $ k ) / $ n ) return false ; return true ; }
function stirlingFactorial ( $ n ) { if ( $ n == 1 ) return 1 ; $ z ; $ e = 2.71 ; $ z = sqrt ( 2 * 3.14 * $ n ) * pow ( ( $ n / $ e ) , $ n ) ; return floor ( $ z ) ; }
function isPalindrome ( $ n ) { $ divisor = 1 ; while ( $ n / $ divisor >= 10 ) $ divisor *= 10 ; while ( $ n != 0 ) { $ leading = floor ( $ n / $ divisor ) ; $ trailing = $ n % 10 ; if ( $ leading != $ trailing ) return false ; $ n = ( $ n % $ divisor ) / 10 ; $ divisor = $ divisor / 100 ; } return true ; }
function toggle ( & $ n ) { $ temp = 1 ; while ( $ temp <= $ n ) { $ n = $ n ^ $ temp ; $ temp = $ temp << 1 ; } }
function dealnnoy ( $ n , $ m ) { $ dp [ $ m + 1 ] [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i ] [ $ j - 1 ] ; return $ dp [ $ m ] [ $ n ] ; }
function findVolume ( $ u , $ v , $ w , $ U , $ V , $ W , $ b ) { $ uPow = pow ( $ u , 2 ) ; $ vPow = pow ( $ v , 2 ) ; $ wPow = pow ( $ w , 2 ) ; $ UPow = pow ( $ U , 2 ) ; $ VPow = pow ( $ V , 2 ) ; $ WPow = pow ( $ W , 2 ) ; $ a = 4 * ( $ uPow * $ vPow * $ wPow ) - $ uPow * pow ( ( $ vPow + $ wPow - $ UPow ) , 2 ) - $ vPow * pow ( ( $ wPow + $ uPow - $ VPow ) , 2 ) - $ wPow * pow ( ( $ uPow + $ vPow - $ WPow ) , 2 ) + ( $ vPow + $ wPow - $ UPow ) * ( $ wPow + $ uPow - $ VPow ) * ( $ uPow + $ vPow - $ WPow ) ; $ vol = sqrt ( $ a ) ; $ vol /= $ b ; echo $ vol ; }
function distance ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) { $ d = sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) + pow ( $ z2 - $ z1 , 2 ) * 1.0 ) ; echo " Distance ▁ is ▁ " . $ d ; }
function printNthElement ( $ n ) { $ arr [ 1 ] = 4 ; $ arr [ 2 ] = 7 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 != 0 ) $ arr [ $ i ] = $ arr [ $ i / 2 ] * 10 + 4 ; else $ arr [ $ i ] = $ arr [ ( $ i / 2 ) - 1 ] * 10 + 7 ; } return $ arr [ $ n ] ; }
function calSum ( $ n ) { $ a = 3 ; $ b = 0 ; $ c = 2 ; return 3 ; return 3 ; return 5 ; $ sum = 5 ; while ( $ n > 2 ) { $ d = $ a + $ b ; $ sum += $ d ; $ a = $ b ; $ b = $ c ; $ c = $ d ; $ n -- ; } return $ sum ; }
function recLen ( & $ str , $ i ) { if ( $ i == strlen ( $ str ) ) return 0 ; else return 1 + recLen ( $ str , $ i + 1 ) ; }
function findNth ( $ N ) { $ b = 14 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { if ( $ i % 2 == 0 ) $ b = $ b * 2 ; else $ b = $ b - 8 ; } return $ b ; }
function geometricMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + log ( $ arr [ $ i ] ) ; $ sum = $ sum / $ n ; return exp ( $ sum ) ; }
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return " Yes " ; return " No " ; }
function subtractOne ( $ x ) { return ( ( $ x << 1 ) + ( ~ $ x ) ) ; }
function AvgofSquareN ( $ n ) { return ( ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; }
function countNumbers ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; return ( 9 * ( int ) pow ( 10 , $ n / 2 - 1 ) ) ; }
function printSubsets ( $ n ) { for ( $ i = $ n ; $ i > 0 ; $ i = ( $ i - 1 ) & $ n ) echo $ i . " " ; echo "0" ; }
function leftRotate ( $ arr , $ n , $ k ) { $ mod = $ k % $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ ( $ mod + $ i ) % $ n ] ) , " ▁ " ; echo " STRNEWLINE " ; }
function length_of_chord ( $ r , $ x ) { echo " The ▁ length ▁ of ▁ the ▁ chord " , " ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * $ r * sin ( $ x * ( 3.14 / 180 ) ) ; }
function printLeaders ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) { if ( $ arr [ $ i ] <= $ arr [ $ j ] ) break ; } if ( $ j == $ size ) echo ( $ arr [ $ i ] . " ▁ " ) ; } }
function sumOfAP ( $ a , $ d , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ a ; $ a = $ a + $ d ; } return $ sum ; }
function sum ( $ k , $ n ) { $ sum = pow ( $ k , $ n + 1 ) - pow ( $ k - 1 , $ n + 1 ) ; return $ sum ; }
function polygonArea ( $ X , $ Y , $ n ) { $ area = 0.0 ; $ j = $ n - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ area += ( $ X [ $ j ] + $ X [ $ i ] ) * ( $ Y [ $ j ] - $ Y [ $ i ] ) ; $ j = $ i ; } return abs ( $ area / 2.0 ) ; }
function countOccurrences ( $ str , $ word ) { $ a = explode ( " ▁ " , $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ a ) ; $ i ++ ) { if ( $ word == $ a [ $ i ] ) $ count ++ ; } return $ count ; }
function maxVol ( $ P , $ A ) { $ l = ( $ P - sqrt ( $ P * $ P - 24 * $ A ) ) / 12 ; $ V = $ l * ( $ A / 2.0 - $ l * ( $ P / 4.0 - $ l ) ) ; return $ V ; }
function rearrange ( & $ arr , $ n ) { $ temp = array ( ) ; $ small = 0 ; $ large = $ n - 1 ; $ flag = true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ flag ) $ temp [ $ i ] = $ arr [ $ large -- ] ; else $ temp [ $ i ] = $ arr [ $ small ++ ] ; $ flag = ! $ flag ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; }
function printXYZ ( $ n ) { if ( $ n == 1 ) echo - 1 ; else echo " x ▁ is ▁ " , $ n , " STRNEWLINE y ▁ is ▁ " , $ n + 1 , " STRNEWLINE z ▁ is ▁ " , $ n * ( $ n + 1 ) ; }
function check ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & 1 ) return true ; } return false ; }
function isOsiris ( $ n ) { $ a = $ n % 10 ; $ b = floor ( $ n / 10 ) % 10 ; $ c = floor ( $ n / 100 ) ; $ digit_sum = $ a + $ b + $ c ; if ( $ n == ( 2 * ( $ digit_sum ) * 11 ) ) { return true ; } return false ; }
function findMedian ( & $ a , $ n ) { sort ( $ a ) ; if ( $ n % 2 != 0 ) return ( double ) $ a [ $ n / 2 ] ; return ( double ) ( $ a [ ( $ n - 1 ) / 2 ] + $ a [ $ n / 2 ] ) / 2.0 ; }
function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; }
function numberOfSquares ( $ base ) { $ base = ( $ base - 2 ) ; $ base = intdiv ( $ base , 2 ) ; return $ base * ( $ base + 1 ) / 2 ; }
function centereddecagonalnum ( $ n ) { return ( 5 * $ n * $ n + 5 * $ n + 1 ) ; }
function replace ( $ s , $ c1 , $ c2 ) { $ l = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ s [ $ i ] == $ c1 ) $ s [ $ i ] = $ c2 ; else if ( $ s [ $ i ] == $ c2 ) $ s [ $ i ] = $ c1 ; } return $ s ; }
function printMaxActivities ( $ s , $ f , $ n ) { echo " Following ▁ activities ▁ are ▁ selected ▁ " . " STRNEWLINE " ; $ i = 0 ; echo $ i . " " ; for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ s [ $ j ] >= $ f [ $ i ] ) { echo $ j . " " ; $ i = $ j ; } } }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum = $ sum + $ i ; return $ sum ; }
function find_area ( $ r , $ d ) { $ R = $ d / PI ; $ R += pow ( $ r , 2 ) ; $ R = sqrt ( $ R ) ; $ area = PI * pow ( $ R , 2 ) ; return $ area ; }
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( " Pattern ▁ found ▁ at ▁ index ▁ $ i " . " STRNEWLINE " ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } }
function minRemoval ( $ str ) { $ hash = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ hash [ ord ( $ str [ $ i ] ) - 97 ] ++ ; $ count = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ hash [ $ i ] % 2 ) $ count ++ ; return ( $ count == 0 ) ? 0 : $ count - 1 ; }
function smallest_pair ( $ a , $ n ) { $ min = PHP_INT_MAX ; $ secondMin = PHP_INT_MAX ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ j ] < $ min ) { $ secondMin = $ min ; $ min = $ a [ $ j ] ; } else if ( ( $ a [ $ j ] < $ secondMin ) && $ a [ $ j ] != $ min ) $ secondMin = $ a [ $ j ] ; } return ( $ secondMin + $ min ) ; }
function doMatch ( $ A , $ B ) { for ( $ i = 0 ; $ i < strlen ( $ A ) ; $ i ++ ) if ( $ A [ $ i ] != ' * ' && $ B [ $ i ] != ' * ' ) if ( $ A [ $ i ] != $ B [ $ i ] ) return false ; return true ; }
function find ( $ start , $ adj , $ n , $ dp ) { if ( $ start == $ n ) return 0 ; if ( $ dp [ $ start ] != -1 ) return $ dp [ $ start ] ; $ dp [ $ start ] = 0 ; $ one = 0 ; $ zero = 0 ; for ( $ k = $ start ; $ k < $ n ; $ k ++ ) { if ( $ adj [ $ k ] == '1' ) $ one ++ ; else $ zero ++ ; if ( $ one > $ zero ) $ dp [ $ start ] = max ( $ dp [ $ start ] , find ( $ k + 1 , $ adj , $ n , $ dp ) + $ k - $ start + 1 ) ; else $ dp [ $ start ] = max ( $ dp [ $ start ] , find ( $ k + 1 , $ adj , $ n , $ dp ) ) ; } return $ dp [ $ start ] ; }
function findpos ( $ n ) { $ pos = 0 ; for ( $ i = 0 ; isset ( $ n [ $ i ] ) != NULL ; $ i ++ ) { switch ( $ n [ $ i ] ) { case '2' : $ pos = $ pos * 4 + 1 ; break ; case '3' : $ pos = $ pos * 4 + 2 ; break ; case '5' : $ pos = $ pos * 4 + 3 ; break ; case '7' : $ pos = $ pos * 4 + 4 ; break ; } } return $ pos ; }
function findWinner ( $ A , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res ^= $ A [ $ i ] ; if ( $ res == 0 or $ n % 2 == 0 ) return " Alice " ; else return " Bob " ; }
function maxAND ( $ L , $ R ) { if ( $ L == $ R ) return $ L ; else if ( ( $ R - $ L ) == 1 ) return ( $ R & $ L ) ; else { if ( ( ( $ R - 1 ) & $ R ) > ( ( $ R - 2 ) & ( $ R - 1 ) ) ) return ( ( $ R - 1 ) & $ R ) ; else return ( ( $ R - 2 ) & ( $ R - 1 ) ) ; } }
function isFibbinaryNum ( $ n ) { if ( ( $ n & ( $ n >> 1 ) ) == 0 ) return true ; return false ; }
function printTriplets ( $ arr , $ n , $ sum ) { sort ( $ arr , 0 ) ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { $ j = $ i + 1 ; $ k = $ n - 1 ; while ( $ j < $ k ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] >= $ sum ) $ k -- ; else { for ( $ x = $ j + 1 ; $ x <= $ k ; $ x ++ ) echo $ arr [ $ i ] . " , " ▁ . ▁ $ arr [ $ j ] ▁ . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL " , " ▁ . ▁ $ arr [ $ x ] ▁ . ▁ " " $ j ++ ; } } } }
function decToBinary ( $ n ) { $ binaryNum ; $ i = 0 ; while ( $ n > 0 ) { $ binaryNum [ $ i ] = $ n % 2 ; $ n = ( int ) ( $ n / 2 ) ; $ i ++ ; } for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) echo $ binaryNum [ $ j ] ; }
function LargestString ( $ na ) { $ N = sizeof ( $ na ) ; $ c = array_fill ( 0 , $ N , 0 ) ; $ m = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ character = array_fill ( 0 , 26 , false ) ; for ( $ k = 0 ; $ k < strlen ( $ na [ $ j ] ) ; $ k ++ ) { $ x = ord ( $ na [ $ j ] [ $ k ] ) - 65 ; if ( ( $ na [ $ j ] [ $ k ] != ' ▁ ' ) && ( $ character [ $ x ] == false ) ) { $ c [ $ j ] ++ ; $ character [ $ x ] = true ; } } if ( $ c [ $ j ] > $ c [ $ m ] ) $ m = $ j ; } echo $ na [ $ m ] . " STRNEWLINE " ; }
function minSteps ( $ str ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) - 2 ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) { if ( $ str [ $ i + 1 ] == '1' ) { if ( $ str [ $ i + 2 ] == '0' ) { $ count ++ ; $ i += 2 ; } } } } return $ count ; }
function sortExceptK ( & $ arr , $ k , $ n ) { $ t = $ arr [ $ k ] ; $ arr [ $ k ] = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ t ; $ t = $ arr [ count ( $ arr ) - 1 ] ; $ arr = array_slice ( $ arr , 0 , -1 ) ; sort ( $ arr ) ; array_push ( $ arr , $ t ) ; $ last = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 1 ; $ i > $ k ; $ i -- ) $ arr [ $ i ] = $ arr [ $ i - 1 ] ; $ arr [ $ k ] = $ last ; }
function isAutomorphic ( $ N ) { $ sq = $ N * $ N ; while ( $ N > 0 ) { if ( $ N % 10 != $ sq % 10 ) return -1 ; $ N /= 10 ; $ sq /= 10 ; } return 1 ; }
function center_hexadecagonal_num ( $ n ) { return 8 * $ n * $ n - 8 * $ n + 1 ; }
function nthTerm ( $ N ) { $ nth = 0 ; $ nth = ( $ N * $ N * ( $ N + 1 ) ) / 2 ; return $ nth ; }
function isInside ( $ circle_x , $ circle_y , $ rad , $ x , $ y ) { if ( ( $ x - $ circle_x ) * ( $ x - $ circle_x ) + ( $ y - $ circle_y ) * ( $ y - $ circle_y ) <= $ rad * $ rad ) return true ; else return false ; }
function avg_of_odd_num ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( 2 * $ i + 1 ) ; return $ sum / $ n ; }
function posOfRightMostDiffBit ( $ m , $ n ) { $ t = floor ( log ( $ m ^ $ n , 2 ) ) ; return $ t ; }
function steps ( $ source , $ step , $ dest ) { if ( abs ( $ source ) > ( $ dest ) ) return PHP_INT_MAX ; if ( $ source == $ dest ) return $ step ; $ pos = steps ( $ source + $ step + 1 , $ step + 1 , $ dest ) ; $ neg = steps ( $ source - $ step - 1 , $ step + 1 , $ dest ) ; return min ( $ pos , $ neg ) ; }
function calculateSum ( $ n ) { return ( $ n * ( 4 * $ n * $ n + 6 * $ n - 1 ) / 3 ) ; }
function isPath ( $ arr ) { global $ row , $ col ; $ arr [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ row ; $ i ++ ) if ( $ arr [ $ i ] [ 0 ] != -1 ) $ arr [ $ i ] [ 0 ] = $ arr [ $ i - 1 ] [ 0 ] ; for ( $ j = 1 ; $ j < $ col ; $ j ++ ) if ( $ arr [ 0 ] [ $ j ] != -1 ) $ arr [ 0 ] [ $ j ] = $ arr [ 0 ] [ $ j - 1 ] ; for ( $ i = 1 ; $ i < $ row ; $ i ++ ) for ( $ j = 1 ; $ j < $ col ; $ j ++ ) if ( $ arr [ $ i ] [ $ j ] != -1 ) $ arr [ $ i ] [ $ j ] = max ( $ arr [ $ i ] [ $ j - 1 ] , $ arr [ $ i - 1 ] [ $ j ] ) ; return ( $ arr [ $ row - 1 ] [ $ col - 1 ] == 1 ) ; }
function minimumSteps ( $ n , $ m , $ a , $ b ) { global $ MAXN ; if ( $ n > $ m ) return $ MAXN ; if ( $ n == $ m ) return 0 ; return min ( 1 + minimumSteps ( $ n * $ a , $ m , $ a , $ b ) , 1 + minimumSteps ( $ n * $ b , $ m , $ a , $ b ) ) ; }
function findUniquePair ( $ arr , $ n ) { $ XOR = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ XOR = $ XOR ^ $ arr [ $ i ] ; $ set_bit_no = $ XOR & ~ ( $ XOR - 1 ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo " The ▁ unique ▁ pair ▁ is ▁ " , " ( " , $ x , " ▁ " , $ y , " ) " ; }
function areacircumscribed ( $ a ) { global $ PI ; return ( $ a * $ a * ( $ PI / 2 ) ) ; }
function Div_by_8 ( $ n ) { return ( ( ( $ n >> 3 ) << 3 ) == $ n ) ; }
function digSum ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n == 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n = ( int ) $ n / 10 ; } return $ sum ; }
function countDigit ( $ n ) { $ temp = $ n ; $ sum = 0 ; $ product = 1 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp = ( int ) ( $ temp / 10 ) ; if ( $ d > 0 && $ n % $ d == 0 ) { $ sum += $ d ; $ product *= $ d ; } } echo " Sum = " . $ sum ; STRNEWLINE TABSYMBOL echo ▁ " Product = " }
function cosXSertiesSum ( $ x , $ n ) { global $ PI ; $ x = $ x * ( $ PI / 180.0 ) ; $ res = 1 ; $ sign = 1 ; $ fact = 1 ; $ pow = 1 ; for ( $ i = 1 ; $ i < 5 ; $ i ++ ) { $ sign = $ sign * -1 ; $ fact = $ fact * ( 2 * $ i - 1 ) * ( 2 * $ i ) ; $ pow = $ pow * $ x * $ x ; $ res = $ res + $ sign * $ pow / $ fact ; } return $ res ; }
function nthTerm ( $ n ) { return ( $ n * $ n ) + ( $ n * $ n * $ n ) ; }
function countDyckPaths ( $ n ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ res *= ( 2 * $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res / ( $ n + 1 ) ; }
function getSum ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ sum += ( $ i / pow ( $ a , $ i ) ) ; } return $ sum ; }
function maximumResult ( $ a , $ b , $ c ) { $ countOfNegative = 0 ; $ sum = $ a + $ b + $ c ; $ product = $ a * $ b * $ c ; $ largest = max ( $ a , $ b , $ c ) ; $ smallest = min ( $ a , $ b , $ c ) ; if ( $ a < 0 ) $ countOfNegative ++ ; if ( $ b < 0 ) $ countOfNegative ++ ; if ( $ c < 0 ) $ countOfNegative ++ ; switch ( $ countOfNegative ) { case 0 : return ( $ sum - $ largest ) * $ largest ; case 1 : return ( $ product / $ smallest ) + $ smallest ; case 2 : return ( $ product / $ largest ) + $ largest ; case 3 : return ( $ sum - $ smallest ) * $ smallest ; } }
function numberOfWays ( $ x ) { if ( $ x == 0 $ x == 1 ) return 1 ; else return numberOfWays ( $ x - 1 ) + ( $ x - 1 ) * numberOfWays ( $ x - 2 ) ; }
function otherNumber ( $ A , $ Lcm , $ Hcf ) { return ( $ Lcm * $ Hcf ) / $ A ; }
function findevenPair ( $ A , $ N ) { $ evenPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 == 0 ) $ evenPair ++ ; } } return $ evenPair ; }
function removeRecur ( $ n ) { $ prev_digit = $ n % 10 ; $ pow = 10 ; $ res = $ prev_digit ; while ( $ n ) { $ curr_digit = $ n % 10 ; if ( $ curr_digit != $ prev_digit ) { $ res += $ curr_digit * $ pow ; $ prev_digit = $ curr_digit ; $ pow *= 10 ; } $ n = $ n / 10 ; } return $ res ; }
function toggleBits ( $ n1 , $ n2 ) { return $ n1 ^ $ n2 ; }
function count1 ( $ n ) { if ( $ n < 3 ) return $ n ; if ( $ n >= 3 && $ n < 10 ) return $ n - 1 ; $ po = 1 ; for ( $ x = intval ( $ n / $ po ) ; $ x > 9 ; $ x = intval ( $ n / $ po ) ) $ po = $ po * 10 ; $ msd = intval ( $ n / $ po ) ; if ( $ msd != 3 ) return count1 ( $ msd ) * count1 ( $ po - 1 ) + count1 ( $ msd ) + count1 ( $ n % $ po ) ; else return count1 ( $ msd * $ po - 1 ) ; }
function submatrixXor ( $ arr ) { $ ans = 0 ; $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; if ( ( $ top_left % 2 == 1 ) && ( $ bottom_right % 2 == 1 ) ) $ ans = ( $ ans ^ $ arr [ $ i ] [ $ j ] ) ; } } return $ ans ; }
function findMaxRec ( $ A , $ n ) { if ( $ n == 1 ) return $ A [ 0 ] ; return max ( $ A [ $ n - 1 ] , findMaxRec ( $ A , $ n - 1 ) ) ; }
function answer_query ( $ a , $ n , $ l , $ r ) { $ count = 0 ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) if ( $ a [ $ i ] == $ a [ $ i + 1 ] ) $ count += 1 ; return $ count ; }
function sequence ( $ n ) { $ f = array ( 0 ) ; $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; $ f [ 2 ] = 1 ; echo $ f [ 1 ] , " " ▁ , ▁ $ f [ 2 ] ▁ , ▁ " " for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ f [ $ i ] = $ f [ $ f [ $ i - 1 ] ] + $ f [ $ i - $ f [ $ i - 1 ] ] ; echo $ f [ $ i ] , " " ; } } { $ n = 13 ; sequence ( $ n ) ; return 0 ; }
function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; if ( $ x == 0 ) return 0 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; y = $ y / 2 $ y = $ y >> 1 ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; }
function countStrings ( $ n , $ k ) { $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ k + 1 , array_fill ( 0 , 2 , 0 ) ) ) ; $ dp [ 1 ] [ 0 ] [ 0 ] = 1 ; $ dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( isset ( $ dp [ $ i ] [ $ j ] [ 0 ] ) || isset ( $ dp [ $ i ] [ $ j ] [ 1 ] ) ) { $ dp [ $ i ] [ $ j ] [ 0 ] = $ dp [ $ i - 1 ] [ $ j ] [ 0 ] + $ dp [ $ i - 1 ] [ $ j ] [ 1 ] ; $ dp [ $ i ] [ $ j ] [ 1 ] = $ dp [ $ i - 1 ] [ $ j ] [ 0 ] ; } if ( $ j - 1 >= 0 && isset ( $ dp [ $ i ] [ $ j ] [ 1 ] ) ) $ dp [ $ i ] [ $ j ] [ 1 ] += $ dp [ $ i - 1 ] [ $ j - 1 ] [ 1 ] ; } } return $ dp [ $ n ] [ $ k ] [ 0 ] + $ dp [ $ n ] [ $ k ] [ 1 ] ; }
function CalPeri ( $ s ) { $ Perimeter = 10 * $ s ; echo " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ $ Perimeter " ; }
function heptdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.802 * $ a ; return $ d ; }
function nobleInteger ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ arr [ $ i ] < $ arr [ $ j ] ) $ count ++ ; if ( $ count == $ arr [ $ i ] ) return $ arr [ $ i ] ; } return -1 ; }
function calculate_sum ( $ a , $ N ) { $ m = $ N / $ a ; $ sum = $ m * ( $ m + 1 ) / 2 ; $ ans = $ a * $ sum ; return $ ans ; }
function average ( $ arr , $ n , $ k ) { $ total = 0 ; if ( 2 * $ k >= $ n ) return 0 ; sort ( $ arr ) ; $ start = $ k ; $ end = $ n - $ k - 1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) $ total += $ arr [ $ i ] ; return ( $ total / ( $ n - 2 * $ k ) ) ; }
function totalSumDivisibleByNum ( $ digit , $ number ) { $ firstnum = pow ( 10 , $ digit - 1 ) ; $ lastnum = pow ( 10 , $ digit ) ; $ firstnum = ( $ firstnum - $ firstnum % $ number ) + $ number ; $ lastnum = ( $ lastnum - $ lastnum % $ number ) ; $ count = ( ( $ lastnum - $ firstnum ) / $ number + 1 ) ; return ( ( $ lastnum + $ firstnum ) * $ count ) / 2 ; }
function countNum ( $ arr , $ n ) { $ count = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] && $ arr [ $ i ] != $ arr [ $ i + 1 ] - 1 ) $ count += $ arr [ $ i + 1 ] - $ arr [ $ i ] - 1 ; return $ count ; }
function printMaxNumber ( $ n ) { if ( $ n & 1 ) { echo "7" ; for ( $ i = 0 ; $ i < ( $ n - 3 ) / 2 ; $ i ++ ) echo "1" ; } else { for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) echo "1" ; } }
function middleOfThree ( $ a , $ b , $ c ) { if ( ( $ a < $ b && $ b < $ c ) or ( $ c < $ b && $ b < $ a ) ) return $ b ; else if ( ( $ b < $ a and $ a < $ c ) or ( $ c < $ a and $ a < $ b ) ) return $ a ; else return $ c ; }
function findPairs ( $ arr1 , $ arr2 , $ n , $ m , $ x ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ arr1 [ $ i ] + $ arr2 [ $ j ] == $ x ) echo $ arr1 [ $ i ] . " ▁ " . $ arr2 [ $ j ] . " STRNEWLINE " ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; $ oddDigSum = 0 ; $ evenDigSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ oddDigSum += ( $ str [ $ i ] - '0' ) ; else $ evenDigSum += ( $ str [ $ i ] - '0' ) ; } return ( ( $ oddDigSum - $ evenDigSum ) % 11 == 0 ) ; }
function countPairs ( $ n ) { $ count = 0 ; for ( $ x = 1 ; $ x < $ n ; $ x ++ ) { for ( $ y = $ x + 1 ; $ y <= $ n ; $ y ++ ) { if ( ( $ y * $ x ) % ( $ y + $ x ) == 0 ) $ count ++ ; } } return $ count ; }
function maxBalancedStr ( $ s ) { $ open1 = 0 ; $ close1 = 0 ; $ open2 = 0 ; $ close2 = 0 ; $ open3 = 0 ; $ close3 = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { switch ( $ s [ $ i ] ) { case ' ( ' : $ open1 ++ ; break ; case ' ) ' : $ close1 ++ ; break ; case ' { ' : $ open2 ++ ; break ; case ' } ' : $ close2 ++ ; break ; case ' [ ' : $ open3 ++ ; break ; case ' ] ' : $ close3 ++ ; break ; } } $ maxLen = 2 * min ( $ open1 , $ close1 ) + 2 * min ( $ open2 , $ close2 ) + 2 * min ( $ open3 , $ close3 ) ; return $ maxLen ; } { $ s = " ) ) [ ] ] ( ( " ; echo ( maxBalancedStr ( $ s ) ) ; }
function findNthNonSquare ( $ n ) { $ x = $ n ; $ ans = $ x + floor ( 0.5 + sqrt ( $ x ) ) ; return ( int ) $ ans ; }
function printMedian ( $ arr , $ n , $ K ) { sort ( $ arr ) ; echo $ arr [ ( $ n + $ K ) / 2 ] ; }
function squareSum ( $ n ) { return $ n * ( 4 * $ n * $ n - 1 ) / 3 ; }
function solve_sum ( $ n ) { if ( $ n % 2 == 1 ) return ( $ n + 1 ) / 2 ; return - $ n / 2 ; }
function isDivisibleBy5 ( $ str ) { $ n = strlen ( $ str ) ; return ( ( ( $ str [ $ n - 1 ] - '0' ) == 0 ) || ( ( $ str [ $ n - 1 ] - '0' ) == 5 ) ) ; }
function checkcircle ( $ r , $ R , $ r1 , $ x1 , $ y1 ) { $ dis = sqrt ( $ x1 * $ x1 + $ y1 * $ y1 ) ; return ( $ dis - $ r1 >= $ R && $ dis + $ r1 <= $ r ) ; }
function Remainder ( $ str , $ R ) { $ len = strlen ( $ str ) ; $ Num = 0 ; $ Rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ Num = $ Rem * 10 + ( $ str [ $ i ] - '0' ) ; $ Rem = $ Num % $ R ; } return $ Rem ; }
function gcdMax ( $ a , $ b , $ n , $ N ) { $ cnt = array_fill ( 0 , $ N , 0 ) ; $ first = array_fill ( 0 , $ N , 0 ) ; $ second = array_fill ( 0 , $ N , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cnt [ $ a [ $ i ] ] = 1 ; for ( $ i = 1 ; $ i < $ N ; ++ $ i ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) if ( $ cnt [ $ j ] ) $ first [ $ i ] = max ( $ first [ $ i ] , $ j ) ; $ cnt = array_fill ( 0 , $ N , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cnt [ $ b [ $ i ] ] = 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) if ( $ cnt [ $ j ] ) $ second [ $ i ] = max ( $ second [ $ i ] , $ j ) ; $ x = $ N - 1 ; for ( ; $ x >= 0 ; $ x -- ) if ( $ first [ $ x ] && $ second [ $ x ] ) break ; echo $ first [ $ x ] . " ▁ " . $ second [ $ x ] . " STRNEWLINE " ; }
function findEletobeInserted ( $ A , $ n , $ k ) { $ ans = $ k ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ans ^= $ A [ $ i ] ; return $ ans ; }
function countPairs ( $ n ) { $ num = ( ( $ n / 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { $ val = ( ( $ n % $ i ) % $ j ) % $ n ; if ( $ val == $ max ) $ count ++ ; } } return $ count ; }
function printString ( $ str , $ n ) { $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] == '1' ) $ ones ++ ; $ used = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '2' && ! $ used ) { $ used = 1 ; for ( $ j = 0 ; $ j < $ ones ; $ j ++ ) echo "1" ; } if ( $ str [ $ i ] != '1' ) echo $ str [ $ i ] ; } if ( ! $ used ) for ( $ j = 0 ; $ j < $ ones ; $ j ++ ) echo "1" ; }
function getGreatestSum ( $ a ) { global $ N ; $ prev_max = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ prev_max < $ a [ $ N - 1 ] [ $ j ] ) $ prev_max = $ a [ $ N - 1 ] [ $ j ] ; $ sum = $ prev_max ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { $ curr_max = PHP_INT_MIN ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ prev_max > $ a [ $ i ] [ $ j ] and $ a [ $ i ] [ $ j ] > $ curr_max ) $ curr_max = $ a [ $ i ] [ $ j ] ; if ( $ curr_max == PHP_INT_MIN ) return -1 ; $ prev_max = $ curr_max ; $ sum += $ prev_max ; } return $ sum ; }
function coin ( $ totalRupees , $ X , $ Y , $ Z ) { $ one = 0 ; $ fifty = 0 ; $ twentyfive = 0 ; $ result = 0 ; $ total = 0 ; $ one = $ X * 1 ; $ fifty = ( ( $ Y * 1 ) / 2.0 ) ; $ twentyfive = ( ( $ Z * 1 ) / 4.0 ) ; $ total = $ one + $ fifty + $ twentyfive ; $ result = ( ( $ totalRupees ) / $ total ) ; return $ result ; }
function countSetBitsRec ( $ num ) { global $ num_to_bits ; $ nibble = 0 ; if ( 0 == $ num ) return $ num_to_bits [ 0 ] ; $ nibble = $ num & 0xf ; return $ num_to_bits [ $ nibble ] + countSetBitsRec ( $ num >> 4 ) ; }
function surfaceArea ( $ b , $ s ) { return 2 * $ b * $ s + pow ( $ b , 2 ) ; }
function findMaxAverage ( $ arr , $ n , $ k ) { if ( $ k > $ n ) return -1 ; $ sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ k ; $ i ++ ) $ sum += $ arr [ $ i ] ; $ max_sum = $ sum ; $ max_end = $ k - 1 ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ arr [ $ i ] - $ arr [ $ i - $ k ] ; if ( $ sum > $ max_sum ) { $ max_sum = $ sum ; $ max_end = $ i ; } } return $ max_end - $ k + 1 ; }
function findValue ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ ans = max ( $ ans , abs ( $ arr [ $ i ] - $ arr [ $ j ] ) + abs ( $ i - $ j ) ) ; return $ ans ; }
function getMinVal ( $ p , $ q ) { if ( $ q % $ p == 0 ) return $ p ; return -1 ; }
function checkSame ( $ n ) { $ set = 0 ; $ unset = 0 ; while ( $ n ) { if ( $ n & 1 ) $ set ++ ; else $ unset ++ ; $ n = $ n >> 1 ; } if ( $ set == $ unset ) return true ; else return false ; }
function countSort ( $ arr ) { global $ RANGE ; $ output = array ( strlen ( $ arr ) ) ; $ len = strlen ( $ arr ) ; $ count = array_fill ( 0 , $ RANGE + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) ++ $ count [ ord ( $ arr [ $ i ] ) ] ; for ( $ i = 1 ; $ i <= $ RANGE ; ++ $ i ) $ count [ $ i ] += $ count [ $ i - 1 ] ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { $ output [ $ count [ ord ( $ arr [ $ i ] ) ] - 1 ] = $ arr [ $ i ] ; -- $ count [ ord ( $ arr [ $ i ] ) ] ; } for ( $ i = 0 ; $ i < $ len ; ++ $ i ) $ arr [ $ i ] = $ output [ $ i ] ; return $ arr ; }
function ksmallest ( $ arr , $ n , $ k ) { sort ( $ arr ) ; if ( $ k < $ arr [ 0 ] ) return $ k ; if ( $ k == $ arr [ 0 ] ) return $ arr [ 0 ] + 1 ; if ( $ k > $ arr [ $ n - 1 ] ) return $ k + $ n ; if ( $ arr [ 0 ] == 1 ) $ k -- ; else $ k -= ( $ arr [ 0 ] - 1 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ c = $ arr [ $ i ] - $ arr [ $ i - 1 ] - 1 ; if ( $ k <= $ c ) return $ arr [ $ i - 1 ] + $ k ; else $ k -= $ c ; } return $ arr [ $ n - 1 ] + $ k ; }
function calculateProduct ( $ A , $ L , $ R , $ P ) { $ L = $ L - 1 ; $ R = $ R - 1 ; $ ans = 1 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { $ ans = $ ans * $ A [ $ i ] ; $ ans = $ ans % $ P ; } return $ ans ; }
function LucasSum ( $ N ) { $ sum = 0 ; $ a = 2 ; $ b = 1 ; $ c ; $ sum += $ a ; while ( $ b <= $ N ) { $ sum += $ b ; $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ sum ; }
function centeredTridecagonalNum ( $ n ) { return ( 13 * $ n * ( $ n - 1 ) + 2 ) / 2 ; }
function vol_tetra ( $ side ) { $ volume = ( pow ( $ side , 3 ) / ( 6 * sqrt ( 2 ) ) ) ; return $ volume ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 && $ n == 1 ) return false ; if ( $ n == 2 ) return ( ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( $ n == 3 ) return ( ( ( $ str [ $ n - 3 ] - '0' ) * 100 + ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 16 == 0 ) ; $ last = $ str [ $ n - 1 ] - '0' ; $ second_last = $ str [ $ n - 2 ] - '0' ; $ third_last = $ str [ $ n - 3 ] - '0' ; $ fourth_last = $ str [ $ n - 4 ] - '0' ; return ( ( $ fourth_last * 1000 + $ third_last * 100 + $ second_last * 10 + $ last ) % 16 == 0 ) ; }
function findS ( $ s ) { $ sum = 0 ; for ( $ n = 1 ; $ sum < $ s ; $ n ++ ) { $ sum += $ n ; if ( $ sum == $ s ) return $ n ; } return -1 ; }
function MaximumHeight ( $ a , $ n ) { $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ y = ( $ i * ( $ i + 1 ) ) / 2 ; if ( $ y < $ n ) $ result = $ i ; else break ; } return $ result ; }
function calculateSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( 1 << $ i ) ; } return $ sum ; }
function countNumbers ( $ n ) { return ( int ) ( $ n - $ n / 2 ) - ( int ) ( $ n / 3 ) - ( int ) ( $ n / 5 ) - ( int ) ( $ n / 7 ) + ( int ) ( $ n / 6 ) + ( int ) ( $ n / 10 ) + ( int ) ( $ n / 14 ) + ( int ) ( $ n / 15 ) + ( int ) ( $ n / 21 ) + ( int ) ( $ n / 35 ) - ( int ) ( $ n / 30 ) - ( int ) ( $ n / 42 ) - ( int ) ( $ n / 70 ) - ( int ) ( $ n / 105 ) + ( int ) ( $ n / 210 ) ; }
function lengtang ( $ r1 , $ r2 ) { echo " The ▁ length ▁ of ▁ the ▁ " , " direct ▁ common ▁ tangent ▁ is ▁ " , 2 * sqrt ( $ r1 * $ r2 ) ; }
function isEven ( $ n ) { $ isEven = true ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ isEven = ! $ isEven ; return $ isEven ; }
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) echo " Pattern ▁ found ▁ at ▁ index ▁ " , $ i . " STRNEWLINE " ; } }
function isIdentity ( $ mat , $ N ) { for ( $ row = 0 ; $ row < $ N ; $ row ++ ) { for ( $ col = 0 ; $ col < $ N ; $ col ++ ) { if ( $ row == $ col and $ mat [ $ row ] [ $ col ] != 1 ) return false ; else if ( $ row != $ col && $ mat [ $ row ] [ $ col ] != 0 ) return false ; } } return true ; }
function distance ( $ a1 , $ b1 , $ c1 , $ d1 , $ a2 , $ b2 , $ c2 , $ d2 ) { if ( $ a1 / $ a2 == $ b1 / $ b2 && $ b1 / $ b2 == $ c1 / $ c2 ) { $ x1 = $ y1 = 0 ; $ z1 = - $ d1 / $ c1 ; $ d = abs ( ( $ c2 * $ z1 + $ d2 ) ) / ( sqrt ( $ a2 * $ a2 + $ b2 * $ b2 + $ c2 * $ c2 ) ) ; echo " Perpendicular ▁ distance ▁ is ▁ " , $ d ; } else echo " Planes ▁ are ▁ not ▁ parallel " ; }
function maxCost ( $ mat , $ N ) { $ dp = array ( array ( ) ) ; memset ( dp , 0 , sizeof ( dp ) ) ; $ dp [ 0 ] [ 0 ] = $ mat [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ mat [ $ i ] [ 0 ] + $ dp [ $ i - 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j < $ i + 1 && $ j < $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } $ result = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ result < $ dp [ $ N - 1 ] [ $ i ] ) $ result = $ dp [ $ N - 1 ] [ $ i ] ; return $ result ; }
function printFourSquares ( $ a ) { for ( $ i = 0 ; $ i * $ i <= $ a ; $ i ++ ) { for ( $ j = $ i ; $ j * $ j <= $ a ; $ j ++ ) { for ( $ k = $ j ; $ k * $ k <= $ a ; $ k ++ ) { for ( $ l = $ k ; $ l * $ l <= $ a ; $ l ++ ) { if ( $ i * $ i + $ j * $ j + $ k * $ k + $ l * $ l == $ a ) { echo $ a , " = " ▁ , ▁ $ i ▁ , ▁ " * " ▁ , $ i , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL " + " ▁ , ▁ $ j ▁ , ▁ " * " ▁ , ▁ $ j ▁ , ▁ " + " echo $ k , " * " ▁ , ▁ $ k ▁ , ▁ " + " $ l , " * " , $ l , " STRNEWLINE " ; } } } } } }
function calcSafe ( $ pos ) { $ j = $ pos % 10 ; $ i = $ pos / 10 ; $ dis_11 = min ( abs ( 1 - $ i ) , abs ( 1 - $ j ) ) ; $ dis_18 = min ( abs ( 1 - $ i ) , abs ( 8 - $ j ) ) ; $ dis_81 = min ( abs ( 8 - $ i ) , abs ( 1 - $ j ) ) ; $ dis_88 = min ( abs ( 8 - $ i ) , abs ( 8 - $ j ) ) ; $ sum = $ dis_11 + $ dis_18 + $ dis_81 + $ dis_88 + 1 ; return ceil ( 64 - $ sum ) ; }
function fitOrNotFit ( $ R , $ r , $ x , $ y , $ rad ) { $ val = sqrt ( pow ( $ x , 2 ) + pow ( $ y , 2 ) ) ; if ( $ val + $ rad <= $ R && $ val - $ rad >= $ R - $ r ) echo " Fits STRNEWLINE " ; else echo " Doesn ' t ▁ Fit STRNEWLINE " ; }
function sumOfDigitsFrom1ToN ( $ n ) { if ( $ n < 10 ) return ( $ n * ( $ n + 1 ) / 2 ) ; $ d = ( int ) ( log10 ( $ n ) ) ; $ a [ $ d + 1 ] = array ( ) ; $ a [ 0 ] = 0 ; $ a [ 1 ] = 45 ; for ( $ i = 2 ; $ i <= $ d ; $ i ++ ) $ a [ $ i ] = $ a [ $ i - 1 ] * 10 + 45 * ( int ) ( ceil ( pow ( 10 , $ i - 1 ) ) ) ; $ p = ( int ) ( ceil ( pow ( 10 , $ d ) ) ) ; $ msd = ( int ) ( $ n / $ p ) ; return ( $ msd * $ a [ $ d ] + ( $ msd * ( int ) ( $ msd - 1 ) / 2 ) * $ p + $ msd * ( 1 + $ n % $ p ) + sumOfDigitsFrom1ToN ( $ n % $ p ) ) ; }
function trianglearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ area = ( 3 * sqrt ( 3 ) * pow ( $ a , 2 ) ) / ( 4 * $ b ) ; return $ area ; }
function exponentMod ( $ A , $ B , $ C ) { if ( $ A == 0 ) return 0 ; if ( $ B == 0 ) return 1 ; if ( $ B % 2 == 0 ) { $ y = exponentMod ( $ A , $ B / 2 , $ C ) ; $ y = ( $ y * $ y ) % $ C ; } else { $ y = $ A % $ C ; $ y = ( $ y * exponentMod ( $ A , $ B - 1 , $ C ) % $ C ) % $ C ; } return ( ( $ y + $ C ) % $ C ) ; }
function lastCoordinate ( $ n , $ a , $ b ) { return ( ( $ n + 1 ) / 2 ) * $ a - ( int ) ( $ n / 2 ) * $ b ; }
function maxAbsDiff ( $ arr , $ n ) { $ minEle = $ arr [ 0 ] ; $ maxEle = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ minEle = min ( $ minEle , $ arr [ $ i ] ) ; $ maxEle = max ( $ maxEle , $ arr [ $ i ] ) ; } return ( $ maxEle - $ minEle ) ; }
function largestCube ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( float ) ( ( 2 * $ r ) / sqrt ( 3 ) ) ; return $ a ; }
function checkPowerof8 ( $ n ) { $ i = log ( $ n ) / log ( 8 ) ; return ( $ i - floor ( $ i ) < 0.000001 ) ; }
function getInvCount ( & $ arr , $ n ) { $ inv_count = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ inv_count ++ ; return $ inv_count ; }
function onlyFirstAndLastAreSet ( $ n ) { if ( $ n == 1 ) return true ; if ( $ n == 2 ) return false ; return ( ( ( $ n - 1 ) & ( $ n - 2 ) ) == 0 ) ; }
function getMinCost ( $ n , $ m ) { $ cost = ( $ n - 1 ) * $ m + ( $ m - 1 ) * $ n ; return $ cost ; }
function minimum ( $ n ) { $ product = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) $ n = $ n / $ i ; $ product = $ product * $ i ; } } if ( $ n >= 2 ) $ product = $ product * $ n ; return $ product ; }
function minAbsDiff ( $ n ) { $ mod = $ n % 4 ; if ( $ mod == 0 $ mod == 3 ) return 0 ; return 1 ; }
function centeredTetrahedralNumber ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 3 ) / 3 ; }
function countPairs ( $ A , $ n , $ k ) { $ ans = 0 ; sort ( $ A ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ x = 0 ; while ( ( $ A [ $ i ] * pow ( $ k , $ x ) ) <= $ A [ $ j ] ) { if ( ( $ A [ $ i ] * pow ( $ k , $ x ) ) == $ A [ $ j ] ) { $ ans ++ ; break ; } $ x ++ ; } } } return $ ans ; }
function countLattice ( $ r ) { if ( $ r <= 0 ) return 0 ; $ result = 4 ; for ( $ x = 1 ; $ x < $ r ; $ x ++ ) { $ ySquare = $ r * $ r - $ x * $ x ; $ y = ceil ( sqrt ( $ ySquare ) ) ; if ( $ y * $ y == $ ySquare ) $ result += 4 ; } return $ result ; }
function largestGCDSubsequence ( $ arr , $ n ) { $ ans = 0 ; $ maxele = max ( $ arr ) ; for ( $ i = 2 ; $ i <= $ maxele ; ++ $ i ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { if ( $ arr [ $ j ] % $ i == 0 ) ++ $ count ; } $ ans = max ( $ ans , $ count ) ; } return $ ans ; }
function countNums ( $ n , $ x , $ y ) { $ arr = array_fill ( 0 , $ n + 1 , false ) ; if ( $ x <= $ n ) $ arr [ $ x ] = true ; if ( $ y <= $ n ) $ arr [ $ y ] = true ; $ result = 0 ; for ( $ i = min ( $ x , $ y ) ; $ i <= $ n ; $ i ++ ) { if ( $ arr [ $ i ] ) { if ( $ i + $ x <= $ n ) $ arr [ $ i + $ x ] = true ; if ( $ i + $ y <= $ n ) $ arr [ $ i + $ y ] = true ; $ result ++ ; } } return $ result ; }
function generateSequence ( $ n , $ g ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ i * $ g . " ▁ " ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 ) return false ; if ( $ n == 1 ) return ( ( $ str [ 0 ] - '0' ) % 8 == 0 ) ; if ( $ n == 2 ) return ( ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 8 == 0 ) ; $ last = $ str [ $ n - 1 ] - '0' ; $ second_last = $ str [ $ n - 2 ] - '0' ; $ third_last = $ str [ $ n - 3 ] - '0' ; return ( ( $ third_last * 100 + $ second_last * 10 + $ last ) % 8 == 0 ) ; }
function sum ( $ x , $ y , $ n ) { $ sum1 = ( pow ( $ x , 2 ) * ( pow ( $ x , 2 * $ n ) - 1 ) ) / ( pow ( $ x , 2 ) - 1 ) ; $ sum2 = ( $ x * $ y * ( pow ( $ x , $ n ) * pow ( $ y , $ n ) - 1 ) ) / ( $ x * $ y - 1 ) ; return $ sum1 + $ sum2 ; }
function countRotations ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; $ min_index ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ min > $ arr [ $ i ] ) { $ min = $ arr [ $ i ] ; $ min_index = $ i ; } } return $ min_index ; }
function check ( $ N , $ D ) { $ temp = ( $ N * ( $ N + 1 ) ) / 2 + $ D ; return ( $ temp % 2 == 0 ) ; }
function sumofsquare ( $ n ) { $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ C [ $ n ] [ $ i ] * $ C [ $ n ] [ $ i ] ) ; return $ sum ; }
function getInvCount ( $ arr , $ n ) { $ invcount = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ small = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ small ++ ; $ great = 0 ; for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) if ( $ arr [ $ i ] < $ arr [ $ j ] ) $ great ++ ; $ invcount += $ great * $ small ; } return $ invcount ; }
function isEven ( $ n ) { return ( ( int ) ( $ n / 2 ) * 2 == $ n ) ; }
function divide ( $ dividend , $ divisor ) { $ sign = ( ( $ dividend < 0 ) ^ ( $ divisor < 0 ) ) ? -1 : 1 ; $ dividend = abs ( $ dividend ) ; $ divisor = abs ( $ divisor ) ; $ quotient = 0 ; $ temp = 0 ; for ( $ i = 31 ; $ i >= 0 ; -- $ i ) { if ( $ temp + ( $ divisor << $ i ) <= $ dividend ) { $ temp += $ divisor << $ i ; $ quotient |= ( double ) ( 1 ) << $ i ; } } if ( $ sign == -1 ) $ quotient = - $ quotient ; return $ quotient ; }
function sumBitDifferences ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) ) $ count ++ ; $ ans += ( $ count * ( $ n - $ count ) * 2 ) ; } return $ ans ; }
function nthElement ( $ a , $ b , $ n ) { $ seq = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) array_push ( $ seq , $ a * $ i ) ; sort ( $ seq ) ; for ( $ i = 1 , $ k = $ n ; $ i <= $ n && $ k > 0 ; $ i ++ ) { if ( array_search ( $ b * $ i , $ seq ) == 0 ) { array_push ( $ seq , $ b * $ i ) ; sort ( $ seq ) ; $ k -- ; } } return $ seq [ $ n - 1 ] ; }
function countAnomalies ( & $ arr , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= $ k ) break ; if ( $ j == $ n ) $ res ++ ; } return $ res ; }
function sumOddFibonacci ( $ n ) { global $ mod ; $ Sum [ $ n + 1 ] = array ( ) ; $ Sum [ 0 ] = 0 ; $ Sum [ 1 ] = 1 ; $ Sum [ 2 ] = 2 ; $ Sum [ 3 ] = 5 ; $ Sum [ 4 ] = 10 ; $ Sum [ 5 ] = 23 ; for ( $ i = 6 ; $ i <= $ n ; $ i ++ ) { $ Sum [ $ i ] = ( ( $ Sum [ $ i - 1 ] + ( 4 * $ Sum [ $ i - 2 ] ) % $ mod - ( 4 * $ Sum [ $ i - 3 ] ) % $ mod + $ mod ) % $ mod + ( $ Sum [ $ i - 4 ] - $ Sum [ $ i - 5 ] + $ mod ) % $ mod ) % $ mod ; } return $ Sum [ $ n ] ; }
function calcNodes ( $ N , $ I ) { $ result = 0 ; $ result = $ I * ( $ N - 1 ) + 1 ; return $ result ; }
function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; }
function findMaxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ prefix_sum = $ arr [ $ i ] ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ prefix_sum += $ arr [ $ j ] ; $ suffix_sum = $ arr [ $ i ] ; for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) $ suffix_sum += $ arr [ $ j ] ; if ( $ prefix_sum == $ suffix_sum ) $ res = max ( $ res , $ prefix_sum ) ; } return $ res ; }
function countValues ( $ n ) { $ countV = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( ( $ n + $ i ) == ( $ n ^ $ i ) ) $ countV ++ ; return $ countV ; }
function countBuildings ( $ arr , $ n ) { $ count = 1 ; $ curr_max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ curr_max $ arr [ $ i ] == $ curr_max ) { $ count ++ ; $ curr_max = $ arr [ $ i ] ; } } return $ count ; }
function noOfYears ( $ t1 , $ n1 , $ t2 ) { $ years = ( ( $ t2 - 1 ) * $ n1 / ( $ t1 - 1 ) ) ; return $ years ; }
function countAnomalies ( $ arr , $ n , $ k ) { $ cnt = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( abs ( $ arr [ $ i ] - ( $ sum - $ arr [ $ i ] ) ) > $ k ) $ cnt ++ ; return $ cnt ; }
function minOperation ( & $ arr ) { global $ N , $ M ; $ ans = 0 ; for ( $ i = $ N - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ M - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] [ $ j ] == 0 ) { $ ans ++ ; for ( $ k = 0 ; $ k <= $ i ; $ k ++ ) { for ( $ h = 0 ; $ h <= $ j ; $ h ++ ) { if ( $ arr [ $ k ] [ $ h ] == 1 ) $ arr [ $ k ] [ $ h ] = 0 ; else $ arr [ $ k ] [ $ h ] = 1 ; } } } } } return $ ans ; }
function printTriplets ( & $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] < $ sum ) { echo ( $ arr [ $ i ] ) ; echo ( " , ▁ " ) ; echo ( $ arr [ $ j ] ) ; echo ( " , ▁ " ) ; echo ( $ arr [ $ k ] ) ; echo ( " STRNEWLINE " ) ; } } } }
function findLongestRepeatingSubSeq ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ str [ $ i - 1 ] == $ str [ $ j - 1 ] && $ i != $ j ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } } return $ dp [ $ n ] [ $ n ] ; }
function find ( $ n ) { $ b = $ n ; $ a = $ b * ( $ n - 1 ) ; if ( $ a * $ b > $ n && $ a / $ b < $ n ) { echo " a = " ▁ , ▁ $ a ▁ , ▁ " , b = " } else echo - 1 ; }
function findWaysToPair ( $ p ) { $ dp = array ( ) ; $ dp [ 1 ] = 1 ; $ dp [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ p ; $ i ++ ) { $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; } return $ dp [ $ p ] ; }
function printCombination ( $ n ) { echo "1 ▁ " ; if ( ( $ n - 2 ) % 3 == 0 ) echo "2 ▁ " . ( $ n - 3 ) ; else echo "1 ▁ " . ( $ n - 2 ) ; }
function countSteps ( $ x , $ y ) { if ( $ x < $ y ) { return $ x + $ y + 2 * ( ( $ y - $ x ) / 2 ) ; } else { return $ x + $ y + 2 * ( ( ( $ x - $ y ) + 1 ) / 2 ) ; } }
function minMovesToSort ( $ arr , $ n ) { $ moves = 0 ; $ mn = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] > $ mn ) $ moves += $ arr [ $ i ] - $ mn ; } return $ moves ; }
function MinOperation ( $ a , $ n , $ k ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ a [ $ i ] != 1 && $ a [ $ i ] > $ k ) { $ result = $ result + min ( $ a [ $ i ] % $ k , $ k - $ a [ $ i ] % $ k ) ; } else { $ result = $ result + $ k - $ a [ $ i ] ; } } return $ result ; }
function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; sort ( $ arr ) ; $ x = $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] * $ arr [ $ n - 3 ] * $ arr [ $ n - 4 ] ; $ y = $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ 2 ] * $ arr [ 3 ] ; $ z = $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] ; return max ( $ x , max ( $ y , $ z ) ) ; }
function minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) { sort ( $ arr1 ) ; sort ( $ arr2 ) ; return $ arr1 [ $ n1 - 1 ] * $ arr2 [ 0 ] ; }
function printThreeParts ( $ N ) { if ( $ N % 3 == 0 ) echo " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " . ( $ N - 2 ) . " STRNEWLINE " ; else echo " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " . ( $ N - 3 ) . " STRNEWLINE " ; }
function getTotalXorOfSubarrayXors ( $ arr , $ N ) { if ( $ N % 2 == 0 ) return 0 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i += 2 ) $ res ^= $ arr [ $ i ] ; return $ res ; }
function calculateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = $ fibo [ 0 ] + $ fibo [ 1 ] ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; $ sum += $ fibo [ $ i ] ; } return $ sum ; }
function maxSum ( $ n ) { if ( $ n == 1 ) return 1 ; else return ( $ n * ( $ n - 1 ) / 2 ) - 1 + $ n / 2 ; }
function isWoodall ( $ x ) { if ( $ x % 2 == 0 ) return false ; if ( $ x == 1 ) return true ; $ x ++ ; $ p = 0 ; while ( $ x % 2 == 0 ) { $ x = $ x / 2 ; $ p ++ ; if ( $ p == $ x ) return true ; } return false ; }
function printLines ( $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo ( $ k * ( 6 * $ i + 1 ) ) ; echo ( " ▁ " ) ; echo ( $ k * ( 6 * $ i + 2 ) ) ; echo ( " ▁ " ) ; echo ( $ k * ( 6 * $ i + 3 ) ) ; echo ( " ▁ " ) ; echo ( $ k * ( 6 * $ i + 5 ) ) ; echo ( " STRNEWLINE " ) ; } }
function snoob ( $ x ) { $ next = 0 ; if ( $ x ) { $ rightOne = $ x & - $ x ; $ nextHigherOneBit = $ x + $ rightOne ; $ rightOnesPattern = $ x ^ $ nextHigherOneBit ; $ rightOnesPattern = intval ( ( $ rightOnesPattern ) / $ rightOne ) ; $ rightOnesPattern >>= 2 ; $ next = $ nextHigherOneBit | $ rightOnesPattern ; } return $ next ; }
function isPower ( $ x , $ y ) { $ res1 = log ( $ y ) / log ( $ x ) ; $ res2 = log ( $ y ) / log ( $ x ) ; return ( $ res1 == $ res2 ) ; }
function shortdis ( $ r , $ d ) { echo " The ▁ shortest ▁ distance ▁ " ; echo " from ▁ the ▁ chord ▁ to ▁ centre ▁ " ; echo sqrt ( ( $ r * $ r ) - ( ( $ d * $ d ) / 4 ) ) ; }
function countSetBits ( $ n ) { if ( $ n == 0 ) return 0 ; else return 1 + countSetBits ( $ n & ( $ n - 1 ) ) ; }
function remAnagram ( $ str1 , $ str2 ) { $ count1 = array ( 26 ) ; $ count2 = array ( 26 ) ; for ( $ i = 0 ; $ i < strlen ( $ str1 ) ; $ i ++ ) $ count1 [ $ str1 [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < strlen ( $ str2 ) ; $ i ++ ) $ count2 [ $ str2 [ $ i ] - ' a ' ] ++ ; $ result = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ result += abs ( $ count1 [ $ i ] - $ count2 [ $ i ] ) ; return $ result ; } { $ str1 = " bcadeh " ; $ str2 = " hea " ; echo ( remAnagram ( $ str1 , $ str2 ) ) ; }
function squarearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = 4 * ( pow ( $ r , 2 ) / 5 ) ; return $ a ; }
function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; }
function findLargestDivisor ( $ n ) { for ( $ i = 2 ; $ i < sqrt ( $ n ) + 1 ; $ i ++ ) { while ( $ n % ( $ i * $ i ) == 0 ) { $ n = $ n / $ i ; } } return $ n ; }
function countIntegralSolutions ( $ n ) { return ( ( $ n + 1 ) * ( $ n + 2 ) ) / 2 ; }
function countt ( $ n ) { $ dp [ $ n + 1 ] = 0 ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i >= 1 && $ i <= 3 ) $ dp [ $ i ] = 1 ; else if ( $ i == 4 ) $ dp [ $ i ] = 2 ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 4 ] ; } return $ dp [ $ n ] ; }
function maxDP ( $ n ) { $ res [ 0 ] = 0 ; $ res [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = max ( $ i , ( $ res [ $ i / 2 ] + $ res [ $ i / 3 ] + $ res [ $ i / 4 ] + $ res [ $ i / 5 ] ) ) ; return $ res [ $ n ] ; }
function findSum ( $ n ) { return ( $ n * ( pow ( $ n , 2 ) + 3 * $ n + 5 ) ) / 3 ; }
function Series ( $ n ) { $ i ; $ sums = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sums += ( $ i * $ i ) ; return $ sums ; }
function setallbitgivenrange ( $ n , $ l , $ r ) { $ range = ( ( ( 1 << ( $ l - 1 ) ) - 1 ) ^ ( ( 1 << ( $ r ) ) - 1 ) ) ; return ( $ n $ range ) ; }
function isPanalphabeticWindow ( $ s , $ n ) { $ ch = ' a ' ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) $ ch ++ ; if ( $ ch == ' z ' ) return true ; } return false ; }
function computeXOR ( $ n ) { $ x = $ n & 3 ; switch ( $ x ) { case 0 : return $ n ; case 1 : return 1 ; case 2 : return $ n + 1 ; case 3 : return 0 ; } return 0 ; }
function ceilSearch ( $ arr , $ low , $ high , $ x ) { $ mid ; if ( $ x <= $ arr [ $ low ] ) return $ low ; if ( $ x > $ arr [ $ high ] ) return -1 ; $ mid = ( $ low + $ high ) / 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; else if ( $ arr [ $ mid ] < $ x ) { if ( $ mid + 1 <= $ high && $ x <= $ arr [ $ mid + 1 ] ) return $ mid + 1 ; else return ceilSearch ( $ arr , $ mid + 1 , $ high , $ x ) ; } else { if ( $ mid - 1 >= $ low && $ x > $ arr [ $ mid - 1 ] ) return $ mid ; else return ceilSearch ( $ arr , $ low , $ mid - 1 , $ x ) ; } }
function maxTripletSum ( $ arr , $ n ) { $ sum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ sum < $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ) $ sum = $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ; return $ sum ; }
function solve ( $ M , $ N , $ s ) { $ ans = ( ( int ) ( ceil ( $ M / $ s ) ) * ( int ) ( ceil ( $ N / $ s ) ) ) ; return $ ans ; }
function gcd ( $ a , $ b ) { if ( $ a == 0 && $ b == 0 ) return 0 ; if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; }
function polygonArea ( $ X , $ Y , $ n ) { $ area = 0.0 ; $ j = $ n - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ area += ( $ X [ $ j ] + $ X [ $ i ] ) * ( $ Y [ $ j ] - $ Y [ $ i ] ) ; $ j = $ i ; } return abs ( $ area / 2.0 ) ; }
function findNature ( $ a , $ b , $ n ) { global $ MAX ; $ seq = array_fill ( 0 , $ MAX , 0 ) ; $ seq [ 0 ] = $ a ; $ seq [ 1 ] = $ b ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ seq [ $ i ] = $ seq [ $ i - 1 ] + $ seq [ $ i - 2 ] ; return ( $ seq [ $ n ] & 1 ) ; }
function asciiToSentence ( $ string , $ length ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ num = $ num * 10 + ( ord ( $ string [ $ i ] ) - ord ( '0' ) ) ; if ( $ num >= 32 && $ num <= 122 ) { $ ch = chr ( $ num ) ; print ( $ ch ) ; $ num = 0 ; } } }
function countMultiples ( $ n ) { return floor ( $ n / 3 + $ n / 7 - $ n / 21 ) ; }
function findMinRec ( $ A , $ n ) { if ( $ n == 1 ) return $ A [ 0 ] ; return min ( $ A [ $ n - 1 ] , findMinRec ( $ A , $ n - 1 ) ) ; }
function isSumEqual ( $ ar , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ sum += $ ar [ $ i ] ; if ( $ sum == $ ar [ $ n - 1 ] ) return true ; return false ; }
function maxFreq ( $ s , $ a , $ b ) { $ fre = array_fill ( 0 , 10 , 0 ) ; $ n = strlen ( $ s ) ; if ( $ a > $ b ) { $ xx = $ a ; $ a = $ b ; $ b = $ xx ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = ord ( $ s [ $ i ] ) - ord ( '0' ) ; $ fre [ $ a ] += 1 ; } if ( $ fre [ $ a ] == 0 and $ fre [ $ b ] == 0 ) return -1 ; else if ( $ fre [ $ a ] >= $ fre [ $ b ] ) return $ a ; else return $ b ; }
function extrema ( $ a , $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ count += ( $ a [ $ i ] > $ a [ $ i - 1 ] and $ a [ $ i ] > $ a [ $ i + 1 ] ) ; $ count += ( $ a [ $ i ] < $ a [ $ i - 1 ] and $ a [ $ i ] < $ a [ $ i + 1 ] ) ; } return $ count ; }
function digit_product_Sum ( $ N ) { $ a = array_fill ( 0 , $ N , 0 ) ; $ product = 1 ; $ a [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ product = ( int ) ( $ a [ $ i - 1 ] / 10 ) ; if ( $ product == 0 ) $ product = 1 ; else $ product = $ a [ $ i - 1 ] % 10 ; $ val = ( int ) ( $ a [ $ i - 1 ] / 10 ) ; if ( $ val == 0 ) $ val = $ a [ $ i - 1 ] ; $ a [ $ i ] = $ a [ $ i - 1 ] + ( $ val * $ product ) ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) echo $ a [ $ i ] . " ▁ " ; }
function colMaxDiff ( $ mat ) { $ N = 5 ; $ max_diff = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ max_val = $ mat [ 0 ] [ $ i ] ; $ min_val = $ mat [ 0 ] [ $ i ] ; for ( $ j = 1 ; $ j < $ N ; $ j ++ ) { $ max_val = max ( $ max_val , $ mat [ $ j ] [ $ i ] ) ; $ min_val = min ( $ min_val , $ mat [ $ j ] [ $ i ] ) ; } $ max_diff = max ( $ max_diff , $ max_val - $ min_val ) ; } return $ max_diff ; }
function percent ( $ a , $ b ) { $ result = 0 ; $ result = ( ( $ b - $ a ) * 100 ) / $ a ; return $ result ; }
function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : $ n * factorial ( $ n - 1 ) ; }
function vol_of_dodecahedron ( $ side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( $ side , 3 ) ) ) ; }
function minCoins ( $ coins , $ m , $ V ) { if ( $ V == 0 ) return 0 ; $ res = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ coins [ $ i ] <= $ V ) { $ sub_res = minCoins ( $ coins , $ m , $ V - $ coins [ $ i ] ) ; if ( $ sub_res != PHP_INT_MAX && $ sub_res + 1 < $ res ) $ res = $ sub_res + 1 ; } } return $ res ; }
function checkSolution ( $ a , $ b , $ c ) { if ( ( ( $ b * $ b ) - ( 4 * $ a * $ c ) ) > 0 ) echo "2 ▁ solutions " ; else if ( ( ( $ b * $ b ) - ( 4 * $ a * $ c ) ) == 0 ) echo "1 ▁ solution " ; else echo " No ▁ solutions " ; }
function modInverse ( $ a , $ m ) { for ( $ x = 1 ; $ x < $ m ; $ x ++ ) if ( ( ( $ a % $ m ) * ( $ x % $ m ) ) % $ m == 1 ) return $ x ; }
function getCount ( $ arr , $ n , $ num1 , $ num2 ) { $ i = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ num1 ) break ; if ( $ i >= $ n - 1 ) return 0 ; $ j ; for ( $ j = $ n - 1 ; $ j >= $ i + 1 ; $ j -- ) if ( $ arr [ $ j ] == $ num2 ) break ; if ( $ j == $ i ) return 0 ; return ( $ j - $ i - 1 ) ; }
function countTriplets ( $ arr , $ n , $ a , $ b ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] >= $ a && $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] <= $ b ) $ ans ++ ; } } return $ ans ; }
function findEvenPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) / 2 ; }
function countWords ( $ str ) { global $ OUT , $ IN ; $ state = $ OUT ; $ wc = 0 ; $ i = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == " ▁ " $ str [ $ i ] == " STRNEWLINE " $ str [ $ i ] == " TABSYMBOL " ) $ state = $ OUT ; else if ( $ state == $ OUT ) { $ state = $ IN ; ++ $ wc ; } ++ $ i ; } return $ wc ; }
function findNthEvenDigitNumber ( $ n ) { $ count = 0 ; for ( $ i = 0 ; ; $ i ++ ) { $ curr = $ i ; $ isCurrEvenDigit = true ; while ( $ curr != 0 ) { if ( $ curr % 10 == 1 $ curr % 10 == 3 $ curr % 10 == 5 $ curr % 10 == 7 $ curr % 10 == 9 ) $ isCurrEvenDigit = false ; $ curr = $ curr / 10 ; } if ( $ isCurrEvenDigit == true ) $ count ++ ; if ( $ count == $ n ) return $ i ; } }
function minimumMoves ( $ a , $ n ) { $ operations = 0 ; sort ( $ a ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ operations += abs ( $ a [ $ i ] - ( $ i + 1 ) ) ; return $ operations ; }
function center_nonadecagon_num ( $ n ) { return ( 19 * $ n * $ n - 19 * $ n + 2 ) / 2 ; }
function getTime ( $ u , $ v , $ x ) { $ speed = $ u + $ v ; $ time = $ x / $ speed ; return $ time ; }
function kthOdd ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 1 ) $ k -- ; if ( $ k == 0 ) return $ arr [ $ i ] ; } return -1 ; }
function nthSquareCube ( $ n ) { return $ n * $ n * $ n * $ n * $ n * $ n ; }
function countDigits ( $ n ) { return intval ( $ n * log10 ( 2 ) + 1 ) ; }
function add ( & $ A , & $ B , & $ C ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] + $ B [ $ i ] [ $ j ] ; } $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ N = 4 ; add ( $ A , $ B , $ C ) ; echo " Result ▁ matrix ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo " ▁ " ; } echo " STRNEWLINE " ; }
function countNegative ( $ M , $ n , $ m ) { $ count = 0 ; $ i = 0 ; $ j = $ m - 1 ; while ( $ j >= 0 and $ i < $ n ) { if ( $ M [ $ i ] [ $ j ] < 0 ) { $ count += $ j + 1 ; $ i += 1 ; } else $ j -= 1 ; } return $ count ; }
function isLucky ( $ n ) { $ counter = 2 ; $ next_position = $ n ; if ( $ counter > $ n ) return 1 ; if ( $ n % $ counter == 0 ) return 0 ; $ next_position -= $ next_position / $ counter ; $ counter ++ ; return isLucky ( $ next_position ) ; }
function findElements ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] > $ arr [ $ i ] ) $ count ++ ; if ( $ count >= 2 ) echo $ arr [ $ i ] . " ▁ " ; } }
function nthTerm ( $ n ) { return pow ( $ n , 2 ) + 4 * $ n ; }
function minInsertionStepToSortArray ( $ arr , $ N ) { $ lis [ $ N ] = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] >= $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ max = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ max < $ lis [ $ i ] ) $ max = $ lis [ $ i ] ; return ( $ N - $ max ) ; }
function countPaths ( $ n , $ m ) { if ( $ n == 0 $ m == 0 ) return 1 ; return ( countPaths ( $ n - 1 , $ m ) + countPaths ( $ n , $ m - 1 ) ) ; }
function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 3 * $ n + 2 ; }
function sumofseries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) / 4 ) ; }
function isEvenOrOdd ( $ L , $ R ) { $ oddCount = floor ( ( $ R - $ L ) / 2 ) ; if ( $ R % 2 == 1 $ L % 2 == 1 ) $ oddCount ++ ; if ( $ oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; }
function nthTerm ( $ N ) { return ( 2 * $ N + 3 ) * ( 2 * $ N + 3 ) - 2 * $ N ; }
function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ l <= ord ( $ str [ $ i ] ) && ord ( $ str [ $ i ] ) <= $ r ) { $ cnt ++ ; echo $ str [ $ i ] . " " ; } } return $ cnt ; }
function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; }
function lengtang ( $ r1 , $ r2 , $ d ) { echo " The ▁ length ▁ of ▁ the ▁ direct " , " ▁ common ▁ tangent ▁ is ▁ " , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 - $ r2 ) , 2 ) ) , " STRNEWLINE " ; }
function printOrder ( $ arr , $ n , $ k ) { $ a = array_slice ( $ arr , 0 , $ k ) ; sort ( $ a ) ; $ b = array_slice ( $ arr , $ k , $ n ) ; sort ( $ b ) ; $ b = array_reverse ( $ b ) ; unset ( $ arr ) ; $ arr = $ a ; return array_merge ( $ arr , $ b ) ; }
function numberOfElements ( $ height , $ n ) { $ max_so_far = 0 ; $ coun = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ height [ $ i ] > $ max_so_far ) { $ max_so_far = $ height [ $ i ] ; $ coun ++ ; } } return $ coun ; }
function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; $ ans += $ n * ( int ) ( $ a / $ n ) * ( int ) ( $ b / $ n ) ; $ ans += ( int ) ( $ a / $ n ) * ( $ b % $ n ) ; $ ans += ( $ a % $ n ) * ( int ) ( $ b / $ n ) ; $ ans += ( ( $ a % $ n ) + ( int ) ( $ b % $ n ) ) / $ n ; return $ ans ; }
function wastedWater ( $ V , $ M , $ N ) { $ amt_per_min = $ M - $ N ; $ time_to_fill = $ V / $ amt_per_min ; $ wasted_amt = $ N * $ time_to_fill ; return $ wasted_amt ; }
function uniqueCharacters ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) { if ( $ str [ $ i ] == $ str [ $ j ] ) { return false ; } } } return true ; } $ str = " GeeksforGeeks " ; if ( uniqueCharacters ( $ str ) ) { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE " ; } else { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ duplicate ▁ characters STRNEWLINE " ; }
function ReuleauxArea ( $ r ) { if ( $ r < 0 ) return -1 ; $ A = 0.70477 * 2 * pow ( $ r , 2 ) ; return $ A ; }
function isProduct ( $ arr , $ n , $ x ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] * $ arr [ $ j ] == $ x ) return true ; return false ; }
function survival ( $ S , $ N , $ M ) { if ( ( ( $ N * 6 ) < ( $ M * 7 ) && $ S > 6 ) $ M > $ N ) echo " No " ; else { $ days = ( $ M * $ S ) / $ N ; if ( ( ( $ M * $ S ) % $ N ) != 0 ) $ days ++ ; echo " Yes ▁ " , floor ( $ days ) ; } }
function occurredOnce ( & $ arr , $ n ) { sort ( $ arr ) ; if ( $ arr [ 0 ] != $ arr [ 1 ] ) echo $ arr [ 0 ] . " ▁ " ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] && $ arr [ $ i ] != $ arr [ $ i - 1 ] ) echo $ arr [ $ i ] . " ▁ " ; if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) echo $ arr [ $ n - 1 ] . " ▁ " ; }
function area_of_segment ( $ radius , $ angle ) { $ pi = 3.14159 ; $ area_of_sector = $ pi * ( $ radius * $ radius ) * ( $ angle / 360 ) ; $ area_of_triangle = 1 / 2 * ( $ radius * $ radius ) * sin ( ( $ angle * $ pi ) / 180 ) ; return $ area_of_sector - $ area_of_triangle ; }
function printOriginalMatrix ( $ a , $ b , $ mat ) { for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) { for ( $ j = 0 ; $ j < $ GLOBALS [ ' M ' ] ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == 1 ) echo min ( $ a [ $ i ] , $ b [ $ j ] ) . " ▁ " ; else echo "0" . " ▁ " ; } echo " \r STRNEWLINE " ; } }
function possibleOrNot ( $ a1 , $ a2 , $ b1 , $ b2 , $ c1 , $ c2 ) { $ dis1 = pow ( $ b1 - $ a1 , 2 ) + pow ( $ b2 - $ a2 , 2 ) ; $ dis2 = pow ( $ c1 - $ b1 , 2 ) + pow ( $ c2 - $ b2 , 2 ) ; if ( $ dis1 != $ dis2 ) echo " No " ; else if ( $ b1 == ( ( $ a1 + $ c1 ) / 2.0 ) && $ b2 == ( ( $ a2 + $ c2 ) / 2.0 ) ) echo " No " ; else echo " Yes " ; }
function maximumSegments ( $ n , $ a , $ b , $ c ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n + 10 ; $ i ++ ) $ dp [ $ i ] = -1 ; $ dp [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ dp [ $ i ] != -1 ) { $ dp [ $ i + $ a ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ a ] ) ; $ dp [ $ i + $ b ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ b ] ) ; $ dp [ $ i + $ c ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ c ] ) ; } } return $ dp [ $ n ] ; }
function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr1 [ $ i ] + $ arr2 [ $ j ] ) == $ x ) $ count ++ ; return $ count ; }
function nthKyneaNumber ( $ n ) { $ n = ( 1 << $ n ) + 1 ; $ n = $ n * $ n ; $ n = $ n - 2 ; return $ n ; }
function findNum ( $ div , $ rem , $ N ) { $ num = $ rem [ $ N - 1 ] ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { $ num = $ num * $ div [ $ i ] + $ rem [ $ i ] ; } return $ num ; }
function MaxTraceSub ( $ mat ) { global $ N ; $ max_trace = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r = $ i ; $ s = $ j ; $ trace = 0 ; while ( $ r < $ N && $ s < $ N ) { $ trace += $ mat [ $ r ] [ $ s ] ; $ r ++ ; $ s ++ ; $ max_trace = max ( $ trace , $ max_trace ) ; } } } return $ max_trace ; }
function findMissing ( $ arr1 , $ arr2 , $ M , $ N ) { if ( $ M != $ N - 1 && $ N != $ M - 1 ) { echo " Invalid ▁ Input " ; return ; } $ res = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ res = $ res ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ res = $ res ^ $ arr2 [ $ i ] ; echo " Missing ▁ element ▁ is ▁ " , $ res ; }
function findPair ( & $ arr , $ size , $ n ) { $ i = 0 ; $ j = 1 ; while ( $ i < $ size && $ j < $ size ) { if ( $ i != $ j && $ arr [ $ j ] - $ arr [ $ i ] == $ n ) { echo " Pair ▁ Found : ▁ " . " ( " . $ arr [ $ i ] . " , ▁ " . $ arr [ $ j ] . " ) " ; return true ; } else if ( $ arr [ $ j ] - $ arr [ $ i ] < $ n ) $ j ++ ; else $ i ++ ; } echo " No ▁ such ▁ pair " ; return false ; }
function moduloMultiplication ( $ a , $ b , $ mod ) { $ a %= $ mod ; while ( $ b ) { if ( $ b & 1 ) $ res = ( $ res + $ a ) % $ mod ; $ a = ( 2 * $ a ) % $ mod ; } return $ res ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 9 == 0 ) ; }
function calculateSide ( $ n , $ r ) { $ theta ; $ theta_in_radians ; $ theta = 360 / $ n ; $ theta_in_radians = $ theta * 3.14 / 180 ; return 2 * $ r * sin ( $ theta_in_radians / 2 ) ; }
function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ sum = 0 ; for ( $ n = 1 ; $ sum <= $ num ; $ n ++ ) { $ sum = $ sum + $ n ; if ( $ sum == $ num ) return true ; } return false ; }
function turnOnK ( $ n , $ k ) { if ( $ k <= 0 ) return $ n ; return ( $ n | ( 1 << ( $ k - 1 ) ) ) ; }
function solve ( $ N , $ M , & $ cp , & $ sp ) { $ profit = array_fill ( 0 , $ N , NULL ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ profit [ $ i ] = $ sp [ $ i ] - $ cp [ $ i ] ; rsort ( $ profit ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { if ( $ profit [ $ i ] > 0 ) $ sum += $ profit [ $ i ] ; else break ; } return $ sum ; }
function findArea ( $ arr , $ n ) { rsort ( $ arr ) ; $ dimension = array ( 0 , 0 ) ; for ( $ i = 0 , $ j = 0 ; $ i < $ n - 1 && $ j < 2 ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ dimension [ $ j ++ ] = $ arr [ $ i ++ ] ; return ( $ dimension [ 0 ] * $ dimension [ 1 ] ) ; }
function findSum ( $ N ) { return ( $ N * ( $ N + 1 ) * ( 2 * $ N - 5 ) + 4 * $ N ) / 2 ; }
function findMaxCock ( $ ar ) { global $ R , $ C ; if ( $ R < 3 $ C < 3 ) return -1 ; $ max_sum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ R - 2 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C - 2 ; $ j ++ ) { $ sum = ( $ ar [ $ i ] [ $ j ] + $ ar [ $ i ] [ $ j + 2 ] ) + ( $ ar [ $ i + 1 ] [ $ j + 1 ] ) + ( $ ar [ $ i + 2 ] [ $ j ] + $ ar [ $ i + 2 ] [ $ j + 1 ] + $ ar [ $ i + 2 ] [ $ j + 2 ] ) ; $ max_sum = max ( $ max_sum , $ sum ) ; } } return $ max_sum ; }
function maxSumBitonicSubArr ( $ arr , $ n ) { $ msis = array ( ) ; $ msds = array ( ) ; $ max_sum = PHP_INT_MIN ; $ msis [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ msis [ $ i ] = $ msis [ $ i - 1 ] + $ arr [ $ i ] ; else $ msis [ $ i ] = $ arr [ $ i ] ; $ msds [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) $ msds [ $ i ] = $ msds [ $ i + 1 ] + $ arr [ $ i ] ; else $ msds [ $ i ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max_sum < ( $ msis [ $ i ] + $ msds [ $ i ] - $ arr [ $ i ] ) ) $ max_sum = $ msis [ $ i ] + $ msds [ $ i ] - $ arr [ $ i ] ; return $ max_sum ; }
function hammingDist ( $ str1 , $ str2 ) { $ i = 0 ; $ count = 0 ; while ( isset ( $ str1 [ $ i ] ) != ' ' ) { if ( $ str1 [ $ i ] != $ str2 [ $ i ] ) $ count ++ ; $ i ++ ; } return $ count ; }
function findAngle ( $ n ) { $ interiorAngle ; $ exteriorAngle ; $ interiorAngle = ( $ n - 2 ) * 180 / $ n ; $ exteriorAngle = 360 / $ n ; echo " Interior ▁ angle : ▁ " , $ interiorAngle , " STRNEWLINE " ; echo " Exterior ▁ angle : ▁ " , $ exteriorAngle ; }
function numberOfWays ( $ x ) { $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ x ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; return $ dp [ $ x ] ; }
function findevenPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] % 2 != 0 ) $ count ++ ; $ oddCount = $ count * ( $ count - 1 ) / 2 ; return ( $ N * ( $ N - 1 ) / 2 ) - $ oddCount ; }
function maxPartitions ( $ arr , $ n ) { $ ans = 0 ; $ max_so_far = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ max_so_far = max ( $ max_so_far , $ arr [ $ i ] ) ; if ( $ max_so_far == $ i ) $ ans ++ ; } return $ ans ; } { $ arr = array ( 1 , 0 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo maxPartitions ( $ arr , $ n ) ; return 0 ; }
function reverse ( $ str ) { if ( ( $ str == null ) || ( strlen ( $ str ) <= 1 ) ) echo ( $ str ) ; else { echo ( $ str [ strlen ( $ str ) - 1 ] ) ; reverse ( substr ( $ str , 0 , ( strlen ( $ str ) - 1 ) ) ) ; } }
function squaresum ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; }
function binarySearch ( $ arr , $ x ) { $ l = 0 ; $ r = count ( $ arr ) ; while ( $ l <= $ r ) { $ m = $ l + ( int ) ( ( $ r - $ l ) / 2 ) ; $ res = strcmp ( $ x , $ arr [ $ m ] ) ; if ( $ res == 0 ) return $ m - 1 ; if ( $ res > 0 ) $ l = $ m + 1 ; else $ r = $ m - 1 ; } return -1 ; }
function findLargestd ( $ S , $ n ) { $ found = false ; sort ( $ S ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) continue ; for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { if ( $ i == $ k ) continue ; for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) { if ( $ i == $ l ) continue ; if ( $ S [ $ i ] == $ S [ $ j ] + $ S [ $ k ] + $ S [ $ l ] ) { $ found = true ; return $ S [ $ i ] ; } } } } } if ( $ found == false ) return PHP_INT_MIN ; }
function cyl ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( 2 * $ a * sqrt ( 2 ) ) / 3 ; $ h = ( 2 * $ a ) / 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; }
function maxSum ( $ arr , $ n ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( $ arr [ $ i ] * $ i ) ; return $ sum ; }
function printDivisors ( $ n ) { $ v ; $ t = 0 ; for ( $ i = 1 ; $ i <= ( int ) sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( ( int ) $ n / $ i == $ i ) echo $ i . " " ; else { echo $ i . " " ; $ v [ $ t ++ ] = ( int ) $ n / $ i ; } } } for ( $ i = count ( $ v ) - 1 ; $ i >= 0 ; $ i -- ) echo $ v [ $ i ] . " ▁ " ; }
function maxIndexDiff ( $ arr , $ n ) { $ maxDiff = -1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { for ( $ j = $ n - 1 ; $ j > $ i ; -- $ j ) { if ( $ arr [ $ j ] > $ arr [ $ i ] && $ maxDiff < ( $ j - $ i ) ) $ maxDiff = $ j - $ i ; } } return $ maxDiff ; }
function harmonicMean ( $ arr , $ freq , $ n ) { $ sum = 0 ; $ frequency_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( float ) ( $ freq [ $ i ] / $ arr [ $ i ] ) ; $ frequency_sum = $ frequency_sum + $ freq [ $ i ] ; } return ( $ frequency_sum / $ sum ) ; }
function checkValidity ( $ a , $ b , $ c ) { if ( $ a + $ b <= $ c $ a + $ c <= $ b $ b + $ c <= $ a ) return false ; else return true ; }
function rhombusAreaPeri ( $ d1 , $ d2 ) { $ area = ( $ d1 * $ d2 ) / 2 ; $ perimeter = 2 * sqrt ( pow ( $ d1 , 2 ) + pow ( $ d2 , 2 ) ) ; echo " The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " . $ d1 . " ▁ and ▁ " . $ d2 . " ▁ is ▁ " . $ area . " . " . " STRNEWLINE " ; echo " The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " . $ d1 . " ▁ and ▁ " . $ d2 . " ▁ is ▁ " . $ perimeter . " . " . " STRNEWLINE " ; }
function overflow ( $ H , $ r , $ h , $ N , $ R ) { $ tank_cap = 3.14 * $ r * $ r * $ H ; $ water_vol = 3.14 * $ r * $ r * $ h ; $ balls_vol = $ N * ( 4 / 3 ) * 3.14 * $ R * $ R * $ R ; $ vol = $ water_vol + $ balls_vol ; if ( $ vol > $ tank_cap ) { echo " Overflow " , " STRNEWLINE " ; } else { echo " Not ▁ in ▁ overflow ▁ state " , " STRNEWLINE " ; } }
function findS ( $ s ) { $ sum = 0 ; for ( $ n = 1 ; $ sum < $ s ; $ n ++ ) { $ sum += $ n * $ n * $ n ; if ( $ sum == $ s ) return $ n ; } return -1 ; }
function countNegative ( $ M , $ n , $ m ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ M [ $ i ] [ $ j ] < 0 ) $ count += 1 ; else break ; } } return $ count ; }
function printTaxicab2 ( $ N ) { $ i = 1 ; $ count = 0 ; while ( $ count < $ N ) { $ int_count = 0 ; for ( $ j = 1 ; $ j <= pow ( $ i , 1.0 / 3 ) ; $ j ++ ) for ( $ k = $ j + 1 ; $ k <= pow ( $ i , 1.0 / 3 ) ; $ k ++ ) if ( $ j * $ j * $ j + $ k * $ k * $ k == $ i ) $ int_count ++ ; if ( $ int_count == 2 ) { $ count ++ ; echo $ count , " " , ▁ $ i , ▁ " " } $ i ++ ; } }
function query ( $ s , $ i , $ j ) { $ n = strlen ( $ s ) ; $ i %= $ n ; $ j %= $ n ; if ( ( $ s [ $ i ] == $ s [ $ j ] ) ) echo " Yes STRNEWLINE " ; else echo " No " ; }
function countNumbers ( $ n ) { return ( int ) ( $ n / 2520 ) ; }
function check ( $ arr , $ x , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = sqrt ( $ arr [ $ i ] ) ; if ( floor ( $ x ) == ceil ( $ x ) ) { $ sum += $ arr [ $ i ] ; } } if ( ( $ sum % $ x ) == 0 ) return true ; else return false ; } $ arr = array ( 2 , 3 , 4 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; $ x = 13 ; if ( ! check ( $ arr , $ x , $ n ) ) { echo " Yes " ; } else { echo " No " ; }
function FindIndexKthBit ( $ n , $ k ) { $ cnt = 0 ; $ ind = 0 ; while ( $ n ) { if ( $ n & 1 ) $ cnt ++ ; if ( $ cnt == $ k ) return $ ind ; $ ind ++ ; $ n = $ n >> 1 ; } return -1 ; }
function minDaysToEmpty ( $ C , $ l ) { if ( $ l >= $ C ) return $ C ; $ eq_root = ( int ) sqrt ( 1 + 8 * ( $ C - $ l ) - 1 ) / 2 ; return ceil ( $ eq_root ) + $ l ; }
function checkEquilibrium ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ resx = $ x1 + $ x2 + $ x3 ; $ resy = $ y1 + $ y2 + $ y3 ; $ resz = $ z1 + $ z2 + $ z3 ; if ( $ resx == 0 and $ resy == 0 and $ resz == 0 ) return true ; else return false ; }
function SellingPrice ( $ CP , $ PP ) { $ P_decimal = 1 + ( $ PP / 100 ) ; $ res = $ P_decimal * $ CP ; return $ res ; }
function findPosition ( $ n , $ f , $ b ) { return $ n - max ( $ f + 1 , $ n - $ b ) + 1 ; }
function findOptimalSolution ( $ a , $ N ) { sort ( $ a ) ; $ points = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ points += $ a [ $ i ] * $ i ; } return $ points ; }
function linearSearch ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ i ) return $ i ; } return -1 ; }
function printTetra ( $ n ) { $ dp = array_fill ( 0 , $ n + 5 , 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = $ dp [ 2 ] = 1 ; $ dp [ 3 ] = 2 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + $ dp [ $ i - 3 ] + $ dp [ $ i - 4 ] ; echo $ dp [ $ n ] ; }
function firstkdigits ( $ n , $ k ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product *= $ n ; while ( ( int ) ( $ product / pow ( 10 , $ k ) ) != 0 ) $ product = ( int ) $ product / 10 ; return floor ( $ product ) ; }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * $ i ; return $ sum ; }
function PointInKSquares ( $ n , $ a , $ k ) { sort ( $ a ) ; return $ a [ $ n - $ k ] ; }
function phi ( $ n ) { $ result = $ n ; for ( $ p = 2 ; $ p * $ p <= $ n ; ++ $ p ) { if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) $ n /= $ p ; $ result *= ( 1.0 - ( 1.0 / $ p ) ) ; } } if ( $ n > 1 ) $ result *= ( 1.0 - ( 1.0 / $ n ) ) ; return intval ( $ result ) ; }
function findpair ( $ l , $ r ) { $ ans1 = $ l ; $ ans2 = 2 * $ l ; echo ( $ ans1 . " , ▁ " . $ ans2 ) ; }
function nextPerfectSquare ( $ N ) { $ nextN = floor ( sqrt ( $ N ) ) + 1 ; return $ nextN * $ nextN ; }
function totalTriangles ( $ h , $ v ) { if ( $ h == 0 && $ v == 0 ) return 1 ; if ( $ h == 0 ) return ( ( $ v + 1 ) * ( $ v + 2 ) / 2 ) ; if ( $ v == 0 ) return ( $ h + 1 ) ; $ Total = ( $ h + 1 ) * ( ( $ v + 1 ) * ( $ v + 2 ) / 2 ) ; return $ Total ; }
function areSetBitsIncreasing ( $ n ) { $ prev_count = PHP_INT_MAX ; while ( $ n > 0 ) { while ( $ n > 0 && $ n % 2 == 0 ) $ n = $ n / 2 ; $ curr_count = 1 ; while ( $ n > 0 and $ n % 2 == 1 ) { $ n = $ n / 2 ; $ curr_count ++ ; } if ( $ curr_count >= $ prev_count ) return false ; $ prev_count = $ curr_count ; } return true ; }
function sumOfTheSeries ( $ n ) { $ sum = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 1.0 / ( $ i * ( $ i + 1 ) ) ; return $ sum ; }
function changeEvenBits ( $ n ) { $ to_subtract = 0 ; $ m = 0 ; for ( $ x = $ n ; $ x ; $ x >>= 2 ) { if ( $ x & 1 ) $ to_subtract += ( 1 << $ m ) ; $ m += 2 ; } return $ n - $ to_subtract ; }
function divisibleBy20 ( $ num ) { $ lastTwoDigits = intval ( substr ( $ num , ( strlen ( $ num ) - 2 ) , 2 ) ) ; return ( ( $ lastTwoDigits % 5 == 0 ) && ( $ lastTwoDigits % 4 == 0 ) ) ; }
function longestsubarray ( $ arr , $ n , $ k ) { $ current_count = 0 ; $ max_count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % $ k == 0 ) $ current_count ++ ; else $ current_count = 0 ; $ max_count = max ( $ current_count , $ max_count ) ; } return $ max_count ; }
function squareRootExists ( $ n , $ p ) { $ n = $ n % $ p ; for ( $ x = 2 ; $ x < $ p ; $ x ++ ) if ( ( $ x * $ x ) % $ p == $ n ) return true ; return false ; }
function numbers ( $ n ) { return ( pow ( 2 , $ n + 1 ) ) - 2 ; }
function nextPerfectCube ( $ N ) { $ nextN = ( int ) ( floor ( pow ( $ N , ( 1 / 3 ) ) ) + 1 ) ; return $ nextN * $ nextN * $ nextN ; }
function isPossible ( $ a , $ n ) { $ sum = 0 ; $ maxS = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; $ maxS = max ( $ a [ $ i ] , $ maxS ) ; } if ( ( $ sum - $ maxS ) > $ maxS ) return true ; return false ; }
function lengthOfTangent ( $ r1 , $ r2 , $ d ) { echo " The ▁ length ▁ of ▁ the ▁ transverse ▁ common ▁ tangent ▁ is ▁ " , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 + $ r2 ) , 2 ) ) ; }
function minDistance ( $ n , $ k , & $ point ) { for ( $ i = 0 ; $ i < $ k ; ++ $ i ) sort ( $ point [ $ i ] ) ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) echo $ point [ $ i ] [ ( ceil ( ( double ) $ n / 2 ) - 1 ) ] . " ▁ " ; }
function minimumCost ( & $ cost , $ n ) { if ( $ n == 1 ) return $ cost [ 0 ] ; $ dp [ 0 ] = $ cost [ 0 ] ; $ dp [ 1 ] = $ cost [ 1 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] , $ dp [ $ i - 2 ] ) + $ cost [ $ i ] ; } return min ( $ dp [ $ n - 2 ] , $ dp [ $ n - 1 ] ) ; }
function convert ( $ m , $ n ) { if ( $ m == $ n ) return 0 ; if ( $ m > $ n ) return $ m - $ n ; if ( $ m <= 0 && $ n > 0 ) return -1 ; if ( $ n % 2 == 1 ) return 1 + convert ( $ m , $ n + 1 ) ; else return 1 + convert ( $ m , $ n / 2 ) ; } { $ m = 3 ; $ n = 11 ; echo " Minimum ▁ number ▁ of ▁ " . " operations ▁ : ▁ " , convert ( $ m , $ n ) ; return 0 ; }
function isAlphabaticOrder ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] < $ s [ $ i - 1 ] ) return false ; } return true ; }
function nonFibonacci ( $ n ) { $ prevPrev = 1 ; $ prev = 2 ; $ curr = 3 ; while ( $ n > 0 ) { $ prevPrev = $ prev ; $ prev = $ curr ; $ curr = $ prevPrev + $ prev ; $ n = $ n - ( $ curr - $ prev - 1 ) ; } $ n = $ n + ( $ curr - $ prev - 1 ) ; return $ prev + $ n ; }
function findNumbers ( $ n ) { $ odd = pow ( 10 , $ n ) - 1 ; $ even = $ odd - 1 ; echo " Even ▁ = ▁ $ even ▁ STRNEWLINE " ; echo " Odd ▁ = ▁ $ odd " ; }
function minAND ( $ arr , $ n ) { $ s = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ s = $ s & $ arr [ $ i ] ; } print ( $ s . " " ) ; }
function Mixture ( $ X , $ Y , $ Z ) { $ result = 0.0 ; $ result1 = 0.0 ; $ result1 = ( ( $ X - $ Y ) / $ X ) ; $ result = pow ( $ result1 , $ Z ) ; $ result = $ result * $ X ; return $ result ; }
function sumOfAP ( $ a , $ d , $ n ) { $ sum = ( $ n / 2 ) * ( 2 * $ a + ( $ n - 1 ) * $ d ) ; return $ sum ; }
function validate ( $ n ) { for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ temp = $ n ; $ count = 0 ; while ( $ temp ) { if ( $ temp % 10 == $ i ) $ count ++ ; if ( $ count > $ i ) return -1 ; $ temp /= 10 ; } } return 1 ; }
function countDigits ( $ a , $ b ) { return floor ( log10 ( abs ( $ a ) ) - log10 ( abs ( $ b ) ) ) + 1 ; }
function Area ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.464 * $ a ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; }
function vertices ( $ N , $ A , $ B ) { $ position = 0 ; $ minisum = PHP_INT_MAX ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i == $ A $ i == $ B ) continue ; else { $ x = abs ( $ i - $ A ) ; $ y = abs ( $ i - $ B ) ; $ sum = $ x + $ y ; if ( $ sum < $ minisum ) { $ minisum = $ sum ; $ position = $ i ; } } } return $ position ; }
function hendecagonal_num ( $ n ) { return ( 9 * $ n * $ n - 7 * $ n ) / 2 ; }
function maxHamming ( $ arr , $ n ) { $ brr = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ brr [ $ i ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ brr [ $ n + $ i ] = $ arr [ $ i ] ; $ maxHam = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ currHam = 0 ; for ( $ j = $ i , $ k = 0 ; $ j < ( $ i + $ n ) ; $ j ++ , $ k ++ ) if ( $ brr [ $ j ] != $ arr [ $ k ] ) $ currHam ++ ; if ( $ currHam == $ n ) return $ n ; $ maxHam = max ( $ maxHam , $ currHam ) ; } return $ maxHam ; }
function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = $ a / 3 ; return $ x ; }
function power ( $ x , $ y ) { $ temp ; if ( $ y == 0 ) return 1 ; $ temp = power ( $ x , $ y / 2 ) ; if ( $ y % 2 == 0 ) return $ temp * $ temp ; else { if ( $ y > 0 ) return $ x * $ temp * $ temp ; else return ( $ temp * $ temp ) / $ x ; } }
function isPowerOfFour ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) { while ( $ n > 1 ) { $ n >>= 1 ; $ count += 1 ; } return ( $ count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
function findIntersection ( $ intervals , $ N ) { $ l = $ intervals [ 0 ] [ 0 ] ; $ r = $ intervals [ 0 ] [ 1 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { if ( $ intervals [ $ i ] [ 0 ] > $ r $ intervals [ $ i ] [ 1 ] < $ l ) { echo - 1 ; return ; } else { $ l = max ( $ l , $ intervals [ $ i ] [ 0 ] ) ; $ r = min ( $ r , $ intervals [ $ i ] [ 1 ] ) ; } } echo " [ " ▁ . ▁ $ l ▁ . ▁ " , " ▁ . ▁ $ r ▁ . ▁ " ] " ; }
function sumOfTermsInNthRow ( $ n ) { $ sum = $ n * ( 2 * pow ( $ n , 2 ) + 1 ) ; return $ sum ; }
function findXor ( $ arr , $ n ) { $ xoR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ xoR = $ xoR ^ $ arr [ $ i ] ; } return $ xoR * 2 ; }
function minimumSets ( $ arr , $ n , $ key ) { $ i ; $ j ; sort ( $ arr ) ; for ( $ i = 0 , $ j = $ n - 1 ; $ i <= $ j ; ++ $ i ) if ( $ arr [ $ i ] + $ arr [ $ j ] <= $ key ) $ j -- ; return $ i ; }
function countMaxSetBits ( $ left , $ right ) { while ( ( $ left | ( $ left + 1 ) ) <= $ right ) $ left |= $ left + 1 ; return $ left ; }
function nthKyneaNumber ( $ n ) { return ( ( 1 << ( 2 * $ n ) ) + ( 1 << ( $ n + 1 ) ) - 1 ) ; }
function zigzag ( $ n , $ k ) { if ( $ n == 0 and $ k == 0 ) return 1 ; if ( $ k == 0 ) return 0 ; return zigzag ( $ n , $ k - 1 ) + zigzag ( $ n - 1 , $ n - $ k ) ; }
function MatrixChainOrder ( & $ p , $ i , $ j ) { if ( $ i == $ j ) return 0 ; $ min = PHP_INT_MAX ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) { $ count = MatrixChainOrder ( $ p , $ i , $ k ) + MatrixChainOrder ( $ p , $ k + 1 , $ j ) + $ p [ $ i - 1 ] * $ p [ $ k ] * $ p [ $ j ] ; if ( $ count < $ min ) $ min = $ count ; } return $ min ; }
function countDistinct ( & $ arr , $ n ) { $ res = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) break ; if ( $ i == $ j ) $ res ++ ; } return $ res ; }
function findEle ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ sum - $ arr [ $ i ] ) return $ arr [ $ i ] ; return -1 ; }
function area ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = pow ( ( $ a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return $ area ; }
function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ digits = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ digits += log10 ( $ i ) ; return floor ( $ digits ) + 1 ; }
function pattern ( $ str , $ len ) { for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ j = $ len - 1 - $ i ; for ( $ k = 0 ; $ k < $ len ; $ k ++ ) { if ( $ k == $ i $ k == $ j ) echo $ str [ $ k ] ; else echo " ▁ " ; } echo " STRNEWLINE " ; } }
function ispowerof2 ( $ num ) { if ( ( $ num & ( $ num - 1 ) ) == 0 ) return 1 ; return 0 ; }
function numberOfTriangles ( $ n ) { $ ans = 2 * ( pow ( 3 , $ n ) ) - 1 ; return $ ans ; }
function countNumbersWith4 ( $ n ) { if ( $ n < 4 ) return 0 ; $ d = ( int ) log10 ( $ n ) ; $ a = array_fill ( 0 , $ d + 1 , NULL ) ; $ a [ 0 ] = 0 ; $ a [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ d ; $ i ++ ) $ a [ $ i ] = $ a [ $ i - 1 ] * 9 + ceil ( pow ( 10 , $ i - 1 ) ) ; $ p = ceil ( pow ( 10 , $ d ) ) ; $ msd = intval ( $ n / $ p ) ; if ( $ msd == 4 ) return ( $ msd ) * $ a [ $ d ] + ( $ n % $ p ) + 1 ; if ( $ msd > 4 ) return ( $ msd - 1 ) * $ a [ $ d ] + $ p + countNumbersWith4 ( $ n % $ p ) ; return ( $ msd ) * $ a [ $ d ] + countNumbersWith4 ( $ n % $ p ) ; }
function setbitsfromLtoR ( $ L , $ R ) { return ( 1 << ( $ R + 1 ) ) - ( 1 << $ L ) ; }
function avg_of_odd_num ( $ n ) { return $ n ; }
function findVolume ( $ l , $ b , $ h ) { $ volume = ( $ l * $ b * $ h ) / 2 ; return $ volume ; }
function removeDuplicatesFromString ( $ str ) { $ counter = 0 ; $ i = 0 ; $ size = strlen ( $ str ) ; $ x = 0 ; $ length = 0 ; while ( $ i < $ size ) { $ x = ord ( $ str [ $ i ] ) - 97 ; if ( ( $ counter & ( 1 << $ x ) ) == 0 ) { $ str [ $ length ] = chr ( 97 + $ x ) ; $ counter = $ counter | ( 1 << $ x ) ; $ length ++ ; } $ i ++ ; } return substr ( $ str , 0 , $ length ) ; }
function printDiagonalSums ( $ mat , $ n ) { global $ MAX ; $ principal = 0 ; $ secondary = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ principal += $ mat [ $ i ] [ $ i ] ; $ secondary += $ mat [ $ i ] [ $ n - $ i - 1 ] ; } echo " Principal ▁ Diagonal : " , $ principal , " STRNEWLINE " ; echo " Secondary ▁ Diagonal : " , $ secondary , " STRNEWLINE " ; }
function findPairs ( $ n ) { $ cubeRoot = pow ( $ n , 1.0 / 3.0 ) ; $ cube = array ( ) ; for ( $ i = 1 ; $ i <= $ cubeRoot ; $ i ++ ) $ cube [ $ i ] = $ i * $ i * $ i ; $ l = 1 ; $ r = $ cubeRoot ; while ( $ l < $ r ) { if ( $ cube [ $ l ] + $ cube [ $ r ] < $ n ) $ l ++ ; else if ( $ cube [ $ l ] + $ cube [ $ r ] > $ n ) $ r -- ; else { echo " ( " , $ l , " , ▁ " , floor ( $ r ) , " ) " ; echo " STRNEWLINE " ; $ l ++ ; $ r -- ; } } }
function minimumX ( $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ rem = $ k - 1 ; $ rem > 0 ; $ rem -- ) { if ( $ n % $ rem == 0 ) $ ans = min ( $ ans , $ rem + ( $ n / $ rem ) * $ k ) ; } return $ ans ; }
function fourthPowerSum ( $ n ) { return ( ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 15 * $ n * $ n * $ n * $ n ) + ( 10 * $ n * $ n * $ n ) - $ n ) / 30 ; }
function lds ( $ arr , $ n ) { $ lds = array ( ) ; $ i ; $ j ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] < $ arr [ $ j ] and $ lds [ $ i ] < $ lds [ $ j ] + 1 ) { $ lds [ $ i ] = $ lds [ $ j ] + 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ lds [ $ i ] ) $ max = $ lds [ $ i ] ; return $ max ; }
function calculateProbability ( $ N ) { $ probability = $ N / ( $ N + 1 ) ; return $ probability ; }
function getSlope ( $ m ) { return $ m ; }
function binomialCoeffSum ( $ n ) { return ( 1 << $ n ) ; }
function minimumMoves ( $ k , $ l , $ r ) { $ count = $ r - $ l + 1 ; if ( $ count % $ k == 0 ) return 0 ; return ( $ k - ( $ count % $ k ) ) ; }
function printSpiral ( $ mat , $ r , $ c ) { global $ MAX ; $ i ; $ a = 0 ; $ b = 2 ; $ low_row = ( 0 > $ a ) ? 0 : $ a ; $ low_column = ( 0 > $ b ) ? 0 : $ b - 1 ; $ high_row = ( ( $ a + 1 ) >= $ r ) ? $ r - 1 : $ a + 1 ; $ high_column = ( ( $ b + 1 ) >= $ c ) ? $ c - 1 : $ b + 1 ; while ( ( $ low_row > 0 - $ r && $ low_column > 0 - $ c ) ) { for ( $ i = $ low_column + 1 ; $ i <= $ high_column && $ i < $ c && $ low_row >= 0 ; ++ $ i ) echo $ mat [ $ low_row ] [ $ i ] , " ▁ " ; $ low_row -= 1 ; for ( $ i = $ low_row + 2 ; $ i <= $ high_row && $ i < $ r && $ high_column < $ c ; ++ $ i ) echo $ mat [ $ i ] [ $ high_column ] , " ▁ " ; $ high_column += 1 ; for ( $ i = $ high_column - 2 ; $ i >= $ low_column && $ i >= 0 && $ high_row < $ r ; -- $ i ) echo $ mat [ $ high_row ] [ $ i ] , " ▁ " ; $ high_row += 1 ; for ( $ i = $ high_row - 2 ; $ i > $ low_row && $ i >= 0 && $ low_column >= 0 ; -- $ i ) echo $ mat [ $ i ] [ $ low_column ] , " ▁ " ; $ low_column -= 1 ; } echo " STRNEWLINE " ; }
function printKDistinct ( $ arr , $ n , $ k ) { $ dist_count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && $ arr [ $ j ] == $ arr [ $ i ] ) break ; if ( $ j == $ n ) $ dist_count ++ ; if ( $ dist_count == $ k ) return $ arr [ $ i ] ; } return -1 ; }
function make_sequence ( $ N ) { $ arr = array ( ) ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i % 2 == 1 ) $ arr [ $ i ] = 1 ; else $ arr [ $ i ] = 2 ; $ sum += $ arr [ $ i ] ; } if ( $ sum % 2 == 1 ) $ arr [ 2 ] = 3 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ arr [ $ i ] , " ▁ " ; }
function Nth_Term ( $ n ) { return ( 3 * pow ( $ n , 2 ) - $ n + 2 ) / ( 2 ) ; }
function uniqueCharacters ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ bitAtIndex = $ str [ $ i ] - ' a ' ; if ( ( $ checker & ( 1 << $ bitAtIndex ) ) > 0 ) { return false ; } $ checker = $ checker | ( 1 << $ bitAtIndex ) ; } return true ; } $ str = " geeksforgeeks " ; if ( uniqueCharacters ( $ str ) ) { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE " ; } else { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ duplicate ▁ characters STRNEWLINE " ; }
function calculate ( & $ array , $ size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) if ( $ array [ $ i ] % 2 == 0 && $ array [ $ i ] != 0 && $ array [ $ i ] != 2 ) $ count ++ ; return $ count ; }
function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - 1 ) - ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) / 2 ; }
function findM ( $ s , $ x ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ s [ $ i ] ) - ord ( '0' ) != $ x ) $ cnt ++ ; } return $ cnt ; }
function isEven ( $ s ) { $ l = strlen ( $ s ) ; $ dotSeen = false ; for ( $ i = $ l - 1 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '0' && $ dotSeen == false ) continue ; if ( $ s [ $ i ] == ' . ' ) { $ dotSeen = true ; continue ; } if ( ( $ s [ $ i ] - '0' ) % 2 == 0 ) return true ; return false ; } }
function nDigitPerfectCubes ( $ n ) { print ( pow ( ceil ( pow ( pow ( 10 , ( $ n - 1 ) ) , 1 / 3 ) ) , 3 ) . " ▁ " ) ; print ( ( int ) pow ( ceil ( pow ( pow ( 10 , ( $ n ) ) , 1 / 3 ) ) - 1 , 3 ) ) ; }
function findoptimal ( $ N ) { if ( $ N <= 6 ) return $ N ; $ max = 0 ; $ b ; for ( $ b = $ N - 3 ; $ b >= 1 ; $ b -= 1 ) { $ curr = ( $ N - $ b - 1 ) * findoptimal ( $ b ) ; if ( $ curr > $ max ) $ max = $ curr ; } return $ max ; }
function maxXorSum ( $ n , $ k ) { if ( $ k == 1 ) return $ n ; $ res = 1 ; while ( $ res <= $ n ) $ res <<= 1 ; return $ res - 1 ; }
function missingK ( & $ a , $ k , $ n ) { $ difference = 0 ; $ ans = 0 ; $ count = $ k ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ difference = 0 ; if ( ( $ a [ $ i ] + 1 ) != $ a [ $ i + 1 ] ) { $ difference += ( $ a [ $ i + 1 ] - $ a [ $ i ] ) - 1 ; if ( $ difference >= $ count ) { $ ans = $ a [ $ i ] + $ count ; $ flag = 1 ; break ; } else $ count -= $ difference ; } } if ( $ flag ) return $ ans ; else return -1 ; }
function volumeOfEllipsoid ( $ r1 , $ r2 , $ r3 ) { $ pi = 3.14 ; return 1.33 * $ pi * $ r1 * $ r2 * $ r3 ; }
function freq ( $ ar , $ m , $ n ) { $ even = 0 ; $ odd = 0 ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) { for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { if ( ( $ ar [ $ i ] [ $ j ] % 2 ) == 0 ) ++ $ even ; else ++ $ odd ; } } echo " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = ▁ " , $ odd , " STRNEWLINE " ; echo " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ " , $ even ; }
function countGreater ( $ arr , $ n , $ k ) { $ l = 0 ; $ r = $ n - 1 ; $ leftGreater = $ n ; while ( $ l <= $ r ) { $ m = $ l + ( int ) ( ( $ r - $ l ) / 2 ) ; if ( $ arr [ $ m ] > $ k ) { $ leftGreater = $ m ; $ r = $ m - 1 ; } else $ l = $ m + 1 ; } return ( $ n - $ leftGreater ) ; }
function Maxsum ( $ c1 , $ c2 , $ c3 , $ c4 ) { $ sum = 0 ; $ two34 = min ( $ c2 , min ( $ c3 , $ c4 ) ) ; $ sum = $ two34 * 234 ; $ c2 -= $ two34 ; $ sum += min ( $ c2 , $ c1 ) * 12 ; return $ sum ; }
function MinOfCubedDP ( $ k ) { $ DP = array ( $ k + 1 ) ; $ j = 1 ; $ t = 1 ; $ DP [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { $ DP [ $ i ] = PHP_INT_MAX ; while ( $ j <= $ i ) { if ( $ j == $ i ) $ DP [ $ i ] = 1 ; else if ( $ DP [ $ i ] > $ DP [ $ i - $ j ] ) $ DP [ $ i ] = $ DP [ $ i - $ j ] + 1 ; $ t ++ ; $ j = $ t * $ t * $ t ; } $ t = $ j = 1 ; } return $ DP [ $ k ] ; }
function printbinomial ( $ max ) { for ( $ m = 0 ; $ m <= $ max ; $ m ++ ) { echo $ m ; $ binom = 1 ; for ( $ x = 0 ; $ x <= $ m ; $ x ++ ) { if ( $ m != 0 && $ x != 0 ) $ binom = $ binom * ( $ m - $ x + 1 ) / $ x ; echo " ▁ " , $ binom , " ▁ " ; } echo " STRNEWLINE " ; } }
function decToHexa ( $ n ) { $ hexaDeciNum ; $ i = 0 ; while ( $ n != 0 ) { $ temp = 0 ; $ temp = $ n % 16 ; if ( $ temp < 10 ) { $ hexaDeciNum [ $ i ] = chr ( $ temp + 48 ) ; $ i ++ ; } else { $ hexaDeciNum [ $ i ] = chr ( $ temp + 55 ) ; $ i ++ ; } $ n = ( int ) ( $ n / 16 ) ; } for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) echo $ hexaDeciNum [ $ j ] ; }
function printNumHavingAltBitPatrn ( $ n ) { $ curr_num = 1 ; echo $ curr_num . " " ; while ( 1 ) { $ curr_num <<= 1 ; if ( $ n < $ curr_num ) break ; echo $ curr_num . " " ; $ curr_num = ( ( $ curr_num ) << 1 ) ^ 1 ; if ( $ n < $ curr_num ) break ; echo $ curr_num . " " ; } }
function summingSeries ( $ n ) { return pow ( $ n , 2 ) ; }
function countTrailingZero ( $ x ) { $ count = 0 ; while ( ( $ x & 1 ) == 0 ) { $ x = $ x >> 1 ; $ count ++ ; } return $ count ; }
function digitsNum ( $ N ) { if ( $ N == 0 ) echo "0 STRNEWLINE " ; if ( $ N % 9 != 0 ) echo ( $ N % 9 ) ; for ( $ i = 1 ; $ i <= ( $ N / 9 ) ; ++ $ i ) echo "9" ; for ( $ i = 1 ; $ i <= $ N ; ++ $ i ) echo "0" ; echo " STRNEWLINE " ; }
function setBitNumber ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; $ n = $ n + 1 ; return ( $ n >> 1 ) ; }
function sortBinaryArray ( $ a , $ n ) { $ j = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] < 1 ) { $ j ++ ; $ temp = $ a [ $ j ] ; $ a [ $ j ] = $ a [ $ i ] ; $ a [ $ i ] = $ temp ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] . " ▁ " ; }
function NumberOfRectangles ( $ n , $ m ) { if ( $ n % 2 == 0 ) return ( $ n / 2 ) * $ m ; else if ( $ m % 2 == 0 ) return ( $ m / 2 ) * $ n ; return ( $ n * $ m - 1 ) / 2 ; }
function findSmallest ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ j ] % $ a [ $ i ] ) break ; if ( $ j == $ n ) return $ a [ $ i ] ; } return -1 ; }
function findElement ( $ arr , $ n , $ key ) { $ i ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ key ) return $ i ; return -1 ; }
function findElements ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) echo $ arr [ $ i ] , " ▁ " ; }
function maxDistance ( $ arr , $ n ) { $ max1 = PHP_INT_MIN ; $ min1 = PHP_INT_MAX ; $ max2 = PHP_INT_MIN ; $ min2 = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ max1 = max ( $ max1 , $ arr [ $ i ] + $ i ) ; $ min1 = min ( $ min1 , $ arr [ $ i ] + $ i ) ; $ max2 = max ( $ max2 , $ arr [ $ i ] - $ i ) ; $ min2 = min ( $ min2 , $ arr [ $ i ] - $ i ) ; } return max ( $ max1 - $ min1 , $ max2 - $ min2 ) ; }
function findCountOfSolutions ( $ n , $ p ) { $ ans = 0 ; for ( $ x = 1 ; $ x < $ p ; $ x ++ ) { if ( ( $ x * $ x ) % $ p == 1 ) { $ last = $ x + $ p * ( $ n / $ p ) ; if ( $ last > $ n ) $ last -= $ p ; $ ans += ( ( $ last - $ x ) / $ p + 1 ) ; } } return $ ans ; }
function printSubstrings ( $ n ) { $ s = ( int ) log10 ( $ n ) ; $ d = ( int ) ( pow ( 10 , $ s ) + 0.5 ) ; $ k = $ d ; while ( $ n ) { while ( $ d ) { echo ( int ) ( $ n / $ d ) . " STRNEWLINE " ; $ d = ( int ) ( $ d / 10 ) ; } $ n = $ n % $ k ; $ k = ( int ) ( $ k / 10 ) ; $ d = $ k ; } }
function numberSequence ( $ n ) { $ num = pow ( 4 , $ n ) - pow ( 2 , $ n ) - 1 ; return $ num ; }
function Conversion ( $ centi ) { $ pixels = ( 96 * $ centi ) / 2.54 ; echo ( $ pixels . " " ) ; }
function mergeTwoHalf ( & $ A , $ n ) { sort ( $ A , 0 ) ; }
function items ( $ n , $ a ) { sort ( $ a ) ; $ z = $ a [ $ n - 1 ] ; $ x = 1 ; $ s = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ s += $ a [ $ i ] ; if ( $ s <= $ z ) $ x += 1 ; else break ; } return $ x ; }
function findNumbers ( $ arr , $ n ) { $ sumN = ( $ n * ( $ n + 1 ) ) / 2 ; $ sumSqN = ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; $ sum = 0 ; $ sumSq = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ sumSq += pow ( $ arr [ $ i ] , 2 ) ; } $ B = ( ( ( $ sumSq - $ sumSqN ) / ( $ sum - $ sumN ) ) + $ sumN - $ sum ) / 2 ; $ A = $ sum - $ sumN + $ B ; echo " A = " , ▁ $ A , ▁ " B = " }
function completeSequence ( $ s ) { $ n = strlen ( $ s ) ; $ open = 0 ; $ close = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' ( ' ) $ open ++ ; else $ close ++ ; if ( $ close > $ open ) { echo ( " IMPOSSIBLE " ) ; return ; } } echo ( $ s ) ; for ( $ i = 0 ; $ i < $ open - $ close ; $ i ++ ) echo ( " ) " ) ; }
function printRect ( $ X , $ Y , $ n ) { $ Xmax = max ( $ X ) ; $ Xmin = min ( $ X ) ; $ Ymax = max ( $ Y ) ; $ Ymin = min ( $ Y ) ; echo " { " , $ Xmin , " , ▁ " , $ Ymin , " } " , " STRNEWLINE " ; echo " { " , $ Xmin , " , ▁ " , $ Ymax , " } " , " STRNEWLINE " ; echo " { " , $ Xmax , " , ▁ " , $ Ymax , " } " , " STRNEWLINE " ; echo " { " , $ Xmax , " , ▁ " , $ Ymin , " } " ; }
function check ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) - 1 ; $ i ++ ) if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) return true ; return false ; }
function countSubstrs ( $ str , $ i , $ j , $ n ) { if ( $ n == 1 ) return 1 ; if ( $ n <= 0 ) return 0 ; $ res = countSubstrs ( $ str , $ i + 1 , $ j , $ n - 1 ) + countSubstrs ( $ str , $ i , $ j - 1 , $ n - 1 ) - countSubstrs ( $ str , $ i + 1 , $ j - 1 , $ n - 2 ) ; if ( $ str [ $ i ] == $ str [ $ j ] ) $ res ++ ; return $ res ; }
function findMaxAverage ( $ arr , $ n , $ k ) { if ( $ k > $ n ) return -1 ; $ csum = array ( ) ; $ csum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ csum [ $ i ] = $ csum [ $ i - 1 ] + $ arr [ $ i ] ; $ max_sum = $ csum [ $ k - 1 ] ; $ max_end = $ k - 1 ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ curr_sum = $ csum [ $ i ] - $ csum [ $ i - $ k ] ; if ( $ curr_sum > $ max_sum ) { $ max_sum = $ curr_sum ; $ max_end = $ i ; } } return $ max_end - $ k + 1 ; }
function printCountDP ( $ dist ) { $ count = array ( ) ; $ count [ 0 ] = 1 ; $ count [ 1 ] = 1 ; $ count [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ dist ; $ i ++ ) $ count [ $ i ] = $ count [ $ i - 1 ] + $ count [ $ i - 2 ] + $ count [ $ i - 3 ] ; return $ count [ $ dist ] ; }
function nextPowerOf2 ( $ n ) { $ n -- ; $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; $ n ++ ; return $ n ; }
function isSubSequence ( $ str1 , $ str2 , $ m , $ n ) { if ( $ m == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ str1 [ $ m - 1 ] == $ str2 [ $ n - 1 ] ) return isSubSequence ( $ str1 , $ str2 , $ m - 1 , $ n - 1 ) ; return isSubSequence ( $ str1 , $ str2 , $ m , $ n - 1 ) ; }
function minCoins ( $ coins , $ m , $ V ) { $ table [ $ V + 1 ] = array ( ) ; $ table [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ V ; $ i ++ ) $ table [ $ i ] = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ V ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ coins [ $ j ] <= $ i ) { $ sub_res = $ table [ $ i - $ coins [ $ j ] ] ; if ( $ sub_res != PHP_INT_MAX && $ sub_res + 1 < $ table [ $ i ] ) $ table [ $ i ] = $ sub_res + 1 ; } } if ( $ table [ $ V ] == PHP_INT_MAX ) return -1 ; return $ table [ $ V ] ; }
function fnMod ( $ n ) { if ( $ n % 5 == 1 ) return 4 ; else return 0 ; }
function nth_group ( $ n ) { return $ n * ( 2 * pow ( $ n , 2 ) + 1 ) ; }
function sumOfTheSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ k = 2 ; for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ sum += $ k ; $ k += 2 ; } } return $ sum ; }
function maximumSumSubarray ( $ arr , $ n ) { $ min_prefix_sum = 0 ; $ res = PHP_INT_MIN ; $ prefix_sum = array ( ) ; $ prefix_sum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prefix_sum [ $ i ] = $ prefix_sum [ $ i - 1 ] + $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ res = max ( $ res , $ prefix_sum [ $ i ] - $ min_prefix_sum ) ; $ min_prefix_sum = min ( $ min_prefix_sum , $ prefix_sum [ $ i ] ) ; } return $ res ; }
function countSquares ( $ row , $ column ) { $ topLeft = min ( $ row , $ column ) - 1 ; $ bottomRight = 8 - max ( $ row , $ column ) ; $ topRight = min ( $ row , 9 - $ column ) - 1 ; $ bottomLeft = 8 - max ( $ row , 9 - $ column ) ; return ( $ topLeft + $ topRight + $ bottomRight + $ bottomLeft ) ; }
function findWinner ( $ x , $ y , $ n ) { $ dp = array ( ) ; $ dp [ 0 ] = false ; $ dp [ 1 ] = true ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i - 1 >= 0 and ! $ dp [ $ i - 1 ] ) $ dp [ $ i ] = true ; else if ( $ i - $ x >= 0 and ! $ dp [ $ i - $ x ] ) $ dp [ $ i ] = true ; else if ( $ i - $ y >= 0 and ! $ dp [ $ i - $ y ] ) $ dp [ $ i ] = true ; else $ dp [ $ i ] = false ; } return $ dp [ $ n ] ; }
function reachTarget ( $ target ) { $ target = abs ( $ target ) ; $ sum = 0 ; $ step = 0 ; while ( $ sum < $ target or ( $ sum - $ target ) % 2 != 0 ) { $ step ++ ; $ sum += $ step ; } return $ step ; }
function count1 ( $ N , $ K , $ R ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i % $ K == $ R ) $ sum += $ i ; } return $ sum ; }
function findNum ( $ N , $ K ) { $ rem = ( $ N + $ K ) % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N + $ K - $ rem ; }
function maxSum ( $ N ) { $ ans = 0 ; for ( $ u = 1 ; $ u <= $ N ; $ u ++ ) { for ( $ v = 1 ; $ v <= $ N ; $ v ++ ) { if ( $ u == $ v ) continue ; $ degreeU = 2 ; if ( $ u == 1 $ u == $ N ) $ degreeU = 1 ; $ degreeV = 2 ; if ( $ v == 1 $ v == $ N ) $ degreeV = 1 ; $ ans += ( $ degreeU * $ degreeV ) ; } } return $ ans ; }
function fact ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * fact ( $ n - 1 ) ; }
function unitDigitXRaisedY ( $ x , $ y ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ y ; $ i ++ ) $ res = ( $ res * $ x ) % 10 ; return $ res ; }
function nthprimedigitsnumber ( $ number ) { $ num = " " ; while ( $ number > 0 ) { $ rem = $ number % 4 ; switch ( $ rem ) { case 1 : $ num . = '2' ; break ; case 2 : $ num . = '3' ; break ; case 3 : $ num . = '5' ; break ; case 0 : $ num . = '7' ; break ; } if ( $ number % 4 == 0 ) $ number -- ; $ number = ( int ) ( $ number / 4 ) ; } return strrev ( $ num ) ; }
function countDivisors ( $ n , $ k ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 && $ i % $ k == 0 ) { $ count ++ ; } } return $ count ; }
function middleOfThree ( $ a , $ b , $ c ) { $ x = $ a - $ b ; $ y = $ b - $ c ; $ z = $ a - $ c ; if ( $ x * $ y > 0 ) return $ b ; else if ( $ x * $ z > 0 ) return $ c ; else return $ a ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + $ n - 3 ; }
function search ( $ arr , $ n , $ x ) { $ res = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ x == $ arr [ $ i ] ) $ res = $ i ; if ( $ res == -1 ) return false ; $ temp = $ arr [ $ res ] ; for ( $ i = $ res ; $ i > 0 ; $ i -- ) $ arr [ $ i ] = $ arr [ $ i - 1 ] ; $ arr [ 0 ] = $ temp ; return true ; }
function calTime ( & $ arr , $ n ) { $ work = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ work += 1 / $ arr [ $ i ] ; return 1 / $ work ; }
function maxDiff ( $ arr , $ n ) { $ maxDiff = -1 ; $ maxRight = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] > $ maxRight ) $ maxRight = $ arr [ $ i ] ; else { $ diff = $ maxRight - $ arr [ $ i ] ; if ( $ diff > $ maxDiff ) { $ maxDiff = $ diff ; } } } return $ maxDiff ; }
function maxSubArraySumRepeated ( $ a , $ n , $ k ) { $ INT_MIN = 0 ; $ max_so_far = $ INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ n * $ k ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i % $ n ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; }
function printCase ( $ n ) { if ( $ n <= 2 ) { echo ( -1 ) ; return ; } for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { echo ( $ i ) ; echo ( " ▁ " ) ; } }
function pronic_check ( $ n ) { $ x = floor ( sqrt ( $ n ) ) ; if ( $ x * ( $ x + 1 ) == $ n ) return true ; else return false ; }
function getTotalNumberOfSequences ( $ m , $ n ) { $ T = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) { if ( $ i == 0 or $ j == 0 ) $ T [ $ i ] [ $ j ] = 0 ; else if ( $ i < $ j ) $ T [ $ i ] [ $ j ] = 0 ; else if ( $ j == 1 ) $ T [ $ i ] [ $ j ] = $ i ; else $ T [ $ i ] [ $ j ] = $ T [ $ i - 1 ] [ $ j ] + $ T [ $ i / 2 ] [ $ j - 1 ] ; } } return $ T [ $ m ] [ $ n ] ; }
function findCount ( $ mat , $ i , $ j , $ m ) { if ( $ i == 0 && $ j == 0 ) { if ( $ m == $ mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( $ m < 0 ) return 0 ; if ( $ i < 0 $ j < 0 ) return 0 ; if ( $ v [ $ i ] [ $ j ] [ $ m ] ) return $ dp [ $ i ] [ $ j ] [ $ m ] ; $ v [ $ i ] [ $ j ] [ $ m ] = true ; $ dp [ $ i ] [ $ j ] [ $ m ] = findCount ( $ mat , $ i - 1 , $ j , $ m - $ mat [ $ i ] [ $ j ] ) + findCount ( $ mat , $ i , $ j - 1 , $ m - $ mat [ $ i ] [ $ j ] ) ; return $ dp [ $ i ] [ $ j ] [ $ m ] ; }
function isTrimorphic ( $ N ) { $ cube = $ N * $ N * $ N ; while ( $ N > 0 ) { if ( $ N % 10 != $ cube % 10 ) return -1 ; $ N /= 10 ; $ cube /= 10 ; } return 1 ; }
function findCount ( $ str ) { $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ( $ i == ord ( $ str [ $ i ] ) - ord ( ' a ' ) ) or ( $ i == ord ( $ str [ $ i ] ) - ord ( ' A ' ) ) ) $ result += 1 ; } return $ result ; }
function LiesInsieRectangle ( $ a , $ b , $ x , $ y ) { if ( $ x - $ y - $ b <= 0 && $ x - $ y + $ b >= 0 && $ x + $ y - 2 * $ a + $ b <= 0 && $ x + $ y - $ b >= 0 ) return true ; return false ; }
function countDigitOne ( $ n ) { $ countr = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ str = strval ( $ i ) ; $ countr += substr_count ( $ str , '1' ) ; } return $ countr ; }
function length_rope ( $ r ) { global $ PI ; return ( ( 2 * $ PI * $ r ) + 6 * $ r ) ; }
function countUnmarked ( $ N ) { if ( $ N % 2 == 0 ) return $ N / 2 ; else return $ N / 2 + 1 ; }
function difference ( $ arr , $ n ) { $ d1 = 0 ; $ d2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) $ d1 += $ arr [ $ i ] [ $ j ] ; if ( $ i == $ n - $ j - 1 ) $ d2 += $ arr [ $ i ] [ $ j ] ; } } return abs ( $ d1 - $ d2 ) ; } { $ n = 3 ; $ arr = array ( array ( 11 , 2 , 4 ) , array ( 4 , 5 , 6 ) , array ( 10 , 8 , -12 ) ) ; echo difference ( $ arr , $ n ) ; return 0 ; }
function maxLength ( $ s , $ n ) { $ right = 0 ; $ left = 0 ; $ coun = 0 ; $ max_length = PHP_INT_MIN ; $ s = $ s . '1' ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' o ' ) $ coun ++ ; else { if ( $ coun > $ max_length ) { $ right = 0 ; $ left = 0 ; if ( $ s [ $ i ] == ' x ' ) $ right = 1 ; if ( ( ( $ i - $ coun ) > 0 ) && ( $ s [ $ i - $ coun - 1 ] == ' x ' ) ) $ left = 1 ; $ coun = ( int ) ceil ( ( double ) $ coun / ( $ right + $ left ) ) ; $ max_length = max ( $ max_length , $ coun ) ; } $ coun = 0 ; } } return $ max_length ; }
function maxAverageOfPath ( $ cost , $ N ) { $ dp = array ( array ( ) ) ; $ dp [ 0 ] [ 0 ] = $ cost [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i - 1 ] [ 0 ] + $ cost [ $ i ] [ 0 ] ; for ( $ j = 1 ; $ j < $ N ; $ j ++ ) $ dp [ 0 ] [ $ j ] = $ dp [ 0 ] [ $ j - 1 ] + $ cost [ 0 ] [ $ j ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) + $ cost [ $ i ] [ $ j ] ; } return $ dp [ $ N - 1 ] [ $ N - 1 ] / ( 2 * $ N - 1 ) ; }
function countPaths ( $ sum , $ get , $ m , $ n , & $ dp ) { global $ max , $ c ; if ( $ sum < 0 ) return 0 ; if ( $ sum == 0 ) return $ get ; if ( $ dp [ $ sum ] [ $ get ] != -1 ) return $ dp [ $ sum ] [ $ get ] ; $ res = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i == $ m ) $ res += countPaths ( $ sum - $ i , 1 , $ m , $ n , $ dp ) ; $ res += countPaths ( $ sum - $ i , $ get , $ m , $ n , $ dp ) ; } $ dp [ $ sum ] [ $ get ] = $ res ; return $ dp [ $ sum ] [ $ get ] ; }
function findPCSlope ( $ m ) { return -1.0 / $ m ; }
function findPrimeFactors ( ) { global $ N , $ primeFactors ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) if ( $ primeFactors [ $ i ] == 0 ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) $ primeFactors [ $ j ] = $ primeFactors [ ( int ) ( $ j / $ i ) ] + 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ primeFactors [ $ i ] += $ primeFactors [ $ i - 1 ] ; }
function maxSum ( $ arr , $ n ) { if ( $ n < 2 ) return -1 ; $ ans = $ arr [ 0 ] + $ arr [ 1 ] ; for ( $ i = 1 ; $ i + 1 < $ n ; $ i ++ ) $ ans = min ( $ ans , ( $ arr [ $ i ] + $ arr [ $ i + 1 ] ) ) ; return $ ans ; }
function octahedral_num ( $ n ) { return $ n * ( 2 * $ n * $ n + 1 ) / 3 ; }
function sumOfSeries ( $ n ) { $ ans = pow ( $ n % $ GLOBALS [ ' MOD ' ] , 2 ) ; return ( $ ans % $ GLOBALS [ ' MOD ' ] ) ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ sum = $ sum + $ x ; return $ sum ; }
function totEdge ( $ n ) { $ result = 0 ; $ result = ( $ n * ( $ n - 1 ) ) / 2 ; return $ result ; }
function superSeq ( $ X , $ Y , $ m , $ n ) { if ( ! $ m ) return $ n ; if ( ! $ n ) return $ m ; if ( $ X [ $ m - 1 ] == $ Y [ $ n - 1 ] ) return 1 + superSeq ( $ X , $ Y , $ m - 1 , $ n - 1 ) ; return 1 + min ( superSeq ( $ X , $ Y , $ m - 1 , $ n ) , superSeq ( $ X , $ Y , $ m , $ n - 1 ) ) ; }
function arekAnagrams ( $ str1 , $ str2 , $ k ) { global $ MAX_CHAR ; $ n = strlen ( $ str1 ) ; if ( strlen ( $ str2 ) != $ n ) return false ; $ count1 = ( 0 ) ; $ count2 = ( 0 ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ count1 [ $ i ] > $ count2 [ $ i ] ) $ count = $ count + abs ( $ count1 [ $ i ] - $ count2 [ $ i ] ) ; return ( $ count <= $ k ) ; }
function EqualNumbers ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; if ( $ sum % $ n ) return $ n - 1 ; return $ n ; }
function countStrings ( $ n ) { $ a [ $ n ] = 0 ; $ b [ $ n ] = 0 ; $ a [ 0 ] = $ b [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = $ a [ $ i - 1 ] + $ b [ $ i - 1 ] ; $ b [ $ i ] = $ a [ $ i - 1 ] ; } return ( 1 << $ n ) - $ a [ $ n - 1 ] - $ b [ $ n - 1 ] ; }
function isTriPerfect ( $ n ) { $ sum = 1 + $ n ; $ i = 2 ; while ( $ i * $ i <= $ n ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ sum = $ sum + $ i ; else $ sum = $ sum + $ i + $ n / $ i ; } $ i += 1 ; } if ( $ sum == 3 * $ n and $ n != 1 ) return true ; else false ; }
function checkCentrosymmetricted ( $ n , $ m ) { $ mid_row ; if ( $ n & 1 ) $ mid_row = $ n / 2 + 1 ; else $ mid_row = $ n / 2 ; for ( $ i = 0 ; $ i < $ mid_row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ m [ $ i ] [ $ j ] != $ m [ $ n - $ i - 1 ] [ $ n - $ j - 1 ] ) return false ; } } return true ; }
function countFriendsPairings ( $ n ) { $ dp = array_fill ( 0 , 1000 , -1 ) ; if ( $ dp [ $ n ] != -1 ) return $ dp [ $ n ] ; if ( $ n > 2 ) { $ dp [ $ n ] = countFriendsPairings ( $ n - 1 ) + ( $ n - 1 ) * countFriendsPairings ( $ n - 2 ) ; return $ dp [ $ n ] ; } else { $ dp [ $ n ] = $ n ; return $ dp [ $ n ] ; } }
function getElements ( $ a , & $ arr , & $ n ) { $ elements [ 0 ] = $ a ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ elements [ $ i + 1 ] = $ arr [ $ i ] ^ $ elements [ $ i ] ; } for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) { echo ( $ elements [ $ i ] . " " ) ; } }
function isKthBitSet ( $ n , $ k ) { if ( ( $ n >> ( $ k - 1 ) ) & 1 ) echo " SET " ; else echo " NOT ▁ SET " ; }
function findTrailingZeros ( $ n ) { $ count = 0 ; for ( $ i = 5 ; $ n / $ i >= 1 ; $ i *= 5 ) $ count += $ n / $ i ; return $ count ; }
function MinOperation ( $ a , $ b , $ n ) { sort ( $ a ) ; sort ( $ b ) ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ a [ $ i ] > $ b [ $ i ] ) $ result = $ result + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; else if ( $ a [ $ i ] < $ b [ $ i ] ) $ result = $ result + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; } return $ result ; }
function countOddSum ( & $ ar , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ val = 0 ; for ( $ j = $ i ; $ j <= $ n - 1 ; $ j ++ ) { $ val = $ val + $ ar [ $ j ] ; if ( $ val % 2 != 0 ) $ result ++ ; } } return ( $ result ) ; }
function findParity ( $ x ) { $ y = $ x ^ ( $ x >> 1 ) ; $ y = $ y ^ ( $ y >> 2 ) ; $ y = $ y ^ ( $ y >> 4 ) ; $ y = $ y ^ ( $ y >> 8 ) ; $ y = $ y ^ ( $ y >> 16 ) ; if ( $ y & 1 ) return 1 ; return 0 ; }
function Add ( $ x , $ y ) { while ( $ y != 0 ) { $ carry = $ x & $ y ; $ x = $ x ^ $ y ; $ y = $ carry << 1 ; } return $ x ; }
function printTetra ( $ n ) { if ( $ n < 0 ) return ; $ first = 0 ; $ second = 1 ; $ third = 1 ; $ fourth = 2 ; $ curr ; if ( $ n == 0 ) echo $ first ; else if ( $ n == 1 $ n == 2 ) echo $ second ; else if ( $ n == 3 ) echo $ fourth ; else { for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) { $ curr = $ first + $ second + $ third + $ fourth ; $ first = $ second ; $ second = $ third ; $ third = $ fourth ; $ fourth = $ curr ; } echo $ curr ; } }
function fun ( $ n ) { return $ n & ( $ n - 1 ) ; }
function rearrange ( & $ arr , $ n ) { if ( $ arr == NULL $ n % 2 == 1 ) return ; $ currIdx = intval ( ( $ n - 1 ) / 2 ) ; while ( $ currIdx > 0 ) { $ count = $ currIdx ; $ swapIdx = $ currIdx ; while ( $ count -- > 0 ) { $ temp = $ arr [ $ swapIdx + 1 ] ; $ arr [ $ swapIdx + 1 ] = $ arr [ $ swapIdx ] ; $ arr [ $ swapIdx ] = $ temp ; $ swapIdx ++ ; } $ currIdx -- ; } }
function countOddSquares ( $ n , $ m ) { return pow ( $ m , 0.5 ) - pow ( $ n - 1 , 0.5 ) ; }
function isSubsetAndZero ( $ array , $ length , $ N ) { $ arrAnd = $ array [ 0 ] ; for ( $ i = 1 ; $ i < $ length ; $ i ++ ) { $ arrAnd = $ arrAnd & $ array [ $ i ] ; } if ( ( $ arrAnd & $ N ) == 0 ) echo ( " YES " ) ; else echo ( " NO " ) ; }
function isSumOfPowersOfTwo ( $ n ) { if ( $ n % 2 == 1 ) return false ; else return true ; }
function minItems ( $ k , $ r ) { for ( $ i = 1 ; $ i < 10 ; $ i ++ ) if ( ( $ i * $ k - $ r ) % 10 == 0 || ( $ i * $ k ) % 10 == 0 ) return $ i ; return 10 ; }
function result ( $ n , $ k , $ t ) { if ( $ t <= $ k ) echo t ; else if ( $ t <= $ n ) echo k ; else { $ temp = $ t - $ n ; $ temp = $ k - $ temp ; echo $ temp ; } }
function isMember ( $ a , $ d , $ x ) { if ( $ d == 0 ) return ( $ x == $ a ) ; return ( ( $ x - $ a ) % $ d == 0 && ( $ x - $ a ) / $ d >= 0 ) ; }
function numberOfSolutions ( $ n ) { $ c = 0 ; for ( $ x = 0 ; $ x <= $ n ; ++ $ x ) if ( $ n == $ x + $ n ^ $ x ) ++ $ c ; return $ c ; }
function findSDSFunc ( $ n ) { $ DP [ 0 ] = 0 ; $ DP [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ DP [ $ i ] = $ DP [ $ i / 2 ] ; else $ DP [ $ i ] = $ DP [ ( $ i - 1 ) / 2 ] + $ DP [ ( $ i + 1 ) / 2 ] ; } return $ DP [ $ n ] ; }
function findSum ( $ n , $ a , $ b ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ i % $ a == 0 $ i % $ b == 0 ) $ sum += $ i ; return $ sum ; }
function maxSumWO3Consec ( $ n ) { global $ sum , $ arr ; if ( $ sum [ $ n ] != -1 ) return $ sum [ $ n ] ; if ( $ n == 0 ) return $ sum [ $ n ] = 0 ; if ( $ n == 1 ) return $ sum [ $ n ] = $ arr [ 0 ] ; if ( $ n == 2 ) return $ sum [ $ n ] = $ arr [ 1 ] + $ arr [ 0 ] ; return $ sum [ $ n ] = max ( max ( maxSumWO3Consec ( $ n - 1 ) , maxSumWO3Consec ( $ n - 2 ) + $ arr [ $ n ] ) , $ arr [ $ n ] + $ arr [ $ n - 1 ] + maxSumWO3Consec ( $ n - 3 ) ) ; }
function findValues ( $ a , $ b ) { if ( ( $ a - $ b ) % 2 == 1 ) { echo " - 1" ; return ; } echo ( $ a - $ b ) / 2 , " ▁ " , ( $ a + $ b ) / 2 ; }
function printNonConsecutive ( $ n ) { $ p = ( 1 << $ n ) ; for ( $ i = 1 ; $ i < $ p ; $ i ++ ) if ( ( $ i & ( $ i << 1 ) ) == 0 ) echo $ i . " " ; }
function zigzag ( $ n , $ k ) { $ dp = array ( array ( ) ) ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ i - $ j ] ; } return $ dp [ $ n ] [ $ k ] ; }
function countWords ( $ str , $ len ) { $ count = 1 ; if ( $ len == 1 ) return $ count ; if ( $ str [ 0 ] == $ str [ 1 ] ) $ count *= 1 ; else $ count *= 2 ; for ( $ j = 1 ; $ j < $ len - 1 ; $ j ++ ) { if ( $ str [ $ j ] == $ str [ $ j - 1 ] && $ str [ $ j ] == $ str [ $ j + 1 ] ) $ count *= 1 ; else if ( $ str [ $ j ] == $ str [ $ j - 1 ] $ str [ $ j ] == $ str [ $ j + 1 ] $ str [ $ j - 1 ] == $ str [ $ j + 1 ] ) $ count *= 2 ; else $ count *= 3 ; } if ( $ str [ $ len - 1 ] == $ str [ $ len - 2 ] ) $ count *= 1 ; else $ count *= 2 ; return $ count ; }
function xorCalc ( $ k ) { if ( $ k == 1 ) return 2 ; if ( ( ( $ k + 1 ) & $ k ) == 0 ) return floor ( $ k / 2 ) ; return 1 ; }
function maxAND ( $ arr , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ res = max ( $ res , $ arr [ $ i ] & $ arr [ $ j ] ) ; return $ res ; }
function nswp ( $ n ) { if ( $ n == 0 $ n == 1 ) return 1 ; return 2 * nswp ( $ n - 1 ) + nswp ( $ n - 2 ) ; }
function sumOfInternalAngles ( $ n ) { if ( $ n < 3 ) return 0 ; return ( ( $ n - 2 ) * 180 ) ; }
function maxPrefix ( $ s , $ t ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ t ) ; $ i ++ ) { if ( $ count == strlen ( $ s ) ) break ; if ( $ t [ $ i ] == $ s [ $ count ] ) $ count ++ ; } return $ count ; } { $ S = " digger " ; $ T = " biggerdiagram " ; echo maxPrefix ( $ S , $ T ) ; return 0 ; }
function printClosest ( $ arr , $ n , $ x ) { $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; $ diff = PHP_INT_MAX ; while ( $ r > $ l ) { if ( abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) ; } if ( $ arr [ $ l ] + $ arr [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo " ▁ The ▁ closest ▁ pair ▁ is ▁ " , $ arr [ $ res_l ] , " ▁ and ▁ " , $ arr [ $ res_r ] ; }
function solve ( $ a , $ n ) { $ ones = 0 ; $ twos = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ ones ++ ; else $ twos ++ ; } $ ind = 0 ; if ( $ twos ) $ a [ $ ind ++ ] = 2 ; $ evenOnes = ( $ ones % 2 == 0 ) ? true : false ; if ( $ evenOnes ) $ ones -= 1 ; for ( $ i = 0 ; $ i < $ ones ; $ i ++ ) $ a [ $ ind ++ ] = 1 ; for ( $ i = 0 ; $ i < $ twos - 1 ; $ i ++ ) $ a [ $ ind ++ ] = 2 ; if ( $ evenOnes ) $ a [ $ ind ++ ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] , " ▁ " ; }
function countSolutions ( $ n , $ val ) { $ total = 0 ; if ( $ n == 1 && $ val >= 0 ) return 1 ; for ( $ i = 0 ; $ i <= $ val ; $ i ++ ) { $ total += countSolutions ( $ n - 1 , $ val - $ i ) ; } return $ total ; }
function GIF ( $ n ) { return floor ( $ n ) ; }
function gcd ( $ a , $ b ) { if ( $ a < $ b ) return gcd ( $ b , $ a ) ; if ( abs ( $ b ) < 0.001 ) return $ a ; else return ( gcd ( $ b , $ a - floor ( $ a / $ b ) * $ b ) ) ; }
function trianglearea ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = ( 3 * sqrt ( 3 ) * pow ( $ a , 2 ) ) / 4 ; return $ area ; }
function solve ( $ n , $ k ) { if ( $ n >= ( $ k * ( $ k + 1 ) ) / 2 ) { return true ; } return false ; }
function multiplyWith4 ( $ n ) { return ( $ n << 2 ) ; }
function findSmallest ( $ arr , $ n ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ n and $ arr [ $ i ] <= $ res ; $ i ++ ) $ res = $ res + $ arr [ $ i ] ; return $ res ; }
function minSum ( $ A , $ n ) { $ min_val = min ( $ A ) ; return ( $ min_val * ( $ n - 1 ) ) ; }
function calculateAreaSum ( $ l , $ b ) { $ size = 1 ; $ maxSize = min ( $ l , $ b ) ; $ totalArea = 0 ; for ( $ i = 1 ; $ i <= $ maxSize ; $ i ++ ) { $ totalSquares = ( $ l - $ size + 1 ) * ( $ b - $ size + 1 ) ; $ area = $ totalSquares * $ size * $ size ; $ totalArea += $ area ; $ size ++ ; } return $ totalArea ; }
function multiply ( $ n , $ m ) { $ ans = 0 ; $ count = 0 ; while ( $ m ) { if ( $ m % 2 == 1 ) $ ans += $ n << $ count ; $ count ++ ; $ m /= 2 ; } return $ ans ; }
function countZeroes ( $ mat ) { $ row = $ N - 1 ; $ col = 0 ; $ count = 0 ; while ( $ col < $ N ) { while ( $ mat [ $ row ] [ $ col ] ) if ( -- $ row < 0 ) return $ count ; $ count += ( $ row + 1 ) ; $ col ++ ; } return $ count ; }
function magicOfSequence ( $ N ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ sum += ( $ i * $ i * $ i + $ i * 2 ) ; return $ sum ; }
function isUpperTriangularMatrix ( $ mat ) { global $ N ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != 0 ) return false ; return true ; }
function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) + 2 * $ n - 5 ; }
function addNDigits ( $ a , $ b , $ n ) { $ num = $ a ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { $ tmp = $ a * 10 + $ i ; if ( $ tmp % $ b == 0 ) { $ a = $ tmp ; break ; } } if ( $ num == $ a ) return -1 ; for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) $ a *= 10 ; return $ a ; }
function term ( $ n ) { $ x = ( ( ( 1 ) + ( double ) sqrt ( 1 + ( 8 * $ n ) ) ) / 2 ) ; return $ x ; }
function setKthBit ( $ n , $ k ) { return ( ( 1 << $ k ) $ n ) ; }
function cyl ( $ r , $ R , $ h ) { if ( $ h < 0 && $ r < 0 && $ R < 0 ) return -1 ; $ r1 = $ r ; $ h1 = $ h ; $ V = ( 3.14 * pow ( $ r1 , 2 ) * $ h1 ) ; return $ V ; }
function getValueOfF ( $ n ) { if ( $ n == 1 ) return 0 ; if ( $ n == 2 ) return 1 ; $ cnt = 0 ; while ( $ n % 2 == 0 ) { $ cnt += 1 ; $ n /= 2 ; } return 2 * $ cnt ; }
function getSum ( $ n , $ d ) { $ sum = 0 ; while ( $ d <= $ n ) { $ sum += $ d ; $ d += 10 ; } return $ sum ; }
function getCount ( $ a , $ b ) { if ( strlen ( $ b ) % strlen ( $ a ) != 0 ) return -1 ; $ count = floor ( strlen ( $ b ) / strlen ( $ a ) ) ; $ str = " " ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ str = $ str . $ a ; } if ( strcmp ( $ a , $ b ) ) return $ count ; return -1 ; }
function kPresentProbability ( & $ a , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] == $ k ) $ count ++ ; return $ count / $ n ; }
function countCrossLine ( $ arr , $ n ) { $ count_crossline = 0 ; $ i ; $ key ; $ j ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ key = $ arr [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 and $ arr [ $ j ] > $ key ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j = $ j - 1 ; $ count_crossline ++ ; } $ arr [ $ j + 1 ] = $ key ; } return $ count_crossline ; }
function findSum ( $ n ) { if ( $ n % 2 == 0 ) return ( $ n / 2 ) * ( $ n + 1 ) ; else return ( ( $ n + 1 ) / 2 ) * $ n ; }
function count_triples ( $ n , $ k ) { $ i = 0 ; $ j = 0 ; $ l = 0 ; $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { for ( $ l = 1 ; $ l <= $ n ; $ l ++ ) { if ( ( $ i + $ j ) % $ k == 0 && ( $ i + $ l ) % $ k == 0 && ( $ j + $ l ) % $ k == 0 ) $ count ++ ; } } } return $ count ; }
function checking ( $ s ) { $ c = 0 ; $ n = strlen ( $ s ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '0' ) $ c ++ ; if ( $ c >= 6 and $ s [ $ i ] == '1' ) return true ; } return false ; }
function findMinSum ( $ arr , $ n ) { $ occ1 = ( $ n ) ; $ occ = $ occ1 - 1 ; $ Sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ Sum += $ arr [ $ i ] * pow ( 2 , $ occ ) ; $ occ -= 1 ; } return $ Sum ; }
function minParentheses ( $ p ) { $ bal = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < strlen ( $ p ) ; ++ $ i ) { if ( $ p [ $ i ] == ' ( ' ) $ bal += 1 ; else $ bal += -1 ; if ( $ bal == -1 ) { $ ans += 1 ; $ bal += 1 ; } } return $ bal + $ ans ; }
function printFibonacciNumbers ( $ n ) { $ f1 = 0 ; $ f2 = 1 ; $ i ; if ( $ n < 1 ) return ; echo ( $ f1 ) ; echo ( " ▁ " ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { echo ( $ f2 ) ; echo ( " ▁ " ) ; $ next = $ f1 + $ f2 ; $ f1 = $ f2 ; $ f2 = $ next ; } }
function lenoflongestnonpalindrome ( $ s ) { $ max1 = 1 ; $ len = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) - 1 ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ len = 0 ; else if ( $ s [ $ i + 1 ] == $ s [ $ i - 1 ] && $ i > 0 ) $ len = 1 ; $ len ++ ; } if ( $ max1 == 1 ) return 0 ; else return $ max1 ; }
function maxOnesIndex ( $ arr , $ n ) { $ max_count = 0 ; $ max_index ; $ prev_zero = -1 ; $ prev_prev_zero = -1 ; for ( $ curr = 0 ; $ curr < $ n ; ++ $ curr ) { if ( $ arr [ $ curr ] == 0 ) { if ( $ curr - $ prev_prev_zero > $ max_count ) { $ max_count = $ curr - $ prev_prev_zero ; $ max_index = $ prev_zero ; } $ prev_prev_zero = $ prev_zero ; $ prev_zero = $ curr ; } } if ( $ n - $ prev_prev_zero > $ max_count ) $ max_index = $ prev_zero ; return $ max_index ; }
function isDivisibleby17 ( $ n ) { if ( $ n == 0 $ n == 17 ) return true ; if ( $ n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( $ n >> 4 ) - ( int ) ( $ n & 15 ) ) ; }
function profitLoss ( $ N , $ M ) { if ( $ N == $ M ) echo " No ▁ Profit ▁ nor ▁ Loss " ; else { $ result = 0.0 ; $ result = ( abs ( $ N - $ M ) ) / $ M ; if ( $ N - $ M < 0 ) echo " Loss ▁ = ▁ - " , $ result * 100 , " % " ; else echo " Profit ▁ = ▁ " , $ result * 100 , " % " ; } }
function findX ( $ A , $ B ) { $ j = 0 ; $ x = 0 ; while ( $ A $ B ) { if ( ( $ A & 1 ) && ( $ B & 1 ) ) { $ x += ( 1 << $ j ) ; } $ A >>= 1 ; $ B >>= 1 ; $ j += 1 ; } return $ x ; }
function NumberofWays ( $ n ) { $ x = ( 1 * ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; $ y = ( 1 * ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) ) ; return ( 1 * $ x * $ y ) ; }
function smallestSumSubarr ( $ arr , $ n ) { $ min_ending_here = 999999 ; $ min_so_far = 999999 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ min_ending_here > 0 ) $ min_ending_here = $ arr [ $ i ] ; else $ min_ending_here += $ arr [ $ i ] ; $ min_so_far = min ( $ min_so_far , $ min_ending_here ) ; } return $ min_so_far ; }
function countSubStr ( $ S , $ X ) { $ cnt = 0 ; $ N = strlen ( $ S ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { if ( $ S [ $ i ] != '0' ) { for ( $ len = 1 ; ( $ i + $ len ) <= $ N ; ++ $ len ) { $ num = intval ( substr ( $ S , $ i , $ len ) ) ; if ( $ num > $ X ) $ cnt ++ ; } } } return $ cnt ; }
function findMinDifference ( $ arr , $ n ) { sort ( $ arr , 0 ) ; $ diff1 = $ arr [ $ n - 1 ] - $ arr [ 1 ] ; $ diff2 = $ arr [ $ n - 2 ] - $ arr [ 0 ] ; return min ( $ diff1 , $ diff2 ) ; }
function nthTerm ( $ n ) { return pow ( $ n , 2 ) + 2 * $ n + 2 ; }
function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; }
function makeAndCheckString ( $ words , $ str ) { $ n = sizeof ( $ words ) ; $ first = false ; $ second = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ words [ $ i ] == $ str ) return true ; if ( $ str [ 0 ] == $ words [ $ i ] [ 1 ] ) $ first = true ; if ( $ str [ 1 ] == $ words [ $ i ] [ 0 ] ) $ second = true ; if ( $ first && $ second ) return true ; } return false ; }
function minimumflip ( $ mat , $ n ) { global $ N ; $ transpose ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ transpose [ $ i ] [ $ j ] = $ mat [ $ j ] [ $ i ] ; $ flip = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ transpose [ $ i ] [ $ j ] != $ mat [ $ i ] [ $ j ] ) $ flip ++ ; return $ flip / 2 ; }
function search ( $ ar , $ size ) { $ a = 0 ; $ b = $ size - 1 ; $ mid ; while ( ( $ b - $ a ) > 1 ) { $ mid = ( int ) ( ( $ a + $ b ) / 2 ) ; if ( ( $ ar [ $ a ] - $ a ) != ( $ ar [ $ mid ] - $ mid ) ) $ b = $ mid ; else if ( ( $ ar [ $ b ] - $ b ) != ( $ ar [ $ mid ] - $ mid ) ) $ a = $ mid ; } return ( $ ar [ $ a ] + 1 ) ; }
function maxPathSum ( $ tri , $ m , $ n ) { for ( $ i = $ m - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ tri [ $ i + 1 ] [ $ j ] > $ tri [ $ i + 1 ] [ $ j + 1 ] ) $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j ] ; else $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j + 1 ] ; } } return $ tri [ 0 ] [ 0 ] ; }
function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : $ n * factorial ( $ n - 1 ) ; }
function findMissing ( $ arr , $ n ) { $ l = 0 ; $ h = $ n - 1 ; while ( $ h > $ l ) { $ mid = floor ( $ l + ( $ h - $ l ) / 2 ) ; if ( $ arr [ $ mid ] - $ mid == $ arr [ 0 ] ) { if ( $ arr [ $ mid + 1 ] - $ arr [ $ mid ] > 1 ) return $ arr [ $ mid ] + 1 ; else { $ l = $ mid + 1 ; } } else { if ( $ arr [ $ mid ] - $ arr [ $ mid - 1 ] > 1 ) return $ arr [ $ mid ] - 1 ; else { $ h = $ mid - 1 ; } } } return -1 ; }
function lucas ( $ n ) { $ a = 2 ; $ b = 1 ; $ c ; $ i ; if ( $ n == 0 ) return $ a ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ b ; }
function printMaxOfMin ( $ arr , $ n ) { for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) { $ maxOfMin = PHP_INT_MIN ; for ( $ i = 0 ; $ i <= $ n - $ k ; $ i ++ ) { $ min = $ arr [ $ i ] ; for ( $ j = 1 ; $ j < $ k ; $ j ++ ) { if ( $ arr [ $ i + $ j ] < $ min ) $ min = $ arr [ $ i + $ j ] ; } if ( $ min > $ maxOfMin ) $ maxOfMin = $ min ; } echo $ maxOfMin , " " ; } }
function gcd ( $ a , $ b ) { if ( $ a == $ b ) return $ a ; if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; { return gcd ( $ a >> 1 , $ b ) ; return gcd ( $ a >> 1 , $ b >> 1 ) << 1 ; } return gcd ( $ a , $ b >> 1 ) ; if ( $ a > $ b ) return gcd ( ( $ a - $ b ) >> 1 , $ b ) ; return gcd ( ( $ b - $ a ) >> 1 , $ a ) ; }
function longestAlternating ( $ arr , $ n ) { $ count = array ( ) ; $ count [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] * $ arr [ $ i + 1 ] < 0 ) $ count [ $ i ] = $ count [ $ i + 1 ] + 1 ; else $ count [ $ i ] = 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ count [ $ i ] , " ▁ " ; }
function findSingle ( $ ar , $ ar_size ) { $ res = $ ar [ 0 ] ; for ( $ i = 1 ; $ i < $ ar_size ; $ i ++ ) $ res = $ res ^ $ ar [ $ i ] ; return $ res ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 3 ) + pow ( $ n , 2 ) ; }
function minReplacement ( $ s , $ len ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ i % 2 == 0 && $ s [ $ i ] == '1' ) $ ans ++ ; if ( $ i % 2 == 1 && $ s [ $ i ] == '0' ) $ ans ++ ; } return min ( $ ans , $ len - $ ans ) ; }
function countDigits ( $ a , $ b ) { $ count = 0 ; $ p = abs ( $ a * $ b ) ; if ( $ p == 0 ) return 1 ; while ( $ p > 0 ) { $ count ++ ; $ p = ( int ) ( $ p / 10 ) ; } return $ count ; }
function rainDayProbability ( $ a , $ n ) { $ count = 0 ; $ m ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ count ++ ; } $ m = $ count / $ n ; return $ m ; }
function get_max_splits ( $ num_string ) { $ count = 0 ; $ running_sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num_string ) ; $ i ++ ) { $ current_num = intval ( $ num_string [ $ i ] ) ; $ running_sum += $ current_num ; if ( $ current_num % 3 == 0 or ( $ running_sum != 0 and $ running_sum % 3 == 0 ) ) { $ count += 1 ; $ running_sum = 0 ; } } return $ count ; }
function isDudeney ( $ n ) { $ cube_rt = floor ( round ( ( pow ( $ n , 1.0 / 3.0 ) ) ) ) ; if ( $ cube_rt * $ cube_rt * $ cube_rt != $ n ) return false ; $ dig_sum = 0 ; $ temp = $ n ; while ( $ temp > 0 ) { $ rem = $ temp % 10 ; $ dig_sum += $ rem ; $ temp = $ temp / 10 ; } if ( $ cube_rt != $ dig_sum ) return false ; return true ; }
function numbersWith3Divisors ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; $ prime [ 0 ] = $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } echo " Numbers ▁ with ▁ 3 ▁ divisors ▁ : STRNEWLINE " ; for ( $ i = 0 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ prime [ $ i ] ) echo $ i * $ i . " ▁ " ; }
function isPrime ( $ n , $ i = 2 ) { if ( $ n <= 2 ) return ( $ n == 2 ) ? true : false ; if ( $ n % $ i == 0 ) return false ; if ( $ i * $ i > $ n ) return true ; return isPrime ( $ n , $ i + 1 ) ; }
function modFact ( $ n , $ p ) { if ( $ n >= $ p ) return 0 ; $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ result = ( $ result * $ i ) % $ p ; return $ result ; }
function printPairs ( $ arr , $ n , $ k ) { $ isPairFound = true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i != $ j && $ arr [ $ i ] % $ arr [ $ j ] == $ k ) { echo " ( " , $ arr [ $ i ] , " , ▁ " , $ arr [ $ j ] , " ) " , " ▁ " ; $ isPairFound = true ; } } } return $ isPairFound ; }
function findMaxValue ( & $ mat ) { global $ N ; $ maxValue = PHP_INT_MIN ; for ( $ a = 0 ; $ a < $ N - 1 ; $ a ++ ) for ( $ b = 0 ; $ b < $ N - 1 ; $ b ++ ) for ( $ d = $ a + 1 ; $ d < $ N ; $ d ++ ) for ( $ e = $ b + 1 ; $ e < $ N ; $ e ++ ) if ( $ maxValue < ( $ mat [ $ d ] [ $ e ] - $ mat [ $ a ] [ $ b ] ) ) $ maxValue = $ mat [ $ d ] [ $ e ] - $ mat [ $ a ] [ $ b ] ; return $ maxValue ; }
function isDivBy2PowerM ( $ n , $ m ) { if ( ( $ n & ( ( 1 << $ m ) - 1 ) ) == 0 ) return true ; return false ; }
function rectanglearea ( $ a , $ b ) { if ( $ a < 0 or $ b < 0 ) return -1 ; return 2 * $ a * $ b ; }
function sph ( $ r , $ R , $ h ) { if ( $ r < 0 && $ R < 0 && $ h < 0 ) return -1 ; $ x = $ r ; $ V = ( 4 * 3.14 * pow ( $ r , 3 ) ) / 3 ; return $ V ; }
function getFinalElement ( $ n ) { $ finalNum = 0 ; for ( $ finalNum = 2 ; ( $ finalNum * 2 ) <= $ n ; $ finalNum *= 2 ) ; return $ finalNum ; }
function weightedMean ( $ n ) { return ( 2 * $ n + 1 ) / 3 ; }
function finalPosition ( $ move ) { $ l = strlen ( $ move ) ; $ countUp = 0 ; $ countDown = 0 ; $ countLeft = 0 ; $ countRight = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ move [ $ i ] == ' U ' ) $ countUp ++ ; else if ( $ move [ $ i ] == ' D ' ) $ countDown ++ ; else if ( $ move [ $ i ] == ' L ' ) $ countLeft ++ ; else if ( $ move [ $ i ] == ' R ' ) $ countRight ++ ; } echo " Final ▁ Position : ▁ ( " . ( $ countRight - $ countLeft ) . " , " ▁ , ▁ ( $ countUp ▁ - ▁ $ countDown ) ▁ . ▁ " ) " ▁ . " " }
function pairInSortedRotated ( $ arr , $ n , $ x ) { $ i ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) break ; $ l = ( $ i + 1 ) % $ n ; $ r = $ i ; while ( $ l != $ r ) { if ( $ arr [ $ l ] + $ arr [ $ r ] == $ x ) return true ; if ( $ arr [ $ l ] + $ arr [ $ r ] < $ x ) $ l = ( $ l + 1 ) % $ n ; else $ r = ( $ n + $ r - 1 ) % $ n ; } return false ; }
function arrayEvenAndOdd ( $ arr , $ n ) { $ i = -1 ; $ j = 0 ; $ t ; while ( $ j != $ n ) { if ( $ arr [ $ j ] % 2 == 0 ) { $ i ++ ; $ x = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ x ; } $ j ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . " ▁ " ; }
function getPairs ( $ a ) { $ count = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ a ) ; $ i ++ ) { for ( $ j = 0 ; $ j < sizeof ( $ a ) ; $ j ++ ) { if ( $ a [ $ i ] < $ a [ $ j ] ) $ count ++ ; } } return $ count ; }
function AlternateRearrange ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 == 0 ) array_push ( $ v1 , $ arr [ $ i ] ) ; else array_push ( $ v2 , $ arr [ $ i ] ) ; $ index = 0 ; $ i = 0 ; $ j = 0 ; $ flag = false ; if ( $ arr [ 0 ] % 2 == 0 ) $ flag = true ; while ( $ index < $ n ) { if ( $ flag == true ) { $ arr [ $ index ++ ] = $ v1 [ $ i ++ ] ; $ flag = ! $ flag ; } else { $ arr [ $ index ++ ] = $ v2 [ $ j ++ ] ; $ flag = ! $ flag ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , " ▁ " ; }
function findMinimumCost ( $ n , $ x , $ y ) { $ dp [ $ n + 1 ] = array ( ) ; $ dp [ 1 ] = $ x ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i & 1 ) { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] + $ x , $ dp [ ( $ i + 1 ) / 2 ] + $ y + $ x ) ; } else { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] + $ x , $ dp [ $ i / 2 ] + $ y ) ; } } return $ dp [ $ n ] ; }
function Nth_of_AP ( $ a , $ d , $ N ) { return ( $ a + ( $ N - 1 ) * $ d ) ; }
function largestPalinSub ( $ s ) { $ res = " " ; $ mx = $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ mx = max ( $ mx , $ s [ $ i ] ) ; } for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ mx ) { $ res . = $ s [ $ i ] ; } } return $ res ; }
function countP ( $ n , $ k ) { if ( $ n == 0 $ k == 0 $ k > $ n ) return 0 ; if ( $ k == 1 $ k == $ n ) return 1 ; return $ k * countP ( $ n - 1 , $ k ) + countP ( $ n - 1 , $ k - 1 ) ; }
function dupLastIndex ( $ arr , $ n ) { if ( $ arr == null or $ n <= 0 ) return ; for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) { echo " Last ▁ index : " , $ i , " STRNEWLINE " ; echo " Last ▁ duplicate ▁ item : " , $ arr [ $ i ] ; return ; } } echo " no ▁ duplicate ▁ found " ; }
function Kroneckerproduct ( $ A , $ B ) { global $ cola ; global $ rowa ; global $ colb ; global $ rowb ; $ C ; for ( $ i = 0 ; $ i < $ rowa ; $ i ++ ) { for ( $ k = 0 ; $ k < $ rowb ; $ k ++ ) { for ( $ j = 0 ; $ j < $ cola ; $ j ++ ) { for ( $ l = 0 ; $ l < $ colb ; $ l ++ ) { $ C [ $ i + $ l + 1 ] [ $ j + $ k + 1 ] = $ A [ $ i ] [ $ j ] * $ B [ $ k ] [ $ l ] ; echo ( $ C [ $ i + $ l + 1 ] [ $ j + $ k + 1 ] ) , " TABSYMBOL " ; } } echo " STRNEWLINE " ; } } }
function isPentagonal ( int $ N ) { $ i = 1 ; $ M ; do { $ M = ( 3 * $ i * $ i - $ i ) / 2 ; $ i += 1 ; } while ( $ M < $ N ) ; return ( $ M == $ N ) ; }
function rearrange ( & $ arr , $ n ) { $ max_idx = $ n - 1 ; $ min_idx = 0 ; $ max_elem = $ arr [ $ n - 1 ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) { $ arr [ $ i ] += ( $ arr [ $ max_idx ] % $ max_elem ) * $ max_elem ; $ max_idx -- ; } else { $ arr [ $ i ] += ( $ arr [ $ min_idx ] % $ max_elem ) * $ max_elem ; $ min_idx ++ ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = ( int ) ( $ arr [ $ i ] / $ max_elem ) ; }
function getTotalXorOfSubarrayXors ( $ arr , $ N ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i ; $ j < $ N ; $ j ++ ) for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) $ res = $ res ^ $ arr [ $ k ] ; return $ res ; }
function no_of_digit ( $ a , $ b ) { return ( ( int ) ( $ b * log10 ( $ a ) ) + 1 ) ; }
function minSum ( $ arr , $ n ) { $ sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) { $ j = $ i ; while ( $ j < $ n && $ arr [ $ j ] <= $ arr [ $ j - 1 ] ) { $ arr [ $ j ] = $ arr [ $ j ] + 1 ; $ j ++ ; } } $ sum = $ sum + $ arr [ $ i ] ; } return $ sum ; }
function replace_elements ( $ arr , $ n ) { $ pos = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ pos ++ ] = $ arr [ $ i ] ; while ( $ pos > 1 && $ arr [ $ pos - 2 ] == $ arr [ $ pos - 1 ] ) { $ pos -- ; $ arr [ $ pos - 1 ] ++ ; } } for ( $ i = 0 ; $ i < $ pos ; $ i ++ ) echo $ arr [ $ i ] . " ▁ " ; }
function sum_series ( $ n ) { $ nSquare = $ n * $ n ; return $ nSquare * ( $ nSquare - 1 ) / 4 ; }
function countDivisors ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) + 1 ; $ i ++ ) { if ( $ n % $ i == 0 ) $ count += ( $ n / $ i == $ i ) ? 1 : 2 ; } if ( $ count % 2 == 0 ) echo " Even STRNEWLINE " ; else echo " Odd STRNEWLINE " ; }
function floorSqrt ( $ x ) { if ( $ x == 0 $ x == 1 ) return $ x ; $ i = 1 ; $ result = 1 ; while ( $ result <= $ x ) { $ i ++ ; $ result = $ i * $ i ; } return $ i - 1 ; }
function isConvertible ( $ str1 , $ str2 , $ k ) { if ( ( strlen ( $ str1 ) + strlen ( $ str2 ) ) < $ k ) return true ; $ commonLength = 0 ; for ( $ i = 0 ; $ i < min ( strlen ( $ str1 ) , strlen ( $ str2 ) ) ; $ i ++ ) { if ( $ str1 == $ str2 ) $ commonLength += 1 ; else break ; } if ( ( $ k - strlen ( $ str1 ) - strlen ( $ str2 ) + 2 * $ commonLength ) % 2 == 0 ) return true ; return false ; }
function checksum ( $ n ) { if ( $ n % 3 == 0 ) echo $ n / 3 - 1 , " ▁ " , $ n / 3 , " ▁ " , $ n / 3 + 1 ; else echo " - 1" ; }
function evenbittogglenumber ( $ n ) { $ res = 0 ; $ count = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 0 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return $ n ^ $ res ; }
function partitions ( $ n ) { $ p = array_fill ( 0 , $ n + 1 , 0 ) ; $ p [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) { $ k = 1 ; while ( ( $ k * ( 3 * $ k - 1 ) ) / 2 <= $ i ) { $ p [ $ i ] += ( ( $ k % 2 ? 1 : -1 ) * $ p [ $ i - ( $ k * ( 3 * $ k - 1 ) ) / 2 ] ) ; if ( $ k > 0 ) $ k *= -1 ; else $ k = 1 - $ k ; } } return $ p [ $ n ] ; }
function findEdges ( $ s1 , $ s2 , $ s3 ) { $ a = sqrt ( $ s1 * $ s2 / $ s3 ) ; $ b = sqrt ( $ s3 * $ s1 / $ s2 ) ; $ c = sqrt ( $ s3 * $ s2 / $ s1 ) ; $ sum = $ a + $ b + $ c ; return 4 * $ sum ; }
function getSingle ( $ arr , $ n ) { $ ones = 0 ; $ twos = 0 ; $ common_bit_mask ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ twos = $ twos | ( $ ones & $ arr [ $ i ] ) ; $ ones = $ ones ^ $ arr [ $ i ] ; $ common_bit_mask = ~ ( $ ones & $ twos ) ; $ ones &= $ common_bit_mask ; $ twos &= $ common_bit_mask ; } return $ ones ; }
function calculateSum ( $ n ) { return ( pow ( 2 , $ n + 1 ) + $ n - 2 ) ; }
function countPairs ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ product = $ arr [ $ i ] * $ arr [ $ j ] ; for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ k ] == $ product ) { $ result ++ ; break ; } } } } return $ result ; }
function minimumSets ( $ s , $ y ) { $ cnt = 0 ; $ num = 0 ; $ l = strlen ( $ s ) ; $ f = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { $ num = $ num * 10 + ( $ s [ $ i ] - '0' ) ; if ( $ num <= $ y ) $ f = 1 ; { if ( $ f ) $ cnt += 1 ; $ num = $ s [ $ i ] - '0' ; $ f = 0 ; if ( $ num <= $ y ) $ f = 1 ; else $ num = 0 ; } } if ( $ f ) $ cnt += 1 ; return $ cnt ; }
function count9s ( $ number ) { $ count = 0 ; $ n = strlen ( $ number ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ number [ $ i ] - '0' ; if ( $ number [ $ i ] == '9' ) $ count ++ ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ sum = ( $ sum + $ number [ $ j ] - '0' ) % 9 ; if ( $ sum == 0 ) $ count ++ ; } } return $ count ; }
function findCount ( $ d ) { return 9 * ( pow ( 10 , $ d - 1 ) - pow ( 9 , $ d - 1 ) ) ; } { $ d = 1 ; echo findCount ( $ d ) , " STRNEWLINE " ; $ d = 2 ; echo findCount ( $ d ) , " STRNEWLINE " ; $ d = 4 ; echo findCount ( $ d ) , " STRNEWLINE " ; return 0 ; }
function maxSumLCM ( $ n ) { $ max_sum = 0 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ max_sum += $ i ; if ( $ n / $ i != $ i ) $ max_sum += ( $ n / $ i ) ; } } return $ max_sum ; }
function surface_area_octahedron ( $ side ) { return ( 2 * ( sqrt ( 3 ) ) * ( $ side * $ side ) ) ; }
function isMultipleOf4 ( $ n ) { if ( $ n == 1 ) return false ; $ XOR = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ XOR = $ XOR ^ $ i ; return ( $ XOR == $ n ) ; }
function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; }
function LCIS ( $ arr1 , $ n , $ arr2 , $ m ) { $ table = Array ( ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) $ table [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current = 0 ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ arr1 [ $ i ] == $ arr2 [ $ j ] ) if ( $ current + 1 > $ table [ $ j ] ) $ table [ $ j ] = $ current + 1 ; if ( $ arr1 [ $ i ] > $ arr2 [ $ j ] ) if ( $ table [ $ j ] > $ current ) $ current = $ table [ $ j ] ; } } $ result = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ table [ $ i ] > $ result ) $ result = $ table [ $ i ] ; return $ result ; }
function sumOfTheSeries ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; }
function count_minimum_operations ( $ n ) { $ count = 0 ; while ( $ n > 1 ) { if ( $ n % 3 == 0 ) $ n /= 3 ; else if ( $ n % 3 == 1 ) $ n -- ; else { if ( $ n == 2 ) $ n -- ; else $ n ++ ; } $ count ++ ; } return $ count ; }
function countOfMultiples ( $ n ) { return floor ( floor ( $ n / 3 ) + floor ( $ n / 5 ) - floor ( $ n / 15 ) ) ; }
function findLarger ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = $ n - 1 ; $ i >= $ n / 2 ; $ i -- ) echo $ arr [ $ i ] , " ▁ " ; }
function Preprocess ( $ A , $ B ) { $ n = strlen ( $ A ) ; $ ans = 0 ; $ mp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mp [ $ A [ $ i ] ] = 0 ; for ( $ i = 0 ; $ i < floor ( $ n / 2 ) ; $ i ++ ) { $ mp [ $ A [ $ i ] ] ++ ; $ mp [ $ A [ $ n - $ i - 1 ] ] ++ ; $ mp [ $ B [ $ i ] ] ++ ; $ mp [ $ B [ $ n - $ i - 1 ] ] ++ ; $ sz = sizeof ( $ mp ) ; if ( $ sz == 4 ) $ ans += 2 ; else if ( $ sz == 3 ) if ( $ A [ $ i ] == $ A [ $ n - $ i - 1 ] ) $ ans += 1 ; else $ ans += 1 ; else if ( $ sz == 2 ) $ ans += $ mp [ $ A [ $ i ] ] != 2 ; } if ( $ n % 2 == 1 && ( $ A [ floor ( $ n / 2 ) ] != $ B [ floor ( $ n / 2 ) ] ) ) $ ans ++ ; return $ ans ; }
function countPairs ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ ans ++ ; return $ ans ; }
function precomputation ( $ arr , $ n ) { global $ max_Element , $ sum3 , $ sum2 , $ sum1 ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum1 [ $ j ] += $ i ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum2 [ $ j ] += ( $ sum1 [ $ j ] - $ i ) * $ i ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) $ sum2 [ $ i ] = ( int ) ( $ sum2 [ $ i ] / 2 ) ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum3 [ $ j ] += $ i * ( $ sum2 [ $ j ] - $ i * ( $ sum1 [ $ j ] - $ i ) ) ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) $ sum3 [ $ i ] = ( int ) ( $ sum3 [ $ i ] / 3 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ sum3 [ $ arr [ $ i ] ] . " ▁ " ; }
function findpair ( $ l , $ r ) { $ c = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j <= $ r ; $ j ++ ) { if ( $ j % $ i == 0 && $ j != $ i ) { echo ( $ i . " , ▁ " . $ j ) ; $ c = 1 ; break ; } } if ( $ c == 1 ) break ; } }
function findLUSlength ( $ a , $ b ) { if ( ! strcmp ( $ a , $ b ) ) return 0 ; return max ( strlen ( $ a ) , strlen ( $ b ) ) ; }
function gouldSequence ( $ n ) { for ( $ row_num = 1 ; $ row_num <= $ n ; $ row_num ++ ) { $ count = 1 ; $ c = 1 ; for ( $ i = 1 ; $ i <= $ row_num ; $ i ++ ) { $ c = $ c * ( $ row_num - $ i ) / $ i ; if ( $ c % 2 == 1 ) $ count ++ ; } echo $ count , " " ; } }
function asPowerSum ( $ w , $ m ) { while ( $ m ) { if ( ( $ m - 1 ) % $ w == 0 ) $ m = ( $ m - 1 ) / $ w ; else if ( ( $ m + 1 ) % $ w == 0 ) $ m = ( $ m + 1 ) / $ w ; else if ( $ m % $ w == 0 ) $ m = $ m / $ w ; else } return ( $ m == 0 ) ; }
function largestPower ( $ n , $ p ) { $ x = 0 ; while ( $ n ) { $ n = ( int ) $ n / $ p ; $ x += $ n ; } return floor ( $ x ) ; }
function circlearea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; if ( $ l < $ b ) return 3.14 * pow ( $ l / 2 , 2 ) ; else return 3.14 * pow ( $ b / 2 , 2 ) ; }
function centeredHexagonalNumber ( $ n ) { return 3 * $ n * ( $ n - 1 ) + 1 ; }
function countTripletsLessThanL ( $ n , $ L , $ arr ) { sort ( $ arr ) ; $ ways = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { $ mostDistantDistance = $ arr [ $ k ] - $ arr [ $ i ] ; if ( $ mostDistantDistance <= $ L ) { $ ways ++ ; } } } } return $ ways ; }
function Squares ( $ n , $ m , $ a ) { return ( ( int ) ( ( $ m + $ a - 1 ) / $ a ) ) * ( ( int ) ( ( $ n + $ a - 1 ) / $ a ) ) ; }
function minInsertions ( $ H , $ n , $ K ) { $ inser = 0 ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) { $ diff = abs ( $ H [ $ i ] - $ H [ $ i - 1 ] ) ; if ( $ diff <= $ K ) continue ; else $ inser += ceil ( $ diff / $ K ) - 1 ; } return $ inser ; }
function findVolume ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = $ a / 2 ; $ h = $ a ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; }
function power ( $ n ) { if ( $ n == 1 ) return 2 ; return 2 * power ( $ n - 1 ) ; } { $ n = 4 ; echo ( power ( $ n ) ) ; } }
function oddbitsetnumber ( $ n ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 0 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n $ res ) ; }
function octaside ( $ a ) { if ( $ a < 0 ) return -1 ; $ s = $ a / ( sqrt ( 2 ) + 1 ) ; return $ s ; }
function productOfSingelDgt ( $ n , $ SIZE ) { if ( $ n >= 0 && $ n <= 9 ) return true ; $ prime = array ( 2 , 3 , 5 , 7 ) ; for ( $ i = 0 ; $ i < $ SIZE && $ n > 1 ; $ i ++ ) while ( $ n % $ prime [ $ i ] == 0 ) $ n = $ n / $ prime [ $ i ] ; return ( $ n == 1 ) ; }
function seriesSum ( $ n ) { $ i = 1 ; $ res = 0.0 ; $ sign = true ; while ( $ n > 0 ) { $ n -- ; if ( $ sign ) { $ sign = ! $ sign ; $ res = $ res + ( double ) ++ $ i / ++ $ i ; } else { $ sign = ! $ sign ; $ res = $ res - ( double ) ++ $ i / ++ $ i ; } } return $ res ; }
function countarray ( $ n , $ k , $ x ) { $ dp = array ( 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = ( $ k - 2 ) * $ dp [ $ i - 1 ] + ( $ k - 1 ) * $ dp [ $ i - 2 ] ; return ( $ x == 1 ? ( $ k - 1 ) * $ dp [ $ n - 2 ] : $ dp [ $ n - 1 ] ) ; }
function intToRoman ( $ num ) { $ m = array ( " " , " M " , " MM " , " MMM " ) ; $ c = array ( " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM " ) ; $ x = array ( " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " ) ; $ i = array ( " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " ) ; $ thousands = $ m [ $ num / 1000 ] ; $ hundereds = $ c [ ( $ num % 1000 ) / 100 ] ; $ tens = $ x [ ( $ num % 100 ) / 10 ] ; $ ones = $ i [ $ num % 10 ] ; $ ans = $ thousands . $ hundereds . $ tens . $ ones ; return $ ans ; }
function fnMod ( $ n ) { $ rem = $ n % 4 ; if ( $ rem == 0 or $ rem == 3 ) return 0 ; else if ( $ rem == 1 or $ rem == 2 ) return 1 ; }
function alternateFib ( $ n ) { if ( $ n < 0 ) return ; $ f1 = 0 ; $ f2 = 1 ; echo $ f1 . " " ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ f3 = $ f2 + $ f1 ; if ( $ i % 2 == 0 ) echo $ f3 . " " ; $ f1 = $ f2 ; $ f2 = $ f3 ; } }
function convert ( $ s ) { $ n = strlen ( $ s ) ; $ s [ 0 ] = strtolower ( $ s [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' ▁ ' && $ i < $ n ) { $ s [ $ i + 1 ] = strtolower ( $ s [ $ i + 1 ] ) ; $ i ++ ; } else $ s [ $ i ] = strtoupper ( $ s [ $ i ] ) ; } return $ s ; }
function noOfTriples ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ 2 ] ) $ count ++ ; if ( $ arr [ 0 ] == $ arr [ 2 ] ) return ( $ count - 2 ) * ( $ count - 1 ) * ( $ count ) / 6 ; else if ( $ arr [ 1 ] == $ arr [ 2 ] ) return ( $ count - 1 ) * ( $ count ) / 2 ; return $ count ; }
function findArea ( $ d ) { return ( $ d * $ d ) / 2 ; }
function breakEvenPoint ( $ exp , $ S , $ M ) { $ earn = $ S - $ M ; $ res = ceil ( $ exp / $ earn ) ; return $ res ; }
function findSteps ( $ n , $ m , $ a ) { $ cur = 1 ; $ steps = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ a [ $ i ] >= $ cur ) $ steps += ( $ a [ $ i ] - $ cur ) ; else $ steps += ( $ n - $ cur + $ a [ $ i ] ) ; $ cur = $ a [ $ i ] ; } return $ steps ; }
function NthTerm ( $ n ) { $ mod = 1000000009 ; $ x = ( 3 * $ n * $ n ) % $ mod ; return ( $ x - $ n + $ mod ) % $ mod ; }
function areEqual ( $ arr1 , $ arr2 , $ n , $ m ) { if ( $ n != $ m ) return false ; sort ( $ arr1 ) ; sort ( $ arr2 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] != $ arr2 [ $ i ] ) return false ; return true ; }
function check ( $ n , $ marks ) { $ x = max ( $ marks ) ; $ bonus = 100 - $ x ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ marks [ $ i ] + $ bonus >= 50 ) $ c += 1 ; } return $ c ; }
function fourthPowerSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + ( $ i * $ i * $ i * $ i ) ; return $ sum ; }
function procal ( $ n ) { return ( 3.0 * $ n ) / ( 4.0 * ( $ n * $ n ) - 1 ) ; }
function checkEVENodd ( $ arr , $ n , $ l , $ r ) { if ( $ arr [ $ r ] == 1 ) echo " odd " , " STRNEWLINE " ; else echo " even " , " STRNEWLINE " ; }
function solve ( $ a , $ n ) { $ max1 = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( abs ( $ a [ $ i ] - $ a [ $ j ] ) > $ max1 ) { $ max1 = abs ( $ a [ $ i ] - $ a [ $ j ] ) ; } } } return $ max1 ; }
function ifPossible ( & $ arr , $ n ) { $ cp = array ( ) ; $ cp = $ arr ; sort ( $ cp ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! ( $ arr [ $ i ] == $ cp [ $ i ] ) && ! ( $ arr [ $ n - 1 - $ i ] == $ cp [ $ i ] ) ) return false ; } return true ; }
function solution ( $ a , $ b , $ n ) { for ( $ i = 0 ; $ i * $ a <= $ n ; $ i ++ ) { if ( ( $ n - ( $ i * $ a ) ) % $ b == 0 ) { echo " x = " ▁ , ▁ $ i ▁ , ▁ " , y = " ( $ n - ( $ i * $ a ) ) / $ b ; return ; } } echo " No ▁ solution " ; }
function countPairs ( $ a , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( $ a [ $ j ] - $ a [ $ i ] ) < $ k ) $ res ++ ; return $ res ; }
function getSingle ( $ arr , $ n ) { global $ INT_SIZE ; $ result = 0 ; $ x ; $ sum ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) { $ sum = 0 ; $ x = ( 1 << $ i ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] & $ x ) $ sum ++ ; } if ( ( $ sum % 3 ) != 0 ) $ result |= $ x ; } return $ result ; }
function FirstAndLast ( $ str ) { $ ch = $ str ; for ( $ i = 0 ; $ i < strlen ( $ ch ) ; $ i ++ ) { $ k = $ i ; while ( $ i < strlen ( $ ch ) && $ ch [ $ i ] != ' ▁ ' ) $ i ++ ; $ ch [ $ k ] = chr ( ( $ ch [ $ k ] >= ' a ' && $ ch [ $ k ] <= ' z ' ) ? ( ord ( $ ch [ $ k ] ) - 32 ) : ( ord ( $ ch [ $ k ] ) ) ) ; $ ch [ $ i - 1 ] = chr ( ( $ ch [ $ i - 1 ] >= ' a ' && $ ch [ $ i - 1 ] <= ' z ' ) ? ( ord ( $ ch [ $ i - 1 ] ) - 32 ) : ( ord ( $ ch [ $ i - 1 ] ) ) ) ; } return $ ch ; }
function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; sort ( $ arr ) ; $ l = 0 ; $ r = 0 ; while ( $ r < $ n ) { if ( $ arr [ $ r ] - $ arr [ $ l ] == $ k ) { $ count ++ ; $ l ++ ; $ r ++ ; } else if ( $ arr [ $ r ] - $ arr [ $ l ] > $ k ) $ l ++ ; else $ r ++ ; } return $ count ; }
function find ( $ n , $ k ) { if ( $ n + 1 >= $ k ) return ( $ k - 1 ) ; else return ( 2 * $ n + 1 - $ k ) ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; if ( ( $ str [ $ n - 1 ] - '0' ) % 2 != 0 ) return false ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 3 == 0 ) ; }
function motzkin ( $ n ) { if ( $ n == 0 $ n == 1 ) return 1 ; return ( ( 2 * $ n + 1 ) * motzkin ( $ n - 1 ) + ( 3 * $ n - 3 ) * motzkin ( $ n - 2 ) ) / ( $ n + 2 ) ; }
function Check_is_possible ( $ l , $ r , $ k ) { $ div_count = ( int ) ( $ r / $ k ) - ( int ) ( $ l / $ k ) ; if ( $ l % $ k == 0 ) $ div_count ++ ; return ( $ div_count > 1 ) ; }
function Nonagonal ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo $ i * ( 7 * $ i - 5 ) / 2 ; echo " ▁ " ; } }
function averageValue ( $ s ) { $ sum_char = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ sum_char += ord ( $ s [ $ i ] ) ; } return ( int ) ( $ sum_char / strlen ( $ s ) ) ; }
function check ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ s [ $ i ] > $ s [ $ i + 1 ] ) return true ; } return false ; }
function minIndex ( $ arr , $ n , $ pos ) { $ num = $ arr [ $ pos ] ; $ i = $ pos - 1 ; while ( $ i >= 0 ) { if ( $ arr [ $ i ] != $ num ) break ; $ i -- ; } return $ i + 1 ; }
function toggleLastMBits ( $ n , $ m ) { $ num = ( 1 << $ m ) - 1 ; return ( $ n ^ $ num ) ; } { $ n = 107 ; $ m = 4 ; echo toggleLastMBits ( $ n , $ m ) ; return 0 ; }
function printGolomb ( $ n ) { $ dp [ 1 ] = 1 ; echo $ dp [ 1 ] , " " ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = 1 + $ dp [ $ i - $ dp [ $ dp [ $ i - 1 ] ] ] ; echo $ dp [ $ i ] , " " ; } }
function calcScore ( $ str ) { $ score = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len { $ chunkSize = 1 ; $ currentChar = $ str [ $ i ++ ] ; while ( $ i < $ len && $ str [ $ i ] == $ currentChar ) { $ chunkSize ++ ; $ i ++ ; } if ( $ currentChar == '1' ) $ score += pow ( $ chunkSize , 2 ) ; else $ score -= pow ( $ chunkSize , 2 ) ; } return $ score ; }
function getModulo ( $ n , $ d ) { return ( $ n & ( $ d - 1 ) ) ; }
function bankNotes ( $ A , $ B , $ S , $ N ) { $ numerator = $ S - ( $ B * $ N ) ; $ denominator = $ A - $ B ; if ( $ numerator % $ denominator == 0 ) return ( $ numerator / $ denominator ) ; return -1 ; }
function sumOfSeries ( $ n ) { return ( $ n * ( 2 * $ n - 1 ) * ( 2 * $ n + 1 ) ) / 3 ; }
function isNumber ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) if ( is_numeric ( $ s [ $ i ] ) == false ) return false ; return true ; }
function solve ( $ s1 , $ s2 ) { if ( strlen ( $ s1 ) != strlen ( $ s2 ) ) return false ; $ l = strlen ( $ s1 ) ; for ( $ i = 0 ; $ i < 1 ; $ i ++ ) { if ( $ s1 [ $ i ] == '1' ) $ flag1 = 1 ; if ( $ s2 [ $ i ] == '1' ) $ flag2 = 1 ; if ( ! $ flag1 && ! $ flag2 ) return true ; } return false ; }
function sum ( $ a , $ b ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= min ( $ a , $ b ) ; $ i ++ ) if ( $ a % $ i == 0 && $ b % $ i == 0 ) $ sum += $ i ; return $ sum ; }
function checkPalindrome ( $ str ) { $ n = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; ++ $ i ) if ( $ str [ $ i ] != $ str [ $ n - $ i - 1 ] ) ++ $ count ; return ( $ count <= 1 ) ; } { $ str = " abccaa " ; if ( checkPalindrome ( $ str ) ) echo " Yes " ; else echo " No " ; return 0 ; }
function avgOfFirstN ( $ n ) { return ( float ) ( 1 + $ n ) / 2 ; }
function area ( $ a , $ b , $ c ) { $ d = abs ( ( $ c * $ c ) / ( 2 * $ a * $ b ) ) ; return $ d ; }
function getTotalNumberOfSequences ( $ m , $ n ) { if ( $ m < $ n ) return 0 ; if ( $ n == 0 ) return 1 ; return getTotalNumberOfSequences ( $ m - 1 , $ n ) + getTotalNumberOfSequences ( $ m / 2 , $ n - 1 ) ; }
function evenFib ( $ n ) { if ( $ n < 1 ) return $ n ; if ( $ n == 1 ) return 2 ; return ( ( 4 * evenFib ( $ n - 1 ) ) + evenFib ( $ n - 2 ) ) ; }
function isPowerOfTwo ( $ x ) { return $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ; }
function possibleStrings ( $ n , $ r , $ b , $ g ) { $ fact [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fact [ $ i ] = $ fact [ $ i - 1 ] * $ i ; $ left = $ n - ( $ r + $ g + $ b ) ; $ sum = 0 ; for ( $ i = 0 ; $ i <= $ left ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ left - $ i ; $ j ++ ) { $ k = $ left - ( $ i + $ j ) ; $ sum = $ sum + $ fact [ $ n ] / ( $ fact [ $ i + $ r ] * $ fact [ $ j + $ b ] * $ fact [ $ k + $ g ] ) ; } } return $ sum ; }
function sumProductDifference ( $ a , $ b , $ c , $ d , $ e ) { $ rootSum = ( double ) ( -1 * $ b ) / $ a ; $ rootProduct = ( double ) $ e / $ a ; return abs ( $ rootSum - $ rootProduct ) ; }
function cyl ( $ R ) { if ( $ R < 0 ) return -1 ; $ V = ( 2 * 3.14 * pow ( $ R , 3 ) ) / ( 3 * sqrt ( 3 ) ) ; return $ V ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = $ i ; $ j <= $ n ; $ j ++ ) $ sum = $ sum + $ i * $ j ; return $ sum ; }
function calcDeterminant ( $ arr ) { global $ N ; $ determinant = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ determinant += pow ( $ arr [ $ i ] , 3 ) ; } $ determinant -= 3 * $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ 2 ] ; return $ determinant ; }
function countInRange ( $ arr , $ n , $ x , $ y ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] >= $ x && $ arr [ $ i ] <= $ y ) $ count ++ ; } return $ count ; }
function countPaths ( $ m , $ n ) { $ dp ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 1 $ j == 1 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i ] [ $ j - 1 ] ; } } return $ dp [ $ m ] [ $ n ] ; }
function pairStar ( & $ input , & $ output , $ i = 0 ) { $ output = $ output . $ input [ $ i ] ; if ( $ i == strlen ( $ input ) - 1 ) return ; if ( $ input [ $ i ] == $ input [ $ i + 1 ] ) $ output = $ output . ' * ' ; pairStar ( $ input , $ output , $ i +1 ) ; }
function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 ) $ odd = ! $ odd ; if ( $ odd ) return 1 ; return 2 ; }
function is_possible ( $ s ) { $ l = strlen ( $ s ) ; $ one = 0 ; $ zero = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ s [ $ i ] == '0' ) $ zero ++ ; else $ one ++ ; } if ( $ l % 2 == 0 ) return ( $ one == $ zero ) ; else return ( abs ( $ one - $ zero ) == 1 ) ; }
function odd_even ( $ n ) { $ odd_indexes = array ( ) ; $ even_indexes = array ( ) ; for ( $ i = 0 ; $ i < sizeof ( $ n ) ; $ i ++ ) { if ( $ i % 2 == 0 ) array_push ( $ odd_indexes , $ n [ $ i ] ) ; else array_push ( $ even_indexes , $ n [ $ i ] ) ; } sort ( $ odd_indexes ) ; for ( $ i = 0 ; $ i < sizeof ( $ odd_indexes ) ; $ i ++ ) echo $ odd_indexes [ $ i ] , " ▁ " ; sort ( $ even_indexes ) ; for ( $ i = 0 ; $ i < sizeof ( $ even_indexes ) ; $ i ++ ) echo $ even_indexes [ $ i ] , " ▁ " ; }
function sum ( $ n ) { if ( $ n == 1 ) return 1 ; else return ( pow ( $ n , $ n ) + sum ( $ n - 1 ) ) ; }
function printPossible ( $ a , $ b , $ c ) { if ( ( $ a + $ b + $ c ) % 2 != 0 $ a + $ b < $ c ) echo ( " NO " ) ; else echo ( " YES " ) ; }
function printLastChar ( $ str ) { $ str = $ str . " ▁ " ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ! strcmp ( $ str [ $ i ] , ' ▁ ' ) ) echo ( $ str [ $ i - 1 ] . " ▁ " ) ; } }
function maxProduct ( $ arr , $ n ) { if ( $ n < 3 ) { return -1 ; } sort ( $ arr ) ; return max ( $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ $ n - 1 ] , $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] * $ arr [ $ n - 3 ] ) ; } $ arr = array ( -10 , -3 , 5 , 6 , -20 ) ; $ n = sizeof ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) { echo ( " No ▁ Triplet ▁ Exists " ) ; } else { echo ( " Maximum ▁ product ▁ is ▁ " . $ max ) ; }
function maxSum ( $ arr , $ n ) { $ cum_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cum_sum += $ arr [ $ i ] ; $ curr_val = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ curr_val += $ i * $ arr [ $ i ] ; $ res = $ curr_val ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ next_val = $ curr_val - ( $ cum_sum - $ arr [ $ i - 1 ] ) + $ arr [ $ i - 1 ] * ( $ n - 1 ) ; $ curr_val = $ next_val ; $ res = max ( $ res , $ next_val ) ; } return $ res ; }
function minOps ( $ arr , $ n , $ k ) { $ max = max ( $ arr ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ max - $ arr [ $ i ] ) % $ k != 0 ) return -1 ; else $ res += ( $ max - $ arr [ $ i ] ) / $ k ; } return $ res ; }
function findTriangle ( $ a , $ n ) { $ b [ $ n + 2 ] = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ b [ $ i ] = $ a [ $ i ] * $ a [ $ i ] ; sort ( $ a ) ; sort ( $ b ) ; $ x = 0 ; $ y = 0 ; $ z = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ p = $ i + 1 ; $ q = $ i + 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { while ( $ p < $ n - 1 && $ b [ $ i ] + $ b [ $ j ] >= $ b [ $ p + 1 ] ) $ p ++ ; $ q = max ( $ q , $ p ) ; while ( $ q < $ n - 1 && $ a [ $ i ] + $ a [ $ j ] > $ a [ $ q + 1 ] ) $ q ++ ; if ( $ b [ $ i ] + $ b [ $ j ] == $ b [ $ p ] ) { $ x += max ( $ p - $ j - 1 , 0 ) ; $ y ++ ; $ z += $ q - $ p ; } else { $ x += max ( $ p - $ j , 0 ) ; $ z += $ q - $ p ; } } } echo " Acute ▁ Triangle : ▁ " , $ x , " STRNEWLINE " ; echo " Right ▁ Triangle : ▁ " , $ y , " STRNEWLINE " ; echo " Obtuse ▁ Triangle : ▁ " , $ z , " STRNEWLINE " ; }
function Nth_Term ( $ n ) { return ( 2 * pow ( $ n , 3 ) - 3 * pow ( $ n , 2 ) + $ n + 6 ) / 6 ; }
function myXOR ( $ x , $ y ) { return ( $ x $ y ) & ( ~ $ x ~ $ y ) ; }
function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) { if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) { return false ; } } return true ; } $ n = 17 ; if ( isPrime ( $ n ) && ( $ n % 16 == 1 ) ) { echo " YES " ; } else { echo " NO " ; }
function rev ( $ n , $ temp ) { if ( $ n == 0 ) return $ temp ; $ temp = ( $ temp * 10 ) + ( $ n % 10 ) ; return rev ( $ n / 10 , $ temp ) ; }
function findGreater ( $ x , $ y ) { if ( $ x > $ y ) { return false ; } else { return true ; } }
function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = $ str [ $ i ] - '0' ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; }
function minValue ( $ A , $ B , $ n ) { sort ( $ A ) ; sort ( $ A , $ n ) ; sort ( $ B ) ; sort ( $ B , $ n ) ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += ( $ A [ $ i ] * $ B [ $ n - $ i - 1 ] ) ; return $ result ; }
function minimumChar ( $ S1 , $ S2 ) { $ n = strlen ( $ S1 ) ; $ m = strlen ( $ S2 ) ; $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ m - $ n + 1 ; $ i ++ ) { $ minRemovedChar = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ S1 [ $ j ] != $ S2 [ $ i + $ j ] ) { $ minRemovedChar ++ ; } } $ ans = min ( $ minRemovedChar , $ ans ) ; } return $ ans ; }
function check ( $ n ) { return 1162261467 % $ n == 0 ; }
function squareArea ( $ l , $ b , $ h ) { if ( $ l < 0 $ b < 0 $ h < 0 ) return -1 ; $ a = ( $ l * $ b ) / ( $ l + $ b ) ; return $ a * $ a ; }
function findSum ( $ n ) { $ multiTerms = ( int ) ( $ n * ( $ n + 1 ) / 2 ) ; $ sum = $ multiTerms ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ multiTerms = $ multiTerms - ( $ i - 1 ) ; $ sum = $ sum + $ multiTerms * $ i ; } return $ sum ; }
function area_of_tetrahedron ( $ side ) { return ( sqrt ( 3 ) * ( $ side * $ side ) ) ; }
function Area ( $ a ) { if ( $ a < 0 ) return -1 ; $ h = 1.268 * $ a ; $ A = 0.70477 * pow ( $ h , 2 ) ; return $ A ; }
function countStrings ( $ s ) { $ sum = 1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ i % 2 == 0 && $ s [ $ i ] == ' $ ' ) $ sum *= 21 ; else if ( $ s [ $ i ] == ' $ ' ) $ sum *= 5 ; } return $ sum ; }
function pythagoreanTriplet ( $ n ) { for ( $ i = 1 ; $ i <= $ n / 3 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j <= $ n / 2 ; $ j ++ ) { $ k = $ n - $ i - $ j ; if ( $ i * $ i + $ j * $ j == $ k * $ k ) { echo $ i , " , ▁ " , $ j , " , ▁ " , $ k ; return ; } } } echo " No ▁ Triplet " ; }
function isComposite ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return false ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return true ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return true ; return false ; }
function sum ( $ n ) { $ sum = 0 ; $ fact = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ fact *= $ i ; $ sum += 1.0 / $ fact ; } return $ sum ; }
function calculateSum ( $ n ) { return $ n * ( $ n + 1 ) / 2 + pow ( ( $ n * ( $ n + 1 ) / 2 ) , 2 ) ; }
function getNumToAdd ( $ arr , $ n ) { sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; $ numToAdd = -1 ; $ numAdded = false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ diff = $ arr [ $ i ] - $ arr [ $ i - 1 ] ; if ( $ diff != $ d ) { if ( $ numAdded ) return -1 ; if ( $ diff == 2 * $ d ) { $ numToAdd = $ arr [ $ i ] - $ d ; $ numAdded = true ; } else return -1 ; } } if ( $ numToAdd == -1 ) return ( $ arr [ $ n - 1 ] + $ d ) ; return $ numToAdd ; }
function rectanglearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = $ r * $ r ; return $ a ; }
function minNumber ( $ a , $ n , $ x ) { sort ( $ a ) ; $ k ; for ( $ k = 0 ; $ a [ ( $ n - 1 ) / 2 ] != $ x ; $ k ++ ) { $ a [ $ n ++ ] = $ x ; sort ( $ a ) ; } return $ k ; }
function findF_N ( $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans += ( $ i + 1 ) * ( $ n - $ i - 1 ) ; return $ ans ; }
function countChar ( $ str , $ x ) { $ count = 0 ; $ n = 10 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ str [ $ i ] == $ x ) $ count ++ ; $ repetitions = ( int ) ( $ n / strlen ( $ str ) ) ; $ count = $ count * $ repetitions ; for ( $ i = 0 ; $ i < $ n % strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == $ x ) $ count ++ ; } return $ count ; }
function countPS ( $ i , $ j ) { global $ str , $ dp , $ n ; if ( $ i > $ j ) return 0 ; if ( $ dp [ $ i ] [ $ j ] != -1 ) return $ dp [ $ i ] [ $ j ] ; if ( $ i == $ j ) return $ dp [ $ i ] [ $ j ] = 1 ; else if ( $ str [ $ i ] == $ str [ $ j ] ) return $ dp [ $ i ] [ $ j ] = countPS ( $ i + 1 , $ j ) + countPS ( $ i , $ j - 1 ) + 1 ; else return $ dp [ $ i ] [ $ j ] = countPS ( $ i + 1 , $ j ) + countPS ( $ i , $ j - 1 ) - countPS ( $ i + 1 , $ j - 1 ) ; }
function findRepeatingElement ( $ arr , $ low , $ high ) { if ( $ low > $ high ) return -1 ; $ mid = floor ( ( $ low + $ high ) / 2 ) ; if ( $ arr [ $ mid ] != $ mid + 1 ) { if ( $ mid > 0 && $ arr [ $ mid ] == $ arr [ $ mid - 1 ] ) return $ mid ; return findRepeatingElement ( $ arr , $ low , $ mid - 1 ) ; } return findRepeatingElement ( $ arr , $ mid + 1 , $ high ) ; }
function isPossible ( $ a , $ b , $ n , $ k ) { sort ( $ a ) ; rsort ( $ b ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] + $ b [ $ i ] < $ k ) return false ; return true ; }
function countSubStr ( $ str , $ n , $ x ) { $ res = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ x ) { $ res += ( ( $ count + 1 ) * ( $ n - $ i ) ) ; $ count = 0 ; } else $ count ++ ; } return $ res ; }
function printOtherSides ( $ n ) { if ( $ n & 1 ) { if ( $ n == 1 ) echo - 1 ; else { $ b = ( $ n * $ n - 1 ) / 2 ; $ c = ( $ n * $ n + 1 ) / 2 ; echo " b ▁ = ▁ " , $ b , " , ▁ c ▁ = ▁ " , $ c ; } } else { if ( $ n == 2 ) echo - 1 ; else { $ b = $ n * $ n / 4 - 1 ; $ c = $ n * $ n / 4 + 1 ; echo " b ▁ = ▁ " , $ b , " , ▁ c ▁ = ▁ " , $ c ; } } }
function findMax ( $ arr ) { global $ N ; $ row = 0 ; $ i ; $ j = $ N - 1 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { while ( $ arr [ $ i ] [ $ j ] == 1 && $ j >= 0 ) { $ row = $ i ; $ j -- ; } } echo " Row ▁ number ▁ = ▁ " , $ row + 1 ; echo " , MaxCount = " }
function twoEggDrop ( $ k ) { return ceil ( ( -1.0 + sqrt ( 1 + 8 * $ k ) ) / 2.0 ) ; }
function transpose ( & $ A , & $ B ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ M ; $ j ++ ) $ B [ $ i ] [ $ j ] = $ A [ $ j ] [ $ i ] ; } $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) ) ; $ N = 4 ; $ M = 3 ; transpose ( $ A , $ B ) ; echo " Result ▁ matrix ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { echo $ B [ $ i ] [ $ j ] ; echo " ▁ " ; } echo " STRNEWLINE " ; }
function largest ( $ arr , $ n ) { return max ( $ arr ) ; }
function smallestSumSubarr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = - $ arr [ $ i ] ; $ sum_here = $ arr [ 0 ] ; $ max_sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum_here = max ( $ sum_here + $ arr [ $ i ] , $ arr [ $ i ] ) ; $ max_sum = max ( $ max_sum , $ sum_here ) ; } return ( -1 ) * $ max_sum ; }
function isMajority ( $ arr , $ n , $ x ) { $ i ; $ last_index = $ n % 2 ? ( $ n / 2 + 1 ) : ( $ n / 2 ) ; for ( $ i = 0 ; $ i < $ last_index ; $ i ++ ) { if ( $ arr [ $ i ] == $ x && $ arr [ $ i + $ n / 2 ] == $ x ) return 1 ; } return 0 ; }
function SumDivisible ( $ n , $ k ) { $ sum = 0 ; $ position = 1 ; while ( $ n > 0 ) { if ( $ position % 2 == 1 ) $ sum += $ n % 10 ; $ n = ( int ) $ n / 10 ; $ position ++ ; } if ( $ sum % $ k == 0 ) return true ; return false ; }
function checkNumber ( $ N ) { $ temp = $ N ; while ( $ temp > 0 ) { if ( $ temp % 1000 == 144 ) $ temp /= 1000 ; else if ( $ temp % 100 == 14 ) $ temp /= 100 ; else if ( $ temp % 10 == 1 ) $ temp /= 10 ; else { return " YES " ; } } return " NO " ; }
function foot ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) { $ k = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 - $ d ) / ( $ a * $ a + $ b * $ b + $ c * $ c ) ; $ x2 = $ a * $ k + $ x1 ; $ y2 = $ b * $ k + $ y1 ; $ z2 = $ c * $ k + $ z1 ; echo " x2 = " ▁ . ▁ round ( $ x2 , ▁ 1 ) ; STRNEWLINE TABSYMBOL echo ▁ " y2 = " ▁ . ▁ round ( $ y2 , ▁ 1 ) ; STRNEWLINE TABSYMBOL echo ▁ " z2 = " }
function term ( $ n ) { return $ n * ( $ n + 1 ) / 2 ; }
function calculateEnergy ( $ mat , $ n ) { $ i_des ; $ j_des ; $ q ; $ tot_energy = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ q = ( int ) ( $ mat [ $ i ] [ $ j ] / $ n ) ; $ i_des = $ q ; $ j_des = $ mat [ $ i ] [ $ j ] - ( $ n * $ q ) ; $ tot_energy += abs ( $ i_des - $ i ) + abs ( $ j_des - $ j ) ; } } return $ tot_energy ; }
function findDuplicate ( $ arr , $ n , $ k ) { sort ( $ arr ) ; $ i = 0 ; while ( $ i < $ n ) { $ j ; $ count = 1 ; for ( $ j = $ i + 1 ; $ j < $ n && $ arr [ $ j ] == $ arr [ $ i ] ; $ j ++ ) $ count ++ ; if ( $ count == $ k ) return $ arr [ $ i ] ; $ i = $ j ; } return -1 ; }
function minDifferenceAmongMaxMin ( $ arr , $ N , $ K ) { $ INT_MAX = 2 ; sort ( $ arr ) ; sort ( $ arr , $ N ) ; $ res = $ INT_MAX ; for ( $ i = 0 ; $ i <= ( $ N - $ K ) ; $ i ++ ) { $ curSeqDiff = $ arr [ $ i + $ K - 1 ] - $ arr [ $ i ] ; $ res = min ( $ res , $ curSeqDiff ) ; } return $ res ; }
function segments ( $ n , $ p , $ m ) { $ c = array ( ) ; $ c [ 0 ] = 1 ; $ has = false ; $ sum = 0 ; $ ans = 0 ; for ( $ r = 0 ; $ r < $ n ; $ r ++ ) { if ( $ p [ $ r ] < $ m ) $ sum -- ; else if ( $ p [ $ r ] > $ m ) $ sum ++ ; if ( $ p [ $ r ] == $ m ) $ has = true ; if ( $ has ) $ ans += $ c [ $ sum ] + $ c [ $ sum - 1 ] ; else $ c [ $ sum ] ++ ; } return $ ans ; }
function FirstDigit ( $ arr , $ n ) { $ S = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ S = $ S + log10 ( $ arr [ $ i ] * 1.0 ) ; $ fract_S = $ S - floor ( $ S ) ; $ ans = pow ( 10 , $ fract_S ) ; return floor ( $ ans ) ; }
function countNumberOfTriangles ( $ n ) { return $ n * ( $ n - 1 ) * ( $ n - 2 ) / 6 ; }
function subArraySum ( $ arr , $ n , $ sum ) { $ curr_sum ; $ i ; $ j ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum = $ arr [ $ i ] ; for ( $ j = $ i + 1 ; $ j <= $ n ; $ j ++ ) { if ( $ curr_sum == $ sum ) { echo " Sum ▁ found ▁ between ▁ indexes ▁ " , $ i , " ▁ and ▁ " , $ j - 1 ; return 1 ; } if ( $ curr_sum > $ sum $ j == $ n ) break ; $ curr_sum = $ curr_sum + $ arr [ $ j ] ; } } echo " No ▁ subarray ▁ found " ; return 0 ; }
function printNthElement ( $ n ) { $ arr = array_fill ( 0 , ( $ n + 1 ) , NULL ) ; $ arr [ 1 ] = 3 ; $ arr [ 2 ] = 5 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 != 0 ) $ arr [ $ i ] = $ arr [ $ i / 2 ] * 10 + 3 ; else $ arr [ $ i ] = $ arr [ ( $ i / 2 ) - 1 ] * 10 + 5 ; } return $ arr [ $ n ] ; }
function powerNumbers ( $ n ) { $ v = array ( ) ; for ( $ i = 2 ; $ i * $ i * $ i <= $ n ; $ i ++ ) { $ j = $ i * $ i ; while ( $ j * $ i <= $ n ) { $ j *= $ i ; $ s = sqrt ( $ j ) ; if ( $ s * $ s != $ j ) array_push ( $ v , $ j ) ; } } sort ( $ v ) ; $ uni = array_unique ( $ v ) ; for ( $ i = 0 ; $ i < count ( $ uni ) ; $ i ++ ) { $ key = array_search ( $ uni [ $ i ] , $ v ) ; unset ( $ v [ $ key ] ) ; } return count ( $ v ) + 3 + intval ( sqrt ( $ n ) ) ; }
function count_1 ( $ a , $ b , $ m , $ n ) { if ( ( $ m == 0 && $ n == 0 ) $ n == 0 ) return 1 ; if ( $ m == 0 ) return 0 ; if ( $ a [ $ m - 1 ] == $ b [ $ n - 1 ] ) return count_1 ( $ a , $ b , $ m - 1 , $ n - 1 ) + count_1 ( $ a , $ b , $ m - 1 , $ n ) ; else return count_1 ( $ a , $ b , $ m - 1 , $ n ) ; }
function findMinSum ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] * ( $ n - $ i ) ; return $ sum ; }
function isEven ( $ n ) { return ( ! ( n & 1 ) ) ; }
function subsetCount ( $ arr , $ n ) { return 1 << $ n ; }
function sph ( $ r , $ h ) { if ( $ r < 0 && $ h < 0 ) return -1 ; $ R = $ r ; return $ R ; }
function findSum ( $ N , $ K ) { $ ans = 0 ; $ y = $ N / $ K ; $ x = $ N % $ K ; $ ans = ( $ K * ( $ K - 1 ) / 2 ) * $ y + ( $ x * ( $ x + 1 ) ) / 2 ; return $ ans ; }
function printPalindrome ( $ n ) { if ( $ n == 1 ) { echo " Smallest ▁ Palindrome : ▁ 0 STRNEWLINE " ; echo " Largest ▁ Palindrome : ▁ 9" ; } else { echo " Smallest ▁ Palindrome : ▁ " , pow ( 10 , $ n - 1 ) + 1 ; echo " Largest Palindrome : " pow ( 10 , $ n ) - 1 ; } }
function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) + $ n - 2 ; }
function countPairs ( $ str ) { $ result = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( ord ( $ str [ $ i ] ) - ord ( $ str [ $ j ] ) ) == abs ( $ i - $ j ) ) $ result ++ ; return $ result ; }
function CntDivbyX ( $ arr , $ n , $ x ) { $ number = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ number = $ number * 2 + $ arr [ $ i ] ; if ( ( $ number % $ x == 0 ) ) $ count += 1 ; } return $ count ; }
function countValues ( $ n ) { $ unset_bits = 0 ; while ( $ n ) { if ( ( $ n & 1 ) == 0 ) $ unset_bits ++ ; $ n = $ n >> 1 ; } return 1 << $ unset_bits ; }
function findMissing ( $ a , $ b , $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ a [ $ i ] == $ b [ $ j ] ) break ; if ( $ j == $ m ) echo $ a [ $ i ] , " ▁ " ; } }
function countXOR ( $ n ) { $ count0 = 0 ; $ count1 = 0 ; while ( $ n ) { ( $ n % 2 == 0 ) ? $ count0 ++ : $ count1 ++ ; $ n = intval ( $ n / 2 ) ; } return ( $ count0 ^ $ count1 ) ; }
function countMaxChoco ( $ money , $ price , $ wrap ) { if ( $ money < $ price ) return 0 ; $ choc = $ money / $ price ; $ choc = $ choc + ( $ choc - 1 ) / ( $ wrap - 1 ) ; return $ choc ; }
function countIntegralSolutions ( $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n - $ i ; $ j ++ ) for ( $ k = 0 ; $ k <= ( $ n - $ i - $ j ) ; $ k ++ ) if ( $ i + $ j + $ k == $ n ) $ result ++ ; return $ result ; }
function countSetBits ( $ n ) { $ i = 0 ; $ ans = 0 ; while ( ( 1 << $ i ) <= $ n ) { $ k = 0 ; $ change = 1 << $ i ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { $ ans += $ k ; if ( $ change == 1 ) { $ k = ! $ k ; $ change = 1 << $ i ; } else { $ change -- ; } } $ i ++ ; } return $ ans ; }
function perfectPowerOf2 ( $ n ) { $ per_pow = 1 ; while ( $ n > 0 ) { $ per_pow = $ per_pow << 1 ; $ n = $ n >> 1 ; } return $ per_pow ; }
function Triplets ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = $ i ; $ j <= $ n ; ++ $ j ) { $ x = $ i * $ i + $ j * $ j ; $ y = ( int ) sqrt ( $ x ) ; if ( $ y * $ y == $ x && $ y <= $ n ) ++ $ ans ; } } return $ ans ; }
function Circular ( $ n ) { $ Result = 1 ; while ( $ n > 0 ) { $ Result = $ Result * $ n ; $ n -- ; } return $ Result ; }
function getMinCost ( $ arr , $ n ) { $ min_ele = min ( $ arr ) ; return $ min_ele * ( $ n - 1 ) ; }
function smallestDivisor ( $ n ) { if ( $ n % 2 == 0 ) return 2 ; for ( $ i = 3 ; $ i * $ i <= $ n ; $ i += 2 ) { if ( $ n % $ i == 0 ) return $ i ; } return $ n ; }
function constructArr ( $ pair ) { $ arr = array ( ) ; $ n = 5 ; $ arr [ 0 ] = intval ( ( $ pair [ 0 ] + $ pair [ 1 ] - $ pair [ $ n - 1 ] ) / 2 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ pair [ $ i - 1 ] - $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . " ▁ " ; }
function compute ( $ a , $ b ) { $ AM ; $ GM ; $ HM ; $ AM = ( $ a + $ b ) / 2 ; $ GM = sqrt ( $ a * $ b ) ; $ HM = ( $ GM * $ GM ) / $ AM ; return $ HM ; }
function findValue ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ k ) $ k *= 2 ; return $ k ; }
function rod ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ l = sqrt ( pow ( $ h , 2 ) + 4 * pow ( $ r , 2 ) ) ; return $ l ; }
function sum ( $ n ) { $ ans = ( $ n * ( $ n - 1 ) ) / 2 ; return $ ans ; }
function MatrixChainOrder ( $ p , $ n ) { $ m [ ] [ ] = array ( $ n , $ n ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ m [ $ i ] [ $ i ] = 0 ; for ( $ L = 2 ; $ L < $ n ; $ L ++ ) { for ( $ i = 1 ; $ i < $ n - $ L + 1 ; $ i ++ ) { $ j = $ i + $ L - 1 ; if ( $ j == $ n ) continue ; $ m [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = $ i ; $ k <= $ j - 1 ; $ k ++ ) { $ q = $ m [ $ i ] [ $ k ] + $ m [ $ k + 1 ] [ $ j ] + $ p [ $ i - 1 ] * $ p [ $ k ] * $ p [ $ j ] ; if ( $ q < $ m [ $ i ] [ $ j ] ) $ m [ $ i ] [ $ j ] = $ q ; } } } return $ m [ 1 ] [ $ n - 1 ] ; }
function findPattern ( $ n ) { $ prev = $ n % 2 ; $ n = $ n / 2 ; while ( $ n > 0 ) { $ curr = $ n % 2 ; if ( $ curr == $ prev ) return false ; $ prev = $ curr ; $ n = floor ( $ n / 2 ) ; } return true ; }
function countkDist ( $ str , $ k ) { $ res = 0 ; $ n = strlen ( $ str ) ; $ cnt = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dist_count = 0 ; $ cnt = array_fill ( 0 , 0 , true ) ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( $ cnt [ ord ( $ str [ $ j ] ) - ord ( ' a ' ) ] == 0 ) $ dist_count ++ ; $ cnt [ ord ( $ str [ $ j ] ) - ord ( ' a ' ) ] ++ ; if ( $ dist_count == $ k ) $ res ++ ; } } return $ res ; } { $ ch = " abcbaa " ; $ k = 3 ; echo ( " Total ▁ substrings ▁ with ▁ exactly ▁ " . $ k . " ▁ distinct ▁ characters ▁ : ▁ " . countkDist ( $ ch , $ k ) ) ; }
function fib ( $ n ) { global $ PHI ; $ f = array ( 0 , 1 , 1 , 2 , 3 , 5 ) ; if ( $ n < 6 ) return $ f [ $ n ] ; $ t = 5 ; $ fn = 5 ; while ( $ t < $ n ) { $ fn = round ( $ fn * $ PHI ) ; $ t ++ ; } return $ fn ; }
function printMaxAfterRemoval ( $ s ) { $ flag = false ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '0' && $ flag == false ) { $ flag = true ; continue ; } else echo $ s [ $ i ] ; } }
function Centered_Triangular_num ( $ n ) { return ( 3 * $ n * $ n + 3 * $ n + 2 ) / 2 ; }
function nthHarmonic ( $ N ) { $ harmonic = 1.00 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { $ harmonic += ( float ) 1 / $ i ; } return $ harmonic ; }
function maxDiff ( $ arr , $ arr_size ) { $ max_diff = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ j ] - $ arr [ $ i ] > $ max_diff ) $ max_diff = $ arr [ $ j ] - $ arr [ $ i ] ; } } return $ max_diff ; }
function countSolutions ( $ n ) { $ res = 0 ; for ( $ x = 0 ; $ x * $ x < $ n ; $ x ++ ) for ( $ y = 0 ; $ x * $ x + $ y * $ y < $ n ; $ y ++ ) $ res ++ ; return $ res ; } { echo " Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " ; echo countSolutions ( 6 ) ; return 0 ; }
function findDivisor ( $ x , $ y ) { if ( $ x == $ y ) return $ y ; return 2 ; }
function findNoIsDivisibleOrNot ( $ a , $ n , $ l ) { for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ a [ $ i ] % $ n != 0 ) return false ; } return true ; }
function missing4 ( $ arr , $ n ) { $ helper = array ( 0 , 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp = abs ( $ arr [ $ i ] ) ; if ( $ temp <= $ n ) $ arr [ $ temp - 1 ] = $ arr [ $ temp - 1 ] * ( -1 ) ; else if ( $ temp > $ n ) { if ( $ temp % $ n != 0 ) $ helper [ $ temp % $ n - 1 ] = -1 ; else $ helper [ ( $ temp % $ n ) + $ n - 1 ] = -1 ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > 0 ) { $ a = $ i + 1 ; echo " $ a " , " ▁ " ; } for ( $ i = 0 ; $ i < 4 ; $ i ++ ) if ( $ helper [ $ i ] >= 0 ) { $ b = $ n + $ i + 1 ; echo " $ b " , " ▁ " ; } echo " STRNEWLINE " ; return ; }
function minElements ( $ arr , $ n ) { $ halfSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ halfSum = $ halfSum + $ arr [ $ i ] ; $ halfSum = $ halfSum / 2 ; rsort ( $ arr ) ; $ res = 0 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum += $ arr [ $ i ] ; $ res ++ ; if ( $ curr_sum > $ halfSum ) return $ res ; } return $ res ; }
function maxOfSegmentMins ( $ a , $ n , $ k ) { if ( $ k == 1 ) return min ( $ a ) ; if ( $ k == 2 ) return max ( $ a [ 0 ] , $ a [ $ n - 1 ] ) ; return max ( $ a ) ; }
function permute ( $ input ) { $ n = strlen ( $ input ) ; $ max = 1 << $ n ; $ input = strtolower ( $ input ) ; for ( $ i = 0 ; $ i < $ max ; $ i ++ ) { $ combination = $ input ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( ( $ i >> $ j ) & 1 ) == 1 ) $ combination [ $ j ] = chr ( ord ( $ combination [ $ j ] ) - 32 ) ; } echo $ combination . " " ; } }
function nthterm ( $ n ) { $ An = ( pow ( 1 , $ n ) + pow ( 2 , $ n ) ) * pow ( 3 , $ n ) ; return $ An ; }
function checkJumbled ( $ num ) { if ( $ num / 10 == 0 ) return true ; while ( $ num != 0 ) { if ( $ num / 10 == 0 ) return true ; $ digit1 = $ num % 10 ; $ digit2 = ( $ num / 10 ) % 10 ; if ( abs ( $ digit2 - $ digit1 ) > 1 ) return false ; $ num = $ num / 10 ; } return true ; }
function isDiagonalMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( ( $ i != $ j ) && ( $ mat [ $ i ] [ $ j ] != 0 ) ) return false ; return true ; }
function minOperations ( $ N ) { $ x = log ( $ N , 2 ) ; $ ans = ceil ( $ x ) ; return $ ans ; }
function printSpiral ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ x ; $ x = min ( min ( $ i , $ j ) , min ( $ n - 1 - $ i , $ n - 1 - $ j ) ) ; if ( $ i <= $ j ) echo " TABSYMBOL ▁ " , ( $ n - 2 * $ x ) * ( $ n - 2 * $ x ) - ( $ i - $ x ) - ( $ j - $ x ) ; else echo " TABSYMBOL ▁ " , ( $ n - 2 * $ x - 2 ) * ( $ n - 2 * $ x - 2 ) + ( $ i - $ x ) + ( $ j - $ x ) ; } echo " STRNEWLINE " ; } }
function countIncreasing ( $ arr , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] > $ arr [ $ j - 1 ] ) $ cnt ++ ; else break ; } } return $ cnt ; }
function check ( $ n , $ m ) { if ( $ n == 2 $ m == 2 $ n % $ m == 0 ) { echo " Yes " , " STRNEWLINE " ; } else { echo " No " , " ▁ STRNEWLINE " ; } }
function summation ( $ n ) { return $ n << ( $ n - 1 ) ; }
function maxDiff ( $ arr , $ n ) { $ diff = $ arr [ 1 ] - $ arr [ 0 ] ; $ curr_sum = $ diff ; $ max_sum = $ curr_sum ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = $ arr [ $ i + 1 ] - $ arr [ $ i ] ; if ( $ curr_sum > 0 ) $ curr_sum += $ diff ; else $ curr_sum = $ diff ; if ( $ curr_sum > $ max_sum ) $ max_sum = $ curr_sum ; } return $ max_sum ; }
function find_prob ( $ N , $ P ) { $ dp ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 0 ; $ dp [ 2 ] = $ P ; $ dp [ 3 ] = 1 - $ P ; for ( $ i = 4 ; $ i <= $ N ; ++ $ i ) $ dp [ $ i ] = ( $ P ) * $ dp [ $ i - 2 ] + ( 1 - $ P ) * $ dp [ $ i - 3 ] ; return $ dp [ $ N ] ; }
function MaximumSum ( $ a , $ b , $ n ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 |= $ a [ $ i ] ; $ sum2 |= $ b [ $ i ] ; } echo ( $ sum1 + $ sum2 ) . " STRNEWLINE " ; }
function almostSort ( $ A , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ A [ $ i ] > $ A [ $ i + 1 ] ) { list ( $ A [ $ i ] , $ A [ $ i + 1 ] ) = array ( $ A [ $ i + 1 ] , $ A [ $ i ] ) ; $ i ++ ; } } for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ A [ $ i ] > $ A [ $ i + 1 ] ) return false ; return true ; }
function findsolution ( $ n , $ x , $ y ) { if ( ( $ y - $ n + 1 ) * ( $ y - $ n + 1 ) + $ n - 1 < $ x $ y < $ n ) { echo " No ▁ solution " ; return ; } echo $ y - $ n + 1 ; while ( $ n -- > 1 ) echo " STRNEWLINE " . 1 ; }
function isScalarMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( ( $ i != $ j ) && ( $ mat [ $ i ] [ $ j ] != 0 ) ) return false ; for ( $ i = 0 ; $ i < $ N - 1 ; $ i ++ ) if ( $ mat [ $ i ] [ $ i ] != $ mat [ $ i + 1 ] [ $ i + 1 ] ) return false ; return true ; }
function findOptimalPairs ( $ arr , $ N ) { sort ( $ arr ) ; for ( $ i = 0 , $ j = $ N - 1 ; $ i <= $ j ; $ i ++ , $ j -- ) echo " ( " , $ arr [ $ i ] , " , ▁ " , $ arr [ $ j ] , " ) " , " ▁ " ; }
function findSum ( $ n ) { $ ans = 0 ; $ temp = 0 ; $ num ; for ( $ i = 1 ; $ i <= $ n and $ temp < $ n ; $ i ++ ) { $ temp = $ i - 1 ; $ num = 1 ; while ( $ temp < $ n ) { if ( $ temp + $ i <= $ n ) $ ans += ( $ i * $ num ) ; else $ ans += ( ( $ n - $ temp ) * $ num ) ; $ temp += $ i ; $ num ++ ; } } return $ ans ; }
function makeOdd ( $ n ) { if ( $ n % 2 != 0 ) return 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) if ( ( $ n % $ i == 0 ) && ( ( $ n / $ i ) % 2 == 1 ) ) return $ i ; }
function checksum ( $ n ) { if ( $ n % 5 == 0 ) echo $ n / 5 - 2 , " ▁ " , $ n / 5 - 1 , " ▁ " , $ n / 5 , " ▁ " , $ n / 5 + 1 , " ▁ " , $ n / 5 + 2 ; else echo " - 1" ; }
function interchangeFirstLast ( & $ m ) { global $ n ; $ rows = $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ t = $ m [ 0 ] [ $ i ] ; $ m [ 0 ] [ $ i ] = $ m [ $ rows - 1 ] [ $ i ] ; $ m [ $ rows - 1 ] [ $ i ] = $ t ; } } $ m = array ( array ( 8 , 9 , 7 , 6 ) , array ( 4 , 7 , 6 , 5 ) , array ( 3 , 2 , 1 , 8 ) , array ( 9 , 9 , 7 , 7 ) ) ; interchangeFirstLast ( $ m ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo $ m [ $ i ] [ $ j ] . " ▁ " ; echo " STRNEWLINE " ; }
function sizeSubSet ( $ a , $ k , $ n ) { sort ( $ a ) ; $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % $ k != 0 or ! in_array ( floor ( $ a [ $ i ] / $ k ) , $ s ) ) array_push ( $ s , $ a [ $ i ] ) ; } return sizeof ( $ s ) ; }
function findTangent ( $ A , $ x , $ y ) { $ dif = $ A - $ x * 2 ; if ( $ y == ( 2 * $ x - $ x * $ x ) ) { if ( $ dif < 0 ) echo " y = " , ▁ $ dif ▁ , ▁ " x " ( $ x * $ dif ) + ( $ y ) ; else if ( $ dif > 0 ) echo " y ▁ = ▁ " , $ dif , " x + " , - $ x * $ dif + $ y ; else echo " Not ▁ possible " ; } }
function parallel ( $ n , $ a ) { $ x = true ; $ y = true ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ i ] [ 0 ] != $ a [ $ i + 1 ] [ 0 ] ) $ x = false ; if ( $ a [ $ i ] [ 1 ] != $ a [ $ i + 1 ] [ 1 ] ) $ y = false ; } if ( $ x ) echo " parallel ▁ to ▁ Y ▁ Axis " ; else if ( y ) echo " parallel ▁ to ▁ X ▁ Axis " ; else echo " Not ▁ parallel ▁ to ▁ X " , " ▁ and ▁ Y ▁ Axis " ; }
function sackRace ( $ p1 , $ s1 , $ p2 , $ s2 ) { return ( ( $ s1 > $ s2 && ( $ p2 - $ p1 ) % ( $ s1 - $ s2 ) == 0 ) || ( $ s2 > $ s1 && ( $ p1 - $ p2 ) % ( $ s2 - $ s1 ) == 0 ) ) ; }
function deleteElement ( & $ A , $ L , $ R , $ N ) { $ i = 0 ; $ j = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ i <= $ L $ i >= $ R ) { $ A [ $ j ] = $ A [ $ i ] ; $ j ++ ; } } return $ j ; } $ A = array ( 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 ) ; $ L = 2 ; $ R = 7 ; $ n = sizeof ( $ A ) ; $ res_size = deleteElement ( $ A , $ L , $ R , $ n ) ; for ( $ i = 0 ; $ i < $ res_size ; $ i ++ ) { echo ( $ A [ $ i ] ) ; echo ( " ▁ " ) ; }
function first ( $ a , $ b , $ c ) { $ a %= $ b ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) { $ a = $ a * 10 ; if ( $ a / $ b == $ c ) return $ i ; $ a %= $ b ; } return -1 ; }
function maxTripletSum ( $ arr , $ n ) { sort ( $ arr ) ; return $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] + $ arr [ $ n - 3 ] ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ sum = $ sum + $ x ; return $ sum ; }
function smallestIndex ( $ a , $ n ) { $ right1 = 0 ; $ right0 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ right1 = $ i ; else $ right0 = $ i ; } return min ( $ right1 , $ right0 ) ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( ( $ i * ( $ i + 1 ) * ( 2 * $ i + 1 ) ) / 6 ) ; return $ sum ; }
function recaman ( $ n ) { $ arr [ 0 ] = 0 ; echo $ arr [ 0 ] , " , ▁ " ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr = $ arr [ $ i - 1 ] - $ i ; $ j ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( ( $ arr [ $ j ] == $ curr ) $ curr < 0 ) { $ curr = $ arr [ $ i - 1 ] + $ i ; break ; } } $ arr [ $ i ] = $ curr ; echo $ arr [ $ i ] , " , ▁ " ; } }
function sumBetweenTwoKth ( $ arr , $ n , $ k1 , $ k2 ) { sort ( $ arr ) ; $ result = 0 ; for ( $ i = $ k1 ; $ i < $ k2 - 1 ; $ i ++ ) $ result += $ arr [ $ i ] ; return $ result ; }
function calculateSquareSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = ( $ fibo [ 0 ] * $ fibo [ 0 ] ) + ( $ fibo [ 1 ] * $ fibo [ 1 ] ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; $ sum += ( $ fibo [ $ i ] * $ fibo [ $ i ] ) ; } return $ sum ; }
function area_fun ( $ side ) { $ area = $ side * $ side ; return $ area ; }
function angle_triangle ( $ x1 , $ x2 , $ x3 , $ y1 , $ y2 , $ y3 , $ z1 , $ z2 , $ z3 ) { $ num = ( $ x2 - $ x1 ) * ( $ x3 - $ x1 ) + ( $ y2 - $ y1 ) * ( $ y3 - $ y1 ) + ( $ z2 - $ z1 ) * ( $ z3 - $ z1 ) ; $ den = sqrt ( pow ( ( $ x2 - $ x1 ) , 2 ) + pow ( ( $ y2 - $ y1 ) , 2 ) + pow ( ( $ z2 - $ z1 ) , 2 ) ) * sqrt ( pow ( ( $ x3 - $ x1 ) , 2 ) + pow ( ( $ y3 - $ y1 ) , 2 ) + pow ( ( $ z3 - $ z1 ) , 2 ) ) ; $ angle = acos ( $ num / $ den ) * ( 180.0 / 3.141592653589793238463 ) ; return $ angle ; }
function findCount ( $ m , $ n ) { $ num1 = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ num1 = ( $ num1 * 10 ) + 9 ; $ num2 = 0 ; for ( $ i = 0 ; $ i < ( $ m - 1 ) ; $ i ++ ) $ num2 = ( $ num2 * 10 ) + 9 ; return ( ( $ num1 / $ n ) - ( $ num2 / $ n ) ) ; }
function isPossible ( $ x , $ y , $ z ) { $ a = round ( $ x * $ x + $ y * $ y + $ z * $ z ) ; if ( ceil ( $ a ) == 1 && floor ( $ a ) == 1 ) return true ; return false ; }
function findDivisors ( $ n ) { $ div = array_fill ( 0 , $ n + 2 , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j * $ i <= $ n ; $ j ++ ) $ div [ $ i * $ j ] ++ ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ div [ $ i ] , " ▁ " ; }
function countConsecutive ( $ s ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ i ++ ; else $ count ++ ; } return $ count ; }
function maxProductSum ( $ str , $ m ) { $ n = strlen ( $ str ) ; $ maxProd = PHP_INT_MIN ; $ maxSum = PHP_INT_MIN ; for ( $ i = 0 ; $ i <= ( $ n - $ m ) ; $ i ++ ) { $ product = 1 ; $ sum = 0 ; for ( $ j = $ i ; $ j < ( $ m + $ i ) ; $ j ++ ) { $ product = $ product * ( $ str [ $ j ] - '0' ) ; $ sum = $ sum + ( $ str [ $ j ] - '0' ) ; } $ maxProd = max ( $ maxProd , $ product ) ; $ maxSum = max ( $ maxSum , $ sum ) ; } echo " Maximum ▁ Product ▁ = ▁ " , $ maxProd ; echo " Maximum Sum = " }
function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; }
function minCells ( $ mat , $ m , $ n ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ dp [ $ i ] [ $ j ] != PHP_INT_MAX and ( $ j + $ mat [ $ i ] [ $ j ] ) < $ n and ( $ dp [ $ i ] [ $ j ] + 1 ) < $ dp [ $ i ] [ $ j + $ mat [ $ i ] [ $ j ] ] ) $ dp [ $ i ] [ $ j + $ mat [ $ i ] [ $ j ] ] = $ dp [ $ i ] [ $ j ] + 1 ; if ( $ dp [ $ i ] [ $ j ] != PHP_INT_MAX and ( $ i + $ mat [ $ i ] [ $ j ] ) < $ m and ( $ dp [ $ i ] [ $ j ] + 1 ) < $ dp [ $ i + $ mat [ $ i ] [ $ j ] ] [ $ j ] ) $ dp [ $ i + $ mat [ $ i ] [ $ j ] ] [ $ j ] = $ dp [ $ i ] [ $ j ] + 1 ; } } if ( $ dp [ $ m - 1 ] [ $ n - 1 ] != PHP_INT_MAX ) return $ dp [ $ m - 1 ] [ $ n - 1 ] ; return -1 ; }
function findXOR ( $ Set , $ n ) { if ( $ n == 1 ) return $ Set [ 0 ] ; else return 0 ; }
function lastPosition ( $ n , $ m , $ k ) { if ( $ m <= $ n - $ k + 1 ) return $ m + $ k - 1 ; $ m = $ m - ( $ n - $ k + 1 ) ; return ( $ m % $ n == 0 ) ? $ n : ( $ m % $ n ) ; }
function increment ( $ i ) { $ i = - ( ~ ord ( $ i ) ) ; return chr ( $ i ) ; }
function addOne ( $ x ) { return ( - ( ~ $ x ) ) ; }
function andSum ( $ arr , $ n ) { global $ BITS ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ BITS ; $ i ++ ) { $ countSetBits = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] & ( 1 << $ i ) ) $ countSetBits ++ ; } $ subset = ( 1 << $ countSetBits ) - 1 ; $ subset = ( $ subset * ( 1 << $ i ) ) ; $ ans += $ subset ; } return $ ans ; }
function solve ( $ p , $ n ) { $ G = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ p [ $ i ] & 1 ) $ G ^= ( $ p [ $ i ] + 1 ) ; $ G ^= ( $ p [ $ i ] - 1 ) ; } return $ G ; }
function countSubstrings ( $ s , $ c ) { $ n = strlen ( $ s ) ; $ cnt = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != $ c ) $ cnt ++ ; else { $ sum += floor ( ( $ cnt * ( $ cnt + 1 ) ) / 2 ) ; $ cnt = 0 ; } } $ sum += floor ( ( $ cnt * ( $ cnt + 1 ) ) / 2 ) ; return $ sum ; }
function p_rint ( $ n ) { echo floor ( $ n + $ n / 2 ) , " STRNEWLINE " ; for ( $ i = 2 ; $ i <= $ n ; $ i += 2 ) echo $ i , " ▁ " ; for ( $ i = 1 ; $ i <= $ n ; $ i += 2 ) echo $ i , " ▁ " ; for ( $ i = 2 ; $ i <= $ n ; $ i += 2 ) echo $ i , " ▁ " ; }
function DivisibleBy41 ( $ first , $ second , $ c , $ n ) { $ digit [ $ n ] = range ( 1 , $ n ) ; $ digit [ 0 ] = $ first ; $ digit [ 1 ] = $ second ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ digit [ $ i ] = ( $ digit [ $ i - 1 ] * $ c + $ digit [ $ i - 2 ] ) % 10 ; $ ans = $ digit [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans = ( $ ans * 10 + $ digit [ $ i ] ) % 41 ; if ( $ ans % 41 == 0 ) return true ; else return false ; }
function Reverseorder ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = $ n ; $ p >= 2 ; $ p -- ) if ( $ prime [ $ p ] ) echo $ p . " " ; }
function answer ( $ n ) { if ( $ n == 1 ) return 10 ; for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) $ dp [ 1 ] [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) { if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j + 1 ] ; else if ( $ j == 9 ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ j + 1 ] ; } } $ sum = 0 ; for ( $ j = 1 ; $ j <= 9 ; $ j ++ ) $ sum += $ dp [ $ n ] [ $ j ] ; return $ sum ; }
function findNumber ( $ n ) { $ x = floor ( ( -1 + sqrt ( 1 + 8 * $ n - 8 ) ) / 2 ) ; $ base = ( $ x * ( $ x + 1 ) ) / 2 + 1 ; return $ n - $ base + 1 ; }
function center_pentadecagonal_num ( $ n ) { return ( 15 * $ n * $ n - 15 * $ n + 2 ) / 2 ; }
function minStepToDeleteString ( $ str ) { $ N = strlen ( $ str ) ; $ dp [ $ N + 1 ] [ $ N + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) for ( $ j = 0 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ len = 1 ; $ len <= $ N ; $ len ++ ) { for ( $ i = 0 , $ j = $ len - 1 ; $ j < $ N ; $ i ++ , $ j ++ ) { if ( $ len == 1 ) $ dp [ $ i ] [ $ j ] = 1 ; else { $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i + 1 ] [ $ j ] ; if ( $ str [ $ i ] == $ str [ $ i + 1 ] ) $ dp [ $ i ] [ $ j ] = min ( 1 + $ dp [ $ i + 2 ] [ $ j ] , $ dp [ $ i ] [ $ j ] ) ; for ( $ K = $ i + 2 ; $ K <= $ j ; $ K ++ ) if ( $ str [ $ i ] == $ str [ $ K ] ) $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i + 1 ] [ $ K - 1 ] + $ dp [ $ K + 1 ] [ $ j ] , $ dp [ $ i ] [ $ j ] ) ; } } } return $ dp [ 0 ] [ $ N - 1 ] ; }
function findWater ( $ arr , $ n ) { $ result = 0 ; $ left_max = 0 ; $ right_max = 0 ; $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo <= $ hi ) { if ( $ arr [ $ lo ] < $ arr [ $ hi ] ) { if ( $ arr [ $ lo ] > $ left_max ) $ left_max = $ arr [ $ lo ] ; else $ result += $ left_max - $ arr [ $ lo ] ; $ lo ++ ; } else { if ( $ arr [ $ hi ] > $ right_max ) $ right_max = $ arr [ $ hi ] ; else $ result += $ right_max - $ arr [ $ hi ] ; $ hi -- ; } } return $ result ; }
function CountPair ( $ L , $ R ) { $ x = ( $ R - $ L + 1 ) ; echo $ x / 2 , " STRNEWLINE " ; }
function findTerm ( $ n ) { if ( $ n == 1 ) return $ n ; else { $ term = 7 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ term = $ term * 2 + ( $ i - 1 ) ; return $ term ; } }
function get_unit_digit ( $ N ) { if ( $ N == 0 $ N == 1 ) return 1 ; else if ( $ N == 2 ) return 3 ; else if ( $ N == 3 ) return 9 ; return 3 ; }
function findWater ( $ arr , $ n ) { $ water = 0 ; $ left [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ left [ $ i ] = max ( $ left [ $ i - 1 ] , $ arr [ $ i ] ) ; $ right [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) $ right [ $ i ] = max ( $ right [ $ i + 1 ] , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ water += min ( $ left [ $ i ] , $ right [ $ i ] ) - $ arr [ $ i ] ; return $ water ; }
function computeTotient ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ phi [ $ i ] = $ i ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ phi [ $ p ] == $ p ) { $ phi [ $ p ] = $ p - 1 ; for ( $ i = 2 * $ p ; $ i <= $ n ; $ i += $ p ) { $ phi [ $ i ] = ( $ phi [ $ i ] / $ p ) * ( $ p - 1 ) ; } } } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo " Totient ▁ of ▁ " , $ i , " ▁ is ▁ " , $ phi [ $ i ] , " STRNEWLINE " ; }
function isDivisible ( $ n ) { while ( $ n / 100 != 0 ) { $ d = ( int ) $ n % 10 ; $ n /= 10 ; $ n -= $ d * 5 ; } return ( $ n % 17 == 0 ) ; }
function modInverse ( $ a , $ m ) { $ m0 = $ m ; $ y = 0 ; $ x = 1 ; if ( $ m == 1 ) return 0 ; while ( $ a > 1 ) { $ q = ( int ) ( $ a / $ m ) ; $ t = $ m ; $ m = $ a % $ m ; $ a = $ t ; $ t = $ y ; $ y = $ x - $ q * $ y ; $ x = $ t ; } if ( $ x < 0 ) $ x += $ m0 ; return $ x ; }
function dealnnoy ( $ n , $ m ) { if ( $ m == 0 or $ n == 0 ) return 1 ; return dealnnoy ( $ m - 1 , $ n ) + dealnnoy ( $ m - 1 , $ n - 1 ) + dealnnoy ( $ m , $ n - 1 ) ; }
function xor_pair_sum ( $ ar , $ n ) { $ total = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ total = $ total ^ $ ar [ $ i ] ; return ( 2 * $ total ) ; }
function repUnitValue ( $ n ) { if ( $ n % 2 == 0 $ n % 5 == 0 ) return 0 ; $ rem = 1 ; $ power = 1 ; $ k = 1 ; while ( $ rem % $ n != 0 ) { $ k ++ ; $ power = $ power * 10 % $ n ; $ rem = ( $ rem + $ power ) % $ n ; } return $ k ; }
function printLargest ( $ a , $ n ) { $ max = -1 ; $ ind = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ num = $ a [ $ i ] ; while ( $ num ) { $ r = $ num % 10 ; $ num = ( int ) $ num / 10 ; if ( $ num == 0 ) { if ( $ max < $ r ) { $ max = $ r ; $ ind = $ i ; } } } } for ( $ i = $ ind ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] ; for ( $ i = 0 ; $ i < $ ind ; $ i ++ ) echo $ a [ $ i ] ; }
function bellNumber ( $ n ) { $ bell [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ bell [ $ i ] [ 0 ] = $ bell [ $ i - 1 ] [ $ i - 1 ] ; for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ bell [ $ i ] [ $ j ] = $ bell [ $ i - 1 ] [ $ j - 1 ] + $ bell [ $ i ] [ $ j - 1 ] ; } return $ bell [ $ n ] [ 0 ] ; }
function printNGE ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ next = -1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { $ next = $ arr [ $ j ] ; break ; } } echo $ arr [ $ i ] . " -- " . ▁ $ next . " " } }
function countNonIncreasing ( $ arr , $ n ) { $ cnt = 0 ; $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ arr [ $ i + 1 ] <= $ arr [ $ i ] ) $ len ++ ; else { $ cnt += ( ( $ len + 1 ) * $ len ) / 2 ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( $ len + 1 ) * $ len ) / 2 ; return $ cnt ; }
function maximumSum ( $ arr , $ n , $ k ) { $ INT_MAX = 0 ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { $ min = $ INT_MAX ; $ index = -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] < $ min ) { $ min = $ arr [ $ j ] ; $ index = $ j ; } } if ( $ min == 0 ) break ; $ arr [ $ index ] = - $ arr [ $ index ] ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; return $ sum ; }
function countGroups ( $ position , $ previous_sum , $ length , $ num ) { if ( $ position == $ length ) return 1 ; $ res = 0 ; $ sum = 0 ; for ( $ i = $ position ; $ i < $ length ; $ i ++ ) { $ sum += ( $ num [ $ i ] - '0' ) ; if ( $ sum >= $ previous_sum ) $ res += countGroups ( $ i + 1 , $ sum , $ length , $ num ) ; } return $ res ; }
function sumOfSeries ( $ n ) { $ x ; if ( $ n % 2 == 0 ) $ x = ( $ n / 2 ) * ( $ n + 1 ) ; else $ x = ( ( $ n + 1 ) / 2 ) * $ n ; return $ x * $ x ; }
function maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ K ) { sort ( $ arr ) ; $ dp = array ( ) ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ dp [ $ i ] = $ dp [ $ i - 1 ] ; if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] < $ K ) { if ( $ i >= 2 ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ i - 2 ] + $ arr [ $ i ] + $ arr [ $ i - 1 ] ) ; else $ dp [ $ i ] = max ( $ dp [ $ i ] , $ arr [ $ i ] + $ arr [ $ i - 1 ] ) ; } } return $ dp [ $ N - 1 ] ; }
function numberOfPaths ( $ m , $ n ) { $ count = array ( ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ count [ $ i ] [ 0 ] = 1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ count [ 0 ] [ $ j ] = 1 ; for ( $ i = 1 ; $ i < $ m ; $ i ++ ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) $ count [ $ i ] [ $ j ] = $ count [ $ i - 1 ] [ $ j ] + $ count [ $ i ] [ $ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; } return $ count [ $ m - 1 ] [ $ n - 1 ] ; }
function countSolutions ( $ n ) { $ x = 0 ; $ yCount ; $ res = 0 ; for ( $ yCount = 0 ; $ yCount * $ yCount < $ n ; $ yCount ++ ) ; while ( $ yCount != 0 ) { $ res += $ yCount ; $ x ++ ; while ( $ yCount != 0 and ( $ x * $ x + ( $ yCount - 1 ) * ( $ yCount - 1 ) >= $ n ) ) $ yCount -- ; } return $ res ; }
function power ( $ n , $ r ) { $ count = 0 ; for ( $ i = $ r ; ( $ n / $ i ) >= 1 ; $ i = $ i * $ r ) $ count += $ n / $ i ; return $ count ; }
function minimumNumbers ( $ n , $ s ) { if ( $ s % $ n ) return round ( $ s / $ n + 1 ) ; else return round ( $ s / $ n ) ; }
function avg_of_even_num ( $ n ) { return $ n + 1 ; }
function possibleToReach ( $ a , $ b ) { $ c = ( $ a * $ b ) ; $ re1 = $ a / $ c ; $ re2 = $ b / $ c ; if ( ( $ re1 * $ re1 * $ re2 == $ a ) && ( $ re2 * $ re2 * $ re1 == $ b ) ) return 1 ; else return -1 ; }
function area ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ A = $ a * $ b ; return $ A ; }
function isUndulating ( $ n ) { if ( strlen ( $ n ) <= 2 ) return false ; for ( $ i = 2 ; $ i < strlen ( $ n ) ; $ i ++ ) if ( $ n [ $ i - 2 ] != $ n [ $ i ] ) false ; return true ; }
function seiresSum ( $ n , $ a ) { $ res = 0 ; for ( $ i = 0 ; $ i < 2 * $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ res += $ a [ $ i ] * $ a [ $ i ] ; else $ res -= $ a [ $ i ] * $ a [ $ i ] ; } return $ res ; }
function isRefactorableNumber ( $ n ) { $ divCount = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; ++ $ i ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) ++ $ divCount ; else $ divCount += 2 ; } } return $ n % $ divCount == 0 ; }
function printDemlo ( $ str ) { $ len = strlen ( $ str ) ; $ res = " " ; for ( $ i = 1 ; $ i <= $ len ; $ i ++ ) $ res . = chr ( $ i + 48 ) ; for ( $ i = $ len - 1 ; $ i >= 1 ; $ i -- ) $ res . = chr ( $ i + 48 ) ; return $ res ; }
function Move ( $ a , $ x , $ b ) { if ( ( ( ( $ b - $ a ) % $ x == 0 ) || ( ( $ b - $ a - 1 ) % $ x == 0 ) && $ a + 1 != $ b ) && $ b >= $ a ) return true ; return false ; }
function maxConsecutiveOnes ( $ x ) { $ count = 0 ; while ( $ x != 0 ) { $ x = ( $ x & ( $ x << 1 ) ) ; $ count ++ ; } return $ count ; }
function Cel_To_Fah ( $ n ) { return ( ( $ n * 9.0 / 5.0 ) + 32.0 ) ; }
function getPosition ( $ n , $ m ) { if ( $ m > ( $ n / 2 ) ) return ( $ m - ( $ n / 2 ) ) ; return ( $ m + ( $ n / 2 ) ) ; }
function isequal ( $ str ) { $ n = strlen ( $ str ) ; $ num = 0 ; $ x = 1 ; $ i = $ n - 1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( '0' <= $ str [ $ i ] && $ str [ $ i ] <= '9' ) { $ num = ( $ str [ $ i ] - '0' ) * $ x + $ num ; $ x = $ x * 10 ; if ( $ num >= $ n ) return false ; } else break ; } return $ num == $ i + 1 ; }
function seriesFunc ( $ n ) { $ sumSquare = ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; $ sumNatural = ( $ n * ( $ n + 1 ) / 2 ) ; return ( $ sumSquare + $ sumNatural + 1 ) ; }
function getProbability ( $ a , $ b , $ c , $ d ) { $ p = $ a / $ b ; $ q = $ c / $ d ; $ ans = $ p * ( 1 / ( 1 - ( 1 - $ q ) * ( 1 - $ p ) ) ) ; return round ( $ ans , 6 ) ; }
function find_probability ( $ p , $ q , $ r , $ s ) { $ t = ( 1 - $ p / $ q ) * ( 1 - $ r / $ s ) ; $ ans = ( $ p / $ q ) / ( 1 - $ t ) ; return $ ans ; }
function endPointOfDiameterofCircle ( $ x1 , $ y1 , $ c1 , $ c2 ) { echo " x2 = " , (2 ▁ * ▁ $ c1 ▁ - ▁ $ x1 ) , " " ; STRNEWLINE TABSYMBOL echo ▁ " y2 = " }
function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; }
function center_octadecagon_num ( $ n ) { return ( 9 * $ n * $ n - 9 * $ n + 1 ) ; }
function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; }
function sum ( $ x , $ n ) { $ i ; $ total = 1.0 ; $ multi = $ x ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ total = $ total + $ multi / $ i ; $ multi = $ multi * $ x ; } return $ total ; }
function smallest ( $ x , $ y , $ z ) { $ c = 0 ; while ( $ x && $ y && $ z ) { $ x -- ; $ y -- ; $ z -- ; $ c ++ ; } return $ c ; }
function countWays ( $ N ) { if ( $ N == 1 ) return 4 ; $ countB = 1 ; $ countS = 1 ; $ prev_countB ; $ prev_countS ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { $ prev_countB = $ countB ; $ prev_countS = $ countS ; $ countS = $ prev_countB + $ prev_countS ; $ countB = $ prev_countS ; } $ result = $ countS + $ countB ; return ( $ result * $ result ) ; }
function getProbability ( $ p , $ q ) { $ p /= 100 ; $ q /= 100 ; $ probability = ( $ p * $ p + $ q * $ q ) / ( $ p + $ q ) ; return $ probability ; }
function Pentatope_number ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) / 24 ; }
function closestMultiple ( $ n , $ x ) { if ( $ x > $ n ) return $ x ; $ n = $ n + $ x / 2 ; $ n = $ n - ( $ n % $ x ) ; return $ n ; }
function findMaximum ( $ arr , $ low , $ high ) { if ( $ low == $ high ) return $ arr [ $ low ] ; if ( ( $ high == $ low + 1 ) && $ arr [ $ low ] >= $ arr [ $ high ] ) return $ arr [ $ low ] ; if ( ( $ high == $ low + 1 ) && $ arr [ $ low ] < $ arr [ $ high ] ) return $ arr [ $ high ] ; $ mid = ( $ low + $ high ) / 2 ; if ( $ arr [ $ mid ] > $ arr [ $ mid + 1 ] && $ arr [ $ mid ] > $ arr [ $ mid - 1 ] ) return $ arr [ $ mid ] ; if ( $ arr [ $ mid ] > $ arr [ $ mid + 1 ] && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return findMaximum ( $ arr , $ low , $ mid - 1 ) ; else return findMaximum ( $ arr , $ mid + 1 , $ high ) ; }
function isMultipleof5 ( $ n ) { global $ MAX ; $ str = ( string ) $ n ; $ len = strlen ( $ str ) ; if ( $ str [ $ len - 1 ] == '5' $ str [ $ len - 1 ] == '0' ) return true ; return false ; }
function swapThree ( & $ a , & $ b , & $ c ) { $ a = $ a ^ $ b ^ $ c ; $ b = $ a ^ $ b ^ $ c ; $ c = $ a ^ $ b ^ $ c ; $ a = $ a ^ $ b ^ $ c ; }
