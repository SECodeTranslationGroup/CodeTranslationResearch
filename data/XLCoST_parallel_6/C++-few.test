bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
int longestSubArray ( int arr [ ] , int n ) { bool isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
ll F ( ll A , ll B ) { if ( A == 1 ) return ( 4 % B ) ; else { ll temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
bool sentencePalindrome ( string str ) { int l = 0 , h = str . length ( ) - 1 ; for ( int i = 0 ; i <= h ; i ++ ) str [ i ] = tolower ( str [ i ] ) ; while ( l <= h ) { if ( ! ( str [ l ] >= ' a ' && str [ l ] <= ' z ' ) ) l ++ ; else if ( ! ( str [ h ] >= ' a ' && str [ h ] <= ' z ' ) ) h -- ; else if ( str [ l ] == str [ h ] ) l ++ , h -- ; else return false ; } return true ; }
float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = max ( x1 , x3 ) ; int y5 = max ( y1 , y3 ) ; int x6 = min ( x2 , x4 ) ; int y6 = min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { cout << " No ▁ intersection " ; return ; } cout << " ( " << x5 << " , ▁ " << y5 << " ) ▁ " ; cout << " ( " << x6 << " , ▁ " << y6 << " ) ▁ " ; int x7 = x5 ; int y7 = y6 ; cout << " ( " << x7 << " , ▁ " << y7 << " ) ▁ " ; int x8 = x6 ; int y8 = y5 ; cout << " ( " << x8 << " , ▁ " << y8 << " ) ▁ " ; }
int maxSum ( int mat [ SIZE ] [ SIZE ] , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ n ] [ n ] ; int maxSum = INT_MIN , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = INT_MIN ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = pow ( a , n ) + pow ( b , n ) ; double c = pow ( pow_sum , 1.0 / n ) ; int c_pow = pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { cout << " Count ▁ example ▁ found " ; return ; } } cout << " No ▁ counter ▁ example ▁ within ▁ given " " ▁ range ▁ and ▁ data " ; }
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << " Triplet ▁ is ▁ " << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] ; return true ; } } } } return false ; }
int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
float pentdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.22 * a ; return d ; }
int evenNumSubstring ( char str [ ] ) { int len = strlen ( str ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
bool isPerfectSquareString ( string str ) { int sum = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] ; long double squareRoot = sqrt ( sum ) ; return ( ( squareRoot - floor ( squareRoot ) ) == 0 ) ; }
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
int StepstoReachTarget ( int target ) { target = abs ( target ) ; int n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) ? 2 : 1 ) ; }
float findAreaShaded ( float a ) { float sqArea = a * a ; float semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ; float ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; }
int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return -1 ; }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
int maxSum ( int arr [ ] , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
int maxLines ( int n , int x1 [ ] , int y1 [ ] , int x2 [ ] , int y2 [ ] ) { unordered_set < double > s ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = INT_MAX ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . insert ( slope ) ; } return s . size ( ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; }
void pairwiseDifference ( int arr [ ] , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = abs ( arr [ i ] - arr [ i + 1 ] ) ; cout << diff << " ▁ " ; } }
int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = min ( mn , A [ i ] ) ; mx = max ( mx , A [ i ] ) ; } return max ( 0 , mx - mn - 2 * x ) ; }
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != -1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; }
int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd += 1 ; return ( odd % 2 ) ? 1 : 2 ; }
string encryptString ( string str , int n ) { int i = 0 , cnt = 0 ; string encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; }
int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) pow ( i , i ) ; int numerator = ( int ) pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
int maxSum ( int a [ ] , int n ) { int ans = 0 ; int * arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int * * dp = new int * [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = new int [ 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = max ( ans , dp [ i ] [ 0 ] ) ; ans = max ( ans , dp [ i ] [ 1 ] ) ; ans = max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ; } else { return pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ; } }
int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return -1 ; }
bool isDvisibleBy12 ( string num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num [ num . length ( ) - 1 ] ; if ( d1 % 2 != 0 ) return ( 0 ) ; int d2 = ( int ) num [ num . length ( ) - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = stoi ( num ) ; return ( number % 12 == 0 ) ; } }
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << " ▁ " ; C = C * ( line - i ) / i ; } cout << " STRNEWLINE " ; } }
int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }
int number_of_tower ( int house [ ] , int range , int n ) { sort ( house , house + n ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
void reArrange ( string words [ ] , int n ) { map < string , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ words [ i ] ] = i + 1 ; sort ( words , words + n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << mp [ words [ i ] ] << " ▁ " ; }
void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ; else break ; } }
int countDe ( int arr [ ] , int n ) { vector < int > v ( arr , arr + n ) ; sort ( arr , arr + n ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; reverse ( arr , arr + n ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( min ( count1 , count2 ) ) ; }
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) cout << " Angle ▁ not ▁ possible " ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector ; } }
int results ( int n , int k ) { return round ( pow ( n , ( 1.0 / pow ( 2 , k ) ) ) ) ; }
int findRepeatFirstN2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; }
int missingNumber ( int arr1 [ ] , int arr2 [ ] , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
int countSequences ( int arr [ ] , int n ) { int count = 1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
unsigned countBits ( unsigned int number ) { return ( int ) log2 ( number ) + 1 ; }
int countNumbers ( int n ) { int k = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += pow ( 2 , k ) ; k += 1 ; n >>= 1 ; } return count ; }
char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ; return 0 ; }
void center ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " , ▁ " << ( float ) ( y1 + y2 ) / 2 ; }
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
ll multiply ( ll x , ll n ) { return x << n ; }
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }
int minimal ( int a [ ] , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
int fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " << x << " ▁ & ▁ " << y ; }
ll minSum ( int arr [ ] , int n , int x ) { ll sum = 0 ; int largestDivisible = -1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == -1 ) return sum ; ll sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return min ( sum , sumAfterOperation ) ; }
int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - pow ( i , 2 ) ; else result = result + pow ( i , 2 ) ; } return result ; }
int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return -1 ; }
void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { sort ( arrl , arrl + n ) ; sort ( exit , exit + n ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } cout << " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " << max_guests << " ▁ at ▁ time ▁ " << time ; }
int numberofways ( int n , int m ) { int dp [ n + 2 ] [ n + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
int series ( int n ) { return ( 8 * n * n ) + 1 ; }
int find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; }
ll CalculateMax ( ll arr [ ] , int n ) { sort ( arr , arr + n ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return abs ( max_sum - min_sum ) ; }
string updateString ( string S , string A , string B ) { int l = A . length ( ) ; for ( int i = 0 ; i + l <= S . length ( ) ; i ++ ) { string curr = S . substr ( i , i + l ) ; if ( curr == A ) { string new_string = " " ; new_string += S . substr ( 0 , i ) + B + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } else { string new_string = " " ; new_string += S . substr ( 0 , i ) + A + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } } return S ; }
int MinimumMail ( int n , int k , int x ) { ll m = ( n - 1 ) + ( ll ) ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + ( ll ) ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= cbrt ( N ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = cbrt ( diff ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
void pendulumArrangement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int op [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; cout << " Pendulum ▁ arrangement : " << endl ; for ( i = 0 ; i < n ; i ++ ) cout << op [ i ] << " ▁ " ; cout << endl ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
int maxLength ( char s [ ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ( ' && s [ i + 1 ] == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ( ' && s [ j ] == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
int findKthGoodNo ( long long int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
int countBT ( int h ) { long long int dp [ h + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod ; } return dp [ h ] ; }
bool pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; { cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
int countChar ( string str ) { int n = str . length ( ) ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
int minCost ( int A [ ] , int n ) { int cost = 0 ; sort ( A , A + n ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += abs ( A [ i ] - K ) ; cost = min ( cost , tempCost ) ; } return cost ; }
int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return max ( max_length , count ) ; }
int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) pow ( 10 , temp ) ; palindrome += n - 1 ; printf ( " % d " , palindrome ) ; if ( k & 1 ) palindrome /= 10 ; while ( palindrome ) { printf ( " % d " , palindrome % 10 ) ; palindrome /= 10 ; } printf ( " STRNEWLINE " ) ; }
int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return -1 ; }
int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != -1 ) return dp [ ind ] ; else { int ans = INT_MAX ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; cout << r ; }
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input unlock_code ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
bool sumSquare ( int n ) { for ( long i = 1 ; i * i <= n ; i ++ ) for ( long j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { cout << i << " ^ 2 ▁ + ▁ " << j << " ^ 2" << endl ; return true ; } return false ; }
void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
int calculate ( string s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s [ 0 ] - '0' ) c ++ ; if ( j != s [ 1 ] - '0' ) c ++ ; if ( k != s [ 2 ] - '0' ) c ++ ; if ( l != s [ 3 ] - '0' ) c ++ ; if ( m != s [ 4 ] - '0' ) c ++ ; if ( n != s [ 5 ] - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
int number_of_tower ( int house [ ] , int range , int n ) { sort ( house , house + n ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
int getOddOccurrence ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return -1 ; }
int day_of_the_week ( int y , int m , int d ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ) ; }
int countDistinct ( int arr [ ] , int n ) { unordered_set < int > s ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; res ++ ; } } return res ; }
bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
