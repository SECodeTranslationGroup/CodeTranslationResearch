def sumDigits ( no ) : NEW_LINE INDENT return 0 if no == 0 else int ( no % 10 ) + sumDigits ( int ( no / 10 ) ) NEW_LINE DEDENT
def findSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i // j NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def ispalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE j = l - 1 NEW_LINE while i <= j : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def getMinStepToReachEnd ( arr , N ) : NEW_LINE INDENT visit = [ False for i in range ( N ) ] NEW_LINE distance = [ 0 for i in range ( N ) ] NEW_LINE digit = [ [ 0 for i in range ( N ) ] for j in range ( 10 ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT digit [ arr [ i ] ] . append ( i ) NEW_LINE DEDENT distance [ 0 ] = 0 NEW_LINE visit [ 0 ] = True NEW_LINE q = [ ] NEW_LINE q . append ( 0 ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT idx = q [ 0 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE if ( idx == N - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT d = arr [ idx ] NEW_LINE for i in range ( len ( digit [ d ] ) ) : NEW_LINE INDENT nextidx = digit [ d ] [ i ] NEW_LINE if ( visit [ nextidx ] == False ) : NEW_LINE INDENT visit [ nextidx ] = True NEW_LINE q . append ( nextidx ) NEW_LINE distance [ nextidx ] = distance [ idx ] + 1 NEW_LINE DEDENT DEDENT if ( idx - 1 >= 0 and visit [ idx - 1 ] == False ) : NEW_LINE INDENT visit [ idx - 1 ] = True NEW_LINE q . append ( idx - 1 ) NEW_LINE distance [ idx - 1 ] = distance [ idx ] + 1 NEW_LINE DEDENT if ( idx + 1 < N and visit [ idx + 1 ] == False ) : NEW_LINE INDENT visit [ idx + 1 ] = True NEW_LINE q . append ( idx + 1 ) NEW_LINE distance [ idx + 1 ] = distance [ idx ] + 1 NEW_LINE DEDENT DEDENT return distance [ N - 1 ] NEW_LINE DEDENT
def findWays ( f , d , s ) : NEW_LINE INDENT mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] NEW_LINE mem [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( 1 , s + 1 ) : NEW_LINE INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] NEW_LINE if j - f - 1 >= 0 : NEW_LINE INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mem [ d ] [ s ] NEW_LINE DEDENT
def maxvolume ( s ) : NEW_LINE INDENT maxvalue = 0 NEW_LINE i = 1 NEW_LINE for i in range ( s - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( s ) : NEW_LINE INDENT k = s - i - j NEW_LINE maxvalue = max ( maxvalue , i * j * k ) NEW_LINE DEDENT DEDENT return maxvalue NEW_LINE DEDENT
def minDaysToEmpty ( C , l ) : NEW_LINE INDENT if ( l >= C ) : return C NEW_LINE eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 NEW_LINE return math . ceil ( eq_root ) + l NEW_LINE DEDENT
def minDiff ( arr , n , k ) : NEW_LINE INDENT result = + 2147483647 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def concatenate ( a , b , c , n1 , n2 ) : NEW_LINE INDENT i = - 1 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT c [ i ] = a [ i ] NEW_LINE DEDENT for j in range ( n2 ) : NEW_LINE INDENT c [ i ] = b [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def printMaxSubSquare ( M ) : NEW_LINE INDENT R = len ( M ) NEW_LINE C = len ( M [ 0 ] ) NEW_LINE S = [ [ 0 for k in range ( C ) ] for l in range ( R ) ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT if ( M [ i ] [ j ] == 1 ) : NEW_LINE INDENT S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT S [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT max_of_s = S [ 0 ] [ 0 ] NEW_LINE max_i = 0 NEW_LINE max_j = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( max_of_s < S [ i ] [ j ] ) : NEW_LINE INDENT max_of_s = S [ i ] [ j ] NEW_LINE max_i = i NEW_LINE max_j = j NEW_LINE DEDENT DEDENT DEDENT print ( " Maximum ▁ size ▁ sub - matrix ▁ is : ▁ " ) NEW_LINE for i in range ( max_i , max_i - max_of_s , - 1 ) : NEW_LINE INDENT for j in range ( max_j , max_j - max_of_s , - 1 ) : NEW_LINE INDENT print ( M [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT max = arr1 [ 0 ] NEW_LINE min = arr2 [ 0 ] NEW_LINE i = 1 NEW_LINE while ( i < n1 and i < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] > max ) : NEW_LINE INDENT max = arr1 [ i ] NEW_LINE DEDENT if ( arr2 [ i ] < min ) : NEW_LINE INDENT min = arr2 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while ( i < n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max ) : NEW_LINE INDENT max = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT while ( i < n2 ) : NEW_LINE INDENT if ( arr2 [ i ] < min ) : NEW_LINE INDENT min = arr2 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return max * min NEW_LINE DEDENT
def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( ) NEW_LINE exit . sort ( ) NEW_LINE guests_in = 1 NEW_LINE max_guests = 1 NEW_LINE time = arrl [ 0 ] NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arrl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guests_in = guests_in + 1 NEW_LINE if ( guests_in > max_guests ) : NEW_LINE INDENT max_guests = guests_in NEW_LINE time = arrl [ i ] NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT guests_in = guests_in - 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = " , max_guests , " at ▁ time " , time ) NEW_LINE DEDENT
def Identity ( size ) : NEW_LINE INDENT for row in range ( 0 , size ) : NEW_LINE INDENT for col in range ( 0 , size ) : NEW_LINE INDENT if ( row == col ) : NEW_LINE INDENT print ( "1 ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0 ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def reorder ( arr , index , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp [ index [ i ] ] = arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE index [ i ] = i NEW_LINE DEDENT DEDENT
def printCountDP ( dist ) : NEW_LINE INDENT count = [ 0 ] * ( dist + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE count [ 1 ] = 1 NEW_LINE count [ 2 ] = 2 NEW_LINE for i in range ( 3 , dist + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) NEW_LINE DEDENT return count [ dist ] NEW_LINE DEDENT
def maximumChars ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = - 1 NEW_LINE firstInd = [ - 1 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT first_ind = firstInd [ ord ( str1 [ i ] ) ] NEW_LINE if ( first_ind == - 1 ) : NEW_LINE INDENT firstInd [ ord ( str1 [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def FirstRepeated ( string ) : NEW_LINE INDENT checker = 0 NEW_LINE pos = 0 NEW_LINE for i in string : NEW_LINE INDENT val = ord ( i ) - ord ( ' a ' ) ; NEW_LINE if ( ( checker & ( 1 << val ) ) > 0 ) : NEW_LINE INDENT return pos NEW_LINE DEDENT checker |= ( 1 << val ) NEW_LINE pos += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findMaxProduct ( arr , n ) : NEW_LINE INDENT ans = - float ( ' inf ' ) NEW_LINE maxval = 1 NEW_LINE minval = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT maxval = maxval * arr [ i ] NEW_LINE minval = min ( 1 , minval * arr [ i ] ) NEW_LINE DEDENT elif arr [ i ] == 0 : NEW_LINE INDENT minval = 1 NEW_LINE maxval = 0 NEW_LINE DEDENT elif arr [ i ] < 0 : NEW_LINE INDENT prevMax = maxval NEW_LINE maxval = minval * arr [ i ] NEW_LINE minval = prevMax * arr [ i ] NEW_LINE DEDENT ans = max ( ans , maxval ) NEW_LINE if maxval <= 0 : NEW_LINE INDENT maxval = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def survival ( S , N , M ) : NEW_LINE INDENT if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT days = ( M * S ) / N NEW_LINE if ( ( ( M * S ) % N ) != 0 ) : NEW_LINE INDENT days += 1 NEW_LINE DEDENT print ( " Yes ▁ " ) , NEW_LINE print ( days ) NEW_LINE DEDENT DEDENT
def firstnonrepeating ( Str ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE q = Queue ( ) NEW_LINE charCount = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT q . put ( Str [ i ] ) NEW_LINE charCount [ ord ( Str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT if ( charCount [ ord ( q . queue [ 0 ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT q . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q . queue [ 0 ] , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( q . empty ( ) ) : NEW_LINE INDENT print ( - 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def dfs ( List , node , arrival ) : NEW_LINE INDENT print ( node ) NEW_LINE for i in range ( len ( List [ node ] ) ) : NEW_LINE INDENT if ( List [ node ] [ i ] != arrival ) : NEW_LINE INDENT dfs ( List , List [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT res = res ^ ( i + 1 ) ^ arr [ i ] NEW_LINE DEDENT res = res ^ arr [ n - 1 ] NEW_LINE return res NEW_LINE DEDENT
def getCount ( keypad , n ) : NEW_LINE INDENT if ( not keypad or n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT odd = [ 0 ] * 10 NEW_LINE even = [ 0 ] * 10 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE useOdd = 0 NEW_LINE totalCount = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE DEDENT for j in range ( 2 , n + 1 ) : NEW_LINE INDENT useOdd = 1 - useOdd NEW_LINE if ( useOdd == 1 ) : NEW_LINE INDENT even [ 0 ] = odd [ 0 ] + odd [ 8 ] NEW_LINE even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] NEW_LINE even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] NEW_LINE even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] NEW_LINE even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] NEW_LINE even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] NEW_LINE even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] NEW_LINE even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] NEW_LINE even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] NEW_LINE even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] NEW_LINE DEDENT else : NEW_LINE INDENT odd [ 0 ] = even [ 0 ] + even [ 8 ] NEW_LINE odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] NEW_LINE odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] NEW_LINE odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] NEW_LINE odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] NEW_LINE odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] NEW_LINE odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] NEW_LINE odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] NEW_LINE odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] NEW_LINE odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] NEW_LINE DEDENT DEDENT totalCount = 0 NEW_LINE if ( useOdd == 1 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT totalCount += even [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT totalCount += odd [ i ] NEW_LINE DEDENT DEDENT return totalCount NEW_LINE DEDENT
def countSubarrWithEqualZeroAndOne ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE Sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT Sum += arr [ i ] NEW_LINE if ( Sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( Sum in mp . keys ( ) ) : NEW_LINE INDENT count += mp [ Sum ] NEW_LINE DEDENT mp [ Sum ] = mp . get ( Sum , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def search ( mat , fromRow , toRow , fromCol , toCol , key ) : NEW_LINE INDENT i = fromRow + ( toRow - fromRow ) // 2 NEW_LINE j = fromCol + ( toCol - fromCol ) // 2 NEW_LINE if ( mat [ i ] [ j ] == key ) : NEW_LINE INDENT print ( " Found ▁ " , key , " ▁ at ▁ " , i , " ▁ " , j ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( i != toRow or j != fromCol ) : NEW_LINE INDENT search ( mat , fromRow , i , j , toCol , key ) NEW_LINE DEDENT if ( fromRow == toRow and fromCol + 1 == toCol ) : NEW_LINE INDENT if ( mat [ fromRow ] [ toCol ] == key ) : NEW_LINE INDENT print ( " Found ▁ " , key , " ▁ at ▁ " , fromRow , " ▁ " , toCol ) NEW_LINE DEDENT DEDENT if ( mat [ i ] [ j ] < key ) : NEW_LINE INDENT if ( i + 1 <= toRow ) : NEW_LINE INDENT search ( mat , i + 1 , toRow , fromCol , toCol , key ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j - 1 >= fromCol ) : NEW_LINE INDENT search ( mat , fromRow , toRow , fromCol , j - 1 , key ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def kthgroupsum ( k ) : NEW_LINE INDENT return k * k * k NEW_LINE DEDENT
def areKAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT hash_str1 = [ 0 ] * ( MAX_CHAR ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash_str1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash_str1 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] > 0 ) : NEW_LINE INDENT hash_str1 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def bonacciseries ( n , m ) : NEW_LINE INDENT a = [ 0 ] * m NEW_LINE a [ n - 1 ] = 1 NEW_LINE for i in range ( n , m ) : NEW_LINE INDENT for j in range ( i - n , i ) : NEW_LINE INDENT a [ i ] = a [ i ] + a [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printMinIndexChar ( Str , patt ) : NEW_LINE INDENT minIndex = 10 ** 9 NEW_LINE m = len ( Str ) NEW_LINE n = len ( patt ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( patt [ i ] == Str [ j ] and j < minIndex ) : NEW_LINE INDENT minIndex = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minIndex != 10 ** 9 ) : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ Character ▁ = ▁ " , Str [ minIndex ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ character ▁ present " ) NEW_LINE DEDENT DEDENT
def negCyclefloydWarshall ( graph ) : NEW_LINE INDENT dist = [ [ 0 for i in range ( V + 1 ) ] for j in range ( V + 1 ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT dist [ i ] [ j ] = graph [ i ] [ j ] NEW_LINE DEDENT DEDENT for k in range ( V ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : NEW_LINE INDENT dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( V ) : NEW_LINE INDENT if ( dist [ i ] [ i ] < 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def lexNext ( s , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != ' z ' : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE s [ i ] = chr ( k + 1 ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT s [ i ] = ' a ' NEW_LINE DEDENT DEDENT
def printDuo ( string ) : NEW_LINE INDENT countChar = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE n = len ( string ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT countChar [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str1 = " " NEW_LINE str2 = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( countChar [ i ] > 1 ) : NEW_LINE INDENT str2 = str2 + chr ( i + ord ( ' a ' ) ) NEW_LINE DEDENT elif ( countChar [ i ] == 1 ) : NEW_LINE INDENT str1 = str1 + chr ( i + ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT print ( " String ▁ with ▁ characters ▁ occurring ▁ once : " , " \n " , str1 ) NEW_LINE print ( " String ▁ with ▁ characters ▁ occurring " , " multiple ▁ times : " , " \n " , str2 ) NEW_LINE DEDENT
def Round_off ( N , n ) : NEW_LINE INDENT b = N NEW_LINE c = floor ( N ) NEW_LINE i = 0 NEW_LINE while ( b >= 1 ) : NEW_LINE INDENT b = b / 10 NEW_LINE i = i + 1 NEW_LINE DEDENT d = n - i NEW_LINE b = N NEW_LINE b = b * pow ( 10 , d ) NEW_LINE e = b + 0.5 NEW_LINE if ( float ( e ) == float ( ceil ( b ) ) ) : NEW_LINE INDENT f = ( ceil ( b ) ) NEW_LINE h = f - 2 NEW_LINE if ( h % 2 != 0 ) : NEW_LINE INDENT e = e - 1 NEW_LINE DEDENT DEDENT j = floor ( e ) NEW_LINE m = pow ( 10 , d ) NEW_LINE j = j / m NEW_LINE print ( " The ▁ number ▁ after ▁ rounding - off ▁ is " , j ) NEW_LINE DEDENT
def printRotatedString ( str ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE temp = [ 0 ] * ( lenn ) NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT j = i NEW_LINE k = 0 NEW_LINE while ( j < len ( str ) ) : NEW_LINE INDENT temp [ k ] = str [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT j = 0 NEW_LINE while ( j < i ) : NEW_LINE INDENT temp [ k ] = str [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT print ( * temp , sep = " " ) NEW_LINE DEDENT DEDENT
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT d1 += arr [ i ] [ j ] NEW_LINE DEDENT if ( i == n - j - 1 ) : NEW_LINE INDENT d2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return abs ( d1 - d2 ) NEW_LINE DEDENT
def calculate ( N ) : NEW_LINE INDENT length = len ( N ) NEW_LINE l = int ( ( length ) / 2 ) NEW_LINE count = 0 NEW_LINE for i in range ( l + 1 ) : NEW_LINE INDENT s = N [ 0 : 0 + i ] NEW_LINE l1 = len ( s ) NEW_LINE t = N [ i : l1 + i ] NEW_LINE try : NEW_LINE INDENT if s [ 0 ] == '0' or t [ 0 ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT continue NEW_LINE DEDENT if s == t : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def printUnion ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT elif arr2 [ j ] < arr1 [ i ] : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT while i < m : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT while j < n : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
def printDistinct ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE index = [ n for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ord ( Str [ i ] ) NEW_LINE count [ x ] += 1 NEW_LINE if ( count [ x ] == 1 and x != ' ▁ ' ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT index = sorted ( index ) NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if index [ i ] == n : NEW_LINE INDENT break NEW_LINE DEDENT print ( Str [ index [ i ] ] , end = " " ) NEW_LINE DEDENT DEDENT
def findCommon ( mat ) : NEW_LINE INDENT column = [ N - 1 ] * M NEW_LINE min_row = 0 NEW_LINE while ( column [ min_row ] >= 0 ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) : NEW_LINE INDENT min_row = i NEW_LINE DEDENT DEDENT eq_count = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) : NEW_LINE INDENT if ( column [ i ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT column [ i ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT eq_count += 1 NEW_LINE DEDENT DEDENT if ( eq_count == M ) : NEW_LINE INDENT return mat [ min_row ] [ column [ min_row ] ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT
def maxProfit ( prices , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT max_so_far = 0 NEW_LINE for l in range ( i ) : NEW_LINE INDENT max_so_far = max ( max_so_far , prices [ i ] - prices [ l ] + profit [ l ] [ j - 1 ] ) NEW_LINE DEDENT profit [ i ] [ j ] = max ( profit [ i - 1 ] [ j ] , max_so_far ) NEW_LINE DEDENT DEDENT return profit [ n - 1 ] [ k ] NEW_LINE DEDENT
def match ( first , second ) : NEW_LINE INDENT if len ( first ) == 0 and len ( second ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( first ) > 1 and first [ 0 ] == ' * ' and len ( second ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( first ) > 1 and first [ 0 ] == ' ? ' ) or ( len ( first ) != 0 and len ( second ) != 0 and first [ 0 ] == second [ 0 ] ) : NEW_LINE INDENT return match ( first [ 1 : ] , second [ 1 : ] ) ; NEW_LINE DEDENT if len ( first ) != 0 and first [ 0 ] == ' * ' : NEW_LINE INDENT return match ( first [ 1 : ] , second ) or match ( first , second [ 1 : ] ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE y = N / K NEW_LINE x = N % K NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) NEW_LINE return int ( ans ) NEW_LINE DEDENT
def isPermutedMatrix ( mat , n ) : NEW_LINE INDENT str_cat = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT str_cat = str_cat + " - " + str ( mat [ 0 ] [ i ] ) NEW_LINE DEDENT str_cat = str_cat + str_cat NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_str = " " NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_str = curr_str + " - " + str ( mat [ i ] [ j ] ) NEW_LINE DEDENT if ( str_cat . find ( curr_str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isSparse ( array , m , n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( array [ i ] [ j ] == 0 ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT return ( counter > ( ( m * n ) // 2 ) ) NEW_LINE DEDENT
def findArea ( r ) : NEW_LINE INDENT PI = 3.142 NEW_LINE return PI * ( r * r ) NEW_LINE DEDENT
def countObtuseAngles ( a , b , k ) : NEW_LINE INDENT c1 = ( b - a ) - 1 NEW_LINE c2 = ( k - b ) + ( a - 1 ) NEW_LINE if ( c1 == c2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( c1 , c2 ) NEW_LINE DEDENT
def counterClockspiralPrint ( m , n , arr ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE cnt = 0 NEW_LINE total = m * n NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( k , m ) : NEW_LINE INDENT print ( arr [ i ] [ l ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT l += 1 NEW_LINE if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( l , n ) : NEW_LINE INDENT print ( arr [ m - 1 ] [ i ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT m -= 1 NEW_LINE if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( k < m ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ i ] [ n - 1 ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ k ] [ i ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT
def numberOfTriangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 NEW_LINE return ans NEW_LINE DEDENT
def minmaxProduct ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE return arr1 [ n1 - 1 ] * arr2 [ 0 ] NEW_LINE DEDENT
def timeToMeet ( s , v ) : NEW_LINE INDENT V = 3 * v / 2 NEW_LINE time = s / V NEW_LINE print ( time ) NEW_LINE DEDENT
def countToMake0lternate ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printCountRec ( dist ) : NEW_LINE INDENT if dist < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dist == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ) NEW_LINE DEDENT
def compute_average ( a , b ) : NEW_LINE INDENT return ( a // 2 ) + ( b // 2 ) + ( ( a % 2 + b % 2 ) // 2 ) NEW_LINE DEDENT
def countSubStr ( st , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( st [ j ] == '1' ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def isDivisibleBy10 ( bin ) : NEW_LINE INDENT n = len ( bin ) NEW_LINE if ( bin [ n - 1 ] == '1' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( bin [ i ] == '1' ) : NEW_LINE INDENT posFromRight = n - i - 1 NEW_LINE if ( posFromRight % 4 == 1 ) : NEW_LINE INDENT sum = sum + 2 NEW_LINE DEDENT elif ( posFromRight % 4 == 2 ) : NEW_LINE INDENT sum = sum + 4 NEW_LINE DEDENT elif ( posFromRight % 4 == 3 ) : NEW_LINE INDENT sum = sum + 8 NEW_LINE DEDENT elif ( posFromRight % 4 == 0 ) : NEW_LINE INDENT sum = sum + 6 NEW_LINE DEDENT DEDENT i = i - 1 NEW_LINE DEDENT if ( sum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def search ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return None NEW_LINE DEDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if mid % 2 == 0 : NEW_LINE INDENT if arr [ mid ] == arr [ mid + 1 ] : NEW_LINE INDENT return search ( arr , mid + 2 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ mid ] == arr [ mid - 1 ] : NEW_LINE INDENT return search ( arr , mid + 1 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = arr_size - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ i ] + A [ l ] + A [ r ] == sum ) : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , ' , ▁ ' , A [ l ] , ' , ▁ ' , A [ r ] ) NEW_LINE return True NEW_LINE DEDENT elif ( A [ i ] + A [ l ] + A [ r ] < sum ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def makePermutation ( a , n ) : NEW_LINE INDENT count = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count . get ( a [ i ] ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT next_missing = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 : NEW_LINE INDENT count [ a [ i ] ] -= 1 NEW_LINE while count . get ( next_missing ) : NEW_LINE INDENT next_missing += 1 NEW_LINE DEDENT a [ i ] = next_missing NEW_LINE count [ next_missing ] = 1 NEW_LINE DEDENT DEDENT DEDENT
def optimalStrategyOfGame ( arr , n ) : NEW_LINE INDENT table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for gap in range ( n ) : NEW_LINE INDENT for j in range ( gap , n ) : NEW_LINE INDENT i = j - gap NEW_LINE x = 0 NEW_LINE if ( ( i + 2 ) <= j ) : NEW_LINE INDENT x = table [ i + 2 ] [ j ] NEW_LINE DEDENT y = 0 NEW_LINE if ( ( i + 1 ) <= ( j - 1 ) ) : NEW_LINE INDENT y = table [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT z = 0 NEW_LINE if ( i <= ( j - 2 ) ) : NEW_LINE INDENT z = table [ i ] [ j - 2 ] NEW_LINE DEDENT table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) NEW_LINE DEDENT DEDENT return table [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def findSumSubsets ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def seiresSum ( n , a ) : NEW_LINE INDENT return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ) NEW_LINE DEDENT
def interchangeFirstLast ( mat , n , m ) : NEW_LINE INDENT rows = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = mat [ 0 ] [ i ] NEW_LINE mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] NEW_LINE mat [ rows - 1 ] [ i ] = t NEW_LINE DEDENT DEDENT
def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE DEDENT
def maxOverlap ( start , end ) : NEW_LINE INDENT n = len ( start ) NEW_LINE maxa = max ( start ) NEW_LINE maxb = max ( end ) NEW_LINE maxc = max ( maxa , maxb ) NEW_LINE x = ( maxc + 2 ) * [ 0 ] NEW_LINE cur = 0 idx = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT x [ start [ i ] ] += 1 NEW_LINE x [ end [ i ] + 1 ] -= 1 NEW_LINE DEDENT maxy = - 1 NEW_LINE for i in range ( 0 , maxc + 1 ) : NEW_LINE INDENT cur += x [ i ] NEW_LINE if maxy < cur : NEW_LINE INDENT maxy = cur NEW_LINE idx = i NEW_LINE DEDENT DEDENT print ( " Maximum ▁ value ▁ is : ▁ { 0 : d } " . format ( maxy ) , " ▁ at ▁ position : ▁ { 0 : d } " . format ( idx ) ) NEW_LINE DEDENT
def canFormPalindrome ( strr ) : NEW_LINE INDENT listt = [ ] NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT if ( strr [ i ] in listt ) : NEW_LINE INDENT listt . remove ( strr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT listt . append ( strr [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( strr ) % 2 == 0 and len ( listt ) == 0 or \ ( len ( strr ) % 2 == 1 and len ( listt ) == 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def fib ( n , a = 0 , b = 1 ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return b NEW_LINE DEDENT return fib ( n - 1 , b , a + b ) ; NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] & a [ j ] ) == 0 : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def kmax ( arr , k , n ) : NEW_LINE INDENT for c in range ( k ) : NEW_LINE INDENT max_so_far = - float ( " inf " ) NEW_LINE max_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_here += arr [ i ] NEW_LINE if ( max_so_far < max_here ) : NEW_LINE INDENT max_so_far = max_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if ( max_here < 0 ) : NEW_LINE INDENT max_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ non - overlapping ▁ sub - array ▁ sum " , c + 1 , " : ▁ " , max_so_far , " , ▁ starting ▁ index : ▁ " , start , " , ▁ ending ▁ index : ▁ " , end , " . " , sep = " " ) NEW_LINE for l in range ( start , end + 1 ) : NEW_LINE INDENT arr [ l ] = - float ( " inf " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE hzntl = 1 vert = 1 NEW_LINE i = 0 j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT
def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT if ( k is not 1 ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT DEDENT
def minPalPartion ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE C = [ 0 ] * ( n + 1 ) NEW_LINE P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if ( L == 2 ) : NEW_LINE INDENT P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( P [ 0 ] [ i ] == True ) : NEW_LINE INDENT C [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] = sys . maxsize NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( P [ j + 1 ] [ i ] == True and 1 + C [ j ] < C [ i ] ) : NEW_LINE INDENT C [ i ] = 1 + C [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return C [ n - 1 ] NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if i * j == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT
def printLevels ( graph , V , x ) : NEW_LINE INDENT level = [ None ] * V NEW_LINE marked = [ False ] * V NEW_LINE que = queue . Queue ( ) NEW_LINE que . put ( x ) NEW_LINE level [ x ] = 0 NEW_LINE marked [ x ] = True NEW_LINE while ( not que . empty ( ) ) : NEW_LINE INDENT x = que . get ( ) NEW_LINE for i in range ( len ( graph [ x ] ) ) : NEW_LINE INDENT b = graph [ x ] [ i ] NEW_LINE if ( not marked [ b ] ) : NEW_LINE INDENT que . put ( b ) NEW_LINE level [ b ] = level [ x ] + 1 NEW_LINE marked [ b ] = True NEW_LINE DEDENT DEDENT DEDENT print ( " Nodes " , " ▁ " , " Level " ) NEW_LINE for i in range ( V ) : NEW_LINE INDENT print ( " ▁ " , i , " ▁ - - > ▁ " , level [ i ] ) NEW_LINE DEDENT DEDENT
def numOfways ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if ( k % 2 ) : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n NEW_LINE DEDENT
def dealnnoy ( n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) NEW_LINE DEDENT
def subArrayExists ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if sum == 0 or sum in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( sum ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def merge ( ar1 , ar2 , m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = ar1 [ m - 1 ] NEW_LINE j = m - 2 NEW_LINE while ( j >= 0 and ar1 [ j ] > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar1 [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j != m - 2 or last > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar2 [ i ] NEW_LINE ar2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT
def longestString ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result = result + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT
def decodeMedianString ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s1 = " " NEW_LINE if ( l % 2 == 0 ) : NEW_LINE INDENT isEven = True NEW_LINE DEDENT else : NEW_LINE INDENT isEven = False NEW_LINE DEDENT for i in range ( 0 , l , 2 ) : NEW_LINE INDENT if ( isEven ) : NEW_LINE INDENT s1 = s [ i ] + s1 NEW_LINE s1 += s [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( l - i > 1 ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s1 = s [ i + 1 ] + s1 NEW_LINE DEDENT else : NEW_LINE INDENT s1 += s [ i ] NEW_LINE DEDENT DEDENT DEDENT return s1 NEW_LINE DEDENT
def MaximumPath ( Mat ) : NEW_LINE INDENT result = 0 NEW_LINE dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + \ NEW_LINE INDENT Mat [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT result = max ( result , dp [ N - 1 ] [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def minSwap ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] <= k ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT bad = 0 NEW_LINE for i in range ( 0 , count ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT bad = bad + 1 NEW_LINE DEDENT DEDENT ans = bad NEW_LINE j = count NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ i ] > k ) : NEW_LINE INDENT bad = bad - 1 NEW_LINE DEDENT if ( arr [ j ] > k ) : NEW_LINE INDENT bad = bad + 1 NEW_LINE DEDENT ans = min ( ans , bad ) NEW_LINE j = j + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def decToOctal ( n ) : NEW_LINE INDENT octalNum = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octalNum [ i ] = n % 8 NEW_LINE n = int ( n / 8 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( octalNum [ j ] , end = " " ) NEW_LINE DEDENT DEDENT
def sumOfDigitsFrom1ToN ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT d = ( int ) ( math . log10 ( n ) ) NEW_LINE a = [ 0 ] * ( d + 1 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 45 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = ( int ) ( math . ceil ( math . pow ( 10 , d ) ) ) NEW_LINE msd = n // p NEW_LINE return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) NEW_LINE DEDENT
def vol_tetra ( side ) : NEW_LINE INDENT volume = ( side ** 3 / ( 6 * math . sqrt ( 2 ) ) ) NEW_LINE return round ( volume , 2 ) NEW_LINE DEDENT
def myCopy ( s1 , s2 , index ) : NEW_LINE INDENT s2 [ index ] = s1 [ index ] NEW_LINE if ( index == len ( s1 ) - 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT myCopy ( s1 , s2 , index + 1 ) NEW_LINE DEDENT
def findFlips ( str , n ) : NEW_LINE INDENT last = ' ▁ ' NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( last != str [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT last = str [ i ] NEW_LINE DEDENT return res // 2 NEW_LINE DEDENT
def interLeaveQueue ( q ) : NEW_LINE INDENT if ( q . qsize ( ) % 2 != 0 ) : NEW_LINE INDENT print ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) NEW_LINE DEDENT s = [ ] NEW_LINE halfSize = int ( q . qsize ( ) / 2 ) NEW_LINE for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT
def oddEvenSort ( arr , n ) : NEW_LINE INDENT isSorted = 0 NEW_LINE while isSorted == 0 : NEW_LINE INDENT isSorted = 1 NEW_LINE temp = 0 NEW_LINE for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE isSorted = 0 NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE isSorted = 0 NEW_LINE DEDENT DEDENT DEDENT return NEW_LINE DEDENT
def shortestSeq ( S : list , T : list ) : NEW_LINE INDENT m = len ( S ) NEW_LINE n = len ( T ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ch = S [ i - 1 ] NEW_LINE k = j - 1 NEW_LINE while k >= 0 : NEW_LINE INDENT if T [ k ] == ch : NEW_LINE INDENT break NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT if k == - 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT ans = dp [ m ] [ n ] NEW_LINE if ans >= MAX : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLongestConseqSubseq ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE ans = 0 NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) not in s : NEW_LINE INDENT j = arr [ i ] NEW_LINE while ( j in s ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printPowerSet ( set , set_size ) : NEW_LINE INDENT pow_set_size = ( int ) ( math . pow ( 2 , set_size ) ) NEW_LINE counter = 0 NEW_LINE j = 0 NEW_LINE for counter in range ( 0 , pow_set_size ) : NEW_LINE INDENT for j in range ( 0 , set_size ) : NEW_LINE INDENT if ( ( counter & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT print ( set [ j ] , end = " " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT x1 = a [ 0 ] NEW_LINE x2 = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x1 = x1 ^ a [ i ] NEW_LINE DEDENT for i in range ( 2 , n + 2 ) : NEW_LINE INDENT x2 = x2 ^ i NEW_LINE DEDENT return x1 ^ x2 NEW_LINE DEDENT
def printRotatedString ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE temp = string + string NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( temp [ i + j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT