static int sumDigits ( int no ) { return no == 0 ? 0 : no % 10 + sumDigits ( no / 10 ) ; }
static int findSum ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) ans += ( i / j ) ; return ans ; }
static boolean ispalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s . charAt ( i ) != s . charAt ( j ) ) { return false ; } } return true ; }
static int getMinStepToReachEnd ( int arr [ ] , int N ) { boolean [ ] visit = new boolean [ N ] ; int [ ] distance = new int [ N ] ; Vector < Integer > [ ] digit = new Vector [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) digit [ i ] = new Vector < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) visit [ i ] = false ; for ( int i = 1 ; i < N ; i ++ ) digit [ arr [ i ] ] . add ( i ) ; distance [ 0 ] = 0 ; visit [ 0 ] = true ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 0 ) ; while ( ! q . isEmpty ( ) ) { int idx = q . peek ( ) ; q . remove ( ) ; if ( idx == N - 1 ) break ; int d = arr [ idx ] ; for ( int i = 0 ; i < digit [ d ] . size ( ) ; i ++ ) { int nextidx = digit [ d ] . get ( i ) ; if ( ! visit [ nextidx ] ) { visit [ nextidx ] = true ; q . add ( nextidx ) ; distance [ nextidx ] = distance [ idx ] + 1 ; } } digit [ d ] . clear ( ) ; if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) { visit [ idx - 1 ] = true ; q . add ( idx - 1 ) ; distance [ idx - 1 ] = distance [ idx ] + 1 ; } if ( idx + 1 < N && ! visit [ idx + 1 ] ) { visit [ idx + 1 ] = true ; q . add ( idx + 1 ) ; distance [ idx + 1 ] = distance [ idx ] + 1 ; } } return distance [ N - 1 ] ; }
public static long findWays ( int f , int d , int s ) { long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
static int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
static int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . ceil ( eq_root ) + l ) ; }
static int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
static void concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) { int i ; for ( i = 0 ; i < n1 ; i ++ ) { c [ i ] = a [ i ] ; } for ( int j = 0 ; j < n2 ; j ++ ) { c [ i ++ ] = b [ j ] ; } }
static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
static void printMaxSubSquare ( int M [ ] [ ] ) { int i , j ; int R = M . length ; int C = M [ 0 ] . length ; int S [ ] [ ] = new int [ R ] [ C ] ; int max_of_s , max_i , max_j ; for ( i = 0 ; i < R ; i ++ ) S [ i ] [ 0 ] = M [ i ] [ 0 ] ; for ( j = 0 ; j < C ; j ++ ) S [ 0 ] [ j ] = M [ 0 ] [ j ] ; for ( i = 1 ; i < R ; i ++ ) { for ( j = 1 ; j < C ; j ++ ) { if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = Math . min ( S [ i ] [ j - 1 ] , Math . min ( S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) ) + 1 ; else S [ i ] [ j ] = 0 ; } } max_of_s = S [ 0 ] [ 0 ] ; max_i = 0 ; max_j = 0 ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( max_of_s < S [ i ] [ j ] ) { max_of_s = S [ i ] [ j ] ; max_i = i ; max_j = j ; } } } System . out . println ( " Maximum ▁ size ▁ sub - matrix ▁ is : ▁ " ) ; for ( i = max_i ; i > max_i - max_of_s ; i -- ) { for ( j = max_j ; j > max_j - max_of_s ; j -- ) { System . out . print ( M [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
public static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; }
static boolean isComposite ( int n ) { if ( n <= 1 ) System . out . println ( " False " ) ; if ( n <= 3 ) System . out . println ( " False " ) ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } System . out . println ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + max_guests + " ▁ at ▁ time ▁ " + time ) ; }
static int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + " ▁ " ) ; else System . out . print ( 0 + " ▁ " ) ; } System . out . println ( ) ; } return 0 ; }
static int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
static void reorder ( ) { int temp [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
static int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; }
static int FirstRepeated ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
static int findMaxProduct ( int arr [ ] , int n ) { int i ; int ans = Integer . MIN_VALUE ; int maxval = 1 ; int minval = 1 ; int prevMax ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; minval = Math . min ( 1 , minval * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { minval = 1 ; maxval = 0 ; } else if ( arr [ i ] < 0 ) { prevMax = maxval ; maxval = minval * arr [ i ] ; minval = prevMax * arr [ i ] ; } ans = Math . max ( ans , maxval ) ; if ( maxval <= 0 ) { maxval = 1 ; } } return ans ; }
static void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) System . out . println ( " No " ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( " Yes ▁ " + days ) ; } }
static void firstNonRepeating ( String str ) { int [ ] charCount = new int [ MAX_CHAR ] ; Queue < Character > q = new LinkedList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; q . add ( ch ) ; charCount [ ch - ' a ' ] ++ ; while ( ! q . isEmpty ( ) ) { if ( charCount [ q . peek ( ) - ' a ' ] > 1 ) q . remove ( ) ; else { System . out . print ( q . peek ( ) + " ▁ " ) ; break ; } } if ( q . isEmpty ( ) ) System . out . print ( - 1 + " ▁ " ) ; } System . out . println ( ) ; }
public static void dfs ( LinkedList < Integer > list [ ] , int node , int arrival ) { System . out . println ( node ) ; for ( int i = 0 ; i < list [ node ] . size ( ) ; i ++ ) { if ( list [ node ] . get ( i ) != arrival ) dfs ( list , list [ node ] . get ( i ) , node ) ; } }
static int findRepeating ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) res = res ^ ( i + 1 ) ^ arr [ i ] ; res = res ^ arr [ n - 1 ] ; return res ; }
static int getCount ( char keypad [ ] [ ] , int n ) { if ( keypad == null || n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int [ ] odd = new int [ 10 ] ; int [ ] even = new int [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }
static int countSubarrWithEqualZeroAndOne ( int [ ] arr , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; sum += arr [ i ] ; if ( sum == 0 ) count ++ ; if ( myMap . containsKey ( sum ) ) count += myMap . get ( sum ) ; if ( ! myMap . containsKey ( sum ) ) myMap . put ( sum , 1 ) ; else myMap . put ( sum , myMap . get ( sum ) + 1 ) ; } return count ; }
public static void search ( int [ ] [ ] mat , int fromRow , int toRow , int fromCol , int toCol , int key ) { int i = fromRow + ( toRow - fromRow ) / 2 ; int j = fromCol + ( toCol - fromCol ) / 2 ; if ( mat [ i ] [ j ] == key ) System . out . println ( " Found ▁ " + key + " ▁ at ▁ " + i + " ▁ " + j ) ; else { if ( i != toRow || j != fromCol ) search ( mat , fromRow , i , j , toCol , key ) ; if ( fromRow == toRow && fromCol + 1 == toCol ) if ( mat [ fromRow ] [ toCol ] == key ) System . out . println ( " Found ▁ " + key + " ▁ at ▁ " + fromRow + " ▁ " + toCol ) ; if ( mat [ i ] [ j ] < key ) { if ( i + 1 <= toRow ) search ( mat , i + 1 , toRow , fromCol , toCol , key ) ; } else { if ( j - 1 >= fromCol ) search ( mat , fromRow , toRow , fromCol , j - 1 , key ) ; } } }
public static int kthgroupsum ( int k ) { return k * k * k ; }
static boolean areKAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] hash_str1 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 . charAt ( i ) - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 . charAt ( i ) - ' a ' ] > 0 ) hash_str1 [ str2 . charAt ( i ) - ' a ' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }
static void bonacciseries ( int n , int m ) { int [ ] a = new int [ m ] ; a [ n - 1 ] = 1 ; for ( int i = n ; i < m ; i ++ ) for ( int j = i - n ; j < i ; j ++ ) a [ i ] += a [ j ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
static void printMinIndexChar ( String str , String patt ) { int minIndex = Integer . MAX_VALUE ; int m = str . length ( ) ; int n = patt . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt . charAt ( i ) == str . charAt ( j ) && j < minIndex ) { minIndex = j ; break ; } } } if ( minIndex != Integer . MAX_VALUE ) System . out . println ( " Minimum ▁ Index ▁ Character ▁ = ▁ " + str . charAt ( minIndex ) ) ; else System . out . println ( " No ▁ character ▁ present " ) ; }
static boolean negCyclefloydWarshall ( int graph [ ] [ ] ) { int dist [ ] [ ] = new int [ V ] [ V ] , i , j , k ; for ( i = 0 ; i < V ; i ++ ) for ( j = 0 ; j < V ; j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ] ; for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } for ( i = 0 ; i < V ; i ++ ) if ( dist [ i ] [ i ] < 0 ) return true ; return false ; }
static String lexNext ( String str , int n ) { char [ ] s = str . toCharArray ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return String . valueOf ( s ) ; } s [ i ] = ' a ' ; } return null ; }
static void printDuo ( String str ) { int countChar [ ] = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { countChar [ str . charAt ( i ) - ' a ' ] ++ ; } String str1 = " " , str2 = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( countChar [ i ] > 1 ) { str2 = str2 + ( char ) ( i + ' a ' ) ; } else if ( countChar [ i ] == 1 ) { str1 = str1 + ( char ) ( i + ' a ' ) ; } } System . out . print ( " String ▁ with ▁ characters ▁ occurring ▁ " + " once : \n " ) ; System . out . print ( str1 + " \n " ) ; System . out . print ( " String ▁ with ▁ characters ▁ occurring ▁ " + " multiple ▁ times : \n " ) ; System . out . print ( str2 + " \n " ) ; System . out . print ( " " ) ; }
static void Round_off ( double N , double n ) { int h ; double l , a , b , c , d , e , i , j , m , f , g ; b = N ; c = floor ( N ) ; for ( i = 0 ; b >= 1 ; ++ i ) b = b / 10 ; d = n - i ; b = N ; b = b * pow ( 10 , d ) ; e = b + 0.5 ; if ( ( float ) e == ( float ) ceil ( b ) ) { f = ( ceil ( b ) ) ; h = ( int ) ( f - 2 ) ; if ( h % 2 != 0 ) { e = e - 1 ; } } j = floor ( e ) ; m = pow ( 10 , d ) ; j = j / m ; System . out . println ( " The ▁ number ▁ after ▁ rounding - off ▁ is ▁ " + j ) ; }
static void printRotatedString ( String str ) { int len = str . length ( ) ; StringBuffer sb ; for ( int i = 0 ; i < len ; i ++ ) { sb = new StringBuffer ( ) ; int j = i ; int k = 0 ; for ( int k2 = j ; k2 < str . length ( ) ; k2 ++ ) { sb . insert ( k , str . charAt ( j ) ) ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { sb . insert ( k , str . charAt ( j ) ) ; j ++ ; k ++ ; } System . out . println ( sb ) ; } }
public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }
static int calculate ( String N ) { int len = N . length ( ) ; int l = ( len ) / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { String s = N . substring ( 0 , i ) ; int l1 = s . length ( ) ; String t = N . substring ( i , l1 + i ) ; if ( s . charAt ( 0 ) == '0' || t . charAt ( 0 ) == '0' ) continue ; if ( s . compareTo ( t ) == 0 ) count ++ ; } return count ; }
static int printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) System . out . print ( arr1 [ i ++ ] + " ▁ " ) ; else if ( arr2 [ j ] < arr1 [ i ] ) System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; else { System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; i ++ ; } } while ( i < m ) System . out . print ( arr1 [ i ++ ] + " ▁ " ) ; while ( j < n ) System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; return 0 ; }
static void printDistinct ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; int [ ] index = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 && x != ' ▁ ' ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_CHAR && index [ i ] != n ; i ++ ) System . out . print ( str . charAt ( index [ i ] ) ) ; }
static int findCommon ( int mat [ ] [ ] ) { int column [ ] = new int [ M ] ; int min_row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; } int eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return - 1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return - 1 ; }
static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
static int maxProfit ( int [ ] price , int n , int k ) { int [ ] [ ] profit = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int max_so_far = 0 ; for ( int m = 0 ; m < j ; m ++ ) max_so_far = Math . max ( max_so_far , price [ j ] - price [ m ] + profit [ i - 1 ] [ m ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , max_so_far ) ; } } return profit [ k ] [ n - 1 ] ; }
static boolean match ( String first , String second ) { if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) > 1 && first . charAt ( 0 ) == ' * ' && second . length ( ) == 0 ) return false ; if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == ' ? ' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ; if ( first . length ( ) > 0 && first . charAt ( 0 ) == ' * ' ) return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ; return false ; }
static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
static boolean isPermutedMatrix ( int mat [ ] [ ] , int n ) { String str_cat = " " ; for ( int i = 0 ; i < n ; i ++ ) { str_cat = str_cat + " - " + String . valueOf ( mat [ 0 ] [ i ] ) ; } str_cat = str_cat + str_cat ; for ( int i = 1 ; i < n ; i ++ ) { String curr_str = " " ; for ( int j = 0 ; j < n ; j ++ ) { curr_str = curr_str + " - " + String . valueOf ( mat [ i ] [ j ] ) ; } if ( str_cat . contentEquals ( curr_str ) ) { return false ; } } return true ; }
static boolean isSparse ( int array [ ] [ ] , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ; return ( counter > ( ( m * n ) / 2 ) ) ; }
static double findArea ( int r ) { return PI * Math . pow ( r , 2 ) ; }
static int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
static void counterClockspiralPrint ( int m , int n , int arr [ ] [ ] ) { int i , k = 0 , l = 0 ; int cnt = 0 ; int total = m * n ; while ( k < m && l < n ) { if ( cnt == total ) break ; for ( i = k ; i < m ; ++ i ) { System . out . print ( arr [ i ] [ l ] + " ▁ " ) ; cnt ++ ; } l ++ ; if ( cnt == total ) break ; for ( i = l ; i < n ; ++ i ) { System . out . print ( arr [ m - 1 ] [ i ] + " ▁ " ) ; cnt ++ ; } m -- ; if ( cnt == total ) break ; if ( k < m ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( arr [ i ] [ n - 1 ] + " ▁ " ) ; cnt ++ ; } n -- ; } if ( cnt == total ) break ; if ( l < n ) { for ( i = n - 1 ; i >= l ; -- i ) { System . out . print ( arr [ k ] [ i ] + " ▁ " ) ; cnt ++ ; } k ++ ; } } }
public static double numberOfTriangles ( int n ) { double ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }
public static int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }
static void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; System . out . println ( ( float ) time ) ; }
static int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) result ++ ; return result ; }
static int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
static int compute_average ( int a , int b ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }
int countSubStr ( char str [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) res ++ ; } } } return res ; }
static boolean isDivisibleBy10 ( String bin ) { int n = bin . length ( ) ; if ( bin . charAt ( n - 1 ) == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin . charAt ( i ) == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; }
public static void search ( int [ ] arr , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . println ( " The ▁ required ▁ element ▁ is ▁ " + arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else if ( mid % 2 == 1 ) { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; quickSort ( A , 0 , arr_size - 1 ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { System . out . print ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ l ] + " , ▁ " + A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; }
static void makePermutation ( int [ ] a , int n ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) ) { count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ; } else { count . put ( a [ i ] , 1 ) ; } } int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 || a [ i ] > n || a [ i ] < 1 ) { count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ; while ( count . containsKey ( next_missing ) ) next_missing ++ ; a [ i ] = next_missing ; count . put ( next_missing , 1 ) ; } } }
static int optimalStrategyOfGame ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
static long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
static int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
static void interchangeFirstLast ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
public static void maxOverlap ( int [ ] start , int [ ] end , int n ) { int maxa = Arrays . stream ( start ) . max ( ) . getAsInt ( ) ; int maxb = Arrays . stream ( end ) . max ( ) . getAsInt ( ) ; int maxc = Math . max ( maxa , maxb ) ; int [ ] x = new int [ maxc + 2 ] ; Arrays . fill ( x , 0 ) ; int cur = 0 , idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } int maxy = Integer . MIN_VALUE ; for ( int i = 0 ; i <= maxc ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) { maxy = cur ; idx = i ; } } System . out . println ( " Maximum ▁ value ▁ is : " + maxy + " ▁ at ▁ position : ▁ " + idx + " " ) ; }
static boolean canFormPalindrome ( String str ) { List < Character > list = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( list . contains ( str . charAt ( i ) ) ) list . remove ( ( Character ) str . charAt ( i ) ) ; else list . add ( str . charAt ( i ) ) ; } if ( str . length ( ) % 2 == 0 && list . isEmpty ( ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) return true ; else return false ; }
static int fib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; return fib ( n - 1 , b , a + b ) ; }
static int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } return count ; }
static void kmax ( int arr [ ] , int k , int n ) { for ( int c = 0 ; c < k ; c ++ ) { int max_so_far = Integer . MIN_VALUE ; int max_here = 0 ; int start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_here += arr [ i ] ; if ( max_so_far < max_here ) { max_so_far = max_here ; start = s ; end = i ; } if ( max_here < 0 ) { max_here = 0 ; s = i + 1 ; } } System . out . println ( " Maximum ▁ non - overlapping ▁ sub - arraysum " + ( c + 1 ) + " : ▁ " + max_so_far + " , ▁ starting ▁ index : ▁ " + start + " , ▁ ending ▁ index : ▁ " + end + " . " ) ; for ( int l = start ; l <= end ; l ++ ) arr [ l ] = Integer . MIN_VALUE ; } System . out . println ( ) ; }
static int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ; Arrays . sort ( X , Collections . reverseOrder ( ) ) ; Arrays . sort ( Y , Collections . reverseOrder ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
static int ksmallest ( int arr [ ] , int n , int k ) { int b [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return Integer . MAX_VALUE ; }
static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] C = new int [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; } } for ( i = 0 ; i < n ; i ++ ) { if ( P [ 0 ] [ i ] == true ) C [ i ] = 0 ; else { C [ i ] = Integer . MAX_VALUE ; for ( j = 0 ; j < i ; j ++ ) { if ( P [ j + 1 ] [ i ] == true && 1 + C [ j ] < C [ i ] ) C [ i ] = 1 + C [ j ] ; } } } return C [ n - 1 ] ; }
boolean isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
static void printLevels ( Vector < Vector < Integer > > graph , int V , int x ) { int level [ ] = new int [ V ] ; boolean marked [ ] = new boolean [ V ] ; Queue < Integer > que = new LinkedList < Integer > ( ) ; que . add ( x ) ; level [ x ] = 0 ; marked [ x ] = true ; while ( que . size ( ) > 0 ) { x = que . peek ( ) ; que . remove ( ) ; for ( int i = 0 ; i < graph . get ( x ) . size ( ) ; i ++ ) { int b = graph . get ( x ) . get ( i ) ; if ( ! marked [ b ] ) { que . add ( b ) ; level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } } System . out . println ( " Nodes " + " ▁ " + " Level " ) ; for ( int i = 0 ; i < V ; i ++ ) System . out . println ( " ▁ " + i + " ▁ - - > ▁ " + level [ i ] ) ; }
static int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
public static int dealnnoy ( int n , int m ) { if ( m == 0 || n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
static Boolean subArrayExists ( int arr [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 || sum == 0 || hM . get ( sum ) != null ) return true ; hM . put ( sum , i ) ; } return false ; }
static void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 || last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } }
static void longestString ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] , count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; } String result = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += ( char ) ( ' a ' + i ) ; } } System . out . println ( result ) ; }
static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
static String decodeMedianString ( String s ) { int l = s . length ( ) ; String s1 = " " ; boolean isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s . charAt ( i ) + s1 ; s1 += s . charAt ( i + 1 ) ; } else { if ( l - i > 1 ) { s1 += s . charAt ( i ) ; s1 = s . charAt ( i + 1 ) + s1 ; } else { s1 += s . charAt ( i ) ; } } } return s1 ; }
static int MaximumPath ( int Mat [ ] [ ] ) { int result = 0 ; int dp [ ] [ ] = new int [ N ] [ N + 2 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
static int minSwap ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = Math . min ( ans , bad ) ; } return ans ; }
static void decToOctal ( int n ) { int [ ] octalNum = new int [ 100 ] ; int i = 0 ; while ( n != 0 ) { octalNum [ i ] = n % 8 ; n = n / 8 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( octalNum [ j ] ) ; }
static int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
static double vol_tetra ( int side ) { double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }
static void myCopy ( char s1 [ ] , char s2 [ ] , int index ) { s2 [ index ] = s1 [ index ] ; if ( index == s1 . length - 1 ) { return ; } myCopy ( s1 , s2 , index + 1 ) ; }
static int findFlips ( String str , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return res / 2 ; }
static void interLeaveQueue ( Queue < Integer > q ) { if ( q . size ( ) % 2 != 0 ) System . out . println ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) ; Stack < Integer > s = new Stack < > ( ) ; int halfSize = q . size ( ) / 2 ; for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { q . add ( q . peek ( ) ) ; q . poll ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; q . add ( q . peek ( ) ) ; q . poll ( ) ; } }
public static void oddEvenSort ( int arr [ ] , int n ) { boolean isSorted = false ; while ( ! isSorted ) { isSorted = true ; int temp = 0 ; for ( int i = 1 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; isSorted = false ; } } for ( int i = 0 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; isSorted = false ; } } } return ; }
static int shortestSeq ( char [ ] S , char [ ] T ) { int m = S . length , n = T . length ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = MAX ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = S [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) { if ( T [ k ] == ch ) { break ; } } if ( k == - 1 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } } int ans = dp [ m ] [ n ] ; if ( ans >= MAX ) { ans = - 1 ; } return ans ; }
static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) S . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! S . contains ( arr [ i ] - 1 ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; if ( ans < j - arr [ i ] ) ans = j - arr [ i ] ; } } return ans ; }
static void printPowerSet ( char [ ] set , int set_size ) { long pow_set_size = ( long ) Math . pow ( 2 , set_size ) ; int counter , j ; for ( counter = 0 ; counter < pow_set_size ; counter ++ ) { for ( j = 0 ; j < set_size ; j ++ ) { if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( set [ j ] ) ; } System . out . println ( ) ; } }
static int getMissingNo ( int a [ ] , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) x1 = x1 ^ a [ i ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) x2 = x2 ^ i ; return ( x1 ^ x2 ) ; }
static void printRotatedString ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) System . out . print ( sb . charAt ( i + j ) ) ; System . out . println ( ) ; } }
static int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }