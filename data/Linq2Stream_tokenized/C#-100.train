public List < Tuple < string , double >> CustomerInRegionOrdersTotalAverage ( string region ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalAverage = customers . Where ( c => c . Region . Equals ( region ) ) . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Average ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalAverage ; }
public List < Tuple < string , int , int >> CustomerSelectManyCustomerOrderDateYearAndMonth ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int , int >> customerProperties = customers . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate . Year , o . OrderDate . Month ) ) . ToList ( ) ; return customerProperties ; }
public List < Tuple < string , Product >> ProductLeftOuterJoinCategories ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , Product >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . SelectMany ( t => t . Item2. DefaultIfEmpty ( null ) , ( t , p ) => Tuple . Create ( t . Item1 , p ) ) . ToList ( ) ; return q ; }
public List < Tuple < bool , List < double >>> DoubleGroupByBoolOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Tuple < bool , List < double >>> numbersGroups = numbers . GroupBy ( n => n > 5 ) . Select ( g => Tuple . Create ( g . Key , g . OrderBy ( n => n - ( int ) n ) . ToList ( ) ) ) . ToList ( ) ; return numbersGroups ; }
public List < Tuple < string , List < Customer >>> CustomerEachCountryOrdersMinCustomer ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , List < Customer >>> customerOrdersMin = customers . GroupBy ( c => c . Country ) . Select ( g => Tuple . Create ( g . Key , g . Where ( c => c . Orders . Count == g . Min ( c => c . Orders . Count ) ) . ToList ( ) ) ) . ToList ( ) ; return customerOrdersMin ; }
public Dictionary < string , List < Product >> ProductEachGroupTakeWhile ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> firstEachGroupsWhile = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . TakeWhile ( p => p . ProductId > 100 ) . ToList ( ) ) ; return firstEachGroupsWhile ; }
public Dictionary < bool , List < double >> DoubleGroupByBoolDictOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Dictionary < bool , List < double >> numbersGroups = numbers . GroupBy ( n => n > 5 ) . ToDictionary ( g => g . Key , g => g . OrderBy ( w => w ) . ToList ( ) ) ; return numbersGroups ; }
public List < double > BigDoubleOrderbyFractionDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 3 ) . OrderByDescending ( n => n - ( int ) n ) . ThenBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public double [ ] DoublesConvertToDescendingArray ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = doubles . OrderByDescending ( d => d ) . ToArray ( ) ; return doublesArray ; }
public double [ ] ConvertSelectedDoubleItemToArrayAndPrint ( ) { object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; double [ ] doubles = numbers . OfType < double > ( ) . ToArray ( ) ; for ( int i = 0 ; i < doubles . Length ; i ++ ) Console . WriteLine ( doubles [ i ] ) ; return doubles ; }
public Dictionary < string , int > CustomerDistinctOrdersCountDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > orderCounts = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Distinct ( ) . Count ( ) ) ; return orderCounts ; }
public List < Customer > RepeatedCustomers ( ) { List < Customer > customers = Enumerable . Repeat ( Customer . Default , 5 ) . ToList ( ) ; return customers ; }
public int [ ] BigIntAddIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = numbers . Where ( n => n > 5 ) . Select ( ( n , i ) => n + i ) . ToArray ( ) ; return numSelected ; }
public List < Product > ExpensiveProductSkipWhile ( ) { List < Product > products = GetProductList ( ) ; List < Product > afterProductsWhile = products . Where ( p => p . UnitPrice > 100 ) . SkipWhile ( p => p . ProductId > 100 ) . ToList ( ) ; return afterProductsWhile ; }
public int NumbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = numbers . Sum ( n => n * 2 ) ; return numbersSum ; }
public int IntDotProduct ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int dotProduct = numbersA . Zip ( numbersB , ( a , b ) => a * b ) . Sum ( ) ; return dotProduct ; }
public bool CustomerOrdersNestedAnyMatch ( ) { List < Customer > customers = GetCustomerList ( ) ; bool anyMatch = customers . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . Any ( t => t . Item2 > new DateTime ( 2000 , 1 , 1 ) ) ; return anyMatch ; }
public List < string > IndexedSelectManyString ( ) { List < Customer > customers = GetCustomerList ( ) ; List < string > customerOrders = customers . SelectMany ( ( c , i ) => c . Orders . Select ( o => " Customer ▁ # " + ( i + 1 ) + " ▁ has ▁ an ▁ order ▁ with ▁ OrderID ▁ " + o . OrderId ) ) . ToList ( ) ; return customerOrders ; }
public double [ ] DoubleUnion ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] uniqueNumbers = numbersA . Union ( numbersB ) . ToArray ( ) ; return uniqueNumbers ; }
public Dictionary < Tuple < string , int > , List < Customer >> CustomerGroupJoinRegionsWithCodeRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; Dictionary < Tuple < string , int > , List < Customer >> q = regions . GroupJoin ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r , c . ToList ( ) ) ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; return q ; }
public List < int > IntTake ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > first3Numbers = numbers . Take ( 3 ) . ToList ( ) ; return first3Numbers ; }
public List < Tuple < string , Order >> CustomerIdAndFirstOrDefaultOrder ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Order >> customerProperties = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . FirstOrDefault ( Order . Default ) ) ) . ToList ( ) ; return customerProperties ; }
public int [ ] IntUnion ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; int [ ] uniqueNumbers = numbersA . Union ( numbersB ) . ToArray ( ) ; return uniqueNumbers ; }
public List < Tuple < string , List < Product >>> ProductEachCategoryMaxUnitPriceProducts ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < Product >>> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Where ( p => p . UnitPrice == g . Max ( p => p . UnitPrice ) ) . ToList ( ) ) ) . ToList ( ) ; return categories ; }
public List < int > ShortStringLengthOrderby ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < int > sortedWords = words . Where ( w => w . Length < 6 ) . Select ( w => w . Length ) . OrderBy ( w => w ) . ToList ( ) ; return sortedWords ; }
public List < string > StringTakeCount ( int n ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > firstNWords = words . Take ( n ) . ToList ( ) ; return firstNWords ; }
public bool OddIntAnyMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool anyMatch = numbers . Where ( i => i % 2 == 1 ) . Any ( n => n > 3 ) ; return anyMatch ; }
public bool UnequalInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 6 , 10 } ; bool equal = numbersA . SequenceEqual ( numbersB ) ; return equal ; }
public List < string > StringOrderbyCustomThenbyLengthCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < string > sortedWords = words . OrderBy ( w => w , new CaseInsensitiveComparer ( ) ) . ThenBy ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public List < string > StringOrderbyDescendingLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . OrderByDescending ( w => w . Length ) . ToList ( ) ; return sortedWords ; }
public Dictionary < char , List < string >> StringGroupByFirstCharDictOrderby ( ) { string [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Dictionary < char , List < string >> wordsGroups = words . GroupBy ( w => w [ 0 ] ) . ToDictionary ( g => g . Key , g => g . OrderBy ( w => w ) . ToList ( ) ) ; return wordsGroups ; }
public List < Tuple < string , List < Product >>> ExpensiveProductEachCategoryMaxUnitPriceProducts ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < Product >>> categories = products . Where ( p => p . UnitPrice > 100 ) . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Where ( p => p . UnitPrice == g . Max ( p => p . UnitPrice ) ) . ToList ( ) ) ) . ToList ( ) ; return categories ; }
public List < double > BigDoubleOrderbyModDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 3 ) . OrderByDescending ( n => n % 1.5 ) . ThenByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public List < int > RepeatedIntsWithValue ( int value ) { List < int > numbers = Enumerable . Range ( value , 10 ) . ToList ( ) ; return numbers ; }
public List < Tuple < bool , List < double >>> DoubleGroupByBoolOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Tuple < bool , List < double >>> numbersGroups = numbers . GroupBy ( n => n > 5 ) . Select ( g => Tuple . Create ( g . Key , g . OrderByDescending ( w => w ) . ToList ( ) ) ) . ToList ( ) ; return numbersGroups ; }
public List < string > StringOrderbyDescending ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . OrderByDescending ( w => w ) . ToList ( ) ; return sortedWords ; }
public List < Product > ProductSkipWhile ( ) { List < Product > products = GetProductList ( ) ; List < Product > afterProductsWhile = products . SkipWhile ( p => p . ProductId > 100 ) . ToList ( ) ; return afterProductsWhile ; }
public List < Tuple < string , DateTime >> WaCustomerOrdersEachNestedSkipWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> afterOrdersEachWhile = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders . SkipWhile ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return afterOrdersEachWhile ; }
public Dictionary < string , Dictionary < string , Dictionary < string , Customer >>> CustomerNestedGroupByRegionAndCountryAndName ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , Dictionary < string , Dictionary < string , Customer >>> customerGroups = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . ToDictionary ( c => c . CompanyName , c => c ) ) ) ; return customerGroups ; }
public List < string > IntersectOfName ( ) { List < Product > products = GetProductList ( ) ; List < Customer > customers = GetCustomerList ( ) ; var productNames = products . Select ( p => p . ProductName ) ; var customerNames = customers . Select ( c => c . CompanyName ) ; List < string > sharedNames = productNames . Intersect ( customerNames ) . ToList ( ) ; return sharedNames ; }
public void ShortStringLengthEager ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; int i = 0 ; var q = words . Where ( w => w . Length < 7 ) . Select ( w => w . Length ) . Select ( n => i += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public bool ProductAllMatch ( ) { List < Product > products = GetProductList ( ) ; bool allMatch = products . All ( p => p . UnitsInStock > 0 ) ; return allMatch ; }
public double NumbersAggregateFindMax ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double aggregateSum = numbers . Aggregate ( ( a , b ) => Math . Max ( a , b ) ) ; return aggregateSum ; }
public int BigNumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = numbers . Where ( n => n > 5 ) . Sum ( ) ; return numbersSum ; }
public Dictionary < bool , List < string >> StringGroupByLengthDictOrderbyLengthCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Dictionary < bool , List < string >> wordsGroups = words . GroupBy ( w => w . Length > 8 ) . ToDictionary ( g => g . Key , g => g . OrderBy ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ) ; return wordsGroups ; }
public double BigDoubleNumbersMax ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double maxNum = numbers . Where ( d => d > 5 ) . Max ( ) ; return maxNum ; }
public Dictionary < bool , int > CountExpensiveProductByInStockDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , int > inStockCounts = products . GroupBy ( p => p . UnitsInStock == 0 ) . ToDictionary ( g => g . Key , g => g . Count ( p => p . UnitPrice > 100 ) ) ; return inStockCounts ; }
public List < int > RepeatedInts ( ) { List < int > numbers = Enumerable . Repeat ( 0 , 50 ) . ToList ( ) ; return numbers ; }
public Dictionary < string , Dictionary < string , Dictionary < string , Customer >>> CustomerNestedGroupByRegionAndCountryAndNamePrint ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , Dictionary < string , Dictionary < string , Customer >>> customerGroups = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . ToDictionary ( c => c . CompanyName , c => c ) ) ) ; foreach ( var e1 in customerGroups ) { Console . WriteLine ( e1. Key + " : " ) ; foreach ( var e2 in e1. Value ) { Console . WriteLine ( " \ t " + e2. Key + " : " ) ; foreach ( var e3 in e2. Value ) Console . WriteLine ( " \ t \ t " + e3. Key + " : " + e3. Value ) ; } } return customerGroups ; }
public List < Tuple < string , DateTime >> WaCustomerOrdersNestedSkipWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> afterOrdersWhile = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . SkipWhile ( t => t . Item2 > new DateTime ( 2000 , 1 , 1 ) ) . ToList ( ) ; return afterOrdersWhile ; }
public double BigDoubleNumbersElementAt ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numAt = numbers . Where ( d => d > 5 ) . ElementAt ( 1 ) ; return numAt ; }
public Dictionary < string , int > ProductEachCategoryStockDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , int > categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Min ( p => p . UnitsInStock ) ) ; return categories ; }
public void BigDoubleNumbersEager ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double d = 0 ; var q = numbers . Where ( d => d > 5 ) . Select ( n => d += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + d ) ; }
public Dictionary < string , List < Product >> ProductGroupByCategoryDictOrderbyDescendingName ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> productsGroups = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . OrderByDescending ( p => p . ProductName ) . ToList ( ) ) ; return productsGroups ; }
public Dictionary < string , double > CustomerExpensiveOrdersTotalMaxDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalMax = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Where ( o => o . Total > 100 ) . Max ( o => o . Total ) ) ; return ordersTotalMax ; }
public List < string > ShortStringReverse ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < string > sortedWords = words . Where ( w => w . Length < 6 ) . Reverse ( ) . ToList ( ) ; return sortedWords ; }
public int CustomerInRegionCount ( string region ) { List < Customer > customers = GetCustomerList ( ) ; int count = customers . Count ( c => c . Region . Equals ( region ) ) ; return count ; }
public List < char > UnionOfNameFirstChar ( ) { List < Product > products = GetProductList ( ) ; List < Customer > customers = GetCustomerList ( ) ; var productFirstChars = products . Select ( p => p . ProductName [ 0 ] ) ; var customerFirstChars = customers . Select ( c => c . CompanyName [ 0 ] ) ; List < char > uniqueFirstChars = productFirstChars . Union ( customerFirstChars ) . ToList ( ) ; return uniqueFirstChars ; }
public List < Tuple < string , Product >> ProductCrossGroupJoinCategories ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , Product >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . SelectMany ( t => t . Item2 , ( t , p ) => Tuple . Create ( t . Item1 , p ) ) . ToList ( ) ; return q ; }
public List < Tuple < string , DateTime >> WaCustomerOrdersNestedTakeWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> firstOrdersWhile = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . TakeWhile ( t => t . Item2 > new DateTime ( 2000 , 1 , 1 ) ) . ToList ( ) ; return firstOrdersWhile ; }
public List < string > StringSkipWhile ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > afterWordsWhile = words . SkipWhile ( w => w [ 0 ] > ' b ' ) . ToList ( ) ; return afterWordsWhile ; }
public Dictionary < string , int > CustomerEachCountryOrdersMinDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > ordersMin = customers . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . Min ( c => c . Orders . Count ) ) ; return ordersMin ; }
public double StringAverageLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; double averageLength = words . Average ( w => w . Length ) ; return averageLength ; }
public List < Tuple < string , int >> ProductEachCategoryStock ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , int >> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Max ( p => p . UnitsInStock ) ) ) . ToList ( ) ; return categories ; }
public Dictionary < int , List < Customer >> CustomerGroupJoinRegionsWithCode ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; Dictionary < int , List < Customer >> q = regions . GroupJoin ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r . Item2 , c . ToList ( ) ) ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; return q ; }
public List < Tuple < bool , List < int >>> ProductGroupByInStockWithId ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < bool , List < int >>> productGroup = products . GroupBy ( p => p . UnitsInStock == 0 ) . Select ( g => Tuple . Create ( g . Key , g . Select ( p => p . ProductId ) . ToList ( ) ) ) . ToList ( ) ; return productGroup ; }
public int ProductLongNameLengthSum ( ) { List < Product > products = GetProductList ( ) ; int totalSum = products . Select ( p => p . ProductName ) . Where ( name => name . Length > 7 ) . Sum ( name => name . Length ) ; return totalSum ; }
public void BigNumbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int i = 0 ; var q = numbers . Where ( n => n > 5 ) . Select ( n => i += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public List < Tuple < char , List < string >>> StringGroupByFirstCharOrderbyDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Tuple < char , List < string >>> wordsGroups = words . GroupBy ( w => char . ToLower ( w [ 0 ] ) ) . Select ( g => Tuple . Create ( g . Key , g . OrderByDescending ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ) ) . ToList ( ) ; return wordsGroups ; }
public List < string > StringOrderbyLengthThenbyDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < string > sortedWords = words . OrderBy ( w => w . Length ) . ThenByDescending ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public List < string > OutOfStockProductName ( ) { List < Product > products = GetProductList ( ) ; List < string > productNames = products . Where ( p => p . UnitsInStock == 0 ) . Select ( p => p . ProductName ) . ToList ( ) ; return productNames ; }
public int StringSumLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; int totalChars = words . Sum ( w => w . Length ) ; return totalChars ; }
public bool ExpensiveProductAnyMatch ( ) { List < Product > products = GetProductList ( ) ; bool anyMatch = products . Where ( p => p . UnitPrice > 100 ) . Any ( p => p . UnitsInStock > 0 ) ; return anyMatch ; }
public List < string > LongStringOrginalIndexedWhere ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > q = words . Where ( ( w , i ) => w . Length < i * 3 && w . Length > 5 ) . ToList ( ) ; return q ; }
public Dictionary < string , List < string >> CustomerGroupJoinRegionsPhone ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < string >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c . Select ( c1 => c1. Phone ) . ToList ( ) ) ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; return q ; }
public List < Tuple < string , double >> CustomerExpensiveOrdersTotalSum ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalSum = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Where ( o => o . Total > 100 ) . Sum ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalSum ; }
public int NumbersMax ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = numbers . Max ( ) ; return maxNum ; }
public int [ ] IntAddIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = numbers . Select ( ( n , i ) => n + i ) . ToArray ( ) ; return numSelected ; }
public bool StringAnyMatchCount ( string [ ] strings , char c ) { bool anyMatch = strings . Any ( w => w [ 0 ] > c ) ; return anyMatch ; }
public List < Tuple < string , double >> CustomerEachRegionOrdersTotalMin ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalMin = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . SelectMany ( c => c . Orders ) . Min ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalMin ; }
public double NumbersDoubledAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = numbers . Select ( n => n * 2 ) . Aggregate ( ( a , b ) => a * b ) ; return product ; }
public string [ ] TransformIndexHashToString ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string [ ] textNums = numbers . Select ( n => strings [ n * 97 % 10 ] ) . ToArray ( ) ; return textNums ; }
public Dictionary < string , List < Product >> ExpensiveProductEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> categories = products . Where ( p => p . UnitPrice > 100 ) . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice == g . Min ( p => p . UnitPrice ) ) . ToList ( ) ) ; return categories ; }
public List < Tuple < bool , int >> CountExpensiveProductByInStock ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < bool , int >> inStockCounts = products . GroupBy ( p => p . UnitsInStock == 0 ) . Select ( g => Tuple . Create ( g . Key , g . Count ( p => p . UnitPrice > 100 ) ) ) . ToList ( ) ; return inStockCounts ; }
public int DistinctOrdersCount ( string region ) { List < Customer > customers = GetCustomerList ( ) ; int count = customers . SelectMany ( c => c . Orders ) . Distinct ( ) . Count ( ) ; return count ; }
public bool CustomerOrdersAnyMatch ( ) { List < Customer > customers = GetCustomerList ( ) ; bool anyMatch = customers . SelectMany ( c => c . Orders ) . Any ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) ; return anyMatch ; }
public List < int > IntSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > afterNumbersWhile = numbers . SkipWhile ( i => i > 3 ) . ToList ( ) ; return afterNumbersWhile ; }
public List < Tuple < string , string >> CustomerCrossGroupJoinRegionsName ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , string >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. Select ( c => c . CompanyName ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public List < string > StringOrderbyReverse ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . OrderBy ( w => w ) . Reverse ( ) . ToList ( ) ; return sortedWords ; }
public List < Tuple < string , string >> CustomerRegionAndCountry ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , string >> customerProperties = customers . Select ( c => Tuple . Create ( c . Region , c . Country ) ) . ToList ( ) ; return customerProperties ; }
public bool CategoryProductAllMatch ( ) { List < Product > products = GetProductList ( ) ; bool allMatch = products . Where ( p => p . Category == " Beverages " ) . All ( p => p . UnitsInStock > 0 ) ; return allMatch ; }
public List < int > StringLengthSkip ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < int > after3Words = words . Select ( w => w . Length ) . Skip ( 3 ) . ToList ( ) ; return after3Words ; }
public List < Tuple < bool , List < string >>> StringGroupByLengthOrderbyDescendingLengthCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Tuple < bool , List < string >>> wordsGroups = words . GroupBy ( w => w . Length > 8 ) . Select ( g => Tuple . Create ( g . Key , g . OrderByDescending ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ) ) . ToList ( ) ; return wordsGroups ; }
public double NumbersAverage ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = numbers . Average ( ) ; return averageNum ; }
public List < Order > CustomerOrdersSkipWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Order > afterOrdersWhile = customers . SelectMany ( c => c . Orders ) . SkipWhile ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) . ToList ( ) ; return afterOrdersWhile ; }
public List < Tuple < string , List < Customer >>> CustomerEachRegionOrdersMinCustomer ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , List < Customer >>> customerOrdersMin = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . Where ( c => c . Orders . Count == g . Min ( c => c . Orders . Count ) ) . ToList ( ) ) ) . ToList ( ) ; return customerOrdersMin ; }
public List < Tuple < string , List < Product >>> ProductEachCategoryMinUnitPriceProducts ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < Product >>> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Where ( p => p . UnitPrice == g . Min ( p => p . UnitPrice ) ) . ToList ( ) ) ) . ToList ( ) ; return categories ; }
public double ExpensiveProductStockAverage ( ) { List < Product > products = GetProductList ( ) ; double averageUnitPrice = products . Where ( p => p . UnitPrice > 100 ) . Average ( p => p . UnitsInStock ) ; return averageUnitPrice ; }
public double OddNumbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = numbers . Where ( n => n % 2 == 1 ) . Average ( n => n * 2 ) ; return averageNum ; }
public List < string > ProductNameOrderbyDescending ( ) { List < Product > products = GetProductList ( ) ; List < string > sortedProducts = products . Select ( p => p . ProductName ) . OrderByDescending ( n => n ) . ToList ( ) ; return sortedProducts ; }
