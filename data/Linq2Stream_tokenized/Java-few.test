public List < Pair < String , Double >> customerExpensiveOrdersTotalMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public int projectedStringElementAt ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . skip ( 2 ) . findFirst ( ) . getAsInt ( ) ; return firstStringLength ; }
public List < Pair < String , Integer >> customerEachCountryOrdersMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMin ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . skip ( 3 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public int oddNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . findFirst ( ) . orElse ( - 2 ) ; return firstNum ; }
public List < Pair < String , Integer >> customerExpensiveOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Integer > intWithSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] < i * i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public int [ ] projectionIntConcat ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] allNumbers = IntStream . concat ( first , second ) . toArray ( ) ; return allNumbers ; }
public List < Integer > rangeOfEvenIntsStartFrom ( int start , int count ) { List < Integer > numbers = IntStream . range ( start , start + count ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Pair < String , String >> productLeftOuterJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getProductName ( ) : " No ▁ Product " ) ) ) . toList ( ) ; return q ; }
public List < Triplet < String , Integer , Double >> customerSelectManyCustomerNewOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , List < Product >> productEachCategoryMaxUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public Product productFirstOrDefault ( ) { List < Product > products = getProductList ( ) ; Product product12 = products . stream ( ) . filter ( p -> p . getProductId ( ) == 12 ) . findFirst ( ) . orElse ( Product . DEFAULT ) ; return product12 ; }
public int oddFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int factorsCount = ( int ) Arrays . stream ( factorsOf300 ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return factorsCount ; }
public List < Double > doubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public double doubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . findFirst ( ) . orElse ( 3.14 ) ; return firstNum ; }
public List < Integer > rangeOfEvenIntsStartFrom ( ) { List < Integer > numbers = IntStream . range ( 100 , 200 ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public Map < String , List < Product >> productEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public Map < String , Double > customerOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public List < Pair < String , List < Order >>> customerIdAndOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Order >>> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Double > bigDoubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Pair < String , Order >> customerSelectManyCustomerOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , Map < String , Customer >> customerNestedGroupByRegionAndName ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , Customer >> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c ) ) ) ) ; return customerGroups ; }
public List < Order > customerOrdersTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . takeWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public Map < Double , Double > convertArrayToDictionaryWithDistinctAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 1.7 , 2.9 } ; Map < Double , Double > doublesDict = Arrays . stream ( doubles ) . distinct ( ) . boxed ( ) . collect ( toMap ( sr -> sr , sr -> sr * 2 ) ) ; for ( var pair : doublesDict . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return doublesDict ; }
public double [ ] projectionDoubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] sharedNumbers = first . distinct ( ) . filter ( a -> second . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedNumbers ; }
public List < Pair < String , String >> customerCrossGroupJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getPhone ( ) ) ) ) . toList ( ) ; return q ; }
public List < Double > bigDoubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public List < Integer > intTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> numbers [ i ] > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Integer > intSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> numbers [ i ] > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public double bigNumbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public Map < String , Double > customerExpensiveOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public Map < String , List < Product >> productEachGroupTake ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . limit ( 3 ) . toList ( ) ) ) ; return after3EachGroups ; }
public double bigDoubleNumbersFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . filter ( d -> d > 5 ) . findFirst ( ) . getAsDouble ( ) ; return firstNum ; }
public double productUnitPriceMin ( ) { List < Product > products = getProductList ( ) ; double minUnitPrice = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . min ( ) . getAsDouble ( ) ; return minUnitPrice ; }
public List < Pair < String , String >> customerLeftOuterJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getCompanyName ( ) : " No ▁ Customer " ) ) ) . toList ( ) ; return q ; }
public int projectedBigNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . map ( i -> ( int ) Math . pow ( 2 , i ) ) . filter ( n -> n > 100 ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public Map < Integer , Map < Integer , List < Order >>> customerNestedGroupByOrderYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; Map < Integer , Map < Integer , List < Order >>> customerOrderGroups = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ; return customerOrderGroups ; }
public List < Pair < String , List < Product >>> productEachCategoryFirstOrDefaultUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Product . DEFAULT ) . getUnitPrice ( ) ) . toList ( ) ) ) . toList ( ) ; return categories ; }
public boolean stringAnyMatch ( char c ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . anyMatch ( w -> w . charAt ( 0 ) > c ) ; return anyMatch ; }
public Map < String , Double > customerEachRegionOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < Pair < Double , List < Double >>> doubleGroupByMod ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; List < Pair < Double , List < Double >>> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 1.5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public Map < String , Integer > customerEachRegionOrdersMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) ; return ordersMin ; }
public int bigNumbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . sum ( ) ; return numbersSum ; }
public List < Integer > intSquareSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . dropWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public Map < String , Boolean > productEachGroupAllMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > allMatch = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return allMatch ; }
public boolean longStringAnyMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . anyMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return anyMatch ; }
public List < Product > productOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public Boolean [ ] bigIntWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] bigNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . toArray ( ) ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , bigNumbers . length ) . mapToObj ( i -> bigNumbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public double productUnitPriceSum ( ) { List < Product > products = getProductList ( ) ; double totalSum = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . sum ( ) ; return totalSum ; }
public List < Pair < String , Customer >> customerLeftOuterJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Customer >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public Map < String , Integer > customerNewOrdersCountDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > orderCounts = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . count ( ) ) ) ; return orderCounts ; }
public List < String > stringOrderbyLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . toList ( ) ; return sortedWords ; }
public String [ ] selectByCaseConcat ( ) { String [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; String [ ] upperLowerWords = ( String [ ] ) Arrays . stream ( words ) . map ( w -> w . toUpperCase ( ) + w . toLowerCase ( ) ) . toArray ( ) ; return upperLowerWords ; }
public List < Product > productOrderbyDescendingId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public Map < String , List < Product >> productsConvertGroupingToDictionaryAndPrint ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> catagory = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) ; for ( var pair : catagory . entrySet ( ) ) { System . out . println ( pair . getKey ( ) + " : " ) ; for ( var product : pair . getValue ( ) ) System . out . println ( " \ t " + product ) ; } return catagory ; }
public List < Pair < String , Double >> customerOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public List < Pair < Integer , String >> customerCrossJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , String >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Pair . with ( r . getValue1 ( ) , c . getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public double bigNumbersAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> a * b ) ; return product ; }
public int projectedStringFirst ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . findFirst ( ) . getAsInt ( ) ; return firstStringLength ; }
public boolean productAnyMatch ( ) { List < Product > products = getProductList ( ) ; boolean anyMatch = products . stream ( ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return anyMatch ; }
public List < Triplet < String , Integer , Double >> customerSelectManyCustomerOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public int numbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . sum ( ) ; return numbersSum ; }
public Character [ ] shortStringFirstChar ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Character [ ] selected = ( Character [ ] ) Arrays . stream ( strings ) . filter ( w -> w . length ( ) < 4 ) . map ( w -> w . charAt ( 0 ) ) . toArray ( ) ; return selected ; }
public int [ ] oddFactorOf300And900Count ( ) { int [ ] [ ] factorsOf300And900 = { { 2 , 2 , 3 , 5 , 5 } , { 2 , 2 , 3 , 3 , 5 , 5 } } ; int [ ] factorsCount = Arrays . stream ( factorsOf300And900 ) . mapToInt ( a -> ( int ) Arrays . stream ( a ) . filter ( n -> n % 2 == 1 ) . count ( ) ) . toArray ( ) ; return factorsCount ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public int [ ] intPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . map ( n -> n + 1 ) . toArray ( ) ; return numSelected ; }
public List < Pair < String , Customer >> customerCrossGroupJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Customer >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1 ) ) ) . toList ( ) ; return q ; }
public boolean waCustomerOrdersNestedAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean anyMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . anyMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return anyMatch ; }
public Map < Pair < String , Integer > , List < String >> customerGroupJoinRegionsWithCodeNameRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Pair < String , Integer > , List < String >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> c . getCompanyName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Pair < String , LocalDate >> customerOrdersNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . takeWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public Pair < Integer , Integer > [ ] selectManyJoinSumEven ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . filter ( b -> ( a + b ) % 2 == 0 ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public int [ ] stringLength ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = Arrays . stream ( strings ) . mapToInt ( w -> w . length ( ) ) . toArray ( ) ; return selected ; }
public int shortStringMaxLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int maxLength = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . max ( ) . getAsInt ( ) ; return maxLength ; }
public Boolean [ ] intWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , numbers . length ) . mapToObj ( i -> numbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public List < Integer > rangeOfSquareInts ( ) { List < Integer > numbers = IntStream . range ( 0 , 50 ) . map ( n -> n * n ) . boxed ( ) . toList ( ) ; return numbers ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDictOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Map < Boolean , List < Double >> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ) ) ; return numbersGroups ; }
public List < String > shortStringOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public Map < String , Order > customerEachRegionFirstOrderDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Order > ordersFirst = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . findFirst ( ) . get ( ) ) ) ; return ordersFirst ; }
public List < Pair < Boolean , List < Integer >>> productGroupByPriceWithId ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Integer >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) . toList ( ) ; return productGroup ; }
public List < Pair < String , Integer >> customerDistinctOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public int oddNumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . sum ( ) ; return numbersSum ; }
public List < Integer > intTakeCount ( int [ ] numbers , int n ) { List < Integer > afterNNumbers = Arrays . stream ( numbers ) . limit ( n ) . boxed ( ) . toList ( ) ; return afterNNumbers ; }
public List < Order > waCustomerSelectManyNewOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < parallel . linq101. datasource . Order > customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Double > doubleFractionOrderbyReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public Map < String , Double > customerExpensiveOrdersTotalMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public Map < Boolean , List < Integer >> productGroupByInStockWithIdDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Integer >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public List < Pair < String , Double >> productCrossJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Double >> q = Arrays . stream ( categories ) . flatMap ( c -> products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p -> Pair . with ( c , p . getUnitPrice ( ) ) ) ) . toList ( ) ; return q ; }
public Map < String , Double > customerOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < String > stringTakeCount ( String [ ] strings , int n ) { List < String > afterNWords = Arrays . stream ( strings ) . limit ( 3 ) . toList ( ) ; return afterNWords ; }
public void numbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public double [ ] doublesConvertToDescendingArrayAndPrintForeach ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . mapToDouble ( d -> d ) . toArray ( ) ; for ( double d : doublesArray ) System . out . println ( d ) ; return doublesArray ; }
public double expensiveProductUnitPriceSum ( ) { List < Product > products = getProductList ( ) ; double totalSum = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . sum ( ) ; return totalSum ; }
public List < Double > bigDoubleOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public Map < String , Integer > convertTuplesToDictionaryAndPrint ( ) { List < Pair < String , Integer >> scoreRecords = Arrays . asList ( Pair . with ( " Alice " , 50 ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) ) ; Map < String , Integer > scoreRecordsDict = scoreRecords . stream ( ) . collect ( toMap ( sr -> sr . getValue0 ( ) , sr -> sr . getValue1 ( ) ) ) ; for ( var pair : scoreRecordsDict . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return scoreRecordsDict ; }
public List < Product > repeatedProductsWithCount ( int count ) { List < Product > products = Collections . nCopies ( count , Product . DEFAULT ) ; return products ; }
public List < String > stringSkipWhileCount ( String [ ] strings , char c ) { List < String > afterNWords = Arrays . stream ( strings ) . dropWhile ( w -> w . charAt ( 0 ) > c ) . toList ( ) ; return afterNWords ; }
public List < Integer > intTakeWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public double inputNumbersAggregate ( double [ ] numbers ) { double product = Arrays . stream ( numbers ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
