public List < Pair < String , Double >> customerExpensiveOrdersTotalMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public int projectedStringElementAt ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . skip ( 2 ) . findFirst ( ) . getAsInt ( ) ; return firstStringLength ; }
public List < Pair < String , Integer >> customerEachCountryOrdersMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMin ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . skip ( 3 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public int oddNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . findFirst ( ) . orElse ( - 2 ) ; return firstNum ; }
public List < Pair < String , Integer >> customerExpensiveOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Integer > intWithSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] < i * i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public int [ ] projectionIntConcat ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] allNumbers = IntStream . concat ( first , second ) . toArray ( ) ; return allNumbers ; }
public List < Integer > rangeOfEvenIntsStartFrom ( int start , int count ) { List < Integer > numbers = IntStream . range ( start , start + count ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Pair < String , String >> productLeftOuterJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getProductName ( ) : " No ▁ Product " ) ) ) . toList ( ) ; return q ; }
public List < Triplet < String , Integer , Double >> customerSelectManyCustomerNewOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , List < Product >> productEachCategoryMaxUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public Product productFirstOrDefault ( ) { List < Product > products = getProductList ( ) ; Product product12 = products . stream ( ) . filter ( p -> p . getProductId ( ) == 12 ) . findFirst ( ) . orElse ( Product . DEFAULT ) ; return product12 ; }
public int oddFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int factorsCount = ( int ) Arrays . stream ( factorsOf300 ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return factorsCount ; }
public List < Double > doubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public double doubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . findFirst ( ) . orElse ( 3.14 ) ; return firstNum ; }
public List < Integer > rangeOfEvenIntsStartFrom ( ) { List < Integer > numbers = IntStream . range ( 100 , 200 ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public Map < String , List < Product >> productEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public Map < String , Double > customerOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public List < Pair < String , List < Order >>> customerIdAndOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Order >>> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Double > bigDoubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Pair < String , Order >> customerSelectManyCustomerOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , Map < String , Customer >> customerNestedGroupByRegionAndName ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , Customer >> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c ) ) ) ) ; return customerGroups ; }
public List < Order > customerOrdersTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . takeWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public Map < Double , Double > convertArrayToDictionaryWithDistinctAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 1.7 , 2.9 } ; Map < Double , Double > doublesDict = Arrays . stream ( doubles ) . distinct ( ) . boxed ( ) . collect ( toMap ( sr -> sr , sr -> sr * 2 ) ) ; for ( var pair : doublesDict . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return doublesDict ; }
public double [ ] projectionDoubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] sharedNumbers = first . distinct ( ) . filter ( a -> second . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedNumbers ; }
public List < Pair < String , String >> customerCrossGroupJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getPhone ( ) ) ) ) . toList ( ) ; return q ; }
public List < Double > bigDoubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public List < Integer > intTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> numbers [ i ] > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Integer > intSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> numbers [ i ] > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public double bigNumbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public Map < String , Double > customerExpensiveOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public Map < String , List < Product >> productEachGroupTake ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . limit ( 3 ) . toList ( ) ) ) ; return after3EachGroups ; }
public double bigDoubleNumbersFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . filter ( d -> d > 5 ) . findFirst ( ) . getAsDouble ( ) ; return firstNum ; }
public double productUnitPriceMin ( ) { List < Product > products = getProductList ( ) ; double minUnitPrice = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . min ( ) . getAsDouble ( ) ; return minUnitPrice ; }
public List < Pair < String , String >> customerLeftOuterJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getCompanyName ( ) : " No ▁ Customer " ) ) ) . toList ( ) ; return q ; }
public int projectedBigNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . map ( i -> ( int ) Math . pow ( 2 , i ) ) . filter ( n -> n > 100 ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public Map < Integer , Map < Integer , List < Order >>> customerNestedGroupByOrderYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; Map < Integer , Map < Integer , List < Order >>> customerOrderGroups = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ; return customerOrderGroups ; }
public List < Pair < String , List < Product >>> productEachCategoryFirstOrDefaultUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Product . DEFAULT ) . getUnitPrice ( ) ) . toList ( ) ) ) . toList ( ) ; return categories ; }
public boolean stringAnyMatch ( char c ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . anyMatch ( w -> w . charAt ( 0 ) > c ) ; return anyMatch ; }
public Map < String , Double > customerEachRegionOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < Pair < Double , List < Double >>> doubleGroupByMod ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; List < Pair < Double , List < Double >>> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 1.5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public Map < String , Integer > customerEachRegionOrdersMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) ; return ordersMin ; }
public int bigNumbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . sum ( ) ; return numbersSum ; }
public List < Integer > intSquareSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . dropWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public Map < String , Boolean > productEachGroupAllMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > allMatch = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return allMatch ; }
public boolean longStringAnyMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . anyMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return anyMatch ; }
public List < Product > productOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public Boolean [ ] bigIntWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] bigNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . toArray ( ) ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , bigNumbers . length ) . mapToObj ( i -> bigNumbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public double productUnitPriceSum ( ) { List < Product > products = getProductList ( ) ; double totalSum = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . sum ( ) ; return totalSum ; }
public List < Pair < String , Customer >> customerLeftOuterJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Customer >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public Map < String , Integer > customerNewOrdersCountDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > orderCounts = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . count ( ) ) ) ; return orderCounts ; }
public List < String > stringOrderbyLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . toList ( ) ; return sortedWords ; }
public String [ ] selectByCaseConcat ( ) { String [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; String [ ] upperLowerWords = ( String [ ] ) Arrays . stream ( words ) . map ( w -> w . toUpperCase ( ) + w . toLowerCase ( ) ) . toArray ( ) ; return upperLowerWords ; }
public List < Product > productOrderbyDescendingId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public Map < String , List < Product >> productsConvertGroupingToDictionaryAndPrint ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> catagory = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) ; for ( var pair : catagory . entrySet ( ) ) { System . out . println ( pair . getKey ( ) + " : " ) ; for ( var product : pair . getValue ( ) ) System . out . println ( " \ t " + product ) ; } return catagory ; }
public List < Pair < String , Double >> customerOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public List < Pair < Integer , String >> customerCrossJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , String >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Pair . with ( r . getValue1 ( ) , c . getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public double bigNumbersAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> a * b ) ; return product ; }
public int projectedStringFirst ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . findFirst ( ) . getAsInt ( ) ; return firstStringLength ; }
public boolean productAnyMatch ( ) { List < Product > products = getProductList ( ) ; boolean anyMatch = products . stream ( ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return anyMatch ; }
public List < Triplet < String , Integer , Double >> customerSelectManyCustomerOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public int numbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . sum ( ) ; return numbersSum ; }
public Character [ ] shortStringFirstChar ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Character [ ] selected = ( Character [ ] ) Arrays . stream ( strings ) . filter ( w -> w . length ( ) < 4 ) . map ( w -> w . charAt ( 0 ) ) . toArray ( ) ; return selected ; }
public int [ ] oddFactorOf300And900Count ( ) { int [ ] [ ] factorsOf300And900 = { { 2 , 2 , 3 , 5 , 5 } , { 2 , 2 , 3 , 3 , 5 , 5 } } ; int [ ] factorsCount = Arrays . stream ( factorsOf300And900 ) . mapToInt ( a -> ( int ) Arrays . stream ( a ) . filter ( n -> n % 2 == 1 ) . count ( ) ) . toArray ( ) ; return factorsCount ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public int [ ] intPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . map ( n -> n + 1 ) . toArray ( ) ; return numSelected ; }
public List < Pair < String , Customer >> customerCrossGroupJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Customer >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1 ) ) ) . toList ( ) ; return q ; }
public boolean waCustomerOrdersNestedAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean anyMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . anyMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return anyMatch ; }
public Map < Pair < String , Integer > , List < String >> customerGroupJoinRegionsWithCodeNameRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Pair < String , Integer > , List < String >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> c . getCompanyName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Pair < String , LocalDate >> customerOrdersNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . takeWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public Pair < Integer , Integer > [ ] selectManyJoinSumEven ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . filter ( b -> ( a + b ) % 2 == 0 ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public int [ ] stringLength ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = Arrays . stream ( strings ) . mapToInt ( w -> w . length ( ) ) . toArray ( ) ; return selected ; }
public int shortStringMaxLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int maxLength = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . max ( ) . getAsInt ( ) ; return maxLength ; }
public Boolean [ ] intWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , numbers . length ) . mapToObj ( i -> numbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public List < Integer > rangeOfSquareInts ( ) { List < Integer > numbers = IntStream . range ( 0 , 50 ) . map ( n -> n * n ) . boxed ( ) . toList ( ) ; return numbers ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDictOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Map < Boolean , List < Double >> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ) ) ; return numbersGroups ; }
public List < String > shortStringOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public Map < String , Order > customerEachRegionFirstOrderDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Order > ordersFirst = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . findFirst ( ) . get ( ) ) ) ; return ordersFirst ; }
public List < Pair < Boolean , List < Integer >>> productGroupByPriceWithId ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Integer >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) . toList ( ) ; return productGroup ; }
public List < Pair < String , Integer >> customerDistinctOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public int oddNumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . sum ( ) ; return numbersSum ; }
public List < Integer > intTakeCount ( int [ ] numbers , int n ) { List < Integer > afterNNumbers = Arrays . stream ( numbers ) . limit ( n ) . boxed ( ) . toList ( ) ; return afterNNumbers ; }
public List < Order > waCustomerSelectManyNewOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < parallel . linq101. datasource . Order > customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Double > doubleFractionOrderbyReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public Map < String , Double > customerExpensiveOrdersTotalMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public Map < Boolean , List < Integer >> productGroupByInStockWithIdDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Integer >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public List < Pair < String , Double >> productCrossJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Double >> q = Arrays . stream ( categories ) . flatMap ( c -> products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p -> Pair . with ( c , p . getUnitPrice ( ) ) ) ) . toList ( ) ; return q ; }
public Map < String , Double > customerOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < String > stringTakeCount ( String [ ] strings , int n ) { List < String > afterNWords = Arrays . stream ( strings ) . limit ( 3 ) . toList ( ) ; return afterNWords ; }
public void numbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public double [ ] doublesConvertToDescendingArrayAndPrintForeach ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . mapToDouble ( d -> d ) . toArray ( ) ; for ( double d : doublesArray ) System . out . println ( d ) ; return doublesArray ; }
public double expensiveProductUnitPriceSum ( ) { List < Product > products = getProductList ( ) ; double totalSum = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . sum ( ) ; return totalSum ; }
public List < Double > bigDoubleOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public Map < String , Integer > convertTuplesToDictionaryAndPrint ( ) { List < Pair < String , Integer >> scoreRecords = Arrays . asList ( Pair . with ( " Alice " , 50 ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) ) ; Map < String , Integer > scoreRecordsDict = scoreRecords . stream ( ) . collect ( toMap ( sr -> sr . getValue0 ( ) , sr -> sr . getValue1 ( ) ) ) ; for ( var pair : scoreRecordsDict . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return scoreRecordsDict ; }
public List < Product > repeatedProductsWithCount ( int count ) { List < Product > products = Collections . nCopies ( count , Product . DEFAULT ) ; return products ; }
public List < String > stringSkipWhileCount ( String [ ] strings , char c ) { List < String > afterNWords = Arrays . stream ( strings ) . dropWhile ( w -> w . charAt ( 0 ) > c ) . toList ( ) ; return afterNWords ; }
public List < Integer > intTakeWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public double inputNumbersAggregate ( double [ ] numbers ) { double product = Arrays . stream ( numbers ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public List < String > stringTakeWhileCount ( String [ ] strings , char c ) { List < String > afterNWords = Arrays . stream ( strings ) . takeWhile ( w -> w . charAt ( 0 ) > c ) . toList ( ) ; return afterNWords ; }
public List < Integer > stringLengthTake ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < Integer > after3Words = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . limit ( 3 ) . toList ( ) ; return after3Words ; }
public void stringLengthEager ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . map ( n -> i . addAndGet ( n ) ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public int bigNumbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public List < Product > productIndexedWhere ( ) { List < Product > products = getProductList ( ) ; List < Product > q = IntStream . range ( 0 , products . size ( ) ) . filter ( i -> products . get ( i ) . getUnitsInStock ( ) > 0 && i % 2 == 1 ) . mapToObj ( i -> products . get ( i ) ) . toList ( ) ; return q ; }
public List < Pair < String , Product >> productCrossJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Product >> q = Arrays . stream ( categories ) . flatMap ( c -> products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p -> Pair . with ( c , p ) ) ) . toList ( ) ; return q ; }
public int [ ] shortStringLength ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = Arrays . stream ( strings ) . filter ( w -> w . length ( ) < 4 ) . mapToInt ( w -> w . length ( ) ) . toArray ( ) ; return selected ; }
public List < Product > inStockProductTakeWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public List < Pair < String , Integer >> convertSelectedTupleToListAndPrint ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; List < Pair < String , Integer >> strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . toList ( ) ; for ( var i = 0 ; i < strings . size ( ) ; i ++ ) System . out . println ( strings . get ( i ) . getValue0 ( ) + " : " + strings . get ( i ) . getValue1 ( ) ) ; return strings ; }
public int [ ] transformIndexHashToInt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] textNums = Arrays . stream ( numbers ) . map ( n -> numbers [ n * 97 % 10 ] ) . toArray ( ) ; return textNums ; }
public int expensiveOrdersCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ; return count ; }
public Map < String , Integer > convertTuplesToDictionary ( ) { List < Pair < String , Integer >> scoreRecords = Arrays . asList ( Pair . with ( " Alice " , 50 ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) ) ; Map < String , Integer > scoreRecordsDict = scoreRecords . stream ( ) . collect ( toMap ( sr -> sr . getValue0 ( ) , sr -> sr . getValue1 ( ) ) ) ; return scoreRecordsDict ; }
public double numbersDoubledAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = product = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . reduce ( seed , ( a , b ) -> a * b ) ; return product ; }
public Map < String , List < Double >> productGroupUnitPriceDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Double >> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ) ) ; return productNames ; }
public int [ ] intTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . toArray ( ) ; return numSelected ; }
public List < Pair < String , Double >> customerInRegionOrdersTotalMin ( String region ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMin = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMin ; }
public List < Double > outOfStockProductUnitPrice ( ) { List < Product > products = getProductList ( ) ; List < Double > productNames = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) == 0 ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ; return productNames ; }
public boolean equalInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; boolean equal = Arrays . equals ( numbersA , numbersB ) ; return equal ; }
public Product [ ] productsConvertToDescendingArrayAndPrintForeach ( ) { List < Product > products = getProductList ( ) ; Product [ ] productsArray = ( Product [ ] ) products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toArray ( ) ; for ( Product p : productsArray ) System . out . println ( p ) ; return productsArray ; }
public boolean intAnyMatchInput ( int i ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean anyMatch = Arrays . stream ( numbers ) . anyMatch ( n -> n > i ) ; return anyMatch ; }
public List < String > longStringIndexedWhere ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; String [ ] longWords = ( String [ ] ) Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . toArray ( ) ; List < String > q = IntStream . range ( 0 , longWords . length ) . filter ( i -> longWords [ i ] . length ( ) < i * 3 ) . mapToObj ( i -> longWords [ i ] ) . toList ( ) ; return q ; }
public List < String > stringOrderbyLengthCustomThenby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) , new CustomNumberComparer ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < String , Integer >> countRegionDistinctCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> regionCounts = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return regionCounts ; }
public int [ ] transformIndexToInt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] textNums = Arrays . stream ( numbers ) . map ( n -> numbers [ n ] ) . toArray ( ) ; return textNums ; }
public List < Double > doubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public double expensiveProductUnitPriceAggregateAverageWithSeed ( ) { List < Product > products = getProductList ( ) ; double seed = 15.5 ; double aggregateSum = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . filter ( d -> d > 100 ) . reduce ( seed , ( a , b ) -> ( a + b ) / 2 ) ; return aggregateSum ; }
public List < String > expensiveProductNameOrderbyDescending ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getProductName ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedProducts ; }
public Character [ ] projectionStringExcept ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = Arrays . stream ( wordsA ) . map ( n -> n . charAt ( 0 ) ) ; var second = Arrays . stream ( wordsB ) . map ( n -> n . charAt ( 0 ) ) ; Character [ ] differemtWords = ( Character [ ] ) first . distinct ( ) . filter ( a -> second . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtWords ; }
public Map < String , List < Product >> productEachGroupSkip ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . skip ( 3 ) . toList ( ) ) ) ; return after3EachGroups ; }
public List < Pair < String , Product >> productEachCategoryElementAt ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . skip ( 1 ) . findFirst ( ) . get ( ) ) ) . toList ( ) ; return categories ; }
public List < String > stringOrderbyThenbyLengthCustom ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public int distinctProductCategoryCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . map ( p -> p . getCategory ( ) ) . distinct ( ) . count ( ) ; return count ; }
public Map < String , List < Customer >> customerEachCountryOrdersMaxCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersMax ; }
public int bigNumbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public List < Pair < String , String >> customerIdAndName ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getCompanyName ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < Boolean , List < Product >>> productGroupByInStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Product >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return productGroup ; }
public double [ ] projectionDoubleConcat ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] allNumbers = DoubleStream . concat ( first , second ) . toArray ( ) ; return allNumbers ; }
public Product [ ] productsConvertToArray ( ) { List < Product > products = getProductList ( ) ; Product [ ] productsArray = ( Product [ ] ) products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) ) ) . toArray ( ) ; return productsArray ; }
public List < Double > doubleOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public double expensiveProductUnitPriceAverage ( ) { List < Product > products = getProductList ( ) ; double averageUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . average ( ) . getAsDouble ( ) ; return averageUnitPrice ; }
public List < Product > repeatedProducts ( ) { List < Product > products = Collections . nCopies ( 30 , Product . DEFAULT ) ; return products ; }
public int projectedStringFirstOrDefault ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . findFirst ( ) . orElse ( - 1 ) ; return firstStringLength ; }
public List < Pair < String , Integer >> convertSelectedTupleToList ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; List < Pair < String , Integer >> strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . toList ( ) ; return strings ; }
public List < Integer > intTakeWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . takeWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Triplet < String , Integer , String >> customerCrossJoinRegionsWithCodeNameRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , String >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Triplet . with ( r . getValue0 ( ) , r . getValue1 ( ) , c . getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public List < Product > productsConvertToList ( ) { List < Product > products = getProductList ( ) ; List < Product > productsList = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) ) ) . toList ( ) ; return productsList ; }
public List < Product > repeatedProductsWithBase ( Product product ) { List < Product > products = Collections . nCopies ( 10 , product ) ; return products ; }
public List < Pair < String , List < Product >>> productGroupByCategoryOrderbyId ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ) ) . toList ( ) ; return productsGroups ; }
public Map < String , Integer > customerEachRegionOrdersSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . sum ( ) ) ) ; return ordersSum ; }
public List < String > stringIndexedWhere ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; IntStream . range ( 0 , words . length ) . filter ( i -> words [ i ] . length ( ) < i ) . mapToObj ( i -> words [ i ] ) . toList ( ) ; List < String > q = IntStream . range ( 0 , words . length ) . filter ( i -> words [ i ] . length ( ) < i ) . mapToObj ( i -> words [ i ] ) . toList ( ) ; return q ; }
public boolean categoryProductAnyMatch ( ) { List < Product > products = getProductList ( ) ; boolean anyMatch = products . stream ( ) . filter ( p -> p . getCategory ( ) == " Beverages " ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return anyMatch ; }
public List < Pair < String , Product >> productEachCategoryFirst ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) ) ) . toList ( ) ; return categories ; }
public double doubleFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . findFirst ( ) . getAsDouble ( ) ; return firstNum ; }
public List < Integer > shortStringLengthOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < Integer > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . map ( w -> w . length ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < Double > bigDoubleFractionOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public Map < String , Integer > convertSelectedTupleToDictionaryAndPrint ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; Map < String , Integer > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . collect ( toMap ( p -> p . getValue0 ( ) , p -> p . getValue1 ( ) ) ) ; for ( var pair : strings . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " : " + pair . getValue ( ) ) ; return strings ; }
public double bigDoubleNumbersSum ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numbersSum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . sum ( ) ; return numbersSum ; }
public List < Integer > intIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] < i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public int [ ] oddIntPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n + 1 ) . toArray ( ) ; return numSelected ; }
public List < Pair < Boolean , List < String >>> stringGroupByLengthOrderbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public List < String > concatOfRegion ( ) { String [ ] regions = { " WA " , " AF " , " RO " } ; List < Customer > customers = getCustomerList ( ) ; var customerRegions = customers . stream ( ) . map ( c -> c . getRegion ( ) ) ; List < String > allRegions = Stream . concat ( customerRegions , Arrays . stream ( regions ) ) . toList ( ) ; return allRegions ; }
public List < Double > doubleOrderbyFractionThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Pair < String , Order >> waCustomerSelectManyCustomerNewOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o ) ) ) . toList ( ) ; return customerProperties ; }
public List < Order > customerSelectManyNewOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Double > bigDoubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public int [ ] intZipAdd ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int [ ] addNumbers = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] + numbersB [ i ] ) . toArray ( ) ; return addNumbers ; }
public List < Pair < Boolean , List < Integer >>> intGroupByBool ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Pair < Boolean , List < Integer >>> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 4 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public Map < String , Boolean > expensiveProductEachGroupAllMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > allMatch = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return allMatch ; }
public List < String > shortStringOrderbyDescendingLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . comparing ( w -> w . length ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Product > expensiveProductTakeWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public List < Pair < String , Double >> customerOrdersTotalAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalAverage = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalAverage ; }
public Map < String , Integer > countDistinctProductByCategoryDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categoryCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) ; return categoryCounts ; }
public List < String > stringOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public List < Pair < String , Double >> productCrossGroupJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Double >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1. getUnitPrice ( ) ) ) ) . toList ( ) ; return q ; }
public double numbersAggregateFindMin ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( ( a , b ) -> Math . min ( a , b ) ) . getAsDouble ( ) ; return aggregateSum ; }
public void oddNumbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyDescendingId ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public boolean unequalStrings ( ) { List < String > wordsA = Arrays . asList ( " Alpha " , " Beta " , " Gamma " ) ; List < String > wordsB = Arrays . asList ( " aLPhA " , " bETa " , " gAaMa " ) ; boolean equal = wordsA . equals ( wordsB ) ; return equal ; }
public List < Double > doubleOrderbyDescendingFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < String > intersectOfCategory ( ) { String [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = getProductList ( ) ; var productCategories = products . stream ( ) . map ( p -> p . getCategory ( ) ) ; List < String > sharedCategories = productCategories . distinct ( ) . filter ( a -> Arrays . stream ( categories ) . anyMatch ( b -> b . equals ( a ) ) ) . toList ( ) ; return sharedCategories ; }
public Map < String , List < String >> customerGroupJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; Map < String , List < String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> c . getCompanyName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Product > productSkip ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . skip ( 3 ) . toList ( ) ; return after3Products ; }
public boolean stringAnyMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . anyMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return anyMatch ; }
public List < Pair < String , List < Customer >>> customerGroupByRegion ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> catagory = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return catagory ; }
public void oddNumbersTwiceDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public int uniqueFactorsCount ( int [ ] factors ) { int factorsCount = ( int ) Arrays . stream ( factors ) . distinct ( ) . count ( ) ; return factorsCount ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . takeWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public String [ ] stringConcat ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; String [ ] allWords = ( String [ ] ) Stream . concat ( Arrays . stream ( wordsA ) , Arrays . stream ( wordsB ) ) . toArray ( ) ; return allWords ; }
public List < Double > doubleOrderbyFractionDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public Map < Boolean , List < Integer >> intGroupByBoolDictPrint ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Map < Boolean , List < Integer >> numberGroups = numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 4 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; numberGroups . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; numberGroups . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return numberGroups ; }
public List < Pair < String , LocalDate >> customerSelectManyCustomerOrderDates ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , String >> customerCrossJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> Pair . with ( r , c . getPhone ( ) ) ) ) . toList ( ) ; return q ; }
public double [ ] doubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] sharedNumbers = Arrays . stream ( numbersA ) . distinct ( ) . filter ( a -> Arrays . stream ( numbersB ) . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedNumbers ; }
public List < Character > concatOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > allFirstChars = Stream . concat ( productFirstChars , customerFirstChars ) . toList ( ) ; return allFirstChars ; }
public List < String > unionOfCategory ( ) { String [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = getProductList ( ) ; var productCategories = products . stream ( ) . map ( p -> p . getCategory ( ) ) ; List < String > uniqueCategories = Stream . concat ( productCategories , Arrays . stream ( categories ) ) . distinct ( ) . toList ( ) ; return uniqueCategories ; }
public double numbersAggregateSqrtWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> Math . sqrt ( a * b ) ) ; return aggregateSum ; }
public List < Product > productOrderbyCategoryThenbyDescendingName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > expensiveProductOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Pair < Pair < String , Integer > , String >> customerLeftOuterJoinRegionsWithCodeNameRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Pair < String , Integer > , String >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getCompanyName ( ) : " No ▁ Customer " ) ) ) . toList ( ) ; return q ; }
public List < Integer > intSquareSkip ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . skip ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public Pair < String , Boolean > [ ] selectByEvenOdd ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Pair < String , Boolean > [ ] evenOddWords = ( Pair < String , Boolean > [ ] ) Arrays . stream ( numbers ) . mapToObj ( n -> Pair . with ( strings [ n ] , n % 2 == 0 ) ) . toArray ( ) ; return evenOddWords ; }
public List < Pair < String , Double >> customerEachCountryOrdersAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersAverage ; }
public List < Double > doubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public List < Pair < Pair < String , Integer > , Customer >> customerLeftOuterJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Pair < String , Integer > , Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public int [ ] bigIntTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n * 2 ) . toArray ( ) ; return numSelected ; }
public List < Pair < String , Double >> expensiveProductEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Double >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return categories ; }
public List < Triplet < String , Integer , Customer >> customerCrossJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Customer >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Triplet . with ( r . getValue0 ( ) , r . getValue1 ( ) , c ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , List < Customer >>> customerEachCountryOrdersFirstCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersFirst = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) . getOrders ( ) . size ( ) ) . toList ( ) ) ) . toList ( ) ; return customerOrdersFirst ; }
public double projectedDoubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . map ( i -> Math . log ( i ) ) . filter ( n -> n > 3 ) . findFirst ( ) . orElse ( 3.01 ) ; return firstNum ; }
public Map < String , List < String >> productGroupNameDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < String >> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductName ( ) ) . toList ( ) ) ) ; return productNames ; }
public List < String > stringSkipCount ( String [ ] strings , int n ) { List < String > afterNWords = Arrays . stream ( strings ) . skip ( 3 ) . toList ( ) ; return afterNWords ; }
public Map < Boolean , List < Product >> productGroupByInStockDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public Map < String , Double > customerOrdersTotalMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public List < Pair < String , List < Product >>> expensiveProductEachCategoryMinUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , Integer > customerEachCountryOrdersSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . sum ( ) ) ) ; return ordersSum ; }
public int bigNumbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyDescending ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public double productUnitPriceAggregateAverageWithSeed ( ) { List < Product > products = getProductList ( ) ; double seed = 15.5 ; double aggregateSum = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . reduce ( seed , ( a , b ) -> ( a + b ) / 2 ) ; return aggregateSum ; }
public Character [ ] projectionStringConcat ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = Arrays . stream ( wordsA ) . map ( n -> n . charAt ( 0 ) ) ; var second = Arrays . stream ( wordsB ) . map ( n -> n . charAt ( 0 ) ) ; Character [ ] allWords = ( Character [ ] ) Stream . concat ( first , second ) . toArray ( ) ; return allWords ; }
public List < Pair < String , LocalDate >> customerSelectManyCustomerNewOrderDates ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public double [ ] doubleConcat ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] allNumbers = DoubleStream . concat ( Arrays . stream ( numbersA ) , Arrays . stream ( numbersB ) ) . toArray ( ) ; return allNumbers ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderbyDescending ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public List < String > longStringSkip ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . skip ( 3 ) . toList ( ) ; return after3Words ; }
public List < Integer > intTakeWhileIndexedCount ( int [ ] numbers , int n ) { List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public String stringFirstOrDefaultStartWith ( char c ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithChar = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == c ) . findFirst ( ) . orElse ( " none " ) ; return startWithChar ; }
public Map < Boolean , List < Integer >> productGroupByPriceWithIdDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Integer >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public List < String > shortStringOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public Boolean [ ] bigIntWithOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] > 5 ) . filter ( i -> numbers [ i ] % 2 == 1 ) . mapToObj ( i -> numbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public int numbersFirstOrDefaultOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . findFirst ( ) . orElse ( - 1 ) ; return firstNum ; }
public int shortStringMinLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int minLength = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . min ( ) . getAsInt ( ) ; return minLength ; }
public List < Double > intSqrtTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Double > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> Math . sqrt ( numbers [ i ] ) > i ) . mapToDouble ( i -> Math . sqrt ( numbers [ i ] ) ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < String > longStringSkipWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . dropWhile ( w -> w . charAt ( 0 ) > ' b ' ) . toList ( ) ; return after3Words ; }
public Map < String , List < String >> productGroupJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; Map < String , List < String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p1 -> p1. getProductName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public boolean intSquareAllMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean allMatch = Arrays . stream ( numbers ) . map ( i -> i * i ) . allMatch ( n -> n > 3 ) ; return allMatch ; }
public Product [ ] productsConvertToDescendingArrayAndPrint ( ) { List < Product > products = getProductList ( ) ; Product [ ] productsArray = ( Product [ ] ) products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toArray ( ) ; for ( int i = 0 ; i < productsArray . length ; i ++ ) System . out . println ( productsArray [ i ] ) ; return productsArray ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . dropWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public List < Boolean > waCustomerOrdersEachNestedAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; List < Boolean > allMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . map ( c -> c . getOrders ( ) . stream ( ) . allMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ) . toList ( ) ; return allMatch ; }
public Map < String , List < Order >> customerEachRegionOrdersTotalMaxCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Order >> customerOrdersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersTotalMax ; }
public double doubleSum ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numbersSum = Arrays . stream ( numbers ) . sum ( ) ; return numbersSum ; }
public String [ ] stringProjectionZipAdd ( ) { String [ ] wordsA = { " Alpha " , " Beta " , " Gamma " } ; String [ ] wordsB = { " red " , " green " , " blue " } ; int length = wordsA . length ; String [ ] results = ( String [ ] ) IntStream . range ( 0 , length ) . mapToObj ( i -> String . valueOf ( wordsA [ i ] . charAt ( 0 ) ) + wordsB [ i ] . charAt ( 0 ) ) . toArray ( ) ; return results ; }
public Map < String , List < Product >> productGroupSkipWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . dropWhile ( g -> g . getKey ( ) . length ( ) > 6 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public List < Pair < String , List < String >>> productGroupName ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < String >>> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductName ( ) ) . toList ( ) ) ) . toList ( ) ; return productNames ; }
public List < Pair < Integer , String >> customerCrossGroupJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , String >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public Map < String , List < Product >> productsConvertGroupingToDictionary ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> catagory = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) ; return catagory ; }
public List < Product > repeatedProductsWithBaseAndCount ( Product product , int count ) { List < Product > products = Collections . nCopies ( count , product ) ; return products ; }
public List < Integer > intsConvertToList ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < Integer > intsList = Arrays . stream ( ints ) . boxed ( ) . sorted ( ) . toList ( ) ; return intsList ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public List < Pair < String , Customer >> customerCrossJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Customer >> q = Arrays . stream ( regions ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> Pair . with ( r , c ) ) ) . toList ( ) ; return q ; }
public double bigNumbersAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public String stringElementAtStartWithO ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithO = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == ' o ' ) . skip ( 0 ) . findFirst ( ) . get ( ) ; return startWithO ; }
public int aggregateWithdrawMoney ( ) { int [ ] attemptedWithdrawals = { 100 , 20 , 10 , 40 , 50 , 10 , 70 , 30 } ; int endBalance = Arrays . stream ( attemptedWithdrawals ) . reduce ( ( balance , nextWithdrawal ) -> nextWithdrawal <= balance ? balance - nextWithdrawal : balance ) . getAsInt ( ) ; return 0 ; }
public int [ ] intZipSub ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int [ ] subNumbers = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] - numbersB [ i ] ) . toArray ( ) ; return subNumbers ; }
public List < Integer > intSkipWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < String > longStringTakeWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . takeWhile ( w -> w . charAt ( 0 ) > ' b ' ) . toList ( ) ; return after3Words ; }
public String stringElementAtStartWith ( char c ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithO = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == c ) . skip ( 2 ) . findFirst ( ) . get ( ) ; return startWithO ; }
public Map < String , List < Customer >> customerEachRegionOrdersMaxCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersMax ; }
public boolean stringLengthAnyMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . anyMatch ( n -> n > 5 ) ; return anyMatch ; }
public List < String > stringOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public String stringFirstOrDefaultLong ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startsWithO = Arrays . stream ( strings ) . filter ( s -> s . length ( ) > 4 ) . findFirst ( ) . orElse ( " empty " ) ; return startsWithO ; }
public boolean projectionEqualInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 6 , 10 } ; boolean equal = Arrays . equals ( Arrays . stream ( numbersA ) . map ( n -> n + 1 ) . toArray ( ) , numbersB ) ; return equal ; }
public Map < Boolean , List < String >> stringGroupByLengthDict ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) ; return wordsGroups ; }
public List < Double > doubleOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public String [ ] selectByStringAndLengthConcat ( ) { String [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; String [ ] upperLowerWords = ( String [ ] ) Arrays . stream ( words ) . map ( w -> w + w . length ( ) ) . toArray ( ) ; return upperLowerWords ; }
public List < Pair < String , Integer >> customerEachRegionOrdersMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMin ; }
public double projectedDoubleFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . map ( i -> Math . log ( i ) ) . filter ( n -> n > 3 ) . findFirst ( ) . getAsDouble ( ) ; return firstNum ; }
public double expensiveProductUnitPriceMin ( ) { List < Product > products = getProductList ( ) ; double minUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . min ( ) . getAsDouble ( ) ; return minUnitPrice ; }
public List < String > stringOrderbyCustomThenbyLengthDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w , new CaseInsensitiveComparer ( ) ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public int [ ] projectionIntUnion ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] uniqueNumbers = IntStream . concat ( first , second ) . distinct ( ) . toArray ( ) ; return uniqueNumbers ; }
public String [ ] stringExcept ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; String [ ] differemtWords = ( String [ ] ) Arrays . stream ( wordsA ) . distinct ( ) . filter ( a -> Arrays . stream ( wordsB ) . allMatch ( b -> ! b . equals ( a ) ) ) . toArray ( ) ; return differemtWords ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public Map < String , Integer > expensiveProductEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ) ) ; return categories ; }
public Map < String , List < Product >> productEachCategoryFirstUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) . getUnitPrice ( ) ) . toList ( ) ) ) ; return categories ; }
public List < String > stringOrderbyLengthReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public int oddNumbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . map ( n -> n * 2 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public List < Product > productOrderbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ; return sortedProducts ; }
public boolean expensiveProductAllMatch ( ) { List < Product > products = getProductList ( ) ; boolean allMatch = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return allMatch ; }
public List < Product > expensiveProductOrderbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ; return sortedProducts ; }
public double shortStringAverageLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; double averageLength = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . average ( ) . getAsDouble ( ) ; return averageLength ; }
public int oddNumbersMax ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public List < Double > expensiveProductUnitPrice ( ) { List < Product > products = getProductList ( ) ; List < Double > productNames = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ; return productNames ; }
public double [ ] projectionDoubleExcept ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] differemtNumbers = first . distinct ( ) . filter ( a -> second . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtNumbers ; }
public List < Pair < String , String >> productCrossGroupJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1. getProductName ( ) ) ) ) . toList ( ) ; return q ; }
public Map < Boolean , List < Product >> productGroupByPriceDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public int [ ] intsConvertToArrayAndPrintForeach ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; int [ ] intsArray = Arrays . stream ( ints ) . sorted ( ) . toArray ( ) ; for ( int i : intsArray ) System . out . println ( i ) ; return intsArray ; }
public List < Product > inStockProductSkipWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public int oddNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public int totalOrdersCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . count ( ) ; return count ; }
public Map < Character , List < String >> stringGroupByFirstCharDict ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) ; return wordsGroups ; }
public List < String > stringReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public Map < String , Integer > customerEachCountryOrdersMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . max ( ) . getAsInt ( ) ) ) ; return ordersMax ; }
public double bigNumbersAverage ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public void oddNumbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public Map < Integer , Boolean > rangeOfIntsToDict ( ) { Map < Integer , Boolean > numbers = IntStream . range ( 0 , 100 ) . boxed ( ) . collect ( toMap ( n -> n , n -> n % 2 == 0 ) ) ; return numbers ; }
public List < Integer > intsConvertToDescendingListAndPrint ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < Integer > intsList = Arrays . stream ( ints ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; for ( int i = 0 ; i < intsList . size ( ) ; i ++ ) System . out . println ( intsList . get ( i ) ) ; return intsList ; }
public Map < String , List < Customer >> customerEachCountryOrdersFirstCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersFirst = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) . getOrders ( ) . size ( ) ) . toList ( ) ) ) ; return customerOrdersFirst ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public List < Double > bigDoubleFractionOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public Map < Boolean , List < Product >> productGroupByInStockDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) ; return productGroup ; }
public int uniqueFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int uniqueFactorsCount = ( int ) Arrays . stream ( factorsOf300 ) . distinct ( ) . count ( ) ; return uniqueFactorsCount ; }
public boolean longStringAllMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean allMatch = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . allMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return allMatch ; }
public List < Product > productTakeWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public int oddNumbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . map ( n -> n * 2 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public void bigDoubleNumbersDeferred ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; AtomicReference < Double > d = new AtomicReference <> ( 0.0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> d . accumulateAndGet ( n , Double :: sum ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + d ) ) ; }
public List < Pair < String , LocalDate >> waCustomerOrdersEachNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachWAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . takeWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachWAOrders ; }
public Map < String , Integer > expensiveProductEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . sum ( ) ) ) ; return categories ; }
public List < String > stringOrderbyThenbyLengthDescendingCustom ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public double bigDoubleNumbersFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . filter ( d -> d > 5 ) . findFirst ( ) . orElse ( - 2.3 ) ; return firstNum ; }
public Map < String , Double > customerInRegionOrdersTotalSumDict ( String region ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public List < Double > doubleOrderbyFractionDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public Map < String , List < Product >> productGroupSkip ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . skip ( 3 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public Map < Boolean , List < Product >> productGroupByPriceDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) ; return productGroup ; }
public int numbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . min ( ) . getAsInt ( ) ; return minNum ; }
public List < String > expensiveProductNameOrderby ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getProductName ( ) ) . sorted ( ) . toList ( ) ; return sortedProducts ; }
public boolean projectionEqualDoubles ( ) { double [ ] numbersA = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; double [ ] numbersB = { 6.5 , 1.3 , 8.7 , 2.4 , 4.8 } ; boolean equal = Arrays . equals ( Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) . toArray ( ) , numbersB ) ; return equal ; }
public List < Product > productOrderbyCategoryThenbyDescendingId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < String > shortStringOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ; return sortedWords ; }
public List < Product > productOrderbyName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > productOrderbyCategoryThenbyName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) ) ) . toList ( ) ; return sortedProducts ; }
public boolean projectionEqualStrings ( ) { List < String > wordsA = Arrays . asList ( " Alpha " , " Beta " , " Gamma " ) ; List < String > wordsB = Arrays . asList ( " aLPhA " , " bETa " , " gAaMa " ) ; boolean equal = wordsA . stream ( ) . map ( w -> w . toLowerCase ( ) ) . toList ( ) . equals ( wordsB ) ; return equal ; }
public List < Order > customerSelectManyBigOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) ) . toList ( ) ; return customerProperties ; }
