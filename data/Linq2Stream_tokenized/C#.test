public List < Tuple < string , double >> CustomerExpensiveOrdersTotalMax ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalMax = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Where ( o => o . Total > 100 ) . Max ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalMax ; }
public int ProjectedStringElementAt ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = strings . Select ( s => s . Length ) . Where ( i => i % 2 == 0 ) . ElementAt ( 2 ) ; return firstStringLength ; }
public List < Tuple < string , int >> CustomerEachCountryOrdersMin ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int >> ordersMin = customers . GroupBy ( c => c . Country ) . Select ( g => Tuple . Create ( g . Key , g . Min ( c => c . Orders . Count ) ) ) . ToList ( ) ; return ordersMin ; }
public List < Tuple < string , DateTime >> CustomerOrdersEachNestedSkip ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> after3EachOrders = customers . SelectMany ( c => c . Orders . Skip ( 3 ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return after3EachOrders ; }
public int OddNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = numbers . FirstOrDefault ( n => n % 2 == 1 , - 2 ) ; return firstNum ; }
public List < Tuple < string , int >> CustomerExpensiveOrdersCount ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int >> orderCounts = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Count ( o => o . Total > 100 ) ) ) . ToList ( ) ; return orderCounts ; }
public Dictionary < char , List < string >> StringGroupByFirstCharDictOrderbyDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Dictionary < char , List < string >> wordsGroups = words . GroupBy ( w => char . ToLower ( w [ 0 ] ) ) . ToDictionary ( g => g . Key , g => g . OrderByDescending ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ) ; return wordsGroups ; }
public List < int > IntWithSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > q = numbers . Where ( ( n , i ) => n < i * i ) . ToList ( ) ; return q ; }
public int [ ] ProjectionIntConcat ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = numbersA . Select ( n => n + 1 ) ; var second = numbersB . Select ( n => n - 1 ) ; int [ ] numbers = first . Concat ( second ) . ToArray ( ) ; return numbers ; }
public List < int > RangeOfEvenIntsStartFrom ( int start , int count ) { List < int > numbers = Enumerable . Range ( start , count ) . Where ( n => n % 2 == 0 ) . ToList ( ) ; return numbers ; }
public List < Tuple < string , string >> ProductLeftOuterJoinCategoriesName ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , string >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . SelectMany ( t => t . Item2. Select ( p => p . ProductName ) . DefaultIfEmpty ( " No ▁ Product " ) , ( t , n ) => Tuple . Create ( t . Item1 , n ) ) . ToList ( ) ; return q ; }
public List < Tuple < string , int , double >> CustomerSelectManyCustomerNewOrderIdAndTotals ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int , double >> customerProperties = customers . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderId , o . Total ) ) . ToList ( ) ; return customerProperties ; }
public Dictionary < string , List < Product >> ProductEachCategoryMaxUnitPriceProductsDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice == g . Max ( p => p . UnitPrice ) ) . ToList ( ) ) ; return categories ; }
public Product ProductFirstOrDefault ( ) { List < Product > products = GetProductList ( ) ; Product product12 = products . FirstOrDefault ( p => p . ProductId == 12 , Product . Default ) ; return product12 ; }
public int OddFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int factorsCount = factorsOf300. Count ( n => n % 2 == 1 ) ; return factorsCount ; }
public List < double > DoubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n % 1.5 ) . ThenByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public double DoubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . FirstOrDefault ( 3.14 ) ; return firstNum ; }
public List < int > RangeOfEvenIntsStartFrom ( ) { List < int > numbers = Enumerable . Range ( 100 , 100 ) . Where ( n => n % 2 == 0 ) . ToList ( ) ; return numbers ; }
public Dictionary < string , List < Product >> ProductEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice == g . Min ( p => p . UnitPrice ) ) . ToList ( ) ) ; return categories ; }
public Dictionary < string , double > CustomerOrdersTotalSumDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalSum = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Sum ( o => o . Total ) ) ; return ordersTotalSum ; }
public List < Tuple < string , List < Order >>> CustomerIdAndOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , List < Order >>> customerProperties = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders ) ) . ToList ( ) ; return customerProperties ; }
public List < double > BigDoubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 3 ) . OrderBy ( n => n % 1.5 ) . ThenBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public List < Tuple < string , Order >> CustomerSelectManyCustomerOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Order >> customerProperties = customers . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o ) ) . ToList ( ) ; return customerProperties ; }
public Dictionary < string , Dictionary < string , Customer >> CustomerNestedGroupByRegionAndName ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , Dictionary < string , Customer >> customerGroups = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . ToDictionary ( c => c . CompanyName , c => c ) ) ; return customerGroups ; }
public List < Order > CustomerOrdersTakeWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Order > firstOrdersWhile = customers . SelectMany ( c => c . Orders ) . TakeWhile ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) . ToList ( ) ; return firstOrdersWhile ; }
public Dictionary < double , double > ConvertArrayToDictionaryWithDistinctAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 1.7 , 2.9 } ; Dictionary < double , double > doublesDict = doubles . Distinct ( ) . ToDictionary ( sr => sr , sr => sr * 2 ) ; foreach ( var pair in doublesDict ) Console . WriteLine ( pair . Key + " ▁ " + pair . Value ) ; return doublesDict ; }
public double [ ] ProjectionDoubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = numbersA . Select ( n => n - ( int ) n ) ; var second = numbersB . Select ( n => n - ( int ) n ) ; double [ ] numbers = first . Intersect ( second ) . ToArray ( ) ; return numbers ; }
public List < Tuple < string , string >> CustomerCrossGroupJoinRegionsPhone ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , string >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. Select ( c => c . Phone ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public List < double > BigDoubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 5 ) . OrderByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public List < int > IntTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > firstNumbers = numbers . TakeWhile ( ( n , i ) => n > i ) . ToList ( ) ; return firstNumbers ; }
public List < int > IntSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > afterNumbers = numbers . SkipWhile ( ( n , i ) => n > i ) . ToList ( ) ; return afterNumbers ; }
public double BigNumbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = numbers . Where ( n => n > 5 ) . Average ( n => n * 2 ) ; return averageNum ; }
public Dictionary < string , double > CustomerExpensiveOrdersTotalSumDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalSum = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Where ( o => o . Total > 100 ) . Sum ( o => o . Total ) ) ; return ordersTotalSum ; }
public Dictionary < string , List < Product >> ProductEachGroupTake ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> first3EachGroups = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Take ( 3 ) . ToList ( ) ) ; return first3EachGroups ; }
public double BigDoubleNumbersFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . First ( d => d > 5 ) ; return firstNum ; }
public double ProductUnitPriceMin ( ) { List < Product > products = GetProductList ( ) ; double minUnitPrice = products . Min ( p => p . UnitPrice ) ; return minUnitPrice ; }
public List < Tuple < string , string >> CustomerLeftOuterJoinRegionsName ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , string >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. Select ( c => c . CompanyName ) . DefaultIfEmpty ( " No ▁ Customer " ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public int ProjectedBigNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = numbers . Select ( i => ( int ) Math . Pow ( 2 , i ) ) . First ( n => n > 100 ) ; return firstNum ; }
public Dictionary < int , Dictionary < int , List < Order >>> CustomerNestedGroupByOrderYearAndMonth ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < int , Dictionary < int , List < Order >>> customerOrderGroups = customers . SelectMany ( c => c . Orders ) . GroupBy ( o => o . OrderDate . Year ) . ToDictionary ( yg => yg . Key , yg => yg . GroupBy ( o => o . OrderDate . Month ) . ToDictionary ( mg => mg . Key , mg => mg . ToList ( ) ) ) ; return customerOrderGroups ; }
public List < Tuple < string , List < Product >>> ProductEachCategoryFirstOrDefaultUnitPriceProducts ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < Product >>> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Where ( p => p . UnitPrice == g . FirstOrDefault ( Product . Default ) . UnitPrice ) . ToList ( ) ) ) . ToList ( ) ; return categories ; }
public bool StringAnyMatch ( char c ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; bool anyMatch = words . Any ( w => w [ 0 ] > c ) ; return anyMatch ; }
public Dictionary < string , double > CustomerEachRegionOrdersTotalMaxDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalMax = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . SelectMany ( c => c . Orders ) . Max ( o => o . Total ) ) ; return ordersTotalMax ; }
public List < Tuple < double , List < double >>> DoubleGroupByMod ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; List < Tuple < double , List < double >>> numberGroups = numbers . GroupBy ( n => n % 1.5 ) . Select ( g => Tuple . Create ( g . Key , g . ToList ( ) ) ) . ToList ( ) ; return numberGroups ; }
public Dictionary < string , int > CustomerEachRegionOrdersMinDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > ordersMin = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . Min ( c => c . Orders . Count ) ) ; return ordersMin ; }
public int BigNumbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = numbers . Where ( n => n > 5 ) . Sum ( n => n * 2 ) ; return numbersSum ; }
public List < int > IntSquareSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > afterNumbersWhile = numbers . Select ( i => i * i ) . SkipWhile ( i => i > 3 ) . ToList ( ) ; return afterNumbersWhile ; }
public Dictionary < string , bool > ProductEachGroupAllMatch ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , bool > allMatch = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . All ( p => p . UnitsInStock > 0 ) ) ; return allMatch ; }
public bool LongStringAnyMatch ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; bool anyMatch = words . Where ( w => w . Length > 5 ) . Any ( n => string . CompareOrdinal ( n , " b " ) > 0 ) ; return anyMatch ; }
public List < Product > ProductOrderbyDescendingName ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderByDescending ( p => p . ProductName ) . ToList ( ) ; return sortedProducts ; }
public bool [ ] BigIntWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool [ ] numSelected = numbers . Where ( n => n > 5 ) . Select ( ( n , i ) => n == i ) . ToArray ( ) ; return numSelected ; }
public double ProductUnitPriceTotalSum ( ) { List < Product > products = GetProductList ( ) ; double totalSum = products . Sum ( p => p . UnitPrice ) ; return totalSum ; }
public List < Tuple < string , Customer >> CustomerLeftOuterJoinRegions ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Customer >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. DefaultIfEmpty ( null ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public Dictionary < string , int > CustomerNewOrdersCountDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > orderCounts = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Count ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) ) ; return orderCounts ; }
public List < string > StringOrderbyLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . OrderBy ( w => w . Length ) . ToList ( ) ; return sortedWords ; }
public string [ ] SelectByCaseConcat ( ) { string [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; string [ ] upperLowerWords = words . Select ( w => w . ToUpper ( ) + w . ToLower ( ) ) . ToArray ( ) ; return upperLowerWords ; }
public List < Product > ProductOrderbyDescendingId ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderByDescending ( p => p . ProductId ) . ToList ( ) ; return sortedProducts ; }
public Dictionary < string , List < Product >> ProductsConvertGroupingToDictionaryAndPrint ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> catagory = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; foreach ( var pair in catagory ) { Console . WriteLine ( pair . Key + " : " ) ; foreach ( var product in pair . Value ) Console . WriteLine ( " \ t " + product ) ; } return catagory ; }
public List < Tuple < string , double >> CustomerOrdersTotalSum ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalSum = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Sum ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalSum ; }
public List < Tuple < int , string >> CustomerCrossJoinRegionsWithCodeName ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < int , string >> q = regions . Join ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r . Item2 , c . CompanyName ) ) . ToList ( ) ; return q ; }
public double BigNumbersAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = numbers . Where ( n => n > 2 ) . Aggregate ( seed , ( a , b ) => a * b ) ; return product ; }
public int ProjectedStringFirst ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = strings . Select ( s => s . Length ) . First ( i => i % 2 == 0 ) ; return firstStringLength ; }
public bool ProductAnyMatch ( ) { List < Product > products = GetProductList ( ) ; bool anyMatch = products . Any ( p => p . UnitsInStock > 0 ) ; return anyMatch ; }
public List < Tuple < string , int , double >> CustomerSelectManyCustomerOrderIdAndTotals ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int , double >> customerProperties = customers . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderId , o . Total ) ) . ToList ( ) ; return customerProperties ; }
public int NumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = numbers . Sum ( ) ; return numbersSum ; }
public char [ ] ShortStringFirstChar ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; char [ ] selected = strings . Where ( w => w . Length < 4 ) . Select ( w => w [ 0 ] ) . ToArray ( ) ; return selected ; }
public int [ ] OddFactorOf300And900Count ( ) { int [ ] [ ] factorsOf300And900 = { new [ ] { 2 , 2 , 3 , 5 , 5 } , new [ ] { 2 , 2 , 3 , 3 , 5 , 5 } } ; int [ ] factorsCount = factorsOf300And900. Select ( a => a . Count ( n => n % 2 == 1 ) ) . ToArray ( ) ; return factorsCount ; }
public List < Tuple < string , double >> CustomerEachRegionOrdersTotalSum ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalSum = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . SelectMany ( c => c . Orders ) . Sum ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalSum ; }
public int [ ] IntPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = numbers . Select ( n => n + 1 ) . ToArray ( ) ; return numSelected ; }
public List < Tuple < string , Customer >> CustomerCrossGroupJoinRegions ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Customer >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2 , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public bool WaCustomerOrdersNestedAnyMatch ( ) { List < Customer > customers = GetCustomerList ( ) ; bool anyMatch = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . Any ( t => t . Item2 > new DateTime ( 2000 , 1 , 1 ) ) ; return anyMatch ; }
public Dictionary < Tuple < string , int > , List < string >> CustomerGroupJoinRegionsWithCodeNameRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; Dictionary < Tuple < string , int > , List < string >> q = regions . GroupJoin ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r , c . Select ( c => c . CompanyName ) . ToList ( ) ) ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; return q ; }
public List < Tuple < string , DateTime >> CustomerOrdersNestedTakeWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> firstOrdersWhile = customers . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . TakeWhile ( t => t . Item2 > new DateTime ( 2000 , 1 , 1 ) ) . ToList ( ) ; return firstOrdersWhile ; }
public Tuple < int , int > [ ] SelectManyJoinSumEven ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Tuple < int , int > [ ] pairs = numbersA . SelectMany ( a => numbersB . Where ( b => ( a + b ) % 2 == 0 ) , ( a , b ) => Tuple . Create ( a , b ) ) . ToArray ( ) ; return pairs ; }
public int [ ] StringLength ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = strings . Select ( w => w . Length ) . ToArray ( ) ; return selected ; }
public int ShortStringMaxLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; int maxLength = words . Where ( w => w . Length < 7 ) . Max ( w => w . Length ) ; return maxLength ; }
public bool [ ] IntWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool [ ] numSelected = numbers . Select ( ( n , i ) => n == i ) . ToArray ( ) ; return numSelected ; }
public List < int > RangeOfSquareInts ( ) { List < int > numbers = Enumerable . Range ( 0 , 20 ) . Select ( n => n * n ) . ToList ( ) ; return numbers ; }
public Dictionary < bool , List < double >> DoubleGroupByBoolDictOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Dictionary < bool , List < double >> numbersGroups = numbers . GroupBy ( n => n > 5 ) . ToDictionary ( g => g . Key , g => g . OrderBy ( n => n - ( int ) n ) . ToList ( ) ) ; return numbersGroups ; }
public List < string > ShortStringOrderbyDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < string > sortedWords = words . Where ( w => w . Length < 6 ) . OrderByDescending ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public Dictionary < string , Order > CustomerEachRegionFirstOrderDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , Order > ordersMax = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . SelectMany ( c => c . Orders ) . First ( ) ) ; return ordersMax ; }
public List < Tuple < bool , List < int >>> ProductGroupByPriceWithId ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < bool , List < int >>> productGroup = products . GroupBy ( p => p . UnitPrice > 100 ) . Select ( g => Tuple . Create ( g . Key , g . Select ( p => p . ProductId ) . ToList ( ) ) ) . ToList ( ) ; return productGroup ; }
public List < Tuple < string , int >> CustomerDistinctOrdersCount ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int >> orderCounts = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Distinct ( ) . Count ( ) ) ) . ToList ( ) ; return orderCounts ; }
public int OddNumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = numbers . Where ( n => n % 2 == 1 ) . Sum ( ) ; return numbersSum ; }
public List < int > IntTakeCount ( int [ ] numbers , int n ) { List < int > firstNNumbers = numbers . Take ( n ) . ToList ( ) ; return firstNNumbers ; }
public List < Order > WaCustomerSelectManyNewOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Order > customerProperties = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) ) . ToList ( ) ; return customerProperties ; }
public List < double > DoubleFractionOrderbyReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Select ( n => n - ( int ) n ) . OrderBy ( n => n ) . Reverse ( ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < string , double > CustomerExpensiveOrdersTotalMinDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalMin = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Where ( o => o . Total > 100 ) . Min ( o => o . Total ) ) ; return ordersTotalMin ; }
public Dictionary < bool , List < int >> ProductGroupByInStockWithIdDictPrint ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < int >> productGroup = products . GroupBy ( p => p . UnitsInStock == 0 ) . ToDictionary ( g => g . Key , g => g . Select ( p => p . ProductId ) . ToList ( ) ) ; productGroup [ true ] . ForEach ( p => Console . Write ( p ) ) ; Console . WriteLine ( ) ; productGroup [ false ] . ForEach ( p => Console . Write ( p ) ) ; return productGroup ; }
public List < Tuple < string , double >> ProductCrossJoinCategoriesUnitPrice ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , double >> q = categories . Join ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p . UnitPrice ) ) . ToList ( ) ; return q ; }
public Dictionary < string , double > CustomerOrdersTotalMaxDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalMax = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Max ( o => o . Total ) ) ; return ordersTotalMax ; }
public List < string > StringTakeCount ( string [ ] strings , int n ) { List < string > firstNWords = strings . Take ( n ) . ToList ( ) ; return firstNWords ; }
public void NumbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int i = 0 ; var q = numbers . Select ( n => n * 2 ) . Select ( n => i += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public double [ ] DoublesConvertToDescendingArrayAndPrintForeach ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = doubles . OrderByDescending ( d => d ) . ToArray ( ) ; foreach ( double d in doublesArray ) Console . WriteLine ( d ) ; return doublesArray ; }
public double ExpensiveProductUnitPriceTotalSum ( ) { List < Product > products = GetProductList ( ) ; double totalSum = products . Where ( p => p . UnitPrice > 100 ) . Sum ( p => p . UnitPrice ) ; return totalSum ; }
public List < double > BigDoubleOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 5 ) . OrderBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < string , int > ConvertTuplesToDictionaryAndPrint ( ) { List < Tuple < string , int >> scoreRecords = new List < Tuple < string , int >> { Tuple . Create ( " Alice " , 50 ) , Tuple . Create ( " Bob " , 40 ) , Tuple . Create ( " Cathy " , 45 ) } ; Dictionary < string , int > scoreRecordsDict = scoreRecords . ToDictionary ( sr => sr . Item1 , sr => sr . Item2 ) ; foreach ( var pair in scoreRecordsDict ) Console . WriteLine ( pair . Key + " ▁ " + pair . Value ) ; return scoreRecordsDict ; }
public List < Product > RepeatedProductsWithCount ( int count ) { List < Product > products = Enumerable . Repeat ( Product . Default , count ) . ToList ( ) ; return products ; }
public List < string > StringSkipWhileCount ( string [ ] strings , char c ) { List < string > afterWordsWhile = strings . SkipWhile ( w => w [ 0 ] > c ) . ToList ( ) ; return afterWordsWhile ; }
public List < int > IntTakeWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > firstNumbers = numbers . TakeWhile ( ( n , i ) => n > i ) . ToList ( ) ; return firstNumbers ; }
public double InputNumbersAggregate ( double [ ] numbers ) { double product = numbers . Aggregate ( ( runningProduct , nextFactor ) => runningProduct * nextFactor ) ; return product ; }
public List < string > StringTakeWhileCount ( string [ ] strings , char c ) { List < string > firstWordsWhile = strings . TakeWhile ( w => w [ 0 ] > c ) . ToList ( ) ; return firstWordsWhile ; }
public List < int > StringLengthTake ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < int > first3Words = words . Select ( w => w . Length ) . Take ( 3 ) . ToList ( ) ; return first3Words ; }
public void StringLengthEager ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; int i = 0 ; var q = words . Select ( w => w . Length ) . Select ( n => i += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public int BigNumbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = numbers . Where ( n => n > 5 ) . Max ( n => n * 2 ) ; return maxNum ; }
public List < Product > ProductIndexedWhere ( ) { List < Product > products = GetProductList ( ) ; List < Product > q = products . Where ( ( w , i ) => w . UnitsInStock > 0 && i % 2 == 1 ) . ToList ( ) ; return q ; }
public List < Tuple < string , Product >> ProductCrossJoinCategories ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , Product >> q = categories . Join ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . ToList ( ) ; return q ; }
public int [ ] ShortStringLength ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = strings . Where ( w => w . Length < 4 ) . Select ( w => w . Length ) . ToArray ( ) ; return selected ; }
public List < Product > InStockProductTakeWhile ( ) { List < Product > products = GetProductList ( ) ; List < Product > firstProductsWhile = products . Where ( p => p . UnitsInStock > 0 ) . TakeWhile ( p => p . ProductId > 100 ) . ToList ( ) ; return firstProductsWhile ; }
public List < Tuple < string , int >> ConvertSelectedTupleToListAndPrint ( ) { object [ ] numbers = { Tuple . Create ( " Alice " , " 50 " ) , Tuple . Create ( " Bob " , 40 ) , Tuple . Create ( " Cathy " , 45 ) } ; List < Tuple < string , int >> strings = numbers . OfType < Tuple < string , int >> ( ) . ToList ( ) ; for ( var i = 0 ; i < strings . Count ; i ++ ) Console . WriteLine ( strings [ i ] . Item1 + " : " + strings [ i ] . Item2 ) ; return strings ; }
public int [ ] TransformIndexHashToInt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] textNums = numbers . Select ( n => numbers [ n * 97 % 10 ] ) . ToArray ( ) ; return textNums ; }
public int ExpensiveOrdersCount ( string region ) { List < Customer > customers = GetCustomerList ( ) ; int count = customers . SelectMany ( c => c . Orders ) . Count ( o => o . Total > 100 ) ; return count ; }
public Dictionary < string , int > ConvertTuplesToDictionary ( ) { List < Tuple < string , int >> scoreRecords = new List < Tuple < string , int >> { Tuple . Create ( " Alice " , 50 ) , Tuple . Create ( " Bob " , 40 ) , Tuple . Create ( " Cathy " , 45 ) } ; Dictionary < string , int > scoreRecordsDict = scoreRecords . ToDictionary ( sr => sr . Item1 , sr => sr . Item2 ) ; return scoreRecordsDict ; }
public double NumbersDoubledAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = numbers . Select ( n => n * 2 ) . Aggregate ( seed , ( a , b ) => a * b ) ; return product ; }
public Dictionary < string , List < double >> ProductGroupUnitPriceDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < double >> productNames = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Select ( p => p . UnitPrice ) . ToList ( ) ) ; return productNames ; }
public int [ ] IntTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = numbers . Select ( n => n * 2 ) . ToArray ( ) ; return numSelected ; }
public List < Tuple < string , double >> CustomerInRegionOrdersTotalMin ( string region ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalMin = customers . Where ( c => c . Region . Equals ( region ) ) . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Min ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalMin ; }
public List < double > OutOfStockProductUnitPrice ( ) { List < Product > products = GetProductList ( ) ; List < double > productNames = products . Where ( p => p . UnitsInStock == 0 ) . Select ( p => p . UnitPrice ) . ToList ( ) ; return productNames ; }
public bool EqualInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; bool equal = numbersA . SequenceEqual ( numbersB ) ; return equal ; }
public Product [ ] ProductsConvertToDescendingArrayAndPrintForeach ( ) { List < Product > products = GetProductList ( ) ; Product [ ] productsArray = products . OrderByDescending ( p => p . UnitPrice ) . ToArray ( ) ; foreach ( Product p in productsArray ) Console . WriteLine ( p ) ; return productsArray ; }
public bool IntAnyMatchInput ( int i ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool anyMatch = numbers . Any ( n => n > i ) ; return anyMatch ; }
public List < string > LongStringIndexedWhere ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > q = words . Where ( w => w . Length > 5 ) . Where ( ( w , i ) => w . Length < i * 3 ) . ToList ( ) ; return q ; }
public List < string > StringOrderbyLengthCustomThenby ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > sortedWords = words . OrderBy ( w => w . Length , new CustomNumberComparer ( ) ) . ThenBy ( w => w ) . ToList ( ) ; return sortedWords ; }
public List < Tuple < String , int >> CountRegionDistinctCustomer ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < String , int >> regionCounts = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . Distinct ( ) . Count ( ) ) ) . ToList ( ) ; return regionCounts ; }
public int [ ] TransformIndexToInt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] textNums = numbers . Select ( n => numbers [ n ] ) . ToArray ( ) ; return textNums ; }
public List < double > DoubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n % 1.5 ) . ThenBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public double ExpensiveProductUnitPriceAggregateAverageWithSeed ( ) { List < Product > products = GetProductList ( ) ; double seed = 15.5 ; double aggregateSum = products . Select ( p => p . UnitPrice ) . Where ( d => d > 100 ) . Aggregate ( seed , ( a , b ) => ( a + b ) / 2 ) ; return aggregateSum ; }
public List < string > ExpensiveProductNameOrderbyDescending ( ) { List < Product > products = GetProductList ( ) ; List < string > sortedProducts = products . Where ( p => p . UnitPrice > 100 ) . Select ( p => p . ProductName ) . OrderByDescending ( n => n ) . ToList ( ) ; return sortedProducts ; }
public char [ ] ProjectionStringExcept ( ) { string [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; string [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = wordsA . Select ( n => n [ 0 ] ) ; var second = wordsB . Select ( n => n [ 0 ] ) ; char [ ] words = first . Except ( second ) . ToArray ( ) ; return words ; }
public Dictionary < string , List < Product >> ProductEachGroupSkip ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> after3EachGroups = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Skip ( 3 ) . ToList ( ) ) ; return after3EachGroups ; }
public List < Tuple < string , Product >> ProductEachCategoryElementAt ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , Product >> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . ElementAt ( 1 ) ) ) . ToList ( ) ; return categories ; }
public List < string > StringOrderbyThenbyLengthCustom ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > sortedWords = words . OrderBy ( w => w ) . ThenBy ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public int DistinctProductCategoryCount ( ) { List < Product > products = GetProductList ( ) ; int count = products . Select ( p => p . Category ) . Distinct ( ) . Count ( ) ; return count ; }
public Dictionary < string , List < Customer >> CustomerEachCountryOrdersMaxCustomerDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < Customer >> customerOrdersMax = customers . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . Where ( c => c . Orders . Count == g . Max ( c => c . Orders . Count ) ) . ToList ( ) ) ; return customerOrdersMax ; }
public int BigNumbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = numbers . Where ( n => n > 5 ) . Min ( n => n * 2 ) ; return minNum ; }
public List < Tuple < string , string >> CustomerIdAndName ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , string >> customerProperties = customers . Select ( c => Tuple . Create ( c . CustomerId , c . CompanyName ) ) . ToList ( ) ; return customerProperties ; }
public List < Tuple < bool , List < Product >>> ProductGroupByInStock ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < bool , List < Product >>> productGroup = products . GroupBy ( p => p . UnitsInStock == 0 ) . Select ( g => Tuple . Create ( g . Key , g . ToList ( ) ) ) . ToList ( ) ; return productGroup ; }
public double [ ] ProjectionDoubleConcat ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = numbersA . Select ( n => n - ( int ) n ) ; var second = numbersB . Select ( n => n - ( int ) n ) ; double [ ] numbers = first . Concat ( second ) . ToArray ( ) ; return numbers ; }
public Product [ ] ProductsConvertToArray ( ) { List < Product > products = GetProductList ( ) ; Product [ ] productsArray = products . OrderBy ( p => p . UnitPrice ) . ToArray ( ) ; return productsArray ; }
public List < double > DoubleOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n - ( int ) n ) . ToList ( ) ; return sortedNumbers ; }
public double ExpensiveProductUnitPriceAverage ( ) { List < Product > products = GetProductList ( ) ; double averageUnitPrice = products . Where ( p => p . UnitPrice > 100 ) . Average ( p => p . UnitPrice ) ; return averageUnitPrice ; }
public List < Product > RepeatedProducts ( ) { List < Product > products = Enumerable . Repeat ( Product . Default , 30 ) . ToList ( ) ; return products ; }
public int ProjectedStringFirstOrDefault ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = strings . Select ( s => s . Length ) . FirstOrDefault ( i => i % 2 == 0 , - 1 ) ; return firstStringLength ; }
public List < Tuple < string , int >> ConvertSelectedTupleToList ( ) { object [ ] numbers = { Tuple . Create ( " Alice " , " 50 " ) , Tuple . Create ( " Bob " , 40 ) , Tuple . Create ( " Cathy " , 45 ) } ; List < Tuple < string , int >> strings = numbers . OfType < Tuple < string , int >> ( ) . ToList ( ) ; return strings ; }
public List < int > IntTakeWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > firstNumbersWhile = numbers . TakeWhile ( i => i > 3 ) . ToList ( ) ; return firstNumbersWhile ; }
public List < Tuple < string , int , string >> CustomerCrossJoinRegionsWithCodeNameRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int , string >> q = regions . Join ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r . Item1 , r . Item2 , c . CompanyName ) ) . ToList ( ) ; return q ; }
public List < Product > ProductsConvertToList ( ) { List < Product > products = GetProductList ( ) ; List < Product > productsList = products . OrderBy ( p => p . UnitPrice ) . ToList ( ) ; return productsList ; }
public List < Product > RepeatedProductsWithBase ( Product product ) { List < Product > products = Enumerable . Repeat ( product , 10 ) . ToList ( ) ; return products ; }
public List < Tuple < string , List < Product >>> ProductGroupByCategoryOrderbyId ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < Product >>> productsGroups = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . OrderBy ( p => p . ProductId ) . ToList ( ) ) ) . ToList ( ) ; return productsGroups ; }
public Dictionary < string , int > CustomerEachRegionOrdersSumDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > ordersTotalSum = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . Sum ( c => c . Orders . Count ) ) ; return ordersTotalSum ; }
public List < string > StringIndexedWhere ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > q = words . Where ( ( w , i ) => w . Length < i ) . ToList ( ) ; return q ; }
public bool CategoryProductAnyMatch ( ) { List < Product > products = GetProductList ( ) ; bool anyMatch = products . Where ( p => p . Category == " Beverages " ) . Any ( p => p . UnitsInStock > 0 ) ; return anyMatch ; }
public List < Tuple < string , Product >> ProductEachCategoryFirst ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , Product >> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . First ( ) ) ) . ToList ( ) ; return categories ; }
public double DoubleFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . First ( ) ; return firstNum ; }
public List < int > ShortStringLengthOrderbyDescending ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < int > sortedWords = words . Where ( w => w . Length < 6 ) . Select ( w => w . Length ) . OrderByDescending ( w => w ) . ToList ( ) ; return sortedWords ; }
public List < double > BigDoubleFractionOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 5 ) . Select ( n => n - ( int ) n ) . OrderBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < string , int > ConvertSelectedTupleToDictionaryAndPrint ( ) { object [ ] numbers = { Tuple . Create ( " Alice " , " 50 " ) , Tuple . Create ( " Bob " , 40 ) , Tuple . Create ( " Cathy " , 45 ) } ; Dictionary < string , int > strings = numbers . OfType < Tuple < string , int >> ( ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; foreach ( var pair in strings ) Console . WriteLine ( pair . Key + " : " + pair . Value ) ; return strings ; }
public double BigDoubleNumbersSum ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numbersSum = numbers . Where ( d => d > 5 ) . Sum ( ) ; return numbersSum ; }
public List < int > IntIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > q = numbers . Where ( ( n , i ) => n < i ) . ToList ( ) ; return q ; }
public int [ ] OddIntPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = numbers . Where ( n => n % 2 == 1 ) . Select ( n => n + 1 ) . ToArray ( ) ; return numSelected ; }
public List < Tuple < bool , List < string >>> StringGroupByLengthOrderbyLengthCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Tuple < bool , List < string >>> wordsGroups = words . GroupBy ( w => w . Length > 8 ) . Select ( g => Tuple . Create ( g . Key , g . OrderBy ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ) ) . ToList ( ) ; return wordsGroups ; }
public List < string > ConcatOfRegion ( ) { string [ ] regions = { " WA " , " AF " , " RO " } ; List < Customer > customers = GetCustomerList ( ) ; var customerRegions = customers . Select ( c => c . Region ) ; List < string > allRegions = customerRegions . Concat ( regions ) . ToList ( ) ; return allRegions ; }
public List < double > DoubleOrderbyFractionThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n - ( int ) n ) . ThenBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public List < Tuple < string , Order >> WaCustomerSelectManyCustomerNewOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Order >> customerProperties = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o ) ) . ToList ( ) ; return customerProperties ; }
public List < Order > CustomerSelectManyNewOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Order > customerProperties = customers . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) ) . ToList ( ) ; return customerProperties ; }
public List < double > BigDoubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 3 ) . OrderBy ( n => n % 1.5 ) . ThenByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public int [ ] IntZipAdd ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int [ ] addNumbers = numbersA . Zip ( numbersB , ( a , b ) => a + b ) . ToArray ( ) ; return addNumbers ; }
public List < Tuple < bool , List < int >>> IntGroupByBool ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Tuple < bool , List < int >>> numberGroups = numbers . GroupBy ( n => n > 4 ) . Select ( g => Tuple . Create ( g . Key , g . ToList ( ) ) ) . ToList ( ) ; return numberGroups ; }
public Dictionary < string , bool > ExpensiveProductEachGroupAllMatch ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , bool > allMatch = products . Where ( p => p . UnitPrice > 100 ) . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . All ( p => p . UnitsInStock > 0 ) ) ; return allMatch ; }
public List < string > ShortStringOrderbyDescendingLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < string > sortedWords = words . Where ( w => w . Length < 6 ) . OrderByDescending ( w => w . Length ) . ToList ( ) ; return sortedWords ; }
public List < Product > ExpensiveProductTakeWhile ( ) { List < Product > products = GetProductList ( ) ; List < Product > firstProductsWhile = products . Where ( p => p . UnitPrice > 100 ) . TakeWhile ( p => p . ProductId > 100 ) . ToList ( ) ; return firstProductsWhile ; }
public List < Tuple < string , double >> CustomerOrdersTotalAverage ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalAverage = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Average ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalAverage ; }
public Dictionary < String , int > CountDistinctProductByCategoryDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < String , int > categoryCounts = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Distinct ( ) . Count ( ) ) ; return categoryCounts ; }
public List < string > StringOrderby ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . OrderBy ( w => w ) . ToList ( ) ; return sortedWords ; }
public List < Tuple < string , double >> ProductCrossGroupJoinCategoriesUnitPrice ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , double >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . SelectMany ( t => t . Item2. Select ( p => p . UnitPrice ) , ( t , n ) => Tuple . Create ( t . Item1 , n ) ) . ToList ( ) ; return q ; }
public double NumbersAggregateFindMin ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double aggregateSum = numbers . Aggregate ( ( a , b ) => Math . Min ( a , b ) ) ; return aggregateSum ; }
public void OddNumbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int i = 0 ; var q = numbers . Where ( n => n % 2 == 1 ) . Select ( n => i += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public Dictionary < string , List < Product >> ProductGroupByCategoryDictOrderbyDescendingId ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> productsGroups = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . OrderByDescending ( p => p . ProductId ) . ToList ( ) ) ; return productsGroups ; }
public bool UnequalStrings ( ) { List < string > wordsA = new List < string > { " Alpha " , " Beta " , " Gamma " } ; List < string > wordsB = new List < string > { " aLPhA " , " bETa " , " gAaMa " } ; bool equal = wordsA . SequenceEqual ( wordsB ) ; return equal ; }
public List < double > DoubleOrderbyDescendingFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderByDescending ( n => n - ( int ) n ) . ToList ( ) ; return sortedNumbers ; }
public List < string > IntersectOfCategory ( ) { string [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = GetProductList ( ) ; var productCategories = products . Select ( p => p . Category ) ; List < string > sharedCategories = productCategories . Intersect ( categories ) . ToList ( ) ; return sharedCategories ; }
public Dictionary < string , List < string >> CustomerGroupJoinRegionsName ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < string >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c . Select ( c1 => c1. CompanyName ) . ToList ( ) ) ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; return q ; }
public List < Product > ProductSkip ( ) { List < Product > products = GetProductList ( ) ; List < Product > after3Products = products . Skip ( 3 ) . ToList ( ) ; return after3Products ; }
public bool StringAnyMatch ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; bool anyMatch = words . Any ( n => string . CompareOrdinal ( n , " b " ) > 0 ) ; return anyMatch ; }
public List < Tuple < string , List < Customer >>> CustomerGroupByRegion ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , List < Customer >>> catagory = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . ToList ( ) ) ) . ToList ( ) ; return catagory ; }
public void OddNumbersTwiceDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int i = 0 ; var q = numbers . Where ( n => n % 2 == 1 ) . Select ( n => n * 2 ) . Select ( n => i += n ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public int UniqueFactorsCount ( int [ ] factors ) { int factorsCount = factors . Distinct ( ) . Count ( ) ; return factorsCount ; }
public List < Tuple < string , DateTime >> CustomerOrdersEachNestedTakeWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> firstOrdersEachWhile = customers . SelectMany ( c => c . Orders . TakeWhile ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return firstOrdersEachWhile ; }
public string [ ] StringConcat ( ) { string [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; string [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; string [ ] allWords = wordsA . Concat ( wordsB ) . ToArray ( ) ; return allWords ; }
public List < double > DoubleOrderbyFractionDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderByDescending ( n => n - ( int ) n ) . ThenByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < bool , List < int >> IntGroupByBoolDictPrint ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Dictionary < bool , List < int >> numberGroups = numbers . GroupBy ( n => n > 4 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; numberGroups [ true ] . ForEach ( n => Console . Write ( n ) ) ; Console . WriteLine ( ) ; numberGroups [ false ] . ForEach ( n => Console . Write ( n ) ) ; return numberGroups ; }
public List < Tuple < string , DateTime >> CustomerSelectManyCustomerOrderDates ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> customerProperties = customers . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return customerProperties ; }
public List < Tuple < string , string >> CustomerCrossJoinRegionsPhone ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , string >> q = regions . Join ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c . Phone ) ) . ToList ( ) ; return q ; }
public double [ ] DoubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] sharedNumbers = numbersA . Intersect ( numbersB ) . ToArray ( ) ; return sharedNumbers ; }
public List < char > ConcatOfNameFirstChar ( ) { List < Product > products = GetProductList ( ) ; List < Customer > customers = GetCustomerList ( ) ; var productFirstChars = products . Select ( p => p . ProductName [ 0 ] ) ; var customerFirstChars = customers . Select ( c => c . CompanyName [ 0 ] ) ; List < char > allFirstChars = productFirstChars . Concat ( customerFirstChars ) . ToList ( ) ; return allFirstChars ; }
public List < string > UnionOfCategory ( ) { string [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = GetProductList ( ) ; var productCategories = products . Select ( p => p . Category ) ; List < string > uniqueCategories = productCategories . Union ( categories ) . ToList ( ) ; return uniqueCategories ; }
public double NumbersAggregateSqrtWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double aggregateSum = numbers . Aggregate ( seed , ( a , b ) => Math . Sqrt ( a * b ) ) ; return aggregateSum ; }
public List < Product > ProductOrderbyCategoryThenbyDescendingName ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderBy ( p => p . Category ) . ThenByDescending ( p => p . ProductName ) . ToList ( ) ; return sortedProducts ; }
public List < Product > ExpensiveProductOrderbyDescendingName ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . Where ( p => p . UnitPrice > 100 ) . OrderByDescending ( p => p . ProductName ) . ToList ( ) ; return sortedProducts ; }
public List < Tuple < Tuple < string , int > , string >> CustomerLeftOuterJoinRegionsWithCodeNameRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < Tuple < string , int > , string >> q = regions . GroupJoin ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. Select ( c => c . CompanyName ) . DefaultIfEmpty ( " No ▁ Customer " ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public List < int > IntSquareSkip ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > after3Numbers = numbers . Select ( i => i * i ) . Skip ( 3 ) . ToList ( ) ; return after3Numbers ; }
public Tuple < string , bool > [ ] SelectByEvenOdd ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Tuple < string , bool > [ ] evenOddWords = numbers . Select ( n => Tuple . Create ( strings [ n ] , n % 2 == 0 ) ) . ToArray ( ) ; return evenOddWords ; }
public List < Tuple < string , double >> CustomerEachCountryOrdersAverage ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersAverage = customers . GroupBy ( c => c . Country ) . Select ( g => Tuple . Create ( g . Key , g . Average ( c => c . Orders . Count ) ) ) . ToList ( ) ; return ordersAverage ; }
public List < double > DoubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public List < Tuple < Tuple < string , int > , Customer >> CustomerLeftOuterJoinRegionsWithCodeRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < Tuple < string , int > , Customer >> q = regions . GroupJoin ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. DefaultIfEmpty ( null ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public int [ ] BigIntTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = numbers . Where ( n => n > 5 ) . Select ( n => n * 2 ) . ToArray ( ) ; return numSelected ; }
public List < Tuple < string , double >> ExpensiveProductEachCategoryStock ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , double >> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Where ( p => p . UnitPrice > 100 ) . Average ( p => p . UnitsInStock ) ) ) . ToList ( ) ; return categories ; }
public List < Tuple < string , int , Customer >> CustomerCrossJoinRegionsWithCodeRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int , Customer >> q = regions . Join ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r . Item1 , r . Item2 , c ) ) . ToList ( ) ; return q ; }
public List < Tuple < string , List < Customer >>> CustomerEachCountryOrdersFirstCustomer ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , List < Customer >>> customerOrdersFirst = customers . GroupBy ( c => c . Country ) . Select ( g => Tuple . Create ( g . Key , g . Where ( c => c . Orders . Count == g . First ( ) . Orders . Count ) . ToList ( ) ) ) . ToList ( ) ; return customerOrdersFirst ; }
public double ProjectedDoubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . Select ( i => Math . Log2 ( i ) ) . FirstOrDefault ( n => n > 3 , 3.01 ) ; return firstNum ; }
public Dictionary < string , List < string >> ProductGroupNameDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < string >> productNames = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Select ( p => p . ProductName ) . ToList ( ) ) ; return productNames ; }
public List < string > StringSkipCount ( string [ ] strings , int n ) { List < string > afterNWords = strings . Skip ( n ) . ToList ( ) ; return afterNWords ; }
public Dictionary < bool , List < Product >> ProductGroupByInStockDictPrint ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < Product >> productGroup = products . GroupBy ( p => p . UnitsInStock == 0 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; productGroup [ true ] . ForEach ( p => Console . Write ( p ) ) ; Console . WriteLine ( ) ; productGroup [ false ] . ForEach ( p => Console . Write ( p ) ) ; return productGroup ; }
public Dictionary < string , double > CustomerOrdersTotalMinDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalMin = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Min ( o => o . Total ) ) ; return ordersTotalMin ; }
public List < Tuple < string , List < Product >>> ExpensiveProductEachCategoryMinUnitPriceProducts ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < Product >>> categories = products . Where ( p => p . UnitPrice > 100 ) . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Where ( p => p . UnitPrice == g . Min ( p => p . UnitPrice ) ) . ToList ( ) ) ) . ToList ( ) ; return categories ; }
public Dictionary < string , int > CustomerEachCountryOrdersSumDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > ordersTotalSum = customers . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . Sum ( c => c . Orders . Count ) ) ; return ordersTotalSum ; }
public int BigNumbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = numbers . Where ( n => n > 5 ) . Min ( ) ; return minNum ; }
public Dictionary < char , List < string >> StringGroupByFirstCharDictOrderbyDescending ( ) { string [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Dictionary < char , List < string >> wordsGroups = words . GroupBy ( w => w [ 0 ] ) . ToDictionary ( g => g . Key , g => g . OrderByDescending ( w => w ) . ToList ( ) ) ; return wordsGroups ; }
public double ProductUnitPriceAggregateAverageWithSeed ( ) { List < Product > products = GetProductList ( ) ; double seed = 15.5 ; double aggregateSum = products . Select ( p => p . UnitPrice ) . Aggregate ( seed , ( a , b ) => ( a + b ) / 2 ) ; return aggregateSum ; }
public char [ ] ProjectionStringConcat ( ) { string [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; string [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = wordsA . Select ( n => n [ 0 ] ) ; var second = wordsB . Select ( n => n [ 0 ] ) ; char [ ] words = first . Concat ( second ) . ToArray ( ) ; return words ; }
public List < Tuple < string , DateTime >> CustomerSelectManyCustomerNewOrderDates ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> customerProperties = customers . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return customerProperties ; }
public double [ ] DoubleConcat ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] allNumbers = numbersA . Concat ( numbersB ) . ToArray ( ) ; return allNumbers ; }
public List < Tuple < char , List < string >>> StringGroupByFirstCharOrderbyDescending ( ) { string [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Tuple < char , List < string >>> wordsGroups = words . GroupBy ( w => w [ 0 ] ) . Select ( g => Tuple . Create ( g . Key , g . OrderByDescending ( w => w ) . ToList ( ) ) ) . ToList ( ) ; return wordsGroups ; }
public List < string > LongStringSkip ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > after3Words = words . Where ( w => w . Length > 5 ) . Skip ( 3 ) . ToList ( ) ; return after3Words ; }
public List < int > IntTakeWhileIndexedCount ( int [ ] numbers , int n ) { List < int > firstNumbers = numbers . TakeWhile ( ( n , i ) => n > i ) . ToList ( ) ; return firstNumbers ; }
public string StringFirstOrDefaultStartWith ( char c ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string startWithChar = strings . FirstOrDefault ( s => s [ 0 ] == c , " none " ) ; return startWithChar ; }
public Dictionary < bool , List < int >> ProductGroupByPriceWithIdDictPrint ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < int >> productGroup = products . GroupBy ( p => p . UnitPrice > 100 ) . ToDictionary ( g => g . Key , g => g . Select ( p => p . ProductId ) . ToList ( ) ) ; productGroup [ true ] . ForEach ( p => Console . Write ( p ) ) ; Console . WriteLine ( ) ; productGroup [ false ] . ForEach ( p => Console . Write ( p ) ) ; return productGroup ; }
public List < string > ShortStringOrderby ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < string > sortedWords = words . Where ( w => w . Length < 6 ) . OrderBy ( w => w ) . ToList ( ) ; return sortedWords ; }
public bool [ ] BigIntWithOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool [ ] numSelected = numbers . Select ( ( n , i ) => Tuple . Create ( n > 5 , n == i ) ) . Where ( t => t . Item1 ) . Select ( t => t . Item2 ) . ToArray ( ) ; return numSelected ; }
public int NumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = numbers . FirstOrDefault ( - 1 ) ; return firstNum ; }
public int ShortStringMinLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; int minLength = words . Where ( w => w . Length < 7 ) . Min ( w => w . Length ) ; return minLength ; }
public List < double > IntSqrtSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < double > afterNumbers = numbers . Select ( i => Math . Sqrt ( i ) ) . TakeWhile ( ( n , i ) => n > i ) . ToList ( ) ; return afterNumbers ; }
public List < string > LongStringSkipWhile ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > afterWordsWhile = words . Where ( w => w . Length > 5 ) . SkipWhile ( w => w [ 0 ] > ' b ' ) . ToList ( ) ; return afterWordsWhile ; }
public Dictionary < string , List < string >> ProductGroupJoinCategoriesName ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; Dictionary < string , List < string >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p . Select ( p1 => p1. ProductName ) . ToList ( ) ) ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; return q ; }
public bool IntSquareAllMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool allMatch = numbers . Select ( i => i * i ) . All ( n => n > 3 ) ; return allMatch ; }
public Product [ ] ProductsConvertToDescendingArrayAndPrint ( ) { List < Product > products = GetProductList ( ) ; Product [ ] productsArray = products . OrderByDescending ( p => p . UnitPrice ) . ToArray ( ) ; for ( int i = 0 ; i < productsArray . Length ; i ++ ) Console . WriteLine ( productsArray [ i ] ) ; return productsArray ; }
public List < Tuple < string , DateTime >> CustomerOrdersEachNestedSkipWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> afterOrdersEachWhile = customers . SelectMany ( c => c . Orders . SkipWhile ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return afterOrdersEachWhile ; }
public List < bool > WaCustomerOrdersEachNestedAllMatch ( ) { List < Customer > customers = GetCustomerList ( ) ; List < bool > allMatch = customers . Where ( c => c . Region == " WA " ) . Select ( c => c . Orders . All ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) ) . ToList ( ) ; return allMatch ; }
public Dictionary < string , List < Order >> CustomerEachRegionOrdersTotalMaxCustomerDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < Order >> customerOrdersTotalMax = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . SelectMany ( c => c . Orders ) . Where ( o => o . Total == g . SelectMany ( c => c . Orders ) . Max ( o => o . Total ) ) . ToList ( ) ) ; return customerOrdersTotalMax ; }
public double DoubleSum ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numbersSum = numbers . Sum ( ) ; return numbersSum ; }
public string [ ] StringProjectionZipAdd ( ) { string [ ] wordsA = { " Alpha " , " Beta " , " Gamma " } ; string [ ] wordsB = { " red " , " green " , " blue " } ; string [ ] results = wordsA . Select ( w => w [ 0 ] . ToString ( ) ) . Zip ( wordsB . Select ( w => w [ 0 ] ) , ( a , b ) => a + b ) . ToArray ( ) ; return results ; }
public Dictionary < string , List < Product >> ProductGroupSkipWhile ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> afterGroupsWhile = products . GroupBy ( p => p . Category ) . SkipWhile ( g => g . Key . Length > 6 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return afterGroupsWhile ; }
public List < Tuple < string , List < string >>> ProductGroupName ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < string >>> productNames = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Select ( p => p . ProductName ) . ToList ( ) ) ) . ToList ( ) ; return productNames ; }
public List < Tuple < int , string >> CustomerCrossGroupJoinRegionsWithCodeName ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < int , string >> q = regions . GroupJoin ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r . Item2 , c ) ) . SelectMany ( t => t . Item2. Select ( c => c . CompanyName ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public Dictionary < string , List < Product >> ProductsConvertGroupingToDictionary ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> catagory = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return catagory ; }
public List < Product > RepeatedProductsWithBaseAndCount ( Product product , int count ) { List < Product > products = Enumerable . Repeat ( product , count ) . ToList ( ) ; return products ; }
public List < int > IntsConvertToList ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < int > intsList = ints . OrderBy ( d => d ) . ToList ( ) ; return intsList ; }
public List < Tuple < char , List < string >>> StringGroupByFirstCharOrderbyCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Tuple < char , List < string >>> wordsGroups = words . GroupBy ( w => char . ToLower ( w [ 0 ] ) ) . Select ( g => Tuple . Create ( g . Key , g . OrderBy ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ) ) . ToList ( ) ; return wordsGroups ; }
public List < Tuple < string , Customer >> CustomerCrossJoinRegions ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Customer >> q = regions . Join ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . ToList ( ) ; return q ; }
public double BigNumbersAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = numbers . Where ( n => n > 2 ) . Aggregate ( ( a , b ) => a * b ) ; return product ; }
public string StringElementAtStartWithO ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string startWithO = strings . Where ( s => s [ 0 ] == ' o ' ) . ElementAt ( 0 ) ; return startWithO ; }
public int AggregateWithdrawMoney ( ) { int [ ] attemptedWithdrawals = { 100 , 20 , 10 , 40 , 50 , 10 , 70 , 30 } ; int endBalance = attemptedWithdrawals . Aggregate ( ( balance , nextWithdrawal ) => nextWithdrawal <= balance ? balance - nextWithdrawal : balance ) ; return 0 ; }
public int [ ] IntZipSub ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int [ ] subNumbers = numbersA . Zip ( numbersB , ( a , b ) => a - b ) . ToArray ( ) ; return subNumbers ; }
public List < int > IntSkipWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > afterNumbers = numbers . SkipWhile ( ( n , i ) => n > i ) . ToList ( ) ; return afterNumbers ; }
public List < string > LongStringTakeWhile ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > firstWordsWhile = words . Where ( w => w . Length > 5 ) . TakeWhile ( w => w [ 0 ] > ' b ' ) . ToList ( ) ; return firstWordsWhile ; }
public string StringElementAtStartWith ( char c ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string startWithChar = strings . Where ( s => s [ 0 ] == c ) . ElementAt ( 2 ) ; return startWithChar ; }
public Dictionary < string , List < Customer >> CustomerEachRegionOrdersMaxCustomerDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < Customer >> customerOrdersMax = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . Where ( c => c . Orders . Count == g . Max ( c => c . Orders . Count ) ) . ToList ( ) ) ; return customerOrdersMax ; }
public bool StringLengthAnyMatch ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; bool anyMatch = words . Select ( w => w . Length ) . Any ( n => n > 5 ) ; return anyMatch ; }
public List < string > StringOrderbyDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < string > sortedWords = words . OrderByDescending ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public string StringFirstOrDefaultLong ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string startsWithO = strings . FirstOrDefault ( s => s . Length > 4 , " empty " ) ; return startsWithO ; }
public bool ProjectionEqualInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 6 , 10 } ; bool equal = numbersA . Select ( n => n + 1 ) . SequenceEqual ( numbersB ) ; return equal ; }
public Dictionary < bool , List < string >> StringGroupByLengthDict ( ) { string [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Dictionary < bool , List < string >> wordsGroups = words . GroupBy ( w => w . Length > 8 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return wordsGroups ; }
public List < double > DoubleOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public string [ ] SelectByStringAndLengthConcat ( ) { string [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; string [ ] upperLowerWords = words . Select ( w => w + w . Length ) . ToArray ( ) ; return upperLowerWords ; }
public List < Tuple < string , int >> CustomerEachRegionOrdersMin ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int >> ordersMin = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . Min ( c => c . Orders . Count ) ) ) . ToList ( ) ; return ordersMin ; }
public double ProjectedDoubleFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . Select ( i => Math . Log ( i ) ) . First ( n => n > 3 ) ; return firstNum ; }
public double ExpensiveProductUnitPriceMin ( ) { List < Product > products = GetProductList ( ) ; double minUnitPrice = products . Where ( p => p . UnitPrice > 100 ) . Min ( p => p . UnitPrice ) ; return minUnitPrice ; }
public List < string > StringOrderbyCustomThenbyLengthDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < string > sortedWords = words . OrderBy ( w => w , new CaseInsensitiveComparer ( ) ) . ThenByDescending ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public int [ ] ProjectionIntUnion ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = numbersA . Select ( n => n + 1 ) ; var second = numbersB . Select ( n => n - 1 ) ; int [ ] numbers = first . Union ( second ) . ToArray ( ) ; return numbers ; }
public string [ ] StringExcept ( ) { string [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; string [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; string [ ] differentWords = wordsA . Except ( wordsB ) . ToArray ( ) ; return differentWords ; }
public Dictionary < char , List < string >> StringGroupByFirstCharDictOrderbyCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Dictionary < char , List < string >> wordsGroups = words . GroupBy ( w => char . ToLower ( w [ 0 ] ) ) . ToDictionary ( g => g . Key , g => g . OrderBy ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ) ; return wordsGroups ; }
public Dictionary < string , int > ExpensiveProductEachCategoryStockDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , int > categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice > 100 ) . Max ( p => p . UnitsInStock ) ) ; return categories ; }
public Dictionary < string , List < Product >> ProductEachCategoryFirstUnitPriceProductsDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice == g . First ( ) . UnitPrice ) . ToList ( ) ) ; return categories ; }
public List < string > StringOrderbyLengthReverse ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . OrderBy ( w => w . Length ) . Reverse ( ) . ToList ( ) ; return sortedWords ; }
public int OddNumbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = numbers . Where ( n => n % 2 == 1 ) . Max ( n => n * 2 ) ; return maxNum ; }
public List < Product > ProductOrderbyId ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderBy ( p => p . ProductId ) . ToList ( ) ; return sortedProducts ; }
public bool ExpensiveProductAllMatch ( ) { List < Product > products = GetProductList ( ) ; bool allMatch = products . Where ( p => p . UnitPrice > 100 ) . All ( p => p . UnitsInStock > 0 ) ; return allMatch ; }
public List < Product > ExpensiveProductOrderbyId ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . Where ( p => p . UnitPrice > 100 ) . OrderBy ( p => p . ProductId ) . ToList ( ) ; return sortedProducts ; }
public double ShortStringAverageLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; double averageLength = words . Where ( w => w . Length < 7 ) . Average ( w => w . Length ) ; return averageLength ; }
public int OddNumbersMax ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = numbers . Where ( n => n % 2 == 1 ) . Max ( ) ; return maxNum ; }
public List < double > ExpensiveProductUnitPrice ( ) { List < Product > products = GetProductList ( ) ; List < double > productNames = products . Where ( p => p . UnitPrice > 100 ) . Select ( p => p . UnitPrice ) . ToList ( ) ; return productNames ; }
public double [ ] ProjectionDoubleExcept ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = numbersA . Select ( n => n - ( int ) n ) ; var second = numbersB . Select ( n => n - ( int ) n ) ; double [ ] numbers = first . Except ( second ) . ToArray ( ) ; return numbers ; }
public List < Tuple < string , string >> ProductCrossGroupJoinCategoriesName ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , string >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . SelectMany ( t => t . Item2. Select ( p => p . ProductName ) , ( t , n ) => Tuple . Create ( t . Item1 , n ) ) . ToList ( ) ; return q ; }
public Dictionary < bool , List < Product >> ProductGroupByPriceDictPrint ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < Product >> productGroup = products . GroupBy ( p => p . UnitPrice > 100 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; productGroup [ true ] . ForEach ( p => Console . Write ( p ) ) ; Console . WriteLine ( ) ; productGroup [ false ] . ForEach ( p => Console . Write ( p ) ) ; return productGroup ; }
public int [ ] IntsConvertToArrayAndPrintForeach ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; int [ ] intsArray = ints . OrderBy ( d => d ) . ToArray ( ) ; foreach ( int i in intsArray ) Console . WriteLine ( i ) ; return intsArray ; }
public List < Product > InStockProductSkipWhile ( ) { List < Product > products = GetProductList ( ) ; List < Product > afterProductsWhile = products . Where ( p => p . UnitsInStock > 0 ) . SkipWhile ( p => p . ProductId > 100 ) . ToList ( ) ; return afterProductsWhile ; }
public int OddNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = numbers . First ( n => n % 2 == 1 ) ; return firstNum ; }
public int TotalOrdersCount ( string region ) { List < Customer > customers = GetCustomerList ( ) ; int count = customers . SelectMany ( c => c . Orders ) . Count ( ) ; return count ; }
public Dictionary < char , List < string >> StringGroupByFirstCharDict ( ) { string [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Dictionary < char , List < string >> wordsGroups = words . GroupBy ( w => w [ 0 ] ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return wordsGroups ; }
public List < string > StringReverse ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . Reverse ( ) . ToList ( ) ; return sortedWords ; }
public Dictionary < string , int > CustomerEachCountryOrdersMaxDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > ordersMax = customers . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . Max ( c => c . Orders . Count ) ) ; return ordersMax ; }
public double BigNumbersAverage ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = numbers . Where ( n => n > 5 ) . Average ( ) ; return averageNum ; }
public void OddNumbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int i = 0 ; var q = numbers . Where ( n => n % 2 == 1 ) . Select ( n => n * 2 ) . Select ( n => i += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public Dictionary < int , bool > RangeOfIntsToDict ( ) { Dictionary < int , bool > numbers = Enumerable . Range ( 0 , 100 ) . ToDictionary ( n => n , n => n % 2 == 0 ) ; return numbers ; }
public List < int > IntsConvertToDescendingListAndPrint ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < int > intsList = ints . OrderByDescending ( d => d ) . ToList ( ) ; for ( int i = 0 ; i < intsList . Count ; i ++ ) Console . WriteLine ( intsList [ i ] ) ; return intsList ; }
public Dictionary < string , List < Customer >> CustomerEachCountryOrdersFirstCustomerDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < Customer >> customerOrdersFirst = customers . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . Where ( c => c . Orders . Count == g . First ( ) . Orders . Count ) . ToList ( ) ) ; return customerOrdersFirst ; }
public List < Tuple < string , double >> CustomerEachRegionOrdersTotalMax ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalMax = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . SelectMany ( c => c . Orders ) . Max ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalMax ; }
public List < double > BigDoubleFractionOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 5 ) . Select ( n => n - ( int ) n ) . OrderByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < bool , List < Product >> ProductGroupByInStockDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < Product >> productGroup = products . GroupBy ( p => p . UnitsInStock == 0 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return productGroup ; }
public int UniqueFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int uniqueFactorsCount = factorsOf300. Distinct ( ) . Count ( ) ; return uniqueFactorsCount ; }
public bool LongStringAllMatch ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; bool allMatch = words . Where ( w => w . Length > 5 ) . All ( n => string . CompareOrdinal ( n , " b " ) > 0 ) ; return allMatch ; }
public List < Product > ProductTakeWhile ( ) { List < Product > products = GetProductList ( ) ; List < Product > firstProductsWhile = products . TakeWhile ( p => p . ProductId > 100 ) . ToList ( ) ; return firstProductsWhile ; }
public int OddNumbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = numbers . Where ( n => n % 2 == 1 ) . Min ( n => n * 2 ) ; return minNum ; }
public void BigDoubleNumbersDeferred ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double d = 0 ; var q = numbers . Where ( d => d > 5 ) . Select ( n => d += n ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + d ) ; }
public List < Tuple < string , DateTime >> WaCustomerOrdersEachNestedTakeWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> firstOrdersEachWhile = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders . TakeWhile ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return firstOrdersEachWhile ; }
public Dictionary < string , int > ExpensiveProductEachCategoryStockDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , int > categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice > 100 ) . Sum ( p => p . UnitsInStock ) ) ; return categories ; }
public List < string > StringOrderbyThenbyLengthDescendingCustom ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > sortedWords = words . OrderBy ( w => w ) . ThenByDescending ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public double BigDoubleNumbersFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . FirstOrDefault ( d => d > 5 , - 2.3 ) ; return firstNum ; }
public Dictionary < string , double > CustomerInRegionOrdersTotalSumDict ( string region ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalSum = customers . Where ( c => c . Region . Equals ( region ) ) . ToDictionary ( c => c . CustomerId , c => c . Orders . Sum ( o => o . Total ) ) ; return ordersTotalSum ; }
public List < double > DoubleOrderbyFractionDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderByDescending ( n => n - ( int ) n ) . ThenBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < string , List < Product >> ProductGroupSkip ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> after3Groups = products . GroupBy ( p => p . Category ) . Skip ( 3 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return after3Groups ; }
public Dictionary < bool , List < Product >> ProductGroupByPriceDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < Product >> productGroup = products . GroupBy ( p => p . UnitPrice > 100 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return productGroup ; }
public int NumbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = numbers . Min ( ) ; return minNum ; }
public List < string > ExpensiveProductNameOrderby ( ) { List < Product > products = GetProductList ( ) ; List < string > sortedProducts = products . Where ( p => p . UnitPrice > 100 ) . Select ( p => p . ProductName ) . OrderBy ( n => n ) . ToList ( ) ; return sortedProducts ; }
public bool ProjectionEqualDoubles ( ) { double [ ] numbersA = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; double [ ] numbersB = { 6.5 , 1.3 , 8.7 , 2.4 , 4.8 } ; bool equal = numbersA . Select ( n => n - ( int ) n ) . SequenceEqual ( numbersB . Select ( n => n - ( int ) n ) ) ; return equal ; }
public List < Product > ProductOrderbyCategoryThenbyDescendingId ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderBy ( p => p . Category ) . ThenByDescending ( p => p . ProductId ) . ToList ( ) ; return sortedProducts ; }
public List < string > ShortStringOrderbyCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < string > sortedWords = words . Where ( w => w . Length < 6 ) . OrderBy ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public List < Product > ProductOrderbyName ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderBy ( p => p . ProductName ) . ToList ( ) ; return sortedProducts ; }
public List < Product > ProductOrderbyCategoryThenbyName ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderBy ( p => p . Category ) . ThenBy ( p => p . ProductName ) . ToList ( ) ; return sortedProducts ; }
public bool ProjectionEqualStrings ( ) { List < string > wordsA = new List < string > { " Alpha " , " Beta " , " Gamma " } ; List < string > wordsB = new List < string > { " aLPhA " , " bETa " , " gAaMa " } ; bool equal = wordsA . Select ( w => w . ToLower ( ) ) . SequenceEqual ( wordsB . Select ( w => w . ToLower ( ) ) ) ; return equal ; }
public List < Order > CustomerSelectManyBigOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Order > customerProperties = customers . SelectMany ( c => c . Orders . Where ( o => o . Total > 100 ) ) . ToList ( ) ; return customerProperties ; }
