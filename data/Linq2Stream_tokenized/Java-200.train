public List < Pair < String , Double >> customerInRegionOrdersTotalAverage ( String region ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalAverage = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalAverage ; }
public List < Triplet < String , Integer , Integer >> customerSelectManyCustomerOrderDateYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Integer >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderDate ( ) . getYear ( ) , o . getOrderDate ( ) . getMonthValue ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , Product >> productLeftOuterJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Product >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBoolOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Pair < Boolean , List < Double >>> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ) ) . toList ( ) ; return numbersGroups ; }
public List < Pair < String , List < Customer >>> customerEachCountryOrdersMinCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersMin ; }
public Map < String , List < Product >> productEachGroupTakeWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ) ) ; return after3EachGroups ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDictOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Map < Boolean , List < Double >> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( ) . toList ( ) ) ) ; return numbersGroups ; }
public List < Double > bigDoubleOrderbyFractionDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public double [ ] doublesConvertToDescendingArray ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . mapToDouble ( d -> d ) . toArray ( ) ; return doublesArray ; }
public double [ ] convertSelectedDoubleItemToArrayAndPrint ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; double [ ] doubles = Arrays . stream ( numbers ) . filter ( o -> o instanceof Double ) . mapToDouble ( d -> ( double ) d ) . toArray ( ) ; for ( int i = 0 ; i < doubles . length ; i ++ ) System . out . println ( doubles [ i ] ) ; return doubles ; }
public Map < String , Integer > customerDistinctOrdersCountDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > orderCounts = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> ( int ) c . getOrders ( ) . stream ( ) . distinct ( ) . count ( ) ) ) ; return orderCounts ; }
public List < Customer > repeatedCustomers ( ) { List < Customer > customers = Collections . nCopies ( 5 , Customer . DEFAULT ) ; return customers ; }
public int [ ] bigIntAddIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] bigNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . toArray ( ) ; int [ ] numSelected = IntStream . range ( 0 , bigNumbers . length ) . map ( i -> bigNumbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public List < Product > expensiveProductSkipWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public int numbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . sum ( ) ; return numbersSum ; }
public int intDotProduct ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int dotProduct = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] * numbersB [ i ] ) . sum ( ) ; return dotProduct ; }
public boolean customerOrdersNestedAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean anyMatch = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . anyMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return anyMatch ; }
public List < String > indexedSelectManyString ( ) { List < Customer > customers = getCustomerList ( ) ; List < String > customerOrders = IntStream . range ( 0 , customers . size ( ) ) . boxed ( ) . flatMap ( i -> customers . get ( i ) . getOrders ( ) . stream ( ) . map ( o -> " Customer ▁ # " + ( i + 1 ) + " ▁ has ▁ an ▁ order ▁ with ▁ OrderID ▁ " + o . getOrderId ( ) ) ) . collect ( Collectors . toList ( ) ) ; return customerOrders ; }
public double [ ] doubleUnion ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] uniqueNumbers = DoubleStream . concat ( Arrays . stream ( numbersA ) , Arrays . stream ( numbersB ) ) . distinct ( ) . toArray ( ) ; return uniqueNumbers ; }
public Map < Pair < String , Integer > , List < Customer >> customerGroupJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Pair < String , Integer > , List < Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Integer > intTake ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . limit ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Pair < String , Order >> customerIdAndFirstOrDefaultOrder ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . findFirst ( ) . orElse ( Order . DEFAULT ) ) ) . toList ( ) ; return customerProperties ; }
public int [ ] intUnion ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; int [ ] uniqueNumbers = IntStream . concat ( Arrays . stream ( numbersA ) , Arrays . stream ( numbersB ) ) . distinct ( ) . toArray ( ) ; return uniqueNumbers ; }
public List < Pair < String , List < Product >>> productEachCategoryMaxUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public List < Integer > shortStringLengthOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < Integer > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . map ( w -> w . length ( ) ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public List < String > stringTakeCount ( int n ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNWords = Arrays . stream ( words ) . limit ( 3 ) . toList ( ) ; return afterNWords ; }
public boolean oddIntAnyMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean anyMatch = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . anyMatch ( n -> n > 3 ) ; return anyMatch ; }
public boolean unequalInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 6 , 10 } ; boolean equal = Arrays . equals ( numbersA , numbersB ) ; return equal ; }
public List < String > stringOrderbyCustomThenbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w , new CaseInsensitiveComparer ( ) ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyDescendingLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedWords ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderby ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Pair < String , List < Product >>> expensiveProductEachCategoryMaxUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public List < Double > bigDoubleOrderbyModDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Integer > repeatedIntsWithValue ( int value ) { List < Integer > numbers = Collections . nCopies ( 10 , value ) ; return numbers ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBoolOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Pair < Boolean , List < Double >>> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) . toList ( ) ; return numbersGroups ; }
public List < String > stringOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < Product > productSkipWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public List < Pair < String , LocalDate >> waCustomerOrdersEachNestedSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachWAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . dropWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachWAOrders ; }
public Map < String , Map < String , Map < String , Customer >>> customerNestedGroupByRegionAndCountryAndName ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , Map < String , Customer >>> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g1 -> g1. getKey ( ) , g1 -> g1. getValue ( ) . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c ) ) ) ) ) ) ; return customerGroups ; }
public List < String > intersectOfName ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) ; var customerNames = customers . stream ( ) . map ( c -> c . getCompanyName ( ) ) ; List < String > sharedNames = productNames . distinct ( ) . filter ( a -> customerNames . anyMatch ( b -> b . equals ( a ) ) ) . toList ( ) ; return sharedNames ; }
public void shortStringLengthEager ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . map ( w -> w . length ( ) ) . map ( n -> i . addAndGet ( n ) ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public boolean productAllMatch ( ) { List < Product > products = getProductList ( ) ; boolean allMatch = products . stream ( ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return allMatch ; }
public double numbersAggregateFindMax ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( ( a , b ) -> Math . max ( a , b ) ) . getAsDouble ( ) ; return aggregateSum ; }
public int bigNumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . sum ( ) ; return numbersSum ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public double bigDoubleNumbersMax ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double maxNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . max ( ) . getAsDouble ( ) ; return maxNum ; }
public Map < Boolean , Integer > countExpensiveProductByInStockDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , Integer > inStockCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) == 0 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . count ( ) ) ) ; return inStockCounts ; }
public List < Integer > repeatedInts ( ) { List < Integer > numbers = Collections . nCopies ( 50 , 0 ) ; return numbers ; }
public Map < String , Map < String , Map < String , Customer >>> customerNestedGroupByRegionAndCountryAndNamePrint ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , Map < String , Customer >>> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g1 -> g1. getKey ( ) , g1 -> g1. getValue ( ) . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c ) ) ) ) ) ) ; for ( var e1 : customerGroups . entrySet ( ) ) { System . out . println ( e1. getKey ( ) + " : " ) ; for ( var e2 : e1. getValue ( ) . entrySet ( ) ) { System . out . println ( " \ t " + e2. getKey ( ) + " : " ) ; for ( var e3 : e2. getValue ( ) . entrySet ( ) ) System . out . println ( " \ t \ t " + e3. getKey ( ) + " : " + e3. getValue ( ) ) ; } } return customerGroups ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . dropWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3WAOrders ; }
public double bigDoubleNumbersElementAt ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numAt = Arrays . stream ( numbers ) . filter ( d -> d > 5 ) . skip ( 1 ) . findFirst ( ) . getAsDouble ( ) ; return numAt ; }
public Map < String , Integer > productEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ) ) ; return categories ; }
public void bigDoubleNumbersEager ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; AtomicReference < Double > d = new AtomicReference <> ( 0.0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> d . accumulateAndGet ( n , Double :: sum ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + d ) ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public Map < String , Double > customerExpensiveOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < String > shortStringReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public int customerInRegionCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . count ( ) ; return count ; }
public List < Character > unionOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > uniqueFirstChars = Stream . concat ( productFirstChars , customerFirstChars ) . distinct ( ) . toList ( ) ; return uniqueFirstChars ; }
public List < Pair < String , Product >> productCrossGroupJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Product >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . takeWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3WAOrders ; }
public List < String > stringSkipWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNNumbers = Arrays . stream ( words ) . dropWhile ( w -> w . charAt ( 0 ) > ' b ' ) . toList ( ) ; return afterNNumbers ; }
public Map < String , Integer > customerEachCountryOrdersMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) ; return ordersMin ; }
public double stringAverageLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; double averageLength = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . average ( ) . getAsDouble ( ) ; return averageLength ; }
public List < Pair < String , Integer >> productEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ) ) . toList ( ) ; return categories ; }
public Map < Integer , List < Customer >> customerGroupJoinRegionsWithCode ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Integer , List < Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Pair < Boolean , List < Integer >>> productGroupByInStockWithId ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Integer >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) . toList ( ) ; return productGroup ; }
public int productLongNameLengthSum ( ) { List < Product > products = getProductList ( ) ; int totalSum = products . stream ( ) . map ( p -> p . getProductName ( ) ) . filter ( name -> name . length ( ) > 7 ) . mapToInt ( name -> name . length ( ) ) . sum ( ) ; return totalSum ; }
public void bigNumbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public List < String > stringOrderbyLengthThenbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) ) . thenComparing ( new CaseInsensitiveComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > outOfStockProductName ( ) { List < Product > products = getProductList ( ) ; List < String > productNames = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) == 0 ) . map ( p -> p . getProductName ( ) ) . toList ( ) ; return productNames ; }
public int stringSumLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int totalChars = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . sum ( ) ; return totalChars ; }
public boolean expensiveProductAnyMatch ( ) { List < Product > products = getProductList ( ) ; boolean anyMatch = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return anyMatch ; }
public List < String > longStringOrginalIndexedWhere ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > q = IntStream . range ( 0 , words . length ) . filter ( i -> words [ i ] . length ( ) < i * 3 && words [ i ] . length ( ) > 5 ) . mapToObj ( i -> words [ i ] ) . toList ( ) ; return q ; }
public Map < String , List < String >> customerGroupJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; Map < String , List < String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> c . getPhone ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Pair < String , Double >> customerExpensiveOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public int numbersMax ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public int [ ] intAddIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = IntStream . range ( 0 , numbers . length ) . map ( i -> numbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public boolean stringAnyMatchCount ( String [ ] strings , char c ) { boolean anyMatch = Arrays . stream ( strings ) . anyMatch ( w -> w . charAt ( 0 ) > c ) ; return anyMatch ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMin ; }
public double numbersDoubledAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public String [ ] transformIndexHashToString ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String [ ] textNums = ( String [ ] ) Arrays . stream ( numbers ) . mapToObj ( n -> numbers [ n * 97 % 10 ] ) . toArray ( ) ; return textNums ; }
public Map < String , List < Product >> expensiveProductEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public List < Pair < Boolean , Integer >> countExpensiveProductByInStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , Integer >> inStockCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) == 0 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . count ( ) ) ) . toList ( ) ; return inStockCounts ; }
public int distinctOrdersCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . distinct ( ) . count ( ) ; return count ; }
public boolean customerOrdersAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean anyMatch = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . anyMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return anyMatch ; }
public List < Integer > intSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . dropWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Pair < String , String >> customerCrossGroupJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public List < String > stringOrderbyReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public List < Pair < String , String >> customerRegionAndCountry ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getRegion ( ) , c . getCountry ( ) ) ) . toList ( ) ; return customerProperties ; }
public boolean categoryProductAllMatch ( ) { List < Product > products = getProductList ( ) ; boolean allMatch = products . stream ( ) . filter ( p -> p . getCategory ( ) == " Beverages " ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return allMatch ; }
public List < Integer > stringLengthSkip ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < Integer > after3Words = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . skip ( 3 ) . toList ( ) ; return after3Words ; }
public List < Pair < Boolean , List < String >>> stringGroupByLengthOrderbyDescendingLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public double numbersAverage ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public List < Order > customerOrdersSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . dropWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public List < Pair < String , List < Customer >>> customerEachRegionOrdersMinCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersMin ; }
public List < Pair < String , List < Product >>> productEachCategoryMinUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public double expensiveProductStockAverage ( ) { List < Product > products = getProductList ( ) ; double averageUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ; return averageUnitPrice ; }
public double oddNumbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . map ( n -> n * 2 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public List < String > productNameOrderbyDescending ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . map ( p -> p . getProductName ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedProducts ; }
public int [ ] oddIntAddOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] % 2 == 1 ) . map ( i -> numbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public List < Integer > oddIntIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] oddNumbers = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . toArray ( ) ; List < Integer > q = IntStream . range ( 0 , oddNumbers . length ) . filter ( i -> oddNumbers [ i ] < i ) . map ( i -> oddNumbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public List < Integer > oddIntSkip ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . skip ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Order > waCustomerIndexedSelectManyOrdersTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = IntStream . range ( 0 , customers . size ( ) ) . boxed ( ) . filter ( i -> customers . get ( i ) . getRegion ( ) . equals ( " WA " ) ) . flatMap ( i -> customers . get ( i ) . getOrders ( ) . stream ( ) . limit ( i < 10 ? 5 : 1 ) ) . toList ( ) ; return customerProperties ; }
public List < Double > doubleFractionOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public void numbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public List < Triplet < String , Integer , Integer >> customerSelectManyCustomerNewOrderDateYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Integer >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderDate ( ) . getYear ( ) , o . getOrderDate ( ) . getMonthValue ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Product > productsConvertToDescendingListAndPrintForeach ( ) { List < Product > products = getProductList ( ) ; List < Product > productsList = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; for ( Product p : productsList ) System . out . println ( p ) ; return productsList ; }
public List < Integer > oddIntTake ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . limit ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Pair < String , Order >> customerSelectManyCustomerNewOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o ) ) ) . toList ( ) ; return customerProperties ; }
public List < Integer > stringLengthOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < String , List < Customer >>> customerEachCountryOrdersFirstOrDefaultCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersFirstOrDefault = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Customer . DEFAULT ) . getOrders ( ) . size ( ) ) . toList ( ) ) ) . toList ( ) ; return customerOrdersFirstOrDefault ; }
public List < Integer > intSkipWhileIndexedCount ( int [ ] numbers , int n ) { List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Integer > stringLengthOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . sorted ( new CustomNumberComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < String , Double >> customerExpensiveOrdersTotalMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMin = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMin ; }
public double productUnitPriceMax ( ) { List < Product > products = getProductList ( ) ; double maxUnitPrice = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . max ( ) . getAsDouble ( ) ; return maxUnitPrice ; }
public String [ ] stringZipAdd ( ) { String [ ] wordsA = { " Alpha " , " Beta " , " Gamma " } ; String [ ] wordsB = { " red " , " green " , " blue " } ; int length = wordsA . length ; String [ ] results = ( String [ ] ) IntStream . range ( 0 , length ) . mapToObj ( i -> wordsA [ i ] + wordsB [ i ] ) . toArray ( ) ; return results ; }
public List < Product > productOrderbyCategoryThenbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) ) ) . toList ( ) ; return sortedProducts ; }
public int newOrdersCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . count ( ) ; return count ; }
public int bigNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . findFirst ( ) . orElse ( 0 ) ; return firstNum ; }
public List < Pair < String , Double >> customerExpensiveOrdersTotalAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalAverage = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalAverage ; }
public Map < String , List < Order >> customerEachRegionOrdersTotalMinCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Order >> customerOrdersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersTotalMin ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderby ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public Map < String , Double > customerEachRegionOrdersAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersAverage ; }
public Map < Boolean , List < Integer >> intGroupByBoolDict ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Map < Boolean , List < Integer >> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 4 ) ) ; return numberGroups ; }
public Map < String , Map < Integer , Map < Integer , List < Order >>>> customerNestedGroupByNameAndOrderYearAndMonthPrint ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < Integer , Map < Integer , List < Order >>>> customerOrderGroups = customers . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c . getOrders ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ) ) ; for ( var e1 : customerOrderGroups . entrySet ( ) ) { System . out . println ( e1. getKey ( ) + " : " ) ; for ( var e2 : e1. getValue ( ) . entrySet ( ) ) { System . out . println ( " \ t " + e2. getKey ( ) + " : " ) ; for ( var e3 : e2. getValue ( ) . entrySet ( ) ) { System . out . println ( " \ t \ t " + e3. getKey ( ) + " : " ) ; e3. getValue ( ) . forEach ( o -> System . out . println ( " \ t \ t \ t " + o ) ) ; } } } return customerOrderGroups ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBool ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; List < Pair < Boolean , List < Double >>> numberGroups = numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 3 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public List < Triplet < String , Integer , Integer >> waCustomerSelectManyCustomerNewOrderDateYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Integer >> customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderDate ( ) . getYear ( ) , o . getOrderDate ( ) . getMonthValue ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < Integer , String >> customerLeftOuterJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , String >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getCompanyName ( ) : " No ▁ Customer " ) ) ) . toList ( ) ; return q ; }
public boolean waCustomerOrdersNestedAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean allMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . allMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return allMatch ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBoolOrderbyDescendingFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Pair < Boolean , List < Double >>> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) . toList ( ) ; return numbersGroups ; }
public Map < String , Double > customerInRegionOrdersTotalMaxDict ( String region ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public int oddNumbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public List < String > stringOrderbyLengthCustomThenbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) , new CustomNumberComparer ( ) ) . thenComparing ( new CaseInsensitiveComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public Map < String , Integer > convertSelectedTupleToDictionary ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; Map < String , Integer > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . collect ( toMap ( p -> p . getValue0 ( ) , p -> p . getValue1 ( ) ) ) ; return strings ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . limit ( 3 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public List < String > concatOfCategory ( ) { String [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = getProductList ( ) ; var productCategories = products . stream ( ) . map ( p -> p . getCategory ( ) ) ; List < String > allCategories = Stream . concat ( productCategories , Arrays . stream ( categories ) ) . toList ( ) ; return allCategories ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyName ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public List < Integer > rangeOfSquareIntsStartFrom ( int start , int count ) { List < Integer > numbers = IntStream . range ( start , start + count ) . map ( n -> n * n ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Triplet < String , String , String >> customerCityAndAddressAndPostal ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , String , String >> customerProperties = customers . stream ( ) . map ( c -> Triplet . with ( c . getCity ( ) , c . getAddress ( ) , c . getPostalCode ( ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , Map < String , List < Customer >>> customerNestedGroupByRegionAndCountry ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , List < Customer >>> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) ) ) ; return customerGroups ; }
public Map < String , List < Product >> productGroupByCategoryDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> category = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) ; return category ; }
public List < Pair < String , Double >> customerOrdersTotalMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public void doubleDeferred ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; AtomicReference < Double > d = new AtomicReference <> ( 0.0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> d . accumulateAndGet ( n , Double :: sum ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + d ) ) ; }
public Map < String , Integer > expensiveProductEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ) ) ; return categories ; }
public Map < String , Double > customerEachRegionOrdersTotalAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersTotalAverage ; }
public List < Product > inStockProductTake ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . limit ( 3 ) . toList ( ) ; return after3Products ; }
public List < Pair < String , Integer >> customerEachCountryOrdersMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . max ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMax ; }
public List < Integer > repeatedIntsWithValueAndCount ( int value , int count ) { List < Integer > numbers = Collections . nCopies ( count , value ) ; return numbers ; }
public List < Integer > intsConvertToListAndPrintForeach ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < Integer > intsList = Arrays . stream ( ints ) . boxed ( ) . sorted ( ) . toList ( ) ; for ( int i : intsList ) System . out . println ( i ) ; return intsList ; }
public int projectedBigNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . map ( i -> ( int ) Math . pow ( 2 , i ) ) . filter ( n -> n > 100 ) . findFirst ( ) . orElse ( 100 ) ; return firstNum ; }
public List < Integer > stringLengthOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public List < Product > productOrderbyCategoryThenbyIdCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedProducts ; }
public double bigDoubleNumbersAverage ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public void bigNumbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public List < Integer > intSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] * numbers [ i ] < i ) . map ( i -> numbers [ i ] * numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public int numbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public int stringMaxLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int maxLength = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . max ( ) . getAsInt ( ) ; return maxLength ; }
public List < String > concatOfName ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) ; var customerNames = customers . stream ( ) . map ( c -> c . getCompanyName ( ) ) ; List < String > allNames = Stream . concat ( productNames , customerNames ) . toList ( ) ; return allNames ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Pair < String , LocalDate >> customerOrdersNestedSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . dropWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public int [ ] oddIntTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n * 2 ) . toArray ( ) ; return numSelected ; }
public List < String > convertSelectedStringItemToList ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; List < String > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof String ) . map ( s -> ( String ) s ) . toList ( ) ; return strings ; }
public Map < String , List < Customer >> customerGroupByRegionDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> catagory = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) ; return catagory ; }
public List < Product > expensiveProductTake ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . limit ( 3 ) . toList ( ) ; return after3Products ; }
public Map < Double , List < Double >> doubleGroupByModDict ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; Map < Double , List < Double >> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 1.5 ) ) ; return numberGroups ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . skip ( 3 ) . toList ( ) ; return after3WAOrders ; }
public boolean stringAllMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean allMatch = Arrays . stream ( words ) . allMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return allMatch ; }
public List < Double > doubleOrderbyFractionThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyDescendingLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public Map < String , Double > customerEachRegionOrdersTotalMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public Map < Integer , List < Integer >> intGroupByModDict ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Map < Integer , List < Integer >> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 5 ) ) ; return numberGroups ; }
public List < Pair < String , List < Order >>> customerEachRegionOrdersTotalMinCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Order >>> customerOrdersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersTotalMin ; }
public Map < String , List < Product >> productGroupTakeWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . takeWhile ( g -> g . getKey ( ) . length ( ) > 6 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public List < Product > productOrderbyCategoryThenbyDescendingIdCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < String > stringOrderbyDescendingLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Integer > intSquareTakeWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . takeWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < String > stringSkipCount ( int n ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNWords = Arrays . stream ( words ) . skip ( 3 ) . toList ( ) ; return afterNWords ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . limit ( 3 ) . toList ( ) ; return after3WAOrders ; }
public List < String > longStringTake ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . limit ( 3 ) . toList ( ) ; return after3Words ; }
public List < Pair < String , Integer >> customerNewOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public double doubleAverage ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double averageNum = Arrays . stream ( numbers ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public List < String > stringOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ; return sortedWords ; }
public List < Double > bigDoubleOrderbyFractionDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Product > expensiveProductOrderbyName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Character > exceptOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > differemtFirstChars = productFirstChars . distinct ( ) . filter ( a -> customerFirstChars . allMatch ( b -> b != a ) ) . toList ( ) ; return differemtFirstChars ; }
public List < Double > doubleReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public List < Pair < String , Order >> customerIdAndFirstOrder ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . findFirst ( ) . get ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , List < Customer >>> customerEachCountryOrdersMaxCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersMax ; }
public List < Character > intersectOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > sharedFirstChars = productFirstChars . distinct ( ) . filter ( a -> customerFirstChars . anyMatch ( b -> b == a ) ) . toList ( ) ; return sharedFirstChars ; }
public double doubleMax ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double maxNum = Arrays . stream ( numbers ) . max ( ) . getAsDouble ( ) ; return maxNum ; }
public List < Pair < String , Integer >> customerIdAndOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . size ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Order > repeatedOrders ( ) { List < Order > orders = Collections . nCopies ( 10 , Order . DEFAULT ) ; return orders ; }
public boolean intAnyMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean anyMatch = Arrays . stream ( numbers ) . anyMatch ( n -> n > 3 ) ; return anyMatch ; }
public Product expensiveProductElementAt ( ) { List < Product > products = getProductList ( ) ; Product expensiveProduct = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . skip ( 2 ) . findFirst ( ) . get ( ) ; return expensiveProduct ; }
public List < Pair < String , Integer >> countDistinctProductByCategory ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categoryCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return categoryCounts ; }
public List < Pair < String , Integer >> expensiveProductEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ) ) . toList ( ) ; return categories ; }
public List < Integer > rangeOfIntsWithStartAndCount ( int start , int count ) { List < Integer > numbers = IntStream . range ( start , start + count ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < String > shortStringOrderbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Double > doublesConvertToDescendingList ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; List < Double > doublesList = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return doublesList ; }
