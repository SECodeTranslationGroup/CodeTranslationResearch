public double numbersAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = Arrays . stream ( numbers ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public double numbersAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = Arrays . stream ( numbers ) . reduce ( seed , ( a , b ) -> a * b ) ; return product ; }
public double numbersDoubledAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public double numbersDoubledAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = product = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . reduce ( seed , ( a , b ) -> a * b ) ; return product ; }
public double bigNumbersAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public double bigNumbersAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> a * b ) ; return product ; }
public double numbersAggregateSqrtWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> Math . sqrt ( a * b ) ) ; return aggregateSum ; }
public double numbersAggregateFindMaxWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 5 ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> Math . max ( a , b ) ) ; return aggregateSum ; }
public double numbersAggregateFindMin ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( ( a , b ) -> Math . min ( a , b ) ) . getAsDouble ( ) ; return aggregateSum ; }
public double numbersAggregateFindMinWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 3 ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> Math . min ( a , b ) ) ; return aggregateSum ; }
public double inputNumbersAggregate ( double [ ] numbers ) { double product = Arrays . stream ( numbers ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public int aggregateWithdrawMoney ( ) { int [ ] attemptedWithdrawals = { 100 , 20 , 10 , 40 , 50 , 10 , 70 , 30 } ; int endBalance = Arrays . stream ( attemptedWithdrawals ) . reduce ( ( balance , nextWithdrawal ) -> nextWithdrawal <= balance ? balance - nextWithdrawal : balance ) . getAsInt ( ) ; return 0 ; }
public int aggregateWithdrawMoneyWithSeed ( ) { int startBalance = 100 ; int [ ] attemptedWithdrawals = { 20 , 10 , 40 , 50 , 10 , 70 , 30 } ; int endBalance = Arrays . stream ( attemptedWithdrawals ) . reduce ( startBalance , ( balance , nextWithdrawal ) -> nextWithdrawal <= balance ? balance - nextWithdrawal : balance ) ; return 0 ; }
public double productUnitPriceAggregateAverage ( ) { List < Product > products = getProductList ( ) ; double aggregateSum = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . reduce ( ( a , b ) -> ( a + b ) / 2 ) . get ( ) ; return aggregateSum ; }
public double productUnitPriceAggregateAverageWithSeed ( ) { List < Product > products = getProductList ( ) ; double seed = 15.5 ; double aggregateSum = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . reduce ( seed , ( a , b ) -> ( a + b ) / 2 ) ; return aggregateSum ; }
public double expensiveProductUnitPriceAggregateAverageWithSeed ( ) { List < Product > products = getProductList ( ) ; double seed = 15.5 ; double aggregateSum = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . filter ( d -> d > 100 ) . reduce ( seed , ( a , b ) -> ( a + b ) / 2 ) ; return aggregateSum ; }
public double bigNumbersAverage ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public double oddNumbersAverage ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public double doubleAverage ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double averageNum = Arrays . stream ( numbers ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public double bigDoubleNumbersAverage ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public double numbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public double bigNumbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public double stringAverageLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; double averageLength = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . average ( ) . getAsDouble ( ) ; return averageLength ; }
public double shortStringAverageLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; double averageLength = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . average ( ) . getAsDouble ( ) ; return averageLength ; }
public double productUnitPriceAverage ( ) { List < Product > products = getProductList ( ) ; double averageUnitPrice = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . average ( ) . getAsDouble ( ) ; return averageUnitPrice ; }
public double expensiveProductUnitPriceAverage ( ) { List < Product > products = getProductList ( ) ; double averageUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . average ( ) . getAsDouble ( ) ; return averageUnitPrice ; }
public double expensiveProductStockAverage ( ) { List < Product > products = getProductList ( ) ; double averageUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ; return averageUnitPrice ; }
public double productLongNameLengthAverage ( ) { List < Product > products = getProductList ( ) ; double averageUnitPrice = products . stream ( ) . map ( p -> p . getProductName ( ) ) . filter ( name -> name . length ( ) > 7 ) . mapToInt ( name -> name . length ( ) ) . average ( ) . getAsDouble ( ) ; return averageUnitPrice ; }
public List < Pair < String , Double >> customerOrdersTotalAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalAverage = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalAverage ; }
public Map < String , Double > customerOrdersTotalAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalAverage = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersTotalAverage ; }
public List < Pair < String , Double >> customerInRegionOrdersTotalAverage ( String region ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalAverage = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalAverage ; }
public Map < String , Double > customerExpensiveOrdersTotalAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalAverage = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersTotalAverage ; }
public Map < String , Double > productEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Double > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return categories ; }
public List < Pair < String , Double >> expensiveProductEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Double >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , Double > expensiveProductEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Double > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return categories ; }
public List < Pair < String , Double >> customerEachRegionOrdersAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersAverage ; }
public Map < String , Double > customerEachRegionOrdersAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersAverage ; }
public List < Pair < String , Double >> customerEachCountryOrdersAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersAverage ; }
public Map < String , Double > customerEachCountryOrdersAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersAverage ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalAverage ; }
public boolean equalInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; boolean equal = Arrays . equals ( numbersA , numbersB ) ; return equal ; }
public boolean unequalInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 6 , 10 } ; boolean equal = Arrays . equals ( numbersA , numbersB ) ; return equal ; }
public boolean projectionEqualInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 6 , 10 } ; boolean equal = Arrays . equals ( Arrays . stream ( numbersA ) . map ( n -> n + 1 ) . toArray ( ) , numbersB ) ; return equal ; }
public boolean equalDoubles ( ) { double [ ] numbersA = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; double [ ] numbersB = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; boolean equal = Arrays . equals ( numbersA , numbersB ) ; return equal ; }
public boolean unequalDoubles ( ) { double [ ] numbersA = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; double [ ] numbersB = { 6.5 , 1.3 , 8.7 , 2.4 , 4.8 } ; boolean equal = Arrays . equals ( numbersA , numbersB ) ; return equal ; }
public boolean projectionEqualDoubles ( ) { double [ ] numbersA = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; double [ ] numbersB = { 6.5 , 1.3 , 8.7 , 2.4 , 4.8 } ; boolean equal = Arrays . equals ( Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) . toArray ( ) , numbersB ) ; return equal ; }
public boolean equalStringsLengths ( ) { List < String > wordsA = Arrays . asList ( " Alpha " , " Beta " , " Gamma " ) ; List < String > wordsB = Arrays . asList ( " Gamma " , " Beta " , " Alpha " ) ; boolean equal = wordsA . stream ( ) . map ( w -> w . length ( ) ) . toList ( ) . equals ( wordsB ) ; return equal ; }
public boolean projectionEqualStrings ( ) { List < String > wordsA = Arrays . asList ( " Alpha " , " Beta " , " Gamma " ) ; List < String > wordsB = Arrays . asList ( " aLPhA " , " bETa " , " gAaMa " ) ; boolean equal = wordsA . stream ( ) . map ( w -> w . toLowerCase ( ) ) . toList ( ) . equals ( wordsB ) ; return equal ; }
public int [ ] intConcat ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; int [ ] allNumbers = IntStream . concat ( Arrays . stream ( numbersA ) , Arrays . stream ( numbersB ) ) . toArray ( ) ; return allNumbers ; }
public double [ ] doubleConcat ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] allNumbers = DoubleStream . concat ( Arrays . stream ( numbersA ) , Arrays . stream ( numbersB ) ) . toArray ( ) ; return allNumbers ; }
public String [ ] stringConcat ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; String [ ] allWords = ( String [ ] ) Stream . concat ( Arrays . stream ( wordsA ) , Arrays . stream ( wordsB ) ) . toArray ( ) ; return allWords ; }
public int [ ] projectionIntConcat ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] allNumbers = IntStream . concat ( first , second ) . toArray ( ) ; return allNumbers ; }
public Character [ ] projectionStringConcat ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = Arrays . stream ( wordsA ) . map ( n -> n . charAt ( 0 ) ) ; var second = Arrays . stream ( wordsB ) . map ( n -> n . charAt ( 0 ) ) ; Character [ ] allWords = ( Character [ ] ) Stream . concat ( first , second ) . toArray ( ) ; return allWords ; }
public List < String > concatOfRegion ( ) { String [ ] regions = { " WA " , " AF " , " RO " } ; List < Customer > customers = getCustomerList ( ) ; var customerRegions = customers . stream ( ) . map ( c -> c . getRegion ( ) ) ; List < String > allRegions = Stream . concat ( customerRegions , Arrays . stream ( regions ) ) . toList ( ) ; return allRegions ; }
public List < String > concatOfName ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) ; var customerNames = customers . stream ( ) . map ( c -> c . getCompanyName ( ) ) ; List < String > allNames = Stream . concat ( productNames , customerNames ) . toList ( ) ; return allNames ; }
public List < Character > concatOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > allFirstChars = Stream . concat ( productFirstChars , customerFirstChars ) . toList ( ) ; return allFirstChars ; }
public int [ ] intZipAdd ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int [ ] addNumbers = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] + numbersB [ i ] ) . toArray ( ) ; return addNumbers ; }
public int [ ] intZipAddReverse ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int [ ] addNumbers = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] + numbersB [ length - 1 - i ] ) . toArray ( ) ; return addNumbers ; }
public int [ ] intZipMultiply ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int [ ] multiplyNumbers = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] * numbersB [ i ] ) . toArray ( ) ; return multiplyNumbers ; }
public int intDotProduct ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int dotProduct = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] * numbersB [ i ] ) . sum ( ) ; return dotProduct ; }
public int intAddMultiply ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int product = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] + numbersB [ i ] ) . reduce ( ( a , b ) -> a * b ) . getAsInt ( ) ; return product ; }
public String [ ] stringZipAdd ( ) { String [ ] wordsA = { " Alpha " , " Beta " , " Gamma " } ; String [ ] wordsB = { " red " , " green " , " blue " } ; int length = wordsA . length ; String [ ] results = ( String [ ] ) IntStream . range ( 0 , length ) . mapToObj ( i -> wordsA [ i ] + wordsB [ i ] ) . toArray ( ) ; return results ; }
public String [ ] stringProjectionZipAdd ( ) { String [ ] wordsA = { " Alpha " , " Beta " , " Gamma " } ; String [ ] wordsB = { " red " , " green " , " blue " } ; int length = wordsA . length ; String [ ] results = ( String [ ] ) IntStream . range ( 0 , length ) . mapToObj ( i -> String . valueOf ( wordsA [ i ] . charAt ( 0 ) ) + wordsB [ i ] . charAt ( 0 ) ) . toArray ( ) ; return results ; }
public int [ ] stringProjectionZipAddInt ( ) { String [ ] wordsA = { " Alpha " , " Beta " , " Gamma " } ; String [ ] wordsB = { " red " , " green " , " blue " } ; int length = wordsA . length ; int [ ] results = IntStream . range ( 0 , length ) . map ( i -> wordsA [ i ] . length ( ) + wordsB [ i ] . length ( ) ) . toArray ( ) ; return results ; }
public int [ ] intsConvertToArray ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; int [ ] intsArray = Arrays . stream ( ints ) . sorted ( ) . toArray ( ) ; return intsArray ; }
public int [ ] intsConvertToDescendingArrayAndPrint ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; int [ ] intsArray = Arrays . stream ( ints ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . mapToInt ( d -> d ) . toArray ( ) ; for ( int i = 0 ; i < intsArray . length ; i ++ ) System . out . println ( intsArray [ i ] ) ; return intsArray ; }
public int [ ] intsConvertToArrayAndPrintForeach ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; int [ ] intsArray = Arrays . stream ( ints ) . sorted ( ) . toArray ( ) ; for ( int i : intsArray ) System . out . println ( i ) ; return intsArray ; }
public double [ ] doublesConvertToDescendingArray ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . mapToDouble ( d -> d ) . toArray ( ) ; return doublesArray ; }
public double [ ] doublesConvertToArrayAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = Arrays . stream ( doubles ) . sorted ( ) . toArray ( ) ; for ( int i = 0 ; i < doublesArray . length ; i ++ ) System . out . println ( doublesArray [ i ] ) ; return doublesArray ; }
public double [ ] doublesConvertToDescendingArrayAndPrintForeach ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . mapToDouble ( d -> d ) . toArray ( ) ; for ( double d : doublesArray ) System . out . println ( d ) ; return doublesArray ; }
public Product [ ] productsConvertToDescendingArrayAndPrint ( ) { List < Product > products = getProductList ( ) ; Product [ ] productsArray = ( Product [ ] ) products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toArray ( ) ; for ( int i = 0 ; i < productsArray . length ; i ++ ) System . out . println ( productsArray [ i ] ) ; return productsArray ; }
public Product [ ] productsConvertToDescendingArrayAndPrintForeach ( ) { List < Product > products = getProductList ( ) ; Product [ ] productsArray = ( Product [ ] ) products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toArray ( ) ; for ( Product p : productsArray ) System . out . println ( p ) ; return productsArray ; }
public List < Integer > intsConvertToDescendingListAndPrint ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < Integer > intsList = Arrays . stream ( ints ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; for ( int i = 0 ; i < intsList . size ( ) ; i ++ ) System . out . println ( intsList . get ( i ) ) ; return intsList ; }
public List < Integer > intsConvertToListAndPrintForeach ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < Integer > intsList = Arrays . stream ( ints ) . boxed ( ) . sorted ( ) . toList ( ) ; for ( int i : intsList ) System . out . println ( i ) ; return intsList ; }
public List < Double > doublesConvertToDescendingList ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; List < Double > doublesList = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return doublesList ; }
public List < Double > doublesConvertToListAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; List < Double > doublesList = Arrays . stream ( doubles ) . boxed ( ) . sorted ( ) . toList ( ) ; for ( int i = 0 ; i < doublesList . size ( ) ; i ++ ) System . out . println ( doublesList . get ( i ) ) ; return doublesList ; }
public List < Double > doublesConvertToDescendingListAndPrintForeach ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; List < Double > doublesList = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; for ( double d : doublesList ) System . out . println ( d ) ; return doublesList ; }
public List < Product > productsConvertToList ( ) { List < Product > products = getProductList ( ) ; List < Product > productsList = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) ) ) . toList ( ) ; return productsList ; }
public List < Product > productsConvertToDescendingListAndPrint ( ) { List < Product > products = getProductList ( ) ; List < Product > productsList = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; for ( int i = 0 ; i < productsList . size ( ) ; i ++ ) System . out . println ( productsList . get ( i ) ) ; return productsList ; }
public List < Product > productsConvertToDescendingListAndPrintForeach ( ) { List < Product > products = getProductList ( ) ; List < Product > productsList = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; for ( Product p : productsList ) System . out . println ( p ) ; return productsList ; }
public Map < String , Integer > convertTuplesToDictionary ( ) { List < Pair < String , Integer >> scoreRecords = Arrays . asList ( Pair . with ( " Alice " , 50 ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) ) ; Map < String , Integer > scoreRecordsDict = scoreRecords . stream ( ) . collect ( toMap ( sr -> sr . getValue0 ( ) , sr -> sr . getValue1 ( ) ) ) ; return scoreRecordsDict ; }
public Map < String , Integer > convertTuplesToDictionaryAndPrint ( ) { List < Pair < String , Integer >> scoreRecords = Arrays . asList ( Pair . with ( " Alice " , 50 ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) ) ; Map < String , Integer > scoreRecordsDict = scoreRecords . stream ( ) . collect ( toMap ( sr -> sr . getValue0 ( ) , sr -> sr . getValue1 ( ) ) ) ; for ( var pair : scoreRecordsDict . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return scoreRecordsDict ; }
public Map < Double , Double > convertArrayToDictionary ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; Map < Double , Double > doublesDict = Arrays . stream ( doubles ) . boxed ( ) . collect ( toMap ( sr -> sr , sr -> sr * 2 ) ) ; return doublesDict ; }
public Map < Double , Double > convertArrayToDictionaryAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; Map < Double , Double > doublesDict = Arrays . stream ( doubles ) . boxed ( ) . collect ( toMap ( sr -> sr , sr -> sr * 2 ) ) ; for ( var pair : doublesDict . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return doublesDict ; }
public Map < Double , Double > convertArrayToDictionaryWithDistinct ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 1.7 , 2.9 } ; Map < Double , Double > doublesDict = Arrays . stream ( doubles ) . distinct ( ) . boxed ( ) . collect ( toMap ( sr -> sr , sr -> sr * 2 ) ) ; return doublesDict ; }
public Map < String , Double > productsConvertFieldsToDictionary ( ) { List < Product > products = getProductList ( ) ; Map < String , Double > productsUnitPrice = products . stream ( ) . collect ( toMap ( p -> p . getProductName ( ) , p -> p . getUnitPrice ( ) ) ) ; return productsUnitPrice ; }
public Map < String , Double > productsConvertFieldsToDictionaryAndPrint ( ) { List < Product > products = getProductList ( ) ; Map < String , Double > productsUnitPrice = products . stream ( ) . collect ( toMap ( p -> p . getProductName ( ) , p -> p . getUnitPrice ( ) ) ) ; for ( var pair : productsUnitPrice . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return productsUnitPrice ; }
public Map < String , List < Product >> productsConvertGroupingToDictionary ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> catagory = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) ; return catagory ; }
public double [ ] convertSelectedDoubleItemToArray ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; double [ ] doubles = Arrays . stream ( numbers ) . filter ( o -> o instanceof Double ) . mapToDouble ( d -> ( double ) d ) . toArray ( ) ; return doubles ; }
public double [ ] convertSelectedDoubleItemToArrayAndPrint ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; double [ ] doubles = Arrays . stream ( numbers ) . filter ( o -> o instanceof Double ) . mapToDouble ( d -> ( double ) d ) . toArray ( ) ; for ( int i = 0 ; i < doubles . length ; i ++ ) System . out . println ( doubles [ i ] ) ; return doubles ; }
public double [ ] convertSelectedDoubleItemToArrayAndPrintForeach ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; double [ ] doubles = Arrays . stream ( numbers ) . filter ( o -> o instanceof Double ) . mapToDouble ( d -> ( double ) d ) . toArray ( ) ; for ( double d : doubles ) System . out . println ( d ) ; return doubles ; }
public List < String > convertSelectedStringItemToListAndPrint ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; List < String > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof String ) . map ( s -> ( String ) s ) . toList ( ) ; for ( int i = 0 ; i < strings . size ( ) ; i ++ ) System . out . println ( strings . get ( i ) ) ; return strings ; }
public List < String > convertSelectedStringItemToListAndPrintForeach ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; List < String > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof String ) . map ( s -> ( String ) s ) . toList ( ) ; for ( String s : strings ) System . out . println ( s ) ; return strings ; }
public List < Pair < String , Integer >> convertSelectedTupleToListAndPrint ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; List < Pair < String , Integer >> strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . toList ( ) ; for ( var i = 0 ; i < strings . size ( ) ; i ++ ) System . out . println ( strings . get ( i ) . getValue0 ( ) + " : " + strings . get ( i ) . getValue1 ( ) ) ; return strings ; }
public Map < String , Integer > convertSelectedTupleToDictionary ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; Map < String , Integer > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . collect ( toMap ( p -> p . getValue0 ( ) , p -> p . getValue1 ( ) ) ) ; return strings ; }
public Map < String , Integer > convertSelectedTupleToDictionaryAndPrint ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; Map < String , Integer > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . collect ( toMap ( p -> p . getValue0 ( ) , p -> p . getValue1 ( ) ) ) ; for ( var pair : strings . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " : " + pair . getValue ( ) ) ; return strings ; }
public int uniqueFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int uniqueFactorsCount = ( int ) Arrays . stream ( factorsOf300 ) . distinct ( ) . count ( ) ; return uniqueFactorsCount ; }
public int oddFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int factorsCount = ( int ) Arrays . stream ( factorsOf300 ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return factorsCount ; }
public int uniqueOddFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int uniqueFactorsCount = ( int ) Arrays . stream ( factorsOf300 ) . distinct ( ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return uniqueFactorsCount ; }
public int oddNumbersCount ( int [ ] numbers ) { int oddNumbersCount = ( int ) Arrays . stream ( numbers ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return oddNumbersCount ; }
public int distinctOddNumbersCount ( int [ ] numbers ) { int oddNumbersCount = ( int ) Arrays . stream ( numbers ) . distinct ( ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return oddNumbersCount ; }
public int cheapProductCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . filter ( p -> p . getUnitPrice ( ) < 100 ) . count ( ) ; return count ; }
public int distinctProductCategoryCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . map ( p -> p . getCategory ( ) ) . distinct ( ) . count ( ) ; return count ; }
public int productLongCategoryCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . map ( p -> p . getCategory ( ) ) . filter ( c -> c . length ( ) > 8 ) . count ( ) ; return count ; }
public int productNameWithFirstLetterCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . map ( p -> p . getProductName ( ) ) . filter ( c -> c . startsWith ( " c " ) ) . count ( ) ; return count ; }
public int productOutOfStock ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . filter ( c -> c . getUnitsInStock ( ) == 0 ) . count ( ) ; return count ; }
public int distinctProductLongCategoryCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . map ( p -> p . getCategory ( ) ) . distinct ( ) . filter ( c -> c . length ( ) > 8 ) . count ( ) ; return count ; }
public int customerDistinctRegionsCount ( ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . map ( c -> c . getRegion ( ) ) . distinct ( ) . count ( ) ; return count ; }
public int customerInRegionCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . count ( ) ; return count ; }
public int customerWithManyOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) > 5 ) . count ( ) ; return count ; }
public int totalOrdersCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . count ( ) ; return count ; }
public int newOrdersCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . count ( ) ; return count ; }
public int [ ] uniqueFactorOf300And900Count ( ) { int [ ] [ ] factorsOf300And900 = { { 2 , 2 , 3 , 5 , 5 } , { 2 , 2 , 3 , 3 , 5 , 5 } } ; int [ ] uniqueFactorsCount = Arrays . stream ( factorsOf300And900 ) . mapToInt ( a -> ( int ) Arrays . stream ( a ) . distinct ( ) . count ( ) ) . toArray ( ) ; return uniqueFactorsCount ; }
public int [ ] oddFactorOf300And900Count ( ) { int [ ] [ ] factorsOf300And900 = { { 2 , 2 , 3 , 5 , 5 } , { 2 , 2 , 3 , 3 , 5 , 5 } } ; int [ ] factorsCount = Arrays . stream ( factorsOf300And900 ) . mapToInt ( a -> ( int ) Arrays . stream ( a ) . filter ( n -> n % 2 == 1 ) . count ( ) ) . toArray ( ) ; return factorsCount ; }
public int [ ] uniqueFactorsCount ( int [ ] [ ] factors ) { int [ ] factorsCount = Arrays . stream ( factors ) . mapToInt ( a -> ( int ) Arrays . stream ( a ) . distinct ( ) . count ( ) ) . toArray ( ) ; return factorsCount ; }
public List < Pair < String , Integer >> customerDistinctOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public Map < String , Integer > customerDistinctOrdersCountDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > orderCounts = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> ( int ) c . getOrders ( ) . stream ( ) . distinct ( ) . count ( ) ) ) ; return orderCounts ; }
public List < Pair < String , Integer >> customerExpensiveOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public Map < String , Integer > customerExpensiveOrdersCountDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > orderCounts = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ) ) ; return orderCounts ; }
public Map < String , Integer > customerNewOrdersCountDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > orderCounts = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . count ( ) ) ) ; return orderCounts ; }
public List < Pair < Integer , Integer >> uniqueFactorOf300CountByOddEven ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; List < Pair < Integer , Integer >> uniqueFactorsCount = Arrays . stream ( factorsOf300 ) . boxed ( ) . collect ( groupingBy ( n -> n % 2 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return uniqueFactorsCount ; }
public Map < Integer , Integer > uniqueFactorOf300CountByOddEvenDict ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; Map < Integer , Integer > uniqueFactorsCount = Arrays . stream ( factorsOf300 ) . boxed ( ) . collect ( groupingBy ( n -> n % 2 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) ; return uniqueFactorsCount ; }
public List < Pair < String , Integer >> countDistinctProductByCategory ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categoryCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return categoryCounts ; }
public Map < String , Integer > countDistinctProductByCategoryDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categoryCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) ; return categoryCounts ; }
public List < Pair < Boolean , Integer >> countExpensiveProductByInStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , Integer >> inStockCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) == 0 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . count ( ) ) ) . toList ( ) ; return inStockCounts ; }
public List < Pair < String , Integer >> countRegionDistinctCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> regionCounts = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return regionCounts ; }
public Map < String , Integer > countRegionDistinctCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > regionCounts = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) ; return regionCounts ; }
public Map < String , Integer > countRegionExpensiveOrdersDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > regionCounts = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ) ) ; return regionCounts ; }
public int bigNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public int oddNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public double doubleFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . findFirst ( ) . getAsDouble ( ) ; return firstNum ; }
public double bigDoubleNumbersFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . filter ( d -> d > 5 ) . findFirst ( ) . getAsDouble ( ) ; return firstNum ; }
public String stringFirstStartWithO ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithO = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == ' o ' ) . findFirst ( ) . get ( ) ; return startWithO ; }
public String stringFirstStartWith ( char c ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithChar = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == c ) . findFirst ( ) . get ( ) ; return startWithChar ; }
public String stringFirstLong ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startsWithO = Arrays . stream ( strings ) . filter ( s -> s . length ( ) > 4 ) . findFirst ( ) . get ( ) ; return startsWithO ; }
public int projectedBigNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . map ( i -> ( int ) Math . pow ( 2 , i ) ) . filter ( n -> n > 100 ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public int projectedStringFirst ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . findFirst ( ) . getAsInt ( ) ; return firstStringLength ; }
public Product productFirst ( ) { List < Product > products = getProductList ( ) ; Product product12 = products . stream ( ) . filter ( p -> p . getProductId ( ) == 12 ) . findFirst ( ) . get ( ) ; return product12 ; }
public List < Pair < String , Product >> productEachCategoryFirst ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , Product > productEachCategoryFirstDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Product > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) ) ) ; return categories ; }
public Map < String , Order > customerEachRegionFirstOrderDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Order > ordersFirst = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . findFirst ( ) . get ( ) ) ) ; return ordersFirst ; }
public List < Pair < String , List < Product >>> productEachCategoryFirstUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) . getUnitPrice ( ) ) . toList ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , List < Product >> productEachCategoryFirstUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) . getUnitPrice ( ) ) . toList ( ) ) ) ; return categories ; }
public List < Pair < String , List < Customer >>> customerEachCountryOrdersFirstCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersFirst = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) . getOrders ( ) . size ( ) ) . toList ( ) ) ) . toList ( ) ; return customerOrdersFirst ; }
public int numbersFirstOrDefaultOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . findFirst ( ) . orElse ( - 1 ) ; return firstNum ; }
public int bigNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . findFirst ( ) . orElse ( 0 ) ; return firstNum ; }
public int oddNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . findFirst ( ) . orElse ( - 2 ) ; return firstNum ; }
public double bigDoubleNumbersFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . filter ( d -> d > 5 ) . findFirst ( ) . orElse ( - 2.3 ) ; return firstNum ; }
public String stringFirstOrDefaultStartWithO ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithO = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == ' o ' ) . findFirst ( ) . orElse ( " none " ) ; return startWithO ; }
public String stringFirstOrDefaultLong ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startsWithO = Arrays . stream ( strings ) . filter ( s -> s . length ( ) > 4 ) . findFirst ( ) . orElse ( " empty " ) ; return startsWithO ; }
public int projectedBigNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . map ( i -> ( int ) Math . pow ( 2 , i ) ) . filter ( n -> n > 100 ) . findFirst ( ) . orElse ( 100 ) ; return firstNum ; }
public double projectedDoubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . map ( i -> Math . log ( i ) ) . filter ( n -> n > 3 ) . findFirst ( ) . orElse ( 3.01 ) ; return firstNum ; }
public int projectedStringFirstOrDefault ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . findFirst ( ) . orElse ( - 1 ) ; return firstStringLength ; }
public Product productFirstOrDefault ( ) { List < Product > products = getProductList ( ) ; Product product12 = products . stream ( ) . filter ( p -> p . getProductId ( ) == 12 ) . findFirst ( ) . orElse ( Product . DEFAULT ) ; return product12 ; }
public List < Pair < String , Product >> productEachCategoryFirstOrDefault ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Product . DEFAULT ) ) ) . toList ( ) ; return categories ; }
public List < Pair < String , Order >> customerEachRegionFirstOrDefaultOrder ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> ordersFirstOrDefault = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . findFirst ( ) . orElse ( Order . DEFAULT ) ) ) . toList ( ) ; return ordersFirstOrDefault ; }
public Map < String , Order > customerEachRegionFirstOrDefaultOrderDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Order > ordersFirstOrDefault = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . findFirst ( ) . orElse ( Order . DEFAULT ) ) ) ; return ordersFirstOrDefault ; }
public Map < String , List < Product >> productEachCategoryFirstOrDefaultUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Product . DEFAULT ) . getUnitPrice ( ) ) . toList ( ) ) ) ; return categories ; }
public List < Pair < String , List < Customer >>> customerEachCountryOrdersFirstOrDefaultCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersFirstOrDefault = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Customer . DEFAULT ) . getOrders ( ) . size ( ) ) . toList ( ) ) ) . toList ( ) ; return customerOrdersFirstOrDefault ; }
public Map < String , List < Customer >> customerEachCountryOrdersFirstOrDefaultCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersFirstOrDefault = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Customer . DEFAULT ) . getOrders ( ) . size ( ) ) . toList ( ) ) ) ; return customerOrdersFirstOrDefault ; }
public int oddNumbersElementAt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numAt = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . skip ( 3 ) . findFirst ( ) . getAsInt ( ) ; return numAt ; }
public double bigDoubleNumbersElementAt ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numAt = Arrays . stream ( numbers ) . filter ( d -> d > 5 ) . skip ( 1 ) . findFirst ( ) . getAsDouble ( ) ; return numAt ; }
public String stringElementAtStartWithO ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithO = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == ' o ' ) . skip ( 0 ) . findFirst ( ) . get ( ) ; return startWithO ; }
public double projectedDoubleElementAt ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numAt = Arrays . stream ( numbers ) . map ( i -> Math . log ( i ) ) . filter ( n -> n > 3 ) . skip ( 2 ) . findFirst ( ) . getAsDouble ( ) ; return numAt ; }
public int projectedStringElementAt ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . skip ( 2 ) . findFirst ( ) . getAsInt ( ) ; return firstStringLength ; }
public Product expensiveProductElementAt ( ) { List < Product > products = getProductList ( ) ; Product expensiveProduct = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . skip ( 2 ) . findFirst ( ) . get ( ) ; return expensiveProduct ; }
public List < Pair < String , Product >> productEachCategoryElementAt ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . skip ( 1 ) . findFirst ( ) . get ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , Product > productEachCategoryElementAtDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Product > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . skip ( 1 ) . findFirst ( ) . get ( ) ) ) ; return categories ; }
public List < Integer > rangeOfInts ( ) { List < Integer > numbers = IntStream . range ( 0 , 50 ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Integer > rangeOfEvenInts ( ) { List < Integer > numbers = IntStream . range ( 0 , 50 ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Integer > rangeOfSquareInts ( ) { List < Integer > numbers = IntStream . range ( 0 , 50 ) . map ( n -> n * n ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Integer > rangeOfIntsStartFrom ( ) { List < Integer > numbers = IntStream . range ( 100 , 150 ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Integer > rangeOfEvenIntsStartFrom ( ) { List < Integer > numbers = IntStream . range ( 100 , 200 ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Integer > rangeOfSquareIntsStartFrom ( ) { List < Integer > numbers = IntStream . range ( 100 , 120 ) . map ( n -> n * n ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Integer > rangeOfIntsWithStartAndCount ( int start , int count ) { List < Integer > numbers = IntStream . range ( start , start + count ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Integer > rangeOfSquareIntsStartFrom ( int start , int count ) { List < Integer > numbers = IntStream . range ( start , start + count ) . map ( n -> n * n ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Integer > repeatedIntsWithValue ( int value ) { List < Integer > numbers = Collections . nCopies ( 10 , value ) ; return numbers ; }
public List < Integer > repeatedIntsWithValueAndCount ( int value , int count ) { List < Integer > numbers = Collections . nCopies ( count , value ) ; return numbers ; }
public List < Product > repeatedProducts ( ) { List < Product > products = Collections . nCopies ( 30 , Product . DEFAULT ) ; return products ; }
public List < Product > repeatedProductsWithBase ( Product product ) { List < Product > products = Collections . nCopies ( 10 , product ) ; return products ; }
public List < Product > repeatedProductsWithCount ( int count ) { List < Product > products = Collections . nCopies ( count , Product . DEFAULT ) ; return products ; }
public List < Product > repeatedProductsWithBaseAndCount ( Product product , int count ) { List < Product > products = Collections . nCopies ( count , product ) ; return products ; }
public List < Customer > repeatedCustomers ( ) { List < Customer > customers = Collections . nCopies ( 5 , Customer . DEFAULT ) ; return customers ; }
public List < Order > repeatedOrders ( ) { List < Order > orders = Collections . nCopies ( 10 , Order . DEFAULT ) ; return orders ; }
public List < Pair < Integer , List < Integer >>> intGroupByMod ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Pair < Integer , List < Integer >>> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public Map < Integer , List < Integer >> intGroupByModDict ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Map < Integer , List < Integer >> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 5 ) ) ; return numberGroups ; }
public List < Pair < Boolean , List < Integer >>> intGroupByBool ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Pair < Boolean , List < Integer >>> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 4 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public Map < Boolean , List < Integer >> intGroupByBoolDictPrint ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Map < Boolean , List < Integer >> numberGroups = numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 4 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; numberGroups . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; numberGroups . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return numberGroups ; }
public List < Pair < Double , List < Double >>> doubleGroupByMod ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; List < Pair < Double , List < Double >>> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 1.5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public Map < Double , List < Double >> doubleGroupByModDict ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; Map < Double , List < Double >> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 1.5 ) ) ; return numberGroups ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBool ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; List < Pair < Boolean , List < Double >>> numberGroups = numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 3 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public List < Pair < Character , List < String >>> stringGroupByFirstChar ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return wordsGroups ; }
public Map < Character , List < String >> stringGroupByFirstCharDict ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) ; return wordsGroups ; }
public List < Pair < Boolean , List < String >>> stringGroupByLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return wordsGroups ; }
public List < Pair < String , List < Product >>> productGroupByCategory ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> category = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return category ; }
public Map < String , List < Product >> productGroupByCategoryDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> category = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) ; return category ; }
public Map < String , List < Integer >> productGroupByCategoryWithIdDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Integer >> category = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; return category ; }
public List < Pair < Boolean , List < Product >>> productGroupByPrice ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Product >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return productGroup ; }
public Map < Boolean , List < Product >> productGroupByPriceDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) ; return productGroup ; }
public Map < Boolean , List < Product >> productGroupByPriceDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public List < Pair < Boolean , List < Integer >>> productGroupByPriceWithId ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Integer >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) . toList ( ) ; return productGroup ; }
public Map < Boolean , List < Integer >> productGroupByPriceWithIdDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Integer >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; return productGroup ; }
public List < Pair < Boolean , List < Product >>> productGroupByInStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Product >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return productGroup ; }
public Map < Boolean , List < Product >> productGroupByInStockDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) ; return productGroup ; }
public Map < Boolean , List < Product >> productGroupByInStockDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public List < Pair < Boolean , List < Integer >>> productGroupByInStockWithId ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Integer >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) . toList ( ) ; return productGroup ; }
public Map < Boolean , List < Integer >> productGroupByInStockWithIdDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Integer >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; return productGroup ; }
public List < Pair < String , List < Customer >>> customerGroupByRegion ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> catagory = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return catagory ; }
public Map < String , List < Customer >> customerGroupByRegionDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> catagory = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) ; return catagory ; }
public Map < String , Map < String , Customer >> customerNestedGroupByRegionAndName ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , Customer >> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c ) ) ) ) ; return customerGroups ; }
public Map < String , Map < String , List < Customer >>> customerNestedGroupByRegionAndCountry ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , List < Customer >>> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) ) ) ; return customerGroups ; }
public Map < String , Map < String , Map < String , Customer >>> customerNestedGroupByRegionAndCountryAndName ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , Map < String , Customer >>> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g1 -> g1. getKey ( ) , g1 -> g1. getValue ( ) . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c ) ) ) ) ) ) ; return customerGroups ; }
public Map < Integer , Map < Integer , List < Order >>> customerNestedGroupByOrderYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; Map < Integer , Map < Integer , List < Order >>> customerOrderGroups = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ; return customerOrderGroups ; }
public Map < Integer , Map < Integer , List < Order >>> customerNestedGroupByOrderYearAndMonthPrint ( ) { List < Customer > customers = getCustomerList ( ) ; Map < Integer , Map < Integer , List < Order >>> customerOrderGroups = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ; for ( var e1 : customerOrderGroups . entrySet ( ) ) { System . out . println ( e1. getKey ( ) + " : " ) ; for ( var e2 : e1. getValue ( ) . entrySet ( ) ) { System . out . println ( " \ t " + e2. getKey ( ) + " : " ) ; e2. getValue ( ) . stream ( ) . forEach ( o -> System . out . println ( " \ t \ t " + o ) ) ; } } return customerOrderGroups ; }
public Map < String , Map < Integer , Map < Integer , List < Order >>>> customerNestedGroupByNameAndOrderYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < Integer , Map < Integer , List < Order >>>> customerOrderGroups = customers . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c . getOrders ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ) ) ; return customerOrderGroups ; }
public Map < String , Map < Integer , Map < Integer , List < Order >>>> customerNestedGroupByNameAndOrderYearAndMonthPrint ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < Integer , Map < Integer , List < Order >>>> customerOrderGroups = customers . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c . getOrders ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ) ) ; for ( var e1 : customerOrderGroups . entrySet ( ) ) { System . out . println ( e1. getKey ( ) + " : " ) ; for ( var e2 : e1. getValue ( ) . entrySet ( ) ) { System . out . println ( " \ t " + e2. getKey ( ) + " : " ) ; for ( var e3 : e2. getValue ( ) . entrySet ( ) ) { System . out . println ( " \ t \ t " + e3. getKey ( ) + " : " ) ; e3. getValue ( ) . forEach ( o -> System . out . println ( " \ t \ t \ t " + o ) ) ; } } } return customerOrderGroups ; }
public List < Pair < String , Product >> productCrossJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Product >> q = Arrays . stream ( categories ) . flatMap ( c -> products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p -> Pair . with ( c , p ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , Double >> productCrossJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Double >> q = Arrays . stream ( categories ) . flatMap ( c -> products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p -> Pair . with ( c , p . getUnitPrice ( ) ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , Customer >> customerCrossJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Customer >> q = Arrays . stream ( regions ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> Pair . with ( r , c ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , String >> customerCrossJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> Pair . with ( r , c . getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , String >> customerCrossJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> Pair . with ( r , c . getPhone ( ) ) ) ) . toList ( ) ; return q ; }
public List < Pair < Integer , Customer >> customerCrossJoinRegionsWithCode ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , Customer >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Pair . with ( r . getValue1 ( ) , c ) ) ) . toList ( ) ; return q ; }
public List < Pair < Integer , String >> customerCrossJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , String >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Pair . with ( r . getValue1 ( ) , c . getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public List < Triplet < String , Integer , Customer >> customerCrossJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Customer >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Triplet . with ( r . getValue0 ( ) , r . getValue1 ( ) , c ) ) ) . toList ( ) ; return q ; }
public Map < String , List < Product >> productGroupJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; Map < String , List < Product >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public Map < String , List < String >> productGroupJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; Map < String , List < String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p1 -> p1. getProductName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public Map < String , List < Double >> productGroupJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; Map < String , List < Double >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p1 -> p1. getUnitPrice ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public Map < String , List < Customer >> customerGroupJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public Map < String , List < String >> customerGroupJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; Map < String , List < String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> c . getCompanyName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public Map < Integer , List < Customer >> customerGroupJoinRegionsWithCode ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Integer , List < Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public Map < Integer , List < String >> customerGroupJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Integer , List < String >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> c . getCompanyName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public Map < Pair < String , Integer > , List < Customer >> customerGroupJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Pair < String , Integer > , List < Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Pair < String , Product >> productCrossGroupJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Product >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , String >> productCrossGroupJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1. getProductName ( ) ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , Double >> productCrossGroupJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Double >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1. getUnitPrice ( ) ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , String >> customerCrossGroupJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , String >> customerCrossGroupJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getPhone ( ) ) ) ) . toList ( ) ; return q ; }
public List < Pair < Integer , Customer >> customerCrossGroupJoinRegionsWithCode ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1 ) ) ) . toList ( ) ; return q ; }
public List < Pair < Integer , String >> customerCrossGroupJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , String >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public List < Pair < Pair < String , Integer > , Customer >> customerCrossGroupJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Pair < String , Integer > , Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1 ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , Product >> productLeftOuterJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Product >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , String >> productLeftOuterJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getProductName ( ) : " No ▁ Product " ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , Double >> productLeftOuterJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Double >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getUnitPrice ( ) : 0 ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , String >> customerLeftOuterJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getCompanyName ( ) : " No ▁ Customer " ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , String >> customerLeftOuterJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getPhone ( ) : " No ▁ phone " ) ) ) . toList ( ) ; return q ; }
public List < Pair < Integer , Customer >> customerLeftOuterJoinRegionsWithCode ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public List < Pair < Pair < String , Integer > , Customer >> customerLeftOuterJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Pair < String , Integer > , Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public List < Pair < Pair < String , Integer > , String >> customerLeftOuterJoinRegionsWithCodeNameRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Pair < String , Integer > , String >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getCompanyName ( ) : " No ▁ Customer " ) ) ) . toList ( ) ; return q ; }
public boolean intAllMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean allMatch = Arrays . stream ( numbers ) . allMatch ( n -> n > 3 ) ; return allMatch ; }
public boolean oddIntAllMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean allMatch = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . allMatch ( n -> n > 3 ) ; return allMatch ; }
public boolean intSquareAllMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean allMatch = Arrays . stream ( numbers ) . map ( i -> i * i ) . allMatch ( n -> n > 3 ) ; return allMatch ; }
public boolean intAllMatchInput ( int [ ] numbers , int i ) { boolean allMatch = Arrays . stream ( numbers ) . allMatch ( n -> n > i ) ; return allMatch ; }
public boolean stringAllMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean allMatch = Arrays . stream ( words ) . allMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return allMatch ; }
public boolean longStringAllMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean allMatch = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . allMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return allMatch ; }
public boolean stringLengthAllMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean allMatch = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . allMatch ( n -> n > 5 ) ; return allMatch ; }
public boolean stringAllMatch ( char c ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean allMatch = Arrays . stream ( words ) . allMatch ( w -> w . charAt ( 0 ) > c ) ; return allMatch ; }
public boolean productAllMatch ( ) { List < Product > products = getProductList ( ) ; boolean allMatch = products . stream ( ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return allMatch ; }
public boolean categoryProductAllMatch ( ) { List < Product > products = getProductList ( ) ; boolean allMatch = products . stream ( ) . filter ( p -> p . getCategory ( ) == " Beverages " ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return allMatch ; }
public Map < String , Boolean > productEachGroupAllMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > allMatch = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return allMatch ; }
public Map < String , Boolean > expensiveProductEachGroupAllMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > allMatch = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return allMatch ; }
public boolean customerOrdersAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean allMatch = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . allMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return allMatch ; }
public boolean customerOrdersNestedAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean allMatch = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . allMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return allMatch ; }
public List < Boolean > customerOrdersEachNestedAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; List < Boolean > allMatch = customers . stream ( ) . map ( c -> c . getOrders ( ) . stream ( ) . allMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ) . toList ( ) ; return allMatch ; }
public boolean waCustomerOrdersNestedAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean allMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . allMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return allMatch ; }
public boolean intAnyMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean anyMatch = Arrays . stream ( numbers ) . anyMatch ( n -> n > 3 ) ; return anyMatch ; }
public boolean oddIntAnyMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean anyMatch = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . anyMatch ( n -> n > 3 ) ; return anyMatch ; }
public boolean intAnyMatchInput ( int i ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean anyMatch = Arrays . stream ( numbers ) . anyMatch ( n -> n > i ) ; return anyMatch ; }
public boolean intAnyMatchInput ( int [ ] numbers , int i ) { boolean anyMatch = Arrays . stream ( numbers ) . anyMatch ( n -> n > i ) ; return anyMatch ; }
public boolean stringAnyMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . anyMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return anyMatch ; }
public boolean stringLengthAnyMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . anyMatch ( n -> n > 5 ) ; return anyMatch ; }
public boolean stringAnyMatch ( char c ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . anyMatch ( w -> w . charAt ( 0 ) > c ) ; return anyMatch ; }
public boolean stringAnyMatchCount ( String [ ] strings , char c ) { boolean anyMatch = Arrays . stream ( strings ) . anyMatch ( w -> w . charAt ( 0 ) > c ) ; return anyMatch ; }
public boolean productAnyMatch ( ) { List < Product > products = getProductList ( ) ; boolean anyMatch = products . stream ( ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return anyMatch ; }
public boolean expensiveProductAnyMatch ( ) { List < Product > products = getProductList ( ) ; boolean anyMatch = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return anyMatch ; }
public boolean categoryProductAnyMatch ( ) { List < Product > products = getProductList ( ) ; boolean anyMatch = products . stream ( ) . filter ( p -> p . getCategory ( ) == " Beverages " ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return anyMatch ; }
public Map < String , Boolean > productEachGroupAnyMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > anyMatch = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return anyMatch ; }
public Map < String , Boolean > expensiveProductEachGroupAnyMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > anyMatch = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return anyMatch ; }
public boolean customerOrdersAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean anyMatch = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . anyMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return anyMatch ; }
public boolean waCustomerOrdersNestedAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean anyMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . anyMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return anyMatch ; }
public List < Boolean > waCustomerOrdersEachNestedAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; List < Boolean > anyMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . map ( c -> c . getOrders ( ) . stream ( ) . anyMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ) . toList ( ) ; return anyMatch ; }
public int numbersMax ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public int bigNumbersMax ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public double bigDoubleNumbersMax ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double maxNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . max ( ) . getAsDouble ( ) ; return maxNum ; }
public int numbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public int bigNumbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public int oddNumbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . map ( n -> n * 2 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public int stringMaxLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int maxLength = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . max ( ) . getAsInt ( ) ; return maxLength ; }
public int shortStringMaxLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int maxLength = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . max ( ) . getAsInt ( ) ; return maxLength ; }
public double productUnitPriceMax ( ) { List < Product > products = getProductList ( ) ; double maxUnitPrice = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . max ( ) . getAsDouble ( ) ; return maxUnitPrice ; }
public int expensiveProductStockMax ( ) { List < Product > products = getProductList ( ) ; int maxUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ; return maxUnitPrice ; }
public int productLongNameLengthMax ( ) { List < Product > products = getProductList ( ) ; int maxUnitPrice = products . stream ( ) . map ( p -> p . getProductName ( ) ) . filter ( name -> name . length ( ) > 7 ) . mapToInt ( name -> name . length ( ) ) . max ( ) . getAsInt ( ) ; return maxUnitPrice ; }
public List < Pair < String , Double >> customerOrdersTotalMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public Map < String , Double > customerOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < Pair < String , Double >> customerInRegionOrdersTotalMax ( String region ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public Map < String , Double > customerInRegionOrdersTotalMaxDict ( String region ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public Map < String , Double > customerExpensiveOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < Pair < String , Integer >> productEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , Integer > productEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ) ) ; return categories ; }
public Map < String , Integer > expensiveProductEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ) ) ; return categories ; }
public List < Pair < String , Integer >> customerEachRegionOrdersMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . max ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMax ; }
public List < Pair < String , Integer >> customerEachCountryOrdersMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . max ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMax ; }
public Map < String , Integer > customerEachCountryOrdersMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . max ( ) . getAsInt ( ) ) ) ; return ordersMax ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public Map < String , Double > customerEachRegionOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < Pair < String , List < Product >>> productEachCategoryMaxUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public List < Pair < String , List < Product >>> expensiveProductEachCategoryMaxUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , List < Product >> expensiveProductEachCategoryMaxUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public List < Pair < String , List < Customer >>> customerEachRegionOrdersMaxCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersMax ; }
public Map < String , List < Customer >> customerEachRegionOrdersMaxCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersMax ; }
public Map < String , List < Customer >> customerEachCountryOrdersMaxCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersMax ; }
public List < Pair < String , List < Order >>> customerEachRegionOrdersTotalMaxCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Order >>> customerOrdersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersTotalMax ; }
public Map < String , List < Order >> customerEachRegionOrdersTotalMaxCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Order >> customerOrdersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersTotalMax ; }
public int numbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . min ( ) . getAsInt ( ) ; return minNum ; }
public int oddNumbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public double doubleMin ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double minNum = Arrays . stream ( numbers ) . min ( ) . getAsDouble ( ) ; return minNum ; }
public double bigDoubleNumbersMin ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double minNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . min ( ) . getAsDouble ( ) ; return minNum ; }
public int numbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public int bigNumbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public int stringMinLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int minLength = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . min ( ) . getAsInt ( ) ; return minLength ; }
public int shortStringMinLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int minLength = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . min ( ) . getAsInt ( ) ; return minLength ; }
public double productUnitPriceMin ( ) { List < Product > products = getProductList ( ) ; double minUnitPrice = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . min ( ) . getAsDouble ( ) ; return minUnitPrice ; }
public double expensiveProductUnitPriceMin ( ) { List < Product > products = getProductList ( ) ; double minUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . min ( ) . getAsDouble ( ) ; return minUnitPrice ; }
public int expensiveProductStockMin ( ) { List < Product > products = getProductList ( ) ; int minUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ; return minUnitPrice ; }
public Map < String , Double > customerOrdersTotalMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public List < Pair < String , Double >> customerInRegionOrdersTotalMin ( String region ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMin = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMin ; }
public Map < String , Double > customerInRegionOrdersTotalMinDict ( String region ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public List < Pair < String , Double >> customerExpensiveOrdersTotalMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMin = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMin ; }
public Map < String , Double > customerExpensiveOrdersTotalMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public List < Pair < String , Integer >> productEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return categories ; }
public List < Pair < String , Integer >> expensiveProductEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , Integer > expensiveProductEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ) ) ; return categories ; }
public List < Pair < String , Integer >> customerEachRegionOrdersMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMin ; }
public Map < String , Integer > customerEachRegionOrdersMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) ; return ordersMin ; }
public List < Pair < String , Integer >> customerEachCountryOrdersMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMin ; }
public Map < String , Integer > customerEachCountryOrdersMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) ; return ordersMin ; }
public Map < String , Double > customerEachRegionOrdersTotalMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public List < Pair < String , List < Product >>> productEachCategoryMinUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , List < Product >> productEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public List < Pair < String , List < Product >>> expensiveProductEachCategoryMinUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , List < Product >> expensiveProductEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public Map < String , List < Customer >> customerEachRegionOrdersMinCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersMin ; }
public Map < String , List < Customer >> customerEachCountryOrdersMinCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersMin ; }
public List < Pair < String , List < Order >>> customerEachRegionOrdersTotalMinCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Order >>> customerOrdersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersTotalMin ; }
public Map < String , List < Order >> customerEachRegionOrdersTotalMinCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Order >> customerOrdersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersTotalMin ; }
public List < Double > doubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > doubleFractionOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > bigDoubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > bigDoubleOrderbyDescendingFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > bigDoubleFractionOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBoolOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Pair < Boolean , List < Double >>> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) . toList ( ) ; return numbersGroups ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDictOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Map < Boolean , List < Double >> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) ; return numbersGroups ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDictOrderbyDescendingFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Map < Boolean , List < Double >> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return numbersGroups ; }
public List < String > stringOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < Integer > stringLengthOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < String > shortStringOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < Integer > shortStringLengthOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < Integer > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . map ( w -> w . length ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderbyDescending ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyDescending ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Pair < Boolean , List < String >>> stringGroupByLengthOrderbyDescendingLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyDescendingLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Product > productOrderbyDescendingId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > productOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < String > productNameOrderbyDescending ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . map ( p -> p . getProductName ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > expensiveProductOrderbyDescendingId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > expensiveProductOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < String > expensiveProductNameOrderbyDescending ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getProductName ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedProducts ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyDescendingId ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public List < String > stringOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyDescendingLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > shortStringOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public List < String > shortStringOrderbyDescendingLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Integer > shortStringLengthOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . map ( w -> w . length ( ) ) . sorted ( new CustomNumberComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Pair < Boolean , List < String >>> stringGroupByLengthOrderbyDescendingLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyDescendingLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Double > doubleReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public List < Double > doubleOrderbyFractionReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public List < Double > doubleFractionOrderbyReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public List < String > stringReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public List < String > stringOrderbyReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public List < String > stringOrderbyLengthReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public List < String > shortStringReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public List < String > shortStringOrderbyLengthReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public List < Double > doubleOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public List < Double > doubleOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > doubleFractionOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public List < Double > bigDoubleOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > bigDoubleFractionOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBoolOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Pair < Boolean , List < Double >>> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( ) . toList ( ) ) ) . toList ( ) ; return numbersGroups ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBoolOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Pair < Boolean , List < Double >>> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ) ) . toList ( ) ; return numbersGroups ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDictOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Map < Boolean , List < Double >> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ) ) ; return numbersGroups ; }
public List < Integer > stringLengthOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public List < String > shortStringOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public List < String > shortStringOrderbyLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Integer > shortStringLengthOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < Integer > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . map ( w -> w . length ( ) ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderby ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderby ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Pair < Boolean , List < String >>> stringGroupByLengthOrderbyLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Product > productOrderbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < String > productNameOrderby ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . map ( p -> p . getProductName ( ) ) . sorted ( ) . toList ( ) ; return sortedProducts ; }
public List < Product > expensiveProductOrderbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < String > expensiveProductNameOrderby ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getProductName ( ) ) . sorted ( ) . toList ( ) ; return sortedProducts ; }
public List < Pair < String , List < Product >>> productGroupByCategoryOrderbyId ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ) ) . toList ( ) ; return productsGroups ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyId ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public List < Pair < String , List < Product >>> productGroupByCategoryOrderbyName ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) ) ) . toList ( ) ) ) . toList ( ) ; return productsGroups ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyName ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public List < String > stringOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Integer > stringLengthOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . sorted ( new CustomNumberComparer ( ) ) . toList ( ) ; return sortedWords ; }
public List < String > shortStringOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Pair < Boolean , List < String >>> stringGroupByLengthOrderbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public void numbersDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public void bigNumbersDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public void oddNumbersDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public void doubleDeferred ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; AtomicReference < Double > d = new AtomicReference <> ( 0.0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> d . accumulateAndGet ( n , Double :: sum ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + d ) ) ; }
public void bigNumbersTwiceDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public void oddNumbersTwiceDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public void stringLengthDeferred ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public void shortStringLengthDeferred ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . map ( w -> w . length ( ) ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public void numbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public void bigNumbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public void doubleEager ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; AtomicReference < Double > d = new AtomicReference <> ( 0.0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> d . accumulateAndGet ( n , Double :: sum ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + d ) ; }
public void bigDoubleNumbersEager ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; AtomicReference < Double > d = new AtomicReference <> ( 0.0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> d . accumulateAndGet ( n , Double :: sum ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + d ) ; }
public void bigNumbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public void oddNumbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public void stringLengthEager ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . map ( n -> i . addAndGet ( n ) ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public void shortStringLengthEager ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . map ( w -> w . length ( ) ) . map ( n -> i . addAndGet ( n ) ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public Pair < Integer , Integer > [ ] selectManyJoin ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public Pair < Integer , Integer > [ ] selectManyJoinOdd ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . filter ( b -> b % 2 == 1 ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public Pair < Integer , Integer > [ ] selectManyJoinBig ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . filter ( b -> b > 5 ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public Pair < Integer , Integer > [ ] selectManyJoinSmaller ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . filter ( b -> a < b ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public Pair < Integer , Integer > [ ] selectManyJoinSumEven ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . filter ( b -> ( a + b ) % 2 == 0 ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public List < Order > customerSelectManyOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , Order >> customerSelectManyCustomerOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , LocalDate >> customerSelectManyCustomerOrderDates ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Order > customerSelectManyBigOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , Order >> customerSelectManyCustomerBigOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , LocalDate >> customerSelectManyCustomerBigOrderDates ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Triplet < String , Integer , Double >> customerSelectManyCustomerBigOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Triplet < String , Integer , Integer >> customerSelectManyCustomerBigOrderDateYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Integer >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderDate ( ) . getYear ( ) , o . getOrderDate ( ) . getMonthValue ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , LocalDate >> customerSelectManyCustomerNewOrderDates ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Triplet < String , Integer , Double >> customerSelectManyCustomerNewOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Triplet < String , Integer , Integer >> customerSelectManyCustomerNewOrderDateYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Integer >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderDate ( ) . getYear ( ) , o . getOrderDate ( ) . getMonthValue ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , LocalDate >> waCustomerSelectManyCustomerNewOrderDates ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Triplet < String , Integer , Double >> waCustomerSelectManyCustomerNewOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Triplet < String , Integer , Integer >> waCustomerSelectManyCustomerNewOrderDateYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Integer >> customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderDate ( ) . getYear ( ) , o . getOrderDate ( ) . getMonthValue ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public int [ ] indexedSelectMany ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; int [ ] pairs = IntStream . range ( 0 , numbersA . length ) . flatMap ( i -> Arrays . stream ( numbersB ) . map ( b -> i % 2 == 0 ? numbersA [ i ] : b ) ) . toArray ( ) ; return pairs ; }
public int [ ] indexedSelectManyBig ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; int [ ] pairs = IntStream . range ( 0 , numbersA . length ) . flatMap ( i -> Arrays . stream ( numbersB ) . filter ( b -> b < numbersA [ i ] + i ) ) . toArray ( ) ; return pairs ; }
public List < Order > customerIndexedSelectManyOrdersTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = IntStream . range ( 0 , customers . size ( ) ) . boxed ( ) . flatMap ( i -> customers . get ( i ) . getOrders ( ) . stream ( ) . limit ( i < 10 ? 5 : 1 ) ) . toList ( ) ; return customerProperties ; }
public List < Order > waCustomerIndexedSelectManyOrdersTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = IntStream . range ( 0 , customers . size ( ) ) . boxed ( ) . filter ( i -> customers . get ( i ) . getRegion ( ) . equals ( " WA " ) ) . flatMap ( i -> customers . get ( i ) . getOrders ( ) . stream ( ) . limit ( i < 10 ? 5 : 1 ) ) . toList ( ) ; return customerProperties ; }
public List < String > indexedSelectManyString ( ) { List < Customer > customers = getCustomerList ( ) ; List < String > customerOrders = IntStream . range ( 0 , customers . size ( ) ) . boxed ( ) . flatMap ( i -> customers . get ( i ) . getOrders ( ) . stream ( ) . map ( o -> " Customer ▁ # " + ( i + 1 ) + " ▁ has ▁ an ▁ order ▁ with ▁ OrderID ▁ " + o . getOrderId ( ) ) ) . collect ( Collectors . toList ( ) ) ; return customerOrders ; }
public int [ ] intPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . map ( n -> n + 1 ) . toArray ( ) ; return numSelected ; }
public int [ ] oddIntPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n + 1 ) . toArray ( ) ; return numSelected ; }
public int [ ] intTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . toArray ( ) ; return numSelected ; }
public int [ ] bigIntTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n * 2 ) . toArray ( ) ; return numSelected ; }
public Character [ ] stringFirstChar ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Character [ ] selected = ( Character [ ] ) Arrays . stream ( strings ) . map ( w -> w . charAt ( 0 ) ) . toArray ( ) ; return selected ; }
public Character [ ] shortStringFirstChar ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Character [ ] selected = ( Character [ ] ) Arrays . stream ( strings ) . filter ( w -> w . length ( ) < 4 ) . map ( w -> w . charAt ( 0 ) ) . toArray ( ) ; return selected ; }
public int [ ] stringLength ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = Arrays . stream ( strings ) . mapToInt ( w -> w . length ( ) ) . toArray ( ) ; return selected ; }
public int [ ] shortStringLength ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = Arrays . stream ( strings ) . filter ( w -> w . length ( ) < 4 ) . mapToInt ( w -> w . length ( ) ) . toArray ( ) ; return selected ; }
public List < String > productName ( ) { List < Product > products = getProductList ( ) ; List < String > productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) . toList ( ) ; return productNames ; }
public List < String > expensiveProductName ( ) { List < Product > products = getProductList ( ) ; List < String > productNames = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getProductName ( ) ) . toList ( ) ; return productNames ; }
public List < Double > expensiveProductUnitPrice ( ) { List < Product > products = getProductList ( ) ; List < Double > productNames = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ; return productNames ; }
public List < Double > outOfStockProductUnitPrice ( ) { List < Product > products = getProductList ( ) ; List < Double > productNames = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) == 0 ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ; return productNames ; }
public List < Pair < String , List < String >>> productGroupName ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < String >>> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductName ( ) ) . toList ( ) ) ) . toList ( ) ; return productNames ; }
public Map < String , List < String >> productGroupNameDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < String >> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductName ( ) ) . toList ( ) ) ) ; return productNames ; }
public List < Pair < String , List < Double >>> productGroupUnitPrice ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Double >>> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ) ) . toList ( ) ; return productNames ; }
public Map < String , List < Double >> productGroupUnitPriceDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Double >> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ) ) ; return productNames ; }
public String [ ] transformIndexToString ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String [ ] textNums = ( String [ ] ) Arrays . stream ( numbers ) . mapToObj ( n -> strings [ n ] ) . toArray ( ) ; return textNums ; }
public int [ ] transformIndexHashToInt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] textNums = Arrays . stream ( numbers ) . map ( n -> numbers [ n * 97 % 10 ] ) . toArray ( ) ; return textNums ; }
public String [ ] transformIndexHashToString ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String [ ] textNums = ( String [ ] ) Arrays . stream ( numbers ) . mapToObj ( n -> numbers [ n * 97 % 10 ] ) . toArray ( ) ; return textNums ; }
public String [ ] selectByCaseConcat ( ) { String [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; String [ ] upperLowerWords = ( String [ ] ) Arrays . stream ( words ) . map ( w -> w . toUpperCase ( ) + w . toLowerCase ( ) ) . toArray ( ) ; return upperLowerWords ; }
public Pair < String , Integer > [ ] selectByStringAndLength ( ) { String [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; Pair < String , Integer > [ ] upperLowerWords = ( Pair < String , Integer > [ ] ) Arrays . stream ( words ) . map ( w -> Pair . with ( w , w . length ( ) ) ) . toArray ( ) ; return upperLowerWords ; }
public String [ ] selectByStringAndLengthConcat ( ) { String [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; String [ ] upperLowerWords = ( String [ ] ) Arrays . stream ( words ) . map ( w -> w + w . length ( ) ) . toArray ( ) ; return upperLowerWords ; }
public Pair < String , Boolean > [ ] selectByEvenOdd ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Pair < String , Boolean > [ ] evenOddWords = ( Pair < String , Boolean > [ ] ) Arrays . stream ( numbers ) . mapToObj ( n -> Pair . with ( strings [ n ] , n % 2 == 0 ) ) . toArray ( ) ; return evenOddWords ; }
public String [ ] selectByEvenOddConcat ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String [ ] evenOddWords = ( String [ ] ) Arrays . stream ( numbers ) . mapToObj ( n -> strings [ n ] + ( n % 2 == 0 ? " ▁ even " : " ▁ odd " ) ) . toArray ( ) ; return evenOddWords ; }
public List < Pair < String , String >> customerIdAndName ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getCompanyName ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Triplet < String , String , String >> customerRegionAndCountryAndCity ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , String , String >> customerProperties = customers . stream ( ) . map ( c -> Triplet . with ( c . getRegion ( ) , c . getCountry ( ) , c . getCity ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Triplet < String , String , String >> customerCityAndAddressAndPostal ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , String , String >> customerProperties = customers . stream ( ) . map ( c -> Triplet . with ( c . getCity ( ) , c . getAddress ( ) , c . getPostalCode ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , List < Order >>> customerIdAndOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Order >>> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , Integer >> customerIdAndOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . size ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , Order >> customerIdAndFirstOrder ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . findFirst ( ) . get ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , Order >> customerIdAndFirstOrDefaultOrder ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . findFirst ( ) . orElse ( Order . DEFAULT ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , Double >> customerIdAndBiggestTotal ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return customerProperties ; }
public Boolean [ ] intWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , numbers . length ) . mapToObj ( i -> numbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public Boolean [ ] oddIntWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] oddNumbers = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . toArray ( ) ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , oddNumbers . length ) . mapToObj ( i -> oddNumbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public int [ ] oddIntAddIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] oddNumbers = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . toArray ( ) ; int [ ] numSelected = IntStream . range ( 0 , oddNumbers . length ) . map ( i -> oddNumbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public Boolean [ ] oddIntWithOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] % 2 == 1 ) . mapToObj ( i -> numbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public int [ ] oddIntAddOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] % 2 == 1 ) . map ( i -> numbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public Boolean [ ] bigIntWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] bigNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . toArray ( ) ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , bigNumbers . length ) . mapToObj ( i -> bigNumbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public int [ ] bigIntAddIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] bigNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . toArray ( ) ; int [ ] numSelected = IntStream . range ( 0 , bigNumbers . length ) . map ( i -> bigNumbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public Boolean [ ] bigIntWithOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] > 5 ) . filter ( i -> numbers [ i ] % 2 == 1 ) . mapToObj ( i -> numbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public double [ ] doubleUnion ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] uniqueNumbers = DoubleStream . concat ( Arrays . stream ( numbersA ) , Arrays . stream ( numbersB ) ) . distinct ( ) . toArray ( ) ; return uniqueNumbers ; }
public String [ ] stringUnion ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; String [ ] uniqueWords = ( String [ ] ) Stream . concat ( Arrays . stream ( wordsA ) , Arrays . stream ( wordsB ) ) . distinct ( ) . toArray ( ) ; return uniqueWords ; }
public int [ ] projectionIntUnion ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] uniqueNumbers = IntStream . concat ( first , second ) . distinct ( ) . toArray ( ) ; return uniqueNumbers ; }
public double [ ] projectionDoubleUnion ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] uniqueNumbers = DoubleStream . concat ( first , second ) . distinct ( ) . toArray ( ) ; return uniqueNumbers ; }
public Character [ ] projectionStringUnion ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = Arrays . stream ( wordsA ) . map ( n -> n . charAt ( 0 ) ) ; var second = Arrays . stream ( wordsB ) . map ( n -> n . charAt ( 0 ) ) ; Character [ ] uniqueWords = ( Character [ ] ) Stream . concat ( first , second ) . distinct ( ) . toArray ( ) ; return uniqueWords ; }
public List < String > unionOfCategory ( ) { String [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = getProductList ( ) ; var productCategories = products . stream ( ) . map ( p -> p . getCategory ( ) ) ; List < String > uniqueCategories = Stream . concat ( productCategories , Arrays . stream ( categories ) ) . distinct ( ) . toList ( ) ; return uniqueCategories ; }
public List < String > unionOfRegion ( ) { String [ ] regions = { " WA " , " AF " , " RO " } ; List < Customer > customers = getCustomerList ( ) ; var customerRegions = customers . stream ( ) . map ( c -> c . getRegion ( ) ) ; List < String > uniqueRegions = Stream . concat ( customerRegions , Arrays . stream ( regions ) ) . distinct ( ) . toList ( ) ; return uniqueRegions ; }
public List < String > unionOfName ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) ; var customerNames = customers . stream ( ) . map ( c -> c . getCompanyName ( ) ) ; List < String > uniqueNames = Stream . concat ( productNames , customerNames ) . distinct ( ) . toList ( ) ; return uniqueNames ; }
public int [ ] intIntersect ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; int [ ] sharedNumbers = Arrays . stream ( numbersA ) . distinct ( ) . filter ( a -> Arrays . stream ( numbersB ) . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedNumbers ; }
public double [ ] doubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] sharedNumbers = Arrays . stream ( numbersA ) . distinct ( ) . filter ( a -> Arrays . stream ( numbersB ) . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedNumbers ; }
public double [ ] projectionDoubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] sharedNumbers = first . distinct ( ) . filter ( a -> second . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedNumbers ; }
public Character [ ] projectionStringIntersect ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = Arrays . stream ( wordsA ) . map ( n -> n . charAt ( 0 ) ) ; var second = Arrays . stream ( wordsB ) . map ( n -> n . charAt ( 0 ) ) ; Character [ ] sharedWords = ( Character [ ] ) first . distinct ( ) . filter ( a -> second . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedWords ; }
public List < String > intersectOfCategory ( ) { String [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = getProductList ( ) ; var productCategories = products . stream ( ) . map ( p -> p . getCategory ( ) ) ; List < String > sharedCategories = productCategories . distinct ( ) . filter ( a -> Arrays . stream ( categories ) . anyMatch ( b -> b . equals ( a ) ) ) . toList ( ) ; return sharedCategories ; }
public List < String > intersectOfRegion ( ) { String [ ] regions = { " WA " , " AF " , " RO " } ; List < Customer > customers = getCustomerList ( ) ; var customerRegions = customers . stream ( ) . map ( c -> c . getRegion ( ) ) ; List < String > sharedRegions = customerRegions . distinct ( ) . filter ( a -> Arrays . stream ( regions ) . anyMatch ( b -> b . equals ( a ) ) ) . toList ( ) ; return sharedRegions ; }
public List < String > intersectOfName ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) ; var customerNames = customers . stream ( ) . map ( c -> c . getCompanyName ( ) ) ; List < String > sharedNames = productNames . distinct ( ) . filter ( a -> customerNames . anyMatch ( b -> b . equals ( a ) ) ) . toList ( ) ; return sharedNames ; }
public List < Character > intersectOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > sharedFirstChars = productFirstChars . distinct ( ) . filter ( a -> customerFirstChars . anyMatch ( b -> b == a ) ) . toList ( ) ; return sharedFirstChars ; }
public int [ ] intExcept ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; int [ ] differemtNumbers = Arrays . stream ( numbersA ) . distinct ( ) . filter ( a -> Arrays . stream ( numbersB ) . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtNumbers ; }
public double [ ] doubleExcept ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] differemtNumbers = Arrays . stream ( numbersA ) . distinct ( ) . filter ( a -> Arrays . stream ( numbersB ) . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtNumbers ; }
public int [ ] projectionIntExcept ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] differemtNumbers = first . distinct ( ) . filter ( a -> second . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtNumbers ; }
public double [ ] projectionDoubleExcept ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] differemtNumbers = first . distinct ( ) . filter ( a -> second . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtNumbers ; }
public Character [ ] projectionStringExcept ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = Arrays . stream ( wordsA ) . map ( n -> n . charAt ( 0 ) ) ; var second = Arrays . stream ( wordsB ) . map ( n -> n . charAt ( 0 ) ) ; Character [ ] differemtWords = ( Character [ ] ) first . distinct ( ) . filter ( a -> second . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtWords ; }
public List < String > exceptOfCategory ( ) { String [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = getProductList ( ) ; var productCategories = products . stream ( ) . map ( p -> p . getCategory ( ) ) ; List < String > differemtCategories = productCategories . distinct ( ) . filter ( a -> Arrays . stream ( categories ) . allMatch ( b -> ! b . equals ( a ) ) ) . toList ( ) ; return differemtCategories ; }
public List < String > exceptOfName ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) ; var customerNames = customers . stream ( ) . map ( c -> c . getCompanyName ( ) ) ; List < String > differemtNames = productNames . distinct ( ) . filter ( a -> customerNames . allMatch ( b -> ! b . equals ( a ) ) ) . toList ( ) ; return differemtNames ; }
public List < Character > exceptOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > differemtFirstChars = productFirstChars . distinct ( ) . filter ( a -> customerFirstChars . allMatch ( b -> b != a ) ) . toList ( ) ; return differemtFirstChars ; }
public List < Integer > intSkip ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . skip ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > oddIntSkip ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . skip ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > intSkipCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . skip ( n ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > intSkipCount ( int [ ] numbers , int n ) { List < Integer > afterNNumbers = Arrays . stream ( numbers ) . skip ( n ) . boxed ( ) . toList ( ) ; return afterNNumbers ; }
public List < String > stringSkip ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNNumbers = Arrays . stream ( words ) . skip ( 3 ) . toList ( ) ; return afterNNumbers ; }
public List < String > longStringSkip ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . skip ( 3 ) . toList ( ) ; return after3Words ; }
public List < Integer > stringLengthSkip ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < Integer > after3Words = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . skip ( 3 ) . toList ( ) ; return after3Words ; }
public List < String > stringSkipCount ( int n ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNWords = Arrays . stream ( words ) . skip ( 3 ) . toList ( ) ; return afterNWords ; }
public List < Product > productSkip ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . skip ( 3 ) . toList ( ) ; return after3Products ; }
public List < Product > expensiveProductSkip ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . skip ( 3 ) . toList ( ) ; return after3Products ; }
public List < Product > inStockProductSkip ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . skip ( 3 ) . toList ( ) ; return after3Products ; }
public Map < String , List < Product >> productGroupSkip ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . skip ( 3 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public Map < String , List < Product >> productEachGroupSkip ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . skip ( 3 ) . toList ( ) ) ) ; return after3EachGroups ; }
public List < Pair < String , LocalDate >> customerOrdersNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . skip ( 3 ) . toList ( ) ; return after3Orders ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . skip ( 3 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . skip ( 3 ) . toList ( ) ; return after3WAOrders ; }
public List < Integer > intSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . dropWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > intSquareSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . dropWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > intSkipWhileCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . dropWhile ( i -> i > n ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > intSkipWhileCount ( int [ ] numbers , int n ) { List < Integer > afterNNumbers = Arrays . stream ( numbers ) . dropWhile ( i -> i > n ) . boxed ( ) . toList ( ) ; return afterNNumbers ; }
public List < String > stringSkipWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNNumbers = Arrays . stream ( words ) . dropWhile ( w -> w . charAt ( 0 ) > ' b ' ) . toList ( ) ; return afterNNumbers ; }
public List < Integer > stringLengthSkipWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < Integer > after3Words = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . dropWhile ( n -> n > 5 ) . toList ( ) ; return after3Words ; }
public List < String > stringSkipWhileCount ( char c ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNWords = Arrays . stream ( words ) . dropWhile ( w -> w . charAt ( 0 ) > c ) . toList ( ) ; return afterNWords ; }
public List < String > stringSkipWhileCount ( String [ ] strings , char c ) { List < String > afterNWords = Arrays . stream ( strings ) . dropWhile ( w -> w . charAt ( 0 ) > c ) . toList ( ) ; return afterNWords ; }
public List < Product > productSkipWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public List < Product > expensiveProductSkipWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public List < Product > inStockProductSkipWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public Map < String , List < Product >> productGroupSkipWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . dropWhile ( g -> g . getKey ( ) . length ( ) > 6 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public Map < String , List < Product >> productEachGroupSkipWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ) ) ; return after3EachGroups ; }
public List < Order > customerOrdersSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . dropWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public List < Pair < String , LocalDate >> customerOrdersNestedSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . dropWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . dropWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3WAOrders ; }
public List < Integer > intSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> numbers [ i ] > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Integer > intSquareSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> numbers [ i ] * numbers [ i ] > i ) . map ( i -> numbers [ i ] * numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Double > intSqrtSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Double > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> Math . sqrt ( numbers [ i ] ) > i ) . mapToDouble ( i -> Math . sqrt ( numbers [ i ] ) ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Integer > intSkipWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Integer > intSkipWhileIndexedCount ( int [ ] numbers , int n ) { List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public int numbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . sum ( ) ; return numbersSum ; }
public int bigNumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . sum ( ) ; return numbersSum ; }
public double doubleSum ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numbersSum = Arrays . stream ( numbers ) . sum ( ) ; return numbersSum ; }
public int numbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . sum ( ) ; return numbersSum ; }
public int bigNumbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . sum ( ) ; return numbersSum ; }
public int stringSumLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int totalChars = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . sum ( ) ; return totalChars ; }
public int shortStringSumLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int totalChars = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . sum ( ) ; return totalChars ; }
public double productUnitPriceSum ( ) { List < Product > products = getProductList ( ) ; double totalSum = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . sum ( ) ; return totalSum ; }
public double expensiveProductUnitPriceSum ( ) { List < Product > products = getProductList ( ) ; double totalSum = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . sum ( ) ; return totalSum ; }
public int productLongNameLengthSum ( ) { List < Product > products = getProductList ( ) ; int totalSum = products . stream ( ) . map ( p -> p . getProductName ( ) ) . filter ( name -> name . length ( ) > 7 ) . mapToInt ( name -> name . length ( ) ) . sum ( ) ; return totalSum ; }
public List < Pair < String , Double >> customerOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public Map < String , Double > customerOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public List < Pair < String , Double >> customerInRegionOrdersTotalSum ( String region ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public Map < String , Double > customerInRegionOrdersTotalSumDict ( String region ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public List < Pair < String , Double >> customerExpensiveOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public Map < String , Double > customerExpensiveOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public Map < String , Integer > productEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . sum ( ) ) ) ; return categories ; }
public List < Pair < String , Integer >> expensiveProductEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . sum ( ) ) ) . toList ( ) ; return categories ; }
public List < Pair < String , Integer >> customerEachRegionOrdersSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersSum ; }
public Map < String , Integer > customerEachRegionOrdersSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . sum ( ) ) ) ; return ordersSum ; }
public List < Pair < String , Integer >> customerEachCountryOrdersSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersSum ; }
public Map < String , Integer > customerEachCountryOrdersSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . sum ( ) ) ) ; return ordersSum ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public Map < String , Double > customerEachRegionOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public List < Integer > intTake ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . limit ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > intSquareTake ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . limit ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > intTakeCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . limit ( n ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < String > stringTake ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNNumbers = Arrays . stream ( words ) . limit ( 3 ) . toList ( ) ; return afterNNumbers ; }
public List < String > longStringTake ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . limit ( 3 ) . toList ( ) ; return after3Words ; }
public List < Integer > stringLengthTake ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < Integer > after3Words = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . limit ( 3 ) . toList ( ) ; return after3Words ; }
public List < String > stringTakeCount ( int n ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNWords = Arrays . stream ( words ) . limit ( 3 ) . toList ( ) ; return afterNWords ; }
public List < String > stringTakeCount ( String [ ] strings , int n ) { List < String > afterNWords = Arrays . stream ( strings ) . limit ( 3 ) . toList ( ) ; return afterNWords ; }
public List < Product > inStockProductTake ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . limit ( 3 ) . toList ( ) ; return after3Products ; }
public Map < String , List < Product >> productGroupTake ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . limit ( 3 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public Map < String , List < Product >> productEachGroupTake ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . limit ( 3 ) . toList ( ) ) ) ; return after3EachGroups ; }
public List < Order > customerOrdersTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . limit ( 3 ) . toList ( ) ; return after3Orders ; }
public List < Pair < String , LocalDate >> customerOrdersNestedTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . limit ( 3 ) . toList ( ) ; return after3Orders ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . limit ( 3 ) . toList ( ) ; return after3WAOrders ; }
public List < Pair < String , LocalDate >> waCustomerOrdersEachNestedTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachWAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . limit ( 3 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachWAOrders ; }
public List < Integer > intTakeWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . takeWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > intSquareTakeWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . takeWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > intTakeWhileCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . takeWhile ( i -> i > n ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > intTakeWhileCount ( int [ ] numbers , int n ) { List < Integer > afterNNumbers = Arrays . stream ( numbers ) . takeWhile ( i -> i > n ) . boxed ( ) . toList ( ) ; return afterNNumbers ; }
public List < String > longStringTakeWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . takeWhile ( w -> w . charAt ( 0 ) > ' b ' ) . toList ( ) ; return after3Words ; }
public List < Integer > stringLengthTakeWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < Integer > after3Words = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . takeWhile ( n -> n > 5 ) . toList ( ) ; return after3Words ; }
public List < String > stringTakeWhileCount ( char c ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNWords = Arrays . stream ( words ) . takeWhile ( w -> w . charAt ( 0 ) > c ) . toList ( ) ; return afterNWords ; }
public List < Product > productTakeWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public List < Product > expensiveProductTakeWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public List < Product > inStockProductTakeWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public Map < String , List < Product >> productGroupTakeWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . takeWhile ( g -> g . getKey ( ) . length ( ) > 6 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public Map < String , List < Product >> productEachGroupTakeWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ) ) ; return after3EachGroups ; }
public List < Order > customerOrdersTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . takeWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public List < Pair < String , LocalDate >> customerOrdersNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . takeWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . takeWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public List < Pair < String , LocalDate >> waCustomerOrdersEachNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachWAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . takeWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachWAOrders ; }
public List < Integer > intTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> numbers [ i ] > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Integer > intSquareTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> numbers [ i ] * numbers [ i ] > i ) . map ( i -> numbers [ i ] * numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Double > intSqrtTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Double > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> Math . sqrt ( numbers [ i ] ) > i ) . mapToDouble ( i -> Math . sqrt ( numbers [ i ] ) ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Integer > intTakeWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Double > doubleOrderbyFractionThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > doubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > doubleOrderbyFractionDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > doubleOrderbyModDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > doubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > doubleOrderbyFractionDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > doubleOrderbyModDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > bigDoubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > bigDoubleOrderbyFractionDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > bigDoubleOrderbyModDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > bigDoubleOrderbyFractionThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Double > bigDoubleOrderbyModDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < String > stringOrderbyLengthThenby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyThenbyLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w ) . thenComparing ( w -> w . length ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyLengthCustomThenby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) , new CustomNumberComparer ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyThenbyLengthCustom ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyLengthThenbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) ) . thenComparing ( new CaseInsensitiveComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyLengthCustomThenbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) , new CustomNumberComparer ( ) ) . thenComparing ( new CaseInsensitiveComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyCustomThenbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w , new CaseInsensitiveComparer ( ) ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyLengthThenbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) ) . thenComparing ( new CaseInsensitiveComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyLengthCustomThenbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) , new CustomNumberComparer ( ) ) . thenComparing ( new CaseInsensitiveComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyCustomThenbyLengthDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w , new CaseInsensitiveComparer ( ) ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Product > productOrderbyCategoryThenbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > productOrderbyCategoryThenbyName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > productOrderbyCategoryThenbyDescendingId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > expensiveProductOrderbyCategoryThenbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > productOrderbyCategoryThenbyIdCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > productOrderbyCategoryThenbyNameCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) , new CaseInsensitiveComparer ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > productOrderbyCategoryThenbyDescendingIdCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > productOrderbyCategoryThenbyDescendingNameCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) , new CaseInsensitiveComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > expensiveProductOrderbyCategoryThenbyIdCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > expensiveProductOrderbyCategoryThenbyNameCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) , new CaseInsensitiveComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Integer > intIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] < i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public List < Integer > oddIntOriginalIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] < i && numbers [ i ] % 2 == 1 ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public List < Integer > intSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] * numbers [ i ] < i ) . map ( i -> numbers [ i ] * numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public List < Integer > intWithSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] < i * i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public List < String > stringIndexedWhere ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; IntStream . range ( 0 , words . length ) . filter ( i -> words [ i ] . length ( ) < i ) . mapToObj ( i -> words [ i ] ) . toList ( ) ; List < String > q = IntStream . range ( 0 , words . length ) . filter ( i -> words [ i ] . length ( ) < i ) . mapToObj ( i -> words [ i ] ) . toList ( ) ; return q ; }
public List < String > longStringIndexedWhere ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; String [ ] longWords = ( String [ ] ) Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . toArray ( ) ; List < String > q = IntStream . range ( 0 , longWords . length ) . filter ( i -> longWords [ i ] . length ( ) < i * 3 ) . mapToObj ( i -> longWords [ i ] ) . toList ( ) ; return q ; }
public List < String > longStringOrginalIndexedWhere ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > q = IntStream . range ( 0 , words . length ) . filter ( i -> words [ i ] . length ( ) < i * 3 && words [ i ] . length ( ) > 5 ) . mapToObj ( i -> words [ i ] ) . toList ( ) ; return q ; }
public List < Product > productIndexedWhere ( ) { List < Product > products = getProductList ( ) ; List < Product > q = IntStream . range ( 0 , products . size ( ) ) . filter ( i -> products . get ( i ) . getUnitsInStock ( ) > 0 && i % 2 == 1 ) . mapToObj ( i -> products . get ( i ) ) . toList ( ) ; return q ; }
