def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( y > 0 ) : return x * temp * temp NEW_LINE else : return ( temp * temp ) / x NEW_LINE DEDENT DEDENT
def printDistSum ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( Sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def countWays ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT countB = 1 NEW_LINE countS = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT prev_countB = countB NEW_LINE prev_countS = countS NEW_LINE countS = prev_countB + prev_countS NEW_LINE countB = prev_countS NEW_LINE DEDENT result = countS + countB NEW_LINE return ( result * result ) NEW_LINE DEDENT
def scalarProductMat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT
def maxSum ( arr ) : NEW_LINE INDENT arrSum = 0 NEW_LINE currVal = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arrSum = arrSum + arr [ i ] NEW_LINE currVal = currVal + ( i * arr [ i ] ) NEW_LINE DEDENT maxVal = currVal NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT currVal = currVal + arrSum - n * arr [ n - j ] NEW_LINE if currVal > maxVal : NEW_LINE INDENT maxVal = currVal NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT
def LowerInsertionPoint ( arr , n , X ) : NEW_LINE INDENT if ( X < arr [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( X > arr [ n - 1 ] ) : NEW_LINE INDENT return n NEW_LINE DEDENT lowerPnt = 0 NEW_LINE i = 1 NEW_LINE while ( i < n and arr [ i ] < X ) : NEW_LINE INDENT lowerPnt = i NEW_LINE i = i * 2 NEW_LINE DEDENT while ( lowerPnt < n and arr [ lowerPnt ] < X ) : NEW_LINE INDENT lowerPnt += 1 NEW_LINE DEDENT return lowerPnt NEW_LINE DEDENT
def findMinDiff ( arr , n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE if ( n < m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT min_diff = sys . maxsize NEW_LINE first = 0 NEW_LINE last = 0 NEW_LINE i = 0 NEW_LINE while ( i + m - 1 < n ) : NEW_LINE INDENT diff = arr [ i + m - 1 ] - arr [ i ] NEW_LINE if ( diff < min_diff ) : NEW_LINE INDENT min_diff = diff NEW_LINE first = i NEW_LINE last = i + m - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( arr [ last ] - arr [ first ] ) NEW_LINE DEDENT
def minRemove ( a , b , n , m ) : NEW_LINE INDENT countA = dict ( ) NEW_LINE countB = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT countA [ a [ i ] ] = countA . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT countB [ b [ i ] ] = countB . get ( b [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in countA : NEW_LINE INDENT if x in countB . keys ( ) : NEW_LINE INDENT res += min ( countA [ x ] , countB [ x ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
def arraySortedOrNot ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if n == 1 or n == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] ) NEW_LINE DEDENT
def minTime ( n , k , a ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE minTime = 0 NEW_LINE for i in range ( 0 , n , k ) : NEW_LINE INDENT minTime += ( 2 * a [ i ] ) NEW_LINE DEDENT return minTime NEW_LINE DEDENT
def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def find_max ( A , N , K ) : NEW_LINE INDENT Count = dict ( ) NEW_LINE for i in range ( K - 1 ) : NEW_LINE INDENT Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 NEW_LINE DEDENT Myset = dict ( ) NEW_LINE for x in Count : NEW_LINE INDENT if ( Count [ x ] == 1 ) : NEW_LINE INDENT Myset [ x ] = 1 NEW_LINE DEDENT DEDENT for i in range ( K - 1 , N ) : NEW_LINE INDENT Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 NEW_LINE if ( Count [ A [ i ] ] == 1 ) : NEW_LINE INDENT Myset [ A [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT del Myset [ A [ i ] ] NEW_LINE DEDENT if ( len ( Myset ) == 0 ) : NEW_LINE INDENT print ( " Nothing " ) NEW_LINE DEDENT else : NEW_LINE INDENT maxm = - 10 ** 9 NEW_LINE for i in Myset : NEW_LINE INDENT maxm = max ( i , maxm ) NEW_LINE DEDENT print ( maxm ) NEW_LINE DEDENT x = A [ i - K + 1 ] NEW_LINE if x in Count . keys ( ) : NEW_LINE INDENT Count [ x ] -= 1 NEW_LINE if ( Count [ x ] == 1 ) : NEW_LINE INDENT Myset [ x ] = 1 NEW_LINE DEDENT if ( Count [ x ] == 0 ) : NEW_LINE INDENT del Myset [ x ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT
def totalNodes ( adjac , n , x , y ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE p = [ None ] * n NEW_LINE q = queue . Queue ( ) NEW_LINE q . put ( x ) NEW_LINE visited [ x ] = True NEW_LINE m = None NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT m = q . get ( ) NEW_LINE for i in range ( len ( adjac [ m ] ) ) : NEW_LINE INDENT h = adjac [ m ] [ i ] NEW_LINE if ( not visited [ h ] ) : NEW_LINE INDENT visited [ h ] = True NEW_LINE p [ h ] = m NEW_LINE q . put ( h ) NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE i = p [ y ] NEW_LINE while ( i != x ) : NEW_LINE INDENT count += 1 NEW_LINE i = p [ i ] NEW_LINE DEDENT return count NEW_LINE DEDENT
def solve ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE parent = [ None ] * ( n + 1 ) NEW_LINE vis = [ None ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT parent [ i ] = - 1 NEW_LINE vis [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT j = i NEW_LINE if ( parent [ j ] == - 1 ) : NEW_LINE INDENT while ( parent [ j ] == - 1 ) : NEW_LINE INDENT parent [ j ] = i NEW_LINE j = ( j + A [ j ] + 1 ) % n NEW_LINE DEDENT if ( parent [ j ] == i ) : NEW_LINE INDENT while ( vis [ j ] == 0 ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE cnt = cnt + 1 NEW_LINE j = ( j + A [ j ] + 1 ) % n NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def countDistictSubarray ( arr , n ) : NEW_LINE INDENT vis = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE vid = dict ( ) NEW_LINE ans = 0 NEW_LINE right = 0 NEW_LINE window = 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while ( right < n and window < k ) : NEW_LINE INDENT if arr [ right ] in vid . keys ( ) : NEW_LINE INDENT vid [ arr [ right ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT vid [ arr [ right ] ] = 1 NEW_LINE DEDENT if ( vid [ arr [ right ] ] == 1 ) : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if ( window == k ) : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vid [ arr [ left ] ] -= 1 NEW_LINE if ( vid [ arr [ left ] ] == 0 ) : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def MinOperation ( a , b , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] > b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT elif ( a [ i ] < b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def minHeight ( area , base ) : NEW_LINE INDENT return math . ceil ( ( 2 * area ) / base ) NEW_LINE DEDENT
def checkSentence ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE if string [ 0 ] < ' A ' or string [ 0 ] > ' Z ' : NEW_LINE INDENT return False NEW_LINE DEDENT if string [ length - 1 ] != ' . ' : NEW_LINE INDENT return False NEW_LINE DEDENT prev_state = 0 NEW_LINE curr_state = 0 NEW_LINE index = 1 NEW_LINE while ( string [ index ] ) : NEW_LINE INDENT if string [ index ] >= ' A ' and string [ index ] <= ' Z ' : NEW_LINE INDENT curr_state = 0 NEW_LINE DEDENT elif string [ index ] == ' ▁ ' : NEW_LINE INDENT curr_state = 1 NEW_LINE DEDENT elif string [ index ] >= ' a ' and string [ index ] <= ' z ' : NEW_LINE INDENT curr_state = 2 NEW_LINE DEDENT elif string [ index ] == ' . ' : NEW_LINE INDENT curr_state = 3 NEW_LINE DEDENT if prev_state == curr_state and curr_state != 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if prev_state == 2 and curr_state == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if curr_state == 3 and prev_state != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT index += 1 NEW_LINE prev_state = curr_state NEW_LINE DEDENT return False NEW_LINE DEDENT
def alternateSort ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE j -= 1 NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def getFirstSetBitPos ( n ) : NEW_LINE INDENT return math . log2 ( n & - n ) + 1 NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 19 NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT curr += 9 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findMaxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum = arr [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT prefix_sum += arr [ j ] NEW_LINE DEDENT suffix_sum = arr [ i ] NEW_LINE j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT suffix_sum += arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( prefix_sum == suffix_sum ) : NEW_LINE INDENT res = max ( res , prefix_sum ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def section ( x1 , x2 , y1 , y2 , m , n ) : NEW_LINE INDENT x = ( float ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) NEW_LINE y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) NEW_LINE print ( x , y ) NEW_LINE DEDENT
def checkPair ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if sum % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT sum = sum / 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = sum - arr [ i ] NEW_LINE if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT if val in s : NEW_LINE INDENT print ( " Pair ▁ elements ▁ are " , arr [ i ] , " and " , int ( val ) ) NEW_LINE DEDENT DEDENT DEDENT
def countFibs ( low , high ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT rem = n % 4 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT if ( rem == 1 ) : NEW_LINE INDENT if ( n < 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 9 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 2 ) : NEW_LINE INDENT return ( n - 6 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 3 ) : NEW_LINE INDENT if ( n < 15 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 15 ) // 4 + 2 NEW_LINE DEDENT DEDENT
def kthNonRepeating ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE index = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ ord ( x ) ] += 1 NEW_LINE if ( count [ ord ( x ) ] == 1 ) : NEW_LINE INDENT index [ ord ( x ) ] = i NEW_LINE DEDENT if ( count [ ord ( x ) ] == 2 ) : NEW_LINE INDENT index [ ord ( x ) ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1 NEW_LINE DEDENT
def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ) NEW_LINE DEDENT
def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , " ▁ , ▁ " , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT
def groupElements ( arr , n ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE visited [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def arekAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] > count2 [ i ] ) : NEW_LINE INDENT count = count + abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT DEDENT return ( count <= k ) NEW_LINE DEDENT
def printPrevSmaller ( arr , n ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT print ( arr [ j ] , " , ▁ " , end = " " ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == - 1 ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def lcs ( i , j , count ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT count = lcs ( i - 1 , j - 1 , count + 1 ) NEW_LINE DEDENT count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) NEW_LINE return count NEW_LINE DEDENT
def findLargestSumPair ( arr , n ) : NEW_LINE INDENT if arr [ 0 ] > arr [ 1 ] : NEW_LINE INDENT first = arr [ 0 ] NEW_LINE second = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT first = arr [ 1 ] NEW_LINE second = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second and arr [ i ] != first : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT return ( first + second ) NEW_LINE DEDENT
def check_duck ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE count_zero = 0 NEW_LINE i = 1 NEW_LINE while i < l : NEW_LINE INDENT ch = num [ i ] NEW_LINE if ( ch == "0" ) : NEW_LINE INDENT count_zero = count_zero + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return count_zero NEW_LINE DEDENT
def checkIfAllTogether ( s , c ) : NEW_LINE INDENT oneSeen = False NEW_LINE i = 0 NEW_LINE n = len ( s ) NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT if ( oneSeen == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i < n and s [ i ] == c ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def areElementsContiguous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_ele = arr [ 0 ] - 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele -= 1 NEW_LINE DEDENT curr_ele = arr [ 0 ] + 1 NEW_LINE while curr_ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT
def findMinSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 2 NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE num /= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum += num NEW_LINE return sum NEW_LINE DEDENT
def minStringValue ( str , k ) : NEW_LINE INDENT l = len ( str ) NEW_LINE if ( k >= l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT frequency = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT frequency [ ord ( str [ i ] ) - 97 ] += 1 NEW_LINE DEDENT q = PriorityQueue ( ) NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT q . put ( - frequency [ i ] ) NEW_LINE DEDENT while ( k > 0 ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp + 1 NEW_LINE q . put ( temp , temp ) NEW_LINE k = k - 1 NEW_LINE DEDENT result = 0 ; NEW_LINE while not q . empty ( ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp * ( - 1 ) NEW_LINE result += temp * temp NEW_LINE DEDENT return result NEW_LINE DEDENT
def reverseFibonacci ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 2 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countSubarrWithEqualZeroAndOne ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) NEW_LINE if um . get ( curr_sum ) : NEW_LINE INDENT um [ curr_sum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT um [ curr_sum ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for itr in um : NEW_LINE INDENT if um [ itr ] > 1 : NEW_LINE INDENT count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 ) NEW_LINE DEDENT DEDENT if um . get ( 0 ) : NEW_LINE INDENT count += um [ 0 ] NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
def isLucky ( n ) : NEW_LINE INDENT next_position = n NEW_LINE if isLucky . counter > n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % isLucky . counter == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT next_position = next_position - next_position / isLucky . counter NEW_LINE isLucky . counter = isLucky . counter + 1 NEW_LINE return isLucky ( next_position ) NEW_LINE DEDENT
def count ( s , Len ) : NEW_LINE INDENT global MAX NEW_LINE cur = 0 NEW_LINE dig = 0 NEW_LINE Sum = [ 0 ] * MAX NEW_LINE dp = [ [ 0 , 0 , 0 ] for i in range ( MAX ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE cur += dig NEW_LINE cur %= 3 NEW_LINE Sum [ i ] = cur NEW_LINE dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] NEW_LINE dp [ i ] [ Sum [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE dprev = 0 NEW_LINE value = 0 NEW_LINE dprev2 = 0 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE if dig == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i - 2 >= 0 : NEW_LINE INDENT dprev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = dprev * 10 + dig NEW_LINE if ( value % 8 == 0 ) and ( value % 3 != 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if i - 3 >= 0 : NEW_LINE INDENT dprev2 = int ( s [ i - 3 ] ) - 48 NEW_LINE dprev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = ( dprev2 * 100 + dprev * 10 + dig ) NEW_LINE if value % 8 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans += ( i - 2 ) NEW_LINE ans -= ( dp [ i - 3 ] [ Sum [ i ] ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
def canFormPalindrome ( st ) : NEW_LINE INDENT count = [ 0 ] * ( NO_OF_CHARS ) NEW_LINE for i in range ( 0 , len ( st ) ) : NEW_LINE INDENT count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1 NEW_LINE DEDENT odd = 0 NEW_LINE for i in range ( 0 , NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT if ( odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE while ( x > y ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT
def binarySearch ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE DEDENT if mid is arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT
def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def isConvertible ( str1 , str2 , k ) : NEW_LINE INDENT if ( ( len ( str1 ) + len ( str2 ) ) < k ) : NEW_LINE INDENT return True NEW_LINE DEDENT commonLength = 0 NEW_LINE for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT commonLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def answerQuery ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE l = l - 1 NEW_LINE for i in range ( l , r , 1 ) : NEW_LINE INDENT element = a [ i ] NEW_LINE divisors = 0 NEW_LINE for j in range ( l , r , 1 ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT divisors += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( divisors == ( r - l ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def swap ( xp , yp ) : NEW_LINE INDENT if ( xp [ 0 ] == yp [ 0 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT xp [ 0 ] = xp [ 0 ] + yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE DEDENT
def maxProfit ( price , n , k ) : NEW_LINE INDENT profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT prevDiff = float ( ' - inf ' ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) NEW_LINE profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) NEW_LINE DEDENT DEDENT return profit [ k ] [ n - 1 ] NEW_LINE DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] == b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def countNumberOfTriangles ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) * ( n - 2 ) // 6 ) NEW_LINE DEDENT
def printSorted ( arr , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return NEW_LINE DEDENT printSorted ( arr , start * 2 + 1 , end ) NEW_LINE print ( arr [ start ] , end = " ▁ " ) NEW_LINE printSorted ( arr , start * 2 + 2 , end ) NEW_LINE DEDENT
def search ( mat , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < n and j >= 0 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == x ) : NEW_LINE INDENT print ( " n ▁ Found ▁ at ▁ " , i , " , ▁ " , j ) NEW_LINE return 1 NEW_LINE DEDENT if ( mat [ i ] [ j ] > x ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( " Element ▁ not ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
def findInteger ( arr , n ) : NEW_LINE INDENT neg = 0 NEW_LINE pos = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT return ( sum / abs ( neg - pos ) ) NEW_LINE DEDENT
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum = sum + int ( num [ i ] ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res = res + countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = " " ) NEW_LINE DEDENT for i in range ( 1 , int ( N / 9 ) + 1 ) : NEW_LINE INDENT print ( "9" , end = " " ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( " Touch " ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( " Intersect " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT d1 = d1 + arr [ i ] [ i ] NEW_LINE d2 = d2 + arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT return abs ( d1 - d2 ) NEW_LINE DEDENT
def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 ) ) NEW_LINE DEDENT
def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index NEW_LINE DEDENT
def lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT back_up = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if j == i : NEW_LINE INDENT a [ j ] = 1 NEW_LINE DEDENT elif s [ i ] == s [ j ] : NEW_LINE INDENT temp = a [ j ] NEW_LINE a [ j ] = back_up + 2 NEW_LINE back_up = temp NEW_LINE DEDENT else : NEW_LINE INDENT back_up = a [ j ] NEW_LINE a [ j ] = max ( a [ j - 1 ] , a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return a [ n - 1 ] NEW_LINE DEDENT
def squareRoot ( n ) : NEW_LINE INDENT return pow ( 2 , 0.5 * math . log2 ( n ) ) NEW_LINE DEDENT
def printSmall ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , n ) : NEW_LINE INDENT max_var = arr [ k - 1 ] NEW_LINE pos = k - 1 NEW_LINE for j in range ( k - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] > max_var ) : NEW_LINE INDENT max_var = arr [ j ] NEW_LINE pos = j NEW_LINE DEDENT DEDENT if ( max_var > arr [ i ] ) : NEW_LINE INDENT j = pos NEW_LINE while ( j < k - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT arr [ k - 1 ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) NEW_LINE c = ( float ) ( sum_y - m * sum_x ) / n NEW_LINE print ( " m ▁ = ▁ " , m ) NEW_LINE print ( " c ▁ = ▁ " , c ) NEW_LINE DEDENT
def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) NEW_LINE res = 1 NEW_LINE sign = 1 NEW_LINE fact = 1 NEW_LINE pow = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) NEW_LINE pow = pow * x * x NEW_LINE res = res + sign * pow / fact NEW_LINE DEDENT return res NEW_LINE DEDENT
def printArray ( matrix ) : NEW_LINE INDENT rowCount = len ( matrix ) NEW_LINE if rowCount == 0 : NEW_LINE INDENT return NEW_LINE DEDENT columnCount = len ( matrix [ 0 ] ) NEW_LINE if columnCount == 0 : NEW_LINE INDENT return NEW_LINE DEDENT row_output_format = " ▁ " . join ( [ " % s " ] * columnCount ) NEW_LINE printed = { } NEW_LINE for row in matrix : NEW_LINE INDENT routput = row_output_format % tuple ( row ) NEW_LINE if routput not in printed : NEW_LINE INDENT printed [ routput ] = True NEW_LINE print ( routput ) NEW_LINE DEDENT DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
def countWays ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 1000000007 NEW_LINE same , diff = 0 , k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = total * ( k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = ( same + diff ) % mod NEW_LINE DEDENT return total NEW_LINE DEDENT
def linearSearch ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] is i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def pad ( n ) : NEW_LINE INDENT pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT pNext = pPrevPrev + pPrev NEW_LINE pPrevPrev = pPrev NEW_LINE pPrev = pCurr NEW_LINE pCurr = pNext NEW_LINE DEDENT return pNext ; NEW_LINE DEDENT
def maxLevel ( boxes , n ) : NEW_LINE INDENT boxes . sort ( ) NEW_LINE ans = 1 NEW_LINE prev_width = boxes [ 0 ] NEW_LINE prev_count = 1 NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_width += boxes [ i ] NEW_LINE curr_count += 1 NEW_LINE if ( curr_width > prev_width and curr_count > prev_count ) : NEW_LINE INDENT prev_width = curr_width NEW_LINE prev_count = curr_count NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def MaximumHeight ( a , n ) : NEW_LINE INDENT return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) // 2 NEW_LINE DEDENT
def compute ( graph , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( len ( graph [ i ] ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT
def productArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE prod = [ 0 ] * n NEW_LINE left [ 0 ] = 1 NEW_LINE right [ n - 1 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT left [ i ] = arr [ i - 1 ] * left [ i - 1 ] NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT right [ j ] = arr [ j + 1 ] * right [ j + 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT prod [ i ] = left [ i ] * right [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def findPairs ( arr1 , arr2 , n , m , x ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( ( x - arr2 [ j ] ) in s ) : NEW_LINE INDENT print ( ( x - arr2 [ j ] ) , ' ' , arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) NEW_LINE DEDENT
def printKDistinct ( arr , size , KthIndex ) : NEW_LINE INDENT dict = { } NEW_LINE vect = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in dict ) : NEW_LINE INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( dict [ arr [ i ] ] > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT KthIndex = KthIndex - 1 NEW_LINE DEDENT if ( KthIndex == 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minInsertion ( tr1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE count = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] % 2 == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( res == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return res - 1 NEW_LINE DEDENT DEDENT
def printStringAlternate ( string ) : NEW_LINE INDENT occ = { } NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT temp = string [ i ] . lower ( ) NEW_LINE occ [ temp ] = occ . get ( temp , 0 ) + 1 NEW_LINE if occ [ temp ] & 1 : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT maxA = - 100000000 NEW_LINE maxB = - 100000000 NEW_LINE maxC = - 100000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > maxA ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = maxA NEW_LINE maxA = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxB ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxC ) : NEW_LINE INDENT maxC = arr [ i ] NEW_LINE DEDENT DEDENT return ( maxA + maxB + maxC ) NEW_LINE DEDENT
def dayofweek ( d , m , y ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE y -= m < 3 NEW_LINE return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 ) NEW_LINE DEDENT
def longestSubsequence ( a , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 13 ) } NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] - 1 ) in mp ) : NEW_LINE INDENT lastIndex = mp [ a [ i ] - 1 ] - 1 NEW_LINE dp [ i ] = 1 + dp [ lastIndex ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT mp [ a [ i ] ] = i + 1 NEW_LINE if ( maximum < dp [ i ] ) : NEW_LINE INDENT maximum = dp [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT for curr in range ( a [ index ] - maximum + 1 , a [ index ] + 1 , 1 ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def isPowerOfK ( n , k ) : NEW_LINE INDENT oneSeen = False NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % k NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT if ( oneSeen ) : NEW_LINE INDENT return False NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT n //= k NEW_LINE DEDENT return True NEW_LINE DEDENT
def calculate ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE DEDENT
def findIndex ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE open = [ None ] * ( l + 1 ) NEW_LINE close = [ None ] * ( l + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ l ] = 0 NEW_LINE if ( str [ 0 ] == ' ( ' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ l - 1 ] == ' ) ' ) : NEW_LINE INDENT close [ l - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ) ' ) : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT close [ i ] = close [ i + 1 ] NEW_LINE DEDENT DEDENT if ( open [ l ] == 0 ) : NEW_LINE INDENT return len NEW_LINE DEDENT if ( close [ 0 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( l + 1 ) : NEW_LINE INDENT if ( open [ i ] == close [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def findTriplets ( arr , n ) : NEW_LINE INDENT found = True NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] , arr [ k ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ not ▁ exist ▁ " ) NEW_LINE DEDENT DEDENT
def getIndexInSortedArray ( arr , n , idx ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ idx ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( arr [ i ] == arr [ idx ] and i < idx ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT
def longestRepeatedSubstring ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE LCSRe = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE res = " " NEW_LINE res_length = 0 NEW_LINE index = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) : NEW_LINE INDENT LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 NEW_LINE if ( LCSRe [ i ] [ j ] > res_length ) : NEW_LINE INDENT res_length = LCSRe [ i ] [ j ] NEW_LINE index = max ( i , index ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT LCSRe [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT if ( res_length > 0 ) : NEW_LINE INDENT for i in range ( index - res_length + 1 , index + 1 ) : NEW_LINE INDENT res = res + str [ i - 1 ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT swapped = False NEW_LINE for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if swapped == False : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def minStepToDeleteString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] NEW_LINE for l in range ( 1 , N + 1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = l - 1 NEW_LINE while j < N : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT for K in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ K ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT
def floorSearch ( arr , low , high , x ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( x >= arr [ high ] ) : NEW_LINE INDENT return high NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( x < arr [ mid ] ) : NEW_LINE INDENT return floorSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT return floorSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT
def areAnagram ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if n1 != n2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT str1 = sorted ( str1 ) NEW_LINE str2 = sorted ( str2 ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def findMaxSegment ( s , k ) : NEW_LINE INDENT seg_len = len ( s ) - k NEW_LINE res = 0 NEW_LINE for i in range ( seg_len ) : NEW_LINE INDENT res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT seg_len_pow = pow ( 10 , seg_len - 1 ) NEW_LINE curr_val = res NEW_LINE for i in range ( 1 , len ( s ) - seg_len ) : NEW_LINE INDENT curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_len_pow NEW_LINE curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( '0' ) ) ) NEW_LINE res = max ( res , curr_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def rearrangeArray ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE tempArr = [ 0 ] * ( n + 1 ) NEW_LINE ArrIndex = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i <= n // 2 or j > n // 2 ) : NEW_LINE INDENT tempArr [ ArrIndex ] = arr [ i ] NEW_LINE ArrIndex = ArrIndex + 1 NEW_LINE tempArr [ ArrIndex ] = arr [ j ] NEW_LINE ArrIndex = ArrIndex + 1 NEW_LINE i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = tempArr [ i ] NEW_LINE DEDENT DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 res = arr [ 0 ] curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT
def minSum ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE num1 , num2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT num1 = num1 * 10 + a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT num2 = num2 * 10 + a [ i ] NEW_LINE DEDENT DEDENT return num2 + num1 NEW_LINE DEDENT
def perfectSquare ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = - 1 NEW_LINE num = " " NEW_LINE for i in range ( 1 , ( 1 << n ) ) : NEW_LINE INDENT str = " " NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) : NEW_LINE INDENT str = str + s [ j ] NEW_LINE DEDENT DEDENT if ( str [ 0 ] != '0' ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT k = int ( math . sqrt ( temp ) ) NEW_LINE if ( k * k == temp ) : NEW_LINE INDENT if ( ans < len ( str ) ) : NEW_LINE INDENT ans = len ( str ) NEW_LINE num = str NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ans == - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT print ( " { } ▁ " . format ( num ) , end = " " ) NEW_LINE return n - ans NEW_LINE DEDENT DEDENT
def checkplusperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x // 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x // 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT
def checkStackPermutation ( ip , op , n ) : NEW_LINE INDENT Input = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Input . put ( ip [ i ] ) NEW_LINE DEDENT output = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT output . put ( op [ i ] ) NEW_LINE DEDENT tempStack = [ ] NEW_LINE while ( not Input . empty ( ) ) : NEW_LINE INDENT ele = Input . queue [ 0 ] NEW_LINE Input . get ( ) NEW_LINE if ( ele == output . queue [ 0 ] ) : NEW_LINE INDENT output . get ( ) NEW_LINE while ( len ( tempStack ) != 0 ) : NEW_LINE INDENT if ( tempStack [ - 1 ] == output . queue [ 0 ] ) : NEW_LINE INDENT tempStack . pop ( ) NEW_LINE output . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT tempStack . append ( ele ) NEW_LINE DEDENT DEDENT return ( Input . empty ( ) and len ( tempStack ) == 0 ) NEW_LINE DEDENT
def replaceSpaces ( string ) : NEW_LINE INDENT string = string . strip ( ) NEW_LINE i = len ( string ) NEW_LINE space_count = string . count ( ' ▁ ' ) NEW_LINE new_length = i + space_count * 2 NEW_LINE if new_length > MAX : NEW_LINE INDENT return - 1 NEW_LINE DEDENT index = new_length - 1 NEW_LINE string = list ( string ) NEW_LINE for f in range ( i - 2 , new_length - 2 ) : NEW_LINE INDENT string . append ( '0' ) NEW_LINE DEDENT for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT if string [ j ] == ' ▁ ' : NEW_LINE INDENT string [ index ] = '0' NEW_LINE string [ index - 1 ] = '2' NEW_LINE string [ index - 2 ] = ' % ' NEW_LINE index = index - 3 NEW_LINE DEDENT else : NEW_LINE INDENT string [ index ] = string [ j ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT
def nthPalindrome ( n , k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT temp = k // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = k // 2 - 1 NEW_LINE DEDENT palindrome = 10 ** temp NEW_LINE palindrome = palindrome + n - 1 NEW_LINE print ( palindrome , end = " " ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while ( palindrome ) : NEW_LINE INDENT print ( palindrome % 10 , end = " " ) NEW_LINE palindrome = palindrome // 10 NEW_LINE DEDENT DEDENT
def getOddOccurrence ( arr , size ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in Hash : NEW_LINE INDENT if ( Hash [ i ] % 2 != 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findCommon ( mat ) : NEW_LINE INDENT global M NEW_LINE global N NEW_LINE cnt = dict ( ) NEW_LINE cnt = defaultdict ( lambda : 0 , cnt ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < M ) : NEW_LINE INDENT cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 NEW_LINE j = 1 NEW_LINE while ( j < N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) : NEW_LINE INDENT cnt [ mat [ i ] [ j ] ] = cnt [ mat [ i ] [ j ] ] + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT for ele in cnt : NEW_LINE INDENT if ( cnt [ ele ] == M ) : NEW_LINE INDENT return ele NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minCost ( coin , n , k ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE coins_needed = math . ceil ( 1.0 * n // ( k + 1 ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( coins_needed - 1 + 1 ) : NEW_LINE INDENT ans += coin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSum ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) > len ( str2 ) : NEW_LINE INDENT temp = str1 NEW_LINE str1 = str2 NEW_LINE str2 = temp NEW_LINE DEDENT str3 = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE diff = n2 - n1 NEW_LINE carry = 0 NEW_LINE for i in range ( n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT for i in range ( n2 - n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str3 + str ( carry + '0' ) NEW_LINE DEDENT str3 = str3 [ : : - 1 ] NEW_LINE return str3 NEW_LINE DEDENT
def findRepeatFirstN2 ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( p != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT
def unitnumber ( x , y ) : NEW_LINE INDENT x = x % 10 NEW_LINE if y != 0 : NEW_LINE INDENT y = y % 4 + 4 NEW_LINE DEDENT return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 ) NEW_LINE DEDENT
def policeThief ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE res = 0 NEW_LINE thi = [ ] NEW_LINE pol = [ ] NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == ' P ' : NEW_LINE INDENT pol . append ( i ) NEW_LINE DEDENT elif arr [ i ] == ' T ' : NEW_LINE INDENT thi . append ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while l < len ( thi ) and r < len ( pol ) : NEW_LINE INDENT if ( abs ( thi [ l ] - pol [ r ] ) <= k ) : NEW_LINE INDENT res += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif thi [ l ] < pol [ r ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def calculate ( A , B , C , M ) : NEW_LINE INDENT res = pow ( B , C , M - 1 ) NEW_LINE ans = pow ( A , res , M ) NEW_LINE return ans NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT
def unique ( mat , n , m ) : NEW_LINE INDENT maximum = 0 flag = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( maximum < mat [ i ] [ j ] ) : NEW_LINE INDENT maximum = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT uniqueElementDict = [ 0 ] * ( maximum + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT uniqueElementDict [ mat [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT for key in range ( maximum + 1 ) : NEW_LINE INDENT if uniqueElementDict [ key ] == 1 : NEW_LINE INDENT print ( key , end = " ▁ " ) NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " No ▁ unique ▁ element ▁ in ▁ the ▁ matrix " ) NEW_LINE DEDENT DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
def countSubSets ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE even_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in us : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT return pow ( 2 , even_count ) - 1 NEW_LINE DEDENT
def findSubarraySum ( arr , n , Sum ) : NEW_LINE INDENT prevSum = defaultdict ( lambda : 0 ) NEW_LINE res = 0 NEW_LINE currsum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT currsum += arr [ i ] NEW_LINE if currsum == Sum : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( currsum - Sum ) in prevSum : NEW_LINE INDENT res += prevSum [ currsum - Sum ] NEW_LINE DEDENT prevSum [ currsum ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def summingSeries ( n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT S += i * i - ( i - 1 ) * ( i - 1 ) NEW_LINE DEDENT return S NEW_LINE DEDENT
def shufleArray ( a , f , l ) : NEW_LINE INDENT if ( l > f ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( l - f == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT mid = int ( ( f + l ) / 2 ) NEW_LINE temp = mid + 1 NEW_LINE mmid = int ( ( f + mid ) / 2 ) NEW_LINE for i in range ( mmid + 1 , mid + 1 ) : NEW_LINE INDENT ( a [ i ] , a [ temp ] ) = ( a [ temp ] , a [ i ] ) NEW_LINE temp += 1 NEW_LINE DEDENT shufleArray ( a , f , mid ) NEW_LINE shufleArray ( a , mid + 1 , l ) NEW_LINE DEDENT
def gcdExtended ( a , b , x , y ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT x = 0 NEW_LINE y = 1 NEW_LINE return b NEW_LINE DEDENT x1 = 1 NEW_LINE y1 = 1 NEW_LINE gcd = gcdExtended ( b % a , a , x1 , y1 ) NEW_LINE x = y1 - ( b / a ) * x1 NEW_LINE y = x1 NEW_LINE return gcd NEW_LINE DEDENT
def generateGrayarr ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT arr = list ( ) NEW_LINE arr . append ( "0" ) NEW_LINE arr . append ( "1" ) NEW_LINE i = 2 NEW_LINE j = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if i >= 1 << n : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr . append ( arr [ j ] ) NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT arr [ j ] = "0" + arr [ j ] NEW_LINE DEDENT for j in range ( i , 2 * i ) : NEW_LINE INDENT arr [ j ] = "1" + arr [ j ] NEW_LINE DEDENT i = i << 1 NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def divSum ( num ) : NEW_LINE INDENT result = 0 NEW_LINE i = 2 NEW_LINE while i <= ( math . sqrt ( num ) ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT if ( i == ( num / i ) ) : NEW_LINE INDENT result = result + i ; NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + num / i ) ; NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return ( result + 1 ) ; NEW_LINE DEDENT
def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE curr_sum = sum - A [ i ] NEW_LINE for j in range ( i + 1 , arr_size ) : NEW_LINE INDENT if ( curr_sum - A [ j ] ) in s : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , curr_sum - A [ j ] ) NEW_LINE return True NEW_LINE DEDENT s . add ( A [ j ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if len1 == 0 or len2 == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = ord ( num1 [ i ] ) - 48 NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = ord ( num2 [ j ] ) - 48 NEW_LINE summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = summ // 10 NEW_LINE result [ i_n1 + i_n2 ] = summ % 10 NEW_LINE i_n2 += 1 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE DEDENT i_n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while ( i >= 0 and result [ i ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT s = " " NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s += chr ( result [ i ] + 48 ) NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def modFact ( n , p ) : NEW_LINE INDENT if n >= p : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result = ( result * i ) % p NEW_LINE DEDENT return result NEW_LINE DEDENT
def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( charCount [ i ] ) : NEW_LINE INDENT print ( chr ( 97 + i ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countFact ( low , high ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 1 NEW_LINE while ( fact < low ) : NEW_LINE INDENT fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT res = 0 NEW_LINE while ( fact <= high ) : NEW_LINE INDENT res += 1 NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def area_of_segment ( radius , angle ) : NEW_LINE INDENT area_of_sector = pi * NEW_LINE INDENT ( radius * radius ) NEW_LINE * ( angle / 360 ) NEW_LINE DEDENT area_of_triangle = 1 / 2 * NEW_LINE INDENT ( radius * radius ) * NEW_LINE math . sin ( ( angle * pi ) / 180 ) NEW_LINE DEDENT return area_of_sector - area_of_triangle ; NEW_LINE DEDENT
def printPrevSmaller ( arr , n ) : NEW_LINE INDENT S = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( S ) > 0 and S [ - 1 ] >= arr [ i ] ) : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT if ( len ( S ) == 0 ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( S [ - 1 ] , end = " , ▁ " ) NEW_LINE DEDENT S . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def checkStar ( mat ) : NEW_LINE INDENT global size NEW_LINE vertexD1 = 0 NEW_LINE vertexDn_1 = 0 NEW_LINE if ( size == 1 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 ) NEW_LINE DEDENT if ( size == 2 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) NEW_LINE DEDENT for i in range ( 0 , size ) : NEW_LINE INDENT degreeI = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT degreeI = degreeI + 1 NEW_LINE DEDENT DEDENT if ( degreeI == 1 ) : NEW_LINE INDENT vertexD1 = vertexD1 + 1 NEW_LINE DEDENT elif ( degreeI == size - 1 ) : NEW_LINE INDENT vertexDn_1 = vertexDn_1 + 1 NEW_LINE DEDENT DEDENT return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 ) NEW_LINE DEDENT
def computeTotient ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " Totient ▁ of ▁ " , i , " ▁ is ▁ " , phi [ i ] ) NEW_LINE DEDENT DEDENT
def findIndex ( n ) : NEW_LINE INDENT fibo = 2.078087 * math . log ( n ) + 1.672276 NEW_LINE return round ( fibo ) NEW_LINE DEDENT
def midPoint ( X1 , Y1 , X2 , Y2 ) : NEW_LINE INDENT dx = X2 - X1 NEW_LINE dy = Y2 - Y1 NEW_LINE d = dy - ( dx / 2 ) NEW_LINE x = X1 NEW_LINE y = Y1 NEW_LINE print ( x , " , " , y , " \n " ) NEW_LINE while ( x < X2 ) : NEW_LINE INDENT x = x + 1 NEW_LINE if ( d < 0 ) : NEW_LINE INDENT d = d + dy NEW_LINE DEDENT else : NEW_LINE INDENT d = d + ( dy - dx ) NEW_LINE y = y + 1 NEW_LINE DEDENT print ( x , " , " , y , " \n " ) NEW_LINE DEDENT DEDENT
def isPossible ( n , index , Sum , M , arr , dp ) : NEW_LINE INDENT global MAX NEW_LINE if index == n : NEW_LINE INDENT if ( Sum % M ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if dp [ index ] [ Sum ] != - 1 : NEW_LINE INDENT return dp [ index ] [ Sum ] NEW_LINE DEDENT placeAdd = isPossible ( n , index + 1 , Sum + arr [ index ] , M , arr , dp ) NEW_LINE placeMinus = isPossible ( n , index + 1 , Sum - arr [ index ] , M , arr , dp ) NEW_LINE res = placeAdd or placeMinus NEW_LINE dp [ index ] [ Sum ] = res NEW_LINE return res NEW_LINE DEDENT
def rearrangeArr ( arr , n ) : NEW_LINE INDENT evenPos = int ( n / 2 ) NEW_LINE oddPos = n - evenPos NEW_LINE tempArr = np . empty ( n , dtype = object ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tempArr [ i ] = arr [ i ] NEW_LINE DEDENT tempArr . sort ( ) NEW_LINE j = oddPos - 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT arr [ i ] = tempArr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT j = oddPos NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT arr [ i ] = tempArr [ j ] NEW_LINE j = j + 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = " ▁ " ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not ( flag ) ) : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def sortString ( str ) : NEW_LINE INDENT charCount = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT charCount [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR , 1 ) : NEW_LINE INDENT for j in range ( 0 , charCount [ i ] , 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def pairWiseConsecutive ( s ) : NEW_LINE INDENT aux = [ ] NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT aux . append ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT result = True NEW_LINE while ( len ( aux ) > 1 ) : NEW_LINE INDENT x = aux [ - 1 ] NEW_LINE aux . pop ( ) NEW_LINE y = aux [ - 1 ] NEW_LINE aux . pop ( ) NEW_LINE if ( abs ( x - y ) != 1 ) : NEW_LINE INDENT result = False NEW_LINE DEDENT s . append ( x ) NEW_LINE s . append ( y ) NEW_LINE DEDENT if ( len ( aux ) == 1 ) : NEW_LINE INDENT s . append ( aux [ - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def nextGreater ( num1 ) : NEW_LINE INDENT l = len ( num1 ) NEW_LINE num = list ( num1 ) NEW_LINE i = l - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( num [ i ] == '0' ) : NEW_LINE INDENT num [ i ] = '1' NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT num [ i ] = '0' NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num1 = ' ' . join ( num ) NEW_LINE if ( i < 0 ) : NEW_LINE INDENT num1 = '1' + num1 NEW_LINE DEDENT return num1 NEW_LINE DEDENT
def Restore_Tree ( S , E ) : NEW_LINE INDENT Identity = N * [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT Identity [ Start [ i ] ] = i NEW_LINE DEDENT parent = N * [ - 1 ] NEW_LINE curr_parent = Identity [ 0 ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT child = Identity [ j ] NEW_LINE if End [ child ] - j > 1 : NEW_LINE INDENT parent [ child ] = curr_parent NEW_LINE curr_parent = child NEW_LINE DEDENT else : NEW_LINE INDENT parent [ child ] = curr_parent NEW_LINE while End [ child ] == End [ parent [ child ] ] : NEW_LINE INDENT child = parent [ child ] NEW_LINE curr_parent = parent [ child ] NEW_LINE if curr_parent == Identity [ 0 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT parent [ i ] += 1 NEW_LINE DEDENT return parent NEW_LINE DEDENT
def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = " ▁ " ) NEW_LINE C = int ( C * ( line - i ) / i ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def subsetDifference ( n ) : NEW_LINE INDENT s = int ( n * ( n + 1 ) / 2 ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Difference ▁ = ▁ " , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 4 == 1 or n % 4 == 2 : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) + 1 ) NEW_LINE print ( " Difference ▁ = ▁ " , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Difference ▁ = ▁ " , 0 ) NEW_LINE DEDENT DEDENT DEDENT
def isReversible ( str ) : NEW_LINE INDENT i = 0 j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def getParity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n : NEW_LINE INDENT parity = ~ parity NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return parity NEW_LINE DEDENT
def maxRepeating ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT cur_count = 1 NEW_LINE for j in range ( i + 1 , l ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT cur_count += 1 NEW_LINE DEDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def seiresSum ( n , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT res -= a [ i ] * a [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printTwoElements ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) - 1 ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ repeating ▁ element ▁ is " , abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT print ( " and ▁ the ▁ missing ▁ element ▁ is " , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def isSubSequence ( str1 , str2 , m , n ) : NEW_LINE INDENT j = 0 NEW_LINE i = 0 NEW_LINE while j < m and i < n : NEW_LINE INDENT if str1 [ j ] == str2 [ i ] : NEW_LINE INDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return j == m NEW_LINE DEDENT
def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 2 ) / 2 ) NEW_LINE marked = [ 0 ] * ( nNew + 1 ) NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findTwoscomplement ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return '1' + str NEW_LINE DEDENT k = i - 1 NEW_LINE while ( k >= 0 ) : NEW_LINE INDENT if ( str [ k ] == '1' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE str [ k ] = '0' NEW_LINE str = ' ' . join ( str ) NEW_LINE DEDENT else : NEW_LINE INDENT str = list ( str ) NEW_LINE str [ k ] = '1' NEW_LINE str = ' ' . join ( str ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT
def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE min_len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_sum <= x and end < n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE end += 1 NEW_LINE DEDENT while ( curr_sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_len ) : NEW_LINE INDENT min_len = end - start NEW_LINE DEDENT curr_sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return min_len NEW_LINE DEDENT
def Circumference ( l , w ) : NEW_LINE INDENT return ( 2 * ( l + w ) ) NEW_LINE DEDENT
def sortString ( str ) : NEW_LINE INDENT str = ' ' . join ( sorted ( str ) ) NEW_LINE print ( str ) NEW_LINE DEDENT
def countPair ( a , b ) : NEW_LINE INDENT s = str ( b ) NEW_LINE i = 0 NEW_LINE while i < ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != '9' ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT result = 0 NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT result = a * len ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT result = a * ( len ( s ) - 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def minOperations ( str , n ) : NEW_LINE INDENT lastUpper = - 1 NEW_LINE firstLower = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT lastUpper = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] . islower ( ) ) : NEW_LINE INDENT firstLower = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( lastUpper == - 1 or firstLower == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT countUpper = 0 NEW_LINE for i in range ( firstLower , n ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT countUpper += 1 NEW_LINE DEDENT DEDENT countLower = 0 NEW_LINE for i in range ( lastUpper ) : NEW_LINE INDENT if ( str [ i ] . islower ( ) ) : NEW_LINE INDENT countLower += 1 NEW_LINE DEDENT DEDENT return min ( countLower , countUpper ) NEW_LINE DEDENT
def findSmallest ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] <= res : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printMaxOfMin ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE left = [ - 1 ] * ( n + 1 ) NEW_LINE right = [ n ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( len ( s ) != 0 ) : NEW_LINE INDENT left [ i ] = s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( len ( s ) != 0 ) : NEW_LINE INDENT right [ i ] = s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT ans = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT ans [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT Len = right [ i ] - left [ i ] - 1 NEW_LINE ans [ Len ] = max ( ans [ Len ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def ReversespiralPrint ( m , n , a ) : NEW_LINE INDENT b = [ 0 for i in range ( 100 ) ] NEW_LINE i , k , l = 0 , 0 , 0 NEW_LINE z = 0 NEW_LINE size = m * n NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT val = 0 NEW_LINE for i in range ( l , n ) : NEW_LINE INDENT val = a [ k ] [ i ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT val = a [ i ] [ n - 1 ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT val = a [ m - 1 ] [ i ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT DEDENT m -= 1 NEW_LINE if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT val = a [ i ] [ l ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) / 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def pairInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT
def MinOperation ( a , n , k ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 1 and a [ i ] > k ) : NEW_LINE INDENT result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + k - a [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum / 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def areaOfInscribedCircle ( a ) : NEW_LINE INDENT return ( PI / 4 ) * a * a NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxsize - 1 NEW_LINE max_ending_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here += a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ % d " % ( max_so_far ) ) NEW_LINE print ( " Starting ▁ Index ▁ % d " % ( start ) ) NEW_LINE print ( " Ending ▁ Index ▁ % d " % ( end ) ) NEW_LINE DEDENT
def subsetGraph ( C ) : NEW_LINE INDENT global N NEW_LINE vertices = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT vertices . add ( i ) NEW_LINE DEDENT while ( len ( vertices ) != 0 ) : NEW_LINE INDENT if ( len ( vertices ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT someone_removed = False NEW_LINE for x in vertices : NEW_LINE INDENT values = set ( ) NEW_LINE for y in vertices : NEW_LINE INDENT if ( y != x ) : NEW_LINE INDENT values . add ( C [ x ] [ y ] ) NEW_LINE DEDENT DEDENT if ( len ( values ) == 1 ) : NEW_LINE INDENT vertices . remove ( x ) NEW_LINE someone_removed = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not someone_removed ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return len ( vertices ) NEW_LINE DEDENT
def maxXOR ( mat , N ) : NEW_LINE INDENT max_xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT r_xor = r_xor ^ mat [ i ] [ j ] NEW_LINE c_xor = c_xor ^ mat [ j ] [ i ] NEW_LINE DEDENT if ( max_xor < max ( r_xor , c_xor ) ) : NEW_LINE INDENT max_xor = max ( r_xor , c_xor ) NEW_LINE DEDENT DEDENT return max_xor NEW_LINE DEDENT
def countSubsequences ( s ) : NEW_LINE INDENT aCount = 0 NEW_LINE bCount = 0 NEW_LINE cCount = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT aCount = ( 1 + 2 * aCount ) NEW_LINE DEDENT elif ( s [ i ] == ' b ' ) : NEW_LINE INDENT bCount = ( aCount + 2 * bCount ) NEW_LINE DEDENT elif ( s [ i ] == ' c ' ) : NEW_LINE INDENT cCount = ( bCount + 2 * cCount ) NEW_LINE DEDENT DEDENT return cCount NEW_LINE DEDENT
def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def printRoots ( n ) : NEW_LINE INDENT theta = math . pi * 2 / n NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT real = math . cos ( k * theta ) NEW_LINE img = math . sin ( k * theta ) NEW_LINE print ( real , end = " ▁ " ) NEW_LINE if ( img >= 0 ) : NEW_LINE INDENT print ( " ▁ + ▁ i ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ - ▁ i ▁ " , end = " ▁ " ) NEW_LINE DEDENT print ( abs ( img ) ) NEW_LINE DEDENT DEDENT
def SieveOfAtkin ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = " ▁ " ) NEW_LINE DEDENT sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def smallestKFreq ( arr , n , k ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = sys . maxsize NEW_LINE res1 = sys . maxsize NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values == k : NEW_LINE INDENT res = min ( res , key ) NEW_LINE DEDENT DEDENT return res if res != res1 else - 1 NEW_LINE DEDENT
def minimumflip ( mat , n ) : NEW_LINE INDENT transpose = [ [ 0 ] * n ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT transpose [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if transpose [ i ] [ j ] != mat [ i ] [ j ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( flip / 2 ) NEW_LINE DEDENT
def minAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if arr_size < 2 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_sum ) > abs ( sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are " , arr [ min_l ] , " and ▁ " , arr [ min_r ] ) NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return NEW_LINE DEDENT a = arr [ 0 ] b = arr [ 1 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] > a * b ) : NEW_LINE INDENT a = arr [ i ] b = arr [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , a , " , " , b , " } " , sep = " " ) NEW_LINE DEDENT
def pageFaults ( pages , n , capacity ) : NEW_LINE INDENT s = set ( ) NEW_LINE indexes = Queue ( ) NEW_LINE page_faults = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( s ) < capacity ) : NEW_LINE INDENT if ( pages [ i ] not in s ) : NEW_LINE INDENT s . add ( pages [ i ] ) NEW_LINE page_faults += 1 NEW_LINE indexes . put ( pages [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( pages [ i ] not in s ) : NEW_LINE INDENT val = indexes . queue [ 0 ] NEW_LINE indexes . get ( ) NEW_LINE s . remove ( val ) NEW_LINE s . add ( pages [ i ] ) NEW_LINE indexes . put ( pages [ i ] ) NEW_LINE page_faults += 1 NEW_LINE DEDENT DEDENT DEDENT return page_faults NEW_LINE DEDENT
def nextfit ( weight , c ) : NEW_LINE INDENT res = 0 NEW_LINE rem = c NEW_LINE for _ in range ( len ( weight ) ) : NEW_LINE INDENT if rem >= weight [ _ ] : NEW_LINE INDENT rem = rem - weight [ _ ] NEW_LINE DEDENT else : NEW_LINE INDENT res += 1 NEW_LINE rem = c - weight [ _ ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count , l , r = 0 , 0 , n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE count += 1 NEW_LINE DEDENT elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def circumferenceparallelogram ( a , b ) : NEW_LINE INDENT return ( ( 2 * a ) + ( 2 * b ) ) NEW_LINE DEDENT
def Print ( n , k ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = " " ) NEW_LINE rem = ( 10 * rem ) % n NEW_LINE DEDENT DEDENT
def findString ( n , k ) : NEW_LINE INDENT res = " " NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + count ) NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT count = 0 ; NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def checkForSorting ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def round ( n ) : NEW_LINE INDENT a = ( n // 10 ) * 10 NEW_LINE b = a + 10 NEW_LINE return ( b if n - a > b - n else a ) NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT if ( divisor == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( divisor < 0 ) : NEW_LINE INDENT divisor = - divisor NEW_LINE DEDENT if ( num < 0 ) : NEW_LINE INDENT num = - num NEW_LINE DEDENT i = 1 NEW_LINE product = 0 NEW_LINE while ( product <= num ) : NEW_LINE INDENT product = divisor * i NEW_LINE i += 1 NEW_LINE DEDENT return num - ( product - divisor ) NEW_LINE DEDENT
def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def costToBalance ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT ans = 0 NEW_LINE o = 0 NEW_LINE c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT o += 1 NEW_LINE DEDENT if ( s [ i ] == ' ) ' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( o != c ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = [ 0 for i in range ( len ( s ) ) ] NEW_LINE if ( s [ 0 ] == ' ( ' ) : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ 0 ] = - 1 NEW_LINE DEDENT if ( a [ 0 ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i - 1 ] - 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxint - 1 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def countSub ( arr , n ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - 1 , - 1 , - 1 ) : NEW_LINE INDENT count [ arr [ i ] ] += count [ j ] NEW_LINE DEDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT result += count [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def countMinReversals ( expr ) : NEW_LINE INDENT lenn = len ( expr ) NEW_LINE if ( lenn % 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( expr [ i ] == ' ' and len ( s ) ) : NEW_LINE INDENT if ( s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT red_len = len ( s ) NEW_LINE n = 0 NEW_LINE while ( len ( s ) and s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE n += 1 NEW_LINE DEDENT return ( red_len // 2 + n % 2 ) NEW_LINE DEDENT
def printPairs ( arr , n , k ) : NEW_LINE INDENT isPairFound = True NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and arr [ i ] % arr [ j ] == k ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , sep = " " , end = " ▁ " ) NEW_LINE isPairFound = True NEW_LINE DEDENT DEDENT DEDENT return isPairFound NEW_LINE DEDENT
def findRepeatFirst ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE hash = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE pos = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE if ( hash [ k ] == 0 ) : NEW_LINE INDENT hash [ k ] += 1 NEW_LINE pos [ k ] = i NEW_LINE DEDENT elif ( hash [ k ] == 1 ) : NEW_LINE INDENT hash [ k ] += 1 NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( hash [ i ] == 2 ) : NEW_LINE INDENT if ( p == - 1 ) : NEW_LINE INDENT p = pos [ i ] NEW_LINE DEDENT elif ( p > pos [ i ] ) : NEW_LINE INDENT p = pos [ i ] NEW_LINE DEDENT DEDENT DEDENT return p NEW_LINE DEDENT
def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] NEW_LINE DEDENT nibble = num & 0xf NEW_LINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
def printDiagonalSums ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT principal += mat [ i ] [ j ] NEW_LINE DEDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT secondary += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal : " , principal ) NEW_LINE print ( " Secondary ▁ Diagonal : " , secondary ) NEW_LINE DEDENT
def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) NEW_LINE DEDENT
def findPlatform ( arr , dep , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dep . sort ( ) NEW_LINE plat_needed = 1 NEW_LINE result = 1 NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arr [ i ] < dep [ j ] ) : NEW_LINE INDENT plat_needed += 1 NEW_LINE i += 1 NEW_LINE if ( plat_needed > result ) : NEW_LINE INDENT result = plat_needed NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT plat_needed -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT
def sumOfLargePrimeFactor ( n ) : NEW_LINE INDENT prime = [ 0 ] * ( n + 1 ) NEW_LINE sum = 0 NEW_LINE max = int ( n / 2 ) NEW_LINE for p in range ( 2 , max + 1 ) : NEW_LINE INDENT if prime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = p NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT sum += prime [ p ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def minJumps ( a , b , d ) : NEW_LINE INDENT temp = a NEW_LINE a = min ( a , b ) NEW_LINE b = max ( temp , b ) NEW_LINE if ( d >= b ) : NEW_LINE INDENT return ( d + b - 1 ) / b NEW_LINE DEDENT if ( d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( d == a ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def permutatedRows ( mat , m , n , r ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( mat [ r ] [ j ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if i == r : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] not in s : NEW_LINE INDENT j = j - 2 NEW_LINE break NEW_LINE DEDENT DEDENT if j + 1 != n : NEW_LINE INDENT continue NEW_LINE DEDENT print ( i ) NEW_LINE DEDENT DEDENT
def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE print ( num , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def ZigZag ( rows , columns , numbers ) : NEW_LINE INDENT k = 0 NEW_LINE arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ] NEW_LINE for i in range ( rows ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < columns and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT j = columns - 1 NEW_LINE while j >= 0 and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT for i in arr : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def findElement ( arr , ranges , rotations , index ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index = index - 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT
def smallestNumber ( num ) : NEW_LINE INDENT num = list ( num ) NEW_LINE n = len ( num ) NEW_LINE rightMin = [ 0 ] * n NEW_LINE right = 0 NEW_LINE rightMin [ n - 1 ] = - 1 ; NEW_LINE right = n - 1 ; NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if num [ i ] > num [ right ] : NEW_LINE INDENT rightMin [ i ] = right NEW_LINE DEDENT else : NEW_LINE INDENT rightMin [ i ] = - 1 NEW_LINE right = i NEW_LINE DEDENT DEDENT small = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if num [ i ] != '0' : NEW_LINE INDENT if small == - 1 : NEW_LINE INDENT if num [ i ] < num [ 0 ] : NEW_LINE INDENT small = i NEW_LINE DEDENT DEDENT elif num [ i ] < num [ small ] : NEW_LINE INDENT small = i NEW_LINE DEDENT DEDENT DEDENT if small != - 1 : NEW_LINE INDENT num [ 0 ] , num [ small ] = num [ small ] , num [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if rightMin [ i ] != - 1 : NEW_LINE INDENT num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ] ] , num [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return ' ' . join ( num ) NEW_LINE DEDENT
def countPaths ( maze ) : NEW_LINE INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT if ( maze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( maze [ 0 ] [ i ] == 0 ) : NEW_LINE INDENT maze [ 0 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , R , 1 ) : NEW_LINE INDENT for j in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( maze [ i ] [ j ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( maze [ i - 1 ] [ j ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( maze [ i ] [ j - 1 ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : NEW_LINE INDENT return maze [ R - 1 ] [ C - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def minMaxLengthWords ( inp ) : NEW_LINE INDENT length = len ( inp ) NEW_LINE si = ei = 0 NEW_LINE min_length = length NEW_LINE min_start_index = max_length = max_start_index = 0 NEW_LINE while ei <= length : NEW_LINE INDENT if ( ei < length ) and ( inp [ ei ] != " ▁ " ) : NEW_LINE INDENT ei += 1 NEW_LINE DEDENT else : NEW_LINE INDENT curr_length = ei - si NEW_LINE if curr_length < min_length : NEW_LINE INDENT min_length = curr_length NEW_LINE min_start_index = si NEW_LINE DEDENT if curr_length > max_length : NEW_LINE INDENT max_length = curr_length NEW_LINE max_start_index = si NEW_LINE DEDENT ei += 1 NEW_LINE si = ei NEW_LINE DEDENT DEDENT minWord = inp [ min_start_index : min_start_index + min_length ] NEW_LINE maxWord = inp [ max_start_index : max_length ] NEW_LINE print ( " Minimum ▁ length ▁ word : ▁ " , minWord ) NEW_LINE print ( " Maximum ▁ length ▁ word : ▁ " , maxWord ) NEW_LINE DEDENT
def findVolume ( l , b , h ) : NEW_LINE INDENT return ( ( l * b * h ) / 2 ) NEW_LINE DEDENT
def sortString ( str , n ) : NEW_LINE INDENT new_str = " " NEW_LINE for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( str [ j ] == chr ( i ) ) : NEW_LINE INDENT new_str += str [ j ] NEW_LINE DEDENT DEDENT DEDENT return new_str NEW_LINE DEDENT
def countTrees ( n ) : NEW_LINE INDENT BT = [ 0 ] * ( n + 1 ) NEW_LINE BT [ 0 ] = BT [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT BT [ i ] += BT [ j ] * BT [ i - j - 1 ] NEW_LINE DEDENT DEDENT return BT [ n ] NEW_LINE DEDENT
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def check ( num ) : NEW_LINE INDENT digitSum = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rem = num % 10 NEW_LINE digitSum = digitSum + rem NEW_LINE num = num // 10 NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT
def LCSubStr ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE result = 0 NEW_LINE len_mat = np . zeros ( ( 2 , n ) ) NEW_LINE currRow = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 | j == 0 ) : NEW_LINE INDENT len_mat [ currRow ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1 NEW_LINE result = max ( result , len_mat [ currRow ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT len_mat [ currRow ] [ j ] = 0 NEW_LINE DEDENT DEDENT currRow = 1 - currRow NEW_LINE DEDENT return result NEW_LINE DEDENT
def removeConsecutiveSame ( v ) : NEW_LINE INDENT n = len ( v ) NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( ( i + 1 ) < len ( v ) ) and ( v [ i ] == v [ i + 1 ] ) : NEW_LINE INDENT v = v [ : i ] NEW_LINE v = v [ : i ] NEW_LINE if ( i > 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT n = n - 2 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return len ( v [ : i - 1 ] ) NEW_LINE DEDENT
def perimeter ( diameter , height ) : NEW_LINE INDENT return 2 * ( diameter + height ) NEW_LINE DEDENT
def isPossibleToMakeDivisible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return ( remainder == 0 ) NEW_LINE DEDENT
def getInvCount ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE invcount = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ k ] : NEW_LINE INDENT invcount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return invcount NEW_LINE DEDENT
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n // 2 ) NEW_LINE DEDENT print ( n % 2 , end = " " ) NEW_LINE DEDENT
def minSum ( ar , n ) : NEW_LINE INDENT if ( n <= 4 ) : NEW_LINE INDENT return min ( ar ) NEW_LINE DEDENT sum = [ 0 for i in range ( n ) ] NEW_LINE sum [ 0 ] = ar [ 0 ] NEW_LINE sum [ 1 ] = ar [ 1 ] NEW_LINE sum [ 2 ] = ar [ 2 ] NEW_LINE sum [ 3 ] = ar [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) NEW_LINE DEDENT return min ( sum [ n - 4 : n ] ) NEW_LINE DEDENT
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT for i in range ( 0 , n1 ) : NEW_LINE INDENT for j in range ( 0 , n2 ) : NEW_LINE INDENT for k in range ( 0 , n3 ) : NEW_LINE INDENT if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def minDist ( arr , n , x , y ) : NEW_LINE INDENT min_dist = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x or arr [ i ] == y : NEW_LINE INDENT prev = i NEW_LINE break NEW_LINE DEDENT DEDENT while i < n : NEW_LINE INDENT if arr [ i ] == x or arr [ i ] == y : NEW_LINE INDENT if arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist : NEW_LINE INDENT min_dist = i - prev NEW_LINE prev = i NEW_LINE DEDENT else : NEW_LINE INDENT prev = i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return min_dist NEW_LINE DEDENT
def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += a [ i ] + b [ i ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if s % n != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s // n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if a [ i ] == x : NEW_LINE INDENT continue NEW_LINE DEDENT y = a [ i ] + b [ i ] NEW_LINE if i + 1 < n : NEW_LINE INDENT y += b [ i + 1 ] NEW_LINE DEDENT if y == x : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE if i + 1 < n : b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT if a [ i ] + b [ i ] == x : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if i + 1 < n and a [ i ] + b [ i + 1 ] == x : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def findString ( str , n , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE return NEW_LINE DEDENT str2 = str NEW_LINE p = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( str2 [ i ] != ' a ' ) : NEW_LINE INDENT str2 = str2 . replace ( str2 [ i ] , ' a ' ) NEW_LINE p += 1 NEW_LINE if ( p == k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( p < k ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str [ i ] == ' a ' ) : NEW_LINE INDENT str2 = str2 . replace ( str2 [ i ] , ' b ' ) NEW_LINE p += 1 NEW_LINE DEDENT if ( p == k ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT print ( str2 ) NEW_LINE DEDENT
def findLongestRepeatingSubSeq ( X , m , n ) : NEW_LINE INDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT dp [ m ] [ n ] = 0 NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT if ( X [ m - 1 ] == X [ n - 1 ] and m != n ) : NEW_LINE INDENT dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT
def productSubSeqCount ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ k ] [ n ] NEW_LINE DEDENT
def pow ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = a NEW_LINE increment = a NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( 1 , a ) : NEW_LINE INDENT answer += increment NEW_LINE DEDENT increment = answer NEW_LINE DEDENT return answer NEW_LINE DEDENT
def fix ( A , len ) : NEW_LINE INDENT for i in range ( 0 , len ) : NEW_LINE INDENT if ( A [ i ] != - 1 and A [ i ] != i ) : NEW_LINE INDENT x = A [ i ] NEW_LINE while ( A [ x ] != - 1 and A [ x ] != x ) : NEW_LINE INDENT y = A [ x ] NEW_LINE A [ x ] = x NEW_LINE x = y NEW_LINE DEDENT A [ x ] = x NEW_LINE if ( A [ i ] != i ) : NEW_LINE INDENT A [ i ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = [ ] NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT s . append ( ( a [ i ] + a [ j ] ) ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT mini = min ( s ) NEW_LINE maxi = max ( s ) NEW_LINE return abs ( maxi - mini ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT
def calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( 10 ) : NEW_LINE INDENT for m in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if ( i + j + k == l + m + n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c < ans ) : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
def sortInWave ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT
def search ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return None NEW_LINE DEDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = ( low + high ) / 2 ; NEW_LINE if mid % 2 == 0 : NEW_LINE INDENT if arr [ mid ] == arr [ mid + 1 ] : NEW_LINE INDENT return search ( arr , mid + 2 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ mid ] == arr [ mid - 1 ] : NEW_LINE INDENT return search ( arr , mid + 1 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT
def stirlingFactorial ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT e = 2.71 NEW_LINE z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) NEW_LINE return math . floor ( z ) NEW_LINE DEDENT
def checkCount ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] == arr [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count > 2 * k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def zigzag ( n , k ) : NEW_LINE INDENT if ( n == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) NEW_LINE DEDENT
def lcs ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] NEW_LINE bi = bool NEW_LINE for i in range ( m ) : NEW_LINE INDENT bi = i & 1 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ bi ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ bi ] [ n ] NEW_LINE DEDENT
def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( k , n ) : NEW_LINE INDENT if ( not Di ) : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = ' ▁ ' ) NEW_LINE DEDENT while Di and Di [ 0 ] <= ( i - k ) : NEW_LINE INDENT Di . popleft ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) NEW_LINE DEDENT DEDENT if not Di : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findRoot ( arr , n ) : NEW_LINE INDENT root = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT root += ( arr [ i ] [ 0 ] - arr [ i ] [ 1 ] ) NEW_LINE DEDENT return root NEW_LINE DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE continue NEW_LINE DEDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT return ( first * second ) NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT max_ele = arr [ n - 1 ] NEW_LINE min_ele = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] = max_ele NEW_LINE max_ele -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE min_ele += 1 NEW_LINE DEDENT DEDENT DEDENT
def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countLattice ( r ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 4 NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT ySquare = r * r - x * x NEW_LINE y = int ( math . sqrt ( ySquare ) ) NEW_LINE if ( y * y == ySquare ) : NEW_LINE INDENT result += 4 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT
def leafNode ( preorder , n ) : NEW_LINE INDENT s = [ ] NEW_LINE i = 0 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT found = False NEW_LINE if preorder [ i ] > preorder [ j ] : NEW_LINE INDENT s . append ( preorder [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while len ( s ) != 0 : NEW_LINE INDENT if preorder [ j ] > s [ - 1 ] : NEW_LINE INDENT s . pop ( - 1 ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if found : NEW_LINE INDENT print ( preorder [ i ] , end = " ▁ " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( preorder [ n - 1 ] ) NEW_LINE DEDENT
def isSubset ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( arr2 [ i ] == arr1 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def multiplyBySeven ( n ) : NEW_LINE INDENT return ( ( n << 3 ) - n ) NEW_LINE DEDENT
def unboundedKnapsack ( W , n , val , wt ) : NEW_LINE INDENT dp = [ 0 for i in range ( W + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( W + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( wt [ j ] <= i ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT
def alternateSubarray ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ prev ) == 0 ) : NEW_LINE INDENT while ( count ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT count += 1 NEW_LINE prev = arr [ i ] NEW_LINE DEDENT while ( count ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT
def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def modularInverse ( n , prime ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT DP = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 NEW_LINE DP [ 3 ] = 2 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] NEW_LINE DEDENT return DP [ n ] NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return n NEW_LINE DEDENT elif n >= 3 and n < 10 : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT po = 1 NEW_LINE while n / po > 9 : NEW_LINE INDENT po = po * 10 NEW_LINE DEDENT msd = n / po NEW_LINE if msd != 3 : NEW_LINE INDENT return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( msd * po - 1 ) NEW_LINE DEDENT DEDENT
def countPattern ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE oneSeen = False NEW_LINE count = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( s [ i ] == '1' and oneSeen ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( s [ i ] == '1' and oneSeen == 0 ) : NEW_LINE INDENT oneSeen = True NEW_LINE DEDENT if ( s [ i ] != '0' and s [ i ] != '1' ) : NEW_LINE INDENT oneSeen = False NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxRemoval ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE cummulative_sum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] >= cummulative_sum : NEW_LINE INDENT count += 1 NEW_LINE cummulative_sum += arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def LexicographicalMaxString ( str ) : NEW_LINE INDENT mx = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT mx = max ( mx , str [ i : ] ) NEW_LINE DEDENT return mx NEW_LINE DEDENT
