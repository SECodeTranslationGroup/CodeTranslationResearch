def changeEvenBits ( n ) : NEW_LINE INDENT to_subtract = 0 NEW_LINE m = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT to_subtract += ( 1 << m ) NEW_LINE DEDENT m += 2 NEW_LINE x >>= 2 NEW_LINE DEDENT return n - to_subtract NEW_LINE DEDENT
def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT a1 = 2 NEW_LINE b1 = - 3 NEW_LINE c1 = 5 NEW_LINE a2 = 3 NEW_LINE b2 = 4 NEW_LINE c2 = - 7 NEW_LINE a3 = 9 NEW_LINE b3 = - 5 NEW_LINE c3 = 8 NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def FindPairs ( n , k ) : NEW_LINE INDENT print ( 1 , n ) NEW_LINE k -= 1 NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( 1 , i ) NEW_LINE k -= 1 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i != n // i ) : NEW_LINE INDENT print ( 1 , n // i ) NEW_LINE k -= 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def decrypt ( Str , Start , End ) : NEW_LINE INDENT if ( Start > End ) : NEW_LINE INDENT return ; NEW_LINE DEDENT mid = ( Start + End ) >> 1 ; NEW_LINE print ( Str [ mid ] , end = " " ) ; NEW_LINE decrypt ( Str , mid + 1 , End ) ; NEW_LINE decrypt ( Str , Start , mid - 1 ) ; NEW_LINE DEDENT
def prefixDivisble ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % i != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 52248 NEW_LINE if ( prefixDivisble ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minimum_required_operations ( arr , n , k ) : NEW_LINE INDENT answer = 0 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] + arr [ i + 1 ] > k : NEW_LINE INDENT if arr [ i ] > k : NEW_LINE INDENT answer += ( arr [ i ] - k ) NEW_LINE arr [ i ] = k NEW_LINE DEDENT answer += ( arr [ i ] + arr [ i + 1 ] ) - k NEW_LINE arr [ i + 1 ] = ( k - arr [ i ] ) NEW_LINE answer %= mod NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def transpose ( A ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE transpose ( A ) NEW_LINE print ( " Modified ▁ matrix ▁ is " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( A [ i ] [ j ] , " ▁ " , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def checkFactors ( N ) : NEW_LINE INDENT ev_count = 0 ; od_count = 0 ; NEW_LINE for i in range ( 1 , int ( pow ( N , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == N / i ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT if ( ( N / i ) % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ev_count % 2 == 0 and od_count % 2 == 1 ) : NEW_LINE INDENT print ( " Yes " + " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " + " " ) ; NEW_LINE DEDENT DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT oddCount = count * ( count - 1 ) / 2 NEW_LINE return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount ) NEW_LINE DEDENT
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def EnneacontahexagonNum ( n ) : NEW_LINE INDENT return ( 94 * n * n - 92 * n ) // 2 ; NEW_LINE DEDENT
def CountPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 or arr [ j ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def Findpermutation ( n ) : NEW_LINE INDENT a = [ 0 ] * ( n + 1 ) ; NEW_LINE a [ 1 ] = n ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT a [ i ] = i - 1 ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def minTime ( arr , n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT incl_new = arr [ i ] + min ( excl , incl ) NEW_LINE excl_new = incl NEW_LINE incl = incl_new NEW_LINE excl = excl_new NEW_LINE DEDENT return min ( incl , excl ) NEW_LINE DEDENT
def countValues ( x ) : NEW_LINE INDENT count = 0 ; NEW_LINE n = 1 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT count += n ; NEW_LINE DEDENT n *= 2 ; NEW_LINE x /= 2 ; NEW_LINE x = int ( x ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE count = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in count : NEW_LINE INDENT ans += count [ arr [ i ] ] NEW_LINE DEDENT if arr [ i ] in count : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findRadius ( r1 , r2 ) : NEW_LINE INDENT a1 , a2 , a3 , r3 = 0 , 0 , 0 , 0 ; NEW_LINE a1 = 3.14 * r1 * r1 ; NEW_LINE a2 = 3.14 * r2 * r2 ; NEW_LINE a3 = a1 + a2 ; NEW_LINE r3 = ( ( a3 / 3.14 ) ** ( 1 / 2 ) ) ; NEW_LINE return r3 ; NEW_LINE DEDENT
def BeattySequence ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = math . floor ( i * math . sqrt ( 2 ) ) NEW_LINE print ( ans , end = ' , ▁ ' ) NEW_LINE DEDENT DEDENT
def testSomeNumbers ( limit , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return NEW_LINE DEDENT for a in range ( 1 , limit + 1 ) : NEW_LINE INDENT for b in range ( a , limit + 1 ) : NEW_LINE INDENT pow_sum = pow ( a , n ) + pow ( b , n ) NEW_LINE c = pow ( pow_sum , 1.0 / n ) NEW_LINE c_pow = pow ( int ( c ) , n ) NEW_LINE if ( c_pow == pow_sum ) : NEW_LINE INDENT print ( " Count ▁ example ▁ found " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ counter ▁ example ▁ within ▁ given ▁ range ▁ and ▁ data " ) NEW_LINE DEDENT
def freq ( ar , m , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " , odd ) NEW_LINE print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = " , even ) NEW_LINE DEDENT
def findSum ( arr , n , k ) : NEW_LINE INDENT ans = arr [ n - k - 1 ] - arr [ 0 ] ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def countSubStr ( st , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT m = m + 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) // 2 NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE n = len ( arr ) NEW_LINE result = search ( arr , n , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index " , result ) NEW_LINE DEDENT
def findPairs ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] = abs ( arr [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE ans = 0 NEW_LINE for right in range ( N ) : NEW_LINE INDENT while ( 2 * arr [ left ] < arr [ right ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT ans += ( right - left ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def possibleStrings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , left + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 , 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def pairStar ( Input , Output , i = 0 ) : NEW_LINE INDENT Output = Output + Input [ i ] NEW_LINE if ( i == len ( Input ) - 1 ) : NEW_LINE INDENT print ( Output ) NEW_LINE return ; NEW_LINE DEDENT if ( Input [ i ] == Input [ i + 1 ] ) : NEW_LINE INDENT Output = Output + ' * ' ; NEW_LINE DEDENT pairStar ( Input , Output , i + 1 ) ; NEW_LINE DEDENT
def findLCMPrime ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return a * b ; NEW_LINE DEDENT
def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while finalNum * 2 <= n : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT
def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT
def checkForSorting ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 0 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkForSorting ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y % i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findMinLength ( arr ) : NEW_LINE INDENT index = len ( arr ) - 1 ; NEW_LINE while ( index > 0 and arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index -= 1 ; NEW_LINE DEDENT return index ; NEW_LINE DEDENT
def countCon ( ar , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ar [ i ] == ar [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def largestNum ( a , b ) : NEW_LINE INDENT return a * ( bool ) ( a // b ) + b * ( bool ) ( b // a ) ; NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT M = 1000000007 NEW_LINE f = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE return f NEW_LINE DEDENT
def possibleToReach ( x , y , z ) : NEW_LINE INDENT if ( z < abs ( x ) + abs ( y ) or ( z - abs ( x ) - abs ( y ) ) % 2 ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Possible " ) NEW_LINE DEDENT DEDENT
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( ( x ** 2 ) * ( x ** ( 2 * n ) - 1 ) ) // ( x ** 2 - 1 ) NEW_LINE sum2 = ( x * y * ( x ** n * y ** n - 1 ) ) // ( x * y - 1 ) NEW_LINE return ( sum1 + sum2 ) NEW_LINE DEDENT
def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT A = A ^ ( A & B ) NEW_LINE B = B ^ ( A & B ) NEW_LINE print ( A , B ) NEW_LINE DEDENT
def countStrings ( s ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( 1 , len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def findLargestString ( s , i , r ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return INT_MIN ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] ; NEW_LINE DEDENT v [ i ] [ r ] = 1 ; NEW_LINE dp [ i ] [ r ] = max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( ord ( s [ i ] ) - ord ( '0' ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; NEW_LINE return dp [ i ] [ r ] ; NEW_LINE DEDENT
def productPairs ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; NEW_LINE product = product % mod ; NEW_LINE DEDENT DEDENT return product % mod ; NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if max == - 1 : NEW_LINE INDENT print ( " No ▁ Tripplet ▁ Exits " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Maximum ▁ product ▁ is " , max ) NEW_LINE DEDENT
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] == num2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT
def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i NEW_LINE sec = n // i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 // k ) * ( num1 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num1 , mini ) NEW_LINE DEDENT num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return mini NEW_LINE DEDENT
def NumberofTimes ( s ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( s ) > 1 ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temporary_sum += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT s = str ( temporary_sum ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def ReuleauxArea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = 0.70477 * 2 * pow ( r , 2 ) NEW_LINE return A NEW_LINE DEDENT
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ( counts ) ; NEW_LINE DEDENT
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > second and arr [ i ] < first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > third and arr [ i ] < second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ Third ▁ Largest " , " element ▁ is " , third ) NEW_LINE DEDENT
def isMember ( a , d , x ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return x == a NEW_LINE DEDENT return ( ( x - a ) % d == 0 and int ( ( x - a ) / d ) >= 0 ) NEW_LINE DEDENT a = 1 NEW_LINE x = 7 NEW_LINE d = 3 NEW_LINE if isMember ( a , d , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printSeriessumm ( N ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT summ += pow ( i , i - 1 ) NEW_LINE DEDENT print ( summ ) NEW_LINE DEDENT
def validQuadruple ( arr , n ) : NEW_LINE INDENT if ( n >= MAX ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( validQuadruple ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def hexadecagonalNum ( n ) : NEW_LINE INDENT return ( ( 14 * n * n ) - 12 * n ) // 2 NEW_LINE DEDENT
def isDivisibleBy5 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE return ( ( st [ n - 1 ] == '0' ) or ( st [ n - 1 ] == '5' ) ) NEW_LINE DEDENT st = "76955" NEW_LINE if isDivisibleBy5 ( st ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No ▁ " NEW_LINE DEDENT
def minTimeForWritingChars ( N , insert , remov , cpy ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return insert NEW_LINE DEDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 1 ] = insert NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + cpy ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + cpy + remov ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
def numberSequence ( n ) : NEW_LINE INDENT num = pow ( 4 , n ) - pow ( 2 , n ) - 1 NEW_LINE return num NEW_LINE DEDENT
def findSubarrays ( arr , N , K ) : NEW_LINE INDENT return N - K + 1 ; NEW_LINE DEDENT
def FindTrip ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N - 1 ) : NEW_LINE INDENT p = arr [ i - 1 ] NEW_LINE q = arr [ i ] NEW_LINE r = arr [ i + 1 ] NEW_LINE if ( p < q and q > r ) : NEW_LINE INDENT print ( i - 1 , i , i + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def polyapothem ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE DEDENT
def reverse ( string , length , l , r ) : NEW_LINE INDENT if ( l < 0 or r >= length or l > r ) : NEW_LINE INDENT return string ; NEW_LINE DEDENT string = list ( string ) NEW_LINE while ( l < r ) : NEW_LINE INDENT c = string [ l ] ; NEW_LINE string [ l ] = string [ r ] ; NEW_LINE string [ r ] = c ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT return " " . join ( string ) ; NEW_LINE DEDENT
def divide ( dividend , divisor ) : NEW_LINE INDENT sign = ( - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 ) ; NEW_LINE dividend = abs ( dividend ) ; NEW_LINE divisor = abs ( divisor ) ; NEW_LINE quotient = 0 ; NEW_LINE temp = 0 ; NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( temp + ( divisor << i ) <= dividend ) : NEW_LINE INDENT temp += divisor << i ; NEW_LINE quotient |= 1 << i ; NEW_LINE DEDENT DEDENT if sign == - 1 : NEW_LINE quotient = - quotient ; NEW_LINE return quotient ; NEW_LINE DEDENT
def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) // x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def power ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT
def subsequence ( S , T , n , m ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , m + 1 ) ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; NEW_LINE if ( S [ i - 1 ] == T [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT dp [ i ] [ j ] += mod ; NEW_LINE dp [ i ] [ j ] %= mod ; NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] ; NEW_LINE DEDENT
def findMaxSum ( arr , n ) : NEW_LINE INDENT preSum = [ 0 for i in range ( n ) ] NEW_LINE suffSum = [ 0 for i in range ( n ) ] NEW_LINE ans = - 10000000 NEW_LINE preSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT preSum [ i ] = preSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT suffSum [ n - 1 ] = arr [ n - 1 ] NEW_LINE if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) : NEW_LINE INDENT ans = max ( ans , preSum [ n - 1 ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] NEW_LINE if ( suffSum [ i ] == preSum [ i ] ) : NEW_LINE INDENT ans = max ( ans , preSum [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minMoves ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( - 1 , 2 ) : NEW_LINE INDENT for j in range ( - 1 , 2 ) : NEW_LINE INDENT num1 = arr [ 0 ] + i NEW_LINE num2 = arr [ 1 ] + j NEW_LINE flag = 1 NEW_LINE moves = abs ( i ) + abs ( j ) NEW_LINE for idx in range ( 2 , N ) : NEW_LINE INDENT num = num1 + num2 NEW_LINE if ( abs ( arr [ idx ] - num ) > 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT moves += abs ( arr [ idx ] - num ) NEW_LINE DEDENT num1 = num2 NEW_LINE num2 = num NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT ans = min ( ans , moves ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def length_of_chord ( r , x ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ chord " , " ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * r * mt . sin ( x * ( 3.14 / 180 ) ) ) NEW_LINE DEDENT
def max_min ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) NEW_LINE DEDENT
def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countElement ( A , N , B , M , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT currentElement = B [ i ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT diff = abs ( currentElement - A [ j ] ) NEW_LINE if ( diff <= K ) : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT
def findFreq ( strr , N ) : NEW_LINE INDENT freq = [ 0 ] * 256 NEW_LINE max = 0 NEW_LINE charMax = '0' NEW_LINE for i in range ( N ) : NEW_LINE INDENT ch = ord ( strr [ i ] ) NEW_LINE freq [ ch ] += 1 NEW_LINE if ( freq [ ch ] >= max ) : NEW_LINE INDENT max = freq [ ch ] NEW_LINE charMax = ch NEW_LINE DEDENT print ( chr ( charMax ) , " - > " , max ) NEW_LINE DEDENT DEDENT
def maxvolume ( s ) : NEW_LINE INDENT maxvalue = 0 NEW_LINE i = 1 NEW_LINE for i in range ( s - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( s ) : NEW_LINE INDENT k = s - i - j NEW_LINE maxvalue = max ( maxvalue , i * j * k ) NEW_LINE DEDENT DEDENT return maxvalue NEW_LINE DEDENT
def minLettersNeeded ( n ) : NEW_LINE INDENT if n % 26 == 0 : NEW_LINE INDENT return ( n // 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) NEW_LINE DEDENT DEDENT
def evenXorSubarray ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT XOR = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ j ] NEW_LINE if ( ( XOR & 1 ) == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def equilibrium ( arr ) : NEW_LINE INDENT total_sum = sum ( arr ) NEW_LINE leftsum = 0 NEW_LINE for i , num in enumerate ( arr ) : NEW_LINE INDENT total_sum -= num NEW_LINE if leftsum == total_sum : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countSubStr ( str , n , x ) : NEW_LINE INDENT res = 0 ; count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT res += ( ( count + 1 ) * ( n - i ) ) ; NEW_LINE count = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
def PrintBothArrays ( a , n ) : NEW_LINE INDENT v1 , v2 = [ ] , [ ] ; NEW_LINE mpp = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpp [ a [ i ] ] += 1 ; NEW_LINE if ( mpp [ a [ i ] ] == 1 ) : NEW_LINE INDENT v1 . append ( a [ i ] ) ; NEW_LINE DEDENT elif ( mpp [ a [ i ] ] == 2 ) : NEW_LINE INDENT v2 . append ( a [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT v1 . sort ( ) ; NEW_LINE print ( " Strictly ▁ increasing ▁ array ▁ is : " ) ; NEW_LINE for it in v1 : NEW_LINE INDENT print ( it , end = " ▁ " ) ; NEW_LINE DEDENT v2 . sort ( reverse = True ) ; NEW_LINE print ( " Strictly decreasing array is : " ) ; NEW_LINE for it in v2 : NEW_LINE INDENT print ( it , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE n //= 2 NEW_LINE while ( n ) : NEW_LINE INDENT ans += n // 5 NEW_LINE n //= 5 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
def checkWord ( board , word , index , row , col ) : NEW_LINE INDENT if ( row < 0 or col < 0 or row >= len ( board ) or col >= len ( board [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( board [ row ] [ col ] != word [ index ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( index == len ( word ) - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = board [ row ] [ col ] NEW_LINE board [ row ] [ col ] = ' * ' NEW_LINE if ( checkWord ( board , word , index + 1 , row + 1 , col ) or checkWord ( board , word , index + 1 , row - 1 , col ) or checkWord ( board , word , index + 1 , row , col + 1 ) or checkWord ( board , word , index + 1 , row , col - 1 ) ) : NEW_LINE INDENT board [ row ] [ col ] = temp NEW_LINE return True NEW_LINE DEDENT board [ row ] [ col ] = temp NEW_LINE return False NEW_LINE DEDENT
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , " , c / ( a * 1.0 ) ) NEW_LINE DEDENT
def findStarNum ( n ) : NEW_LINE INDENT return ( 6 * n * ( n - 1 ) + 1 ) NEW_LINE DEDENT
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT d = 1.73 * a ; NEW_LINE return d ; NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT if n / 10 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + countDigit ( n // 10 ) NEW_LINE DEDENT
def printLastElement ( arr , N ) : NEW_LINE INDENT leftTurn = True NEW_LINE remainElements = N NEW_LINE step = 1 NEW_LINE head = 1 NEW_LINE while ( remainElements > 1 ) : NEW_LINE INDENT if ( leftTurn ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT else : NEW_LINE INDENT if ( remainElements % 2 == 1 ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT DEDENT remainElements = remainElements // 2 NEW_LINE step = step * 2 NEW_LINE leftTurn = not leftTurn NEW_LINE DEDENT print ( arr [ head - 1 ] ) NEW_LINE DEDENT
def countDer ( n ) : NEW_LINE INDENT if ( n == 1 ) : return 0 NEW_LINE if ( n == 2 ) : return 1 NEW_LINE return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) NEW_LINE DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ i ] == True : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE DEDENT DEDENT
def calc_distance ( A , B , n ) : NEW_LINE INDENT distance_traveled_A = 0 NEW_LINE distance_traveled_B = 0 NEW_LINE answer = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT distance_traveled_A += A [ i ] NEW_LINE distance_traveled_B += B [ i ] NEW_LINE if ( ( distance_traveled_A == distance_traveled_B ) and ( A [ i ] == B [ i ] ) ) : NEW_LINE INDENT answer += A [ i ] NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def pairs ( n ) : NEW_LINE INDENT c = [ [ 0 for i in range ( 10 ) ] for i in range ( 10 ) ] NEW_LINE tmp = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i >= tmp * 10 ) : NEW_LINE INDENT tmp *= 10 NEW_LINE DEDENT c [ i // tmp ] [ i % 10 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 1 , 10 ) : NEW_LINE INDENT ans += c [ i ] [ j ] * c [ j ] [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def linearSearch ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] is i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) // 2 NEW_LINE DEDENT
def minOperation ( arr ) : NEW_LINE INDENT minOp = sys . maxsize NEW_LINE minNeg = 0 NEW_LINE maxPos = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT if ( arr [ i ] < minNeg ) : NEW_LINE INDENT minNeg = arr [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ i ] > maxPos : NEW_LINE INDENT maxPos = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return abs ( minNeg ) + maxPos NEW_LINE DEDENT
def maxHamming ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * ( 2 * n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT brr [ n + i ] = arr [ i ] NEW_LINE DEDENT maxHam = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currHam = 0 NEW_LINE k = 0 NEW_LINE for j in range ( i , i + n ) : NEW_LINE INDENT if brr [ j ] != arr [ k ] : NEW_LINE INDENT currHam += 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT if currHam == n : NEW_LINE INDENT return n NEW_LINE DEDENT maxHam = max ( maxHam , currHam ) NEW_LINE DEDENT return maxHam NEW_LINE DEDENT
def mod ( a , m ) : NEW_LINE INDENT return ( a % m + m ) % m NEW_LINE DEDENT
def check ( arr , N ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT DEDENT if ( even == N or odd == N ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def count ( n , k ) : NEW_LINE INDENT count = ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; NEW_LINE print ( count ) ; NEW_LINE DEDENT
def sumOfInternalAngles ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( n - 2 ) * 180 ) NEW_LINE DEDENT
def countNumbers ( N ) : NEW_LINE INDENT return ( pow ( 10 , N ) - pow ( 8 , N ) ) // 2 NEW_LINE DEDENT
def countToMake0lternate ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE DEDENT return result NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT hm = { } NEW_LINE count = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT hm [ arr [ j ] ] = hm . get ( arr [ j ] , 0 ) + 1 NEW_LINE if ( hm [ arr [ j ] ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( hm [ arr [ j ] ] == 2 ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( count == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def findSubstringCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ord ( str [ i ] ) + 1 == ord ( str [ i + 1 ] ) ) : NEW_LINE INDENT result += 1 NEW_LINE while ( ord ( str [ i ] ) + 1 == ord ( str [ i + 1 ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def countDigits ( n ) : NEW_LINE INDENT return int ( n * math . log10 ( 2 ) + 1 ) ; NEW_LINE DEDENT
def findPeak ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE return 0 NEW_LINE if ( arr [ 0 ] >= arr [ 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ i - 1 ] and arr [ i ] >= arr [ i + 1 ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def countNumberOfStrings ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE n = length - 1 NEW_LINE count = 2 ** n NEW_LINE return count NEW_LINE DEDENT
def posOfRightMostSameBit ( m , n ) : NEW_LINE INDENT loopCounter = 1 NEW_LINE while ( m > 0 or n > 0 ) : NEW_LINE INDENT a = m % 2 == 1 NEW_LINE b = n % 2 == 1 NEW_LINE if ( not ( a ^ b ) ) : NEW_LINE INDENT return loopCounter NEW_LINE DEDENT m = m >> 1 NEW_LINE n = n >> 1 NEW_LINE loopCounter += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x / 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT
def pairExists ( arr1 : List [ int ] , m : int , arr2 : List [ int ] , n : int ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( arr2 [ 2 ] - arr1 [ 2 ] ) not in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT s . add ( arr1 [ i ] ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT
def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i * i <= x : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
def findEquation ( A , B , C ) : NEW_LINE INDENT print ( " ( " + str ( C ) + " ) " + " x ^ 2 ▁ + ( " + str ( B ) + " ) x ▁ + ▁ ( " + str ( A ) + " ) ▁ = ▁ 0" ) NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] ; prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] <= prev : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def getM ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n - 2 ; NEW_LINE DEDENT DEDENT
def subtract ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE C = A [ : ] [ : ] NEW_LINE subtract ( A , B , C ) NEW_LINE print ( " Result ▁ matrix ▁ is " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( C [ i ] [ j ] , " ▁ " , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + n - 3 NEW_LINE DEDENT
def volumeRec ( a , b , e , h ) : NEW_LINE INDENT return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; NEW_LINE DEDENT
def findNthNumber ( N ) : NEW_LINE INDENT result = 0 NEW_LINE p = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT result += ( p * ( N % 9 ) ) NEW_LINE N = N // 9 NEW_LINE p = p * 10 NEW_LINE DEDENT return result NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT return ( pow ( n , 2 ) - ( 2 * n ) + 2 ) ; NEW_LINE DEDENT
def lis ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maximum = max ( maximum , lis [ i ] ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] ; NEW_LINE cur -= 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] ; NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 ; NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT cur = nxt ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT
def circle_inscribed ( a ) : NEW_LINE INDENT return pi * ( a * a ) / 12 NEW_LINE DEDENT
def spiralDiaSum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT
def getMin ( arr , n ) : NEW_LINE INDENT minVal = min ( arr ) ; NEW_LINE return minVal ; NEW_LINE DEDENT
def colMaxDiff ( mat ) : NEW_LINE INDENT max_diff = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_val = mat [ 0 ] [ i ] NEW_LINE min_val = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT max_val = max ( max_val , mat [ j ] [ i ] ) NEW_LINE min_val = min ( min_val , mat [ j ] [ i ] ) NEW_LINE DEDENT max_diff = max ( max_diff , max_val - min_val ) NEW_LINE DEDENT return max_diff NEW_LINE DEDENT
def findSmallestNumK ( n ) : NEW_LINE INDENT cummAnd = n NEW_LINE i = n - 1 NEW_LINE while ( cummAnd != 0 ) : NEW_LINE INDENT cummAnd = cummAnd & i NEW_LINE if ( cummAnd == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def area ( d1 , a ) : NEW_LINE INDENT d2 = ( 4 * ( a ** 2 ) - d1 ** 2 ) ** 0.5 NEW_LINE area = 0.5 * d1 * d2 NEW_LINE return ( area ) NEW_LINE DEDENT
def evenNumSubstring ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def printChar ( str_ , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( " { } " . format ( str_ [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def isPossible ( A , B , n , m , x , y ) : NEW_LINE INDENT if ( x > n or y > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE if ( A [ x - 1 ] < B [ m - y ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT A = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE B = [ 2 , 2 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE x = 3 NEW_LINE y = 1 NEW_LINE if ( isPossible ( A , B , n , m , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getMinOps ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT ans += max ( arr [ i ] - arr [ i + 1 ] , 0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def MinimumMail ( n , k , x ) : NEW_LINE INDENT m = ( ( n - 1 ) + int ( math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + math . ceil ( n * 1.0 / x ) * ( k - n ) ) ) ; NEW_LINE return m ; NEW_LINE DEDENT
def can_empty ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 4 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT m = min ( a , min ( b , c ) ) ; NEW_LINE if ( m < ( a + b + c ) // 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT
def removeDuplicatesFromString ( str2 ) : NEW_LINE INDENT counter = 0 ; NEW_LINE i = 0 ; NEW_LINE size = len ( str2 ) ; NEW_LINE str1 = list ( str2 ) ; NEW_LINE x = 0 ; NEW_LINE length = 0 ; NEW_LINE while ( i < size ) : NEW_LINE INDENT x = ord ( str1 [ i ] ) - 97 ; NEW_LINE if ( ( counter & ( 1 << x ) ) == 0 ) : NEW_LINE INDENT str1 [ length ] = chr ( 97 + x ) ; NEW_LINE counter = counter | ( 1 << x ) ; NEW_LINE length += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT str2 = ' ' . join ( str1 ) ; NEW_LINE return str2 [ 0 : length ] ; NEW_LINE DEDENT
def centeredDodecagonal ( n ) : NEW_LINE INDENT return 6 * n * ( n - 1 ) + 1 ; NEW_LINE DEDENT
def summation ( N ) : NEW_LINE INDENT co = ( N + 1 ) / 2 NEW_LINE co = int ( co ) NEW_LINE ce = N / 2 NEW_LINE ce = int ( ce ) NEW_LINE se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) NEW_LINE so = ( co * co ) * ( 2 * ( co * co ) - 1 ) NEW_LINE return so - se NEW_LINE DEDENT
def smallestMultiple ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT
def rectCount ( n , m ) : NEW_LINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4 NEW_LINE DEDENT
def countUnique ( mat , n , m ) : NEW_LINE INDENT rowsum = [ 0 ] * n ; NEW_LINE colsum = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 ) : NEW_LINE INDENT rowsum [ i ] += 1 ; NEW_LINE colsum [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT uniquecount = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) : NEW_LINE INDENT uniquecount += 1 ; NEW_LINE DEDENT DEDENT DEDENT return uniquecount ; NEW_LINE DEDENT
def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // COST ; NEW_LINE x %= COST ; NEW_LINE type2 = y // COST ; NEW_LINE y %= COST ; NEW_LINE type3 = z // COST ; NEW_LINE z %= COST ; NEW_LINE type4 = min ( x , min ( y , z ) ) ; NEW_LINE maxItems = type1 + type2 + type3 + type4 ; NEW_LINE return maxItems ; NEW_LINE DEDENT
def center_octadecagon_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 9 * n + 1 ) NEW_LINE DEDENT
def polynomialRollingHash ( str ) : NEW_LINE INDENT p = 31 NEW_LINE m = 1e9 + 9 NEW_LINE power_of_p = 1 NEW_LINE hash_val = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT hash_val = ( ( hash_val + ( ord ( str [ i ] ) - ord ( ' a ' ) + 1 ) * power_of_p ) % m ) NEW_LINE power_of_p = ( power_of_p * p ) % m NEW_LINE DEDENT return int ( hash_val ) NEW_LINE DEDENT
def isFibbinaryNum ( n ) : NEW_LINE INDENT if ( ( n & ( n >> 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 10 NEW_LINE if ( isFibbinaryNum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def calculate ( n , power ) : NEW_LINE INDENT return sum ( [ int ( i ) for i in str ( pow ( n , power ) ) ] ) NEW_LINE DEDENT
def maxPossibleSum ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE j = N - 3 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE j -= 3 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def maxWater ( arr , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE l_max = 0 NEW_LINE r_max = 0 NEW_LINE result = 0 NEW_LINE while ( left <= right ) : NEW_LINE INDENT if r_max <= l_max : NEW_LINE INDENT result += max ( 0 , r_max - arr [ right ] ) NEW_LINE r_max = max ( r_max , arr [ right ] ) NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += max ( 0 , l_max - arr [ left ] ) NEW_LINE l_max = max ( l_max , arr [ left ] ) NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxArea ( point_x , point_y , n , length , width ) : NEW_LINE INDENT point_x . sort ( ) NEW_LINE point_y . sort ( ) NEW_LINE dx = point_x [ 0 ] NEW_LINE dy = point_y [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dx = max ( dx , point_x [ i ] - point_x [ i - 1 ] ) NEW_LINE dy = max ( dy , point_y [ i ] - point_y [ i - 1 ] ) NEW_LINE DEDENT dx = max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) NEW_LINE dy = max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) NEW_LINE print ( ( dx - 1 ) * ( dy - 1 ) ) NEW_LINE DEDENT
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = math . pow ( 2 , l - 1 ) ; NEW_LINE sumLastLevel = 0 ; NEW_LINE sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) ; NEW_LINE sum = sumLastLevel * l ; NEW_LINE return int ( sum ) ; NEW_LINE DEDENT
def eccHyperbola ( A , B ) : NEW_LINE INDENT r = B * B / A * A NEW_LINE r += 1 NEW_LINE return math . sqrt ( r ) NEW_LINE DEDENT
def Kroneckerproduct ( A , B ) : NEW_LINE INDENT C = [ [ 0 for j in range ( cola * colb ) ] for i in range ( rowa * rowb ) ] NEW_LINE for i in range ( 0 , rowa ) : NEW_LINE INDENT for k in range ( 0 , rowb ) : NEW_LINE INDENT for j in range ( 0 , cola ) : NEW_LINE INDENT for l in range ( 0 , colb ) : NEW_LINE INDENT C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] NEW_LINE print ( C [ i + l + 1 ] [ j + k + 1 ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT DEDENT DEDENT
def Survives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n -= n // i ; NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def countSwaps ( A , n ) : NEW_LINE INDENT mp = { } NEW_LINE max_frequency = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT max_frequency = max ( max_frequency , mp [ A [ i ] ] ) NEW_LINE DEDENT return n - max_frequency NEW_LINE DEDENT
def maxLength ( arr , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE i = 0 NEW_LINE j = i + 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ j ] ) : NEW_LINE INDENT maxLen = max ( maxLen , 2 ) NEW_LINE l = i - 1 NEW_LINE r = j + 1 NEW_LINE while ( l >= 0 and r < n and arr [ l ] == arr [ i ] and arr [ r ] == arr [ j ] ) : NEW_LINE INDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT maxLen = max ( maxLen , 2 * ( r - j ) ) NEW_LINE DEDENT i += 1 NEW_LINE j = i + 1 NEW_LINE DEDENT return maxLen NEW_LINE DEDENT
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( " Found ▁ a ▁ subset ▁ with ▁ given ▁ sum " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ subset ▁ with ▁ given ▁ sum " ) NEW_LINE DEDENT
def No_of_cubes ( N , K ) : NEW_LINE INDENT No = 0 NEW_LINE No = ( N - K + 1 ) NEW_LINE No = pow ( No , 3 ) NEW_LINE return No NEW_LINE DEDENT
def maxModProdSubarr ( arr , n , M ) : NEW_LINE INDENT ans = 0 NEW_LINE length = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = 1 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT product = ( product * arr [ i ] ) % M NEW_LINE if ( product > ans ) : NEW_LINE INDENT ans = product NEW_LINE if ( length > j - i + 1 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Maximum ▁ subarray ▁ product ▁ is " , ans ) NEW_LINE print ( " Minimum ▁ length ▁ of ▁ the ▁ maximum ▁ product ▁ subarray ▁ is " , length ) NEW_LINE DEDENT
def printNSE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + " ▁ - - ▁ " + str ( next ) ) NEW_LINE DEDENT DEDENT
def isPowerOfK ( n , k ) : NEW_LINE INDENT oneSeen = False NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % k NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT if ( oneSeen ) : NEW_LINE INDENT return False NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT n //= k NEW_LINE DEDENT return True NEW_LINE DEDENT n = 64 NEW_LINE k = 4 NEW_LINE if ( isPowerOfK ( n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def computeMaxValue ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT val = max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) NEW_LINE ans = max ( ans , val ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def distance ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT d = math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) + math . pow ( z2 - z1 , 2 ) * 1.0 ) NEW_LINE print ( " Distance ▁ is ▁ " ) NEW_LINE print ( d ) NEW_LINE DEDENT
def isLoeschian ( n ) : NEW_LINE INDENT for x in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT for y in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( x * x + x * y + y * y == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT N = 19 NEW_LINE if ( isLoeschian ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while j >= 0 and i < n : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += ( j + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def heightCalculate ( H , n , m ) : NEW_LINE INDENT N = n * 1.0 NEW_LINE M = m * 1.0 NEW_LINE h = H * sqrt ( N / ( N + M ) ) NEW_LINE return h NEW_LINE DEDENT
def Nonagonal ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( int ( i * ( 7 * i - 5 ) / 2 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def eulerian ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def findDecimal ( arr , N ) : NEW_LINE INDENT power = 0 ; NEW_LINE result = 0 ; NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT bit = abs ( int ( arr [ i ] ) - round ( arr [ i ] ) ) ; NEW_LINE if ( bit ) : NEW_LINE INDENT result += pow ( 2 , power ) ; NEW_LINE DEDENT power += 1 ; NEW_LINE DEDENT print ( result ) ; NEW_LINE DEDENT
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 1 , n - 1 ) : NEW_LINE INDENT for i in range ( n - L ) : NEW_LINE INDENT dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) NEW_LINE DEDENT DEDENT return dp [ 1 ] [ n - 1 ] NEW_LINE DEDENT
def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) // 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT
def findMinSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 2 NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE num /= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum += num NEW_LINE return sum NEW_LINE DEDENT
def findOccurrences ( str , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT
def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 10 ) } NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT sum += - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( sum not in um ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( ( sum - 1 ) in um ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if ( floor ( z ) == ceil ( z ) ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT
def expectedSteps ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( x <= 5 ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT if ( v [ x ] ) : NEW_LINE INDENT return dp [ x ] NEW_LINE DEDENT v [ x ] = 1 NEW_LINE dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 NEW_LINE return dp [ x ] NEW_LINE DEDENT
def isTwoAlter ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = ord ( number [ i ] ) - ord ( '0' ) NEW_LINE if ( number [ i ] == '9' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = ( sum + ord ( number [ j ] ) - ord ( '0' ) ) % 9 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT fl = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] >= n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] < 2 * n ) : NEW_LINE INDENT print ( arr [ i ] % n , end = " ▁ " ) NEW_LINE fl = 1 ; NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n ; NEW_LINE DEDENT if ( fl == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def countSubsequences ( arr ) : NEW_LINE INDENT odd = 0 NEW_LINE for x in arr : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT return ( 1 << odd ) - 1 NEW_LINE DEDENT
def getPairsCount ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( a [ i ] * a [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def answer ( L , R ) : NEW_LINE INDENT if ( 2 * L <= R ) : NEW_LINE INDENT print ( L , " , " , 2 * L ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def precompute ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT cnt [ i + 1 ] = cnt [ i ] NEW_LINE if s [ i : len ( K ) + i ] == K : NEW_LINE INDENT cnt [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def det ( d ) : NEW_LINE INDENT Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) NEW_LINE Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) NEW_LINE Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) NEW_LINE return Sum NEW_LINE DEDENT
def countEvenPairs ( N , M ) : NEW_LINE INDENT count = 0 ; NEW_LINE nEven = int ( math . floor ( N / 2 ) ) ; NEW_LINE nOdd = int ( math . ceil ( N / 2 ) ) ; NEW_LINE mEven = int ( math . floor ( M / 2 ) ) ; NEW_LINE mOdd = int ( math . ceil ( M / 2 ) ) ; NEW_LINE count = nEven * mEven + nOdd * mOdd ; NEW_LINE return count ; NEW_LINE DEDENT
def solve ( n , d , input1 ) : NEW_LINE INDENT a = [ 0 ] * N NEW_LINE cnt = [ 0 ] * ( V + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = input1 [ i ] NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( d ) : NEW_LINE INDENT cnt [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( d , n ) : NEW_LINE INDENT acc = 0 NEW_LINE low_median = - 1 NEW_LINE high_median = - 1 NEW_LINE for v in range ( V + 1 ) : NEW_LINE INDENT acc += cnt [ v ] NEW_LINE if ( low_median == - 1 and acc >= int ( math . floor ( ( d + 1 ) / 2.0 ) ) ) : NEW_LINE INDENT low_median = v NEW_LINE DEDENT if ( high_median == - 1 and acc >= int ( math . ceil ( ( d + 1 ) / 2.0 ) ) ) : NEW_LINE INDENT high_median = v NEW_LINE DEDENT DEDENT double_median = low_median + high_median NEW_LINE if ( a [ i ] >= double_median ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT cnt [ a [ i - d ] ] -= 1 NEW_LINE cnt [ a [ i ] ] += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT
def maximumValue ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] + arr [ j ] + i - j ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( " After ▁ exchange " ) NEW_LINE print ( " x ▁ is " , x ) NEW_LINE DEDENT
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT
def findPairs ( arr1 , arr2 , n , m , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( arr1 [ i ] + arr2 [ j ] == x ) : NEW_LINE INDENT print ( arr1 [ i ] , arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def smallest_pair ( a , n ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE secondMin = sys . maxsize NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( a [ j ] < min ) : NEW_LINE INDENT secondMin = min NEW_LINE min = a [ j ] NEW_LINE DEDENT elif ( ( a [ j ] < secondMin ) and a [ j ] != min ) : NEW_LINE INDENT secondMin = a [ j ] NEW_LINE DEDENT DEDENT return ( secondMin + min ) NEW_LINE DEDENT
def maxSum ( N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for u in range ( 1 , N + 1 ) : NEW_LINE INDENT for v in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( u == v ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT degreeU = 2 ; NEW_LINE if ( u == 1 or u == N ) : NEW_LINE INDENT degreeU = 1 ; NEW_LINE DEDENT degreeV = 2 ; NEW_LINE if ( v == 1 or v == N ) : NEW_LINE INDENT degreeV = 1 ; NEW_LINE DEDENT ans += ( degreeU * degreeV ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
def minMovesToSort ( arr , n ) : NEW_LINE INDENT moves = 0 NEW_LINE mn = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > mn ) : NEW_LINE INDENT moves += arr [ i ] - mn NEW_LINE DEDENT DEDENT return moves NEW_LINE DEDENT
def CalPeri ( ) : NEW_LINE INDENT s = 5 NEW_LINE Perimeter = 10 * s NEW_LINE print ( " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ " , Perimeter ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( n , n ) + sum ( n - 1 ) NEW_LINE DEDENT DEDENT
def path_to_root ( node ) : NEW_LINE INDENT while ( node >= 1 ) : NEW_LINE INDENT print ( node , end = " ▁ " ) NEW_LINE node //= 2 NEW_LINE DEDENT DEDENT
def check ( current_row , current_col , destination_row , destination_col ) : NEW_LINE INDENT if ( current_row == destination_row ) : NEW_LINE INDENT return ( " POSSIBLE " ) NEW_LINE DEDENT elif ( current_col == destination_col ) : NEW_LINE INDENT return ( " POSSIBLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " NOT ▁ POSSIBLE " ) NEW_LINE DEDENT DEDENT
def findSumOfAllSubsets ( arr , n , k ) : NEW_LINE INDENT factorial_N = 1 NEW_LINE factorial_d = 1 NEW_LINE factorial_D = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT factorial_N *= i NEW_LINE DEDENT for i in range ( 1 , k , 1 ) : NEW_LINE INDENT factorial_d *= i NEW_LINE DEDENT for i in range ( 1 , n - k + 1 , 1 ) : NEW_LINE INDENT factorial_D *= i NEW_LINE DEDENT freq = factorial_N // ( factorial_d * factorial_D ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum = sum * freq NEW_LINE print ( " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " , k , " ▁ is ▁ = > " , sum ) NEW_LINE DEDENT
def maximumCandy ( candies , safety , N , M ) : NEW_LINE INDENT total = 0 NEW_LINE ans = 10 ** 8 NEW_LINE all_safe = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( candies [ i ] + M > safety [ i ] ) : NEW_LINE INDENT all_safe = False NEW_LINE ans = min ( ans , safety [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , candies [ i ] + M ) NEW_LINE DEDENT total += candies [ i ] NEW_LINE DEDENT if ( all_safe ) : NEW_LINE INDENT return total NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT
def getSetBitsFromOneToN ( N ) : NEW_LINE INDENT two = 2 NEW_LINE ans = 0 NEW_LINE n = N NEW_LINE while ( n != 0 ) : NEW_LINE INDENT ans += int ( N / two ) * ( two >> 1 ) NEW_LINE if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) : NEW_LINE INDENT ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 NEW_LINE DEDENT two <<= 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sphere ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / 2 NEW_LINE return r NEW_LINE DEDENT
def productOfGP ( a , r , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * a ; NEW_LINE a = a * r ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
def bin ( n ) : NEW_LINE INDENT i = 1 << 31 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( ( n & i ) != 0 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT i = i // 2 NEW_LINE DEDENT DEDENT
def ispalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE j = l - 1 NEW_LINE while i <= j : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def Length_Diagonals ( a , theta ) : NEW_LINE INDENT p = a * math . sqrt ( 2 + ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE q = a * math . sqrt ( 2 - ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE y = n + 1 NEW_LINE while ( y <= n * n + n ) : NEW_LINE INDENT if ( ( n * n ) % ( y - n ) == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT y += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def maximizeFinalElement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE if ( arr [ 0 ] != 1 ) : NEW_LINE INDENT arr [ 0 ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT return arr [ n - 1 ] ; NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 3 * n + 2 NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT
def fractionToDecimal ( numr , denr ) : NEW_LINE INDENT res = " " NEW_LINE mp = { } NEW_LINE rem = numr % denr NEW_LINE while ( ( rem != 0 ) and ( rem not in mp ) ) : NEW_LINE INDENT mp [ rem ] = len ( res ) NEW_LINE rem = rem * 10 NEW_LINE res_part = rem // denr NEW_LINE res += str ( res_part ) NEW_LINE rem = rem % denr NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT return " " NEW_LINE DEDENT else : NEW_LINE INDENT return res [ mp [ rem ] : ] NEW_LINE DEDENT DEDENT numr , denr = 50 , 22 NEW_LINE res = fractionToDecimal ( numr , denr ) NEW_LINE if ( res == " " ) : NEW_LINE INDENT print ( " No ▁ recurring ▁ sequence " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Recurring ▁ sequence ▁ is " , res ) NEW_LINE DEDENT
def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE k = 7 NEW_LINE freq = find ( n , k ) NEW_LINE if ( freq < 0 ) : NEW_LINE INDENT print ( " ▁ element ▁ not ▁ exist " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ Frequency ▁ of ▁ " , k , " ▁ is ▁ " , freq ) NEW_LINE DEDENT
def closetAND ( arr , n , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = arr [ i ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT X &= arr [ j ] NEW_LINE ans = min ( ans , abs ( k - X ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minSteps ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( k == 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == flag ) : NEW_LINE INDENT cnt += 1 NEW_LINE flag = ( flag + 1 ) % 2 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def waysOfDecoding ( s ) : NEW_LINE INDENT dp = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE if s [ 0 ] == ' * ' : NEW_LINE INDENT dp [ 1 ] = 9 NEW_LINE DEDENT elif s [ 0 ] == '0' : NEW_LINE INDENT dp [ 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] = 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' * ' ) : NEW_LINE INDENT dp [ i + 1 ] = 9 * dp [ i ] NEW_LINE if ( s [ i - 1 ] == '1' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == '2' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == ' * ' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i ] != '0' : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = 0 NEW_LINE DEDENT if ( s [ i - 1 ] == '1' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == '2' and s [ i ] <= '6' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == ' * ' ) : NEW_LINE INDENT if ( s [ i ] <= '6' ) : NEW_LINE INDENT dp [ i + 1 ] = dp [ i + 1 ] + 2 * dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = dp [ i + 1 ] + 1 * dp [ i - 1 ] NEW_LINE DEDENT dp [ i + 1 ] = dp [ i + 1 ] % M NEW_LINE DEDENT DEDENT DEDENT return dp [ len ( s ) ] NEW_LINE DEDENT
def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is ▁ " , ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT
def majorityNumber ( nums ) : NEW_LINE INDENT num_count = { } NEW_LINE for num in nums : NEW_LINE INDENT if num in num_count : NEW_LINE INDENT num_count [ num ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_count [ num ] = 1 NEW_LINE DEDENT DEDENT for num in num_count : NEW_LINE INDENT if num_count [ num ] > len ( nums ) / 2 : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minCost ( cost , n ) : NEW_LINE INDENT totalCost = 0 NEW_LINE boardingBus = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( cost [ boardingBus ] > cost [ i ] ) : NEW_LINE INDENT totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) NEW_LINE boardingBus = i NEW_LINE DEDENT DEDENT totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) NEW_LINE return totalCost NEW_LINE DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT return ( floor ( b ** ( 1. / 3. ) ) - ceil ( a ** ( 1. / 3. ) ) + 1 ) NEW_LINE DEDENT
def largestSubStr ( s ) : NEW_LINE INDENT while ( len ( s ) and s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT s = s [ : len ( s ) - 1 ] ; NEW_LINE DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return " - 1" ; NEW_LINE DEDENT else : NEW_LINE INDENT return s ; NEW_LINE DEDENT DEDENT
def maxSum ( mat , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE maxSum = INT_MIN NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxi = INT_MIN NEW_LINE if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + maxi NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getSum ( arr , p ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT
def fun ( marks , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( 0 , n ) ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if marks [ i ] > marks [ i + 1 ] : NEW_LINE INDENT temp = i NEW_LINE while True : NEW_LINE INDENT if marks [ temp ] > marks [ temp + 1 ] and temp >= 0 : NEW_LINE INDENT if dp [ temp ] > dp [ temp + 1 ] : NEW_LINE INDENT temp -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ temp ] = dp [ temp + 1 ] + 1 NEW_LINE temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT elif marks [ i ] < marks [ i + 1 ] : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] + 1 NEW_LINE DEDENT DEDENT return ( sum ( dp ) ) NEW_LINE DEDENT
def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return ( sum // n ) + 1 NEW_LINE DEDENT
def count ( a , n ) : NEW_LINE INDENT countElements = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT flag = True NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i ] % a [ j ] == 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT countElements += 1 NEW_LINE DEDENT DEDENT return countElements NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT return ( math . floor ( math . log10 ( n ) + 1 ) ) NEW_LINE DEDENT
def line ( x0 , y0 ) : NEW_LINE INDENT c = 2 * y0 * x0 NEW_LINE print ( y0 , " x " , " + " , x0 , " y = " , c ) NEW_LINE DEDENT
def find_angle ( x , y , z ) : NEW_LINE INDENT volume = x * x * y ; NEW_LINE ans = 0 ; NEW_LINE if ( z < volume // 2 ) : NEW_LINE INDENT d = ( x * y * y ) / ( 2.0 * z ) ; NEW_LINE ans = atan ( d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT z = volume - z ; NEW_LINE d = ( 2 * z ) / ( float ) ( x * x * x ) ; NEW_LINE ans = atan ( d ) ; NEW_LINE DEDENT ans = ( ans * 180 ) / 3.14159265 ; NEW_LINE return round ( ans , 4 ) ; NEW_LINE DEDENT
def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A or B ) : NEW_LINE INDENT if ( ( A & 1 ) and ( B & 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def asciiToSentence ( string , length ) : NEW_LINE INDENT num = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT num = num * 10 + ( ord ( string [ i ] ) - ord ( '0' ) ) ; NEW_LINE if ( num >= 32 and num <= 122 ) : NEW_LINE INDENT ch = chr ( num ) ; NEW_LINE print ( ch , end = " " ) ; NEW_LINE num = 0 ; NEW_LINE DEDENT DEDENT DEDENT
def countWords ( str ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( 1 , len ( str ) - 1 ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def modifiedBinaryPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 , 1 ) : NEW_LINE INDENT if ( j == 1 or j == i ) : NEW_LINE INDENT print ( 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE DEDENT DEDENT print ( ' ' , end = " " ) NEW_LINE DEDENT DEDENT
def isPossible ( x , y ) : NEW_LINE INDENT if ( ( x - y ) == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT x = 100 NEW_LINE y = 98 NEW_LINE if ( isPossible ( x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def maxSumArray ( arr , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE mp = { i : 0 for i in range ( 4 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += arr [ i ] NEW_LINE mp [ arr [ i ] ] += 1 NEW_LINE DEDENT minimum = maxsize NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( key == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT minimum = min ( minimum , value * key ) NEW_LINE DEDENT return ( sum1 - minimum ) NEW_LINE DEDENT
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT
def print_product ( a , b , c , d ) : NEW_LINE INDENT prod1 = a * c NEW_LINE prod2 = b * d NEW_LINE prod3 = ( a + b ) * ( c + d ) NEW_LINE real = prod1 - prod2 NEW_LINE imag = prod3 - ( prod1 + prod2 ) NEW_LINE print ( real , " ▁ + ▁ " , imag , " i " ) NEW_LINE DEDENT
def numSeq ( n ) : NEW_LINE INDENT return ( pow ( 3 , n ) + 3 * pow ( - 1 , n ) ) // 4 NEW_LINE DEDENT
def getCount ( a , b , c ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , 82 ) : NEW_LINE INDENT cr = b * pow ( i , a ) + c NEW_LINE tmp = cr NEW_LINE sm = 0 NEW_LINE while ( tmp ) : NEW_LINE INDENT sm += tmp % 10 NEW_LINE tmp //= 10 NEW_LINE DEDENT if ( sm == i and cr < 10 ** 9 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def DecakismyriagonNum ( N ) : NEW_LINE INDENT return ( 99998 * N * N - 99996 * N ) // 2 ; NEW_LINE DEDENT
def insertAfter ( self , prev_node , new_data ) : NEW_LINE INDENT if prev_node is None : NEW_LINE INDENT print " The ▁ given ▁ previous ▁ node ▁ must ▁ inLinkedList . " NEW_LINE return NEW_LINE DEDENT new_node = Node ( new_data ) NEW_LINE new_node . next = prev_node . next NEW_LINE prev_node . next = new_node NEW_LINE DEDENT
def judgeSquareSum ( n ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( i % 4 == 3 and count % 2 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return n % 4 != 3 ; NEW_LINE DEDENT n = 17 ; NEW_LINE if ( judgeSquareSum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def LeftRightNode ( preorder , n ) : NEW_LINE INDENT min = 10 ** 9 NEW_LINE max = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min > preorder [ i ] ) : NEW_LINE INDENT min = preorder [ i ] NEW_LINE DEDENT if ( max < preorder [ i ] ) : NEW_LINE INDENT max = preorder [ i ] NEW_LINE DEDENT DEDENT print ( " Leftmost ▁ node ▁ is ▁ " , min ) NEW_LINE print ( " Rightmost ▁ node ▁ is ▁ " , max ) NEW_LINE DEDENT
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT
def Substring ( s ) : NEW_LINE INDENT ans , temp = 1 , 1 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , temp ) NEW_LINE temp = 1 NEW_LINE DEDENT DEDENT ans = max ( ans , temp ) NEW_LINE return ans NEW_LINE DEDENT
def RightRotate ( a , n , k ) : NEW_LINE INDENT k = k % n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT print ( a [ n + i - k ] , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i - k ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( " " ) ; NEW_LINE DEDENT
def squareSide ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.423 * a NEW_LINE return x NEW_LINE DEDENT
def solve ( s1 , s2 ) : NEW_LINE INDENT flag1 = 0 NEW_LINE flag2 = 0 NEW_LINE if ( len ( s1 ) != len ( s2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l = len ( s1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s1 [ i ] == '1' ) : NEW_LINE INDENT flag1 = 1 ; NEW_LINE DEDENT if ( s2 [ i ] == '1' ) : NEW_LINE INDENT flag2 = 1 NEW_LINE DEDENT if ( flag1 & flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ! flag1 &   ! flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s1 = "100101" NEW_LINE s2 = "100000" NEW_LINE if solve ( s1 , s2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getPosition ( N , M ) : NEW_LINE INDENT if ( M > ( N // 2 ) ) : NEW_LINE INDENT return ( M - ( N // 2 ) ) NEW_LINE DEDENT return ( M + ( N // 2 ) ) NEW_LINE DEDENT
def distributeN ( A , B , C , n ) : NEW_LINE INDENT maximum = max ( A , B , C ) NEW_LINE sum = A + B + C NEW_LINE p = ( 3 * maximum ) - sum NEW_LINE diff = n - p NEW_LINE if diff < 0 or diff % 3 : NEW_LINE INDENT print " No " NEW_LINE DEDENT else : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT DEDENT
def findSum ( N ) : NEW_LINE INDENT sum = ( N ) * ( N + 1 ) // 2 NEW_LINE r = log2 ( N ) + 1 NEW_LINE expSum = pow ( 2 , r ) - 1 NEW_LINE print ( int ( sum - expSum ) ) NEW_LINE DEDENT
def printMissingElements ( arr , N ) : NEW_LINE INDENT diff = arr [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] - i != diff ) : NEW_LINE INDENT while ( diff < arr [ i ] - i ) : NEW_LINE INDENT print ( i + diff , end = " ▁ " ) NEW_LINE diff += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def maxsubstringLength ( S , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ' a ' or S [ i ] == ' e ' or S [ i ] == ' i ' or S [ i ] == ' o ' or S [ i ] == ' u ' ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT DEDENT maxLen = 0 NEW_LINE curr_sum = 0 NEW_LINE hash = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if ( curr_sum == 0 ) : NEW_LINE INDENT maxLen = max ( maxLen , i + 1 ) NEW_LINE DEDENT if ( curr_sum in hash . keys ( ) ) : NEW_LINE INDENT maxLen = max ( maxLen , i - hash [ curr_sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash [ curr_sum ] = i NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
def countSubString ( S , C ) : NEW_LINE INDENT count = 0 NEW_LINE conCount = 0 NEW_LINE for ch in S : NEW_LINE INDENT if ( ch == C ) : NEW_LINE INDENT conCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( ( conCount * ( conCount + 1 ) ) // 2 ) NEW_LINE conCount = 0 NEW_LINE DEDENT DEDENT count += ( ( conCount * ( conCount + 1 ) ) // 2 ) NEW_LINE print ( count ) NEW_LINE DEDENT
def exponential ( n , x ) : NEW_LINE INDENT sum = 1.0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT sum = 1 + x * sum / i NEW_LINE DEDENT print ( " e ^ x ▁ = " , sum ) NEW_LINE DEDENT
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( a & 1 ) ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( b & 1 ) ; NEW_LINE DEDENT if ( ( a & 1 ) == 0 ) : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( n % 3 != 0 ) else False ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return True if ( ( n - 1 ) % 3 != 0 ) else False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( ( n + 1 ) % 3 != 0 ) else False ; NEW_LINE DEDENT DEDENT DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE n = 3 ; NEW_LINE if ( findNature ( a , b , n ) == True ) : NEW_LINE INDENT print ( " Odd " , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " , end = " ▁ " ) ; NEW_LINE DEDENT
def count_square ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT k = n - i + 1 ; NEW_LINE count += ( k * k ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def check ( a , b , Na , Nb , k , m ) : NEW_LINE INDENT if ( Na < k or Nb < m ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT a . sort ( ) NEW_LINE a . sort ( ) NEW_LINE if ( a [ k - 1 ] < b [ Nb - m ] ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
def completeSequence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE open = 0 NEW_LINE close = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT open += 1 NEW_LINE DEDENT else : NEW_LINE INDENT close += 1 NEW_LINE DEDENT if ( close > open ) : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( s , end = " " ) NEW_LINE for i in range ( open - close ) : NEW_LINE INDENT print ( " ) " , end = " " ) NEW_LINE DEDENT DEDENT
def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT
def printNum ( L , R ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT temp = i NEW_LINE c = 10 NEW_LINE flag = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 10 >= c ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT c = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def averageRuns ( runs , matches , notout ) : NEW_LINE INDENT out = matches - notout ; NEW_LINE if ( out == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT avg = runs // out ; NEW_LINE return avg ; NEW_LINE DEDENT runs = 10000 ; NEW_LINE matches = 250 ; NEW_LINE notout = 50 ; NEW_LINE avg = averageRuns ( runs , matches , notout ) ; NEW_LINE if ( avg == - 1 ) : NEW_LINE INDENT print ( " NA " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( avg ) ; NEW_LINE DEDENT
def multiplyBySevenByEight ( n ) : NEW_LINE INDENT return ( n - ( n >> 3 ) ) NEW_LINE DEDENT
def maxSelectionCount ( a , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE a . sort ( ) ; NEW_LINE select = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= select ) : NEW_LINE DEDENT DEDENT res += 1 ; NEW_LINE select += 1 ; NEW_LINE INDENT return res ; NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE DEDENT
def minParentheses ( p ) : NEW_LINE INDENT bal = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , len ( p ) ) : NEW_LINE INDENT if ( p [ i ] == ' ( ' ) : NEW_LINE INDENT bal += 1 NEW_LINE DEDENT else : NEW_LINE INDENT bal += - 1 NEW_LINE DEDENT if ( bal == - 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE bal += 1 NEW_LINE DEDENT DEDENT return bal + ans NEW_LINE DEDENT
def minSwaps ( N , M , A , B ) : NEW_LINE INDENT count01 = 0 NEW_LINE count10 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , M ) : NEW_LINE INDENT if ( A [ i ] [ j ] != B [ i ] [ j ] ) : NEW_LINE INDENT if ( A [ i ] [ j ] == 1 ) : NEW_LINE INDENT count10 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count01 += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( count01 == count10 ) : NEW_LINE INDENT return count01 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n >= 5 ) : NEW_LINE INDENT n //= 5 NEW_LINE count += n NEW_LINE DEDENT return count NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 ; NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def printModulus ( X , Y ) : NEW_LINE INDENT d = abs ( X - Y ) ; NEW_LINE i = 1 ; NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT print ( i , end = " " ) ; NEW_LINE if ( d // i != i ) : NEW_LINE INDENT print ( d // i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT
def SubseqWidths ( A ) : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE N = len ( A ) NEW_LINE A . sort ( ) NEW_LINE pow2 = [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pow2 . append ( pow2 [ - 1 ] * 2 % MOD ) NEW_LINE DEDENT ans = 0 NEW_LINE for i , x in enumerate ( A ) : NEW_LINE INDENT ans = ( ans + ( pow2 [ i ] - pow2 [ N - 1 - i ] ) * x ) % MOD NEW_LINE DEDENT return ans NEW_LINE DEDENT
def count ( N ) : NEW_LINE INDENT odd_indices = N // 2 NEW_LINE even_indices = N // 2 + N % 2 NEW_LINE arrange_odd = 4 ** odd_indices NEW_LINE arrange_even = 5 ** even_indices NEW_LINE return arrange_odd * arrange_even NEW_LINE DEDENT
def balancedTernary ( n ) : NEW_LINE INDENT output = " " NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 3 NEW_LINE n = n // 3 NEW_LINE if ( rem == 2 ) : NEW_LINE INDENT rem = - 1 NEW_LINE n += 1 NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT output = '0' + output NEW_LINE DEDENT else : NEW_LINE INDENT if ( rem == 1 ) : NEW_LINE INDENT output = '1' + output NEW_LINE DEDENT else : NEW_LINE INDENT output = ' Z ' + output NEW_LINE DEDENT DEDENT DEDENT return output NEW_LINE DEDENT
def MinOfCubedDP ( k ) : NEW_LINE INDENT DP = [ 0 ] * ( k + 1 ) ; NEW_LINE j = 1 ; NEW_LINE t = 1 ; NEW_LINE DP [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT DP [ i ] = sys . maxsize ; NEW_LINE while ( j <= i ) : NEW_LINE INDENT if ( j == i ) : NEW_LINE INDENT DP [ i ] = 1 ; NEW_LINE DEDENT elif ( DP [ i ] > DP [ i - j ] ) : NEW_LINE INDENT DP [ i ] = DP [ i - j ] + 1 ; NEW_LINE DEDENT t += 1 ; NEW_LINE j = t * t * t ; NEW_LINE DEDENT t = j = 1 ; NEW_LINE DEDENT return DP [ k ] ; NEW_LINE DEDENT
def Mixture ( X , Y , Z ) : NEW_LINE INDENT result = 0.0 NEW_LINE result1 = 0.0 NEW_LINE result1 = ( ( X - Y ) / X ) NEW_LINE result = pow ( result1 , Z ) NEW_LINE result = result * X NEW_LINE return result NEW_LINE DEDENT
def cntWays ( string , n ) : NEW_LINE INDENT x = n + 1 ; NEW_LINE ways = x * x * ( x * x - 1 ) // 12 ; NEW_LINE return ways ; NEW_LINE DEDENT
def SumofInverseDivisors ( N , Sum ) : NEW_LINE INDENT ans = float ( Sum ) * 1.0 / float ( N ) ; NEW_LINE return round ( ans , 2 ) ; NEW_LINE DEDENT
def vectorMagnitude ( x , y , z ) : NEW_LINE INDENT sum = x * x + y * y + z * z NEW_LINE return sqrt ( sum ) NEW_LINE DEDENT
def countSubSeq ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPentadecagon ( N ) : NEW_LINE INDENT n = ( 11 + sqrt ( 104 * N + 121 ) ) / 26 ; NEW_LINE return ( n - int ( n ) == 0 ) ; NEW_LINE DEDENT
def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ int ( ch ) for ch in st ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT st = "3144" NEW_LINE if ( isSubSeqDivisible ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def EqualNumber ( A , B ) : NEW_LINE INDENT return ( A ^ B ) NEW_LINE DEDENT
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
def findUnique ( a , n , k ) : NEW_LINE INDENT INT_SIZE = 8 * sys . getsizeof ( int ) NEW_LINE count = [ 0 ] * INT_SIZE NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( a [ j ] & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT res += ( count [ i ] % k ) * ( 1 << i ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def Maxcost ( s , cost ) : NEW_LINE INDENT count = 0 NEW_LINE maxcost = 0 NEW_LINE i = 0 NEW_LINE while i < len ( s ) - 1 : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT if cost [ i ] > cost [ i + 1 ] : NEW_LINE INDENT maxcost += cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT maxcost += cost [ i + 1 ] NEW_LINE cost [ i + 1 ] = cost [ i ] NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return maxcost NEW_LINE DEDENT
def find ( N , sum ) : NEW_LINE INDENT if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return 1.0 / 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT s = s + find ( N - 1 , sum - i ) / 6 NEW_LINE DEDENT return s NEW_LINE DEDENT
def GenerateArray ( N , X ) : NEW_LINE INDENT prev_xor = X NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT print ( i ^ prev_xor , end = " " ) NEW_LINE if ( i != N ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT prev_xor = i NEW_LINE DEDENT DEDENT
def MinOperation ( a , b , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] > b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT elif ( a [ i ] < b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def distinctCount ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( abs ( arr [ i ] ) ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 4 ; NEW_LINE pi = 1 ; po = 1 ; NEW_LINE n = N ; NEW_LINE while ( n > 1 ) : NEW_LINE INDENT pi *= n - 1 ; NEW_LINE n -= 1 ; NEW_LINE po *= 2 ; NEW_LINE DEDENT nth = ( first_term * pi ) // po ; NEW_LINE return nth ; NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N - 1 ) * ( N - 2 ) / 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findMinLength ( arr , N ) : NEW_LINE INDENT front = 0 NEW_LINE back = N - 1 NEW_LINE while ( front < back ) : NEW_LINE INDENT x = arr [ front ] NEW_LINE if arr [ front ] != arr [ back ] : NEW_LINE INDENT break NEW_LINE DEDENT while ( arr [ front ] == x and front <= back ) : NEW_LINE INDENT front += 1 NEW_LINE DEDENT while ( arr [ back ] == x and front <= back ) : NEW_LINE INDENT back -= 1 NEW_LINE DEDENT DEDENT print ( back - front + 1 ) NEW_LINE DEDENT
def TetracontaoctagonalNum ( n ) : NEW_LINE INDENT return ( 46 * n * n - 44 * n ) / 2 ; NEW_LINE DEDENT
def sumBitDifferences ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans += ( count * ( n - count ) * 2 ) ; NEW_LINE DEDENT return ans NEW_LINE DEDENT
def distance ( r , R ) : NEW_LINE INDENT d = math . sqrt ( ( R ** 2 ) - ( 2 * r * R ) ) NEW_LINE return d NEW_LINE DEDENT
def findMinimumTime ( tasks , K ) : NEW_LINE INDENT map = { } NEW_LINE curr_time = 0 NEW_LINE for c in tasks : NEW_LINE INDENT if ( c in map ) : NEW_LINE INDENT if ( curr_time - map <= K ) : NEW_LINE INDENT curr_time += K - ( curr_time - map ) + 1 NEW_LINE DEDENT DEDENT map = curr_time NEW_LINE curr_time += 1 NEW_LINE DEDENT print ( curr_time ) NEW_LINE DEDENT
def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT print ( N * ceil ( pow ( 2 , ( N - 1 ) ) / N ) ) NEW_LINE DEDENT
def findRepeatFirstN2 ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( p != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT
def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isStar ( N ) : NEW_LINE INDENT n = ( math . sqrt ( 24 * N + 12 ) + 6 ) / 6 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT i = 13 NEW_LINE if isStar ( i ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def solve ( a , n ) : NEW_LINE INDENT mx = - sys . maxsize - 1 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( mx > a [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT mx = max ( mx , a [ j - 1 ] ) NEW_LINE DEDENT return True NEW_LINE DEDENT a = [ 1 , 0 , 2 ] NEW_LINE n = len ( a ) NEW_LINE possible = solve ( a , n ) NEW_LINE if ( possible != 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT
def Colour_Combination ( s ) : NEW_LINE INDENT temp = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) , 1 ) : NEW_LINE INDENT if ( temp != s [ i ] ) : NEW_LINE INDENT if ( ( temp == ' B ' or temp == ' G ' ) and ( s [ i ] == ' G ' or s [ i ] == ' B ' ) ) : NEW_LINE INDENT temp = ' Y ' NEW_LINE DEDENT elif ( ( temp == ' B ' or temp == ' Y ' ) and ( s [ i ] == ' Y ' or s [ i ] == ' B ' ) ) : NEW_LINE INDENT temp = ' G ' NEW_LINE DEDENT else : NEW_LINE INDENT temp = ' B ' NEW_LINE DEDENT DEDENT DEDENT return temp NEW_LINE DEDENT
def totalTriangles ( h , v ) : NEW_LINE INDENT if ( h == 0 and v == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( h == 0 ) : NEW_LINE INDENT return ( ( v + 1 ) * ( v + 2 ) / 2 ) NEW_LINE DEDENT if ( v == 0 ) : NEW_LINE INDENT return ( h + 1 ) NEW_LINE DEDENT total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) NEW_LINE return total NEW_LINE DEDENT
def lucas ( n ) : NEW_LINE INDENT a = 2 NEW_LINE b = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT
def checkJumbled ( num ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( num != 0 ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT digit1 = num % 10 NEW_LINE digit2 = ( num / 10 ) % 10 NEW_LINE if ( abs ( digit2 - digit1 ) > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = num / 10 NEW_LINE DEDENT return True NEW_LINE DEDENT num = - 1234 NEW_LINE if ( checkJumbled ( abs ( num ) ) ) : NEW_LINE INDENT print " True ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT print " False " NEW_LINE DEDENT num = - 1247 NEW_LINE if ( checkJumbled ( abs ( num ) ) ) : NEW_LINE INDENT print " True ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT print " False " NEW_LINE DEDENT
def createArray ( n , s ) : NEW_LINE INDENT if ( 2 * n <= s ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE s -= 2 NEW_LINE DEDENT print ( s ) NEW_LINE print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT
def solve ( arr , n ) : NEW_LINE INDENT countzeroes = 0 ; NEW_LINE countones = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT countzeroes += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countones += 1 ; NEW_LINE DEDENT DEDENT if ( abs ( countzeroes - countones ) == 1 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and ( arr [ j ] not in s ) ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) // 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def prodSquare ( n ) : NEW_LINE INDENT for i in range ( 2 , ( n ) + 1 ) : NEW_LINE INDENT if ( i * i < ( n + 1 ) ) : NEW_LINE INDENT for j in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( ( i * i * j * j ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return False ; NEW_LINE DEDENT
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT ans += b // n NEW_LINE ans += 1 if ( i % n + b % n ) >= n else 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isOsiris ( n ) : NEW_LINE INDENT a = n % 10 NEW_LINE b = ( n // 10 ) % 10 NEW_LINE c = n // 100 NEW_LINE digit_sum = a + b + c NEW_LINE if ( n == ( 2 * ( digit_sum ) * 11 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def checkEVENodd ( arr , n , l , r ) : NEW_LINE INDENT if ( arr [ r ] == 1 ) : NEW_LINE INDENT print ( " odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT DEDENT
def sumSquare ( n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT s [ i * i ] = 1 NEW_LINE if ( n - i * i ) in s . keys ( ) : NEW_LINE INDENT print ( ( n - i * i ) ** ( 1 / 2 ) , " ^ 2 ▁ + " , i , " ^ 2" ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 1 NEW_LINE if n == 1 : NEW_LINE INDENT print ( '0 ^ 2 ▁ + ▁ 1 ^ 2' ) NEW_LINE DEDENT elif ( sumSquare ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isCentereddecagonal ( N ) : NEW_LINE INDENT n = ( 5 + np . sqrt ( 20 * N + 5 ) ) / 10 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT N = 11 NEW_LINE if ( isCentereddecagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isConversionPossible ( s1 , s2 , x ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE s1 = list ( s1 ) NEW_LINE s2 = list ( s2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT diff = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE if diff == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if diff < 0 : NEW_LINE INDENT diff = diff + 26 NEW_LINE DEDENT if diff > x : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isDefeat ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( s1 [ i ] == '0' and s2 [ i ] == '1' ) or ( s1 [ i ] == '1' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( s1 [ i ] == '0' and s2 [ i ] == ' Z ' ) or ( s1 [ i ] == ' Z ' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s1 = "01001101ZZ " NEW_LINE s2 = "10Z1001000" NEW_LINE n = 10 NEW_LINE if ( isDefeat ( s1 , s2 , n ) ) : NEW_LINE INDENT print ( " Defeat " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Victory " ) NEW_LINE DEDENT
def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT
def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , max ( b , c ) ) NEW_LINE get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , " ▁ " , get_mid , " ▁ " , get_max ) NEW_LINE DEDENT
def firstSetBit ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT
def dealnnoy ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def totalSubSets ( n , l , r ) : NEW_LINE INDENT MOD = 1000000007 ; NEW_LINE zero = ( math . floor ( r / 3 ) - math . ceil ( l / 3 ) + 1 ) ; NEW_LINE one = ( math . floor ( ( r - 1 ) / 3 ) - math . ceil ( ( l - 1 ) / 3 ) + 1 ) ; NEW_LINE two = ( math . floor ( ( r - 2 ) / 3 ) - math . ceil ( ( l - 2 ) / 3 ) + 1 ) ; NEW_LINE dp = [ [ 0 for x in range ( 3 ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = zero ; NEW_LINE dp [ 0 ] [ 1 ] = one ; NEW_LINE dp [ 0 ] [ 2 ] = two ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; NEW_LINE dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; NEW_LINE dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; NEW_LINE DEDENT return dp [ n - 1 ] [ 0 ] ; NEW_LINE DEDENT
def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if mat [ i ] [ j ] != mat [ j ] [ i ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
def findLast ( mat ) : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE rows = set ( ) NEW_LINE cols = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] : NEW_LINE INDENT rows . add ( i ) NEW_LINE cols . add ( j ) NEW_LINE DEDENT DEDENT DEDENT avRows = m - len ( list ( rows ) ) NEW_LINE avCols = n - len ( list ( cols ) ) NEW_LINE choices = min ( avRows , avCols ) NEW_LINE if choices & 1 : NEW_LINE INDENT print ( ' P1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' P2' ) NEW_LINE DEDENT DEDENT
def count ( N , X , subStr , index , n ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = subStr + N [ index ] NEW_LINE b = 0 NEW_LINE if ( int ( a ) % X == 0 ) : NEW_LINE INDENT b = 1 NEW_LINE DEDENT m1 = count ( N , X , a , index + 1 , n ) NEW_LINE m2 = b + count ( N , X , " " , index + 1 , n ) NEW_LINE return max ( m1 , m2 ) NEW_LINE DEDENT
def evenFib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT
def permutationCoeff ( n , k ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT return int ( fact [ n ] / fact [ n - k ] ) NEW_LINE DEDENT
def Centered_Triangular_num ( n ) : NEW_LINE INDENT return ( 3 * n * n + 3 * n + 2 ) // 2 NEW_LINE DEDENT
def findMedian ( a , n ) : NEW_LINE INDENT sorted ( a ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT return float ( a [ n // 2 ] ) NEW_LINE DEDENT return float ( ( a [ int ( ( n - 1 ) / 2 ) ] + a [ int ( n / 2 ) ] ) / 2.0 ) NEW_LINE DEDENT
def count ( self , temp , key ) : NEW_LINE INDENT if temp is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT if temp . data == key : NEW_LINE INDENT return 1 + count ( temp . next , key ) NEW_LINE DEDENT return count ( temp . next , key ) NEW_LINE DEDENT
def findRadiusOfcircumcircle ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT radius = ( math . sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ) ; NEW_LINE return radius ; NEW_LINE DEDENT
def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def mulsum ( arr , n , N ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] % N == 0 : NEW_LINE INDENT sums = sums + arr [ i ] NEW_LINE DEDENT DEDENT print ( sums ) NEW_LINE DEDENT
def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT two_digit_num = ( ( ( int ) ( num [ l - 2 ] ) ) * 10 + ( int ) ( num [ l - 1 ] ) ) NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT sm = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sm = sm + ( int ) ( num [ i ] ) NEW_LINE DEDENT if ( sm % 9 != 0 ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT return ( " Yes " ) NEW_LINE DEDENT
def isRepdigit ( num , b ) : NEW_LINE INDENT prev = - 1 NEW_LINE while ( num ) : NEW_LINE INDENT digit = num % b NEW_LINE num //= b NEW_LINE if ( prev != - 1 and digit != prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = digit NEW_LINE DEDENT return True NEW_LINE DEDENT num = 2000 NEW_LINE base = 7 NEW_LINE if ( isRepdigit ( num , base ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def CountTriplets ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT first ^= arr [ j ] NEW_LINE if ( first == 0 ) : NEW_LINE INDENT ans += ( j - i ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findAns ( mat , x , y , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT ans += ( abs ( x - i ) + abs ( y - j ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def maxRepeating ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ arr [ i ] % k ] += k NEW_LINE DEDENT max = arr [ 0 ] NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE result = i NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def FindMaxS ( X , Y , Z , n , A , B , C ) : NEW_LINE INDENT if ( X < 0 or Y < 0 or Z < 0 ) : NEW_LINE INDENT return - sys . maxsize - 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ X ] [ Y ] [ Z ] NEW_LINE DEDENT ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) NEW_LINE ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) NEW_LINE co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) NEW_LINE no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) NEW_LINE maximum = max ( ch , max ( ca , max ( co , no ) ) ) NEW_LINE dp [ n ] [ X ] [ Y ] [ Z ] = maximum NEW_LINE return dp [ n ] [ X ] [ Y ] [ Z ] NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( n == 4 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT return 4 ; NEW_LINE DEDENT table = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = 0 ; NEW_LINE DEDENT table [ 0 ] = 0 ; NEW_LINE table [ 2 ] = 1 ; NEW_LINE table [ 4 ] = 2 ; NEW_LINE table [ 6 ] = 4 ; NEW_LINE for i in range ( 8 , n + 1 , 2 ) : NEW_LINE INDENT table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; NEW_LINE DEDENT return table [ n ] ; NEW_LINE DEDENT
def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT
def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < _min : NEW_LINE INDENT _min = count NEW_LINE DEDENT DEDENT return _min NEW_LINE DEDENT
def closestNumber ( n , m ) : NEW_LINE INDENT q = int ( n / m ) NEW_LINE n1 = m * q NEW_LINE if ( ( n * m ) > 0 ) : NEW_LINE INDENT n2 = ( m * ( q + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n2 = ( m * ( q - 1 ) ) NEW_LINE DEDENT if ( abs ( n - n1 ) < abs ( n - n2 ) ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT sm = - 1000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : NEW_LINE INDENT sm = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return sm NEW_LINE DEDENT
def adjacentSet ( n ) : NEW_LINE INDENT return ( n & ( n >> 1 ) ) NEW_LINE DEDENT
def maxGcd ( a , b ) : NEW_LINE INDENT print ( abs ( a - b ) ) NEW_LINE DEDENT
def TowerOfHanoi ( n , from_rod , to_rod , aux_rod ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( " Move ▁ disk ▁ 1 ▁ from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE return NEW_LINE DEDENT TowerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE TowerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) NEW_LINE DEDENT
def sortExceptUandL ( a , l , u , n ) : NEW_LINE INDENT b = [ 0 ] * ( n - ( u - l + 1 ) ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT b [ l + ( i - ( u + 1 ) ) ] = a [ i ] NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT a [ i ] = b [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT a [ i ] = b [ l + ( i - ( u + 1 ) ) ] NEW_LINE DEDENT DEDENT a = [ 5 , 4 , 3 , 12 , 14 , 9 ] NEW_LINE n = len ( a ) NEW_LINE l = 2 NEW_LINE u = 4 NEW_LINE sortExceptUandL ( a , l , u , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " { } ▁ " . format ( a [ i ] ) , end = " " ) NEW_LINE DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT max_value = max ( arr ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( max_value arr [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def inProportion ( arr ) : NEW_LINE INDENT n = 4 ; NEW_LINE arr . sort ( ) NEW_LINE extremes = arr [ 0 ] * arr [ 3 ] ; NEW_LINE means = arr [ 1 ] * arr [ 2 ] ; NEW_LINE if ( extremes == means ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def findWays ( p ) : NEW_LINE INDENT dp = [ 0 ] * ( p + 1 ) NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 2 NEW_LINE for i in range ( 3 , p + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return dp [ p ] NEW_LINE DEDENT
def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return d NEW_LINE DEDENT
def doMatch ( A , B ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] != ' * ' and B [ i ] != ' * ' : NEW_LINE INDENT if A [ i ] != B [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def countTriplets ( N ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for A in range ( 1 , N + 1 ) : NEW_LINE INDENT for B in range ( 1 , N // A + 1 ) : NEW_LINE INDENT cnt += N // ( A * B ) ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def findMinSum ( mat , N ) : NEW_LINE INDENT sum1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT res |= mat [ i ] [ j ] NEW_LINE DEDENT DEDENT sum1 += res NEW_LINE DEDENT return sum1 NEW_LINE DEDENT
def generatepermutation ( N ) : NEW_LINE INDENT answer = [ ] NEW_LINE answer . append ( N ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT answer . append ( i ) NEW_LINE DEDENT print ( * answer ) NEW_LINE DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT
def countSubstrs ( str , i , j , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) NEW_LINE if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def lastDigit2PowerN ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n % 4 == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif n % 4 == 2 : NEW_LINE INDENT return 4 NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT return 8 NEW_LINE DEDENT else : NEW_LINE DEDENT for n in range ( 20 ) : NEW_LINE INDENT print ( lastDigit2PowerN ( n ) , end = " ▁ " ) NEW_LINE DEDENT
def IsPrime ( i ) : NEW_LINE INDENT if ( i % 2 == 0 and i != 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( 3 , int ( math . sqrt ( i ) + 1 ) , 2 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT DEDENT c = 0 ; NEW_LINE N = 72 ; NEW_LINE for i in range ( 2 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( IsPrime ( i ) ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT c = c + 1 NEW_LINE if ( IsPrime ( N / i ) and i != ( N / i ) ) : NEW_LINE INDENT c = c + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def MaximumPath ( Mat ) : NEW_LINE INDENT result = 0 NEW_LINE dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT result = max ( result , dp [ N - 1 ] [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return false NEW_LINE DEDENT n = 17 NEW_LINE l = 2 NEW_LINE r = 4 NEW_LINE if ( allBitsSetInTheGivenRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findTemperature ( x , y , s ) : NEW_LINE INDENT diff = ( x - y ) * 6 NEW_LINE Day2 = ( diff + s ) // 2 NEW_LINE Day1 = s - Day2 NEW_LINE print ( " Day1 ▁ : ▁ " , Day1 ) NEW_LINE print ( " Day2 ▁ : ▁ " , Day2 ) NEW_LINE DEDENT
def numberOfTriangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 ; NEW_LINE return ans ; NEW_LINE DEDENT
def areaSquare ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT if ( not m ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + superSeq ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) NEW_LINE DEDENT
def findNumber ( N ) : NEW_LINE INDENT ans = [ 1 , 2 , 4 , 8 , 7 , 5 ] NEW_LINE return ans [ N % 6 ] NEW_LINE DEDENT
def shuffle ( N , key ) : NEW_LINE INDENT NO_OF_BITS = N NEW_LINE reverse_num = 0 NEW_LINE for i in range ( NO_OF_BITS ) : NEW_LINE INDENT temp = ( key & ( 1 << i ) ) NEW_LINE if ( temp ) : NEW_LINE INDENT reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) NEW_LINE DEDENT DEDENT print ( reverse_num ) NEW_LINE DEDENT
def FindSub ( string , res , i ) : NEW_LINE INDENT if ( i == len ( string ) ) : NEW_LINE INDENT if ( len ( res ) > 0 ) : NEW_LINE INDENT print ( res , end = " ▁ " ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT ch = string [ i ] ; NEW_LINE FindSub ( string , res , i + 1 ) ; NEW_LINE FindSub ( string , res + ch , i + 1 ) ; NEW_LINE FindSub ( string , res + str ( ord ( ch ) ) , i + 1 ) ; NEW_LINE DEDENT
def findAngle ( M1 , M2 ) : NEW_LINE INDENT PI = 3.14159265 NEW_LINE angle = abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) NEW_LINE ret = atan ( angle ) NEW_LINE val = ( ret * 180 ) / PI NEW_LINE print ( round ( val , 4 ) ) NEW_LINE DEDENT
def binary_searched_find_x ( k ) : NEW_LINE INDENT l = 0 NEW_LINE r = k NEW_LINE ans = 0 NEW_LINE while l <= r : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( ( mid * ( mid + 1 ) ) // 2 ) ** 2 >= k : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minPoints ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( ( n % 2 != 0 ) and ( m % 2 != 0 ) ) : NEW_LINE INDENT ans = ( ( n * m ) // 2 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( n * m ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sentencePalindrome ( s ) : NEW_LINE INDENT l , h = 0 , len ( s ) - 1 NEW_LINE s = s . lower ( ) NEW_LINE while ( l <= h ) : NEW_LINE INDENT if ( not ( s [ l ] >= ' a ' and s [ l ] <= ' z ' ) ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( not ( s [ h ] >= ' a ' and s [ h ] <= ' z ' ) ) : NEW_LINE INDENT h -= 1 NEW_LINE DEDENT elif ( s [ l ] == s [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " Too ▁ hot ▁ to ▁ hoot . " NEW_LINE if ( sentencePalindrome ( s ) ) : NEW_LINE INDENT print " Sentence ▁ is ▁ palindrome . " NEW_LINE DEDENT else : NEW_LINE INDENT print " Sentence ▁ is ▁ not ▁ palindrome . " NEW_LINE DEDENT
def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT
def findAnswer ( X , N ) : NEW_LINE INDENT return ( N - 1 ) * 9 + X ; NEW_LINE DEDENT
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; NEW_LINE DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
def maxbalancedprefix ( str , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE maxi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == ' ( ' : NEW_LINE INDENT _sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT _sum -= 1 NEW_LINE DEDENT if _sum < 0 : NEW_LINE INDENT break NEW_LINE DEDENT if _sum == 0 : NEW_LINE INDENT maxi = i + 1 NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def productOfSingelDgt ( n ) : NEW_LINE INDENT if n >= 0 and n <= 9 : NEW_LINE INDENT return True NEW_LINE DEDENT prime = [ 2 , 3 , 5 , 7 ] NEW_LINE i = 0 NEW_LINE while i < SIZE and n > 1 : NEW_LINE INDENT while n % prime [ i ] == 0 : NEW_LINE INDENT n = n / prime [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n == 1 NEW_LINE DEDENT n = 24 NEW_LINE if productOfSingelDgt ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minimumStepReqArr ( arr , N ) : NEW_LINE INDENT cntStep = 0 NEW_LINE N += 1 NEW_LINE i = 31 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE INDENT cntStep += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return cntStep NEW_LINE DEDENT
def twoWaySort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 3 , 2 , 7 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE twoWaySort ( arr , n ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def minimumIncreasingSubsequences ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freqX = 0 NEW_LINE while ( i < N and arr [ i ] == x ) : NEW_LINE INDENT freqX += 1 NEW_LINE i += 1 NEW_LINE DEDENT count = max ( count , freqX ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def countSquares ( r , c , m ) : NEW_LINE INDENT squares = 0 NEW_LINE for i in range ( 1 , 9 ) : NEW_LINE INDENT for j in range ( 1 , 9 ) : NEW_LINE INDENT if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) : NEW_LINE INDENT squares = squares + 1 NEW_LINE DEDENT DEDENT DEDENT return squares NEW_LINE DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def increment ( i ) : NEW_LINE INDENT i = - ( ~ i ) ; NEW_LINE return i ; NEW_LINE DEDENT
def squareArea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT area = ( 1.268 ** 2 ) * ( a ** 2 ) ; NEW_LINE return area ; NEW_LINE DEDENT
def findMin ( arr , N , k ) : NEW_LINE INDENT pairs = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pairs += arr [ i ] / 2 NEW_LINE DEDENT if ( k > pairs ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * k + N - 1 NEW_LINE DEDENT DEDENT
def nearestPerfectSquare ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT sr = math . floor ( math . sqrt ( arr [ i ] ) ) NEW_LINE a = sr * sr NEW_LINE b = ( sr + 1 ) * ( sr + 1 ) NEW_LINE if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) : NEW_LINE print ( a , end = " ▁ " ) NEW_LINE else : NEW_LINE print ( b , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) ; NEW_LINE arr [ 1 ] = 4 NEW_LINE arr [ 2 ] = 7 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 4 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 7 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT
def weightedMean ( X , W , n ) : NEW_LINE INDENT sum = 0 NEW_LINE numWeight = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT numWeight = numWeight + X [ i ] * W [ i ] NEW_LINE sum = sum + W [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT return ( float ) ( numWeight / sum ) NEW_LINE DEDENT X = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE W = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( X ) NEW_LINE m = len ( W ) NEW_LINE if ( n == m ) : NEW_LINE INDENT print weightedMean ( X , W , n ) NEW_LINE DEDENT else : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE x = 1 NEW_LINE while x <= n : NEW_LINE INDENT sum = sum + x NEW_LINE x = x + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def smallestNum ( n ) : NEW_LINE INDENT res = 1 NEW_LINE i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT length = int ( log10 ( i ) + 1 ) NEW_LINE if ( length == n ) : NEW_LINE INDENT return int ( log ( i ) // log ( 2 ) ) NEW_LINE DEDENT i *= 2 NEW_LINE DEDENT DEDENT
def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N - 1 ) : NEW_LINE INDENT if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair = oddPair + 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT
def maximizeProduct ( N ) : NEW_LINE INDENT MSB = ( int ) ( math . log2 ( N ) ) NEW_LINE X = 1 << MSB NEW_LINE Y = N - ( 1 << MSB ) NEW_LINE for i in range ( MSB ) : NEW_LINE INDENT if ( not ( N & ( 1 << i ) ) ) : NEW_LINE INDENT X += 1 << i NEW_LINE Y += 1 << i NEW_LINE DEDENT DEDENT print ( X , Y ) NEW_LINE DEDENT
def kthNonDivisible ( N , K ) : NEW_LINE INDENT return K + math . floor ( ( K - 1 ) / ( N - 1 ) ) NEW_LINE DEDENT
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 ; NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , 19 ) : NEW_LINE INDENT fact = fact * i ; NEW_LINE m [ fact ] = i ; NEW_LINE DEDENT DEDENT
def maxPointCount ( arr , K , size ) : NEW_LINE INDENT curr_points = 0 NEW_LINE max_points = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT curr_points += arr [ i ] NEW_LINE DEDENT max_points = curr_points NEW_LINE j = size - 1 NEW_LINE for i in range ( K - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_points = ( curr_points + arr [ j ] - arr [ i ] ) NEW_LINE max_points = max ( curr_points , max_points ) NEW_LINE j -= 1 NEW_LINE DEDENT return max_points NEW_LINE DEDENT
def CountSubarray ( arr , n , k ) : NEW_LINE INDENT temp = k NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == temp ) : NEW_LINE INDENT if ( temp == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE temp = k NEW_LINE DEDENT else : NEW_LINE INDENT temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = k NEW_LINE if ( arr [ i ] == k ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findLCS ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return len ( mp ) NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 ; max_count = 0 ; min_count = n NEW_LINE for i in range ( 0 , ( n - 1 ) ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT max_count = max ( max_count , count ) NEW_LINE min_count = min ( min_count , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max_count - min_count NEW_LINE DEDENT
def findMaximumNum ( st , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( k < 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( st [ i ] != '9' ) : NEW_LINE INDENT st = st [ 0 : i ] + '9' + st [ i + 1 : ] NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT
def FindKthChar ( Str , K , X ) : NEW_LINE INDENT ans = ' ▁ ' NEW_LINE Sum = 0 NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT digit = ord ( Str [ i ] ) - 48 NEW_LINE Range = int ( math . pow ( digit , X ) ) NEW_LINE Sum += Range NEW_LINE if ( K <= Sum ) : NEW_LINE INDENT ans = Str [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printNumberWithDR ( k , d ) : NEW_LINE INDENT if d == 0 and k != 1 : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE k -= 1 NEW_LINE while k : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT
def gonNum257 ( n ) : NEW_LINE INDENT return ( 255 * n * n - 253 * n ) // 2 ; NEW_LINE DEDENT
def isTidy ( num ) : NEW_LINE INDENT prev = 10 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE num /= 10 NEW_LINE if rem > prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = rem NEW_LINE DEDENT return True NEW_LINE DEDENT num = 1556 NEW_LINE if isTidy ( num ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minimumDiff ( arr , N ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE sum1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += arr [ i ] NEW_LINE DEDENT min_diff = sum1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( abs ( sum1 - ( arr [ i ] * N ) ) < min_diff ) : NEW_LINE INDENT min_diff = abs ( sum1 - ( arr [ i ] * N ) ) NEW_LINE res = arr [ i ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def sum_series ( n ) : NEW_LINE INDENT nSquare = n * n NEW_LINE return int ( nSquare * ( nSquare - 1 ) / 4 ) NEW_LINE DEDENT
def largestNum ( n ) : NEW_LINE INDENT num = 0 ; NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT x = ( 1 << i ) ; NEW_LINE if ( ( x - 1 ) <= n ) : NEW_LINE INDENT num = ( 1 << i ) - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return num ; NEW_LINE DEDENT
def gcdMax ( a , b , n , N ) : NEW_LINE INDENT cnt = [ 0 ] * N NEW_LINE first = [ 0 ] * N NEW_LINE second = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] ) : NEW_LINE INDENT first [ i ] = max ( first [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT cnt = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT second [ i ] = max ( second [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT i = N - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( first [ i ] > 0 and second [ i ] > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( str ( first [ i ] ) + " ▁ " + str ( second [ i ] ) ) NEW_LINE DEDENT
def canMakeEqual ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE weightOfString = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT weightOfString += ord ( S [ i ] ) - ord ( ' a ' ) + 1 NEW_LINE DEDENT if ( weightOfString % N == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def Max_Sum ( arr1 , arr2 , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = arr1 [ i ] NEW_LINE dp [ i ] [ 1 ] = arr2 [ i ] NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) NEW_LINE DEDENT DEDENT return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT
def countNumbers ( x , n ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ) NEW_LINE DEDENT
def findFourElements ( A , n , X ) : NEW_LINE INDENT for i in range ( 0 , n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] + A [ l ] == X : NEW_LINE INDENT print ( " % d , ▁ % d , ▁ % d , ▁ % d " % ( A [ i ] , A [ j ] , A [ k ] , A [ l ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def findK ( A , n , m , k ) : NEW_LINE INDENT if ( n < 1 or m < 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k <= m ) : NEW_LINE INDENT return A [ 0 ] [ k - 1 ] NEW_LINE DEDENT if ( k <= ( m + n - 1 ) ) : NEW_LINE INDENT return A [ ( k - m ) ] [ m - 1 ] NEW_LINE DEDENT if ( k <= ( m + n - 1 + m - 1 ) ) : NEW_LINE INDENT return A [ n - 1 ] [ m - 1 - ( k - ( m + n - 1 ) ) ] NEW_LINE DEDENT if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) : NEW_LINE INDENT return A [ n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ 0 ] NEW_LINE DEDENT A . pop ( 0 ) NEW_LINE [ j . pop ( 0 ) for j in A ] NEW_LINE return findK ( A , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) NEW_LINE DEDENT
def maximumSumPermutation ( arr ) : NEW_LINE INDENT N = len ( arr ) ; NEW_LINE arr . sort ( ) ; NEW_LINE temp = arr [ 0 ] ; NEW_LINE arr [ 0 ] = arr [ N - 1 ] ; NEW_LINE arr [ N - 1 ] = temp ; NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( dp [ x ] ) NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT return n / 3 + n / 7 - n / 21 ; NEW_LINE DEDENT
def minOps ( arr , n , k ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max1 - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max1 - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return int ( res ) NEW_LINE DEDENT
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; NEW_LINE DEDENT DEDENT return dp [ W ] ; NEW_LINE DEDENT
def LIS ( a , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE d = [ 0 for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ a [ i ] ] = 1 NEW_LINE for j in range ( 2 , a [ i ] ) : NEW_LINE INDENT if j * j > a [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT if ( a [ i ] % j == 0 ) : NEW_LINE INDENT dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) NEW_LINE dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] // j ] ] + 1 ) NEW_LINE d [ j ] = a [ i ] NEW_LINE d [ a [ i ] // j ] = a [ i ] NEW_LINE DEDENT DEDENT ans = max ( ans , dp [ a [ i ] ] ) NEW_LINE d [ a [ i ] ] = a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSide ( a , B , C ) : NEW_LINE INDENT A = 180 - C - B NEW_LINE radA = math . pi * ( A / 180 ) NEW_LINE radB = math . pi * ( B / 180 ) NEW_LINE radC = math . pi * ( C / 180 ) NEW_LINE b = a / math . sin ( radA ) * math . sin ( radB ) NEW_LINE c = a / math . sin ( radA ) * math . sin ( radC ) NEW_LINE return b , c NEW_LINE DEDENT
def first_digit ( x , y ) : NEW_LINE INDENT length = int ( math . log ( x ) / math . log ( y ) + 1 ) NEW_LINE first_digit = x / math . pow ( y , length - 1 ) NEW_LINE print ( int ( first_digit ) ) NEW_LINE DEDENT
def maxOperations ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT diff = Y - X ; NEW_LINE if ( diff == 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( diff % 2 == 0 ) : NEW_LINE INDENT return ( diff // 2 ) ; NEW_LINE DEDENT return ( 1 + ( ( diff - 3 ) // 2 ) ) ; NEW_LINE DEDENT
def findPoint ( n , h ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( " { 0 : . 2f } " . format ( ( ( i / n ) ** 0.5 ) * h ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def minValue ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def find_number ( N , K ) : NEW_LINE INDENT r = " " NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += "00" NEW_LINE DEDENT return r NEW_LINE DEDENT
def computeXOR ( n ) : NEW_LINE INDENT switch = { 0 : n , 1 : 1 , 2 : n + 1 , 3 : 0 , } NEW_LINE return switch . get ( n & 3 , " " ) NEW_LINE DEDENT
def seriesFunc ( n ) : NEW_LINE INDENT sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE sumNatural = ( n * ( n + 1 ) / 2 ) NEW_LINE return ( sumSquare + sumNatural + 1 ) NEW_LINE DEDENT
def countSubStr ( st , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( st [ j ] == '1' ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def possibleToReach ( a , b ) : NEW_LINE INDENT c = np . cbrt ( a * b ) NEW_LINE re1 = a // c NEW_LINE re2 = b // c NEW_LINE if ( ( re1 * re1 * re2 == a ) and ( re2 * re2 * re1 == b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findSubsequenceCount ( S , T ) : NEW_LINE INDENT m = len ( T ) NEW_LINE n = len ( S ) NEW_LINE if m > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( n + 1 ) : NEW_LINE INDENT mat [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if T [ i - 1 ] != S [ j - 1 ] : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return mat [ m ] [ n ] NEW_LINE DEDENT
def minNum ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 210 * ( 10 ** ( n - 1 ) // 210 + 1 ) ) NEW_LINE DEDENT DEDENT
def countSubsequences ( s ) : NEW_LINE INDENT aCount = 0 NEW_LINE bCount = 0 NEW_LINE cCount = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT aCount = ( 1 + 2 * aCount ) NEW_LINE DEDENT elif ( s [ i ] == ' b ' ) : NEW_LINE INDENT bCount = ( aCount + 2 * bCount ) NEW_LINE DEDENT elif ( s [ i ] == ' c ' ) : NEW_LINE INDENT cCount = ( bCount + 2 * cCount ) NEW_LINE DEDENT DEDENT return cCount NEW_LINE DEDENT
def SubArrayProdct ( arr , n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result *= pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : NEW_LINE INDENT maxSum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] < k ) : NEW_LINE INDENT maxSum += arr [ i ] NEW_LINE maxSum += arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return maxSum NEW_LINE DEDENT
def countTotalDistinct ( string ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE items = set ( ) ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT temp = " " ; NEW_LINE ans = set ( ) ; NEW_LINE for j in range ( i , len ( string ) ) : NEW_LINE INDENT temp = temp + string [ j ] ; NEW_LINE ans . add ( string [ j ] ) ; NEW_LINE if temp not in items : NEW_LINE INDENT items . add ( temp ) ; NEW_LINE cnt += len ( ans ) ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def canBreakN ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT m = i * ( i + 1 ) // 2 NEW_LINE if ( m > n ) : NEW_LINE INDENT break NEW_LINE DEDENT k = n - m NEW_LINE if ( k % i ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( i ) NEW_LINE return NEW_LINE DEDENT print ( " - 1" ) NEW_LINE DEDENT
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( X , Y , m , n ) : NEW_LINE INDENT suffix = [ 0 ] * 1005 NEW_LINE total_pairs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT suffix [ Y [ i ] ] += 1 NEW_LINE DEDENT for i in range ( int ( 1e3 ) , 2 , - 1 ) : NEW_LINE INDENT suffix [ i ] += suffix [ i + 1 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( X [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( X [ i ] == 1 ) : NEW_LINE INDENT total_pairs += suffix [ 0 ] NEW_LINE continue NEW_LINE DEDENT elif ( X [ i ] == 2 ) : NEW_LINE INDENT total_pairs += suffix [ 5 ] NEW_LINE DEDENT elif ( X [ i ] == 3 ) : NEW_LINE INDENT total_pairs += ( suffix [ 2 ] + suffix [ 4 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT total_pairs += suffix [ X [ i ] + 1 ] NEW_LINE DEDENT total_pairs += suffix [ 0 ] + suffix [ 1 ] NEW_LINE DEDENT return total_pairs NEW_LINE DEDENT
def solve ( s ) : NEW_LINE INDENT area = ( 1.732 * s ** 2 ) / 8 NEW_LINE return area NEW_LINE DEDENT
def printt ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT print ( a [ i ] , " " , a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT
def minCostToMakeElementEqual ( a ) : NEW_LINE INDENT l = len ( a ) NEW_LINE if ( l % 2 == 1 ) : NEW_LINE INDENT y = a [ l // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT y = ( a [ l // 2 ] + a [ ( l - 2 ) // 2 ] ) // 2 NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT s += abs ( a [ i ] - y ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if i * j == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 9 , 40 ] NEW_LINE x = 400 NEW_LINE n = len ( arr ) NEW_LINE if ( isProduct ( arr , n , x ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT x = 900 NEW_LINE if ( isProduct ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countOddSquares ( n , m ) : NEW_LINE INDENT return int ( m ** 0.5 ) - int ( ( n - 1 ) ** 0.5 ) NEW_LINE DEDENT
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( n // i ) * i NEW_LINE DEDENT return sum - n * ( n + 1 ) // 2 NEW_LINE DEDENT
def HexacontatetragonNum ( n ) : NEW_LINE INDENT return ( 62 * n * n - 60 * n ) / 2 ; NEW_LINE DEDENT
def Numberofways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def no_of_moves ( Matrix , x , y ) : NEW_LINE INDENT moves = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( Matrix [ i ] [ j ] != 0 ) : NEW_LINE INDENT moves += abs ( x - i ) NEW_LINE moves += abs ( y - j ) NEW_LINE DEDENT DEDENT DEDENT print ( moves ) NEW_LINE DEDENT
def findSteps ( n , m , a ) : NEW_LINE INDENT cur = 1 NEW_LINE steps = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( a [ i ] >= cur ) : NEW_LINE INDENT steps += ( a [ i ] - cur ) NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( n - cur + a [ i ] ) NEW_LINE DEDENT cur = a [ i ] NEW_LINE DEDENT return steps NEW_LINE DEDENT
def solve ( low , high , T ) : NEW_LINE INDENT while low <= high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( mid * ( mid + 1 ) ) == T : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and ( mid * ( mid + 1 ) ) > T and ( mid * ( mid - 1 ) ) <= T ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( mid * ( mid + 1 ) ) > T : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT T = 15 NEW_LINE ans = solve ( 1 , T , 2 * T ) NEW_LINE if ans != - 1 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT
def count ( arr , low , high , x ) : NEW_LINE INDENT if ( ( low > high ) or ( low == high and arr [ low ] != x ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( low == high and arr [ low ] == x ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return count ( arr , low , ( low + high ) // 2 , x ) + count ( arr , 1 + ( low + high ) // 2 , high , x ) ; NEW_LINE DEDENT
def printOdds ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT set_bit = res & ( ~ ( res - 1 ) ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & set_bit ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( x , y , end = " " ) NEW_LINE DEDENT
def correlationCoefficient ( X , Y , n ) : NEW_LINE INDENT sum_X = 0 NEW_LINE sum_Y = 0 NEW_LINE sum_XY = 0 NEW_LINE squareSum_X = 0 NEW_LINE squareSum_Y = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum_X = sum_X + X [ i ] NEW_LINE sum_Y = sum_Y + Y [ i ] NEW_LINE sum_XY = sum_XY + X [ i ] * Y [ i ] NEW_LINE squareSum_X = squareSum_X + X [ i ] * X [ i ] NEW_LINE squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / NEW_LINE INDENT ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) NEW_LINE DEDENT return corr NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT num = ( ( n // 2 ) + 1 ) NEW_LINE Max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == Max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def solve ( values , salary ) : NEW_LINE INDENT ret = 1 NEW_LINE amt = 0 NEW_LINE values = sorted ( values ) NEW_LINE salary = sorted ( salary ) NEW_LINE while ( len ( salary ) > 0 ) : NEW_LINE INDENT while ( ( len ( values ) and values [ - 1 ] >= salary [ - 1 ] ) ) : NEW_LINE INDENT amt += 1 NEW_LINE del values [ - 1 ] NEW_LINE DEDENT if ( amt == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ret *= amt NEW_LINE amt -= 1 NEW_LINE ret %= MOD NEW_LINE del salary [ - 1 ] NEW_LINE DEDENT return ret NEW_LINE DEDENT
def String ( l , x , y ) : NEW_LINE INDENT p = 97 NEW_LINE for j in range ( l ) : NEW_LINE INDENT ans = chr ( p + j % y ) NEW_LINE print ( ans , end = " " ) NEW_LINE DEDENT DEDENT
def numberOfWays ( n , k ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n >= pow ( 2 , k ) ) : NEW_LINE INDENT curr_val = pow ( 2 , k ) NEW_LINE return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( n , k - 1 ) NEW_LINE DEDENT DEDENT
def equation_ellipse ( x1 , y1 , a , b , c , e ) : NEW_LINE INDENT t = a * a + b * b NEW_LINE a1 = t - e * ( a * a ) NEW_LINE b1 = t - e * ( b * b ) NEW_LINE c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) NEW_LINE d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) NEW_LINE e1 = - 2 * e * a * b NEW_LINE f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) NEW_LINE print ( " Equation ▁ of ▁ ellipse ▁ is " , a1 , " x ^ 2 ▁ + " , b1 , " y ^ 2 ▁ + " , c1 , " x ▁ + " , d1 , " y ▁ + " , e1 , " xy ▁ + " , f1 , " = ▁ 0" ) NEW_LINE DEDENT
def round ( n ) : NEW_LINE INDENT a = ( n // 10 ) * 10 NEW_LINE b = a + 10 NEW_LINE return ( b if n - a > b - n else a ) NEW_LINE DEDENT
def find_max ( i , sum , v , k ) : NEW_LINE INDENT if ( i == len ( v ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ sum ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) : NEW_LINE INDENT ans = find_max ( i + 1 , sum , v , k ) NEW_LINE DEDENT if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) : NEW_LINE INDENT ans = max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) NEW_LINE DEDENT dp [ i ] [ sum ] = ans NEW_LINE return dp [ i ] [ sum ] NEW_LINE DEDENT
def getCount ( rows , columns , A ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( i + 1 , rows , 1 ) : NEW_LINE INDENT if ( A [ i ] [ 0 ] * A [ j ] [ 1 ] == A [ i ] [ 1 ] * A [ j ] [ 0 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def SubMasks ( N ) : NEW_LINE INDENT S = N NEW_LINE while S > 0 : NEW_LINE INDENT print ( S , end = ' ▁ ' ) NEW_LINE S = ( S - 1 ) & N NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT
def sortArray ( A , N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE INDENT for i in range ( N // 2 ) : NEW_LINE INDENT x = i NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT y = N - i - 2 NEW_LINE z = N - i - 1 NEW_LINE DEDENT A [ z ] = A [ y ] NEW_LINE A [ y ] = A [ x ] NEW_LINE A [ x ] = x + 1 NEW_LINE DEDENT print ( " Sorted ▁ Array : ▁ " , end = " " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT
def largestNumber ( N ) : NEW_LINE INDENT if ( N > 45 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num = 0 NEW_LINE digit = 9 NEW_LINE while ( N > 0 and digit > 0 ) : NEW_LINE INDENT if ( digit <= N ) : NEW_LINE INDENT num *= 10 NEW_LINE num += digit NEW_LINE N -= digit NEW_LINE DEDENT digit -= 1 NEW_LINE DEDENT return num * 10 NEW_LINE DEDENT
def printFourSquares ( a ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i * i <= a ) : NEW_LINE INDENT j = i NEW_LINE while ( j * j <= a ) : NEW_LINE INDENT k = j NEW_LINE while ( k * k <= a ) : NEW_LINE INDENT l = k NEW_LINE while ( l * l <= a ) : NEW_LINE INDENT if ( i * i + j * j + k * k + l * l == a ) : NEW_LINE INDENT print ( " { } ▁ = ▁ { } * { } ▁ + ▁ { } * { } ▁ + " . format ( a , i , i , j , j ) , end = " ▁ " ) NEW_LINE print ( " { } * { } ▁ + ▁ { } * { } " . format ( k , k , l , l ) , end = " " ) NEW_LINE DEDENT l = l + 1 NEW_LINE DEDENT k = k + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
def countBuildings ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > curr_max or arr [ i ] == curr_max ) : NEW_LINE INDENT count += 1 NEW_LINE curr_max = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def minimumSteps ( a , b , c ) : NEW_LINE INDENT if a < 1 or b < 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if a == 1 and b == 1 : NEW_LINE INDENT return c NEW_LINE DEDENT if a < b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return minimumSteps ( a - b , b , c + 1 ) NEW_LINE DEDENT
def lastRemovedCharacter ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return ord ( str [ 0 ] ) NEW_LINE DEDENT if ( str [ n - 2 ] == '0' ) : NEW_LINE INDENT return ( ord ( '1' ) - ord ( str [ n - 1 ] ) + ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( str [ n - 1 ] ) NEW_LINE DEDENT DEDENT
def updateString ( S , A , B ) : NEW_LINE INDENT l = len ( A ) NEW_LINE i = 0 NEW_LINE while i + l <= len ( S ) : NEW_LINE INDENT curr = S [ i : i + l ] NEW_LINE if curr == A : NEW_LINE INDENT new_string = S [ 0 : i ] + B + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_string = S [ 0 : i ] + A + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return S NEW_LINE DEDENT
def numLen ( K ) : NEW_LINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT number = 0 NEW_LINE len = 1 NEW_LINE for len in range ( 1 , K + 1 ) : NEW_LINE INDENT number = ( number * 10 + 1 ) % K NEW_LINE if number == 0 : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def multiple ( a , b , x ) : NEW_LINE INDENT if ( b < 0 ) : NEW_LINE INDENT if ( a == 1 and x == 1 ) : NEW_LINE INDENT print ( "1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) ; NEW_LINE DEDENT DEDENT mul = int ( pow ( a , b ) ) ; NEW_LINE ans = int ( mul / x ) ; NEW_LINE ans1 = x * ans ; NEW_LINE ans2 = x * ( ans + 1 ) ; NEW_LINE if ( ( mul - ans1 ) <= ( ans2 - mul ) ) : NEW_LINE INDENT print ( ans1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans2 ) ; NEW_LINE DEDENT DEDENT
def minimumMEX ( arr , N , K ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , N + 2 , 1 ) : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT for i in range ( K ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT mex = list ( s ) [ 0 ] NEW_LINE for i in range ( K , N , 1 ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE s . add ( arr [ i - K ] ) NEW_LINE firstElem = list ( s ) [ 0 ] NEW_LINE mex = min ( mex , firstElem ) NEW_LINE DEDENT print ( mex ) NEW_LINE DEDENT
def findSolutions ( N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( ( i + N // i ) % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( 4 * count ) ; NEW_LINE DEDENT
def leastValue ( P , A , N , a ) : NEW_LINE INDENT ans = - 1 NEW_LINE tmp = float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = P - a [ i ] * 0.006 NEW_LINE if abs ( t - A ) < tmp : NEW_LINE INDENT tmp = abs ( t - A ) NEW_LINE ans = i NEW_LINE DEDENT DEDENT return a [ ans ] NEW_LINE DEDENT
def turnOnK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n | ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 1 ; NEW_LINE while i <= n : NEW_LINE INDENT sum = sum + i * ( i + 1 ) * ( i + 2 ) NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
def checkPairs ( l , r ) : NEW_LINE INDENT if ( l - r ) % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def group_formed ( S ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT a = S [ i ] NEW_LINE b = S [ i + 1 ] NEW_LINE if ( a != b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def solve ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT ans += N NEW_LINE N //= 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 for k in range ( n ) ] NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( j == n or j == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT arr [ k ] = temp [ k ] NEW_LINE DEDENT DEDENT arr = [ 1 , - 1 , - 3 , - 2 , 7 , 5 , 11 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE segregateElements ( arr , n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT
def removeAll ( arr , n ) : NEW_LINE INDENT if arr [ 0 ] < arr [ n - 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def printPairs ( arr , n ) : NEW_LINE INDENT pairs = set ( ) NEW_LINE pair_exists = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT pairs . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT if ( - arr [ i ] ) in pairs : NEW_LINE INDENT print ( " { } , ▁ { } " . format ( arr [ i ] , - arr [ i ] ) ) NEW_LINE pair_exists = True NEW_LINE DEDENT DEDENT DEDENT if pair_exists == False : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ exists " ) NEW_LINE DEDENT DEDENT
def lenghtOfLongestAP ( A , n ) : NEW_LINE INDENT dp = { } NEW_LINE res = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = A [ j ] - A [ i ] NEW_LINE if d in dp : NEW_LINE INDENT if i in dp [ d ] : NEW_LINE INDENT dp [ d ] [ j ] = dp [ d ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ d ] [ j ] = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ d ] = { } NEW_LINE dp [ d ] [ j ] = 2 NEW_LINE DEDENT if d in dp : NEW_LINE INDENT if j in dp [ d ] : NEW_LINE INDENT res = max ( res , dp [ d ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , 0 , len ( arr ) - 1 , x ) NEW_LINE if result != - 1 : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d " % result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT
def calculateWays ( arr1 , arr2 , N ) : NEW_LINE INDENT A = arr2 [ 0 ] NEW_LINE B = arr2 [ 1 ] NEW_LINE C = arr2 [ 2 ] NEW_LINE D = arr2 [ 3 ] NEW_LINE ans , b , c , d = 0 , 0 , 0 , 0 NEW_LINE while b <= B and b * 5 <= ( N ) : NEW_LINE INDENT c = 0 NEW_LINE while ( c <= C and b * 5 + c * 10 <= ( N ) ) : NEW_LINE INDENT d = 0 NEW_LINE while ( d <= D and b * 5 + c * 10 + d * 20 <= ( N ) ) : NEW_LINE INDENT if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT c += 1 NEW_LINE DEDENT b += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def areaOfSquare ( S ) : NEW_LINE INDENT area = S * S NEW_LINE return area NEW_LINE DEDENT
def noOfYears ( t1 , n1 , t2 ) : NEW_LINE INDENT years = ( t2 - 1 ) * n1 / ( t1 - 1 ) NEW_LINE return years NEW_LINE DEDENT
def graphExists ( a ) : NEW_LINE INDENT while True : NEW_LINE INDENT a = sorted ( a , reverse = True ) NEW_LINE if a [ 0 ] == 0 and a [ len ( a ) - 1 ] == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT v = a [ 0 ] NEW_LINE a = a [ 1 : ] NEW_LINE if v > len ( a ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( v ) : NEW_LINE INDENT a [ i ] -= 1 NEW_LINE if a [ i ] < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT a = [ 3 , 3 , 3 , 3 ] NEW_LINE if ( graphExists ( a ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def solve ( s , k ) : NEW_LINE INDENT count , length , pos = 0 , 0 , 0 NEW_LINE m = dict . fromkeys ( s , 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE length += 1 NEW_LINE if length > k : NEW_LINE INDENT m [ s [ pos ] ] -= 1 NEW_LINE pos += 1 NEW_LINE length -= 1 NEW_LINE DEDENT if length == k and m [ s [ i ] ] == length : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def findCnt ( arr , i , required_sum , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( required_sum == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ required_sum + base ] ) : NEW_LINE INDENT return dp [ i ] [ required_sum + base ] ; NEW_LINE DEDENT v [ i ] [ required_sum + base ] = 1 ; NEW_LINE dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; NEW_LINE return dp [ i ] [ required_sum + base ] ; NEW_LINE DEDENT
def isPossible ( x , y , k ) : NEW_LINE INDENT minMoves = abs ( x ) + abs ( y ) NEW_LINE if ( k >= minMoves and ( k - minMoves ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT x = 5 NEW_LINE y = 8 NEW_LINE k = 20 NEW_LINE if ( isPossible ( x , y , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printCountRec ( dist ) : NEW_LINE INDENT if dist < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dist == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ) NEW_LINE DEDENT
def ceilDifference ( arr , n , x ) : NEW_LINE INDENT totalSum = 0 NEW_LINE perElementSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += arr [ i ] NEW_LINE perElementSum += ceil ( arr [ i ] / x ) NEW_LINE DEDENT totalCeilSum = ceil ( totalSum / x ) NEW_LINE return abs ( perElementSum - totalCeilSum ) NEW_LINE DEDENT
def _print ( string ) : NEW_LINE INDENT print ( string [ 0 ] , end = " " ) NEW_LINE for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT if ( ord ( string [ i ] ) == ord ( string [ i - 1 ] ) + 1 or ord ( string [ i ] ) == ord ( string [ i - 1 ] ) - 1 ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ) NEW_LINE print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findNumbers ( arr , n ) : NEW_LINE INDENT sumN = ( n * ( n + 1 ) ) / 2 ; NEW_LINE sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEW_LINE sum = 0 ; NEW_LINE sumSq = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] ; NEW_LINE sumSq = sumSq + ( math . pow ( arr [ i ] , 2 ) ) ; NEW_LINE DEDENT B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; NEW_LINE A = sum - sumN + B ; NEW_LINE print ( " A ▁ = ▁ " , int ( A ) ) ; NEW_LINE print ( " B ▁ = ▁ " , int ( B ) ) ; NEW_LINE DEDENT
def minimumCost ( cost , n , x ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 2 ) NEW_LINE dp [ 0 ] = cost [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i ] = cost [ i ] + dp [ i - 1 ] NEW_LINE DEDENT if ( i == 2 ) : NEW_LINE INDENT dp [ i ] = cost [ i ] + min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) NEW_LINE DEDENT if ( i >= 3 ) : NEW_LINE INDENT dp [ i ] = ( cost [ i ] + min ( dp [ i - 1 ] , min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ) NEW_LINE DEDENT DEDENT print ( dp [ n - 1 ] ) NEW_LINE DEDENT
def numOfWays ( a , n , i = 0 , blue = [ ] ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 and j not in blue : NEW_LINE INDENT count += numOfWays ( mat , n , i + 1 , blue + [ j ] ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isAutomorphic ( N ) : NEW_LINE INDENT sq = N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != sq % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N /= 10 NEW_LINE sq /= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT N = 5 NEW_LINE if isAutomorphic ( N ) : NEW_LINE INDENT print " Automorphic " NEW_LINE DEDENT else : NEW_LINE INDENT print " Not ▁ Automorphic " NEW_LINE DEDENT
def countSticks ( string , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += ( sticks [ ord ( string [ i ] ) - ord ( '0' ) ] ) ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT max_value = max ( arr ) NEW_LINE number_of_bits = floor ( log2 ( max_value ) ) + 1 NEW_LINE complement = ( ( ( 1 << number_of_bits ) - 1 ) ^ max_value ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != max_value ) : NEW_LINE INDENT c = max ( c , ( complement & arr [ i ] ) ) NEW_LINE DEDENT DEDENT return ( max_value + c ) NEW_LINE DEDENT
def check ( n , m ) : NEW_LINE INDENT if ( n == 2 or m == 2 or n % m == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 NEW_LINE DEDENT
def getMinCost ( A , B , N ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT mini = min ( mini , min ( A [ i ] , B [ i ] ) ) NEW_LINE DEDENT return mini * ( 2 * N - 1 ) NEW_LINE DEDENT
def findRadiusOfcircumcircle ( n , a ) : NEW_LINE INDENT if n < 0 or a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) NEW_LINE return radius NEW_LINE DEDENT
def getCount ( N , M ) : NEW_LINE INDENT total_count = 0 NEW_LINE total_count += N // 10 NEW_LINE x = ( N // 10 ) * 10 NEW_LINE if ( ( N - x ) >= M ) : NEW_LINE INDENT total_count = total_count + 1 NEW_LINE DEDENT return total_count NEW_LINE DEDENT
def pairAndSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] & arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getDivisors ( min , n ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( min , n ) : NEW_LINE INDENT if ( n % i == 0 and n // i >= i ) : NEW_LINE INDENT total += 1 NEW_LINE if ( n // i > i ) : NEW_LINE INDENT total += getDivisors ( i , n // i ) NEW_LINE DEDENT DEDENT DEDENT return total NEW_LINE DEDENT
def findNum ( n , k ) : NEW_LINE INDENT q = k // ( n - 1 ) NEW_LINE r = k % ( n - 1 ) NEW_LINE if ( r != 0 ) : NEW_LINE INDENT a = ( n * q ) + r NEW_LINE DEDENT else : NEW_LINE INDENT a = ( n * q ) - 1 NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT
def wastedWater ( V , M , N ) : NEW_LINE INDENT amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT
def printOriginalMatrix ( a , b , mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT print ( min ( a [ i ] , b [ j ] ) , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def prodSquare ( n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT s [ i * i ] = 1 NEW_LINE if ( ( n // ( i * i ) ) in s ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def haversine ( lat1 , lon1 , lat2 , lon2 ) : NEW_LINE INDENT dLat = ( lat2 - lat1 ) * math . pi / 180.0 NEW_LINE dLon = ( lon2 - lon1 ) * math . pi / 180.0 NEW_LINE lat1 = ( lat1 ) * math . pi / 180.0 NEW_LINE lat2 = ( lat2 ) * math . pi / 180.0 NEW_LINE a = ( pow ( math . sin ( dLat / 2 ) , 2 ) + pow ( math . sin ( dLon / 2 ) , 2 ) * math . cos ( lat1 ) * math . cos ( lat2 ) ) ; NEW_LINE rad = 6371 NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE return rad * c NEW_LINE DEDENT
def findRadius ( r1 , r2 , r3 ) : NEW_LINE INDENT r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) NEW_LINE return r4 NEW_LINE DEDENT
def areaCircle ( b ) : NEW_LINE INDENT area = math . pi * b * b NEW_LINE return area NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE position [ i ] = pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def toBinary ( n ) : NEW_LINE INDENT if ( n >= 1 or n <= 0 ) : NEW_LINE INDENT return " ERROR " ; NEW_LINE DEDENT frac = 0.5 ; NEW_LINE answer = " . " ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( len ( answer ) >= 32 ) : NEW_LINE INDENT return " ERROR " ; NEW_LINE DEDENT if ( n >= frac ) : NEW_LINE INDENT answer += "1" ; NEW_LINE n = n - frac ; NEW_LINE DEDENT else : NEW_LINE INDENT answer += "0" ; NEW_LINE DEDENT frac = ( frac / 2 ) ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT
def countSamePrefixSuffix ( s , n ) : NEW_LINE INDENT prefix = " " NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT prefix += s [ i ] NEW_LINE suffix = s [ n - 1 - i : 2 * n - 2 - i ] NEW_LINE if ( prefix == suffix ) : NEW_LINE INDENT print ( len ( prefix ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE x = m . exp ( _sum / n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT
def getWinner ( string , length ) : NEW_LINE INDENT total = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 ; NEW_LINE DEDENT DEDENT if ( ( total % 2 ) == 1 ) : NEW_LINE INDENT return " First " ; NEW_LINE DEDENT return " Second " ; NEW_LINE DEDENT
def FindElement ( a , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + a [ i ] NEW_LINE DEDENT if s % n == 0 : NEW_LINE INDENT m = s // n NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] == m : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def squareArea ( l , b , h ) : NEW_LINE INDENT if l < 0 or b < 0 or h < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( l * b ) / ( l + b ) NEW_LINE return a * a NEW_LINE DEDENT
def solution ( arr , x ) : NEW_LINE INDENT closestSum = sys . maxsize NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( arr ) ) : NEW_LINE INDENT if ( abs ( x - closestSum ) > abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) : NEW_LINE INDENT closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return closestSum NEW_LINE DEDENT
def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) ; NEW_LINE d = ( math . pow ( 10 , s ) ) ; NEW_LINE k = d ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( int ( n // d ) ) ; NEW_LINE d = int ( d / 10 ) ; NEW_LINE DEDENT n = int ( n % k ) ; NEW_LINE k = int ( k // 10 ) ; NEW_LINE d = k ; NEW_LINE DEDENT DEDENT
def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) // 2 + m - 1 ) // m * m ; NEW_LINE DEDENT DEDENT
def count ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= 3 : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT elif i == 4 : NEW_LINE INDENT dp [ i ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT
def xor ( a , b , n ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT else : NEW_LINE INDENT ans += "1" NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def distinctRemainders ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT return ( ( n // 2 ) + 1 ) NEW_LINE DEDENT
def radius ( n , d ) : NEW_LINE INDENT print ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " , d / ( ( n - 1 ) * ( 2 ** ( 1 / 2 ) ) ) ) ; NEW_LINE DEDENT
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT
def decode_String ( st , K ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( 0 , len ( st ) , K ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT for i in range ( len ( st ) - ( K - 1 ) , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def HogbenNumber ( a ) : NEW_LINE INDENT p = ( pow ( a , 2 ) - a + 1 ) NEW_LINE return p NEW_LINE DEDENT
def avg_of_odd_num ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 2 * i + 1 ) NEW_LINE DEDENT return sm // n NEW_LINE DEDENT
def areDisjoint ( set1 , set2 , m , n ) : NEW_LINE INDENT set1 . sort ( ) NEW_LINE set2 . sort ( ) NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( set1 [ i ] < set2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( set2 [ j ] < set1 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def count_required_sequence ( n , arr ) : NEW_LINE INDENT total_required_subsequence = 0 ; NEW_LINE total_n_required_subsequence = 0 ; NEW_LINE dp = np . zeros ( ( N , 2 ) ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT turn_required = 0 ; NEW_LINE for j in range ( - 1 , 2 , 1 ) : NEW_LINE INDENT turn_required += dp [ arr [ i ] + j ] [ 0 ] ; NEW_LINE DEDENT required_end_i = ( total_required_subsequence + turn_required ) ; NEW_LINE n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; NEW_LINE total_required_subsequence += required_end_i ; NEW_LINE total_n_required_subsequence += n_required_end_i ; NEW_LINE dp [ arr [ i ] ] [ 1 ] += required_end_i ; NEW_LINE dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; NEW_LINE DEDENT return total_required_subsequence ; NEW_LINE DEDENT
def findkthElement ( arr , n , K ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while l + 1 < h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if arr [ l ] >= arr [ mid ] : NEW_LINE INDENT l = mid NEW_LINE DEDENT else : NEW_LINE INDENT h = mid NEW_LINE DEDENT DEDENT if arr [ l ] < arr [ h ] : NEW_LINE INDENT r = l NEW_LINE DEDENT else : NEW_LINE INDENT r = h NEW_LINE DEDENT if K <= r + 1 : NEW_LINE INDENT return arr [ r + 1 - K ] NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ n - ( K - ( r + 1 ) ) ] NEW_LINE DEDENT DEDENT
def countSetBits ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 4 * 8 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE count += 1 NEW_LINE return count NEW_LINE N = 15 NEW_LINE print ( countSetBits ( N ) ) NEW_LINE DEDENT DEDENT
def solve_sum ( n ) : NEW_LINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / pow ( 9 , 3 ) - n * ( n + 1 ) / 18 NEW_LINE DEDENT
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) ; NEW_LINE return math . floor ( x ) + 1 ; NEW_LINE DEDENT
def countDigits ( st , n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT cnt = 1 NEW_LINE i = 0 NEW_LINE st2 = " " NEW_LINE i = 1 NEW_LINE while ( i < len ( st ) ) : NEW_LINE INDENT if ( st [ i ] == st [ i - 1 ] ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT else : NEW_LINE INDENT st2 += chr ( 48 + cnt ) NEW_LINE st2 += st [ i - 1 ] NEW_LINE cnt = 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT st2 += chr ( 48 + cnt ) NEW_LINE st2 += st [ i - 1 ] NEW_LINE countDigits ( st2 , n - 1 ) NEW_LINE n = n - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( st ) NEW_LINE DEDENT DEDENT
def radius ( n , d ) : NEW_LINE INDENT print ( " The ▁ radius ▁ of ▁ each ▁ circle ▁ is ▁ " , d / ( 2 * n - 2 ) ) ; NEW_LINE DEDENT
def minimiseMedian ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE ans = abs ( arr [ n // 2 ] - arr [ ( n // 2 ) - 1 ] ) ; NEW_LINE return ans ; NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT
def generateString ( n ) : NEW_LINE INDENT s = " " ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i & 2 ) > 1 ) : NEW_LINE INDENT s += ' b ' ; NEW_LINE DEDENT else : NEW_LINE INDENT s += ' a ' ; NEW_LINE DEDENT DEDENT print ( s ) ; NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT F [ 1 ] = 2 ; NEW_LINE F [ 2 ] = 3 ; NEW_LINE F [ 3 ] = 4 ; NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; NEW_LINE DEDENT DEDENT
def checkPronic ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= ( int ) ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if ( x == i * ( i + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT i = 0 NEW_LINE while ( i <= 200 ) : NEW_LINE INDENT if checkPronic ( i ) : NEW_LINE INDENT print i , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT
def centeredTetrahedralNumber ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 3 ) // 3 NEW_LINE DEDENT
def isValid ( s ) : NEW_LINE INDENT n = int ( math . sqrt ( len ( s ) ) ) NEW_LINE check = s [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = i NEW_LINE y = i NEW_LINE while ( x >= 0 and y < n ) : NEW_LINE INDENT if ( s [ n * x + y ] != check or s [ n * x + x ] != check ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT x -= 1 NEW_LINE y += 1 NEW_LINE DEDENT DEDENT print ( " Yes " ) NEW_LINE DEDENT
def sum ( N ) : NEW_LINE INDENT global S1 , S2 , S3 NEW_LINE S1 = ( ( ( N // 3 ) ) * ( 2 * 3 + ( N // 3 - 1 ) * 3 ) // 2 ) NEW_LINE S2 = ( ( ( N // 4 ) ) * ( 2 * 4 + ( N // 4 - 1 ) * 4 ) // 2 ) NEW_LINE S3 = ( ( ( N // 12 ) ) * ( 2 * 12 + ( N // 12 - 1 ) * 12 ) // 2 ) NEW_LINE return int ( S1 + S2 - S3 ) NEW_LINE DEDENT
def constructArr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = pair [ i - 1 ] - arr [ 0 ] NEW_LINE DEDENT DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for x in range ( n ) ] for y in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def findNumbers ( N ) : NEW_LINE INDENT ans = '7' * ( N - 1 ) NEW_LINE even = ans + '6' ; NEW_LINE odd = ans + '7' ; NEW_LINE print ( " Even ▁ : ▁ " , even ) ; NEW_LINE print ( " Odd ▁ : ▁ " , odd ) ; NEW_LINE DEDENT
def DivisibleBy41 ( first , second , c , n ) : NEW_LINE INDENT digit = [ 0 ] * n NEW_LINE digit [ 0 ] = first NEW_LINE digit [ 1 ] = second NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 NEW_LINE DEDENT ans = digit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ans * 10 + digit [ i ] ) % 41 NEW_LINE DEDENT if ( ans % 41 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT first = 1 NEW_LINE second = 2 NEW_LINE c = 1 NEW_LINE n = 3 NEW_LINE if ( DivisibleBy41 ( first , second , c , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT
def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , " ▁ , ▁ " , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE DEDENT
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i // j == j ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i // j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def Area ( b1 , b2 , h ) : NEW_LINE INDENT return ( ( b1 + b2 ) / 2 ) * h NEW_LINE DEDENT
def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = a . count ( k ) NEW_LINE return round ( count / n , 2 ) NEW_LINE DEDENT
def findDivisor ( x , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT return y NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def LISusingLCS ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE sortedseq = sorted ( seq ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ n ] [ n ] NEW_LINE DEDENT
def maxBottles ( n , e ) : NEW_LINE INDENT s = 0 NEW_LINE b = 0 NEW_LINE a = n NEW_LINE while ( a != 0 ) : NEW_LINE INDENT s = s + a NEW_LINE a = ( a + b ) // e NEW_LINE b = n - ( a * e ) NEW_LINE n = a + b NEW_LINE DEDENT return s NEW_LINE DEDENT
def minCost ( cost , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost = sys . maxsize NEW_LINE for j in range ( i ) : NEW_LINE INDENT if j < len ( cost ) and cost [ j ] != - 1 : NEW_LINE INDENT min_cost = min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT dp [ i ] = min_cost NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def product_subarrays ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT product *= arr [ k ] ; NEW_LINE DEDENT DEDENT DEDENT print ( product ,   " " ) ; NEW_LINE DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def printSeries ( N ) : NEW_LINE INDENT ith_term = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ith_term = 0 ; NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT ith_term = 2 * i * i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ith_term = 2 * i * i - 1 ; NEW_LINE DEDENT print ( ith_term , end = " , ▁ " ) ; NEW_LINE DEDENT DEDENT
def findTerm ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) ; NEW_LINE DEDENT DEDENT return term ; NEW_LINE DEDENT
def nextGreatestAlphabet ( alphabets , K ) : NEW_LINE INDENT n = len ( alphabets ) NEW_LINE if ( K >= alphabets [ n - 1 ] ) : NEW_LINE return alphabets [ 0 ] NEW_LINE l = 0 NEW_LINE r = len ( alphabets ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = int ( ( l + r ) / 2 ) NEW_LINE if ( alphabets [ mid ] > K ) : NEW_LINE INDENT r = mid - 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT if ( alphabets [ ans ] < K ) : NEW_LINE INDENT return alphabets [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return alphabets [ ans ] NEW_LINE DEDENT DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a // b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = radius / 2 ; NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) ; NEW_LINE return Area ; NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE res = 0.0 ; NEW_LINE sign = True ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False ; NEW_LINE res = res + ( i + 1 ) / ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT sign = True ; NEW_LINE res = res - ( i + 1 ) / ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT res = res | ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT
def getIndex ( n , shuffle ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( shuffle [ i ] [ 0 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 1 ] ; NEW_LINE DEDENT elif ( shuffle [ i ] [ 1 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 0 ] ; NEW_LINE DEDENT DEDENT print ( n ) ; NEW_LINE DEDENT
def pythagoreanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n / 3 ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , " , ▁ " , j , " , ▁ " , k , sep = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ Triplet " ) NEW_LINE DEDENT
def findSmallest ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] <= res : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findDuplicate ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j , count = i + 1 , 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT i = j NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def first ( str ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . istitle ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT str = " geeksforGeeKS " NEW_LINE res = first ( str ) NEW_LINE if ( res == 0 ) : NEW_LINE INDENT print ( " No ▁ uppercase ▁ letter " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
def check ( S , prices , type1 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( type1 [ j ] == 0 and type1 [ k ] == 1 ) or ( type1 [ j ] == 1 and type1 [ k ] == 0 ) ) : NEW_LINE INDENT if ( prices [ j ] + prices [ k ] <= S ) : NEW_LINE INDENT return " Yes " ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return " No " ; NEW_LINE DEDENT
def findAngles ( a , b , c , d ) : NEW_LINE INDENT numerator = a * a + d * d - b * b - c * c NEW_LINE denominator = 2 * ( a * b + c * d ) NEW_LINE x = numerator / denominator NEW_LINE print ( " A : ▁ " , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , " ▁ degrees " ) NEW_LINE numerator = a * a + b * b - c * c - d * d NEW_LINE x = numerator / denominator NEW_LINE print ( " B : ▁ " , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , " ▁ degrees " ) NEW_LINE numerator = c * c + b * b - a * a - d * d NEW_LINE x = numerator / denominator NEW_LINE print ( " C : ▁ " , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , " ▁ degrees " ) NEW_LINE numerator = d * d + c * c - a * a - b * b NEW_LINE x = numerator / denominator NEW_LINE print ( " D : ▁ " , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , " ▁ degrees " ) NEW_LINE DEDENT
def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = INT_MAX ; NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT maxDiff = INT_MIN ; NEW_LINE for j in range ( n - k - 1 ) : NEW_LINE INDENT for p in range ( i , i + j + 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; NEW_LINE DEDENT DEDENT minDiff = min ( minDiff , maxDiff ) ; NEW_LINE DEDENT return minDiff ; NEW_LINE DEDENT
def multiply ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE while ( m ) : NEW_LINE INDENT if ( m % 2 == 1 ) : NEW_LINE INDENT ans += n << count NEW_LINE DEDENT count += 1 NEW_LINE m = int ( m / 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def checkCount ( A , Q , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT L = Q [ i ] [ 0 ] NEW_LINE R = Q [ i ] [ 1 ] NEW_LINE L -= 1 NEW_LINE R -= 1 NEW_LINE if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def maxSide ( a , n ) : NEW_LINE INDENT sideLength = 0 NEW_LINE a . sort NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > sideLength ) : NEW_LINE INDENT sideLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( sideLength ) NEW_LINE DEDENT
def check ( a , n ) : NEW_LINE INDENT ma = a [ 1 ] - a [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( ( a [ i ] > a [ i - 1 ] and a [ i + 1 ] < a [ i ] ) or ( a [ i ] < a [ i - 1 ] and a [ i + 1 ] > a [ i ] ) ) : NEW_LINE INDENT ma = max ( ma , abs ( a [ i ] - a [ i + 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT print ( " Amplitude ▁ = ▁ " , ma ) NEW_LINE return True NEW_LINE DEDENT
def printPalindrome ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Smallest ▁ Palindrome : ▁ 0" ) NEW_LINE print ( " Largest ▁ Palindrome : ▁ 9" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Smallest ▁ Palindrome : " , int ( pow ( 10 , n - 1 ) ) + 1 ) NEW_LINE print ( " Largest ▁ Palindrome : " , int ( pow ( 10 , n ) ) - 1 ) NEW_LINE DEDENT DEDENT
def countP ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ k ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( j == 1 or i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = 0 NEW_LINE change = 1 << i NEW_LINE for j in range ( 0 , n + 1 ) : NEW_LINE INDENT ans += k NEW_LINE if change == 1 : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findAngle ( n ) : NEW_LINE INDENT interiorAngle = int ( ( n - 2 ) * 180 / n ) NEW_LINE exteriorAngle = int ( 360 / n ) NEW_LINE print ( " Interior ▁ angle : ▁ " , interiorAngle ) NEW_LINE print ( " Exterior ▁ angle : ▁ " , exteriorAngle ) NEW_LINE DEDENT
def getHermiteNumber ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ) NEW_LINE DEDENT DEDENT
def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( ( i & 1 ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) - 4 * n + 2 NEW_LINE DEDENT
def printFactorialNums ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while fact <= n : NEW_LINE INDENT print ( fact , end = " ▁ " ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
def getPairs ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE count = ( n * ( n - 1 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT
def CountWays ( r , b , l , R , B , W , dp ) : NEW_LINE INDENT if ( l > W ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( r > R ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( b == B and r == R ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( b == B ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ r ] [ b ] [ l ] != - 1 ) : NEW_LINE INDENT return dp [ r ] [ b ] [ l ] NEW_LINE DEDENT ans = 0 ; NEW_LINE ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE dp [ r ] [ b ] [ l ] = ans NEW_LINE return ans ; NEW_LINE DEDENT
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
def lbs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT lds = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in reversed ( range ( n - 1 ) ) : NEW_LINE INDENT for j in reversed ( range ( i - 1 , n ) ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def minJumps ( arr , N ) : NEW_LINE INDENT fib = [ 0 for i in range ( 30 ) ] NEW_LINE fib [ 0 ] = 0 NEW_LINE fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , 30 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DP = [ 0 for i in range ( N + 2 ) ] NEW_LINE DP [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 2 ) : NEW_LINE INDENT DP [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , N + 2 ) : NEW_LINE INDENT for j in range ( 1 , 30 ) : NEW_LINE INDENT if ( ( arr [ i - 1 ] == 1 or i == N + 1 ) and i - fib [ j ] >= 0 ) : NEW_LINE INDENT DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) NEW_LINE DEDENT DEDENT DEDENT if ( DP [ N + 1 ] != MAX ) : NEW_LINE INDENT return DP [ N + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def lexo_small ( n , k ) : NEW_LINE INDENT arr = " " ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr += ' a ' ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT k -= i ; NEW_LINE if ( k >= 0 ) : NEW_LINE INDENT if ( k >= 26 ) : NEW_LINE INDENT arr = arr [ : i ] + ' z ' + arr [ i + 1 : ] ; NEW_LINE k -= 26 ; NEW_LINE DEDENT else : NEW_LINE INDENT c = ( k + 97 - 1 ) ; NEW_LINE arr = arr [ : i ] + chr ( c ) + arr [ i + 1 : ] ; NEW_LINE k -= ord ( arr [ i ] ) - ord ( ' a ' ) + 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT k += i ; NEW_LINE DEDENT return arr ; NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == n and n != 1 else False ) NEW_LINE DEDENT print ( " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000" ) NEW_LINE n = 2 NEW_LINE for n in range ( 10000 ) : NEW_LINE INDENT if isPerfect ( n ) : NEW_LINE INDENT print ( n , " ▁ is ▁ a ▁ perfect ▁ number " ) NEW_LINE DEDENT DEDENT
def difference ( n ) : NEW_LINE INDENT S = ( n * ( n + 1 ) ) // 2 ; NEW_LINE res = S * ( S - 1 ) ; NEW_LINE return res ; NEW_LINE DEDENT
def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 1 ) / arr [ i ] ; NEW_LINE DEDENT return n / sm NEW_LINE DEDENT
def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y + z * z NEW_LINE a = round ( a , 8 ) NEW_LINE if ( ceil ( a ) == 1 & floor ( a ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def printSumSimple ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT for j in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def isWoodall ( x ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = 0 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x / 2 NEW_LINE p = p + 1 NEW_LINE if ( p == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT x = 383 NEW_LINE if ( isWoodall ( x ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def printIntersection ( A , B ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( A [ i ] [ j ] == B [ i ] [ j ] ) : NEW_LINE INDENT print ( A [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def findMaxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum = arr [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT prefix_sum += arr [ j ] NEW_LINE DEDENT suffix_sum = arr [ i ] NEW_LINE j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT suffix_sum += arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( prefix_sum == suffix_sum ) : NEW_LINE INDENT res = max ( res , prefix_sum ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def XorSum ( A , B , N , M ) : NEW_LINE INDENT ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans1 = ans1 ^ A [ i ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT ans2 = ans2 ^ B [ i ] NEW_LINE DEDENT return ( ans1 & ans2 ) NEW_LINE DEDENT
def xorOfSum ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT answer ^= ( a [ i ] + a [ j ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n * n * n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = 9 NEW_LINE n = findS ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
def maxArea ( A , Len ) : NEW_LINE INDENT area = 0 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT for j in range ( i + 1 , Len ) : NEW_LINE INDENT area = max ( area , min ( A [ j ] , A [ i ] ) * ( j - i ) ) NEW_LINE DEDENT DEDENT return area NEW_LINE DEDENT
def alter ( x , y ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( x == 0 or y == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( x >= 2 * y ) : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif ( y >= 2 * x ) : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " X ▁ = " , x , " , ▁ " , " Y ▁ = " , y ) NEW_LINE DEDENT
def sumOfSeries ( x , k ) : NEW_LINE INDENT return ( float ( x ) / 81 ) * ( 9 * k - 1 + 10 ** ( ( - 1 ) * k ) ) NEW_LINE DEDENT
def avgOfFirstN ( n ) : NEW_LINE INDENT return ( float ) ( 1 + n ) / 2 ; NEW_LINE DEDENT
def highestPower ( n ) : NEW_LINE INDENT return int ( ( math . log ( n ) // math . log ( 2 ) ) ) ; NEW_LINE DEDENT
def ishexadecagonal ( N ) : NEW_LINE INDENT n = ( 12 + sqrt ( 112 * N + 144 ) ) / 28 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT
def minimumMoves ( k , l , r ) : NEW_LINE INDENT count = r - l + 1 NEW_LINE if ( count % k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( k - ( count % k ) ) NEW_LINE DEDENT
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE m [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT DEDENT DEDENT DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE DEDENT
def Rate ( N1 , N2 ) : NEW_LINE INDENT rate = ( N2 - N1 ) * 100 // ( N1 ) ; NEW_LINE return rate NEW_LINE DEDENT
def findSmallestDifference ( A , B , m , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE result = sys . maxsize NEW_LINE while ( a < m and b < n ) : NEW_LINE INDENT if ( abs ( A [ a ] - B [ b ] ) < result ) : NEW_LINE INDENT result = abs ( A [ a ] - B [ b ] ) NEW_LINE DEDENT if ( A [ a ] < B [ b ] ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif i < j : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif j == 1 : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT
def countBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def newvol ( x ) : NEW_LINE INDENT print ( " percentage ▁ increase " " in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ " , ( ( x ** ( 3 ) ) / 10000 + 3 * x + ( 3 * ( x ** ( 2 ) ) ) / 100 ) , " % " ) ; NEW_LINE DEDENT
def positions ( str ) : NEW_LINE INDENT for i in str : NEW_LINE INDENT print ( ( ord ( i ) & NUM ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def leastBricks ( wall ) : NEW_LINE INDENT map = defaultdict ( int ) NEW_LINE res = 0 NEW_LINE for list in wall : NEW_LINE INDENT width = 0 NEW_LINE for i in range ( len ( list ) - 1 ) : NEW_LINE INDENT width += list [ i ] NEW_LINE map [ width ] += 1 NEW_LINE res = max ( res , map [ width ] ) NEW_LINE DEDENT DEDENT print ( len ( wall ) - res ) NEW_LINE DEDENT
def setallbitgivenrange ( n , l , r ) : NEW_LINE INDENT range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) NEW_LINE return ( n range ) NEW_LINE DEDENT
def tripletAndSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for bit in range ( 32 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << bit ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) // 6 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if string [ i ] == string [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def perfectSquare ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT p = sqrt ( arr [ i ] ) NEW_LINE if ( p * p != arr [ i ] ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def largestCoprime ( N ) : NEW_LINE INDENT if N == 6 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif N % 4 == 0 : NEW_LINE INDENT return N // 2 - 1 NEW_LINE DEDENT elif N % 2 == 0 : NEW_LINE INDENT return N // 2 - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) // 2 NEW_LINE DEDENT DEDENT
def oppositeFaceOfDice ( N ) : NEW_LINE INDENT ans = 7 - N NEW_LINE print ( ans ) NEW_LINE DEDENT
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
def findBalance ( x , bal ) : NEW_LINE INDENT if ( x % 10 == 0 and ( x + 1.50 ) <= bal ) : NEW_LINE INDENT print ( round ( bal - x - 1.50 , 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( round ( bal , 2 ) ) NEW_LINE DEDENT DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return math . floor ( x / y ) ; NEW_LINE DEDENT return math . floor ( ( x / y ) + countSteps ( y , x % y ) ) ; NEW_LINE DEDENT
def areDisjoint ( set1 , set2 , m , n ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( set1 [ i ] == set2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def IsRedundantBraces ( A ) : NEW_LINE INDENT a , b = 0 , 0 ; NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == ' ( ' and A [ i + 2 ] == ' ) ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( A [ i ] == ' * ' or A [ i ] == ' + ' or A [ i ] == ' - ' or A [ i ] == ' / ' ) : NEW_LINE INDENT a += 1 ; NEW_LINE DEDENT if ( A [ i ] == ' ( ' ) : NEW_LINE INDENT b += 1 ; NEW_LINE DEDENT DEDENT if ( b > a ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def cntCells ( n ) : NEW_LINE INDENT cells = pow ( n , 2 ) + pow ( n - 1 , 2 ) ; NEW_LINE return cells ; NEW_LINE DEDENT
def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def minOperation ( k ) : NEW_LINE INDENT dp = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i // 2 ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ k ] NEW_LINE DEDENT
def arcLength ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ cannot ▁ be ▁ formed " ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT
def getTime ( u , v , x ) : NEW_LINE INDENT speed = u + v NEW_LINE time = x / speed NEW_LINE return time NEW_LINE DEDENT
def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ None ] * n NEW_LINE msds = [ None ] * n NEW_LINE max_sum = 0 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE index = ceilSearch ( arr , 0 , n - 1 , x ) ; NEW_LINE if index == - 1 : NEW_LINE INDENT print ( " Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " % x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ceiling ▁ of ▁ % d ▁ is ▁ % d " % ( x , arr [ index ] ) ) NEW_LINE DEDENT
def isSymmetric ( mat , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] NEW_LINE if ( isSymmetric ( mat , 3 ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT if ( b > c ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( a > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a > c ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( b > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT DEDENT
def Divisible ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT return count_even + ( n - count_even ) // 2 NEW_LINE DEDENT
def minSum ( A ) : NEW_LINE INDENT min_val = min ( A ) ; NEW_LINE return min_val * ( len ( A ) - 1 ) NEW_LINE DEDENT
def NthComposite ( N ) : NEW_LINE INDENT IsPrime = [ True ] * 1000005 NEW_LINE for p in range ( 2 , 1000005 ) : NEW_LINE INDENT if p * p > 1000005 : NEW_LINE INDENT break NEW_LINE DEDENT if ( IsPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , 1000005 , p ) : NEW_LINE INDENT IsPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT Composites = [ ] NEW_LINE for p in range ( 4 , 1000005 ) : NEW_LINE INDENT if ( not IsPrime [ p ] ) : NEW_LINE INDENT Composites . append ( p ) NEW_LINE DEDENT DEDENT return Composites [ N - 1 ] NEW_LINE DEDENT
def minimumRectangleArea ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE A . sort ( ) NEW_LINE ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT ans = min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( ceil ( ( pow ( 10 , ( n - 1 ) ) ) ** ( 1 / 3 ) ) , 3 ) , end = " ▁ " ) NEW_LINE print ( pow ( ceil ( ( pow ( 10 , ( n ) ) ) ** ( 1 / 3 ) ) - 1 , 3 ) ) NEW_LINE DEDENT
def countNestedPolygons ( sides ) : NEW_LINE INDENT count = 0 NEW_LINE while ( sides > 5 ) : NEW_LINE INDENT sides //= 2 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countXOR ( n ) : NEW_LINE INDENT count0 , count1 = 0 , 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT return ( count0 ^ count1 ) NEW_LINE DEDENT
def nthDigit ( a , n , b ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a = a // b NEW_LINE DEDENT return a % b NEW_LINE DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT Sum = 0 NEW_LINE largestDivisible , minimum = - 1 , arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return Sum NEW_LINE DEDENT sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) ) NEW_LINE return min ( Sum , sumAfterOperation ) NEW_LINE DEDENT
def flippingBits ( N , K ) : NEW_LINE INDENT X = ( 1 << ( K - 1 ) ) - 1 NEW_LINE N = X - N NEW_LINE print ( N ) NEW_LINE DEDENT
def CountWays ( N , M ) : NEW_LINE INDENT count = 1 NEW_LINE count = pow ( 3 , M + N ) NEW_LINE count *= pow ( 2 , M * N ) ; NEW_LINE return count NEW_LINE DEDENT
def enneacontagonNum ( n ) : NEW_LINE INDENT return ( 88 * n * n - 86 * n ) // 2 NEW_LINE DEDENT
def canBeSumofConsec ( n ) : NEW_LINE INDENT return ( ( n & ( n - 1 ) ) and n ) NEW_LINE DEDENT n = 15 NEW_LINE if ( canBeSumofConsec ( n ) ) : NEW_LINE INDENT print ( " true " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " false " ) NEW_LINE DEDENT
def findMaxPoints ( A ) : NEW_LINE INDENT P1S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT for j in range ( 2 , M ) : NEW_LINE INDENT op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] NEW_LINE op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] NEW_LINE ans = max ( ans , max ( op1 , op2 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isDivisibleByDivisor ( S , D ) : NEW_LINE INDENT S %= D NEW_LINE hashMap = set ( ) NEW_LINE hashMap . add ( S ) NEW_LINE for i in range ( D + 1 ) : NEW_LINE INDENT S += ( S % D ) NEW_LINE S %= D NEW_LINE if ( S in hashMap ) : NEW_LINE INDENT if ( S == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT else : NEW_LINE INDENT hashMap . add ( S ) NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def pattern ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE DEDENT print ( "2" , end = " ▁ " ) NEW_LINE print ( n + d ) NEW_LINE DEDENT
def singleDigitSubarrayCount ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] <= 9 ) : NEW_LINE INDENT count += 1 NEW_LINE res += count NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT print ( " Pattern ▁ found ▁ at ▁ index ▁ " , i ) NEW_LINE DEDENT DEDENT DEDENT
def maxScore ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE N += 1 NEW_LINE dp = [ [ - 100000 for i in range ( 2 * N ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for s in range ( 1 , 2 * ( N - 1 ) + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j <= N - 1 and j <= s : NEW_LINE INDENT dp [ i ] [ s ] = max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ N ] [ 2 * ( N - 1 ) ] NEW_LINE DEDENT
def checkPascaltriangle ( N ) : NEW_LINE INDENT x = ( math . sqrt ( 8 * N + 1 ) - 1 ) / 2 NEW_LINE if ( math . ceil ( x ) - x == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isCycleExists ( arr , N ) : NEW_LINE INDENT valley = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " No " ) NEW_LINE DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT size = len ( arr ) NEW_LINE i , j = 0 , 1 NEW_LINE while i < size and j < size : NEW_LINE INDENT if i != j and arr [ j ] - arr [ i ] == n : NEW_LINE INDENT print " Pair ▁ found ▁ ( " , arr [ i ] , " , " , arr [ j ] , " ) " NEW_LINE return True NEW_LINE DEDENT elif arr [ j ] - arr [ i ] < n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print " No ▁ pair ▁ found " NEW_LINE return False NEW_LINE DEDENT
def cube ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = math . pow ( h , 3 ) NEW_LINE return a NEW_LINE DEDENT
def minOpsToEmptyString ( s ) : NEW_LINE INDENT ans = - 10 ** 9 NEW_LINE cn0 = 0 NEW_LINE cn1 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT if ( cn1 > 0 ) : NEW_LINE INDENT cn1 -= 1 NEW_LINE DEDENT cn0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( cn0 > 0 ) : NEW_LINE INDENT cn0 -= 1 NEW_LINE DEDENT cn1 += 1 NEW_LINE DEDENT ans = max ( [ ans , cn0 , cn1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def isdecagonal ( N ) : NEW_LINE INDENT n = ( 3 + math . sqrt ( 16 * N + 9 ) ) / 8 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def reduceZero ( N ) : NEW_LINE INDENT dp = [ 1e9 for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for c in str ( i ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i - ( ord ( c ) - 48 ) ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ) ; NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 12 ; NEW_LINE nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) + 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; NEW_LINE return nth ; NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT j = i NEW_LINE while j < n and arr [ j ] <= arr [ j - 1 ] : NEW_LINE INDENT arr [ j ] = arr [ j ] + 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT
def sameEulerTotient ( N ) : NEW_LINE INDENT return ( N & 1 ) ; NEW_LINE DEDENT
def isEqualSubstring ( string , x ) : NEW_LINE INDENT n = len ( string ) NEW_LINE i = 0 NEW_LINE while i < n and i < x : NEW_LINE INDENT if ( string [ i ] != string [ n - i - 1 ] ) : NEW_LINE INDENT print ( " false " ) NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( " true " ) NEW_LINE return NEW_LINE DEDENT
def countTriplets ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT c1 = odd * ( even * ( even - 1 ) ) // 2 NEW_LINE c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) // 6 NEW_LINE return c1 + c2 NEW_LINE DEDENT
def waysToPaint ( n ) : NEW_LINE INDENT same = 6 NEW_LINE diff = 6 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT sameTmp = 3 * same + 2 * diff NEW_LINE diffTmp = 2 * same + 2 * diff NEW_LINE same = sameTmp NEW_LINE diff = diffTmp NEW_LINE DEDENT print ( same + diff ) NEW_LINE DEDENT
def find_and ( arr ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT ans = ans & arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findString ( arr , N ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += '1' if arr [ i ] [ i ] == '0' else '0' NEW_LINE DEDENT return ans NEW_LINE DEDENT
def find_rectangle ( area ) : NEW_LINE INDENT l , b = 0 , 0 NEW_LINE M = mt . ceil ( mt . sqrt ( area ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( M , 0 , - 1 ) : NEW_LINE INDENT if ( area % i == 0 ) : NEW_LINE INDENT l = ( area // i ) NEW_LINE b = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( " l ▁ = " , l , " , ▁ b ▁ = " , b ) NEW_LINE DEDENT
def xor_pair_sum ( ar , n ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total = total ^ ar [ i ] NEW_LINE DEDENT return 2 * total NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return gcd ( b , a ) NEW_LINE DEDENT if ( abs ( b ) < 0.001 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( b , a - math . floor ( a / b ) * b ) ) NEW_LINE DEDENT DEDENT
def NoCarrySum ( N , M ) : NEW_LINE INDENT return N ^ M NEW_LINE DEDENT
def findMinSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] * ( n - i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isPossible ( n ) : NEW_LINE INDENT fac = [ 0 for i in range ( 10 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE fac [ 1 ] = 1 NEW_LINE for i in range ( 2 , 10 , 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT sum = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT sum += fac [ x % 10 ] NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT if ( sum % n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( str ( arr [ i % n ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] > 0 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = True NEW_LINE dp [ i ] [ j ] [ m ] = ( findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ) NEW_LINE return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT
def linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) : NEW_LINE INDENT randomNums [ 0 ] = Xo NEW_LINE for i in range ( 1 , noOfRandomNums ) : NEW_LINE INDENT randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m NEW_LINE DEDENT DEDENT
def hasEqualBlockFrequency ( N ) : NEW_LINE INDENT S = bin ( N ) . replace ( "0b " , " " ) NEW_LINE p = set ( ) NEW_LINE c = 1 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT if ( S [ i ] == S [ i + 1 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p . add ( c ) NEW_LINE c = 1 NEW_LINE DEDENT p . add ( c ) NEW_LINE DEDENT if ( len ( p ) == 1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findMaximumProfit ( arr , M , N ) : NEW_LINE INDENT max_heap = [ ] NEW_LINE maxProfit = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT max_heap . append ( arr [ i ] ) NEW_LINE DEDENT max_heap . sort ( ) NEW_LINE max_heap . reverse ( ) NEW_LINE while ( M > 0 ) : NEW_LINE INDENT M -= 1 NEW_LINE X = max_heap [ 0 ] NEW_LINE max_heap . pop ( 0 ) NEW_LINE maxProfit += X NEW_LINE max_heap . append ( X - 1 ) NEW_LINE max_heap . sort ( ) NEW_LINE max_heap . reverse ( ) NEW_LINE DEDENT print ( maxProfit ) NEW_LINE DEDENT
def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l / a ) * math . ceil ( b / a ) NEW_LINE DEDENT
def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) ; NEW_LINE i = j ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def printFreq ( arr , N ) : NEW_LINE INDENT freq = 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Frequency ▁ of " , arr [ i - 1 ] , " is : " , freq ) NEW_LINE freq = 1 NEW_LINE DEDENT DEDENT print ( " Frequency ▁ of " , arr [ N - 1 ] , " is : " , freq ) NEW_LINE DEDENT
def ToCheckPowerofX ( n , x ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT rem = n % x NEW_LINE if ( rem >= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // x NEW_LINE DEDENT return True NEW_LINE DEDENT
def isPossible ( arr , n ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT mini = min ( mini , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == mini ) : NEW_LINE INDENT continue NEW_LINE DEDENT Max = ( arr [ i ] + 1 ) // 2 - 1 NEW_LINE if ( mini < 0 or mini > Max ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if ( x > x1 and x < x2 and y > y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def constructXOR ( A , n ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT XOR ^= A [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT A [ i ] = XOR ^ A [ i ] NEW_LINE DEDENT DEDENT A = [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE n = len ( A ) NEW_LINE constructXOR ( A , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def subsetXOR ( arr , n , k ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max_ele : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( int ) ( math . log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE if ( k > m ) : NEW_LINE return 0 NEW_LINE dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def findsolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) / ( pie * d * d ) NEW_LINE if ( n > k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h / ( k - n ) ) NEW_LINE return round ( ans , 5 ) NEW_LINE DEDENT
def temp_convert ( F1 , B1 , F2 , B2 , T ) : NEW_LINE INDENT t2 = F2 + ( ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ) NEW_LINE return t2 NEW_LINE DEDENT
def convertToASCII ( N ) : NEW_LINE INDENT num = str ( N ) NEW_LINE i = 0 NEW_LINE for ch in num : NEW_LINE INDENT print ( ch , " ( " , ord ( ch ) , " ) " ) NEW_LINE DEDENT DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum += k NEW_LINE k += 2 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT return ( - 1 + sqrt ( 1 + 8 * n ) ) // 2 ; NEW_LINE DEDENT
def subString ( Str , n ) : NEW_LINE INDENT for Len in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - Len + 1 ) : NEW_LINE INDENT j = i + Len - 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( Str [ k ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT
def Series ( n ) : NEW_LINE INDENT sums = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ser = 1 / ( i ** i ) NEW_LINE sums += ser NEW_LINE DEDENT return sums NEW_LINE DEDENT
def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT matched = True ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] != arr [ j ] ) : NEW_LINE INDENT matched = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( matched ) : NEW_LINE INDENT return i + 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
def isOctadecagon ( N ) : NEW_LINE INDENT n = ( 14 + math . sqrt ( 128 * N + 196 ) ) // 32 NEW_LINE return ( ( n - int ( n ) ) == 0 ) NEW_LINE DEDENT
def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT
def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < b [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 12 , 34 , 10 , 6 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE key = 40 NEW_LINE index = findElement ( arr , n , key ) NEW_LINE if index != - 1 : NEW_LINE INDENT print ( " element ▁ found ▁ at ▁ position : ▁ " + str ( index + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " element ▁ not ▁ found " ) NEW_LINE DEDENT
def performQueries ( string , n , queries , q ) : NEW_LINE INDENT ptr = 0 ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT if ( queries [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; NEW_LINE DEDENT else : NEW_LINE INDENT k = queries [ i ] [ 1 ] ; NEW_LINE index = ( ptr + k - 1 ) % n ; NEW_LINE print ( string [ index ] ) ; NEW_LINE DEDENT DEDENT DEDENT
def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; NEW_LINE DEDENT
def is_Chiliagon ( N ) : NEW_LINE INDENT n = ( 996 + math . sqrt ( 7984 * N + 992016 ) ) // 1996 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT N = 1000 ; NEW_LINE if ( is_Chiliagon ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' or N [ l - 1 ] == '8' or N [ l - 1 ] == ' A ' or N [ l - 1 ] == ' C ' or N [ l - 1 ] == ' E ' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT
def minimumHammingDistance ( S , K ) : NEW_LINE INDENT n = len ( S ) NEW_LINE pref = [ 0 ] * n NEW_LINE pref [ 0 ] = ord ( S [ 0 ] ) - ord ( '0' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + ( ord ( S [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT cnt = pref [ n - 1 ] NEW_LINE ans = cnt NEW_LINE for i in range ( n - K ) : NEW_LINE INDENT value = pref [ i + K - 1 ] - ( pref [ i - 1 ] if ( i - 1 ) >= 0 else 0 ) NEW_LINE ans = min ( ans , cnt - value + ( K - value ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def circumference ( r ) : NEW_LINE INDENT return ( 2 * PI * r ) NEW_LINE DEDENT
def checkArrays ( arr1 , arr2 , N ) : NEW_LINE INDENT count = 0 NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT if ( arr1 [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE if ( count < 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag and count == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def checkSolution ( a , b , c ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return int ( res ) NEW_LINE DEDENT
def numberOfElements ( height , n ) : NEW_LINE INDENT max_so_far = 0 NEW_LINE coun = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if height [ i ] > max_so_far : NEW_LINE INDENT max_so_far = height [ i ] NEW_LINE coun = coun + 1 NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT
def findK ( arr , size , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE temp_sum = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT temp_sum += arr [ i ] NEW_LINE if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT factors ( n , i + 1 ) ; NEW_LINE DEDENT DEDENT
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT a = a % mod ; NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( 2 * a ) % mod ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def findRemainders ( n ) : NEW_LINE INDENT vc = dict ( ) NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT vc [ n // i ] = 1 NEW_LINE DEDENT for i in range ( n // ceil ( sqrt ( n ) ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT vc [ i ] = 1 NEW_LINE DEDENT for it in sorted ( vc ) : NEW_LINE INDENT print ( it , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minAbsDiff ( N ) : NEW_LINE INDENT sumSet1 = 0 NEW_LINE sumSet2 = 0 NEW_LINE for i in reversed ( range ( N + 1 ) ) : NEW_LINE INDENT if sumSet1 <= sumSet2 : NEW_LINE sumSet1 = sumSet1 + i NEW_LINE else : NEW_LINE sumSet2 = sumSet2 + i NEW_LINE DEDENT return abs ( sumSet1 - sumSet2 ) NEW_LINE DEDENT
def minimumDifference ( N ) : NEW_LINE INDENT sum1 = ( 1 << N ) NEW_LINE sum2 = 0 NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT sum1 += ( 1 << i ) NEW_LINE DEDENT for i in range ( N // 2 , N ) : NEW_LINE INDENT sum2 += ( 1 << i ) NEW_LINE DEDENT print ( sum1 - sum2 ) NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT ans = ( n * n // 4 ) NEW_LINE return ans NEW_LINE DEDENT
def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) // 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT
def sum_star_num ( n ) : NEW_LINE INDENT summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n NEW_LINE return summ NEW_LINE DEDENT
def countSubsequece ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( a [ j ] == a [ l ] and a [ i ] == a [ k ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = 7 NEW_LINE b = 10 NEW_LINE c = 5 NEW_LINE if checkValidity ( a , b , c ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT
def maximumTurns ( arr , N ) : NEW_LINE INDENT Count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT Count += 1 NEW_LINE arr [ i ] = arr [ i ] // 2 NEW_LINE DEDENT DEDENT return Count NEW_LINE DEDENT
def findWays ( f , d , s ) : NEW_LINE INDENT mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] NEW_LINE mem [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( 1 , s + 1 ) : NEW_LINE INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] NEW_LINE if j - f - 1 >= 0 : NEW_LINE INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mem [ d ] [ s ] NEW_LINE DEDENT
def optimalStrategyOfGame ( arr , n ) : NEW_LINE INDENT table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for gap in range ( n ) : NEW_LINE INDENT for j in range ( gap , n ) : NEW_LINE INDENT i = j - gap NEW_LINE x = 0 NEW_LINE if ( ( i + 2 ) <= j ) : NEW_LINE INDENT x = table [ i + 2 ] [ j ] NEW_LINE DEDENT y = 0 NEW_LINE if ( ( i + 1 ) <= ( j - 1 ) ) : NEW_LINE INDENT y = table [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT z = 0 NEW_LINE if ( i <= ( j - 2 ) ) : NEW_LINE INDENT z = table [ i ] [ j - 2 ] NEW_LINE DEDENT table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) NEW_LINE DEDENT DEDENT return table [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def leftRotate ( arr , d , n ) : NEW_LINE INDENT if ( d == 0 or d == n ) : NEW_LINE INDENT return ; NEW_LINE DEDENT i = d NEW_LINE j = n - d NEW_LINE while ( i != j ) : NEW_LINE INDENT if ( i < j ) : NEW_LINE INDENT swap ( arr , d - i , d + j - i , i ) NEW_LINE j -= i NEW_LINE DEDENT else : NEW_LINE INDENT swap ( arr , d - i , d , j ) NEW_LINE i -= j NEW_LINE DEDENT DEDENT swap ( arr , d - i , d , i ) NEW_LINE DEDENT
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ 0 ] * 3 ; NEW_LINE arr [ 0 ] = a ; NEW_LINE arr [ 1 ] = b ; NEW_LINE arr [ 2 ] = c ; NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; NEW_LINE k = k - diff ; NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT
def pow ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = a NEW_LINE increment = a NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( 1 , a ) : NEW_LINE INDENT answer += increment NEW_LINE DEDENT increment = answer NEW_LINE DEDENT return answer NEW_LINE DEDENT
def countPoints ( D ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , int ( sqrt ( D * D ) ) , 1 ) : NEW_LINE INDENT y = int ( sqrt ( ( D * D - x * x ) ) ) NEW_LINE if ( x * x + y * y == D * D ) : NEW_LINE INDENT count += 4 NEW_LINE DEDENT DEDENT count += 4 NEW_LINE return count NEW_LINE DEDENT
def countChar ( str , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE repetitions = n // len ( str ) NEW_LINE count = count * repetitions NEW_LINE l = n % len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def getPercentile ( rank , students ) : NEW_LINE INDENT result = ( students - rank ) / students * 100 ; NEW_LINE return result ; NEW_LINE DEDENT
def totalSumDivisibleByNum ( digit , number ) : NEW_LINE INDENT firstnum = pow ( 10 , digit - 1 ) NEW_LINE lastnum = pow ( 10 , digit ) NEW_LINE firstnum = ( firstnum - firstnum % number ) + number NEW_LINE lastnum = ( lastnum - lastnum % number ) NEW_LINE count = ( ( lastnum - firstnum ) / number + 1 ) NEW_LINE return int ( ( ( lastnum + firstnum ) * count ) / 2 ) NEW_LINE DEDENT
def check_euler_four_square_identity ( a , b , ab ) : NEW_LINE INDENT s = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= ab ) : NEW_LINE INDENT s = i * i ; NEW_LINE j = i ; NEW_LINE while ( j * j <= ab ) : NEW_LINE INDENT s = j * j + i * i ; NEW_LINE k = j ; NEW_LINE while ( k * k <= ab ) : NEW_LINE INDENT s = k * k + j * j + i * i ; NEW_LINE l = k ; NEW_LINE while ( l * l <= ab ) : NEW_LINE INDENT s = l * l + k * k + j * j + i * i ; NEW_LINE if ( s == ab ) : NEW_LINE INDENT print ( " i ▁ = " , i ) ; NEW_LINE print ( " j ▁ = " , j ) ; NEW_LINE print ( " k ▁ = " , k ) ; NEW_LINE print ( " l ▁ = " , l ) ; NEW_LINE print ( " Product ▁ of ▁ " , a , " and " , b , end = " " ) ; NEW_LINE print ( " ▁ can ▁ be ▁ written ▁ as ▁ sum ▁ of " , " squares ▁ of ▁ i , ▁ j , ▁ k , ▁ l " ) ; NEW_LINE print ( ab , " = ▁ " , end = " " ) ; NEW_LINE print ( i , " * " , i , " + ▁ " , end = " " ) ; NEW_LINE print ( j , " * " , j , " + ▁ " , end = " " ) ; NEW_LINE print ( k , " * " , k , " + ▁ " , end = " " ) ; NEW_LINE print ( l , " * " , l ) ; NEW_LINE print ( " " ) ; NEW_LINE DEDENT l += 1 ; NEW_LINE DEDENT k += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT
def minCount ( arr , n , k ) : NEW_LINE INDENT ans = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT sum -= k ; NEW_LINE l = 0 ; NEW_LINE r = 0 ; NEW_LINE tot = 0 ; NEW_LINE while ( l < n ) : NEW_LINE INDENT if ( tot <= sum ) : NEW_LINE INDENT ans = max ( ans , r - l ) ; NEW_LINE if ( r == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT tot += arr [ r ] ; NEW_LINE r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot -= arr [ l ] ; NEW_LINE l += 1 NEW_LINE DEDENT DEDENT return ( n - ans ) ; NEW_LINE DEDENT
def clearBit ( num , i ) : NEW_LINE INDENT mask = ~ ( 1 << i ) NEW_LINE return num & mask NEW_LINE DEDENT
def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE splitArr ( arr , n , position ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT
def TowerOfHanoi ( N ) : NEW_LINE INDENT for x in range ( 1 , int ( math . pow ( 2 , N ) ) ) : NEW_LINE INDENT print ( " Move ▁ from ▁ Rod ▁ " , ( ( x & x - 1 ) % 3 + 1 ) , " ▁ to ▁ Rod ▁ " , ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) ) NEW_LINE DEDENT DEDENT
def printSumSeries ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += 1.0 / ( 2 * i - 1 ) ; NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT
def contain ( L , U , M ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( L , U + 1 ) : NEW_LINE INDENT num = set ( str ( j ) ) NEW_LINE if ( j % M == 0 and str ( M ) not in num ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT return math . floor ( math . log10 ( abs ( a ) ) - math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT
def isStraighLineNum ( N ) : NEW_LINE INDENT if ( N <= 99 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT str1 = str ( N ) ; NEW_LINE d = int ( str1 [ 1 ] ) - int ( str1 [ 0 ] ) ; NEW_LINE for i in range ( 2 , len ( str1 ) ) : NEW_LINE INDENT if ( int ( str1 [ i ] ) - int ( str1 [ i - 1 ] ) != d ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT N = 135 ; NEW_LINE if ( isStraighLineNum ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def replace_elements ( arr , n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ pos ] = arr [ i ] NEW_LINE pos = pos + 1 NEW_LINE while ( pos > 1 and arr [ pos - 2 ] == arr [ pos - 1 ] ) : NEW_LINE INDENT pos -= 1 NEW_LINE arr [ pos - 1 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , pos ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return " Yes " NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT n += 1 ; NEW_LINE powerOf2 = 2 ; NEW_LINE cnt = n // 2 ; NEW_LINE while ( powerOf2 <= n ) : NEW_LINE INDENT totalPairs = n // powerOf2 ; NEW_LINE cnt += ( totalPairs // 2 ) * powerOf2 ; NEW_LINE if ( totalPairs & 1 ) : NEW_LINE INDENT cnt += ( n % powerOf2 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 0 NEW_LINE DEDENT powerOf2 <<= 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT temp = n * [ None ] NEW_LINE small , large = 0 , n - 1 NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if flag is True : NEW_LINE INDENT temp [ i ] = arr [ large ] NEW_LINE large -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ i ] = arr [ small ] NEW_LINE small += 1 NEW_LINE DEDENT flag = bool ( 1 - flag ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT
def removeDuplicates ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT res = res + str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def checkCentrosymmetricted ( n , m ) : NEW_LINE INDENT mid_row = 0 ; NEW_LINE if ( ( n & 1 ) > 0 ) : NEW_LINE INDENT mid_row = n / 2 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mid_row = n / 2 ; NEW_LINE DEDENT for i in range ( int ( mid_row ) ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 3 , 5 ] , [ 6 , 8 , 6 ] , [ 5 , 3 , 1 ] ] ; NEW_LINE if ( checkCentrosymmetricted ( n , m ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT N = 3 NEW_LINE if ( ( N == 1 ) or ( N == 2 ) ) : NEW_LINE INDENT print ( 62 ) NEW_LINE DEDENT else : NEW_LINE INDENT m = ( 10 ** 9 ) + 7 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT k = N // 2 NEW_LINE flag = True NEW_LINE DEDENT else : NEW_LINE INDENT k = ( N - 1 ) // 2 NEW_LINE flag = False NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT a = power ( 62 , k , m ) NEW_LINE print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT a = power ( 62 , ( k + 1 ) , m ) NEW_LINE print ( a ) NEW_LINE DEDENT DEDENT
def count_triples ( n , k ) : NEW_LINE INDENT count , i , j , l = 0 , 0 , 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for l in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i + j ) % k == 0 and ( i + l ) % k == 0 and ( j + l ) % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEW_LINE DEDENT
def checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT resx = x1 + x2 + x3 NEW_LINE resy = y1 + y2 + y3 NEW_LINE resz = z1 + z2 + z3 NEW_LINE if ( resx == 0 and resy == 0 and resz == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT x1 = - 2 ; y1 = - 7 ; z1 = - 9 NEW_LINE x2 = 5 ; y2 = - 14 ; z2 = 14 NEW_LINE x3 = - 3 ; y3 = 21 ; z3 = - 5 NEW_LINE if ( checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ) : NEW_LINE INDENT print ( " The ▁ vectors ▁ are ▁ at ▁ equilibrium . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ vectors ▁ are ▁ not ▁ at ▁ equilibrium . " ) NEW_LINE DEDENT
def findAverage ( N ) : NEW_LINE INDENT avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30 NEW_LINE return avg NEW_LINE DEDENT
def reorder ( arr , index , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while ( index [ i ] != i ) : NEW_LINE INDENT oldTargetI = index [ index [ i ] ] NEW_LINE oldTargetE = arr [ index [ i ] ] NEW_LINE arr [ index [ i ] ] = arr [ i ] NEW_LINE index [ index [ i ] ] = index [ i ] NEW_LINE index [ i ] = oldTargetI NEW_LINE arr [ i ] = oldTargetE NEW_LINE DEDENT DEDENT DEDENT arr = [ 50 , 40 , 70 , 60 , 90 ] NEW_LINE index = [ 3 , 0 , 4 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE reorder ( arr , index , n ) NEW_LINE print ( " Reordered ▁ array ▁ is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " Modified Index array is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( index [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def isCenterednonadecagonal ( N ) : NEW_LINE INDENT n = ( 19 + math . sqrt ( 152 * N + 209 ) ) / 38 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT n = 20 ; NEW_LINE if ( isCenterednonadecagonal ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT digits = set ( ) NEW_LINE temp = n NEW_LINE Sum = 0 NEW_LINE count = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT Sum += temp % 10 NEW_LINE digits . add ( temp % 10 ) NEW_LINE count += 1 NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( ( Sum % count == 0 ) and ( ( int ) ( Sum / count ) in digits ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT
def printValueOfPi ( N ) : NEW_LINE INDENT b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE print ( pi ) ; NEW_LINE DEDENT
def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) NEW_LINE set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) NEW_LINE xor = ( set1 ^ set2 ) NEW_LINE xor = ( xor << p1 ) | ( xor << p2 ) NEW_LINE result = x ^ xor NEW_LINE return result NEW_LINE DEDENT
def canVote ( a , n , x ) : NEW_LINE INDENT dp = [ [ 0 ] * ( x + 1 ) for _ in range ( n + 1 ) ] NEW_LINE a = a [ : ] NEW_LINE a . append ( 0 ) NEW_LINE sm = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sm += a [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT if a [ i ] <= j : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return ( sm - dp [ n ] [ x ] ) <= x NEW_LINE DEDENT
def longestRodInCuboid ( length , breadth , height ) : NEW_LINE INDENT temp = length * length + breadth * breadth + height * height NEW_LINE result = sqrt ( temp ) NEW_LINE return result NEW_LINE DEDENT
def oddSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE curr = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + curr NEW_LINE curr = curr + 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minCost ( a , n , k ) : NEW_LINE INDENT dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] ; NEW_LINE dp [ 0 ] [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] ; NEW_LINE DEDENT
def minimum_sum ( A , N ) : NEW_LINE INDENT A . sort ( reverse = False ) NEW_LINE sum = sys . maxsize NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT sum = min ( sum , abs ( A [ i ] - A [ i + 1 ] ) + abs ( A [ i + 1 ] - A [ i + 2 ] ) ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def nthMagicNo ( n ) : NEW_LINE INDENT pow = 1 NEW_LINE answer = 0 NEW_LINE while ( n ) : NEW_LINE INDENT pow = pow * 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT answer += pow NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE arr . sort ( reverse = False ) NEW_LINE if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ int ( size / 2 ) - 1 ] + arr [ int ( size / 2 ) ] ) / 2 NEW_LINE return median NEW_LINE DEDENT median = arr [ int ( size / 2 ) ] NEW_LINE return median NEW_LINE DEDENT
def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT
def dupLastIndex ( arr , n ) : NEW_LINE INDENT if ( arr == None or n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT print ( " Last ▁ index : " , i ,   " Last " , ▁ " duplicate item : " , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " no ▁ duplicate ▁ found " ) NEW_LINE DEDENT
def seriesSum ( calculated , current , N ) : NEW_LINE INDENT i = calculated ; NEW_LINE cur = 1 ; NEW_LINE if ( current == N + 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( i < calculated + current ) : NEW_LINE INDENT cur *= i ; NEW_LINE i += 1 ; NEW_LINE DEDENT return cur + seriesSum ( i , current + 1 , N ) ; NEW_LINE DEDENT
def centeredNonagonal ( n ) : NEW_LINE INDENT return ( 3 * n - 2 ) * ( 3 * n - 1 ) // 2 NEW_LINE DEDENT
def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT
def check ( a , y ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = math . sqrt ( a [ i ] ) NEW_LINE if ( math . floor ( x ) == math . ceil ( x ) ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT DEDENT if ( sum % y == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE x = 13 NEW_LINE if check ( a , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getMinSteps ( n , jump ) : NEW_LINE INDENT quotient = int ( n / jump ) NEW_LINE remainder = n % jump NEW_LINE steps = quotient + remainder NEW_LINE return steps NEW_LINE DEDENT
def findSides ( A , C , c ) : NEW_LINE INDENT B = 180 - ( A + C ) NEW_LINE A = A * ( 3.14159 / 180 ) NEW_LINE C = C * ( 3.14159 / 180 ) NEW_LINE B = B * ( 3.14159 / 180 ) NEW_LINE a = ( c / math . sin ( C ) ) * math . sin ( A ) NEW_LINE b = ( c / math . sin ( C ) ) * math . sin ( B ) NEW_LINE print ( " { 0 : . 2f } " . format ( a ) ) NEW_LINE print ( " { 0 : . 2f } " . format ( b ) ) NEW_LINE DEDENT
def makeZero ( x , y , a , b ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT tot_cost = ( y - x ) * a NEW_LINE cost1 = 2 * x * a NEW_LINE cost2 = x * b NEW_LINE tot_cost += min ( cost1 , cost2 ) NEW_LINE print ( tot_cost ) NEW_LINE DEDENT
def countways ( n ) : NEW_LINE INDENT A = [ 0 for i in range ( n + 2 ) ] NEW_LINE A [ 0 ] = 1 NEW_LINE A [ 1 ] = 3 NEW_LINE A [ 2 ] = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] NEW_LINE DEDENT return A [ n ] NEW_LINE DEDENT
def cubeSide ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( ( h * r * math . sqrt ( 2 ) ) / ( h + math . sqrt ( 2 ) * r ) ) NEW_LINE return a NEW_LINE DEDENT
def getPairsCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - ( i % arr [ i ] ) , n , arr [ i ] ) : NEW_LINE INDENT if ( i < j and abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def find_max_sum ( arr ) : NEW_LINE INDENT incl = 0 NEW_LINE excl = 0 NEW_LINE for i in arr : NEW_LINE INDENT new_excl = excl if excl > incl else incl NEW_LINE incl = excl + i NEW_LINE excl = new_excl NEW_LINE DEDENT return ( excl if excl > incl else incl ) NEW_LINE DEDENT
def binarySearch ( arr , left , right ) : NEW_LINE INDENT if ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 ; NEW_LINE if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( arr [ mid ] < arr [ mid + 1 ] ) : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , right ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , left , mid - 1 ) ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE index = binarySearch ( arr , 1 , n - 2 ) ; NEW_LINE if ( index != - 1 ) : NEW_LINE INDENT print ( arr [ index ] ) ; NEW_LINE DEDENT
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum = sum + int ( num [ i ] ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res = res + countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " Repeating ▁ elements ▁ are ▁ " , end = ' ' ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def Diagonals ( a , b , c , d ) : NEW_LINE INDENT p = math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) NEW_LINE q = math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT
def findRightAngle ( A , H ) : NEW_LINE INDENT D = pow ( H , 4 ) - 16 * A * A NEW_LINE if D >= 0 : NEW_LINE INDENT root1 = ( H * H + sqrt ( D ) ) / 2 NEW_LINE root2 = ( H * H - sqrt ( D ) ) / 2 NEW_LINE a = sqrt ( root1 ) NEW_LINE b = sqrt ( root2 ) NEW_LINE if b >= a : NEW_LINE INDENT print a , b , H NEW_LINE DEDENT else : NEW_LINE INDENT print b , a , H NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT DEDENT
def minOperations ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE result = 0 NEW_LINE for i in range ( length // 2 ) : NEW_LINE INDENT D1 = ( ord ( max ( s [ i ] , s [ length - 1 - i ] ) ) - ord ( min ( s [ i ] , s [ length - 1 - i ] ) ) ) NEW_LINE D2 = 26 - D1 NEW_LINE result += min ( D1 , D2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT cum_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cum_sum += arr [ i ] NEW_LINE DEDENT curr_val = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_val += i * arr [ i ] NEW_LINE DEDENT res = curr_val NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) NEW_LINE curr_val = next_val NEW_LINE res = max ( res , next_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPossible ( a , n ) : NEW_LINE INDENT k = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != i + 1 ) : NEW_LINE INDENT k += 1 ; NEW_LINE DEDENT DEDENT if ( k <= 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def nthKyneaNumber ( n ) : NEW_LINE INDENT return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) NEW_LINE DEDENT
def countNumbers ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( N % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( N // i != i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findMax ( arr ) : NEW_LINE INDENT row = 0 NEW_LINE j = N - 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( arr [ i ] [ j ] == 1 and j >= 0 ) : NEW_LINE INDENT row = i NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( " Row ▁ number ▁ = ▁ " , row + 1 , " , ▁ MaxCount ▁ = ▁ " , N - 1 - j ) NEW_LINE DEDENT
def minDiffSubArray ( arr , n ) : NEW_LINE INDENT prefix_sum = [ 0 ] * n NEW_LINE prefix_sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] = ( prefix_sum [ i - 1 ] + arr [ i ] ) NEW_LINE DEDENT suffix_sum = [ 0 ] * n NEW_LINE suffix_sum [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffix_sum [ i ] = ( suffix_sum [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT minDiff = sys . maxsize NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) NEW_LINE if ( diff < minDiff ) : NEW_LINE INDENT minDiff = diff NEW_LINE DEDENT DEDENT return minDiff NEW_LINE DEDENT
def minimumBox ( arr , n ) : NEW_LINE INDENT q = collections . deque ( [ ] ) NEW_LINE arr . sort ( ) NEW_LINE q . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q [ 0 ] NEW_LINE if ( arr [ i ] >= 2 * now ) : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT q . append ( arr [ i ] ) NEW_LINE DEDENT return len ( q ) NEW_LINE DEDENT
def findPrefix ( str1 , str2 ) : NEW_LINE INDENT pos = False ; NEW_LINE while ( len ( str1 ) != 0 ) : NEW_LINE INDENT if operator . contains ( str2 , str1 ) != True : NEW_LINE INDENT str1 = str1 [ 0 : len ( str1 ) - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT pos = operator . contains ( str2 , str1 ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( pos == False ) : NEW_LINE INDENT return " - 1" ; NEW_LINE DEDENT return str1 ; NEW_LINE DEDENT
def getcount ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for b in range ( 0 , N ) : NEW_LINE INDENT for a in range ( 0 , N ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT continue NEW_LINE DEDENT for c in range ( 0 , N ) : NEW_LINE INDENT if ( c == a or c == b ) : NEW_LINE INDENT continue NEW_LINE DEDENT d = arr [ b ] * arr [ b ] // 4 NEW_LINE if ( arr [ a ] * arr ) <= d : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def permutation ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxEle = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( s ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def XOROfElements ( arr , n ) : NEW_LINE INDENT FirstHalfXOR = 0 ; NEW_LINE SecondHalfXOR = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT FirstHalfXOR ^= arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT SecondHalfXOR ^= arr [ i ] ; NEW_LINE DEDENT DEDENT print ( FirstHalfXOR , " , " , SecondHalfXOR ) ; NEW_LINE DEDENT
def _sum ( a , n ) : NEW_LINE INDENT maxSum = - 9999999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxSum = max ( maxSum , a [ i ] + a [ j ] ) NEW_LINE DEDENT DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] + a [ j ] == maxSum : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT
def findpos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in n : NEW_LINE INDENT if i == '2' : NEW_LINE INDENT pos = pos * 4 + 1 NEW_LINE DEDENT elif i == '3' : NEW_LINE INDENT pos = pos * 4 + 2 NEW_LINE DEDENT elif i == '5' : NEW_LINE INDENT pos = pos * 4 + 3 NEW_LINE DEDENT elif i == '7' : NEW_LINE INDENT pos = pos * 4 + 4 NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
def reorder ( arr , index , n ) : NEW_LINE INDENT temp = [ 0 ] * n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp [ index [ i ] ] = arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE index [ i ] = i NEW_LINE DEDENT DEDENT arr = [ 50 , 40 , 70 , 60 , 90 ] NEW_LINE index = [ 3 , 0 , 4 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE reorder ( arr , index , n ) NEW_LINE print ( " Reordered ▁ array ▁ is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " Modified Index array is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( index [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT array = [ 0 ] * ( N + 1 ) NEW_LINE array [ 0 ] = 1 NEW_LINE array [ 1 ] = 1 NEW_LINE for i in range ( 2 , math . ceil ( math . sqrt ( N ) + 1 ) ) : NEW_LINE INDENT if array [ i ] == 0 : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT array [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT runningPrimeSum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if array [ i ] == 0 : NEW_LINE INDENT runningPrimeSum += i NEW_LINE DEDENT dp [ i ] = runningPrimeSum NEW_LINE DEDENT DEDENT
def findPair ( a , n , z ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i != j and a [ i ] + a [ j ] == z ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT a = [ 1 , - 2 , 1 , 0 , 5 ] NEW_LINE z = 0 NEW_LINE n = len ( a ) NEW_LINE if ( findPair ( a , n , z ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT
def findMinCost ( arr , X , n , i = 0 ) : NEW_LINE INDENT if ( X <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 10 ** 8 NEW_LINE DEDENT inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) NEW_LINE if ( inc != 10 ** 8 ) : NEW_LINE INDENT inc += arr [ i ] [ 1 ] NEW_LINE DEDENT exc = findMinCost ( arr , X , n , i + 1 ) NEW_LINE return min ( inc , exc ) NEW_LINE DEDENT
def maxlength ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = 1 NEW_LINE j = i + 1 NEW_LINE while ( j <= n - 1 and s [ j ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( count > 1 ) ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 12 ; NEW_LINE k = 5 ; NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def count_pairs ( arr , brr , N , M , K ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE cntPairs = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE brr = sorted ( brr ) NEW_LINE while ( i < N and j < M ) : NEW_LINE INDENT if ( brr [ j ] - arr [ i ] > K ) : NEW_LINE INDENT cntPairs += ( M - j ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT
def MaxSubsetlength ( arr , A , B ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( B + 1 ) ] for i in range ( A + 1 ) ] NEW_LINE for str in arr : NEW_LINE INDENT zeros = str . count ( '0' ) NEW_LINE ones = str . count ( '1' ) NEW_LINE for i in range ( A , zeros - 1 , - 1 ) : NEW_LINE INDENT for j in range ( B , ones - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp [ A ] [ B ] NEW_LINE DEDENT
def findSum ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT sum += ( j - i ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def Count ( s , pos ) : NEW_LINE INDENT c = s [ pos - 1 ] NEW_LINE counter = 0 NEW_LINE for i in range ( pos - 1 ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def productSum ( arr ) : NEW_LINE INDENT cntOne = 0 NEW_LINE N = len ( arr ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT cntOne += 1 NEW_LINE DEDENT DEDENT return cntOne * ( cntOne - 1 ) // 2 NEW_LINE DEDENT
def two_sets ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE return ( a [ n // 2 ] - a [ ( n // 2 ) - 1 ] ) ; NEW_LINE DEDENT
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT for i in arr : NEW_LINE INDENT print ( str ( i ) + " ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT
def findWays ( N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = 0 ; NEW_LINE for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + dp [ i - j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] ) ; NEW_LINE DEDENT
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) NEW_LINE if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : NEW_LINE INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; NEW_LINE DEDENT if ( cnt [ i ] [ j ] >= k ) : NEW_LINE INDENT for a in range ( k , cnt [ i ] [ j ] + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return lcs [ n ] [ m ] NEW_LINE DEDENT
def squarearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 4 * ( pow ( r , 2 ) / 5 ) NEW_LINE return a NEW_LINE DEDENT
def substringConversions ( s , k , b ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ( i + k ) < l + 1 ) : NEW_LINE INDENT sub = s [ i : i + k ] ; NEW_LINE sum , counter = 0 , 0 ; NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ; NEW_LINE counter += 1 ; NEW_LINE DEDENT print ( sum , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def findsubArray ( arr , N , K ) : NEW_LINE INDENT res = N + 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT curr_prad = 1 NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT curr_prad = curr_prad * arr [ j ] NEW_LINE if ( curr_prad % N == K and res > ( j - i + 1 ) ) : NEW_LINE INDENT res = min ( res , j - i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if res == N + 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT
def missingNumber ( arr1 , arr2 , n ) : NEW_LINE INDENT mnum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mnum = mnum ^ arr1 [ i ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT mnum = mnum ^ arr2 [ i ] NEW_LINE DEDENT return mnum NEW_LINE DEDENT
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = 0 NEW_LINE for b in range ( n - 3 , 0 , - 1 ) : NEW_LINE INDENT curr = ( n - b - 1 ) * screen [ b - 1 ] NEW_LINE if ( curr > screen [ n - 1 ] ) : NEW_LINE INDENT screen [ n - 1 ] = curr NEW_LINE DEDENT DEDENT DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
def numberOfUniqueOutcomes ( N , S ) : NEW_LINE INDENT if ( S < N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 or N == S ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) NEW_LINE DEDENT
def zigzag ( n , k ) : NEW_LINE INDENT if ( n == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; NEW_LINE DEDENT
def findGreater ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT x = 4 ; NEW_LINE y = 9 ; NEW_LINE if ( findGreater ( x , y ) ) : NEW_LINE INDENT print ( "1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "2" ) ; NEW_LINE DEDENT
def findNumber ( n , m ) : NEW_LINE INDENT num = ( m - 1 ) * 9 + n ; NEW_LINE return num ; NEW_LINE DEDENT
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s = ' ' . join ( sorted ( s ) ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT height = length NEW_LINE while ( height * length <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE height += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findMinDiff ( arr , n ) : NEW_LINE INDENT diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] - arr [ j ] ) < diff : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT
def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT
def countPairs ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] > B [ ans ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT print ( ( N % 9 + 1 ) * pow ( 10 , ( N // 9 ) ) - 1 ) NEW_LINE DEDENT
def calculate ( n , k , m , power ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT if power == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return power - 1 NEW_LINE DEDENT DEDENT elif n == m : NEW_LINE INDENT return power NEW_LINE DEDENT else : NEW_LINE INDENT return calculate ( n * k , k , m , power + 1 ) NEW_LINE DEDENT DEDENT
def LargestString ( na ) : NEW_LINE INDENT N = len ( na ) NEW_LINE c = [ 0 ] * N NEW_LINE m = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT character = [ False ] * 26 NEW_LINE for k in range ( len ( na [ j ] ) ) : NEW_LINE INDENT x = ord ( na [ j ] [ k ] ) - ord ( ' A ' ) NEW_LINE if ( ( na [ j ] [ k ] != ' ▁ ' ) and ( character [ x ] == False ) ) : NEW_LINE INDENT c [ j ] += 1 NEW_LINE character [ x ] = True NEW_LINE DEDENT if ( c [ j ] > c [ m ] ) : NEW_LINE INDENT m = j NEW_LINE DEDENT DEDENT DEDENT print ( na [ m ] ) NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT sumOfDigit = 0 NEW_LINE prodOfDigit = 1 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE sumOfDigit += rem NEW_LINE prodOfDigit *= rem NEW_LINE n = n // 10 NEW_LINE DEDENT if sumOfDigit > prodOfDigit : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * SIZE NEW_LINE freq2 = [ 0 ] * SIZE NEW_LINE l = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT l += min ( freq1 [ i ] , freq2 [ i ] ) NEW_LINE DEDENT return l NEW_LINE DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT if ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT DEDENT
def checkArray ( arr , N , k ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT Sum = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT R = ( k * k + k + 1 ) NEW_LINE if ( Sum % R != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT Mid = k * ( Sum // R ) NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT temp += arr [ i - 1 ] NEW_LINE if ( arr [ i ] == Mid ) : NEW_LINE INDENT if ( temp == Mid // k ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT
def kth_string ( n , k ) : NEW_LINE INDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if k <= ( n - i - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j == i or j == n - k ) : NEW_LINE INDENT print ( ' Y ' , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' X ' , end = " " ) NEW_LINE DEDENT DEDENT break NEW_LINE DEDENT k -= ( n - i - 1 ) NEW_LINE DEDENT DEDENT
def printNumberOfPairs ( N ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT x = i NEW_LINE while ( x <= N ) : NEW_LINE INDENT x *= i NEW_LINE if ( x <= N ) : NEW_LINE INDENT st . add ( x ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( st ) ) NEW_LINE DEDENT
def countSetBits ( N : int ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N ) : NEW_LINE INDENT N = N & ( N - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def subtract ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT borrow = ( ~ x ) & y NEW_LINE x = x ^ y NEW_LINE y = borrow << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def findTwoThreePrime ( l , r ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE while ( num % 2 == 0 ) : NEW_LINE INDENT num //= 2 ; NEW_LINE DEDENT while ( num % 3 == 0 ) : NEW_LINE INDENT num //= 3 NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def IcosihexagonalNum ( n ) : NEW_LINE INDENT return ( 24 * n * n - 22 * n ) // 2 NEW_LINE DEDENT
def checkSentence ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE if string [ 0 ] < ' A ' or string [ 0 ] > ' Z ' : NEW_LINE INDENT return False NEW_LINE DEDENT if string [ length - 1 ] != ' . ' : NEW_LINE INDENT return False NEW_LINE DEDENT prev_state = 0 NEW_LINE curr_state = 0 NEW_LINE index = 1 NEW_LINE while ( string [ index ] ) : NEW_LINE INDENT if string [ index ] >= ' A ' and string [ index ] <= ' Z ' : NEW_LINE INDENT curr_state = 0 NEW_LINE DEDENT elif string [ index ] == ' ▁ ' : NEW_LINE INDENT curr_state = 1 NEW_LINE DEDENT elif string [ index ] >= ' a ' and string [ index ] <= ' z ' : NEW_LINE INDENT curr_state = 2 NEW_LINE DEDENT elif string [ index ] == ' . ' : NEW_LINE INDENT curr_state = 3 NEW_LINE DEDENT if prev_state == curr_state and curr_state != 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if prev_state == 2 and curr_state == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if curr_state == 3 and prev_state != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT index += 1 NEW_LINE prev_state = curr_state NEW_LINE DEDENT return False NEW_LINE DEDENT string = [ " I ▁ love ▁ cinema . " , " The ▁ vertex ▁ is ▁ S . " , " I ▁ am ▁ single . " , " My ▁ name ▁ is ▁ KG . " , " I ▁ lovE ▁ cinema . " , " GeeksQuiz . ▁ is ▁ a ▁ quiz ▁ site . " , " I ▁ love ▁ Geeksquiz ▁ and ▁ Geeksforgeeks . " , " ▁ You ▁ are ▁ my ▁ friend . " , " I ▁ love ▁ cinema " ] NEW_LINE string_size = len ( string ) NEW_LINE for i in xrange ( string_size ) : NEW_LINE INDENT if checkSentence ( string [ i ] ) : NEW_LINE INDENT print " \ " " + string [ i ] + " \ " ▁ is ▁ correct " NEW_LINE DEDENT else : NEW_LINE INDENT print " \ " " + string [ i ] + " \ " ▁ is ▁ incorrect " NEW_LINE DEDENT DEDENT
def findCost ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT p = a [ j ] - j NEW_LINE a [ j ] = 0 NEW_LINE if ( p < 0 ) : NEW_LINE INDENT p = 0 NEW_LINE continue NEW_LINE DEDENT count += p NEW_LINE DEDENT return count NEW_LINE DEDENT
def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE x = arr [ n // 2 ] ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += abs ( arr [ i ] - x ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def longLenSub ( arr , n ) : NEW_LINE INDENT um = defaultdict ( lambda : 0 ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len1 = 0 NEW_LINE if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len1 + 1 NEW_LINE if longLen < um [ arr [ i ] ] : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT
def swapBits ( n , p1 , p2 ) : NEW_LINE INDENT n ^= 1 << p1 NEW_LINE n ^= 1 << p2 NEW_LINE return n NEW_LINE DEDENT
def subsetCount ( arr , n ) : NEW_LINE INDENT return 1 << n NEW_LINE DEDENT
def isValidSeq ( a , n ) : NEW_LINE INDENT nodes = n + 2 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] < 1 or a [ i ] > nodes ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT
def UpperHessenbergMatrix ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( j > i + 1 ) : NEW_LINE INDENT print ( '0' , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( random . randint ( 1 , 10 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def CountPair ( L , R ) : NEW_LINE INDENT x = ( R - L + 1 ) NEW_LINE print ( x // 2 ) NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT
def findTripleSum ( A , B , C ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M NEW_LINE sum = ( sum + prod ) % M NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT return ( ( ( 2 ** n ) - 1 ) % MOD ) NEW_LINE DEDENT
def swapBits ( n , p1 , p2 ) : NEW_LINE INDENT bit1 = ( n >> p1 ) & 1 NEW_LINE bit2 = ( n >> p2 ) & 1 NEW_LINE x = ( bit1 ^ bit2 ) NEW_LINE x = ( x << p1 ) | ( x << p2 ) NEW_LINE result = n ^ x NEW_LINE return result NEW_LINE DEDENT
def powerof2 ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT elif n % 2 != 0 or n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return powerof2 ( n / 2 ) NEW_LINE DEDENT
def get_permutation ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += abs ( arr [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def rangeSum ( l , r ) : NEW_LINE INDENT a = 1 ; b = 9 ; res = 0 ; NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT L = max ( l , a ) ; NEW_LINE R = min ( r , b ) ; NEW_LINE if ( L <= R ) : NEW_LINE INDENT sum = ( L + R ) * ( R - L + 1 ) // 2 ; NEW_LINE res += ( i * i ) * ( sum % MOD ) ; NEW_LINE res %= MOD ; NEW_LINE DEDENT a *= 10 ; NEW_LINE b = b * 10 + 9 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) ; NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def isAnyNotPalindrome ( s ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT unique . add ( s [ i ] ) NEW_LINE DEDENT if ( len ( unique ) > 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findAverage ( N ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S += i * i * i * i NEW_LINE DEDENT return round ( S / N , 4 ) NEW_LINE DEDENT
def findbitwiseOR ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sub_array = a [ i ] NEW_LINE res = res | curr_sub_array NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_sub_array = curr_sub_array & a [ j ] NEW_LINE res = res | curr_sub_array NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def atleastkDistinctChars ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = defaultdict ( int ) NEW_LINE begin = 0 NEW_LINE end = 0 NEW_LINE ans = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT c = s [ end ] NEW_LINE mp += 1 NEW_LINE end += 1 NEW_LINE while ( len ( mp ) >= k ) : NEW_LINE INDENT pre = s [ begin ] NEW_LINE mp [ pre ] -= 1 NEW_LINE if ( mp [ pre ] == 0 ) : NEW_LINE INDENT del mp [ pre ] NEW_LINE DEDENT ans += len ( s ) - end + 1 NEW_LINE begin += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def findProduct ( arr , n ) : NEW_LINE INDENT sorted ( arr ) NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] != arr [ i ] ) : NEW_LINE INDENT prod = prod * arr [ i ] NEW_LINE DEDENT DEDENT return prod ; NEW_LINE DEDENT
def hIndex ( citations , n ) : NEW_LINE INDENT hindex = 0 NEW_LINE low = 0 NEW_LINE high = n - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( citations [ mid ] >= ( mid + 1 ) ) : NEW_LINE INDENT low = mid + 1 NEW_LINE hindex = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT print ( hindex ) NEW_LINE return hindex NEW_LINE DEDENT
def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT
def magicOfSequence ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += ( i * i * i + i * 2 ) NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def countPairs ( A , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( count ) ; NEW_LINE DEDENT
def check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT value_1 = a * x1 + b * y1 + c * z1 + d NEW_LINE value_2 = a * x2 + b * y2 + c * z2 + d NEW_LINE if ( ( value_1 > 0 and value_2 > 0 ) or ( value_1 < 0 and value_2 < 0 ) ) : NEW_LINE INDENT print ( " On ▁ same ▁ side " ) NEW_LINE DEDENT if ( ( value_1 > 0 and value_2 < 0 ) or ( value_1 < 0 and value_2 > 0 ) ) : NEW_LINE INDENT print ( " On ▁ different ▁ sides " ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 == 0 ) : NEW_LINE INDENT print ( " Both ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 != 0 ) : NEW_LINE INDENT print ( " Point ▁ 1 ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT if ( value_1 != 0 and value_2 == 0 ) : NEW_LINE INDENT print ( " Point ▁ 2 ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT DEDENT
def generateArray ( n , k ) : NEW_LINE INDENT array = [ 0 ] * k NEW_LINE remaining = n - int ( k * ( k + 1 ) / 2 ) NEW_LINE if remaining < 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT right_most = remaining % k NEW_LINE high = ceil ( remaining / k ) NEW_LINE low = floor ( remaining / k ) NEW_LINE for i in range ( k - right_most , k ) : NEW_LINE INDENT array [ i ] = high NEW_LINE DEDENT for i in range ( k - right_most ) : NEW_LINE INDENT array [ i ] = low NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT array [ i ] += i + 1 NEW_LINE DEDENT if k - 1 != remaining or k == 1 : NEW_LINE INDENT print ( * array ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT elif k == 2 or k == 3 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT array [ 1 ] -= 1 NEW_LINE array [ k - 1 ] += 1 NEW_LINE print ( * array ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT
def nthSHN ( n , dp ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT dp [ n ] = 1 NEW_LINE return dp [ n ] NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n NEW_LINE return dp [ n ] NEW_LINE DEDENT
def calcCount ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( k % arr [ i ] == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def checkIfAllTogether ( s , c ) : NEW_LINE INDENT oneSeen = False NEW_LINE i = 0 NEW_LINE n = len ( s ) NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT if ( oneSeen == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i < n and s [ i ] == c ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = "110029" ; NEW_LINE if ( checkIfAllTogether ( s , '1' ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def winner ( a , n , k ) : NEW_LINE INDENT if k >= n - 1 : NEW_LINE INDENT return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > best : NEW_LINE INDENT best = a [ i ] NEW_LINE if i == True : NEW_LINE INDENT times = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE if times >= k : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT
def countPairs ( P , Q , N , M ) : NEW_LINE INDENT A = [ 0 ] * 2 NEW_LINE B = [ 0 ] * 2 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ P [ i ] % 2 ] += 1 NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT B [ Q [ i ] % 2 ] += 1 NEW_LINE DEDENT return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) NEW_LINE DEDENT
def minDel ( s1 , s2 ) : NEW_LINE INDENT i = len ( s1 ) NEW_LINE j = len ( s2 ) NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return i + j NEW_LINE DEDENT
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( " { } ▁ { } ▁ { } " . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end =   " " ) ; NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) ; NEW_LINE DEDENT
def maxPathSum ( tri ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , N - i ) : NEW_LINE INDENT if ( j - 1 >= 0 ) : NEW_LINE INDENT tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; NEW_LINE DEDENT ans = max ( ans , tri [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printDistSum ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( Sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def find_index ( arr , n , B ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if arr [ mid ] == K : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < K : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return end + 1 NEW_LINE DEDENT
def isHexagonal ( N ) : NEW_LINE INDENT val = 8 * N + 1 NEW_LINE x = 1 + sqrt ( val ) NEW_LINE n = x / 4 NEW_LINE if ( ( n - int ( n ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def checkSequence ( a , b ) : NEW_LINE INDENT if len ( b ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( a ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( a [ 0 ] == b [ 0 ] ) : NEW_LINE INDENT return checkSequence ( a [ 1 : ] , b [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return checkSequence ( a [ 1 : ] , b ) NEW_LINE DEDENT DEDENT
def longestCommonPrefix ( a ) : NEW_LINE INDENT size = len ( a ) NEW_LINE if ( size == 0 ) : NEW_LINE INDENT return " " NEW_LINE DEDENT if ( size == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT a . sort ( ) NEW_LINE end = min ( len ( a [ 0 ] ) , len ( a [ size - 1 ] ) ) NEW_LINE i = 0 NEW_LINE while ( i < end and a [ 0 ] [ i ] == a [ size - 1 ] [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT pre = a [ 0 ] [ 0 : i ] NEW_LINE return pre NEW_LINE DEDENT
def minItems ( k , r ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( ( i * k - r ) % 10 == 0 or ( i * k ) % 10 == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 10 ; NEW_LINE DEDENT
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( X ) NEW_LINE Xmin = min ( X ) NEW_LINE Ymax = max ( Y ) NEW_LINE Ymin = min ( Y ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " , sep = " " ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymax , " } " , sep = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " , sep = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " , sep = " " ) NEW_LINE DEDENT
def setleftmostunsetbit ( n ) : NEW_LINE INDENT if not ( n & ( n + 1 ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT pos , temp , count = 0 , n , 0 NEW_LINE while temp : NEW_LINE INDENT if not ( temp & 1 ) : NEW_LINE INDENT pos = count NEW_LINE DEDENT count += 1 ; temp >>= 1 NEW_LINE DEDENT return ( n | ( 1 << ( pos ) ) ) NEW_LINE DEDENT
def to_upper ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ' a ' <= s [ i ] <= ' z ' ) : NEW_LINE INDENT s = s [ 0 : i ] + chr ( ord ( s [ i ] ) & ( ~ ( 1 << 5 ) ) ) + s [ i + 1 : ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT
def pairwiseDifference ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE print ( diff , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def product ( N ) : NEW_LINE INDENT ans = 1 ; NEW_LINE val = 2 ** ( N - 1 ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans *= ( i ** val ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 ; NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] ; NEW_LINE DEDENT nibble = num & 0xf ; NEW_LINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findPairs ( N ) : NEW_LINE INDENT for i in range ( 0 , N + 1 ) : NEW_LINE INDENT print ( " ( " , i , " , " , N - i , " ) , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 / pi ) NEW_LINE return degree NEW_LINE DEDENT
def findMinMax ( a ) : NEW_LINE INDENT min_val = 1000000000 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) NEW_LINE DEDENT return min_val NEW_LINE DEDENT
def hasAllcodes ( s , k ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT us . add ( s [ i : k ] ) NEW_LINE DEDENT return len ( us ) == 1 << k NEW_LINE DEDENT s = "00110110" NEW_LINE k = 2 NEW_LINE if ( hasAllcodes ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def minimumSizeArr ( A , B ) : NEW_LINE INDENT currXor = 0 NEW_LINE reminder = ( A - 1 ) % 4 NEW_LINE if ( reminder == 0 ) : NEW_LINE INDENT currXor = A - 1 NEW_LINE DEDENT elif ( reminder == 1 ) : NEW_LINE INDENT currXor = 1 NEW_LINE DEDENT elif ( reminder == 2 ) : NEW_LINE INDENT currXor = A NEW_LINE DEDENT minSize = A NEW_LINE if ( currXor == B ) : NEW_LINE INDENT return minSize NEW_LINE DEDENT elif ( currXor ^ B == A ) : NEW_LINE INDENT return minSize + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return minSize + 1 NEW_LINE DEDENT DEDENT
def maxEdges ( N ) : NEW_LINE INDENT edges = 0 ; NEW_LINE edges = ( N * N ) // 4 ; NEW_LINE return edges ; NEW_LINE DEDENT
def checkSolution ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT return ( ( a1 / a2 ) == ( b1 / b2 ) and ( b1 / b2 ) == ( c1 / c2 ) ) NEW_LINE DEDENT a1 , b1 , c1 = 1 , - 5 , 6 NEW_LINE a2 , b2 , c2 = 2 , - 10 , 12 NEW_LINE if ( checkSolution ( a1 , b1 , c1 , a2 , b2 , c2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def MaxDotProduct ( A , B , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , m + 1 , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def isSuffix ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if ( n1 > n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483648 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans + i * i * i * i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def lastTwoDigits ( N ) : NEW_LINE INDENT if ( N >= 10 ) : NEW_LINE INDENT print ( "00" , end = " " ) NEW_LINE return NEW_LINE DEDENT fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = ( fac * i ) % 100 NEW_LINE DEDENT print ( fac ) NEW_LINE DEDENT
def maxValue ( a ) : NEW_LINE INDENT a = bin ( a ) [ 2 : ] NEW_LINE b = ' ' NEW_LINE for i in list ( a ) : NEW_LINE INDENT b += str ( int ( not int ( i ) ) ) NEW_LINE DEDENT print ( int ( b , 2 ) ) NEW_LINE return int ( b , 2 ) NEW_LINE DEDENT
def kth_root ( n , k ) : NEW_LINE INDENT return ( pow ( k , ( ( 1.0 / k ) * ( math . log ( n ) / math . log ( k ) ) ) ) ) NEW_LINE DEDENT
def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum / 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def CountCharacters ( str , l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE m = { } NEW_LINE length = len ( str ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if ( not ( l <= ord ( str [ i ] ) and ord ( str [ i ] ) <= r ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ord ( str [ i ] ) not in m : NEW_LINE INDENT m [ ord ( str [ i ] ) ] = 0 NEW_LINE print ( str [ i ] , end = " ▁ " ) NEW_LINE DEDENT m [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def Solve ( N , M ) : NEW_LINE INDENT temp = ( N - 1 ) * ( M - 1 ) NEW_LINE ans = pow ( 2 , temp ) NEW_LINE if ( ( N + M ) % 2 != 0 ) : NEW_LINE INDENT print ( ans ) NEW_LINE else : NEW_LINE print ( 2 * ans ) NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , M = 3 , 3 NEW_LINE Solve ( N , M ) NEW_LINE DEDENT DEDENT DEDENT
def findXOR ( mat , N ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT if ( ( i == j and j == k ) ) : NEW_LINE INDENT XOR ^= mat [ i ] [ j ] [ k ] NEW_LINE XOR ^= mat [ i ] [ j ] [ N - k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( XOR ) NEW_LINE DEDENT
def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT
def checkSorted ( n , arr ) : NEW_LINE INDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( arr [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE ct = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != b [ i ] : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT if ct == 0 or ct == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def extraElement ( A , B , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans ^= A [ i ] ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans ^= B [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def reArrange ( words , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ words [ i ] ] = i + 1 NEW_LINE DEDENT words . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( mp [ words [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE DEDENT
def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) ; NEW_LINE area = 3.14 * R * R / 2.0 ; NEW_LINE return area ; NEW_LINE DEDENT
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
def minValue ( n , x , y ) : NEW_LINE INDENT val = ( y * n ) / 100 NEW_LINE if x >= val : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( val ) - x NEW_LINE DEDENT DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT maxratio = - sys . maxsize - 1 ; NEW_LINE maxindex = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( val [ i ] / wt [ i ] ) > maxratio ) : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) ; NEW_LINE maxindex = i ; NEW_LINE DEDENT DEDENT return ( W * maxratio ) ; NEW_LINE DEDENT
def findTriangles ( n ) : NEW_LINE INDENT num = n NEW_LINE print ( num , end = " ▁ " ) NEW_LINE print ( num * ( num - 4 ) * ( num - 5 ) // 6 ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE sum += 1.0 / fact NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def k_nonzero_numbers ( s , n , k ) : NEW_LINE INDENT dp = [ [ [ 0 for i in range ( k + 2 ) ] for i in range ( 2 ) ] for i in range ( n + 2 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT for x in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ x ] = 0 NEW_LINE DEDENT DEDENT DEDENT dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( sm < 2 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE if sm : NEW_LINE INDENT y = 9 NEW_LINE DEDENT else : NEW_LINE INDENT y = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT while ( x <= y ) : NEW_LINE INDENT dp [ i + 1 ] [ ( sm or x < ( ord ( s [ i ] ) - ord ( '0' ) ) ) ] [ j + ( x > 0 ) ] += dp [ i ] [ sm ] [ j ] NEW_LINE x += 1 NEW_LINE DEDENT DEDENT sm += 1 NEW_LINE DEDENT DEDENT return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] NEW_LINE DEDENT
def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT
def is_possible ( x , y ) : NEW_LINE INDENT if ( x < 2 and y != 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT y = y - x + 1 NEW_LINE if ( y % 2 == 0 and y >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def countOfMultiples ( n ) : NEW_LINE INDENT return ( int ( n / 3 ) + int ( n / 5 ) - int ( n / 15 ) ) ; NEW_LINE DEDENT
def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def square ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.464 * a NEW_LINE return x NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and ( not ( n & ( n - 1 ) ) ) ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT test_no = 64 NEW_LINE if ( isPowerOfFour ( 64 ) ) : NEW_LINE INDENT print ( test_no , ' is ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( test_no , ' is ▁ not ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " , 2 * x2 - x1 , " , " , 2 * y2 - y1 , " ) " ) ; NEW_LINE DEDENT
def FirstDigit ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + math . log10 ( arr [ i ] * 1.0 ) NEW_LINE DEDENT fract_S = S - math . floor ( S ) NEW_LINE ans = math . pow ( 10 , fract_S ) NEW_LINE return ans NEW_LINE DEDENT
def findIndex ( arr ) : NEW_LINE INDENT maxIndex = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > arr [ maxIndex ] ) : NEW_LINE INDENT maxIndex = i NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( maxIndex != i and arr [ maxIndex ] < ( 2 * arr [ i ] ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return maxIndex NEW_LINE DEDENT
def areaSquare ( side , fold ) : NEW_LINE INDENT area = side * side NEW_LINE ans = area / pow ( 2 , fold ) NEW_LINE return ans NEW_LINE DEDENT
def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ j ] % arr [ i ] == 0 ) and ( j + 1 ) % ( i + 1 ) == 0 and ( arr [ j ] // arr [ i ] == ( j + 1 ) // ( i + 1 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findIntersection ( intervals , N ) : NEW_LINE INDENT l = intervals [ 0 ] [ 0 ] NEW_LINE r = intervals [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( intervals [ i ] [ 0 ] > r or intervals [ i ] [ 1 ] < l ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l = max ( l , intervals [ i ] [ 0 ] ) NEW_LINE r = min ( r , intervals [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT print ( " [ " , l , " , ▁ " , r , " ] " ) NEW_LINE DEDENT
def movesRequired ( a , b ) : NEW_LINE INDENT total_moves = a % b NEW_LINE print ( total_moves ) NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT
def PointInKSquares ( n , a , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return a [ n - k ] NEW_LINE DEDENT
def findCount ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 1 NEW_LINE cur_max = arr [ 0 ] NEW_LINE cur_min = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT cur_max = arr [ i ] NEW_LINE if ( cur_max - cur_min > K ) : NEW_LINE INDENT result += 1 NEW_LINE cur_max = arr [ i ] NEW_LINE cur_min = arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def findRadiusOfIncircle ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT p = ( a + b + c ) / 2 NEW_LINE area = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) NEW_LINE radius = area / p NEW_LINE return radius NEW_LINE DEDENT
def Race ( B , C ) : NEW_LINE INDENT result = 0 ; NEW_LINE result = ( ( C * 100 ) // B ) NEW_LINE return 100 - result NEW_LINE DEDENT
def nCycle ( N ) : NEW_LINE INDENT return ( N ) * ( N - 1 ) + 1 NEW_LINE DEDENT
def area_cicumscribed ( c ) : NEW_LINE INDENT return ( c * c * ( PI / 4 ) ) NEW_LINE DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT c_sum = 0 ; NEW_LINE arr . sort ( reverse = True ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c_sum += arr [ i ] ; NEW_LINE if ( c_sum < 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return n ; NEW_LINE DEDENT
def findArea ( a , b ) : NEW_LINE INDENT Area = 3.142 * a * b ; NEW_LINE print ( " Area : " , round ( Area , 2 ) ) ; NEW_LINE DEDENT
def right_angled ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for z in range ( 1 , n + 1 ) : NEW_LINE INDENT for y in range ( 1 , z + 1 ) : NEW_LINE INDENT for x in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( ( x * x ) + ( y * y ) == ( z * z ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def isuppertriangular ( M ) : NEW_LINE INDENT for i in range ( 1 , len ( M ) ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT M = [ [ 1 , 3 , 5 , 3 ] , [ 0 , 4 , 6 , 2 ] , [ 0 , 0 , 2 , 5 ] , [ 0 , 0 , 0 , 6 ] ] NEW_LINE if isuppertriangular ( M ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 ; cntOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 ; NEW_LINE DEDENT DEDENT evenPairs = 0 ; NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) ; NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) ; NEW_LINE oddPairs = 0 ; NEW_LINE oddPairs += ( cntEven * cntOdd ) ; NEW_LINE print ( " Odd ▁ pairs ▁ = ▁ " , oddPairs ) ; NEW_LINE print ( " Even ▁ pairs ▁ = ▁ " , evenPairs ) ; NEW_LINE DEDENT
def countSeq ( n ) : NEW_LINE INDENT nCr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT nCr = ( nCr * ( n + 1 - r ) ) / r ; NEW_LINE res += nCr * nCr ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def Division ( a , n ) : NEW_LINE INDENT maxi = - 10 ** 9 NEW_LINE mini = 10 ** 9 NEW_LINE for i in a : NEW_LINE INDENT maxi = max ( i , maxi ) NEW_LINE mini = min ( i , mini ) NEW_LINE DEDENT return maxi // mini NEW_LINE DEDENT
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE multi = x NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + multi / i NEW_LINE multi = multi * x NEW_LINE DEDENT return total NEW_LINE DEDENT
def maxSubmatrixSum ( matrix ) : NEW_LINE INDENT r = len ( matrix ) NEW_LINE c = len ( matrix [ 0 ] ) NEW_LINE maxSubmatrix = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT for k in range ( i , r ) : NEW_LINE INDENT for l in range ( j , c ) : NEW_LINE INDENT sumSubmatrix = 0 NEW_LINE for m in range ( i , k + 1 ) : NEW_LINE INDENT for n in range ( j , l + 1 ) : NEW_LINE INDENT sumSubmatrix += matrix [ m ] [ n ] NEW_LINE DEDENT DEDENT maxSubmatrix = max ( maxSubmatrix , sumSubmatrix ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( maxSubmatrix ) NEW_LINE DEDENT
def bs ( a , n , ele ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE ch = ' @ ' NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 ; NEW_LINE if ( ar [ mid ] == ele ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT elif ( ar [ mid ] < ele ) : NEW_LINE INDENT ch = ar [ mid ] NEW_LINE start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 ; NEW_LINE DEDENT DEDENT return ch NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def checkOrigin ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) NEW_LINE DEDENT if ( checkOrigin ( 1 , 28 , 2 , 56 ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def smallest ( k , d ) : NEW_LINE INDENT cnt = 1 NEW_LINE m = d % k NEW_LINE v = [ 0 for i in range ( k ) ] ; NEW_LINE v [ m ] = 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k NEW_LINE if ( v [ m ] == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT v [ m ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def Area ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 2 * r ) / mt . sqrt ( 5 ) NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT
def to_upper ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ' a ' <= string [ i ] <= ' z ' ) : NEW_LINE INDENT string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) ) + string [ i + 1 : ] ) NEW_LINE DEDENT DEDENT return string ; NEW_LINE DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT result = result - pow ( i , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + pow ( i , 2 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def Regions ( Vertices , Edges ) : NEW_LINE INDENT R = Edges + 2 - Vertices ; NEW_LINE return R ; NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT
def Perimeter ( a , b ) : NEW_LINE INDENT perimeter = 0 NEW_LINE perimeter = ( 2 * 3.14 * sqrt ( ( a * a + b * b ) / ( 2 * 1.0 ) ) ) ; NEW_LINE print ( perimeter ) NEW_LINE DEDENT
def hectagonNum ( n ) : NEW_LINE INDENT return ( 98 * n * n - 96 * n ) // 2 NEW_LINE DEDENT
def findDirection ( n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT if ( m % 2 == 0 ) : NEW_LINE INDENT print ( " Up " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Down " ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Left " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Right " ) ; NEW_LINE DEDENT DEDENT DEDENT
def Cells ( n , x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 and x / i <= n ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def maximum_inversion ( n , k ) : NEW_LINE INDENT answer = 0 ; NEW_LINE k = min ( k , n // 2 ) ; NEW_LINE left = 1 ; NEW_LINE right = n ; NEW_LINE while ( k > 0 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE answer += 2 * ( right - left ) - 1 ; NEW_LINE left += 1 ; NEW_LINE right -= 1 ; NEW_LINE DEDENT print ( answer ) ; NEW_LINE DEDENT
def maxXOR ( mat , N ) : NEW_LINE INDENT max_xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT r_xor = r_xor ^ mat [ i ] [ j ] NEW_LINE c_xor = c_xor ^ mat [ j ] [ i ] NEW_LINE DEDENT if ( max_xor < max ( r_xor , c_xor ) ) : NEW_LINE INDENT max_xor = max ( r_xor , c_xor ) NEW_LINE DEDENT DEDENT return max_xor NEW_LINE DEDENT
def getLargestSum ( N ) : NEW_LINE INDENT max_sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( i * j % ( i + j ) == 0 ) : NEW_LINE INDENT max_sum = max ( max_sum , i + j ) NEW_LINE DEDENT DEDENT DEDENT return max_sum NEW_LINE DEDENT
def MinOp ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return N ; NEW_LINE DEDENT bit = ( int ) ( math . log ( N ) / math . log ( 2 ) ) + 1 ; NEW_LINE return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; NEW_LINE DEDENT
def MinimumOperations ( A , N , K ) : NEW_LINE INDENT Count = 0 NEW_LINE i = 0 NEW_LINE while ( i < N - 1 ) : NEW_LINE INDENT i = i + K - 1 NEW_LINE Count += 1 NEW_LINE DEDENT return Count NEW_LINE DEDENT
def sumOfMedians ( arr , N , K ) : NEW_LINE INDENT selectMedian = ( K + 1 ) // 2 NEW_LINE totalArrays = N // K NEW_LINE minSum = 0 NEW_LINE i = selectMedian - 1 NEW_LINE while ( i < N and totalArrays != 0 ) : NEW_LINE INDENT minSum = minSum + arr [ i ] NEW_LINE i = i + selectMedian NEW_LINE totalArrays -= 1 NEW_LINE DEDENT print ( minSum ) NEW_LINE DEDENT
def strScore ( str , s , n ) : NEW_LINE INDENT score = 0 NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == s ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT score += ( ord ( s [ j ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT index = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT score = score * index NEW_LINE return score NEW_LINE DEDENT
def answer ( n ) : NEW_LINE INDENT m = 2 ; NEW_LINE ans = 1 ; NEW_LINE r = 1 ; NEW_LINE while r < n : NEW_LINE INDENT r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) ; NEW_LINE if r < n : NEW_LINE INDENT ans = r ; NEW_LINE DEDENT m = m + 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def stirlingFactorial ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT e = 2.71 NEW_LINE z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) NEW_LINE return math . floor ( z ) NEW_LINE DEDENT
def querySum ( arr , N , Q , M ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE sum = 0 NEW_LINE while ( x < N ) : NEW_LINE INDENT sum += arr [ x ] NEW_LINE x += y NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minLength ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ 0 ] != arr [ i ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return N NEW_LINE DEDENT
def dodecahedral_num ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) // 2 NEW_LINE DEDENT
