int countWords ( string str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
int minNum ( int [ ] arr , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . Min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
int findSum ( int [ ] arr , int n , int k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
void decodeStr ( String str , int len ) { char [ ] c = new char [ len ] ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len % 2 == 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) Console . Write ( c [ i ] ) ; }
int countSubArrayWithOddProduct ( int [ ] A , int N ) { int count = 0 ; int last = - 1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
void solve ( int [ ] arr , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
int nthTerm ( int N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
int smallestNum ( int N ) { float x = ( float ) ( Math . Pow ( 10 , ( N - 1 ) / 2.0 ) ) ; return ( int ) ( Math . Ceiling ( x ) ) ; }
long multiplyFactors ( int n ) { long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
int deleteElement ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
int findNumberOfTriangles ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; }
int cntPairs ( int [ ] a , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
bool isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * r * r ) / 4 ) ; return a ; }
void findSetBits ( int n ) { int [ ] dp = new int [ n + 1 ] ; Console . Write ( dp [ 0 ] + " ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i / 2 ] ; } else { dp [ i ] = dp [ i / 2 ] + 1 ; } Console . Write ( dp [ i ] + " ▁ " ) ; } }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
int check ( int n , List < int > marks ) { int x = marks . Max ( ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
double octaside ( double a ) { if ( a < 0 ) return - 1 ; double s = a / ( Math . Sqrt ( 2 ) + 1 ) ; return s ; }
int countTriplets ( int [ ] A ) { int cnt = 0 ; Dictionary < int , int > tuples = new Dictionary < int , int > ( ) ; foreach ( int a in A ) foreach ( int b in A ) { if ( tuples . ContainsKey ( a & b ) ) tuples [ a & b ] = tuples [ a & b ] + 1 ; else tuples . Add ( a & b , 1 ) ; } foreach ( int a in A ) foreach ( KeyValuePair < int , int > t in tuples ) if ( ( t . Key & a ) == 0 ) cnt += t . Value ; return cnt ; }
int minDiff ( int [ ] arr , int n , int k ) { int result = int . MaxValue ; Array . Sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . Min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
bool isSubseqPossible ( int [ ] arr , int N , int K ) { int i ; int odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base1 = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base1 ; base1 = base1 * 2 ; } return dec_value ; }
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
int count_min_length ( string s ) { int [ ] hash = new int [ 26 ] ; int ans = int . MaxValue ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( hash [ s [ i ] - ' a ' ] == - 1 ) hash [ s [ i ] - ' a ' ] = i ; else { if ( hash [ s [ i ] - ' a ' ] == i - 1 hash [ s [ i ] - ' a ' ] == i - 2 ) return 0 ; ans = Math . Min ( ans , i - hash [ s [ i ] - ' a ' ] - 1 ) ; hash [ s [ i ] - ' a ' ] = i ; } } if ( ans == int . MaxValue ) return - 1 ; return ans ; }
int calculateSum ( int n ) { return ( n * ( ( int ) Math . Pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ; }
int calculateSum ( int n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; }
int results ( int n , int k ) { return ( int ) Math . Round ( Math . Pow ( n , ( 1.0 / Math . Pow ( 2.0 , k ) ) ) ) ; }
int findCycles ( int N ) { int res = 0 ; int finalResult = 0 ; int val = 2 * N - 1 ; int s = val ; res = ( N - 1 ) * ( N - 2 ) ; finalResult = res + s ; return finalResult ; }
bool isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; }
int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
int countPairs ( int [ ] arr , int n ) { int ans = 0 ; Array . Sort ( arr ) ; int left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = ( float ) Math . Sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = ( float ) Math . Sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = ( float ) 3.14159 ; float A = ( 180 / pi ) * ( float ) ( Math . Acos ( d ) ) ; Console . Write ( " Angle ▁ is ▁ " + A + " ▁ degree " ) ; }
double get_concentration ( double mass , double volume ) { if ( volume == 0 ) return - 1 ; else return ( mass / volume ) * 1000 ; }
int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
void find ( int n ) { Console . Write ( n / 2 ) ; }
int CntcontSubs ( int [ ] a , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; }
void zigzag ( string s , int rows ) { int interval = 2 * rows - 2 ; for ( int i = 0 ; i < rows ; i ++ ) { int step = interval - 2 * i ; for ( int j = i ; j < s . Length ; j = j + interval ) { Console . Write ( s [ j ] ) ; if ( step > 0 && step < interval && step + j < s . Length ) { for ( int k = 0 ; k < ( interval - rows - i ) ; k ++ ) Console . Write ( " ▁ " ) ; Console . Write ( s [ j + step ] ) ; for ( int k = 0 ; k < i - 1 ; k ++ ) Console . Write ( " ▁ " ) ; } else { for ( int k = 0 ; k < ( interval - rows ) ; k ++ ) Console . Write ( " ▁ " ) ; } } Console . WriteLine ( ) ; } }
int distancesum ( int [ ] x , int [ ] y , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . Abs ( x [ i ] - x [ j ] ) + Math . Abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
int bitPos ( int n1 , int n2 ) { if ( n1 == n2 ) return 0 ; int bitCount1 = ( int ) Math . Floor ( Math . Log ( n1 ) / Math . Log ( 2 ) ) + 1 ; int bitCount2 = ( int ) Math . Floor ( Math . Log ( n2 ) / Math . Log ( 2 ) ) + 1 ; int bitDiff = Math . Abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . Max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . Pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . Pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = ( int ) Math . Floor ( Math . Log ( xorValue ) / Math . Log ( 2 ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
int perfectPowerOf2 ( int n ) { int per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
int longestCommonSum ( int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
int arraySum ( int [ ] arr , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { Console . WriteLine ( " NO " ) ; return ; } double a = ( N + Math . Sqrt ( val ) ) / 2.0 ; double b = ( N - Math . Sqrt ( val ) ) / 2.0 ; Console . WriteLine ( " a ▁ = ▁ " + a ) ; Console . WriteLine ( " b ▁ = ▁ " + b ) ; }
int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
int minSum ( int [ ] arr , int n ) { int sum = 0 ; Array . Sort ( arr ) ; Array . Reverse ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
void charactersCount ( String str , int n ) { int count = 0 ; while ( n > 0 ) { char cur = str [ 0 ] ; int ind = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( str [ j ] < cur ) { cur = str [ j ] ; ind = j ; } } str = str . Substring ( 0 , ind ) + str . Substring ( ind + 1 ) ; n -- ; count += ind + 1 ; } Console . Write ( count + " STRNEWLINE " ) ; }
int pairORSum ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
String NimGame ( int N , int A , int B ) { int sum = A + B ; if ( N % sum <= A - 1 ) return " Bob " ; else return " Alice " ; }
void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { Console . WriteLine ( " Overflow " ) ; } else { Console . WriteLine ( " Not ▁ in ▁ overflow ▁ state " ) ; } }
int maxDiffSubsets ( int [ ] arr ) { int totalSum = 0 ; bool pos = false , neg = false ; int min = int . MaxValue ; for ( int i = 0 ; i < arr . Length ; i ++ ) { totalSum += Math . Abs ( arr [ i ] ) ; if ( arr [ i ] > 0 ) pos = true ; if ( arr [ i ] < 0 ) neg = true ; if ( arr [ i ] < min ) min = arr [ i ] ; } if ( pos && neg ) return totalSum ; else return totalSum - 2 * min ; }
int minCost ( int [ ] arr , int n , int circumference ) { Array . Sort ( arr ) ; int [ ] arr2 = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; arr2 [ i + n ] = arr [ i ] + circumference ; } int res = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; return res ; }
int findCost ( int [ ] A , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
int fib ( long n ) { int f0 = 0 ; int f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { int rem = ( int ) ( n % 60 ) ; if ( rem == 0 ) return 0 ; for ( int i = 2 ; i < rem + 3 ; i ++ ) { int f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } int s = f1 - 1 ; return s ; } }
int countMaxChoco ( int money , int price , int wrap ) { if ( money < price ) return 0 ; int choc = money / price ; choc = choc + ( choc - 1 ) / ( wrap - 1 ) ; return choc ; }
int substrDeletion ( string str , int len ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count0 ++ ; else count1 ++ ; } return Math . Min ( count0 , count1 ) ; }
int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; }
int countOccurrences ( int [ ] arr , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
void findpair ( int l , int r ) { int ans1 = l ; int ans2 = 2 * l ; Console . WriteLine ( ans1 + " , ▁ " + ans2 ) ; }
Boolean isPossible ( char [ ] str ) { Dictionary < char , int > freq = new Dictionary < char , int > ( ) ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . Length ) ; j ++ ) { if ( freq . ContainsKey ( str [ j ] ) ) { var v = freq [ str [ j ] ] + 1 ; freq . Remove ( str [ j ] ) ; freq . Add ( str [ j ] , v ) ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } else { freq . Add ( str [ j ] , 1 ) ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } } if ( max_freq <= ( str . Length - max_freq + 1 ) ) return true ; return false ; }
void printMiddlechar ( String str ) { int len = str . Length ; int middle = len / 2 ; Console . WriteLine ( str [ middle ] ) ; }
int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }
int findLength ( string s , int k ) { int ans = INT_MAX ; int l = 0 ; int r = 0 ; int cnt_zero = 0 , cnt_one = 0 ; while ( l < s . Length && r <= s . Length ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = Math . Min ( ans , r - l ) ; l ++ ; if ( s [ l - 1 ] == '0' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . Length ) break ; if ( s [ r ] == '0' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == INT_MAX ) return - 1 ; return ans ; }
void printMatrix ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) Console . Write ( k + " ▁ " ) ; else Console . Write ( "0 ▁ " ) ; } Console . Write ( " STRNEWLINE " ) ; } }
int remainingArea ( int N , int M , int K ) { while ( K -- > 0 && N > 0 && M > 0 ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
int countDigits ( int a , int b ) { int count = 0 ; int p = Math . Abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
int countPairs ( int [ ] arr , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } int ans = ( N - odd + odd / 2 - 1 ) + odd / 2 ; return ans ; }
int countSol ( int [ ] coeff , int n , int rhs ) { int [ ] dp = new int [ rhs + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
int find_longest_subarray ( int [ ] A , int N , int K ) { int MaxLen = 0 ; int Len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = Math . Max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
double polite ( double n ) { n += 1 ; double base1 = 2 ; return n + ( Math . Log ( ( n + ( Math . Log ( n ) / Math . Log ( base1 ) ) ) ) ) / Math . Log ( base1 ) ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 0 ; else return - 1 ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i , curr ] = l ; if ( r != - 1 ) dp [ i , curr ] = Math . Max ( dp [ i , curr ] , r + 1 ) ; return dp [ i , curr ] ; }
int maxBalancedStr ( string s ) { int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { switch ( s [ i ] ) { case ' ( ' : open1 ++ ; break ; case ' ) ' : close1 ++ ; break ; case ' { ' : open2 ++ ; break ; case ' } ' : close2 ++ ; break ; case ' [ ' : open3 ++ ; break ; case ' ] ' : close3 ++ ; break ; } } int maxLen = 2 * Math . Min ( open1 , close1 ) + 2 * Math . Min ( open2 , close2 ) + 2 * Math . Min ( open3 , close3 ) ; return maxLen ; }
double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; }
void findNums ( int [ ] arr , int n ) { int S = 0 , X = 0 ; for ( int i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } Console . WriteLine ( X + " ▁ " + ( X + S ) ) ; }
int maxSubsequences ( int [ ] arr , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . ContainsKey ( arr [ i ] ) ) { count = map [ arr [ i ] ] ; if ( count > 1 ) { map . Add ( arr [ i ] , count - 1 ) ; } else map . Remove ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) if ( map . ContainsKey ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . Add ( arr [ i ] - 1 , 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) if ( map . ContainsKey ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . Add ( arr [ i ] - 1 , 1 ) ; } } return maxCount ; }
void minumumOperation ( int N , int [ ] arr ) { int sum_arr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum_arr = sum_arr + arr [ i ] ; } if ( sum_arr >= N ) Console . Write ( sum_arr - N ) ; else Console . Write ( 1 ) ; }
void segregate0and1 ( int [ ] arr , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
void printOtherSides ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) Console . WriteLine ( " - 1" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; Console . Write ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } else { if ( n == 2 ) Console . Write ( " - 1" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; Console . Write ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } }
int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
int xorK ( int n , int k ) { int res = n ; for ( int i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return n ; }
double CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( ( double ) Math . Log ( i ) / ( double ) Math . Log ( 10 ) ) ; } sum *= n ; return Math . Ceiling ( sum ) ; }
int minOperation ( int N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } int k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
int ksmallest ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
int findM ( String s , int x ) { int cnt = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] - '0' != x ) cnt ++ ; } return cnt ; }
void specialSieve ( int n ) { int cnt = 0 ; int [ ] prime = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! ( prime [ i ] > 0 ) ) { cnt ++ ; for ( int j = i ; j <= n ; j += i ) prime [ j ] = cnt ; } } for ( int i = 2 ; i <= n ; i ++ ) Console . Write ( prime [ i ] + " ▁ " ) ; }
String nambiarNumber ( String str , int i ) { if ( i >= str . Length ) return " " ; int firstDigit = ( str [ i ] - '0' ) ; int digitParity = firstDigit % 2 ; int sumDigits = 0 ; while ( i < str . Length ) { sumDigits += ( str [ i ] - '0' ) ; int sumParity = sumDigits % 2 ; if ( digitParity != sumParity ) { break ; } i ++ ; } return ( " " + sumDigits + nambiarNumber ( str , i + 1 ) ) ; }
String unique ( String s ) { String str = " " ; int len = s . Length ; for ( int i = 0 ; i < len ; i ++ ) { char c = s [ i ] ; if ( str . IndexOf ( c ) < 0 ) { str += c ; } } return str ; }
int countWays ( int n ) { int [ ] res = new int [ n + 2 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
int totEdge ( int n ) { int result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
int minInsertion ( String str ) { int n = str . Length ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
int numberOfArithmeticSequences ( int [ ] L , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
int maxRightmostElement ( int N , int k , int p , int [ ] arr ) { while ( k > 0 ) { for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= p ) { arr [ i ] = arr [ i ] - p ; arr [ i + 1 ] = arr [ i + 1 ] + p ; break ; } } k -- ; } return arr [ N - 1 ] ; }
int xor_operations ( int N , int [ ] arr , int M , int K ) { if ( M < 0 M >= N ) return - 1 ; if ( K < 0 K >= N - M ) return - 1 ; for ( int p = 0 ; p < M ; p ++ ) { List < int > temp = new List < int > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . Add ( value ) ; arr [ i ] = temp [ i ] ; } } int ans = arr [ K ] ; return ans ; }
int findSingle ( int [ ] ar , int ar_size ) { int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
void divide ( int a , int b ) { for ( int i = 2 ; i <= Math . Min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } Console . WriteLine ( " A ▁ = ▁ " + a + " , ▁ B ▁ = ▁ " + b ) ; }
int solve ( int n , int m , int x , int y , int d ) { int top = Math . Min ( d , x - 1 ) ; int down = Math . Min ( d , n - x ) ; int left = Math . Min ( d , y - 1 ) ; int right = Math . Min ( d , m - y ) ; int quad1 = top * left ; int quad2 = left * down ; int quad3 = down * right ; int quad4 = right * top ; int totalsq = quad1 + quad2 + quad3 + quad4 ; int singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }
int countSubStrings ( String s , int n ) { int count = 0 , sum = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; mp . Add ( 0 , 1 ) ; for ( int i = 0 ; i < n ; ++ i ) { sum += ( s [ i ] - '0' ) ; count += mp . ContainsKey ( sum - ( i + 1 ) ) == true ? mp [ sum - ( i + 1 ) ] : 0 ; if ( ! mp . ContainsKey ( sum - ( i + 1 ) ) ) mp . Add ( sum - ( i + 1 ) , 1 ) ; else mp [ sum - ( i + 1 ) ] = mp [ sum - ( i + 1 ) ] + 1 ; } return count ; }
bool canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
int LongestSubarray ( int [ ] arr , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . Max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . Max ( max_length , count ) ; }
int findMinDiff ( int [ ] arr , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; Array . Sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = int . MaxValue ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
int findNumber ( int N ) { return N & ( N + 1 ) ; }
bool isPossible ( int n , int k , int [ ] arr ) { int sum = arr [ 0 ] ; int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . Max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; }
int count ( int [ ] arr , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }
int minimumflip ( int [ , ] mat , int n ) { int [ , ] transpose = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i , j ] = mat [ j , i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i , j ] != mat [ i , j ] ) flip ++ ; return flip / 2 ; }
int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }
float Length_Diagonal ( int a , int b , int d ) { float diagonal = ( float ) Math . Sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; }
void printExpansion ( String str ) { String suff = " " ; for ( int i = str . Length - 1 ; i >= 0 ; i -- ) { suff = suff + str [ i ] ; Console . Write ( suff ) ; } }
int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return ( int ) ( Math . Pow ( 2 , N / 2 + 1 ) + Math . Pow ( 2 , N / 2 ) - 2 ) ; } else { return ( int ) ( Math . Pow ( 2 , ( N + 1 ) / 2 ) + Math . Pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ; else return ( ( n + 1 ) / 2 ) * n ; }
int countElements ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; float mean = ( float ) sum / n ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float newMean = ( float ) ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }
int findMinDiff ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int diff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
void getElements ( int a , int [ ] arr , int n ) { int [ ] elements = new int [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) Console . Write ( elements [ i ] + " ▁ " ) ; }
void printThreeParts ( int N ) { if ( N % 3 == 0 ) Console . WriteLine ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " + ( N - 2 ) ) ; else Console . WriteLine ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " + ( N - 3 ) ) ; }
int cntElements ( int [ ] arr , int n ) { int [ ] copy_arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s [ i ] == s [ j ] ) result ++ ; return result ; }
void meanOfRemainingElements ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int kthPercent = ( N * K ) / 100 ; float sum = 0f ; for ( int i = 0 ; i < N ; i ++ ) if ( i >= kthPercent && i < ( N - kthPercent ) ) sum += arr [ i ] ; float mean = ( sum / ( N - 2 * kthPercent ) ) ; Console . WriteLine ( Math . Round ( mean , 5 ) ) ; }
double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }
void PossibleValues ( int b , int x , int n ) { int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { Console . Write ( leastdivisible - b + " ▁ " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) Console . WriteLine ( - 1 ) ; }
int countXorPair ( int [ ] arr , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
int findMinDel ( int [ ] arr , int n ) { int min_num = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) min_num = Math . Min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }
int countPalindromic ( int n ) { int count ; if ( n % 2 == 1 ) { count = ( int ) Math . Pow ( 9 , ( n - 1 ) / 2 ) ; } else { count = ( int ) Math . Pow ( 9 , ( n - 2 ) / 2 ) ; } return count ; }
void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * ( int ) Math . Pow ( r , i ) ; Console . Write ( curr_term + " ▁ " ) ; } }
int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }
int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; }
bool checkPowerof8 ( int n ) { double i = Math . Log ( n ) / Math . Log ( 8 ) ; return ( i - Math . Floor ( i ) < 0.000001 ) ; }
int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
bool isValidISBN ( string isbn ) { int n = isbn . Length ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
long NumberofWays ( int n ) { long x = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; long y = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) ; return ( 1l * x * y ) ; }
void productPuzzle ( int [ ] a , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . Log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ( int ) ( EPS + Math . Pow ( 10.00 , sum - Math . Log10 ( a [ i ] ) ) ) + " ▁ " ) ; }
int maxCost ( int [ ] a , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = Math . Max ( mx , a [ i ] ) ; int [ ] count = new int [ mx + 1 ] ; for ( int i = 0 ; i < count . Length ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . Min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = Math . Max ( num - l - 1 , 0 ) ; res [ num ] = Math . Max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
void compute ( int [ ] a , int N , int K ) { Dictionary < long , long > eqVal = new Dictionary < long , long > ( ) ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . ContainsKey ( val ) ) { long numVal = eqVal [ val ] ; maxX = Math . Max ( maxX , val + ( K * numVal ) ) ; eqVal [ val ] = 1 + eqVal . GetValueOrDefault ( val , 0 ) ; } else { eqVal . Add ( val , 1 ) ; maxX = Math . Max ( maxX , val ) ; } } Console . Write ( maxX == 0 ? 0 : maxX + 1 ) ; }
int subsetSum ( int [ ] arr , int n , int i , int sum , int count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }
int SquareRoot ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; }
int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }
void printOrder ( int [ ] arr , int k ) { int n = arr . Length ; Array . Sort ( arr , 0 , k ) ; Array . Sort ( arr , k , n - k ) ; Array . Reverse ( arr , k , n - k ) ; }
int getSingle ( int [ ] arr , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
int count ( String s ) { int N , i , cnt = 0 , ans = 0 ; N = s . Length ; for ( i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' R ' ) cnt ++ ; if ( s [ i ] == ' L ' ) ans += cnt ; } return ans ; }
void check ( ulong m , ulong n ) { double RHS = m * ( double ) Math . Log ( n ) ; double LHS = n * ( double ) Math . Log ( m ) ; if ( LHS > RHS ) Console . Write ( " m ^ n ▁ > ▁ n ^ m " ) ; else if ( LHS < RHS ) Console . Write ( " m ^ n ▁ < ▁ n ^ m " ) ; else Console . Write ( " m ^ n ▁ = ▁ n ^ m " ) ; }
void find_composite_nos ( int n ) { Console . WriteLine ( 9 * n + " ▁ " + 8 * n ) ; }
int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . Min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
void findMinAvgSubarray ( int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } Console . Write ( " Subarray ▁ between ▁ [ " + res_index + " , ▁ " + ( res_index + k - 1 ) + " ] ▁ has ▁ minimum ▁ average " ) ; }
long findDigits ( int n , int b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double M_PI = 3.141592 ; double M_E = 2.7182 ; double x = ( ( n * Math . Log10 ( n / M_E ) + Math . Log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . Log10 ( b ) ) ; return ( long ) ( Math . Floor ( x ) + 1 ) ; }
int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
int kthdigit ( int a , int b , int k ) { int p = ( int ) Math . Pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
int getFirstElement ( int [ ] a , int N , int K , int M ) { K %= N ; int index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v1 [ i , curr ] ) return dp1 [ i , curr ] ; v1 [ i , curr ] = true ; dp1 [ i , curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i , curr ] ; }
bool difSquare ( int n ) { if ( n % 4 != 2 ) { return true ; } return false ; }
int minOR ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; int [ ] pre = new int [ n ] ; int [ ] suf = new int [ n ] ; pre [ 0 ] = arr [ 0 ] ; suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = Math . Min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = Math . Min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
bool check ( int [ ] arr , int n ) { int i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }
int kthOdd ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; }
void sortDiff ( List < int > arr , int n ) { arr . Sort ( ) ; List < int > Out = new List < int > ( ) ; while ( n > 0 ) { Out . Add ( arr [ n / 2 ] ) ; arr . RemoveAt ( n / 2 ) ; n = n - 1 ; } foreach ( int i in Out ) Console . Write ( i + " ▁ " ) ; }
void swapTwoHalves ( string a , string b ) { int la = a . Length ; int lb = b . Length ; string c = a . Substring ( 0 , la / 2 ) + b . Substring ( lb / 2 , lb / 2 + 1 ) ; string d = b . Substring ( 0 , lb / 2 ) + a . Substring ( la / 2 , la / 2 ) ; Console . Write ( c + " STRNEWLINE " + d + " STRNEWLINE " ) ; }
bool isRotation ( long x , long y ) { long x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; }
int minimumcoins ( int [ ] arr , int N ) { int coins = 0 ; int j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } int x = ( j - i ) ; coins += x / 3 ; i = j - 1 ; } return coins ; }
bool isnonagonal ( int N ) { double n = ( 5 + Math . Sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
int cntKnightsAttackPawn ( int [ , ] knights , int [ ] pawn , int M ) { int cntKnights = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int X = Math . Abs ( knights [ i , 0 ] - pawn [ 0 ] ) ; int Y = Math . Abs ( knights [ i , 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }
int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
int sum ( int n ) { n = ( n + 1 ) / 2 ; return ( n * n ) ; }
int countMinSteps ( int [ ] arr , int target , int n ) { Array . Sort ( arr ) ; int minimumSteps = 0 ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i += 1 ; j -= 1 ; } else { j -= 1 ; } minimumSteps += 1 ; } return minimumSteps ; }
void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
int longestOddEvenSubarray ( int [ ] A , int N ) { int dp ; dp = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp = dp + 1 ; ans = Math . Max ( ans , dp ) ; } else dp = 1 ; } return ans ; }
void findArea ( double a , double b , double c ) { double area = 4 * 3.141592653 * Math . Pow ( ( Math . Pow ( a * b , 1.6 ) + Math . Pow ( a * c , 1.6 ) + Math . Pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; Console . Write ( Math . Round ( area , 2 ) ) ; }
long findMinCost ( int [ ] a , int k , int n ) { int max_ele = a . Max ( ) ; long [ ] dp = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) dp [ i ] = int . MaxValue ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int [ ] freq = new int [ max_ele + 1 ] ; for ( int j = i ; j < n ; ++ j ) { freq [ a [ j ] ] ++ ; int cost = 0 ; for ( int x = 0 ; x <= max_ele ; ++ x ) { cost += ( freq [ x ] == 1 ) ? 0 : freq [ x ] ; } dp [ j + 1 ] = Math . Min ( dp [ i ] + cost + k , dp [ j + 1 ] ) ; } } return dp [ n ] ; }
int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
void angleextcycquad ( int z ) { Console . WriteLine ( " The ▁ exterior ▁ angle ▁ of ▁ the " + " ▁ cyclic ▁ quadrilateral ▁ is ▁ " + z + " ▁ degrees " ) ; }
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { Console . Write ( ( 3 * i * ( i - 1 ) + 1 ) + " ▁ " ) ; i ++ ; } }
int findMinDeletions ( int [ , ] v , int n ) { int minDel = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int L = v [ i , 0 ] ; int R = v [ i , 1 ] ; int Count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j , 0 ] >= L && v [ j , 1 ] <= R ) { Count += 1 ; } } minDel = Math . Min ( minDel , n - Count ) ; } return minDel ; }
void makearrayequal ( int [ ] arr , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += ( arr [ i ] & 1 ) ; } Console . WriteLine ( Math . Min ( x , n - x ) ) ; }
int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; }
long fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
void canBeEmptied ( int A , int B ) { if ( Math . Max ( A , B ) > 2 * Math . Min ( A , B ) ) { Console . WriteLine ( " No " ) ; return ; } if ( ( A + B ) % 3 == 0 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
void perfectCube ( int N ) { int cube_root ; cube_root = ( int ) Math . Round ( Math . Cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { Console . WriteLine ( " Yes " ) ; return ; } else { Console . WriteLine ( " NO " ) ; return ; } }
int minimumLectures ( int m , int n ) { int ans = 0 ; if ( n < ( int ) Math . Ceiling ( 0.75 * m ) ) ans = ( int ) Math . Ceiling ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; }
int countNonDecreasing ( int n ) { int [ , ] dp = new int [ 10 , n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i , 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit , len ] += dp [ x , len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i , n ] ; return count ; }
int octahedral_num ( int n ) { return n * ( 2 * n * n + 1 ) / 3 ; }
void checkDistribution ( int R , int B , int D ) { if ( Math . Max ( R , B ) <= Math . Min ( R , B ) * ( D + 1 ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } }
int lenOflongestReqSubstr ( String s , int N ) { Dictionary < int , int > ind = new Dictionary < int , int > ( ) ; int mask = 0 ; ind . Add ( 0 , - 1 ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = s [ i ] - '0' ; mask ^= ( 1 << val ) ; if ( ind . ContainsKey ( mask ) ) { ans = Math . Max ( ans , i - ind [ mask ] ) ; } else ind . Add ( mask , i ) ; } return ans ; }
int summingSeries ( long n ) { return ( int ) Math . Pow ( n , 2 ) ; }
int getMaxLength ( int [ ] arr , int N ) { int res = 2 ; int dist = 2 ; int curradj = ( arr [ 1 ] - arr [ 0 ] ) ; int prevadj = ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < N ; i ++ ) { curradj = arr [ i ] - arr [ i - 1 ] ; if ( curradj == prevadj ) { dist ++ ; } else { prevadj = curradj ; res = Math . Max ( res , dist ) ; dist = 2 ; } } res = Math . Max ( res , dist ) ; return res ; }
int coutSubSeq ( int [ ] A , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
void sameChar ( String S , int N ) { char [ ] temp = S . ToCharArray ( ) ; Array . Sort ( temp ) ; String s = new String ( temp ) ; int mid = s [ N / 2 ] ; int total_operations = 0 ; for ( int i = 0 ; i < N ; i ++ ) { total_operations += Math . Abs ( ( s [ i ] - 0 ) - mid ) ; } Console . Write ( total_operations ) ; }
int oddbitsetnumber ( int n ) { int count = 0 ; int res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
bool isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; }
float strikerate ( float bowls , float runs ) { float z ; z = ( runs / bowls ) * 100 ; return z ; }
void countOperations ( string X , string Y , int K ) { char [ ] ch1 = X . ToCharArray ( ) ; char [ ] ch2 = Y . ToCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < X . Length ; i ++ ) { int c = 0 ; if ( ch1 [ i ] == ch2 [ i ] ) continue ; else if ( ch1 [ i ] < ch2 [ i ] ) { if ( ( ( int ) ch2 [ i ] - ( int ) ch1 [ i ] ) >= K ) { c = ( ( int ) ch2 [ i ] - ( int ) ch1 [ i ] ) / K ; } c += ( ( int ) ch2 [ i ] - ( int ) ch1 [ i ] ) % K ; } else { int t = 90 - ( int ) ch1 [ i ] ; t += ( int ) ch2 [ i ] - 65 + 1 ; if ( t >= K ) c = t / K ; c += ( t % K ) ; } count += c ; } Console . WriteLine ( count ) ; }
int maxMinDifference ( int [ ] arr , int n , int k ) { if ( k >= n - 1 ) return 0 ; Array . Sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; for ( int i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = Math . Min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }
int numberOfTiles ( int n , int m ) { if ( n % 2 == 1 ) { return - 1 ; } return ( m * n ) / 2 ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; }
int FindColumn ( int [ , ] mat ) { int row = 0 , col = M - 1 ; int flag = 0 ; while ( row < N && col >= 0 ) { if ( mat [ row , col ] == 1 ) { col -- ; flag = 1 ; } else { row ++ ; } } col ++ ; if ( flag != 0 ) return col + 1 ; else return - 1 ; }
void search ( int [ , ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i , j ] == x ) { Console . Write ( " n ▁ Found ▁ at ▁ " + i + " , ▁ " + j ) ; return ; } if ( mat [ i , j ] > x ) j -- ; else i ++ ; } Console . Write ( " n ▁ Element ▁ not ▁ found " ) ; return ; }
void findPermutation ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( i + " ▁ " ) ; }
int max_xor ( int [ ] arr , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxXor = Math . Max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }
int countSubStr ( String str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
int countOccurrences ( string str , string word ) { string [ ] a = str . Split ( ' ▁ ' ) ; int count = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { if ( word . Equals ( a [ i ] ) ) count ++ ; } return count ; }
int findXOR ( int [ ] Set , int n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
float Area ( int d , int h1 , int h2 ) { float area ; area = ( float ) 0.5 * d * ( h1 + h2 ) ; return area ; }
bool findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( ( y & 1 ) > 0 ) return true ; return false ; }
int MinimumValue ( int [ ] a , int n ) { int answer = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = Math . Min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; Console . WriteLine ( edges_max_secondary + 3 ) ; } else Console . WriteLine ( " Not ▁ Possible " ) ; }
void countOccurrences ( string S , string X , string Y ) { int count = 0 ; int N = S . Length , A = X . Length ; int B = Y . Length ; int P = Math . Min ( A , Math . Min ( N , B ) ) ; for ( int i = 0 ; i < N - P + 1 ; i ++ ) { if ( S . Substring ( i , Math . Min ( N , B ) ) . Equals ( Y ) ) count ++ ; if ( S . Substring ( i , Math . Min ( N , A ) ) . Equals ( X ) ) Console . Write ( count + " ▁ " ) ; } }
int countEqual ( int n ) { return ( n + 1 ) / 2 ; }
void findMaxValue ( int N , int K ) { int packages ; int maxi = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = Math . Max ( maxi , i ) ; } packages = N / maxi ; Console . WriteLine ( packages ) ; }
void lastDigit ( String a , String b ) { int lastDig = ( a [ a . Length - 1 ] - '0' ) * ( b [ b . Length - 1 ] - '0' ) ; Console . Write ( lastDig % 10 ) ; }
int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N , K ] != 0 ) return memo [ N , K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N , K ] = sum ; return sum ; }
int solve ( int [ ] A , int [ ] B , int [ ] C ) { int i , j , k ; i = A . Length - 1 ; j = B . Length - 1 ; k = C . Length - 1 ; int min_diff , current_diff , max_term ; min_diff = Math . Abs ( Math . Max ( A [ i ] , Math . Max ( B [ j ] , C [ k ] ) ) - Math . Min ( A [ i ] , Math . Min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . Abs ( Math . Max ( A [ i ] , Math . Max ( B [ j ] , C [ k ] ) ) - Math . Min ( A [ i ] , Math . Min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . Max ( A [ i ] , Math . Max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
void MaximumSum ( int [ ] a , int [ ] b , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } Console . WriteLine ( sum1 + sum2 ) ; }
int minAdjustmentCost ( int [ ] A , int n , int target ) { int [ , ] dp = new int [ n , M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 , j ] = Math . Abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i , j ] = int . MaxValue ; int k = Math . Max ( j - target , 0 ) ; for ( ; k <= Math . Min ( M , j + target ) ; k ++ ) dp [ i , j ] = Math . Min ( dp [ i , j ] , dp [ i - 1 , k ] + Math . Abs ( A [ i ] - j ) ) ; } } int res = int . MaxValue ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . Min ( res , dp [ n - 1 , j ] ) ; return res ; }
void checkSamePosition ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . ContainsKey ( temp ) ) { Console . Write ( " Yes " ) ; return ; } mp [ temp ] = 1 ; } Console . Write ( " No " ) ; }
long firstkdigits ( int n , int k ) { long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / Math . Pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; }
int countCommon ( int [ , ] mat , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i , i ] == mat [ i , n - i - 1 ] ) res ++ ; return res ; }
int minswaps ( int [ ] arr , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 2 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; }
void maximum_pallindromic ( int [ ] arr ) { int res = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res += arr [ i ] / 3 ; arr [ i ] = arr [ i ] % 3 ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += Math . Min ( c1 , c2 ) ; int t = Math . Min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * ( c2 / 3 ) ; c2 %= 3 ; res += c2 / 2 ; Console . Write ( res ) ; }
void ASCIISentence ( string str ) { int l = str . Length ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str [ i ] ; Console . Write ( convert ) ; } }
int minDifference ( int x , int y , int k , int [ , ] b , int [ , ] c ) { int diff = 0 ; if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { diff = b [ x , y ] - c [ x , y ] ; return Math . Min ( Math . Abs ( k - diff ) , Math . Abs ( k + diff ) ) ; } int ans = dp [ x , y , k ] ; if ( ans != - 1 ) return ans ; ans = INT_MAX ; diff = b [ x , y ] - c [ x , y ] ; ans = Math . Min ( ans , minDifference ( x + 1 , y , Math . Abs ( k + diff ) , b , c ) ) ; ans = Math . Min ( ans , minDifference ( x , y + 1 , Math . Abs ( k + diff ) , b , c ) ) ; ans = Math . Min ( ans , minDifference ( x + 1 , y , Math . Abs ( k - diff ) , b , c ) ) ; ans = Math . Min ( ans , minDifference ( x , y + 1 , Math . Abs ( k - diff ) , b , c ) ) ; return ans ; }
int sumMax ( int i , int [ ] arr , int n ) { if ( i >= n - 1 ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . Max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) ; return dp [ i ] ; }
int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }
bool Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; }
double findAverageOfCube ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; }
int numPrimeArrangements ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) { for ( int factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } } int primeIndices = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; int mod = ( int ) ( 1e9 + 7 ) , res = 1 ; for ( int i = 1 ; i <= primeIndices ; i ++ ) res = ( int ) ( ( 1L * res * i ) % mod ) ; for ( int i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( int ) ( ( 1L * res * i ) % mod ) ; return res ; }
int deleteElement ( int [ ] arr , int n , int x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; int prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { int curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
int countSequences ( int [ ] arr , int n ) { int count = 1 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
int difference ( int [ , ] arr , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i , j ] ; if ( i == n - j - 1 ) d2 += arr [ i , j ] ; } } return Math . Abs ( d1 - d2 ) ; }
int series ( int n ) { return ( 8 * n * n ) + 1 ; }
void maxSum ( int [ ] a , int n ) { List < int > l = new List < int > ( ) ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += Math . Abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . Add ( i + 1 ) ; else { l . Add ( i + 1 ) ; l . Add ( i ) ; } } Console . WriteLine ( s ) ; for ( int i = 0 ; i < l . Count ; i ++ ) Console . Write ( l [ i ] + " ▁ " ) ; }
void smallerNumbers ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count ++ ; } } Console . Write ( count + " ▁ " ) ; } }
void printMaxSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . Sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( dp [ i ] + " ▁ " ) ; }
int findMinDif ( int [ ] arr , int N ) { Array . Sort ( arr ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }
int minimumcntOperationReq ( int [ ] arr , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }
bool isSumCube ( int N ) { int a = ( int ) Math . Pow ( N , ( double ) 1 / 3 ) ; int b = a - 1 ; return ( ( a * a * a + b * b * b ) == N ) ; }
int countPairs ( string s1 , int n1 , string s2 , int n2 ) { int [ ] freq1 = new int [ 26 ] ; int [ ] freq2 = new int [ 26 ] ; Array . Fill ( freq1 , 0 ) ; Array . Fill ( freq2 , 0 ) ; int i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 [ i ] - ' a ' ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 [ i ] - ' a ' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( Math . Min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }
int computeLastDigit ( long A , long B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long i = A + 1 ; i <= B ; i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
int nextGreater ( int N ) { int power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
int sumOfProd ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }
void minimumOperations ( string S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } Console . WriteLine ( ans ) ; }
int minFlips ( int [ , ] mat , String s ) { int N = mat . GetLength ( 0 ) ; int M = mat . GetLength ( 1 ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i , j ] != s [ i + j ] - '0' ) { count ++ ; } } } return count ; }
int usingBinarySearch ( int start , int end , int N , int S ) { if ( start >= end ) return start ; int mid = start + ( end - start ) / 2 ; int totalSum = ( N * ( N + 1 ) ) / 2 ; int midSum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( totalSum - midSum ) <= S ) { return usingBinarySearch ( start , mid , N , S ) ; } return usingBinarySearch ( mid + 1 , end , N , S ) ; }
int find_index ( int [ ] arr , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }
void checkTriangle ( int x , int y , int z ) { if ( x == y && y == z ) Console . WriteLine ( " Equilateral ▁ Triangle " ) ; else if ( x == y y == z z == x ) Console . WriteLine ( " Isosceles ▁ Triangle " ) ; else Console . WriteLine ( " Scalene ▁ Triangle " ) ; }
void printpairs ( int [ ] arr , int sum ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < arr . Length ; ++ i ) { int temp = sum - arr [ i ] ; if ( s . Contains ( temp ) ) { Console . Write ( " Pair ▁ with ▁ given ▁ sum ▁ " + sum + " ▁ is ▁ ( " + arr [ i ] + " , ▁ " + temp + " ) " ) ; } s . Add ( arr [ i ] ) ; } }
int maxProduct ( int [ ] arr , int n ) { if ( n < 4 ) return - 1 ; Array . Sort ( arr ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . Max ( x , Math . Max ( y , z ) ) ; }
int CountSubSet ( int [ ] arr , int n , int X ) { int N = ( int ) Math . Pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }
void findNumbers ( int n ) { int i = 0 ; while ( i <= n ) { Console . Write ( 2 * i * i + 4 * i + 1 + i % 2 + " ▁ " ) ; i ++ ; } }
void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
void findMinSum ( int [ ] A , int K ) { int n = A . Length ; int minimum_sum = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int min = int . MaxValue ; for ( int j = i + K ; j < n ; j ++ ) min = Math . Min ( min , A [ j ] ) ; if ( min == int . MaxValue ) continue ; minimum_sum = Math . Min ( minimum_sum , A [ i ] + min ) ; } Console . WriteLine ( minimum_sum ) ; }
void redistribute ( int [ ] arr , int n , int x ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum / ( i + 1 ) < x ) { Console . Write ( i + " STRNEWLINE " ) ; break ; } } if ( i == n ) Console . Write ( n + " STRNEWLINE " ) ; }
int NumberOfSolutions ( int x , int y , int z , int n ) { int ans = 0 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { int temp = n - i - j ; if ( temp >= 0 ) { temp = Math . Min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
long getSum ( int n , int d ) { long sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
float trianglearea ( float r ) { if ( r < 0 ) return - 1 ; return r * r ; }
long boost_hyperfactorial ( long num ) { long val = 1 ; for ( long i = 1 ; i <= num ; i ++ ) { val = val * ( long ) Math . Pow ( i , i ) ; } return val ; }
void evenSubMatrix ( int N ) { int even = 1 ; int odd = 2 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( i + j ) % 2 == 0 ) { Console . Write ( even + " ▁ " ) ; even += 2 ; } else { Console . Write ( odd + " ▁ " ) ; odd += 2 ; } } Console . WriteLine ( ) ; } }
void findRange ( int [ ] arr , int N , int K ) { int L = Int32 . MinValue ; int R = Int32 . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { int l = ( int ) Math . Ceiling ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; int r = ( int ) Math . Ceiling ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = Math . Max ( L , l ) ; R = Math . Min ( R , r ) ; } Console . WriteLine ( L + " ▁ " + R ) ; }
int findNthOccur ( String str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; }
int lastElement ( int [ ] arr , int n ) { int sum = 0 ; int multiplier = n % 2 == 0 ? - 1 : 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * multiplier ; multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( - 1 ) ; } return sum ; }
int findMinMoves ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return - 1 ; int avg = sum / N ; int total = 0 ; int needCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = Math . Max ( Math . Max ( Math . Abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }
ArrayList getLudic ( int n ) { ArrayList ludics = new ArrayList ( ) ; for ( int i = 1 ; i <= n ; i ++ ) ludics . Add ( i ) ; for ( int index = 1 ; index < ludics . Count ; index ++ ) { int first_ludic = ( int ) ludics [ index ] ; int remove_index = index + first_ludic ; while ( remove_index < ludics . Count ) { ludics . Remove ( ludics [ remove_index ] ) ; remove_index = remove_index + first_ludic - 1 ; } } return ludics ; }
int sumPairs ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
int min_elimination ( int n , int [ ] arr ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; }
int cntSplits ( String s ) { if ( s [ s . Length - 1 ] == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) c_zero += ( s [ i ] == '0' ) ? 1 : 0 ; return ( int ) Math . Pow ( 2 , c_zero - 1 ) ; }
int maxXorSum ( int n , int k ) { if ( k == 1 ) return n ; int res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
void findMidAlphabet ( String s1 , String s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int mid = ( s1 [ i ] + s2 [ i ] ) / 2 ; Console . Write ( ( char ) mid ) ; } }
void findTriangle ( long S ) { long X1 = 0 , Y1 = 0 ; long X2 = MAX , Y2 = 1 ; long X3 = ( MAX - S % MAX ) % MAX ; long Y3 = ( S + X3 ) / MAX ; Console . WriteLine ( " ( " + X1 + " , ▁ " + Y1 + " ) " ) ; Console . WriteLine ( " ( " + X2 + " , ▁ " + Y2 + " ) " ) ; Console . WriteLine ( " ( " + X3 + " , ▁ " + Y3 + " ) " ) ; }
int countRhombi ( int h , int w ) { int ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
void pen_hex ( long n ) { long pn = 1 ; for ( long i = 1 ; ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; double seqNum = ( 1 + Math . Sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == ( long ) ( seqNum ) ) { Console . Write ( pn + " , ▁ " ) ; } } }
int totalCountDifference ( int n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( n / 2 ) ; }
int Solve ( int [ ] arr , int n ) { int temp = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; }
void findMaxNumbers ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int opr = ( int ) Math . Ceiling ( ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } Console . Write ( cnt ) ; }
int getPairs ( int [ ] a ) { int count = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { for ( int j = 0 ; j < a . Length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; }
String checkPattern ( int [ ] arr , int m , int k , int n ) { int count = 1 , t = 0 ; for ( int i = 0 ; i < n - m ; i ++ ) { if ( arr [ i ] == arr [ i + m ] ) { t ++ ; if ( t == m ) { t = 0 ; count ++ ; if ( count == k ) { return " Yes " ; } } } else { t = 0 ; count = 1 ; } } return " No " ; }
void areSame ( int a , int b ) { if ( ( a - b ) == 0 ) Console . Write ( " Same " ) ; else Console . Write ( " Not ▁ Same " ) ; }
void catalan ( int n ) { int cat_ = 1 ; Console . Write ( cat_ + " ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; Console . Write ( cat_ + " ▁ " ) ; } }
void findMaxGuests ( int [ ] arrl , int [ ] exit , int n ) { Array . Sort ( arrl ) ; Array . Sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } Console . Write ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + max_guests + " ▁ at ▁ time ▁ " + time ) ; }
void findWinner ( int X , int Y ) { int first = ( X ^ Y ) ; int second = ( X + Y ) ; if ( first == second ) { Console . Write ( " No " ) ; } else { Console . Write ( " Yes " ) ; } }
int equilibrium ( int [ ] arr , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }
bool pronic_check ( int n ) { int x = ( int ) ( Math . Sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
int minLength ( int [ ] A , int N ) { int elem = A [ 0 ] , count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; }
double findPCSlope ( double m ) { return - 1.0 / m ; }
int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }
int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; }
double cyl ( double r , double h ) { if ( r < 0 && h < 0 ) return - 1 ; double R = ( 2 * r ) / 3 ; double H = ( 2 * h ) / 3 ; double V = 3.14 * Math . Pow ( R , 2 ) * H ; return V ; }
int minCost ( int [ ] coin , int n , int k ) { Array . Sort ( coin ) ; int coins_needed = ( int ) Math . Ceiling ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . Length ; int [ ] b = solve ( arr , n ) ; Console . WriteLine ( " [ " + String . Join ( " , " , b ) + " ] " ) ; } }
int countValues ( int n ) { int unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
int count ( int [ ] a , int M , int N ) { int cnt = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; }
void removeElements ( int [ ] arr , int n ) { int [ ] brr = new int [ n ] ; int l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) Console . Write ( brr [ i ] + " ▁ " ) ; }
int countZeroes ( int [ , ] mat ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row , col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . Max ( result , arr [ i ] ) ; return result ; }
int length_substring ( string S , char K ) { int curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( int i = 0 ; i < S . Length ; i ++ ) { if ( S [ i ] == K ) { curr_cnt += 1 ; } else { prev_cnt = Math . Max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = Math . Max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; }
int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
int maxPartitions ( int [ ] arr , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = Math . Max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
int Icosikaipentagon ( int n ) { return ( 23 * n * n - 21 * n ) / 2 ; }
int countTrailingZero ( int x ) { int [ ] lookup = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; }
void findkth ( int n , int k ) { List < int > v1 = new List < int > ( ) ; List < int > v2 = new List < int > ( ) ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . Add ( i ) ; if ( i != Math . Sqrt ( n ) ) v2 . Add ( n / i ) ; } } v2 . Reverse ( ) ; if ( k > ( v1 . Count + v2 . Count ) ) Console . Write ( " Doesn ' t ▁ Exist " ) ; else { if ( k <= v1 . Count ) Console . Write ( v1 [ k - 1 ] ) ; else Console . Write ( v2 [ k - v1 . Count - 1 ] ) ; } }
double heptdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.802 * a ; return d ; }
bool asPowerSum ( int w , int m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
bool CheckBinaryEquivalent ( int N ) { return ( N - 1 ) % 8 == 0 ; }
int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
long SmallestPerfectSquare ( long N ) { long X = ( long ) 1e9 ; long ans ; for ( int i = 1 ; i < Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { long a = i ; long b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = Math . Min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = - 1 ; return ans ; }
int speedOfTrain ( float X , float Y ) { float Speed ; Speed = 1188 * ( ( X - Y ) / Y ) ; return ( int ) Speed ; }
void findNthNumber ( int N ) { int [ ] arr = new int [ N + 1 ] ; Queue < int > q = new Queue < int > ( ) ; for ( int i = 1 ; i <= 9 ; i ++ ) q . Enqueue ( i ) ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i ] = q . Peek ( ) ; q . Dequeue ( ) ; if ( arr [ i ] % 10 != 0 ) q . Enqueue ( arr [ i ] * 10 + arr [ i ] % 10 - 1 ) ; q . Enqueue ( arr [ i ] * 10 + arr [ i ] % 10 ) ; if ( arr [ i ] % 10 != 9 ) q . Enqueue ( arr [ i ] * 10 + arr [ i ] % 10 + 1 ) ; } Console . WriteLine ( arr [ N ] ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
void minimumCost ( int [ ] arr , int [ ] cost , int N ) { int [ , ] dp = new int [ N , 3 ] ; dp [ 0 , 0 ] = 0 ; dp [ 0 , 1 ] = cost [ 0 ] ; dp [ 0 , 2 ] = cost [ 0 ] * 2 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int minimum = ( int ) 1e6 ; if ( j + arr [ i ] != arr [ i - 1 ] ) minimum = Math . Min ( minimum , dp [ i - 1 , 0 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 1 ) minimum = Math . Min ( minimum , dp [ i - 1 , 1 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 2 ) minimum = Math . Min ( minimum , dp [ i - 1 , 2 ] ) ; dp [ i , j ] = j * cost [ i ] + minimum ; } } int ans = ( int ) 1e6 ; for ( int i = 0 ; i < 3 ; i ++ ) ans = Math . Min ( ans , dp [ N - 1 , i ] ) ; Console . Write ( ans + " STRNEWLINE " ) ; }
int minNum ( int n , int k ) { int x = ( int ) ( Math . Log ( n ) / Math . Log ( k ) ) + 1 ; int mn = ( int ) ( Math . Pow ( k , x ) - n ) ; return mn ; }
int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }
int smallestNum ( int n ) { return ( int ) ( ( n * n % 9 + 1 ) * Math . Pow ( 10 , n * n / 9 ) - 1 ) ; }
int no_of_ways ( int [ ] a , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
int getCount ( string str , int n ) { int cnt = 0 ; int i = 0 ; while ( i < n - 2 ) { if ( str [ i ] == str [ i + 1 ] && str [ i ] == str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else { i ++ ; } } return cnt ; }
int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int nthEnneadecagonal ( int n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
long countStr ( int N ) { long [ , ] dp = new long [ N + 1 , 3 ] ; dp [ 1 , 0 ] = 1 ; dp [ 1 , 1 ] = 1 ; dp [ 1 , 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i , 0 ] = ( dp [ i - 1 , 0 ] + dp [ i - 1 , 1 ] + dp [ i - 1 , 2 ] ) % MOD ; dp [ i , 1 ] = dp [ i - 1 , 0 ] % MOD ; dp [ i , 2 ] = dp [ i - 1 , 1 ] % MOD ; } long ans = ( dp [ N , 0 ] + dp [ N , 1 ] + dp [ N , 2 ] ) % MOD ; return ans ; }
int FindIndexKthBit ( int n , int k ) { int cnt = 0 ; int ind = 0 ; while ( n > 0 ) { if ( ( n & 1 ) != 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; }
int minDistance ( int n1 , int n2 ) { int bitCount1 = ( int ) Math . Floor ( ( Math . Log ( n1 ) / Math . Log ( 2 ) ) ) + 1 ; int bitCount2 = ( int ) Math . Floor ( ( Math . Log ( n2 ) / Math . Log ( 2 ) ) ) + 1 ; int bitDiff = Math . Abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . Max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . Pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . Pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = ( int ) Math . Floor ( ( Math . Log ( xorValue ) / Math . Log ( 2 ) ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
void minCost ( char [ , ] arr , int A , int B ) { int n = arr . GetLength ( 0 ) ; int m = arr . GetLength ( 1 ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i , j ] == ' * ' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i , j + 1 ] == ' . ' ) { ans += Math . Min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } Console . WriteLine ( ans ) ; }
int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
void sumOfSquaredDifferences ( int [ ] arr , int N ) { int ans = 0 ; int sumA = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; Console . WriteLine ( ans ) ; }
int maxSum ( int [ ] a , int n ) { int ans = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int [ , ] dp = new int [ n + 1 , 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i , 0 ] = Math . Max ( arr [ i ] , dp [ i - 1 , 0 ] + arr [ i ] ) ; dp [ i , 1 ] = Math . Max ( 0 , dp [ i - 1 , 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , dp [ i - 1 , 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i , 2 ] = dp [ i - 1 , 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i , 2 ] = Math . Max ( dp [ i , 2 ] , dp [ i - 1 , 2 ] + arr [ i ] ) ; ans = Math . Max ( ans , dp [ i , 0 ] ) ; ans = Math . Max ( ans , dp [ i , 1 ] ) ; ans = Math . Max ( ans , dp [ i , 2 ] ) ; } return ans ; }
void smallestNumber ( int N ) { int L = ( int ) ( Math . Pow ( 10 , N ) - 1 ) ; int S = ( int ) Math . Pow ( 10 , N - 1 ) ; for ( int i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { Console . Write ( i ) ; return ; } } }
void findPairs ( int [ ] x , int [ ] y , int K ) { int n = x . Length ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( K * Math . Abs ( x [ i ] - x [ j ] ) >= Math . Abs ( y [ i ] - y [ j ] ) ) { ++ ans ; } } } Console . WriteLine ( ans ) ; }
int ways ( int i , int [ ] arr , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
int Circumference ( int a ) { return 4 * a ; }
bool solve ( int n , int k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; }
int pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }
int maxPathSum ( int [ , ] tri , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 , j ] > tri [ i + 1 , j + 1 ] ) tri [ i , j ] += tri [ i + 1 , j ] ; else tri [ i , j ] += tri [ i + 1 , j + 1 ] ; } } return tri [ 0 , 0 ] ; }
int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . Max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
void countWaysToTileBoard ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } Console . Write ( dp [ N ] ) ; }
void pairs ( int [ ] arr , int n , int k ) { int smallest = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . Abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . Abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . Abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } Console . WriteLine ( " Minimal ▁ Value ▁ = ▁ " + smallest ) ; Console . WriteLine ( " Total ▁ Pairs ▁ = ▁ " + count ) ; }
char ShortestPalindrome ( String s ) { int n = s . Length ; char ans = s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( char ) Math . Min ( ans , s [ i ] ) ; } return ans ; }
int findLeastDist ( int [ ] A , int N ) { Array . Sort ( A ) ; if ( N % 2 == 0 ) { return A [ ( N - 1 ) / 2 ] ; } else { return A [ N / 2 ] ; } }
int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
int maxDP ( int n ) { int [ ] res = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . Max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }
long LastTwoDigit ( long num ) { long one = num % 10 ; num /= 10 ; long tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
float trapezoidarea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 3 * ( float ) Math . Sqrt ( 3 ) * ( float ) Math . Pow ( r , 2 ) ) / 4 ; return a ; }
long sum ( long n ) { long root = ( long ) Math . Sqrt ( n ) ; long ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }
int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; }
long F ( long A , long B ) { if ( A == 1 ) return ( 4 % B ) ; else { long temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
float productOfGP ( float a , float r , int n ) { return ( float ) Math . Pow ( a , n ) * ( float ) Math . Pow ( r , n * ( n - 1 ) / 2 ) ; }
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { Console . Write ( ( ( 2 * i ) - 1 ) + " ▁ " ) ; i ++ ; } }
bool checkStar ( int [ , ] mat ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 , 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 , 0 ] == 0 && mat [ 0 , 1 ] == 1 && mat [ 1 , 0 ] == 1 && mat [ 1 , 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i , j ] == 1 ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
bool isDiagonalMatrix ( int [ , ] mat ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i , j ] != 0 ) ) return false ; return true ; }
int minSteps ( int N ) { int res = ( ( int ) Math . Sqrt ( 1 + 8 * N ) - 1 ) / 2 ; return res ; }
long noOfTriples ( long [ ] arr , int n ) { Array . Sort ( arr ) ; long count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + Math . Min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; }
void checkIfCurzonNumber ( long N ) { double powerTerm , productTerm ; powerTerm = Math . Pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int findMaximum ( int [ ] arr , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }
void performQuery ( int [ ] arr , int [ , ] Q ) { for ( int i = 0 ; i < Q . Length ; i ++ ) { int or = 0 ; int x = Q [ i , 0 ] ; arr [ x - 1 ] = Q [ i , 1 ] ; for ( int j = 0 ; j < arr . Length ; j ++ ) { or = or | arr [ j ] ; } Console . Write ( or + " ▁ " ) ; } }
int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }
void mirror_point ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; Console . Write ( " x3 ▁ = ▁ " + x3 + " ▁ " ) ; Console . Write ( " y3 ▁ = ▁ " + y3 + " ▁ " ) ; Console . Write ( " z3 ▁ = ▁ " + z3 + " ▁ " ) ; }
int maxLen ( int [ ] arr ) { Dictionary < int , int > hM = new Dictionary < int , int > ( ) ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < arr . GetLength ( 0 ) ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; int prev_i = 0 ; if ( hM . ContainsKey ( sum ) ) { prev_i = hM [ sum ] ; } if ( hM . ContainsKey ( sum ) ) max_len = Math . Max ( max_len , i - prev_i ) ; else { if ( hM . ContainsKey ( sum ) ) hM . Remove ( sum ) ; hM . Add ( sum , i ) ; } } return max_len ; }
int countXORSetBitsAdjElemRange1_N ( int N ) { int total_set_bits = 0 ; int bit_Position = 1 ; while ( N != 0 ) { total_set_bits += ( ( N + 1 ) / 2 * bit_Position ) ; N -= ( N + 1 ) / 2 ; bit_Position ++ ; } return total_set_bits ; }
void printArray ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) Console . Write ( arr [ i ] + " ▁ " ) ; flag = 0 ; r = i ; } k ++ ; } }
void largestSquare ( int [ , ] matrix , int R , int C , int [ ] q_i , int [ ] q_j , int K , int Q ) { int [ , ] countDP = new int [ R , C ] ; countDP [ 0 , 0 ] = matrix [ 0 , 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i , 0 ] = countDP [ i - 1 , 0 ] + matrix [ i , 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 , j ] = countDP [ 0 , j - 1 ] + matrix [ 0 , j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i , j ] = matrix [ i , j ] + countDP [ i - 1 , j ] + countDP [ i , j - 1 ] - countDP [ i - 1 , j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . Min ( Math . Min ( i , j ) , Math . Min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 , y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 , y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 , y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 , y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } Console . Write ( ans + " STRNEWLINE " ) ; } }
float hexagonArea ( float d ) { return ( float ) ( ( 3 * Math . Sqrt ( 3 ) * d * d ) / 8 ) ; }
void tripletAndSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } Console . WriteLine ( ans ) ; }
int smallestIndex ( int [ ] a , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . Min ( right1 , right0 ) ; }
bool isMultipleof5 ( int n ) { char [ ] str = new char [ MAX ] ; int len = str . Length ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; }
void triangleArea ( float a , float b ) { if ( a < 0 b < 0 ) { Console . WriteLine ( - 1 ) ; return ; } float area = ( 3 * ( float ) Math . Sqrt ( 3 ) * a * b ) / ( 4 ) ; Console . WriteLine ( area ) ; }
void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & N ) > 0 ) { result ++ ; } } Console . WriteLine ( result ) ; }
void precomputation ( int [ ] arr , int n ) { for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( sum3 [ arr [ i ] ] + " ▁ " ) ; }
int findMinSoln ( int n , int k ) { int minSoln = int . MaxValue ; for ( int i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = Math . Min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; }
int countPairs ( int [ ] a , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; HashSet < int > us = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) us . Add ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . Contains ( x - arr2 [ j ] ) ) count ++ ; return count ; }
void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) Math . Pow ( ( X2 - X1 ) , 2 ) + ( int ) Math . Pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) Math . Pow ( ( X3 - X2 ) , 2 ) + ( int ) Math . Pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) Math . Pow ( ( X3 - X1 ) , 2 ) + ( int ) Math . Pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 && B > 0 && C > 0 ) && ( A == ( B + C ) || B == ( A + C ) || C == ( A + B ) ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int solve ( int [ ] A , int n , int [ ] Q , int q ) { int one = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; int glows = 0 , count = 0 ; if ( one >= ( int ) Math . Ceiling ( ( double ) n / 2 ) ) glows = 1 ; for ( int i = 0 ; i < q ; i ++ ) { int prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= ( int ) Math . Ceiling ( ( double ) n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; }
int numberOfPairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; }
void ans ( int n ) { if ( n == 1 ) Console . WriteLine ( "1" ) ; else Console . WriteLine ( "0" ) ; }
int solve ( int [ ] a , int n ) { int max1 = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . Abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . Abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }
int countPairsBruteForce ( int [ ] X , int [ ] Y , int m , int n ) { int ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( Math . Pow ( X [ i ] , Y [ j ] ) > Math . Pow ( Y [ j ] , X [ i ] ) ) ans ++ ; return ans ; }
void numberOfPermWithKInversion ( int N , int K ) { int [ , ] dp = new int [ 2 , K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 , j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 , j ] = 1 ; else dp [ i % 2 , j ] = ( dp [ i % 2 , j - 1 ] % mod + ( dp [ 1 - i % 2 , j ] - ( ( Math . Max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 , Math . Max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } Console . WriteLine ( dp [ N % 2 , K ] ) ; }
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int findMinDenomin ( int n ) { return ( ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ) ; }
int minCells ( int [ , ] mat , int m , int n ) { int [ , ] dp = new int [ m , n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i , j ] = int . MaxValue ; dp [ 0 , 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i , j ] != int . MaxValue && ( j + mat [ i , j ] ) < n && ( dp [ i , j ] + 1 ) < dp [ i , j + mat [ i , j ] ] ) dp [ i , j + mat [ i , j ] ] = dp [ i , j ] + 1 ; if ( dp [ i , j ] != int . MaxValue && ( i + mat [ i , j ] ) < m && ( dp [ i , j ] + 1 ) < dp [ i + mat [ i , j ] , j ] ) dp [ i + mat [ i , j ] , j ] = dp [ i , j ] + 1 ; } } if ( dp [ m - 1 , n - 1 ] != int . MaxValue ) return dp [ m - 1 , n - 1 ] ; return - 1 ; }
int breakSum ( int n ) { if ( n == 0 n == 1 ) return n ; return Math . Max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }
void mul_table ( int N , int i ) { if ( i > 10 ) return ; Console . WriteLine ( N + " ▁ * ▁ " + i + " ▁ = ▁ " + N * i ) ; mul_table ( N , i + 1 ) ; }
int No_of_Triangle ( int N , int K ) { if ( N < K ) return - 1 ; else { int Tri_up = 0 ; Tri_up = ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ; int Tri_down = 0 ; Tri_down = ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ; return Tri_up + Tri_down ; } }
int countPairs ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; }
int minimum ( int n ) { int product = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
int findValue ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; }
int MaxXOR ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; }
int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( Math . Max ( X , Y ) / Math . Min ( X , Y ) ) ; else return ( Math . Max ( 2 * X , Y ) / Math . Min ( 2 * X , Y ) ) ; }
int maxLength ( int [ ] a , int n ) { int maxLen = 0 ; int prev_cnt = 0 , curr_cnt = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = Math . Max ( maxLen , Math . Min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; }
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; }
int firstDigit ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; }
int Nth_of_AP ( int a , int d , int N ) { return ( a + ( N - 1 ) * d ) ; }
int minproduct ( int [ ] a , int [ ] b , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . Abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
void count_unique ( HashSet < int > s , int n ) { if ( s . Contains ( n ) ) return ; s . Add ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = n / 10 ; } count_unique ( s , n ) ; }
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . Min ( Math . Abs ( input_digit - code_digit ) , 10 - Math . Abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
int minChanges ( int [ ] A , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * ( int ) ( Math . Pow ( 2 , ( r - 2 ) ) ) ; int d = ( int ) ( Math . Pow ( 2 , ( r - 1 ) ) ) ; c = c - r ; int element = a + d * c ; return element ; }
int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
double calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; double sum = Math . Pow ( fibo [ 0 ] , 2 ) + Math . Pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
void PrintMinNumberForPattern ( String seq ) { String result = " " ; Stack stk = new Stack ( ) ; for ( int i = 0 ; i <= seq . Length ; i ++ ) { stk . Push ( i + 1 ) ; if ( i == seq . Length seq [ i ] == ' I ' ) { while ( stk . Count != 0 ) { result += String . Join ( " " , stk . Peek ( ) ) ; result += " ▁ " ; stk . Pop ( ) ; } } } Console . WriteLine ( result ) ; }
void checkPalindrome ( int num ) { String str = num . ToString ( ) ; int l = 0 , r = str . Length - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { Console . Write ( " No " ) ; return ; } l ++ ; r -- ; } Console . Write ( " Yes " ) ; return ; }
void countSubarrays ( int [ ] A , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } Console . Write ( ans + " STRNEWLINE " ) ; }
void findNthNum ( int N ) { int bit_L = 1 , last_num = 0 ; while ( bit_L * ( bit_L + 1 ) / 2 < N ) { last_num = last_num + bit_L ; bit_L ++ ; } int bit_R = N - last_num - 1 ; Console . Write ( ( 1 << bit_L ) + ( 1 << bit_R ) + " STRNEWLINE " ) ; }
int countUnsetBits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp > 0 ) { if ( temp % 2 == 0 ) cnt = cnt + 1 ; temp = temp / 2 ; } } return cnt ; }
int count_elements ( int [ ] arr , int n ) { int count = 1 ; int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; }
int rotate ( int [ ] arr , int N , int X ) { int nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return nextPower - N ; int prevPower = nextPower / 2 ; return 2 * ( N - prevPower ) + 1 ; }
int countX ( int n ) { string binary = Convert . ToString ( n , 2 ) ; int count = 0 ; for ( int i = 0 ; i < binary . Length ; i ++ ) { if ( binary [ i ] == '1' ) count ++ ; } int answer = ( int ) Math . Pow ( 2 , count ) ; return answer ; }
void odd_even ( int [ ] arr , int n ) { List < int > odd_indexes = new List < int > ( ) ; List < int > even_indexes = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . Add ( arr [ i ] ) ; else even_indexes . Add ( arr [ i ] ) ; } odd_indexes . Sort ( ) ; even_indexes . Sort ( ) ; for ( int i = 0 ; i < odd_indexes . Count ; i ++ ) Console . Write ( odd_indexes [ i ] + " ▁ " ) ; for ( int i = 0 ; i < even_indexes . Count ; i ++ ) Console . Write ( even_indexes [ i ] + " ▁ " ) ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
void pendulumArrangement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int [ ] op = new int [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; Console . Write ( " Pendulum ▁ arrangement : " ) ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( op [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; }
void findEquation ( int A , int B , int C , int K ) { Console . Write ( A + " ▁ " + K * B + " ▁ " + K * K * C ) ; }
float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
int get_subset_count ( int [ ] arr , int K , int N ) { Array . Sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; }
void gouldSequence ( int n ) { for ( int row_num = 1 ; row_num <= n ; row_num ++ ) { int count = 1 ; int c = 1 ; for ( int i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } Console . Write ( count + " ▁ " ) ; } }
void printPairs ( int [ ] arr , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) Console . Write ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " STRNEWLINE " ) ; }
void generateString ( int K ) { string s = " " ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + ( char ) ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += ( char ) ( i ) ; s += ( char ) ( j ) ; } } s += ( char ) ( 97 ) ; Console . Write ( s ) ; }
double reuleauxArea ( double a ) { if ( a < 0 ) return - 1 ; double A = 0.70477 * Math . Pow ( a , 2 ) ; return A ; }
int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
void printMaxNumber ( int n ) { if ( n % 2 != 0 ) { Console . Write ( "7" ) ; for ( int i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) Console . Write ( "1" ) ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) Console . Write ( "1" ) ; } }
int evenSum ( int n ) { int curr = 2 , sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
void profitLoss ( int N , int M ) { if ( N == M ) Console . Write ( " No ▁ Profit ▁ nor ▁ Loss " ) ; else { float result = 0 ; result = ( float ) ( Math . Abs ( N - M ) ) / M ; if ( N - M < 0 ) Console . Write ( " Loss ▁ = ▁ - " + result * 100 + " % " ) ; else Console . Write ( " Profit ▁ = ▁ " + result * 100 + " % " ) ; } }
int MaxProfit ( int [ ] treasure , int [ ] color , int n , int k , int col , int A , int B ) { return dp [ k , col ] = 0 ; if ( dp [ k , col ] != - 1 ) return dp [ k , col ] ; int sum = 0 ; if ( col == color [ k ] ) sum += Math . Max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . Max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k , col ] = sum ; }
int breakSum ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . Max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
int countChar ( String str ) { int n = str . Length ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
int firstFactorialDivisibleNumber ( int x ) { int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
int maxSum ( int [ ] arr , int n , int K ) { int maximum = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ; for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . Max ( maximum , sumk ) ; } return maximum ; }
void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) % 2 > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } Console . Write ( " The ▁ number ▁ after ▁ unsetting ▁ the ▁ " ) ; Console . Write ( " rightmost ▁ set ▁ bit ▁ " + n ) ; }
void minBox ( int [ ] arr , int n ) { int box = n ; Array . Sort ( arr ) ; int curr_box = 0 , next_box = 1 ; while ( curr_box < n && next_box < n ) { if ( arr [ curr_box ] < arr [ next_box ] ) { box -- ; curr_box ++ ; next_box ++ ; } else if ( arr [ curr_box ] == arr [ next_box ] ) next_box ++ ; } Console . WriteLine ( box ) ; }
String multiply ( String num1 , String num2 ) { int n1 = num1 . Length ; int n2 = num2 . Length ; if ( n1 == 0 n2 == 0 ) return "0" ; int [ ] result = new int [ n1 + n2 ] ; int i_n1 = 0 ; int i_n2 = 0 ; int i = 0 ; for ( i = n1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n_1 = num1 [ i ] - '0' ; i_n2 = 0 ; for ( int j = n2 - 1 ; j >= 0 ; j -- ) { int n_2 = num2 [ j ] - '0' ; int sum = n_1 * n_2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } i = result . Length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = " " ; while ( i >= 0 ) s += ( result [ i -- ] ) . ToString ( ) ; return s ; }
int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
void findpair ( int l , int r ) { int c = 0 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { Console . Write ( i + " , ▁ " + j ) ; c = 1 ; break ; } } if ( c == 1 ) break ; } }
void ConstArrayAdjacentCoprime ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( i + " ▁ " ) ; } }
void uniqueElement ( int [ ] arr ) { int x = arr [ 0 ] ; int flag = 1 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] != x ) { flag = 0 ; break ; } } if ( flag == 1 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int maxSumLCM ( int n ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
void printTetra ( int n ) { int [ ] dp = new int [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; System . Console . WriteLine ( dp [ n ] ) ; }
void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; Console . WriteLine ( remainder ) ; }
int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
int countTriangles ( int [ ] a , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; }
int firstRepeating ( String str ) { Boolean [ ] visited = new Boolean [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) visited [ i ] = false ; int res = - 1 ; for ( int i = str . Length - 1 ; i >= 0 ; i -- ) { if ( visited [ str [ i ] ] == false ) visited [ str [ i ] ] = true ; else res = i ; } return res ; }
int countReduce ( string str ) { int n = str . Length ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += Math . Abs ( str [ i ] - str [ n - i - 1 ] ) ; return res ; }
int minCost ( int [ ] arr , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . Min ( count_even , count_odd ) ; }
uint swapBitsInPair ( uint x ) { return ( ( x & 010101010 ) >> 1 ) | ( ( x & 001010101 ) << 1 ) ; }
double calculateProbability ( int N ) { double probability = ( double ) N / ( N + 1 ) ; return probability ; }
void printAlter ( int [ ] arr , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { Console . Write ( arr [ currIndex ] + " ▁ " ) ; } } }
int reversDigits ( int num ) { if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
int findMinSum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int minsum = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; }
bool isSpiltPossible ( int n , int [ ] a ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
int countStrings ( int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
float find ( int N , int sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N , sum ] > 0 ) return dp [ N , sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( float ) ( 1.0 / 6 ) ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N , sum ] = dp [ N , sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N , sum ] ; }
int remainder ( string str ) { int len = str . Length ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; }
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
int minCoins ( int [ ] coins , int m , int V ) { int [ ] table = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = int . MaxValue ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != int . MaxValue && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } return table [ V ] ; }
int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
int maxDiffSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int maxVal = arr [ i ] , minVal = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { minVal = Math . Min ( minVal , arr [ j ] ) ; maxVal = Math . Max ( maxVal , arr [ j ] ) ; if ( j - 1 >= 0 ) dp [ i ] = Math . Max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) ; else dp [ i ] = Math . Max ( dp [ i ] , maxVal - minVal ) ; } } return dp [ n - 1 ] ; }
void printMaxActivities ( int [ ] s , int [ ] f , int n ) { int i , j ; Console . Write ( " Following ▁ activities ▁ are ▁ selected ▁ : ▁ " ) ; i = 0 ; Console . Write ( i + " ▁ " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { Console . Write ( j + " ▁ " ) ; i = j ; } } }
int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; }
void findVolume ( double u , double v , double w , double U , double V , double W , double b ) { double uPow = Math . Pow ( u , 2 ) ; double vPow = Math . Pow ( v , 2 ) ; double wPow = Math . Pow ( w , 2 ) ; double UPow = Math . Pow ( U , 2 ) ; double VPow = Math . Pow ( V , 2 ) ; double WPow = Math . Pow ( W , 2 ) ; double a = 4 * ( uPow * vPow * wPow ) - uPow * Math . Pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * Math . Pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * Math . Pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; double vol = Math . Sqrt ( a ) ; vol /= b ; Console . Write ( System . Math . Round ( vol , 4 ) ) ; }
int lenOflongZigZagArr ( int [ ] a , int n ) { int max = 1 , len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && ( a [ i ] < a [ i + 1 ] ) ) len ++ ; else if ( i % 2 == 1 && ( a [ i ] > a [ i + 1 ] ) ) len ++ ; else { if ( max < len ) max = len ; len = 1 ; } } if ( max < len ) max = len ; return max ; }
void lengtang ( double r1 , double r2 ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ " + " direct ▁ common ▁ tangent ▁ is ▁ " + ( 2 * Math . Sqrt ( r1 * r2 ) ) ) ; }
void printMinDiffPairs ( int [ ] arr , int n ) { if ( n <= 1 ) return ; Array . Sort ( arr ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = Math . Min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { Console . Write ( " ▁ ( " + arr [ i - 1 ] + " , ▁ " + arr [ i ] + " ) , ▁ " ) ; } } }
int solve ( int [ ] A , int N ) { int i = 0 ; int k = 0 ; for ( int j = 1 ; j < N ; j ++ ) { int tempK = Math . Min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
int lds ( int [ ] arr , int n ) { int [ ] lds = new int [ n ] ; lds [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lds [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( lds [ j ] != 0 && arr [ i ] % arr [ j ] == 0 ) lds [ i ] = Math . Max ( lds [ i ] , lds [ j ] + 1 ) ; } int max = lds . Max ( ) ; return max ; }
int findCount ( int [ ] arr , int n ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { count ++ ; } else { ans = ans + count ; } } return ans ; }
int count ( int n ) { int [ ] table = new int [ n + 1 ] ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( int i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( int i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
int maximumChars ( string str ) { int n = str . Length ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) res = Math . Max ( res , Math . Abs ( j - i - 1 ) ) ; return res ; }
double octadiagonal ( double a ) { if ( a < 0 ) return - 1 ; return a * Math . Sqrt ( 4 + ( 2 * Math . Sqrt ( 2 ) ) ) ; }
int minOperations ( int N ) { double x = Math . Log ( N , 2 ) ; int ans = ( int ) ( Math . Ceiling ( x ) ) ; return ans ; }
bool checkPalindrome ( string str ) { int n = str . Length ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; }
uint catalanDP ( uint n ) { uint [ ] catalan = new uint [ n + 2 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( uint i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( uint j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
void printsubset ( int n , int k ) { int count = 0 , x = 0 ; List < int > vec = new List < int > ( ) ; while ( n != 0 ) { x = n & 1 ; if ( x != 0 ) { vec . Add ( ( int ) Math . Pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( int i = 0 ; i < vec . Count ; i ++ ) Console . Write ( vec [ i ] + " ▁ " ) ; }
void calcSum ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i <= n - k ; i ++ ) { int sum = 0 ; for ( int j = i ; j < k + i ; j ++ ) sum += arr [ j ] ; Console . Write ( sum + " ▁ " ) ; } }
int splitArray ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int result = Int32 . MaxValue ; for ( int i = 1 ; i < N ; i ++ ) { result = Math . Min ( result , arr [ i ] ^ arr [ i - 1 ] ) ; } return result ; }
int maximumSum ( int [ ] arr , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
bool validate ( long n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long temp = n ; int count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
bool isCenteredheptagonal ( int N ) { double n = ( 7 + Math . Sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return Math . Max ( ct0 , ct1 ) ; }
void countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } Console . WriteLine ( even_sum ) ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
long swapBits ( int x ) { long even_bits = x & 0xAAAAAAAA ; long odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
void reverse ( string str , int x ) { int n = ( str . Length - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( str [ i ] ) ; for ( int i = n + x - 1 ; i >= n ; i -- ) Console . Write ( str [ i ] ) ; for ( int i = n + x ; i < str . Length ; i ++ ) Console . Write ( str [ i ] ) ; }
void findNthTerm ( int n ) { Console . WriteLine ( n * ( 4 * n + 3 ) ) ; }
void maxPairs ( int [ ] nums , int k ) { Array . Sort ( nums ) ; int result = 0 ; int start = 0 , end = nums . Length - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } Console . Write ( result ) ; }
int sumOfProductOfDigits ( int n1 , int n2 ) { int sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 /= 10 ; n2 /= 10 ; } return sum ; }
bool check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; }
float Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 ; double p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return ( float ) sum ; }
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
int minOperations ( int n , int m ) { int a = 0 , k = 1 ; int p = Math . Max ( n , m ) ; while ( n != m ) { float s = ( float ) ( p - n + p - m ) ; float q = ( float ) ( ( - 1 + Math . Sqrt ( 8 * s + 1 ) ) / 2 ) ; if ( q - Math . Floor ( q ) == 0 ) { a = ( int ) q ; n = m ; } p = p + 1 ; } return a ; }
int find_distance ( int n ) { return n * ( ( 3 * n ) + 7 ) ; }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
void countNum ( int N ) { int ans = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) + 1 ; Console . WriteLine ( ans ) ; }
int modInverse ( int a , int m ) { for ( int x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; return 1 ; }
int countIntervals ( int [ , ] arr , int V , int N ) { int min = int . MaxValue , max = int . MinValue ; int li , ri ; int [ ] freq = new int [ MAX_VAL ] ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i , 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i , 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
int numberOf2sinRange ( int n ) { string s = " " ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += i + " " ; int count = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '2' ) { count ++ ; } } return count ; }
void solve ( int i , int par , int [ ] a , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . Min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int min_changes ( int [ ] a , int n ) { int ans_a = 0 , ans_b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] == 0 ) ans_a ++ ; else ans_b ++ ; } else { if ( a [ i ] == 0 ) ans_b ++ ; else ans_a ++ ; } } return Math . Min ( ans_a , ans_b ) ; }
int Preprocess ( string A , string B ) { int n = A . Length ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; if ( mp . ContainsKey ( A [ i ] ) ) mp [ A [ i ] ] ++ ; else mp [ A [ i ] ] = 1 ; if ( mp . ContainsKey ( A [ n - i - 1 ] ) ) mp [ A [ n - i - 1 ] ] ++ ; else mp [ A [ n - i - 1 ] ] = 1 ; if ( mp . ContainsKey ( B [ i ] ) ) mp [ B [ i ] ] ++ ; else mp [ B [ i ] ] = 1 ; if ( mp . ContainsKey ( B [ n - i - 1 ] ) ) mp [ B [ n - i - 1 ] ] ++ ; else mp [ B [ n - i - 1 ] ] = 1 ; int sz = mp . Count ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp [ A [ i ] ] != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A [ n / 2 ] != B [ n / 2 ] ) ans ++ ; return ans ; }
void pattern ( String str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { int j = len - 1 - i ; for ( int k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) Console . Write ( str [ k ] ) ; else Console . Write ( " ▁ " ) ; } Console . WriteLine ( " " ) ; } }
bool isValid ( String str , int n ) { if ( ! ( ( str [ 0 ] >= ' a ' && str [ 0 ] <= ' z ' ) || ( str [ 0 ] >= ' A ' && str [ 0 ] <= ' Z ' ) str [ 0 ] == ' _ ' ) ) return false ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( ! ( ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) || ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= '0' && str [ i ] <= '9' ) str [ i ] == ' _ ' ) ) return false ; } return true ; }
void findMinXORSubarray ( int [ ] arr , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } Console . WriteLine ( min_xor ) ; }
int maximumCount ( int [ ] arr , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) odd ++ ; else even ++ ; } if ( odd != 0 && even != 0 ) return N - 2 ; else return N - 1 ; }
int minOp ( int num ) { int rem ; int count = 0 ; while ( num > 0 ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; }
int min_index ( int [ ] p , int n ) { int ans = 0 ; int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }
float area ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float A = a * b ; return A ; }
double countdigits ( int n , int k ) { if ( n == 0 ) return 0 ; int digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }
int checkpoint ( int h , int k , int x , int y , int a ) { int p = ( int ) Math . Pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
int countPair ( int a , int b ) { String s = String . Join ( " " , b ) ; int i ; for ( i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] != '9' ) break ; } int result ; if ( i == s . Length ) result = a * s . Length ; else result = a * ( s . Length - 1 ) ; return result ; }
void calculateSum ( int n ) { double r = ( n * ( n + 1 ) / 2 + Math . Pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ) ; Console . WriteLine ( " Sum ▁ = ▁ " + r ) ; }
int countRotation ( int n ) { int count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 0 ) count ++ ; n = n / 10 ; } while ( n != 0 ) ; return count ; }
int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ( int ) Math . Ceiling ( Math . Log ( N ) / Math . Log ( 2 ) ) ; }
void lengequichord ( int z ) { Console . WriteLine ( " The ▁ distance ▁ between ▁ the ▁ " + " chord ▁ and ▁ the ▁ center ▁ is ▁ " + z ) ; }
void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } }
int minCount ( int n ) { int [ ] hasharr = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }
void diameter ( double r ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " + " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " + 2 * r ) ; }
int maxAlternatingSum ( int [ ] arr , int n ) { int max_sum = 0 ; int i = 0 ; while ( i < n ) { int current_max = arr [ i ] ; int k = i ; while ( k < n && ( ( arr [ i ] > 0 && arr [ k ] > 0 ) || ( arr [ i ] < 0 && arr [ k ] < 0 ) ) ) { current_max = Math . Max ( current_max , arr [ k ] ) ; k += 1 ; } max_sum += current_max ; i = k ; } return max_sum ; }
void countSubstrings ( string s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; foreach ( char i in s ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } Console . WriteLine ( ans ) ; }
void findMinimum ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 1 ; i < 2 * ( N / K ) ; i += 2 ) { ans += arr [ i ] ; } Console . WriteLine ( ans ) ; }
int TotalAndPair ( int [ ] arr , int N ) { int totalAND = ( 1 << 30 ) - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }
String get_last_two_digit ( int N ) { if ( N % 4 == 0 ) return "01" ; else if ( N % 4 == 1 ) return "07" ; else if ( N % 4 == 2 ) return "49" ; return "43" ; }
void find_sum_of_two_squares ( int a , int b ) { int ab = a * b ; for ( int i = 0 ; i * i <= ab ; i ++ ) { for ( int j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) Console . Write ( i + " ^ 2 ▁ + ▁ " + j + " ^ 2 ▁ = ▁ " + ab + " STRNEWLINE " ) ; } } }
int recLen ( string str ) { if ( str . Equals ( " " ) ) return 0 ; else return recLen ( str . Substring ( 1 ) ) + 1 ; }
int maxValue ( int [ ] a , int n , int pos , int moves , int left , int [ , ] dp ) { if ( moves == 0 || ( pos > n - 1 pos < 0 ) ) return 0 ; if ( dp [ pos , left ] != - 1 ) return dp [ pos , left ] ; int value = 0 ; if ( left > 0 && pos >= 1 ) value = Math . Max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) ; if ( pos <= n - 1 ) value = Math . Max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) ; return dp [ pos , left ] = value ; }
int cal ( int n ) { double res = Math . Pow ( Math . Ceiling ( ( Math . Pow ( Math . Pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return ( int ) res ; }
long findSum ( int n ) { long sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }
void checkTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) Console . WriteLine ( " No " ) ; else Console . WriteLine ( " Yes " ) ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 4 ) return - 1 ; int max_product = int . MinValue ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = Math . Max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
int count ( int n ) { return ( int ) ( 15 * Math . Pow ( 16 , n - 1 ) ) ; }
void anglechordtang ( int z ) { Console . WriteLine ( " The ▁ angle ▁ between ▁ tangent " + " ▁ and ▁ the ▁ chord ▁ is ▁ " + z + " ▁ degrees " ) ; }
int minNum ( int [ ] arr , int n ) { bool odd = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
int findEle ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; }
bool isDivisible ( int [ ] arr , int n ) { int lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; }
void minAND ( int [ ] arr , int n ) { int s = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } System . Console . WriteLine ( s ) ; }
int findLastIndex ( string str , char x ) { for ( int i = str . Length - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return - 1 ; }
int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= ( int ) Math . Sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= ( int ) ( Math . Sqrt ( N - 1 ) ) ; return count_pairs ; }
int getMinOps ( int [ ] arr ) { int res = 0 ; for ( int i = 0 ; i < arr . Length - 1 ; i ++ ) { res += Math . Max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; }
int longestGP ( int [ ] A , int N ) { if ( N < 2 ) return N ; int length = 1 , common_ratio = 1 ; int maxlength = 1 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = Math . Max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = Math . Max ( maxlength , length ) ; length = 1 ; } } maxlength = Math . Max ( maxlength , length ) ; return maxlength ; }
void countSubarrays ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } Console . WriteLine ( count ) ; }
string isTriangleExists ( int a , int b , int c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " YES " ; else return " NO " ; else return " NO " ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
bool isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }
void findNthTerm ( int n ) { Console . Write ( n * ( 3 * n + 1 ) / 2 + " STRNEWLINE " ) ; }
int MinRemove ( int [ ] a , int n , int k ) { int [ ] cnt = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }
int decideWinner ( int [ ] a , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
int remAnagram ( string str1 , string str2 ) { int [ ] count1 = new int [ 26 ] ; int [ ] count2 = new int [ 26 ] ; for ( int i = 0 ; i < str1 . Length ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . Length ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . Abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
void findDistinctOddSum ( int n , int k ) { if ( ( k * k ) <= n && ( n + k ) % 2 == 0 ) { int val = 1 ; int sum = 0 ; for ( int i = 1 ; i < k ; i ++ ) { Console . Write ( val + " ▁ " ) ; sum += val ; val += 2 ; } Console . Write ( n - sum + " STRNEWLINE " ) ; } else Console . Write ( " NO ▁ STRNEWLINE " ) ; }
int minElements ( int [ ] arr , int N , int K ) { int count = 0 ; long requiredNum = 1 ; int i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }
int factorialWithoutMul ( int N ) { int ans = N ; for ( int i = N - 1 ; i > 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; Console . Write ( num + " ▁ " ) ; } }
int sumofsquare ( int n ) { int [ , ] C = new int [ n + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n , i ] * C [ n , i ] ) ; return sum ; }
string findString ( int n , int k ) { string res = " " ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' a ' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
int minimumIncrease ( int a , int b , int c ) { int [ ] arr = { a , b , c } ; Array . Sort ( arr ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
bool sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }
void quadrant ( int x , int y ) { if ( x > 0 && y > 0 ) Console . WriteLine ( " lies ▁ in ▁ First ▁ quadrant " ) ; else if ( x < 0 && y > 0 ) Console . WriteLine ( " lies ▁ in ▁ Second ▁ quadrant " ) ; else if ( x < 0 && y < 0 ) Console . WriteLine ( " lies ▁ in ▁ Third ▁ quadrant " ) ; else if ( x > 0 && y < 0 ) Console . WriteLine ( " lies ▁ in ▁ Fourth ▁ quadrant " ) ; else if ( x == 0 && y > 0 ) Console . WriteLine ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) ; else if ( x == 0 && y < 0 ) Console . WriteLine ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) ; else if ( y == 0 && x < 0 ) Console . WriteLine ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) ; else if ( y == 0 && x > 0 ) Console . WriteLine ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) ; else Console . WriteLine ( " lies ▁ at ▁ origin " ) ; }
int findMax ( int num ) { byte size_of_int = 4 ; int num_copy = num ; int j = size_of_int * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
int toggleBits ( int n1 , int n2 ) { return ( n1 ^ n2 ) ; }
bool check ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; }
int findMaxSoln ( int n , int x , int y ) { int ans = int . MinValue ; for ( int k = 0 ; k <= n ; k ++ ) { if ( k % x == y ) { ans = Math . Max ( ans , k ) ; } } return ( ( ans >= 0 && ans <= n ) ? ans : - 1 ) ; }
int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
bool isFactorion ( int n ) { int [ ] fact = new int [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; }
int getHeight ( int X ) { return ( 2 * X ) ; }
int countTriplets ( int n , int sum ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; }
int findNumberOfStrings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }
int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }
void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; Console . WriteLine ( a + " ▁ " + b + " ▁ " + c ) ; }
int minimumValue ( int N , int K ) { return ( int ) Math . Ceiling ( ( double ) K / ( double ) N ) ; }
int countNumbers ( int l , int r ) { return ( ( r / 2 ) - ( l - 1 ) / 2 ) ; }
int countPaths ( int m , int n ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i , j ] = 1 ; else dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] ; } } return dp [ m , n ] ; }
int MinimumString ( int x ) { int b = 1 ; double left_lim = Math . Sqrt ( x ) + 1.0 ; double right_lim = Math . Sqrt ( x ) + 2.0 ; int r = 0 ; for ( int i = ( int ) left_lim ; i <= right_lim ; i ++ ) { if ( i > left_lim && i < right_lim ) { r = i ; break ; } } return b + r ; }
int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
void compareVal ( double x , double y ) { double a = y * Math . Log ( x ) ; double b = x * Math . Log ( y ) ; if ( a > b ) Console . Write ( x + " ^ " + y + " ▁ > ▁ " + y + " ^ " + x ) ; else if ( a < b ) Console . Write ( x + " ^ " + y + " ▁ < ▁ " + y + " ^ " + x ) ; else if ( a == b ) Console . Write ( x + " ^ " + y + " ▁ = ▁ " + y + " ^ " + x ) ; }
int minOperations ( int [ ] a , int [ ] b , int n ) { int minA = a . Max ( ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = true ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; }
bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
void MinimumMaximumPairs ( int n , int m ) { int max_pairs = ( ( n - m + 1 ) * ( n - m ) ) / 2 ; int min_pairs = m * ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 + ( int ) Math . Ceiling ( ( double ) ( ( n - m ) / ( double ) ( m ) ) ) * ( ( n - m ) % m ) ; Console . WriteLine ( " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " + min_pairs ) ; Console . WriteLine ( " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " + max_pairs ) ; }
int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; }
void noOfArraysPossible ( int N , int M ) { int ans = 1 ; for ( int i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } Console . Write ( ans ) ; }
int numPairs ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; }
int minLength ( String str , int N , String K , int M ) { Stack < char > stackOfChar = new Stack < char > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { stackOfChar . Push ( str [ i ] ) ; if ( stackOfChar . Count >= M ) { String l = " " ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( K [ j ] != stackOfChar . Peek ( ) ) { int f = 0 ; while ( f != l . Length ) { stackOfChar . Push ( l [ f ] ) ; f ++ ; } break ; } else { l = stackOfChar . Peek ( ) + l ; stackOfChar . Pop ( ) ; } } } } return stackOfChar . Count ; }
void compareValues ( int a , int b , int c , int d ) { double log1 = Math . Log10 ( a ) ; double num1 = log1 * b ; double log2 = Math . Log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) Console . WriteLine ( a + " ^ " + b ) ; else Console . WriteLine ( c + " ^ " + d ) ; }
int maxSumWO3Consec ( int [ ] arr , int n ) { int [ ] sum = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . Max ( sum [ 1 ] , Math . Max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . Max ( Math . Max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
int countIslands ( int [ , ] mat , int m , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i , j ] == ' X ' ) { if ( ( i == 0 mat [ i - 1 , j ] == ' O ' ) && ( j == 0 mat [ i , j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; }
void solve ( int [ ] a , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; bool evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; }
void countDecrements ( long [ , ] arr ) { int n = arr . GetLength ( 0 ) ; int m = arr . GetLength ( 1 ) ; int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i , j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i , j ] % 2 ) count_2 ++ ; } } Console . WriteLine ( Math . Min ( count_1 , count_2 ) ) ; }
int count_numbers ( int k , int n , bool flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , false ) + count_numbers ( k , n - 1 , true ) ) ; else return count_numbers ( k , n - 1 , true ) ; }
int countSubset ( int [ ] arr , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int [ , ] t = new int [ n + 1 , sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 , j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i , j ] = t [ i - 1 , j ] ; else { t [ i , j ] = t [ i - 1 , j ] + t [ i - 1 , j - arr [ i - 1 ] ] ; } } } return t [ n , sum ] ; }
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
void findMinXORSubarray ( int [ ] arr , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } Console . Write ( min_xor + " STRNEWLINE " ) ; }
int countStrings ( int N ) { if ( N == 1 ) return 0 ; if ( dp . ContainsKey ( N ) ) return dp [ N ] ; int ret = 0 ; for ( int div = 1 ; div <= Math . Sqrt ( N ) ; div ++ ) { if ( N % div == 0 ) { ret += ( 1 << div ) - countStrings ( div ) ; int div2 = N / div ; if ( div2 != div && div != 1 ) ret += ( 1 << div2 ) - countStrings ( div2 ) ; } } dp [ N ] = ret ; return ret ; }
int countDistinct ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }
int countSubsequences ( int [ ] arr ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
int lastRemaining ( int n , Dictionary < int , int > dp ) { if ( dp . ContainsKey ( n ) ) return dp [ n ] ; if ( n == 1 ) return 1 ; else dp . Add ( n , 2 * ( 1 + n / 2 - lastRemaining ( n / 2 , dp ) ) ) ; return dp [ n ] ; }
bool isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; }
String check ( int [ ] arr , int n ) { Dictionary < int , int > hm = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm . Add ( arr [ i ] , 1 ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( hm . ContainsKey ( arr [ j ] ) ) hm [ arr [ j ] ] ++ ; else hm . Add ( arr [ j ] , 1 ) ; bool flag = false ; foreach ( int k in hm . Values ) { if ( k == 1 ) { flag = true ; break ; } } if ( ! flag ) return " No " ; } hm . Clear ( ) ; } return " Yes " ; }
int findMaximum ( int [ ] arr , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int minNumber ( int [ ] a , int n , int x ) { Array . Sort ( a ) ; int k ; for ( k = 0 ; a [ ( n ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; Array . Sort ( a ) ; } return k ; }
int solution ( int A , int B , int C ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; Array . Sort ( arr ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }
void findXandYwithminABSX_Y ( int N ) { if ( N % 2 == 1 ) { Console . Write ( ( N / 2 ) + " ▁ " + ( N / 2 + 1 ) ) ; } else { Console . Write ( ( N / 2 - 1 ) + " ▁ " + ( N / 2 + 1 ) ) ; } }
> solve ( int n , int [ ] arr ) { string s = " aaa " ; List < string > ans = new List < string > ( ) ; ans . Add ( s ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . Length - 1 >= arr [ i ] ) { char ch = s [ arr [ i ] ] ; if ( ch == ' b ' ) ch = ' a ' ; else ch = ' b ' ; char [ ] chr = s . ToCharArray ( ) ; chr [ arr [ i ] ] = ch ; s = new string ( chr ) ; } ans . Add ( s ) ; } return ans ; }
void sumFib ( int N ) { long num = ( long ) Math . Round ( Math . Pow ( ( Math . Sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / Math . Sqrt ( 5 ) ) ; Console . WriteLine ( num - 1 ) ; }
string sort ( string s ) { char [ ] c = new char [ s . Length + 1 ] ; c = s . ToCharArray ( ) ; Array . Sort ( c ) ; int al_c = 0 , nu_c = 0 ; while ( c [ al_c ] < 97 ) al_c ++ ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] < 97 ) s = s . Substring ( 0 , i ) + c [ nu_c ++ ] + s . Substring ( i + 1 ) ; else s = s . Substring ( 0 , i ) + c [ al_c ++ ] + s . Substring ( i + 1 ) ; } return s ; }
void findPair ( int [ ] arr , int n ) { bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { Console . WriteLine ( arr [ i ] + " ▁ " + arr [ j ] ) ; found = true ; } } } } if ( found == false ) Console . WriteLine ( " Not ▁ exist " ) ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; int sqr ; for ( int i = 4 ; i <= n ; i ++ ) { sqr = ( int ) Math . Sqrt ( i ) ; int best = int . MaxValue ; while ( sqr > 1 ) { if ( i % sqr == 0 ) { best = Math . Min ( best , 1 + dp [ sqr ] ) ; } sqr -- ; } best = Math . Min ( best , 1 + dp [ i - 1 ] ) ; dp [ i ] = best ; } return dp [ n ] ; }
int printMaxAfterRemoval ( String s ) { bool flag = false ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' && flag == false ) { flag = true ; continue ; } else Console . Write ( s [ i ] ) ; } return 0 ; }
int MaxProfit ( int [ ] treasure , int [ ] color , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += Math . Max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . Max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; }
void maxFrequency ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int start = 0 , end = 0 ; int sum = 0 , res = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum += arr [ end ] ; while ( ( end - start + 1 ) * arr [ end ] - sum > K ) { sum -= arr [ start ] ; start ++ ; } res = Math . Max ( res , end - start + 1 ) ; } Console . WriteLine ( res ) ; }
long getcount ( long n , int k ) { long res = ( n >> ( k + 1 ) ) << k ; if ( ( ( n >> k ) & 1 ) != 0 ) res += n & ( ( 1 << k ) - 1 ) ; return res ; }
void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { Console . Write ( " - 1" ) ; return ; } Console . WriteLine ( ( ( a - b ) / 2 ) + " ▁ " + ( ( a + b ) / 2 ) ) ; }
void totalInversions ( int [ ] arr , int K , int N ) { int inv = 0 ; int X = 0 ; int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] && i < j ) inv ++ ; if ( arr [ i ] > arr [ j ] ) X ++ ; } } int totalInv = X * K * ( K - 1 ) / 2 + inv * K ; Console . WriteLine ( totalInv ) ; }
void EvenLIS ( int [ ] arr ) { int n = arr . Length ; int [ ] lis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( Math . Abs ( arr [ i ] ) > Math . Abs ( arr [ j ] ) && Math . Abs ( arr [ i ] ) % 2 == 0 && Math . Abs ( arr [ j ] ) % 2 == 0 && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxlen = Math . Max ( maxlen , lis [ i ] ) ; Console . WriteLine ( maxlen ) ; }
int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
int noOfWays ( int N , int K ) { string S = N . ToString ( ) ; int ans = 1 ; for ( int i = 1 ; i < S . Length ; i ++ ) { int count = 1 ; while ( i < S . Length && ( int ) S [ i ] - 48 + ( int ) S [ i - 1 ] - 48 == K ) { count ++ ; i ++ ; } if ( count % 2 == 1 ) ans *= ( count + 1 ) / 2 ; } return ans ; }
double polygonArea ( double [ ] X , double [ ] Y , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . Abs ( area / 2.0 ) ; }
double find_area ( int r , int d ) { double R = d / PI ; R += Math . Pow ( r , 2 ) ; R = Math . Sqrt ( R ) ; double area = PI * Math . Pow ( R , 2 ) ; return area ; }
int GetMinSubarrayLength ( int [ ] a , int n ) { int ans = Math . Max ( a [ 0 ] , a [ n - 1 ] ) ; int lo = 0 , hi = n - 1 ; while ( lo < n && a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo && a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }
int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }
int bitwiseAndOdd ( int n ) { return 1 ; }
bool isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; }
void getSum ( int n ) { bool isOdd = ( n % 2 == 1 ) ? true : false ; int sumOdd = 0 , sumEven = 0 ; while ( n != 0 ) { if ( isOdd ) sumOdd += n % 10 ; else sumEven += n % 10 ; isOdd = ! isOdd ; n /= 10 ; } Console . WriteLine ( " Sum ▁ odd ▁ = ▁ " + sumOdd ) ; Console . Write ( " Sum ▁ even ▁ = ▁ " + sumEven ) ; }
void minCost ( int [ ] arr , int n ) { if ( n < 3 ) { Console . WriteLine ( arr [ 0 ] ) ; return ; } int [ ] dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . Min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . Min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; Console . WriteLine ( dp [ n - 1 ] ) ; }
int maxSum ( int [ ] arr , int n ) { int sum = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
int getMaxDifference ( int N ) { int M = - 1 ; int maxDiff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }
void maxDivisions ( int [ ] arr , int N , int X ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } Console . WriteLine ( maxSub ) ; }
long findNewString ( String s ) { long ans = 0 ; int [ ] freq = new int [ 26 ] ; int n = s . Length ; for ( int i = 0 ; i < ( int ) s . Length ; ++ i ) { ans += freq [ s [ i ] - ' a ' ] ; freq [ s [ i ] - ' a ' ] ++ ; } return ans ; }
int maxLines ( int n , int [ ] x1 , int [ ] y1 , int [ ] x2 , int [ ] y2 ) { HashSet < Double > s = new HashSet < Double > ( ) ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = int . MaxValue ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . Add ( slope ) ; } return s . Count ; }
int sumOddFibonacci ( int n ) { int [ ] Sum = new int [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }
int patternCount ( String str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . Length ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; }
void maxNumTrailNine ( int n , int d ) { int res = n ; int cntDigits = ( int ) Math . Log10 ( n ) + 1 ; int p10 = 10 ; for ( int i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } Console . WriteLine ( res ) ; }
int longestsubarray ( int [ ] arr , int n , int k ) { int current_count = 0 ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . Max ( current_count , max_count ) ; } return max_count ; }
int maxSubArraySum ( int [ ] a ) { int size = a . Length ; int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int subtractOne ( int x ) { int m = 1 ; while ( ! ( ( x & m ) > 0 ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
void findWinner ( int n , int m ) { int X = 0 ; int Y = 0 ; if ( n >= m ) { X = n - 1 ; Y = m ; } else { X = m - 1 ; Y = n ; } if ( X > Y ) Console . Write ( " X " ) ; else if ( Y > X ) Console . Write ( " Y " ) ; else Console . Write ( " - 1" ) ; }
bool isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; }
int cntSubSeq ( int [ ] arr , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . Pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= ( int ) Math . Pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }
void printKPFNums ( int A , int B , int K ) { bool [ ] prime = new bool [ B + 1 ] ; for ( int i = 0 ; i < B + 1 ; i ++ ) prime [ i ] = true ; int [ ] p_factors = new int [ B + 1 ] ; for ( int i = 0 ; i < B + 1 ; i ++ ) p_factors [ i ] = 0 ; for ( int p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( int i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( int i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) Console . Write ( i + " ▁ " ) ; }
bool isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
long count_Strings ( long n ) { int x = 1 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( 1 << x ) ; } return x - 1 ; }
int solve ( int x ) { int ans = 0 , first = 0 , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x != 0 ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; }
float findProb ( int l , int r ) { float countOfPS = ( float ) ( Math . Floor ( Math . Sqrt ( r ) ) - Math . Ceiling ( Math . Sqrt ( l ) ) + 1 ) ; float total = r - l + 1 ; float prob = ( float ) countOfPS / ( float ) total ; return prob ; }
void countNums ( int N ) { int l = ( int ) Math . Pow ( 10 , N - 1 ) , r = ( int ) Math . Pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int xor = 0 , temp = i ; while ( temp > 0 ) { xor = xor ^ ( temp % 10 ) ; temp /= 10 ; } if ( xor <= 9 ) count ++ ; } Console . WriteLine ( count ) ; }
bool check ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { return true ; } } return false ; }
int find ( int [ ] a , int [ ] b , int k , int n1 , int n2 ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . Add ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! s . Contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
int countStrings ( int n , int m , String [ ] s ) { HashSet < int > ind = new HashSet < int > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . Max ( mx , ( int ) ( s [ i ] [ j ] - '0' ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] - '0' == mx ) ind . Add ( i ) ; } return ind . Count ; }
void sumFib ( int N ) { double num = ( 1 - Math . Sqrt ( 5 ) ) / 2 ; double val = Math . Round ( Math . Abs ( 1 / ( Math . Pow ( num , N + 2 ) + Math . Pow ( num , N + 1 ) + Math . Pow ( num , N ) + Math . Pow ( num , N - 1 ) ) ) - 1 ) ; Console . WriteLine ( val ) ; }
void sortarray ( int [ ] arr , int N ) { if ( N == 3 ) Console . WriteLine ( " NO " ) ; else if ( N % 4 == 0 N % 4 == 1 ) { Console . WriteLine ( " YES " ) ; Console . WriteLine ( N / 2 ) ; int k = 1 ; for ( int l = 0 ; l < ( N / 4 ) ; l ++ ) { Console . WriteLine ( k + " ▁ " + ( k + 1 ) + " ▁ " + N ) ; Console . WriteLine ( k + 1 + " ▁ " + N + " ▁ " + ( N - 1 ) ) ; k = k + 2 ; N = N - 2 ; } } else Console . WriteLine ( " NO " ) ; }
int minimumSets ( int [ ] arr , int n , int key ) { int i , j ; Array . Sort ( arr ) ; for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; }
int countNum ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; int count = 0 , maxm = int . MinValue , minm = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { s . Add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( ! s . Contains ( i ) ) count ++ ; return count ; }
int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
int minSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . Min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . Min ( arr [ 0 ] , Math . Min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . Min ( Math . Min ( arr [ 0 ] , arr [ 1 ] ) , Math . Min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . Min ( Math . Min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . Min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . Min ( Math . Min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . Min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
int isSubstring ( string s1 , string s2 ) { int M = s1 . Length ; int N = s2 . Length ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return - 1 ; }
bool canConvert ( string str1 , string str2 ) { int i = 0 , j = 0 ; while ( i < str1 . Length && j < str2 . Length ) { if ( str1 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == '0' && str2 [ j ] == '1' && i + 1 < str1 . Length && str1 [ i + 1 ] == '0' ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i == str1 . Length && j == str2 . Length ) return true ; return false ; }
void missing4 ( int [ ] arr ) { int [ ] helper = new int [ 4 ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) { int temp = Math . Abs ( arr [ i ] ) ; if ( temp <= arr . Length ) arr [ temp - 1 ] *= ( - 1 ) ; else if ( temp > arr . Length ) { if ( temp % arr . Length != 0 ) helper [ temp % arr . Length - 1 ] = - 1 ; else helper [ ( temp % arr . Length ) + arr . Length - 1 ] = - 1 ; } } for ( int i = 0 ; i < arr . Length ; i ++ ) if ( arr [ i ] > 0 ) Console . Write ( i + 1 + " ▁ " ) ; for ( int i = 0 ; i < helper . Length ; i ++ ) if ( helper [ i ] >= 0 ) Console . Write ( arr . Length + i + 1 + " ▁ " ) ; return ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + 4 * n - 2 ; }
long removeElements ( long [ ] arr , int n ) { Array . Sort ( arr ) ; arr = reverse ( arr ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( long ) ( arr [ i ] * Math . Pow ( 2 , i ) ) ; } return ans ; }
int smallestNth ( int A , int B , int N ) { int res = Int32 . MaxValue ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { int D = ( B - A ) / ( j - i ) ; int FirstTerm = A - ( i - 1 ) * D ; int NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = Math . Min ( res , NthTerm ) ; } } } return res ; }
void farthestCellDistance ( int N , int M , int R , int C ) { int d1 = N + M - R - C ; int d2 = R + C - 2 ; int d3 = N - R + C - 1 ; int d4 = M - C + R - 1 ; int maxDistance = Math . Max ( d1 , Math . Max ( d2 , Math . Max ( d3 , d4 ) ) ) ; Console . WriteLine ( maxDistance ) ; }
int ConcatenateArr ( int [ ] arr , int N ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { int l = ( int ) Math . Floor ( Math . Log10 ( arr [ i ] ) + 1 ) ; ans = ans * ( int ) Math . Pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }
void findMajority ( int [ ] arr , int n ) { int len = 32 ; int number = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int countt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countt ++ ; } if ( countt > ( n / 2 ) ) number += ( 1 << i ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > ( n / 2 ) ) Console . Write ( number ) ; else Console . Write ( " Majority ▁ Element ▁ Not ▁ Present " ) ; }
bool checkExists ( int [ ] arr , int N , int M , int K ) { int count = 0 ; for ( int i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; }
void AlternateRearrange ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % 2 == 0 ) v1 . Add ( arr [ j ] ) ; else v2 . Add ( arr [ j ] ) ; int index = 0 , i = 0 , k = 0 ; bool flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ] = ( int ) v1 [ i ] ; i += 1 ; index += 1 ; flag = ! flag ; } else { arr [ index ] = ( int ) v2 [ k ] ; k += 1 ; index += 1 ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; }
void findSubarrays ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int i = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { Console . WriteLine ( " YES " ) ; return ; } } Console . WriteLine ( " NO " ) ; }
double calculateSum ( double n ) { return 2 * ( Math . Pow ( n , 6 ) + 15 * Math . Pow ( n , 4 ) + 15 * Math . Pow ( n , 2 ) + 1 ) ; }
int count_minimum_operations ( long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
int ceilSearch ( int [ ] arr , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
void sameProductQuadruples ( int [ ] nums , int N ) { int [ ] umap = new int [ 10000 ] ; int res = 0 ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = i + 1 ; j < N ; ++ j ) { int prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } Console . Write ( res ) ; }
int countTriplets ( int [ ] A , int N ) { int ans = 0 ; Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int j = N - 2 ; j >= 1 ; j -- ) { if ( map . ContainsKey ( A [ j + 1 ] ) ) map [ A [ j + 1 ] ] = map [ A [ j + 1 ] ] + 1 ; else map . Add ( A [ j + 1 ] , 1 ) ; for ( int i = 0 ; i < j ; i ++ ) { int target = A [ i ] * A [ j ] ; if ( map . ContainsKey ( target ) ) ans += map [ target ] ; } } return ans ; }
int findIndex ( int [ ] a , int n ) { int res = 0 ; long min_diff = Int64 . MaxValue ; long [ ] prod = new long [ n ] ; prod [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long curr_diff = Math . Abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
bool check ( string str ) { int n = str . Length ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ; else evenDigSum += ( str [ i ] - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
int avg_of_even_num ( int n ) { return n + 1 ; }
int evenbitsetnumber ( int n ) { int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
int totalCircles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; }
int repeatingElement ( int [ ] arr , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = Math . Max ( M , arr [ i ] ) ; } int sum1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum1 ) / ( N - M ) ; return ans ; }
void RearrangePosNeg ( int [ ] arr ) { int i = 0 ; int j = arr . Length - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < arr . Length ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } }
int sum_of_4_squares ( int n ) { int i , odd = 0 , even = 0 ; for ( i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }
int Total_Ways ( int n ) { int fac = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) { fac = fac * i ; } return ( fac * 2 ) ; }
void check ( int n ) { if ( ( n & n - 1 ) != 0 ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
int countSubsets ( int [ ] a , int n ) { int answer = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int bitwiseAND = - 1 ; int bitwiseOR = 0 ; int bitwiseXOR = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) == 0 ) { if ( bitwiseAND == - 1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }
void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
void countTotalFrequencies ( string S1 , string S2 ) { HashSet < char > bset = new HashSet < char > ( ) ; foreach ( char x in S1 ) bset . Add ( x ) ; int count = 0 ; foreach ( char x in S2 ) { if ( bset . Contains ( x ) ) count += 1 ; } Console . Write ( count ) ; }
int sum ( int k , int n ) { int sum = ( int ) ( Math . Pow ( k , n + 1 ) - Math . Pow ( k - 1 , n + 1 ) ) ; return sum ; }
int minSumPath ( ref List < List < int > > A ) { int [ ] memo = new int [ A . Count ] ; int n = A . Count - 1 ; for ( int i = 0 ; i < A [ n ] . Count ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . Count - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i + 1 ] . Count - 1 ; j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . Min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
float cyl ( float R ) { if ( R < 0 ) return - 1 ; float V = ( float ) ( ( 2 * 3.14 * Math . Pow ( R , 3 ) ) / ( 3 * Math . Sqrt ( 3 ) ) ) ; return V ; }
void differentStrings ( string s ) { int n = s . Length ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] && ( s [ i ] == '1' s [ i ] == '2' ) ) dp [ i + 1 ] = dp [ i ] + dp [ i - 1 ] ; else dp [ i + 1 ] = dp [ i ] ; } Console . Write ( dp [ n ] ) ; }
String removeRecurringDigits ( char [ ] num ) { int len = num . Length ; String s = " " ; for ( int i = 0 ; i < len ; i ++ ) { s += String . Join ( " " , num [ i ] ) ; while ( i + 1 < len && num [ i ] == num [ i + 1 ] ) { i ++ ; } } return s ; }
int countSubSeq ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { count ++ ; } } return ( int ) ( Math . Pow ( 2 , count ) - 1 ) ; }
void cntWaysConsArray ( int [ ] A , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } Console . WriteLine ( total - oddArray ) ; }
int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }
int maxModulosum ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; }
void findAllTriplets ( int [ ] arr , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { Console . WriteLine ( arr [ j ] + " ▁ " + arr [ i ] + " ▁ " + arr [ k ] ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }
int countSubArrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
void countNums ( int N ) { int [ , ] dp = new int [ N , 16 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 0 , i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 16 ; k ++ ) { int xor = j ^ k ; dp [ i , xor ] += dp [ i - 1 , k ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 , i ] ; Console . Write ( count ) ; }
int maximumAND ( int L , int R ) { return R ; }
bool isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . Abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
int countOccurrences ( int N , int X ) { int count = 0 ; for ( int i = 1 ; i < Math . Sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { int a = i ; int b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; }
int maxValue ( int n ) { return n ; }
void printChar ( String str , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { Console . Write ( str [ i ] ) ; } } }
bool findTriplet ( int [ ] a1 , int [ ] a2 , int [ ] a3 , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return 1 ; }
void PrintIndexes ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int currSubSum = 0 ; for ( int j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; int sq = ( int ) Math . Sqrt ( currSubSum ) ; if ( sq * sq == currSubSum ) { Console . Write ( " ( " + i + " , " + j + " ) " + " ▁ " ) ; } } } }
double calculateSide ( double n , double r ) { double theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return Math . Round ( 2 * r * Math . Sin ( theta_in_radians / 2 ) , 4 ) ; }
long calculate ( long p , long q ) { long mod = 998244353 , expo ; expo = mod - 2 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { p = ( p * q ) % mod ; } q = ( q * q ) % mod ; expo >>= 1 ; } return p ; }
int countCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
void find_numbers ( int N ) { if ( N == 1 ) { Console . Write ( - 1 ) ; } else { Console . Write ( N + " ▁ " + ( N + 1 ) + " ▁ " + ( N * ( N + 1 ) ) ) ; } }
int countWays ( int A , int B , int C ) { int minAddA = Math . Max ( 0 , ( C + B - A + 2 ) / 2 ) ; int count_ways = Math . Max ( C - minAddA + 1 , 0 ) ; return count_ways ; }
char getChar ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { sum += ( str [ i ] - ' a ' + 1 ) ; } if ( sum % 26 == 0 ) return ' z ' ; else { sum = sum % 26 ; return ( char ) ( ' a ' + sum - 1 ) ; } }
void countFreq ( int [ ] a , int n ) { int [ ] hm = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { Console . WriteLine ( a [ i ] + " - > " + cumul ) ; } hm [ a [ i ] ] = 0 ; } }
int KvisibleFromLeft ( int N , int K ) { if ( dp [ N , K ] != - 1 ) return dp [ N , K ] ; if ( N == K ) return dp [ N , K ] = 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return dp [ N , K ] = ans ; } return dp [ N , K ] = KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
char findProffesion ( int level , int pos ) { if ( level == 1 ) return ' e ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' d ' ) return ( pos % 2 > 0 ) ? ' d ' : ' e ' ; return ( pos % 2 > 0 ) ? ' e ' : ' d ' ; }
void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; Console . WriteLine ( " x2 ▁ = ▁ " + x2 + " , ▁ " + " y2 ▁ = ▁ " + y2 ) ; }
void sub_segments ( String str , int n ) { int l = str . Length ; for ( int x = 0 ; x < l ; x += n ) { String newlist = str . Substring ( x , n ) ; List < char > arr = new List < char > ( ) ; foreach ( char y in newlist . ToCharArray ( ) ) { if ( ! arr . Contains ( y ) ) arr . Add ( y ) ; } foreach ( char y in arr ) Console . Write ( y ) ; Console . WriteLine ( ) ; } }
float rmsValue ( int [ ] arr , int n ) { int square = 0 ; float mean = 0 ; float root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { square += ( int ) Math . Pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = ( float ) Math . Sqrt ( mean ) ; return root ; }
int LongestOddEvenSubarray ( int [ ] A , int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) ans = Math . Max ( ans , dp [ i ] ) ; return ans ; }
double increaseInVol ( double l , double b , double h ) { double percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; }
void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
void countXorPartition ( int N ) { double a = Math . Pow ( 2 , ( int ) ( N - Math . Log ( N + 1 ) / Math . Log ( 2 ) ) ) ; Console . Write ( a ) ; }
void angleequichord ( int z ) { Console . WriteLine ( " The ▁ angle ▁ subtended ▁ at ▁ the ▁ center ▁ is ▁ " + z + " ▁ degrees " ) ; }
void largestSquare ( int [ , ] matrix , int R , int C , int [ ] q_i , int [ ] q_j , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . Min ( Math . Min ( i , j ) , Math . Min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row , col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } Console . Write ( ans + " STRNEWLINE " ) ; } }
int count ( int [ ] S , int m , int n ) { int [ ] table = new int [ n + 1 ] ; table [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }
int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * ( int ) Math . Pow ( 10 , n / 2 - 1 ) ) ; }
int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; }
void printTrib ( int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( dp [ i ] + " ▁ " ) ; }
void countSubarrays ( int [ ] a , int n , int k ) { int ans = 0 ; List < int > pref = new List < int > ( ) ; pref . Add ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . Add ( ( a [ i ] + pref [ i ] ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } Console . WriteLine ( ans ) ; }
int SquareCube ( long N ) { int cnt = 0 , i = 1 ; while ( ( int ) ( Math . Pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
void prevGreater ( int [ ] arr , int n ) { Console . Write ( " - 1 , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { Console . Write ( arr [ j ] + " , ▁ " ) ; break ; } } if ( j == - 1 ) Console . Write ( " - 1 , ▁ " ) ; } }
int count ( int n ) { return ( int ) Math . Pow ( 2 , n - 1 ) ; }
void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= Math . Pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= Math . Pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; Console . WriteLine ( count + " ▁ " + i ) ; } i ++ ; } }
int evenSum ( int n ) { int [ , ] C = new int [ n + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n , i ] ; return sum ; }
String reversingString ( char [ ] str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return String . Join ( " " , str ) ; }
double hexagonArea ( double s ) { return ( ( 3 * Math . Sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
void findMinimumCost ( String s , int N ) { int count_1 = 0 , count_0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) count_1 ++ ; else count_0 ++ ; } int k = Math . Abs ( count_0 - count_1 ) ; if ( count_1 == N count_0 == N ) Console . WriteLine ( - 1 ) ; else Console . WriteLine ( k / 2 ) ; }
int xorPairCount ( int [ ] arr , int n , int x ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . ContainsKey ( curr_xor ) ) result += m [ curr_xor ] ; if ( m . ContainsKey ( arr [ i ] ) ) { var val = m [ arr [ i ] ] ; m . Remove ( arr [ i ] ) ; m . Add ( arr [ i ] , val + 1 ) ; } else { m . Add ( arr [ i ] , 1 ) ; } } return result ; }
bool isReversible ( string str ) { int i = 0 , j = str . Length - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) { return false ; } i ++ ; j -- ; } return true ; }
int CountCharacters ( String str , int k ) { int cnt = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( ( int ) str [ i ] ) < k ) cnt ++ ; } return cnt ; }
int xorOfArray ( int [ ] arr , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }
void lengthOfTangent ( double r1 , double r2 , double d ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ transverse " + " ▁ common ▁ tangent ▁ is ▁ " + Math . Sqrt ( Math . Pow ( d , 2 ) - Math . Pow ( ( r1 + r2 ) , 2 ) ) ) ; }
int findNthNumber ( int A , int B , int N ) { int sum = 0 ; for ( int i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }
void calculate ( int [ ] a , int [ ] b , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . Floor ( ( double ) ( a [ i ] / mul ) ) ; Console . Write ( x + " ▁ " ) ; } }
int maxScore ( string s , int [ ] a ) { if ( dp . ContainsKey ( s ) ) return dp [ s ] ; int n = s . Length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int head = 0 ; int mx = - 1 ; while ( head < n ) { int tail = head ; while ( tail < n ) { if ( s [ tail ] != s [ head ] ) { head = tail ; break ; } string sub = s . Substring ( head , tail + 1 - head ) ; mx = Math . Max ( mx , a [ sub . Length - 1 ] + maxScore ( s . Substring ( 0 , head ) + s . Substring ( tail + 1 , s . Length - tail - 1 ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp . Add ( s , mx ) ; return mx ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int getIndexInSortedArray ( int [ ] arr , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
int minimumCostOfBreaking ( int [ ] X , int [ ] Y , int m , int n ) { int res = 0 ; Array . Sort < int > ( X , new Comparison < int > ( ( i1 , i2 ) => i2 . CompareTo ( i1 ) ) ) ; Array . Sort < int > ( Y , new Comparison < int > ( ( i1 , i2 ) => i2 . CompareTo ( i1 ) ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
bool isUndulating ( string n ) { if ( n . Length <= 2 ) return false ; for ( int i = 2 ; i < n . Length ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) return false ; return true ; }
void selectionSort ( node head ) { node temp = head ; while ( temp ) { node min = temp ; node r = temp . next ; while ( r ) { if ( min . data > r . data ) min = r ; r = r . next ; } int x = temp . data ; temp . data = min . data ; min . data = x ; temp = temp . next ; } }
int NumberOfways ( int N , int K ) { int [ ] dp = new int [ ( N + 1 ) ] ; dp [ 0 ] = 1 ; for ( int row = 1 ; row < K + 1 ; row ++ ) { for ( int col = 1 ; col < N + 1 ; col ++ ) { if ( col >= row ) dp [ col ] = dp [ col ] + dp [ col - row ] ; } } return ( dp [ N ] ) ; }
int minCapacity ( int [ ] enter , int [ ] exit , int n ) { int minCap = 0 ; int currCap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = Math . Max ( minCap , currCap ) ; } return minCap ; }
int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; }
void anglequichord ( int z ) { Console . WriteLine ( " The ▁ angle ▁ is ▁ " + z + " ▁ degrees " ) ; }
void findNumbers ( int N ) { for ( int i = 1 ; i <= ( N / 2 ) ; i ++ ) { Console . Write ( i + " , ▁ " + - i + " , ▁ " ) ; } if ( N % 2 == 1 ) Console . Write ( 0 ) ; }
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + Math . Sqrt ( 2 ) ) * side * side ) ; }
int minimumCost ( int [ ] cost , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . Min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . Min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
void FirstAndLast ( string str ) { int i ; for ( i = 0 ; i < str . Length ; i ++ ) { if ( i == 0 ) Console . Write ( str [ i ] ) ; if ( i == str . Length - 1 ) Console . Write ( str [ i ] ) ; if ( str [ i ] == ' ▁ ' ) { Console . Write ( str [ i - 1 ] + " ▁ " + str [ i + 1 ] ) ; } } }
int findMin ( int N ) { int digit = N % 10 ; switch ( digit ) { case 0 : if ( N >= 90 ) return 10 ; break ; case 1 : if ( N >= 81 ) return 9 ; break ; case 2 : if ( N >= 72 ) return 8 ; break ; case 3 : if ( N >= 63 ) return 7 ; break ; case 4 : if ( N >= 54 ) return 6 ; break ; case 5 : if ( N >= 45 ) return 5 ; break ; case 6 : if ( N >= 36 ) return 4 ; break ; case 7 : if ( N >= 27 ) return 3 ; break ; case 8 : if ( N >= 18 ) return 2 ; break ; case 9 : if ( N >= 9 ) return 1 ; break ; } return - 1 ; }
string nthprimedigitsnumber ( int number ) { int rem ; string num = " " ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += '2' ; break ; case 2 : num += '3' ; break ; case 3 : num += '5' ; break ; case 0 : num += '7' ; break ; } if ( number % 4 == 0 ) number -- ; number = number / 4 ; } char [ ] st = num . ToCharArray ( ) ; Array . Reverse ( st ) ; return new string ( st ) ; }
int maxiConsecutiveSubarray ( int [ ] arr , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . Max ( maxi , cnt ) ; i = j ; } return maxi ; }
void factors ( int n ) { int i , j ; Console . Write ( "1 ▁ - - > 1 STRNEWLINE " ) ; for ( i = 2 ; i <= n ; i ++ ) { Console . Write ( i + " ▁ - - > " ) ; for ( j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { Console . Write ( j + " , ▁ " ) ; if ( i / j != j ) Console . Write ( i / j + " , ▁ " ) ; } } Console . Write ( " STRNEWLINE " ) ; } }
int countOnes ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Array . Sort ( dis ) ; return dis [ k - 1 ] ; }
void findPhoneNumber ( int n ) { int temp = n ; int sum = 0 ; while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; } if ( sum < 10 ) Console . Write ( n + "0" + sum ) ; else Console . Write ( n + " " + sum ) ; }
int complement ( int num ) { int len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = num / 10 ; if ( Math . Abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . Pow ( 10 , len ) - num ; return comp ; }
int minLength ( string s ) { int i = 0 , j = s . Length - 1 ; for ( ; i < j && s [ i ] == s [ j ] ; ) { char d = s [ i ] ; while ( i <= j && s [ i ] == d ) i ++ ; while ( i <= j && s [ j ] == d ) j -- ; } return j - i + 1 ; }
int findXORS ( int [ ] arr1 , int [ ] arr2 , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int temp = arr1 [ i ] & arr2 [ j ] ; res ^= temp ; } } return res ; }
int findSmallest ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; }
void BalanceArray ( int [ ] A , int [ , ] Q ) { int [ ] ANS = new int [ A . Length ] ; int i , sum = 0 ; for ( i = 0 ; i < A . Length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . GetLength ( 0 ) ; i ++ ) { int index = Q [ i , 0 ] ; int value = Q [ i , 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS [ i ] = sum ; } for ( i = 0 ; i < ANS . Length ; i ++ ) Console . Write ( ANS [ i ] + " ▁ " ) ; }
void findMin ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; Array . Sort ( arr ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = ( num / d ) + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } Console . WriteLine ( sum - max ) ; }
int findLargestd ( int [ ] S , int n ) { bool found = false ; Array . Sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return int . MaxValue ; return - 1 ; }
int MinDistK ( int [ ] arr , int N , int K ) { int res = Int32 . MaxValue ; int dist = 0 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = Math . Max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = Math . Abs ( arr [ i ] ) + Math . Abs ( arr [ i + K - 1 ] ) + Math . Min ( Math . Abs ( arr [ i ] ) , Math . Abs ( arr [ i + K - 1 ] ) ) ; } res = Math . Min ( res , dist ) ; } return res ; }
String repeat ( String s , int n ) { String s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }
int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
int LCSubStr ( string s , string t , int n , int m ) { int [ , ] dp = new int [ 2 , m + 1 ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) { dp [ i % 2 , j ] = dp [ ( i - 1 ) % 2 , j - 1 ] + 1 ; if ( dp [ i % 2 , j ] > res ) res = dp [ i % 2 , j ] ; } else dp [ i % 2 , j ] = 0 ; } } return res ; }
bool checkIfDivisible ( String str , long num ) { long powerOf2 = ( int ) ( Math . Log ( num ) / Math . Log ( 2 ) ) ; if ( str . Length < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; long i , number = 0 ; int len = str . Length ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( long ) ( ( str [ ( int ) i ] - '0' ) * Math . Pow ( 10 , powerOf2 - 1 ) ) ; powerOf2 -- ; } if ( number % num != 0 ) return false ; else return true ; }
bool isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( Math . Abs ( Sx - Dx ) % x == 0 && Math . Abs ( Sy - Dy ) % y == 0 && ( Math . Abs ( Sx - Dx ) / x ) % 2 == ( Math . Abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
void checkSumOfNatural ( int n ) { int i = 1 ; bool flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = ( int ) Math . Sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
void maximumSubsequenceSum ( int [ ] A , int N ) { int ans = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( A [ i ] - i ) ) mp [ A [ i ] - i ] += A [ i ] ; else mp [ A [ i ] - i ] = A [ i ] ; ans = Math . Max ( ans , mp [ A [ i ] - i ] ) ; } Console . Write ( ans ) ; }
void solve ( int N ) { if ( N % 2 == 0 ) { Console . Write ( N / 2 + " ▁ " + N + " STRNEWLINE " ) ; } else { Console . Write ( ( N - 1 ) / 2 + " ▁ " + ( N - 1 ) + " STRNEWLINE " ) ; } }
int find ( int start , string adj , int n , int [ ] dp ) { if ( start == n ) return 0 ; if ( dp [ start ] != - 1 ) return dp [ start ] ; dp [ start ] = 0 ; int one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj [ k ] == '1' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = Math . Max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = Math . Max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; }
int countSubStr ( string str , int n ) { int len = str . Length ; return ( len - n + 1 ) ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; return dp [ i , curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; }
int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = int . MaxValue ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { int x = Math . Abs ( i - A ) ; int y = Math . Abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
double kthRoot ( double n , int k ) { return Math . Pow ( k , ( ( 1.0 / k ) * ( Math . Log ( n ) / Math . Log ( k ) ) ) ) ; }
int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
void IsEvenPath ( int [ ] Source , int [ ] Destination ) { int x_dif = Math . Abs ( Source [ 0 ] - Destination [ 0 ] ) ; int y_dif = Math . Abs ( Source [ 1 ] - Destination [ 1 ] ) ; int minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int minimumX ( int n , int k ) { int ans = int . MaxValue ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . Min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
int printMinimumProduct ( int [ ] arr , int n ) { int first_min = Math . Min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = Math . Max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
bool isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return true ; return false ; }
void getmax ( int [ ] arr , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } Console . WriteLine ( Math . Min ( s , x ) ) ; }
void findSum ( int N , int K ) { int ans = 0 ; int i = 1 ; while ( i <= N ) { ans += N / i ; i = i * K ; } Console . Write ( ans ) ; }
float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int countPairs ( int [ ] A , int n , int k ) { int ans = 0 ; Array . Sort ( A ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * Math . Pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . Pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
int find_max ( int n , int k ) { int [ ] X = new int [ 32 ] ; int cnt = 0 ; for ( int i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { X [ i ] = 1 ; cnt ++ ; } } String s = " " ; for ( int i = 31 ; i >= 0 ; i -- ) s += X [ i ] == 0 ? '0' : '1' ; return Convert . ToInt32 ( s , 2 ) ; }
void mergeTwoHalf ( int [ ] A , int n ) { Array . Sort ( A ) ; }
bool isPossible ( int [ ] a , int [ ] b , int n , int k ) { Array . Sort ( a ) ; Array . Reverse ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
int findExtra ( int [ ] arr1 , int [ ] arr2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
int countNum ( int n ) { if ( n == 1 ) return 1 ; int count = ( int ) Math . Pow ( 2 , n - 2 ) ; return count ; }
int MinimumValue ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int minXor = Int32 . MaxValue ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . Min ( minXor , val ) ; } return minXor ; }
int find_consecutive_steps ( int [ ] arr , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . Max ( maximum , count ) ; count = 0 ; } } return Math . Max ( maximum , count ) ; }
int countgroup ( int [ ] a , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }
void countPairs ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int xo = ( A [ i ] ^ A [ j ] ) ; int mx = Math . Max ( A [ i ] , A [ j ] ) ; if ( xo > mx ) { count ++ ; } } } Console . WriteLine ( count ) ; }
float ellipse ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float x = ( float ) ( 3.14 * l * b ) / 4 ; return x ; }
int divCount ( int n ) { bool [ ] hash = new bool [ n + 1 ] ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == false ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = true ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] == false ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( float ) ( 2 * a * Math . Sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
int findCount ( int n ) { return ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; }
float circlearea ( double a , double b ) { if ( a < 0 b < 0 ) return - 1 ; float A = ( float ) ( ( 3.14 * Math . Pow ( a , 2 ) * Math . Pow ( b , 2 ) ) / ( 4 * ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) ) ) ; return A ; }
int noOfTriangles ( int n ) { int y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }
int countDer ( int n ) { int [ ] der = new int [ n + 1 ] ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
void numbersWith3Divisors ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; prime [ 0 ] = prime [ 1 ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } System . Console . WriteLine ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : ▁ " ) ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( ! prime [ i ] ) System . Console . Write ( i * i + " ▁ " ) ; }
float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = 4 * ( float ) ( ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) / ( Math . Pow ( a , 2 ) * Math . Pow ( b , 2 ) ) ) ; return area ; }
float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; float x = r ; float V = ( float ) ( 4 * 3.14f * Math . Pow ( r , 3 ) ) / 3 ; return V ; }
double mixtureConcentration ( int n , int [ ] p ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return Math . Round ( res , 4 ) ; }
void radius ( int n , int d ) { Console . Write ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " + d / ( n - 1 ) ) ; }
bool func ( int [ ] a , int k ) { for ( int i = 0 ; i < a . Length ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }
void find_rectangle ( int area ) { for ( int i = ( int ) Math . Ceiling ( Math . Sqrt ( area ) ) ; i <= area ; i ++ ) { if ( area / i * i == area ) { Console . WriteLine ( i + " ▁ " + ( int ) ( area / i ) ) ; return ; } } }
bool isDivisibleBy25 ( String str ) { int n = str . Length ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - '0' == 0 && str [ n - 2 ] - '0' == 0 ) || ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 25 == 0 ) ; }
bool checkPalindromeB ( int N , int B ) { int rev = 0 ; int N1 = N ; while ( N1 > 0 ) { rev = rev * B + N1 % B ; N1 = N1 / B ; } return N == rev ; }
int smallest ( string s ) { int [ ] a = new int [ s . Length ] ; for ( int i = 0 ; i < s . Length ; i ++ ) a [ i ] = ( int ) ( s [ i ] - '0' ) ; ArrayList b = new ArrayList ( ) ; for ( int i = 0 ; i < a . Length ; i ++ ) { if ( a [ i ] % 2 != 0 ) b . Add ( a [ i ] ) ; } b . Sort ( ) ; if ( b . Count > 1 ) return ( ( int ) b [ 0 ] * 10 + ( int ) b [ 1 ] ) ; return - 1 ; }
void findSet ( int N , int K ) { List < int > a = new List < int > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . Add ( i ) ; } int MaxDistinct = ( N - K ) + ( K / 2 ) ; a . Reverse ( ) ; for ( int i = 0 ; i < MaxDistinct ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; }
string canMake ( string s ) { int o = 0 , z = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] - '0' == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return " NO " ; else return " YES " ; }
int minStartValue ( int [ ] nums ) { int minValue = 0 ; int sum = 0 ; foreach ( int n in nums ) { sum += n ; minValue = Math . Min ( minValue , sum ) ; } int startValue = 1 - minValue ; return startValue ; }
int getPairsCount ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && ( arr [ i ] * arr [ j ] ) == Math . Abs ( i - j ) ) { count ++ ; } } } return count ; }
int countPairs ( int A , int B ) { int countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; }
int matrixSum ( int [ , ] arr ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i , j ] ) ; } } return sum ; }
int countPairsWithProdK ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }
int minimumProduct ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int product = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }
int calculateProduct ( int [ ] A , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans = 1 ; for ( int i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; }
void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . Sqrt ( Math . Pow ( x , 2 ) + Math . Pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) Console . WriteLine ( " Fits " ) ; else Console . WriteLine ( " Doesn ' t ▁ Fit " ) ; }
int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
void fibonacci ( double n ) { double fib ; for ( double i = 0 ; i < n ; i ++ ) { fib = ( Math . Pow ( ( 1 + Math . Sqrt ( 5 ) ) , i ) - Math . Pow ( ( 1 - Math . Sqrt ( 5 ) ) , i ) ) / ( Math . Pow ( 2 , i ) * Math . Sqrt ( 5 ) ) ; Console . Write ( ( int ) fib + " ▁ " ) ; } }
int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . Max ( c , i + 1 ) ) ans += d - Math . Max ( c , i + 1 ) + 1 ; return ans ; }
int CntDivbyX ( int [ ] arr , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; }
void minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; Console . WriteLine ( cnt ) ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
int minTotalDistance ( int [ , ] grid ) { if ( ROW == 0 COL == 0 ) return 0 ; List < int > vertical = new List < int > ( ) ; List < int > horizontal = new List < int > ( ) ; for ( int i = 0 ; i < ROW ; i ++ ) { for ( int j = 0 ; j < COL ; j ++ ) { if ( grid [ i , j ] == 1 ) { vertical . Add ( i ) ; horizontal . Add ( j ) ; } } } vertical . Sort ( ) ; horizontal . Sort ( ) ; int size = vertical . Count / 2 ; int x = vertical [ size ] ; int y = horizontal [ size ] ; int distance = 0 ; for ( int i = 0 ; i < ROW ; i ++ ) for ( int j = 0 ; j < COL ; j ++ ) if ( grid [ i , j ] == 1 ) distance += Math . Abs ( x - i ) + Math . Abs ( y - j ) ; return distance ; }
int icosikaienneagonalNum ( int n ) { return ( 27 * n * n - 25 * n ) / 2 ; }
void newvol ( double x ) { Console . WriteLine ( " percentage ▁ increase ▁ in ▁ the " + " ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ " + ( Math . Pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . Pow ( x , 2 ) ) / 100 ) + " % " ) ; }
int longestSubarray ( int [ ] arr , int n ) { int maxMean = 0 ; for ( int i = 1 ; i < n ; i ++ ) maxMean = Math . Max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int subarrayLength = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = Math . Max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; }
int findKthGoodNo ( int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } Console . Write ( A + " ▁ " + B ) ; }
int countAnomalies ( int [ ] arr , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . Abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
int findMaxPairs ( int [ ] a , int [ ] b , int n , int k ) { Array . Sort ( a ) ; Array . Sort ( b ) ; bool [ ] flag = new bool [ n ] ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . Abs ( a [ i ] - b [ j ] ) <= k && flag [ j ] == false ) { result ++ ; flag [ j ] = true ; break ; } } } return result ; }
void MinDiff ( int n ) { int val = ( int ) Math . Pow ( 2 , n ) ; int sep = n / 2 ; int grp1 = 0 ; int grp2 = 0 ; grp1 = grp1 + val ; for ( int i = 1 ; i < sep ; i ++ ) grp1 = grp1 + ( int ) Math . Pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) grp2 = grp2 + ( int ) Math . Pow ( 2 , i ) ; Console . Write ( Math . Abs ( grp1 - grp2 ) ) ; }
int XorSum ( int [ ] A , int [ ] B , int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; }
void additiveCongruentialMethod ( int Xo , int m , int c , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m ; } }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
int minSteps ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . Length - 2 ; i ++ ) { if ( ( ( int ) str [ i ] ) == '0' ) { if ( str [ i + 1 ] == '1' ) { if ( str [ i + 2 ] == '0' ) { count ++ ; i += 2 ; } } } } return count ; }
int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; }
int titleToNumber ( string s ) { int result = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { result *= 26 ; result += s [ i ] - ' A ' + 1 ; } return result ; }
int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
long answer ( int n ) { int [ , ] dp = new int [ n + 1 , 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 , j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i , j ] = dp [ i - 1 , j + 1 ] ; else if ( j == 9 ) dp [ i , j ] = dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = dp [ i - 1 , j - 1 ] + dp [ i - 1 , j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n , j ] ; return sum ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
void quadrant ( String s ) { int l = s . Length ; int i ; if ( s . Contains ( " + " ) ) { i = s . IndexOf ( ' + ' ) ; } else { i = s . IndexOf ( ' - ' ) ; } String real = s . Substring ( 0 , i ) ; String imaginary = s . Substring ( i + 1 , l - 2 - i ) ; int x = Int32 . Parse ( real ) ; int y = Int32 . Parse ( imaginary ) ; if ( x > 0 && y > 0 ) Console . Write ( " Quadrant ▁ 1" ) ; else if ( x < 0 && y > 0 ) Console . Write ( " Quadrant ▁ 2" ) ; else if ( x < 0 && y < 0 ) Console . Write ( " Quadrant ▁ 3" ) ; else if ( x > 0 && y < 0 ) Console . Write ( " Quadrant ▁ 4" ) ; else if ( x == 0 && y > 0 ) Console . Write ( " Lies ▁ on ▁ positive " + " ▁ Imaginary ▁ axis " ) ; else if ( x == 0 && y < 0 ) Console . Write ( " Lies ▁ on ▁ negative " + " ▁ Imaginary ▁ axis " ) ; else if ( y == 0 && x < 0 ) Console . Write ( " Lies ▁ on ▁ negative " + " ▁ X - axis " ) ; else if ( y == 0 && x > 0 ) Console . Write ( " Lies ▁ on ▁ positive " + " ▁ X - axis " ) ; else Console . Write ( " Lies ▁ on ▁ the ▁ Origin " ) ; }
int find_greatest_divisor ( int l , int r ) { if ( l == r ) { return l ; } return 1 ; }
void CalculatePairs ( int [ ] a , int n ) { int cnt_zero = 0 ; int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } int total_XOR_pairs = cnt_zero * cnt_one ; int total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; int total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; Console . WriteLine ( " cntXOR ▁ = ▁ " + total_XOR_pairs ) ; Console . WriteLine ( " cntAND ▁ = ▁ " + total_AND_pairs ) ; Console . WriteLine ( " cntOR ▁ = ▁ " + total_OR_pairs ) ; }
int findWinner ( int N ) { return N & 1 ; }
bool search ( int [ ] arr , int n , int x ) { int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
int SmallestDiv ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }
long getNthTerm ( long N ) { return 4 * ( long ) Math . Pow ( N , 2 ) - 3 * N + 2 ; }
int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }
bool isMajority ( int [ ] arr , int n , int x ) { int i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; }
int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }
int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; }
void alternateSubarray ( bool [ ] arr , int n ) { int [ ] len = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) Console . Write ( len [ i ] + " ▁ " ) ; }
void printPair ( int g , int l ) { Console . Write ( g + " ▁ " + l ) ; }
void search ( string pat , string txt ) { int M = pat . Length ; int N = txt . Length ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { Console . WriteLine ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
bool uniqueCharacters ( String str ) { for ( int i = 0 ; i < str . Length ; i ++ ) for ( int j = i + 1 ; j < str . Length ; j ++ ) if ( str [ i ] == str [ j ] ) return false ; return true ; }
int answer_query ( int [ ] a , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
int contiguousPerfectSquare ( int [ ] arr , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = ( float ) Math . Sqrt ( arr [ i ] ) ; a = ( int ) b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . Max ( max_length , current_length ) ; } return max_length ; }
int oddEquivalent ( String s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } return count ; }
void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( n != 0 ) { int r = n % 10 ; largest = Math . Max ( r , largest ) ; smallest = Math . Min ( r , smallest ) ; n = n / 10 ; } Console . WriteLine ( largest + " ▁ " + smallest ) ; }
bool check ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) return true ; return false ; }
void maxksum ( int L , int R , int K ) { int N = ( R / 10 - L / 10 ) + 1 ; if ( K > N ) { Console . Write ( " - 1" ) ; return ; } R = R / 10 ; int X = R - K ; int sum = 10 * ( ( R * ( R + 1 ) ) / 2 - ( X * ( X + 1 ) ) / 2 ) ; Console . Write ( sum ) ; }
bool istriacontagonal ( int N ) { float n = ( float ) ( ( 26 + Math . Sqrt ( 224 * N + 676 ) ) / 56 ) ; return ( n - ( int ) n ) == 0 ; }
int totalArrays ( int N , int M ) { int [ ] end_with_one = new int [ N + 1 ] ; int [ ] end_not_with_one = new int [ N + 1 ] ; end_with_one [ 0 ] = 1 ; end_not_with_one [ 0 ] = 0 ; end_with_one [ 1 ] = 0 ; end_not_with_one [ 1 ] = M - 1 ; for ( int i = 2 ; i < N ; i ++ ) { end_with_one [ i ] = end_not_with_one [ i - 1 ] ; end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; } return end_with_one [ N - 1 ] ; }
int findPosition ( int n , int f , int b ) { return n - Math . Max ( f + 1 , n - b ) + 1 ; }
int numberOfWays ( int x ) { int [ ] dp = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
int findgroups ( int [ ] arr , int n ) { int [ ] c = new int [ ] { 0 , 0 , 0 } ; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
int countKCountdown ( int [ ] arr , int N , int K ) { int flag = - 1 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) flag = K ; if ( arr [ i ] == flag ) flag -- ; else flag = - 1 ; if ( flag == 0 ) count ++ ; } return count ; }
int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; }
int findLargestDivisor ( int n ) { for ( int i = 2 ; i < Math . Sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || Math . Abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = Math . Min ( a , b ) ; int j = Math . Max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } Console . Write ( ans ) ; }
String replacingConsonants ( String s ) { String str = " aaaeeeeiiiiioooooouuuuuuuu " ; char [ ] st = s . ToCharArray ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { int index = st [ i ] - ' a ' ; st [ i ] = str [ index ] ; } String str1 = new String ( st ) ; return str1 ; }
bool check ( string s , int m ) { int l = s . Length ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
int countOddSquares ( int n , int m ) { return ( int ) Math . Pow ( m , 0.5 ) - ( int ) Math . Pow ( n - 1 , 0.5 ) ; }
int countDistinct ( int [ ] arr , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; }
long sumOfSumSeries ( int N ) { long sum = 0L ; for ( int i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }
int count ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; }
String lexicographicSubConcat ( String s ) { int n = s . Length ; int sub_count = n * ( n + 1 ) / 2 ; String [ ] arr = new String [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) { arr [ index ++ ] = s . Substring ( i , len ) ; } Array . Sort ( arr ) ; String res = " " ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
long calculate ( long [ ] a , int n ) { Array . Sort ( a ) ; int i , j ; List < long > s = new List < long > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . Add ( ( a [ i ] + a [ j ] ) ) ; long mini = s . Min ( ) ; long maxi = s . Max ( ) ; return Math . Abs ( maxi - mini ) ; }
long sumOfSubstrings ( string num ) { long sum = 0 ; long mf = 1 ; for ( int i = num . Length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
void isPossible ( int W , int B , int D ) { if ( W > B ) { int temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) Console . WriteLine ( " NO " ) ; else Console . WriteLine ( " YES " ) ; }
bool isPowerOfFour ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAAAAAA ) == 0 ; }
bool divisibleBy20 ( String num ) { int lastTwoDigits = Int32 . Parse ( num . Substring ( 2 ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
int MinimumX ( int a , int b , int c , int k ) { int x = int . MaxValue ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . Min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
int minIncr ( int [ ] arr , int n ) { int forEven = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 1 ) { if ( ( arr [ i ] % 2 ) == 0 ) forEven += 1 ; } else { if ( arr [ i ] % 2 == 1 ) forEven += 1 ; } } return Math . Min ( forEven , n - forEven ) ; }
void checkHex ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s [ i ] ; if ( ( ch < '0' ch > '9' ) && ( ch < ' A ' ch > ' F ' ) ) { Console . WriteLine ( " No " ) ; return ; } } Console . WriteLine ( " Yes " ) ; }
int formQuadruplets ( int [ ] arr , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; Array . Sort ( arr ) ; Array . Reverse ( arr ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; }
void smallestGreater ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int diff = int . MaxValue ; int closest = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) Console . Write ( " _ ▁ " ) ; else Console . Write ( arr [ closest ] + " ▁ " ) ; } }
void maximumTiles ( int n , int m ) { Console . WriteLine ( ( m * n ) / 2 ) ; }
void checksum ( int n ) { if ( n % 5 == 0 ) Console . WriteLine ( ( n / 5 - 2 ) + " ▁ " + ( n / 5 - 1 ) + " ▁ " + ( n / 5 ) + " ▁ " + ( n / 5 + 1 ) + " ▁ " + ( n / 5 + 2 ) ) ; else Console . WriteLine ( " - 1" ) ; }
void findAandB ( int N ) { int K = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) ; int B = ( 1 << K ) ; int A = B ^ N ; Console . Write ( A + " ▁ " + B ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int maxWater ( int [ ] height , int n ) { int max = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int current = ( Math . Min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; max = Math . Max ( max , current ) ; } } return max ; }
int averageEven ( int n ) { if ( n % 2 != 0 ) { Console . Write ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; int sum = 5 ; while ( n > 2 ) { int d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
int make_permutation ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += Math . Abs ( i + 1 - arr [ i ] ) ; return ans ; }
int findMax ( int [ ] arr , int n ) { int res = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = Math . Max ( count , res ) ; } return res ; }
void countOfPairs ( int x , int y ) { int count = 0 ; for ( int k = 1 ; k * k <= x ; ++ k ) { count += Math . Max ( 0 , Math . Min ( y , x / k - 1 ) - k ) ; } Console . Write ( count ) ; }
void find3largest ( int [ ] arr ) { Array . Sort ( arr ) ; int n = arr . Length ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { Console . Write ( arr [ n - i ] + " ▁ " ) ; check = arr [ n - i ] ; count ++ ; } } else break ; } }
int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
void printElements ( int [ ] arr , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { Console . Write ( arr [ i ] + " ▁ " ) ; } } }
double largestSumOfAverages ( int [ ] A , int K ) { int n = A . Length ; double [ ] pre_sum = new double [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double [ ] dp = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . Max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
int cntEdges ( int n ) { int edges = ( int ) Math . Pow ( 2 , n ) - 2 ; return edges ; }
int minDifferenceAmongMaxMin ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . Min ( res , curSeqDiff ) ; } return res ; }
bool arePermutation ( String str1 , String str2 ) { int n1 = str1 . Length ; int n2 = str2 . Length ; if ( n1 != n2 ) return false ; char [ ] ch1 = str1 . ToCharArray ( ) ; char [ ] ch2 = str2 . ToCharArray ( ) ; Array . Sort ( ch1 ) ; Array . Sort ( ch2 ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( ch1 [ i ] != ch2 [ i ] ) return false ; return true ; }
int pay ( int n ) { int cuts = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; return cuts ; }
void getOrgString ( String s ) { Console . Write ( s [ 0 ] ) ; int i = 1 ; while ( i < s . Length ) { if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) Console . Write ( " ▁ " + char . ToLower ( s [ i ] ) ) ; else Console . Write ( s [ i ] ) ; i ++ ; } }
int countNonIncreasing ( int [ ] arr , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
void myCopy ( char [ ] s1 , char [ ] s2 ) { int i = 0 ; for ( i = 0 ; i < s1 . Length ; i ++ ) s2 [ i ] = s1 [ i ] ; }
bool isequal ( string str ) { int n = str . Length ; int num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( '0' <= str [ i ] && str [ i ] <= '9' ) { num = ( str [ i ] - '0' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; }
int minOperations ( int [ ] A , int n ) { if ( ( n & 1 ) > 0 ) return - 1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }
String minLexRotation ( String str ) { int n = str . Length ; String [ ] arr = new String [ n ] ; String concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = concat . Substring ( i , n ) ; } Array . Sort ( arr ) ; return arr [ 0 ] ; }
int sumOfFactors ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int first = i ; int last = ( N / i ) * i ; int factors = ( last - first ) / i + 1 ; int totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
bool arekAnagrams ( string str1 , string str2 , int k ) { int n = str1 . Length ; if ( str2 . Length != n ) return false ; int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . Abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
double possiblePositions ( double n ) { double term1 = Math . Pow ( n , 4 ) ; double term2 = Math . Pow ( n , 3 ) ; double term3 = Math . Pow ( n , 2 ) ; double term4 = n / 3 ; double ans = ( Math . Ceiling ( term1 / 2 ) ) - ( Math . Ceiling ( 5 * term2 ) / 3 ) + ( Math . Ceiling ( 3 * term3 ) / 2 ) - term4 ; return ( long ) ans ; }
int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; }
void findNumbers ( int n , int b ) { double largest = Math . Pow ( b , n ) - 1 ; Console . Write ( largest ) ; }
void numberOfDigits ( int N ) { int nod = ( int ) Math . Floor ( Math . Log10 ( N ) + 1 ) ; int toDecrease = ( int ) ( Math . Pow ( 10 , nod ) - 1 ) / 9 ; Console . Write ( ( N + 1 ) * nod - toDecrease ) ; }
bool transformString ( ref StringBuilder s ) { char ch = ' a ' ; if ( s . Length < 26 ) return false ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( int ) ch > 122 ) break ; if ( s [ i ] <= ch ) { s [ i ] = ch ; ch = ( char ) ( ( int ) ch + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; }
Boolean isPossible ( int l , int m , int x , int y ) { if ( l * m == x + y ) return true ; return false ; }
bool sumOfTwoCubes ( int n ) { int lo = 1 , hi = ( int ) Math . Pow ( n , ( 1.0 / 3.0 ) ) ; while ( lo <= hi ) { int curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; }
int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = ( int ) Math . Log10 ( n ) ; int [ ] a = new int [ d + 2 ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ( int ) Math . Ceiling ( Math . Pow ( 10 , i - 1 ) ) ; int p = ( int ) Math . Ceiling ( Math . Pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
void minLength ( String S , String T , int N , int M ) { String temp = " " ; int subtract = 0 ; for ( int i = 0 ; i < N ; ++ i ) { temp += S [ i ] ; if ( temp . Length >= M ) { if ( T . Equals ( temp . Substring ( temp . Length - M , M ) ) ) { subtract += M ; int cnt = 0 ; while ( cnt != M ) { temp = temp . Substring ( 0 , temp . Length - 1 ) ; ++ cnt ; } } } } Console . WriteLine ( ( N - subtract ) ) ; }
bool isWordPresent ( String sentence , String word ) { String [ ] s = sentence . Split ( ' ▁ ' ) ; foreach ( String temp in s ) { if ( temp . CompareTo ( word ) == 0 ) { return true ; } } return false ; }
int CountMaximum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
String isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int k = ( int ) n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; }
int maxLevel ( int [ ] boxes , int n ) { Array . Sort ( boxes ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
bool isCenteredtridecagonal ( int N ) { float n = ( float ) ( ( 13 + Math . Sqrt ( 104 * N + 65 ) ) / 26 ) ; return ( n - ( int ) n ) == 0 ; }
int difference ( int [ , ] arr , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i , i ] ; d2 += arr [ i , n - i - 1 ] ; } return Math . Abs ( d1 - d2 ) ; }
int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . Sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
float find_prob ( int N , float P ) { double [ ] dp = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; }
int get_unit_digit ( int N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
int xorZero ( string s ) { int one_count = 0 , zero_count = 0 ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
float findVolume ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; float h = a ; float V = ( float ) ( 3.14 * Math . Pow ( r , 2 ) * h ) ; return V ; }
void lengperpbisect ( double r1 , double r2 ) { double z = 2 * Math . Sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ " + " perpendicular ▁ bisector ▁ is ▁ " + z ) ; }
int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
float Area ( float a ) { if ( a < 0 ) return - 1 ; float x = 0.464f * a ; float A = 0.70477f * ( float ) Math . Pow ( x , 2 ) ; return A ; }
int countAnomalies ( int [ ] arr , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . Abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
bool check ( int X , int K ) { int prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = Convert . ToInt32 ( Math . Sqrt ( X ) ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = temp / i ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; }
int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
int minOperations ( int [ ] A , int [ ] B , int N ) { int cnt = 0 ; int i = 0 ; while ( i < N ) { int j = 0 ; while ( j < N && i < N ) { if ( B [ i ] == A [ j ] ) { i ++ ; } j ++ ; } cnt ++ ; } return cnt ; }
int calculate ( string s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s [ 0 ] - '0' ) c ++ ; if ( j != s [ 1 ] - '0' ) c ++ ; if ( k != s [ 2 ] - '0' ) c ++ ; if ( l != s [ 3 ] - '0' ) c ++ ; if ( m != s [ 4 ] - '0' ) c ++ ; if ( n != s [ 5 ] - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }
void checksum ( int n ) { if ( n % 3 == 0 ) Console . WriteLine ( n / 3 - 1 + " ▁ " + n / 3 + " ▁ " + ( n / 3 + 1 ) ) ; else Console . WriteLine ( " - 1" ) ; }
float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
int minCut ( string a ) { int [ ] cut = new int [ a . Length ] ; bool [ , ] palindrome = new bool [ a . Length , a . Length ] ; for ( int i = 0 ; i < a . Length ; i ++ ) { int minCut = i ; for ( int j = 0 ; j <= i ; j ++ ) { if ( a [ i ] == a [ j ] && ( i - j < 2 palindrome [ j + 1 , i - 1 ] ) ) { palindrome [ j , i ] = true ; minCut = Math . Min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . Length - 1 ] ; }
int findOptimalSolution ( int [ ] a , int N ) { Array . Sort ( a ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( int ) ( Math . Pow ( r , n ) - 1 ) / ( r - 1 ) ; }
bool isprime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int minimunMoves ( string [ ] arr , int n ) { int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int curr_count = 0 ; string tmp = " " ; for ( int j = 0 ; j < n ; j ++ ) { tmp = arr [ j ] + arr [ j ] ; int index = tmp . IndexOf ( arr [ i ] , StringComparison . Ordinal ) ; if ( index == arr [ i ] . Length ) { return - 1 ; } curr_count += index ; } ans = Math . Min ( curr_count , ans ) ; } return ans ; }
int count ( string a , string b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
long nthTermOfTheSeries ( int n ) { long nthTerm ; if ( n % 2 == 0 ) nthTerm = ( long ) Math . Pow ( n - 1 , 2 ) + n ; else nthTerm = ( long ) Math . Pow ( n + 1 , 2 ) + n ; return nthTerm ; }
bool isPal ( int [ , ] a , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i , j ] != a [ n - 1 - i , m - 1 - j ] ) return false ; } } return true ; }
int seriesSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; }
int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; }
int Solution ( int [ ] A ) { int ans = 2 ; int n = A . Length ; if ( n <= 2 ) return n ; int [ ] llap = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) llap [ i ] = 2 ; Array . Sort ( A ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( i >= 0 && k < n ) { if ( A [ i ] + A [ k ] == 2 * A [ j ] ) { llap [ j ] = Math . Max ( llap [ k ] + 1 , llap [ j ] ) ; ans = Math . Max ( ans , llap [ j ] ) ; i -= 1 ; k += 1 ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k += 1 ; else i -= 1 ; } } return ans ; }
void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { System . Console . WriteLine ( i + " ▁ " + j + " ▁ " + k ) ; return ; } } } } } } }
int findSDSFunc ( int n ) { int [ ] DP = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
void getParity ( int n , int [ ] A ) { foreach ( int x in A ) { if ( ( x & 1 ) == 1 ) { Console . WriteLine ( " Even " ) ; return ; } } Console . WriteLine ( " Odd " ) ; }
int FindNoOfFullVessels ( int n , int t ) { double [ , ] Matrix = new double [ n , n ] ; Matrix [ 0 , 0 ] = t * 1.0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { double exceededwater = Matrix [ i , j ] - 1.0 ; if ( exceededwater < 0 ) continue ; ans ++ ; if ( i + 1 < n ) Matrix [ i + 1 , j ] += exceededwater / 2 ; if ( i + 1 < n && j + 1 < n ) Matrix [ i + 1 , j + 1 ] += exceededwater / 2 ; } } return ans ; }
void segregate0and1 ( int [ ] arr , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } }
int lbs ( int [ ] arr , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
void rearrange ( int [ ] A , int [ ] B , int N , int X ) { bool flag = true ; Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
void checkSolveable ( int n , int m ) { if ( n == 1 m == 1 ) Console . WriteLine ( " YES " ) ; else if ( m == 2 && n == 2 ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
void generateNumbers ( int m ) { List < int > numbers = new List < int > ( ) ; int k_max , x ; for ( int y = 0 ; y < 10 ; y ++ ) { k_max = ( int ) ( Math . Pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / ( int ) ( Math . Pow ( 10 , m - 1 ) + y ) ; for ( int k = 1 ; k <= k_max ; k ++ ) { x = ( int ) ( y * ( Math . Pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ; if ( ( int ) ( y * ( Math . Pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) numbers . Add ( 10 * x + y ) ; } } numbers . Sort ( ) ; for ( int i = 0 ; i < numbers . Count ; i ++ ) Console . WriteLine ( numbers [ i ] ) ; }
int sumofproduct ( int n ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int y = n / x ; ans += ( y * x ) ; } return ans ; }
int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }
void countFreq ( int [ ] arr , int n , int limit ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) Console . WriteLine ( i + " ▁ " + count [ i ] ) ; }
int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( ( K - P ) * N ) ; }
int findMaxK ( int N ) { int K = N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }
void isSequenceValid ( int [ ] B , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { Console . WriteLine ( " No " ) ; return ; } } Console . WriteLine ( " Yes " ) ; }
int log_a_to_base_b ( int a , int b ) { int rslt = ( a > b - 1 ) ? 1 + log_a_to_base_b ( a / b , b ) : 0 ; return rslt ; }
bool CheckForSequence ( int [ ] arr , int n , int k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; }
double angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; double den = Math . Sqrt ( Math . Pow ( ( x2 - x1 ) , 2 ) + Math . Pow ( ( y2 - y1 ) , 2 ) + Math . Pow ( ( z2 - z1 ) , 2 ) ) * Math . Sqrt ( Math . Pow ( ( x3 - x1 ) , 2 ) + Math . Pow ( ( y3 - y1 ) , 2 ) + Math . Pow ( ( z3 - z1 ) , 2 ) ) ; double angle = Math . Acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
int findMinDifference ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . Min ( diff1 , diff2 ) ; }
void leftRotate ( int [ ] arr , int n , int k ) { int mod = k % n ; for ( int i = 0 ; i < n ; ++ i ) Console . Write ( arr [ ( i + mod ) % n ] + " ▁ " ) ; Console . WriteLine ( ) ; }
double polygonArea ( double [ ] X , double [ ] Y , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . Abs ( area / 2.0 ) ; }
int findLCM ( int a , int b ) { int lar = Math . Max ( a , b ) ; int small = Math . Min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
int solve ( int i , int X , int Y , int [ ] a , int [ ] b , int n ) { if ( i == n ) return 0 ; if ( X <= 0 ) return b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ; if ( Y <= 0 ) return a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) ; else return Math . Max ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) , b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) ; }
int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
bool isPerfectSquare ( double x ) { if ( x >= 0 ) { double sr = Math . Sqrt ( x ) ; return ( sr * sr == x ) ; } return false ; }
int countWays ( string s ) { int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; count [ s [ 0 ] - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
int getPositionCount ( int [ ] a , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
int EqualNumbers ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n != 0 ) return n - 1 ; return n ; }
void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . Pow ( 10 , temp ) ; palindrome += n - 1 ; Console . Write ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { Console . Write ( palindrome % 10 ) ; palindrome /= 10 ; } Console . WriteLine ( " " ) ; }
void maximumSum ( int [ ] a , int [ ] b , int k , int n ) { int i , j ; Array . Sort ( a ) ; Array . Sort ( b ) ; for ( i = 0 , j = n - 1 ; i < k ; i ++ , j -- ) { if ( a [ i ] < b [ j ] ) { int temp = a [ i ] ; a [ i ] = b [ j ] ; b [ j ] = temp ; } else break ; } int sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; Console . Write ( sum + " STRNEWLINE " ) ; }
int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
void solve ( char [ ] a , char [ ] b ) { int l = a . Length ; int min = 0 , max = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == ' + ' b [ i ] == ' + ' a [ i ] != b [ i ] ) max ++ ; if ( a [ i ] != ' + ' && b [ i ] != ' + ' && a [ i ] != b [ i ] ) min ++ ; } Console . Write ( min + max + " STRNEWLINE " ) ; }
int maxSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
bool isRepunitNum ( int n , int b ) { int length = 0 ; int countOne = 0 ; while ( n != 0 ) { int r = n % b ; length ++ ; if ( r == 1 ) countOne ++ ; n = n / b ; } return countOne >= 3 && countOne == length ; }
void moveAtEnd ( string s , int i , int l ) { if ( i >= l ) return ; char curr = s [ i ] ; if ( curr != ' x ' ) Console . Write ( curr ) ; moveAtEnd ( s , i + 1 , l ) ; if ( curr == ' x ' ) Console . Write ( curr ) ; return ; }
void findDay ( int Y , int B ) { int lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Y / 4 ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) Console . WriteLine ( " Monday " ) ; else if ( day == 1 ) Console . WriteLine ( " Tuesday " ) ; else if ( day == 2 ) Console . WriteLine ( " Wednesday " ) ; else if ( day == 3 ) Console . WriteLine ( " Thursday " ) ; else if ( day == 4 ) Console . WriteLine ( " Friday " ) ; else if ( day == 5 ) Console . WriteLine ( " Saturday " ) ; else if ( day == 6 ) Console . WriteLine ( " Sunday " ) ; else Console . WriteLine ( " INPUT ▁ YEAR ▁ IS ▁ WRONG ! " ) ; }
void shuffleArray ( int [ ] a , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }
long evenPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
int maxConsecutiveRope ( int [ ] ropes , int N ) { int curSize = 0 ; Array . Sort ( ropes ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ropes [ i ] <= curSize + 1 ) { curSize = curSize + ropes [ i ] ; } else break ; } return curSize ; }
int countConsecutive ( int N ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; }
int count ( string s , int k ) { int n = s . Length ; int d = 0 , i ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s [ i ] ; if ( d % k == 0 ) count += 1 ; for ( i = k ; i < n ; i ++ ) { int prev = s [ i - k ] ; d -= prev ; d += s [ i ] ; if ( d % k == 0 ) count += 1 ; } return count ; }
void find_Solution ( double x , int n ) { double sum = x , e = 2 , o = 1 , p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( double ) ( o / e ) * ( double ) ( Math . Pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } Console . WriteLine ( sum ) ; }
int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; }
int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
int min_remove ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = Math . Min ( ans , n - j + i - 1 ) ; } } } return ans ; }
String removeSpace ( String str ) { str = str . Replace ( " ▁ " , " " ) ; return str ; }
int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }
bool getBit ( int num , int i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }
int setBitNumber ( int n ) { int k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; return 1 << k ; }
int findXor ( int [ ] arr , int n ) { int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
int minStepK ( int [ ] arr , int N , int K ) { int E = 0 ; int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 == 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return - 1 ; else return K - S ; }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { string str = i . ToString ( ) ; countr += str . Split ( "1" ) . Length - 1 ; } return countr ; }
void computeTotient ( int n ) { long [ ] phi = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) Console . WriteLine ( " Totient ▁ of ▁ " + i + " ▁ is ▁ " + phi [ i ] ) ; }
int hammingDist ( String str1 , String str2 ) { int i = 0 , count = 0 ; while ( i < str1 . Length ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; }
int countGreater ( int [ ] arr , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) Console . Write ( 1 + " ▁ " ) ; else Console . Write ( 0 + " ▁ " ) ; } Console . WriteLine ( ) ; } return 0 ; }
bool areEqual ( int [ ] arr1 , int [ ] arr2 ) { int n = arr1 . Length ; int m = arr2 . Length ; if ( n != m ) return false ; Array . Sort ( arr1 ) ; Array . Sort ( arr2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
int findCnt ( String s , int i , int r ) { if ( i == s . Length ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i , r ] == 1 ) return dp [ i , r ] ; v [ i , r ] = 1 ; dp [ i , r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i , r ] ; }
int kth ( int [ ] arr1 , int [ ] arr2 , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
int maxORminusXOR ( int N ) { int MSB = ( int ) Math . Ceiling ( Math . Log ( N ) ) ; int M = 0 ; for ( int i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; }
double averageSetBits ( int N , int K , int [ ] arr ) { double p = N ; double q = 0 ; for ( int i = 0 ; i < K ; i ++ ) { double _p = p , _q = q ; p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N ; q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N ; } return p ; }
int removals ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = - 1 ; int ans = n - 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; int j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = Math . Min ( dp [ i ] , j ) ; ans = Math . Min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }
float productOfGP ( float a , float r , int n ) { int an = ( int ) ( a * ( int ) ( Math . Pow ( r , n - 1 ) ) ) ; return ( int ) Math . Sqrt ( ( int ) Math . Pow ( a * an , n ) ) ; }
int Largestpower ( int n , int p ) { int ans = 0 ; while ( n > 0 ) { n /= p ; ans += n ; } return ans ; }
void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) Console . WriteLine ( " Not ▁ possible " ) ; else { int result ; if ( k < Math . Max ( m , n ) - 1 ) { result = Math . Max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . Max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } Console . WriteLine ( result ) ; } }
bool isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }
int maximumSum ( int [ ] a , int [ ] b , int n , int index , int lastpicked ) { if ( index == n ) return 0 ; int option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return Math . Max ( option1 , option2 ) ; }
int minimumNumbers ( int n , int s ) { if ( ( s % n ) > 0 ) return s / n + 1 ; else return s / n ; }
int GIF ( double n ) { return ( int ) Math . Floor ( n ) ; }
void cal_IST ( int h , double r ) { double IST = ( h * r * 1.0 ) / 360 ; int int_IST = ( int ) IST ; int float_IST = ( int ) Math . Floor ( ( double ) ( IST - int_IST ) * 60 ) ; Console . WriteLine ( int_IST + " : " + float_IST ) ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 3 ) + ( int ) Math . Pow ( n , 2 ) ; }
void maxSum ( int [ ] a , int n ) { int maxAnd = a . Max ( ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } Console . Write ( ( maxAnd + maxOR ) ) ; }
int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 1st ▁ octant " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 2nd ▁ octant " ) ; else if ( x < 0 && y < 0 && z >= 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 3rd ▁ octant " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 4th ▁ octant " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 5th ▁ octant " ) ; else if ( x < 0 && y >= 0 && z < 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 6th ▁ octant " ) ; else if ( x < 0 && y < 0 && z < 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 7th ▁ octant " ) ; else if ( x >= 0 && y < 0 && z < 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 8th ▁ octant " ) ; }
void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { Console . Write ( "2 ▁ " ) ; } Console . WriteLine ( check ) ; } else { Console . WriteLine ( " - 1" ) ; } }
int toggle ( int n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
float Area ( float a ) { if ( a < 0 ) return - 1 ; float h = ( float ) 1.268 * a ; float A = ( float ) ( 0.70477 * Math . Pow ( h , 2 ) ) ; return A ; }
bool check ( string str ) { int min = Int32 . MaxValue ; int max = Int32 . MinValue ; int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { int ascii = ( int ) str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }
int avg_of_odd_num ( int n ) { return n ; }
void calculateAngle ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int ABx = x1 - x2 ; int ABy = y1 - y2 ; int ABz = z1 - z2 ; int BCx = x3 - x2 ; int BCy = y3 - y2 ; int BCz = z3 - z2 ; double dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; double magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; double magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; double angle = dotProduct ; angle /= Math . Sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / 3.14 ; Console . Write ( String . Format ( " { 0 : F4 } " , Math . Abs ( angle ) ) ) ; }
int addOne ( int x ) { return ( - ( ~ x ) ) ; }
int findRepeatingElement ( int [ ] arr , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
int solve ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
int totalNumber ( int n ) { return 8 * ( int ) Math . Pow ( 9 , n - 1 ) ; }
int totalMoney ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans += i / 7 ; ans += ( i % 7 + 1 ) ; } return ans ; }
long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
int maxSumWO3Consec ( int [ ] A , int N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; int third = A [ 0 ] ; int second = third + A [ 1 ] ; int first = Math . Max ( second , A [ 1 ] + A [ 2 ] ) ; int sum = Math . Max ( Math . Max ( third , second ) , first ) ; for ( int i = 3 ; i < N ; i ++ ) { sum = Math . Max ( Math . Max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }
void last_digit ( int X , int Y ) { Console . Write ( X % Y ) ; }
void countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } Console . WriteLine ( numbers_rightmost_setbit_K ) ; }
void printPair ( int n ) { Console . Write ( 1 + " ▁ " + ( n - 1 ) ) ; }
int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( l <= str [ i ] && str [ i ] <= r ) { cnt ++ ; Console . Write ( str [ i ] + " ▁ " ) ; } } return cnt ; }
int splitArray ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int result = Int32 . MaxValue ; for ( int i = 1 ; i < N ; i ++ ) { result = Math . Min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
void print_primes_till_N ( int N ) { int i , j , flag ; Console . Write ( " Prime ▁ numbers ▁ between ▁ 1 ▁ and ▁ " + N + " ▁ are : STRNEWLINE " ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) Console . Write ( i + " ▁ " ) ; } }
int maximum_middle_value ( int n , int k , int [ ] arr ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . Max ( ans , arr [ i - 1 ] ) ; } return ans ; }
int oddLengthPalindrome ( int k ) { int palin = k ; k = k / 10 ; while ( k > 0 ) { int rev = k % 10 ; palin = ( palin * 10 ) + rev ; k = k / 10 ; } return palin ; }
bool canMadeEqual ( int [ ] A , int [ ] B , int n ) { Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != B [ i ] ) { return false ; } } return true ; }
void product_subarrays ( int [ ] arr , int n ) { int res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product *= arr [ j ] ; res = res * product ; } } Console . WriteLine ( res + " STRNEWLINE " ) ; }
bool function ( String str ) { int l = str . Length ; int [ ] counter = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) counter [ i ] = 0 ; for ( int i = 0 ; i < l / 2 ; i ++ ) counter [ str [ i ] - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter [ str [ i ] - ' a ' ] -- ; for ( int i = 0 ; i < MAX ; i ++ ) if ( counter [ i ] != 0 ) return true ; return false ; }
int smallestSumSubarr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = Math . Max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . Max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; }
void swapThree ( ref int a , ref int b , ref int c ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }
int count ( int N , int B ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) ( ( B - 1 ) * Math . Pow ( B , i - 1 ) ) ; } return sum ; }
void sumArray ( int [ ] arr , int n ) { int [ ] leftSum = new int [ n ] ; int [ ] rightSum = new int [ n ] ; int [ ] Sum = new int [ n ] ; int i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( Sum [ i ] + " ▁ " ) ; }
int maxPrimes ( int n ) { return n / 2 ; }
int find_Area ( int r ) { return ( 2 * r * r ) ; }
void removeSpecialCharacter ( String str ) { char [ ] s = str . ToCharArray ( ) ; int j = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } Console . WriteLine ( String . Join ( " " , s ) . Substring ( 0 , j ) ) ; }
int minimizeCost ( int A , int B , int C ) { int ans = A + B + C ; for ( int i = 1 ; i <= 2 * C ; i ++ ) { int j = 0 ; while ( i * j <= 2 * C ) { ans = Math . Min ( ans , Math . Abs ( A - i ) + Math . Abs ( B - j ) + Math . Abs ( i * j - C ) ) ; j ++ ; } } return ans ; }
void evenproduct ( int [ ] arr , int length ) { int total_subarray = length * ( length + 1 ) / 2 ; int total_odd = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < arr . Length ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } Console . WriteLine ( total_subarray - total_odd ) ; }
int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; }
int minimumSets ( string s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . Length ; bool f = false ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - '0' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s [ i ] - '0' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; }
int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( Math . Pow ( x , y ) ) ) % 10 ) ; }
string removeChars ( string s ) { string modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( char . IsUpper ( s [ i ] ) && char . IsLower ( s [ i - 1 ] ) || char . IsLower ( s [ i ] ) && char . IsUpper ( s [ i - 1 ] ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; }
int get_palindrome_time ( string str ) { int hh , mm ; hh = ( str [ 0 ] - 48 ) * 10 + ( str [ 1 ] - 48 ) ; mm = ( str [ 3 ] - 48 ) * 10 + ( str [ 4 ] - 48 ) ; int requiredTime = 0 ; while ( hh % 10 != mm / 10 hh / 10 != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }
void printExpansion ( String str ) { for ( int i = ( int ) str . Length - 1 ; i >= 0 ; i -- ) { String subStr = str . Substring ( i ) ; Console . Write ( subStr ) ; } }
void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } Console . Write ( " Sum ▁ = ▁ " + sum ) ; Console . Write ( " Product = " }
String fibWord ( int n ) { String Sn_1 = "0" ; String Sn = "01" ; String tmp ; for ( int i = 2 ; i <= n ; i ++ ) { tmp = Sn ; Sn += Sn_1 ; Sn_1 = tmp ; } return Sn ; }
int countPairs ( int [ ] arr , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; }
void printLargest ( int [ ] a , int n ) { int max = - 1 ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num > 0 ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( int i = ind ; i < n ; i ++ ) Console . Write ( a [ i ] ) ; for ( int i = 0 ; i < ind ; i ++ ) Console . Write ( a [ i ] ) ; }
void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { Console . Write ( " A ▁ = ▁ " + A / 3 + " , ▁ B ▁ = ▁ " + B + " , ▁ C ▁ = ▁ " + C ) ; return ; } } } Console . WriteLine ( - 1 ) ; }
String tidyNum ( String str1 , int len ) { char [ ] str = str1 . ToCharArray ( ) ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( int j = i + 1 ; j < len ; j ++ ) str [ j ] = '9' ; } } string s = new string ( str ) ; return s ; }
int findCost ( int [ , ] cost_mat , int N , int M ) { int [ , ] dp = new int [ N , M ] ; for ( int i = 0 ; i < M ; i ++ ) dp [ 0 , i ] = cost_mat [ 0 , i ] ; for ( int row = 1 ; row < N ; row ++ ) { for ( int curr_col = 0 ; curr_col < M ; curr_col ++ ) { int val = 999999999 ; for ( int prev_col = 0 ; prev_col < M ; prev_col ++ ) { if ( curr_col != prev_col ) val = Math . Min ( val , dp [ row - 1 , prev_col ] ) ; } dp [ row , curr_col ] = val + cost_mat [ row , curr_col ] ; } } int ans = int . MaxValue ; for ( int i = 0 ; i < M ; i ++ ) ans = Math . Min ( ans , dp [ N - 1 , i ] ) ; return ans ; }
int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; }
int minReplacement ( String s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s [ i ] == '1' ) ans ++ ; if ( i % 2 == 1 && s [ i ] == '0' ) ans ++ ; } return Math . Min ( ans , len - ans ) ; }
void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( curr_term + " ▁ " ) ; curr_term += d ; } }
int minCost ( int [ ] A , int n ) { int cost = 0 ; Array . Sort ( A ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += Math . Abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += Math . Abs ( A [ i ] - K ) ; cost = Math . Min ( cost , tempCost ) ; } return cost ; }
int calculate ( int [ ] ar , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }
void lengchord ( int z ) { Console . WriteLine ( " The ▁ length ▁ is ▁ " + z ) ; }
void checkSuffix ( int A , int B ) { String s1 = String . Join ( " " , A ) ; String s2 = String . Join ( " " , B ) ; bool result ; result = s1 . EndsWith ( s2 ) ; if ( result ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } }
double cubeRoot ( double n ) { double ans = Math . Pow ( 3 , ( ( 1.0 / 3 ) * ( Math . Log ( n ) / Math . Log ( 3 ) ) ) ) ; return ans ; }
int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }
void Selection_Sort ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { int min_index = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( arr [ j ] < arr [ min_index ] ) min_index = j ; } int temp = arr [ i ] ; arr [ i ] = arr [ min_index ] ; arr [ min_index ] = temp ; } }
int evenSum ( int n ) { return ( n * ( n + 1 ) ) ; }
void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; Console . Write ( arr [ start ] + " ▁ " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
int distIntegers ( int L , int R ) { return 2 * R - 2 * L + 1 ; }
int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }
int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
int findMin ( int [ ] arr , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }
void constructArray ( int N , int K , int X ) { int [ ] ans = new int [ K ] ; ans [ 0 ] = X ; for ( int i = 0 ; i < N ; ++ i ) { Console . Write ( ans [ i % K ] + " ▁ " ) ; } }
void printMedian ( int [ ] arr , int n , int K ) { Array . Sort ( arr ) ; Console . Write ( arr [ ( n + K ) / 2 ] ) ; }
int getMissingNo ( int [ ] a , int n ) { int n_elements_sum = ( n * ( n + 1 ) / 2 ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum = sum + a [ i ] ; return ( n_elements_sum - sum ) ; }
int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
int solve ( int n , int m ) { int ans = n * ( m / 2 ) ; if ( m % 2 == 1 ) { ans += ( n + 1 ) / 2 ; } return ans ; }
int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; c = a + b ; a = b ; b = c ; } return sum ; }
void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { Console . Write ( " x2 ▁ = ▁ " + ( 2 * c1 - x1 ) + " ▁ " ) ; Console . Write ( " y2 ▁ = ▁ " + ( 2 * c2 - y1 ) ) ; }
int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; }
int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
int totalPay ( int totalItems , int priceOfOneItem , int N , int M ) { int freeItems = 0 , actual = 0 ; freeItems = totalItems / ( N + M ) ; actual = totalItems - freeItems ; int amount = actual * priceOfOneItem ; return amount ; }
int numberOfSquares ( int _base ) { _base = ( _base - 2 ) ; _base = _base / 2 ; return _base * ( _base + 1 ) / 2 ; }
int countOfBase ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; ++ i ) { int highestPower = ( int ) ( Math . Log ( N ) / Math . Log ( i ) ) ; int firstDigit = N / ( int ) Math . Pow ( i , highestPower ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
String getResult ( int n ) { String st = String . Join ( " " , n ) ; int sum = 0 ; foreach ( char i in st . ToCharArray ( ) ) { sum = sum + ( int ) i ; } if ( n % sum == 0 ) return " Yes " ; else return " No " ; }
int largestAnagramSet ( String [ ] arr , int n ) { int maxSize = 0 ; Dictionary < String , int > count = new Dictionary < String , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { char [ ] temp = arr [ i ] . ToCharArray ( ) ; Array . Sort ( temp ) ; arr [ i ] = new String ( temp ) ; if ( count . ContainsKey ( arr [ i ] ) ) { count [ arr [ i ] ] = count [ arr [ i ] ] + 1 ; } else { count . Add ( arr [ i ] , 1 ) ; } maxSize = Math . Max ( maxSize , count [ arr [ i ] ] ) ; } return maxSize ; }
void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; Console . Write ( res ) ; }
Boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
bool isDivisible ( int N ) { return ( N a 1 ) % 3 != 0 ; }
int findCnt ( int [ ] arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; int x = Math . Max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }
int countPieces ( int N ) { return 2 * N ; }
int extrema ( int [ ] a , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; }
int findPairCount ( int N , int K ) { int count = 0 ; int [ ] rem = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
int gonNum65537 ( int n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; }
int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = ( int ) Math . Pow ( ( PX - X ) , 2 ) + ( int ) Math . Pow ( ( PY - Y ) , 2 ) ; if ( val > Math . Pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; return 0 ; }
void findNthTerm ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { ans = ans + 6 ; } else { ans = ans + 2 ; } } Console . Write ( ans + " STRNEWLINE " ) ; }
void parallel ( int [ , ] a ) { bool x = true , y = true ; for ( int i = 0 ; i < a . Rank - 1 ; i ++ ) { if ( a [ i , 0 ] != a [ i + 1 , 0 ] ) x = false ; if ( a [ i , 1 ] != a [ i + 1 , 1 ] ) y = false ; } if ( x ) System . Console . WriteLine ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; else if ( y ) System . Console . WriteLine ( " Parallel ▁ to ▁ X ▁ Axis " ) ; else System . Console . WriteLine ( " Not ▁ parallel ▁ to ▁ X " + " ▁ and ▁ Y ▁ axis " ) ; }
int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }
int maxDiff ( int [ ] arr , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
void printKthBit ( long n , long k ) { Console . WriteLine ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
int findMajority ( int [ ] arr , int n ) { return arr [ n / 2 ] ; }
int getMaxSum ( int [ ] a , int n ) { int [ , ] dp = new int [ n , 2 ] ; dp [ 0 , 0 ] = a [ 0 ] ; dp [ 0 , 1 ] = a [ 0 ] * a [ 0 ] ; int max_sum = Math . Max ( dp [ 0 , 0 ] , dp [ 0 , 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i , 0 ] = Math . Max ( a [ i ] , dp [ i - 1 , 0 ] + a [ i ] ) ; dp [ i , 1 ] = Math . Max ( dp [ i - 1 , 1 ] + a [ i ] , a [ i ] * a [ i ] ) ; dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , dp [ i - 1 , 0 ] + a [ i ] * a [ i ] ) ; max_sum = Math . Max ( max_sum , dp [ i , 1 ] ) ; max_sum = Math . Max ( max_sum , dp [ i , 0 ] ) ; } return max_sum ; }
int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) Console . Write ( a + " ▁ " ) ; if ( n >= 1 ) Console . Write ( b + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; Console . Write ( c + " ▁ " ) ; a = b ; b = c ; } }
bool isDivisible ( long n ) { while ( n / 100 > 0 ) { int last_digit = ( int ) n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
long getNthTerm ( long N ) { return ( ( int ) Math . Pow ( N , 2 ) + N + 1 ) ; }
int oddSum ( int n ) { return ( n * n ) ; }
int nonDecNums ( int n ) { int [ , ] a = new int [ n + 1 , 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 , i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i , 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i , j ] = a [ i - 1 , j ] + a [ i , j + 1 ] ; return a [ n , 0 ] ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
void findOptimalPairs ( int [ ] arr , int N ) { Array . Sort ( arr ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) Console . Write ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " ▁ " ) ; }
void findPosition ( int n ) { int i = 0 ; int pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + ( int ) Math . Pow ( 2 , i + 1 ) ; } else { pos = pos + ( int ) Math . Pow ( 2 , i ) ; } i ++ ; n = n / 10 ; } Console . Write ( pos ) ; }
void evenproduct ( int [ ] arr , int length ) { int count = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { int product = 1 ; for ( int j = i ; j < arr . Length ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } Console . WriteLine ( count ) ; }
int cntSquares ( int n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
long partitions ( int n ) { long [ ] p = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }
int averageValue ( String s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { sum_char += ( int ) s [ i ] ; } return sum_char / s . Length ; }
int numberOfObjects ( int N , int M ) { int initial = Math . Min ( N , M ) ; int last = ( N + M ) / 3 ; return Math . Min ( initial , last ) ; }
int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; }
int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
int maxOfSegmentMins ( int [ ] a , int n , int k ) { if ( k == 1 ) return a . Min ( ) ; if ( k == 2 ) return Math . Max ( a [ 0 ] , a [ n - 1 ] ) ; return a . Max ( ) ; }
void TwentyoneMatchstick ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i += 1 ) { Console . Write ( 5 - arr [ i ] + " ▁ " ) ; } Console . Write ( " STRNEWLINE " ) ; }
long getBoundarySum ( int [ , ] a , int m , int n ) { long sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i , j ] ; else if ( i == m - 1 ) sum += a [ i , j ] ; else if ( j == 0 ) sum += a [ i , j ] ; else if ( j == n - 1 ) sum += a [ i , j ] ; } } return sum ; }
bool orthogonality ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; if ( dsquare == r1 * r1 + r2 * r2 ) return true ; else return false ; }
int getHCF ( int x , int y ) { int minimum = Math . Min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
string evenlength ( string n ) { string res = n ; for ( int j = n . Length - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }
bool is_linear ( String s ) { int tmp = 0 ; char first = s [ 0 ] ; for ( int pos = 0 ; pos < s . Length ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } tmp ++ ; } return true ; }
void countSubsequences ( int [ ] A ) { int odd = 0 ; int even = 0 ; foreach ( int el in A ) { if ( el % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) Console . WriteLine ( 0 ) ; else Console . WriteLine ( 1 << ( A . Length - 1 ) ) ; }
int myXOR ( int x , int y ) { int res = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { int b1 = ( ( x & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int b2 = ( ( y & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int xoredBit = ( ( b1 & b2 ) != 0 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }
int divisorGame ( int N , int A , int [ , ] dp ) { if ( N == 1 N == 3 ) return 0 ; if ( N == 2 ) return 1 ; if ( dp [ N , A ] != - 1 ) return dp [ N , A ] ; int ans = ( A == 1 ) ? 0 : 1 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A == 1 ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N , A ] = ans ; }
long spellsCount ( String num ) { int n = num . Length ; long result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * ( long ) Math . Pow ( 2 , count - 1 ) ; } return result ; }
bool checkMarkov ( double [ , ] m ) { for ( int i = 0 ; i < m . GetLength ( 0 ) ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m . GetLength ( 1 ) ; j ++ ) sum = sum + m [ i , j ] ; if ( sum != 1 ) return false ; } return true ; }
int countDigitsToBeRemoved ( int N , int K ) { string s = Convert . ToString ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . Length - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K == 0 ) return res ; else if ( f_zero == 1 ) return s . Length - 1 ; return - 1 ; }
int numBoxes ( int [ ] A , int n , int K ) { Array . Sort ( A ) ; int i = 0 , j = ( n - 1 ) ; int ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; }
int sumOfDivisors ( int N ) { return N ; }
void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( ( A + i * d ) + " ▁ " ) ; }
void findLargestIndex ( int [ ] arr , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == i ) { Console . Write ( i ) ; return ; } } Console . Write ( - 1 ) ; }
int PentacontahenagonNum ( int N ) { return ( 49 * N * N - 47 * N ) / 2 ; }
int findMaximumScore ( int [ ] a , int n ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . ContainsKey ( a [ i ] ) ) { freq [ a [ i ] ] = freq [ a [ i ] ] + 1 ; } else { freq . Add ( a [ i ] , 1 ) ; } } int [ ] dp = new int [ a . Max ( ) + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = freq [ 1 ] ; for ( int i = 2 ; i < dp . Length ; i ++ ) dp [ i ] = Math . Max ( dp [ i - 1 ] , dp [ i - 2 ] + freq [ i ] * i ) ; return dp [ dp . Length - 1 ] ; }
double AreaofRectangle ( int L , int W ) { double area = ( W + L ) * ( W + L ) / 2 ; return area ; }
string possibleToSort ( int [ ] arr , int n , string str ) { int max_element = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { max_element = Math . Max ( max_element , arr [ i ] ) ; if ( str [ i ] == '0' ) { if ( max_element > i + 1 ) return " No " ; } } return " Yes " ; }
int minFlips ( String target ) { char curr = '1' ; int count = 0 ; for ( int i = 0 ; i < target . Length ; i ++ ) { if ( target [ i ] == curr ) { count ++ ; curr = ( char ) ( 48 + ( curr + 1 ) % 2 ) ; } } return count ; }
long SubArraySum ( int [ ] arr , int n ) { long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
int minDistance ( int [ ] start , int [ ] end , int n , int d ) { int left = Int32 . MinValue ; int right = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { left = Math . Max ( left , start [ i ] ) ; right = Math . Min ( right , end [ i ] ) ; } if ( left > right ) return - 1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return ( left - d ) ; if ( d > right ) return ( d - right ) ; return - 1 ; }
bool isint ( double N ) { int X = ( int ) N ; double temp2 = N - X ; if ( temp2 > 0 ) { return false ; } return true ; }
int distinctSubString ( String P , int N ) { HashSet < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { bool [ ] freq = new bool [ 26 ] ; String s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; if ( freq [ pos ] == true ) break ; freq [ pos ] = true ; s += P [ j ] ; S . Add ( s ) ; } } return S . Count ; }
bool findPartition ( int [ ] arr , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool [ , ] part = new bool [ sum / 2 + 1 , n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 , i ] = true ; for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i , 0 ] = false ; for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i , j ] = part [ i , j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i , j ] = part [ i , j - 1 ] || part [ i - arr [ j - 1 ] , j - 1 ] ; } } return part [ sum / 2 , n ] ; }
> getArray ( int n ) { List < long > ans = new List < long > ( ) ; long p2 = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) ans . Add ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }
int divisible ( String num ) { int n = num . Length ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num [ i ] ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; }
bool pointsAreOnSameSideOfLine ( int a , int b , int c , int x1 , int y1 , int x2 , int y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }
void printmaxSubseq ( int [ ] arr , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( i + 1 < n && arr [ i ] < arr [ i + 1 ] ) Console . Write ( arr [ i ] + " ▁ " ) ; else Console . WriteLine ( arr [ i ] ) ; } }
int equalXORandOR ( int n ) { int m = 0 ; int MSB = ( int ) Math . Log ( n ) ; for ( int i = 0 ; i <= MSB ; i ++ ) { if ( ( n & ( 1 << i ) ) <= 0 ) { m += ( 1 << i ) ; } } return m ; }
bool search ( int [ ] arr , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
int maxSumIS ( int [ ] arr , int n ) { int i , j , max = 0 ; int [ ] msis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
int FindSum ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ; int LesserValue = ( int ) Math . Pow ( 2 , power ) ; int LargerValue = ( int ) Math . Pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; }
int calcScore ( String str ) { int score = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; ) { int chunkSize = 1 ; char currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == '1' ) score += ( int ) Math . Pow ( chunkSize , 2 ) ; else score -= ( int ) Math . Pow ( chunkSize , 2 ) ; } return score ; }
void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; Console . Write ( first + " ▁ " ) ; if ( n > 1 ) Console . Write ( second + " ▁ " ) ; if ( n > 2 ) Console . Write ( second + " ▁ " ) ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; Console . Write ( curr + " ▁ " ) ; } }
int countPairs ( int [ ] arr , int k ) { Array . Sort ( arr ) ; int pair = 0 ; int index = 0 ; while ( index < arr . Length - 1 ) { if ( arr [ index + 1 ] - arr [ index ] <= k ) { pair += 1 ; index += 2 ; } else { index += 1 ; } } return pair ; }
void printPairs ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " , ▁ " ) ; } } }
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
void generate_derangement ( int N ) { int [ ] S = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int [ ] D = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( D [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; }
String maxInt ( char [ ] str ) { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] < '5' ) { str [ i ] = ( char ) ( ( '9' - str [ i ] ) + '0' ) ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '9' ; String str2 = new String ( str ) ; return str2 ; }
void longestSubsequence ( int [ ] arr , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } Console . WriteLine ( count ) ; }
long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
void printSubstrings ( String str ) { int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) { Console . Write ( str [ k ] ) ; } Console . WriteLine ( ) ; } } }
int maxProd ( int n ) { if ( n == 2 n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
int floorMax ( int A , int B , int N ) { int x = Math . Min ( B - 1 , N ) ; return ( A * x ) / B ; }
void PrintReverseOrder ( int N ) { for ( int i = N ; i > 0 ; i -- ) Console . Write ( i + " ▁ " ) ; }
void nDigitPerfectSquares ( int n ) { int smallest = ( int ) Math . Pow ( Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n - 1 ) ) ) , 2 ) ; Console . Write ( smallest + " ▁ " ) ; int largest = ( int ) Math . Pow ( Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n ) ) ) - 1 , 2 ) ; Console . Write ( largest ) ; }
void AreaFactor ( int n ) { double pi = 3.14159265 ; double areaf = 1 / ( Math . Cos ( pi / n ) * Math . Cos ( pi / n ) ) ; Console . WriteLine ( Math . Round ( areaf ) ) ; }
void countPairs ( int [ ] arr , int N ) { int count = 0 ; Dictionary < double , int > mp = new Dictionary < double , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { double val = 1.0 * arr [ i ] ; double idx = 1.0 * ( i + 1 ) ; if ( mp . ContainsKey ( val / idx ) ) count += mp [ val / idx ] ; if ( mp . ContainsKey ( val / idx ) ) mp [ val / idx ] ++ ; else mp [ val / idx ] = 1 ; } Console . WriteLine ( count ) ; }
bool isEven ( int n ) { if ( ( n ^ 1 ) == n + 1 ) return true ; else return false ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
void print_result ( int [ ] a , int n , int k , int m ) { List < List < int > > v = new List < List < int > > ( m ) ; for ( int i = 0 ; i < m ; i ++ ) v . Add ( new List < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v [ rem ] . Add ( a [ i ] ) ; if ( v [ rem ] . Count == k ) { for ( int j = 0 ; j < k ; j ++ ) Console . Write ( v [ rem ] [ j ] + " ▁ " ) ; return ; } } Console . Write ( " - 1" ) ; }
void minCost ( String str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( Math . Abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += Math . Min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; Console . Write ( result + " STRNEWLINE " ) ; }
void rangeSum ( int [ ] arr , int N , int L , int R ) { int [ ] prefix = new int [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; Console . Write ( rightsum - leftsum ) ; }
int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . Pow ( n , ( double ) 1 / 3 ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
int countofPermutations ( int N ) { return ( int ) ( 3 * Math . Pow ( 2 , N - 1 ) ) ; }
int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; }
int strScore ( string [ ] str , string s , int n ) { Dictionary < string , int > m = new Dictionary < string , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m [ str [ i ] ] = i + 1 ; if ( ! m . ContainsKey ( s ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) score += s [ i ] - ' a ' + 1 ; score = score * m [ s ] ; return score ; }
int countInRange ( int [ ] arr , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
int findWays ( int m , int n , int x ) { int [ , ] table = new int [ n + 1 , x + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= x ; j ++ ) table [ i , j ] = 0 ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 , j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) for ( int k = 1 ; k <= m && k < j ; k ++ ) table [ i , j ] += table [ i - 1 , j - k ] ; return table [ n , x ] ; }
int countTriplets ( int N , int K ) { if ( K % 2 == 0 ) { int x = N / K ; int y = ( N + ( K / 2 ) ) / K ; return x * x * x + y * y * y ; } else { int x = N / K ; return x * x * x ; } }
int countTriplets ( int [ ] a , int n , int x ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int [ ] temp = { a [ i ] , a [ j ] , a [ k ] } ; Array . Sort ( temp ) ; if ( temp [ 0 ] < temp [ 1 ] && temp [ 1 ] < temp [ 2 ] && temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) answer ++ ; } } } return answer ; }
bool istetradecagonal ( int N ) { double n = ( 10 + Math . Sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - ( int ) n ) == 0 ; }
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
int singleNumber ( int [ ] nums , int n ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; long sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m . ContainsKey ( nums [ i ] ) ) { sum1 += nums [ i ] ; m . Add ( nums [ i ] , 1 ) ; } sum2 += nums [ i ] ; } return ( int ) ( 2 * ( sum1 ) - sum2 ) ; }
double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }
int minPushes ( int N , int K , int [ ] arr ) { int [ ] dp = new int [ 100000 ] ; for ( int i = 0 ; i < dp . Length ; i ++ ) dp [ i ] = - 1 ; dp [ N ] = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { for ( int xx = 0 ; xx < 100000 ; xx ++ ) { int x = xx ; if ( dp [ x ] == - 1 ) continue ; int next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == - 1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }
bool check ( String s ) { for ( int i = 0 ; i < s . Length - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; }
bool isDivBy2PowerM ( int n , int m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
String even_or_odd ( String N ) { int len = N . Length ; if ( N [ len - 1 ] == '0' N [ len - 1 ] == '2' N [ len - 1 ] == '4' N [ len - 1 ] == '6' ) return ( " Even " ) ; else return ( " Odd " ) ; }
string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = " " ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; }
void findEquation ( int a , int b , int c ) { int X = ( a + b + c ) ; int Y = ( a * b ) + ( b * c ) + ( c * a ) ; int Z = a * b * c ; Console . Write ( " x ^ 3 ▁ - ▁ " + X + " x ^ 2 ▁ + ▁ " + Y + " x ▁ - ▁ " + Z + " ▁ = ▁ 0" ) ; }
bool isMajorityElement ( int [ ] arr , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; }
void printString ( char [ ] str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; bool used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) Console . Write ( "1" ) ; } if ( str [ i ] != '1' ) Console . Write ( str [ i ] ) ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) Console . Write ( "1" ) ; }
void kthpair ( int n , int k , int [ ] arr ) { int i , t = 0 ; Array . Sort ( arr ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } Console . Write ( arr [ i ] + " ▁ " + arr [ k / t ] ) ; }
void findGreater ( int a , int b , int n ) { if ( ! ( ( n & 1 ) > 0 ) ) { a = Math . Abs ( a ) ; b = Math . Abs ( b ) ; } if ( a == b ) Console . WriteLine ( " a ^ n ▁ is ▁ " + " equal ▁ to ▁ b ^ n " ) ; else if ( a > b ) Console . WriteLine ( " a ^ n ▁ is ▁ greater ▁ " + " than ▁ b ^ n " ) ; else Console . WriteLine ( " b ^ n ▁ is ▁ greater ▁ " + " than ▁ a ^ n " ) ; }
bool isPowerofTwo ( int n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }
int nobleInteger ( int [ ] arr ) { Array . Sort ( arr ) ; int n = arr . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
void numberofBoxes ( int W , int B , int O ) { int low = 0 , high = Math . Min ( W , B ) ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( ( ( W >= mid ) && ( B >= mid ) ) && ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } Console . Write ( ans ) ; }
void push ( int new_data ) { Node new_node = new Node ( new_data ) ; new_node . next = head ; head = new_node ; }
bool isDudeney ( int n ) { int cube_rt = ( int ) ( Math . Round ( ( Math . Pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; int dig_sum = 0 ; int temp = n ; while ( temp > 0 ) { int rem = temp % 10 ; dig_sum += rem ; temp /= 10 ; } if ( cube_rt != dig_sum ) return false ; return true ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
double findEdges ( double s1 , double s2 , double s3 ) { double a = Math . Sqrt ( s1 * s2 / s3 ) ; double b = Math . Sqrt ( s3 * s1 / s2 ) ; double c = Math . Sqrt ( s3 * s2 / s1 ) ; double sum = a + b + c ; return 4 * sum ; }
int TrialDivision ( int N ) { int i = 2 ; int k = ( int ) Math . Ceiling ( Math . Sqrt ( N ) ) ; while ( i <= k ) { if ( N % i == 0 ) return 0 ; i += 1 ; } return 1 ; }
int findMinimumCost ( int n , int x , int y ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . Min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = Math . Min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; }
int minimumPossibleProduct ( int K ) { int res = 1 ; int range = ( 1 << K ) - 1 ; for ( int i = 0 ; i < K ; i ++ ) { res *= ( range - 1 ) ; } res *= range ; return res ; }
int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = Math . Min ( Math . Abs ( 1 - i ) , Math . Abs ( 1 - j ) ) ; int dis_18 = Math . Min ( Math . Abs ( 1 - i ) , Math . Abs ( 8 - j ) ) ; int dis_81 = Math . Min ( Math . Abs ( 8 - i ) , Math . Abs ( 1 - j ) ) ; int dis_88 = Math . Min ( Math . Abs ( 8 - i ) , Math . Abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
long countStrings ( long A , long B , long K ) { long X = ( A + B ) / ( K + 1 ) ; return ( Math . Min ( A , Math . Min ( B , X ) ) * ( K + 1 ) ) ; }
int maxGCD ( int N , int K ) { int minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return - 1 ; int i = ( int ) Math . Sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = Math . Max ( res , N / i ) ; if ( N / i >= minSum ) res = Math . Max ( res , i ) ; } i -- ; } return res ; }
void findSum ( int [ ] A , int N , int K ) { Array . Sort ( A ) ; int sum = 0 ; for ( int i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } Console . Write ( sum ) ; }
int maxPlanes ( int [ ] A , int [ ] B ) { HashSet < int > St = new HashSet < int > ( ) ; for ( int i = 0 ; i < A . Length ; i ++ ) { int t = ( A [ i ] % B [ i ] > 0 ) ? 1 : 0 ; t += ( A [ i ] / B [ i ] ) + t ; St . Add ( t ) ; } return St . Count ; }
float area ( float r ) { if ( r < 0 ) return - 1 ; float area = ( float ) ( 3.14 * Math . Pow ( r / ( 2 * Math . Sqrt ( 2 ) ) , 2 ) ) ; return area ; }
void printPFsInPairs ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) Console . Write ( i + " * " + n / i + " STRNEWLINE " ) ; }
void printSinX ( int N ) { int Xi = 0 ; int num = 1 ; while ( N -- > 0 ) { Console . Write ( " X " + num + " ▁ = ▁ " + Xi ) ; Console . Write ( " ▁ sin ( X " + num + " ) ▁ = ▁ " ) ; Console . Write ( " { 0 : F6 } " , Math . Sin ( Xi ) ) ; Console . WriteLine ( ) ; num += 1 ; Xi += 710 ; } }
String check ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count ++ ; } if ( count == 1 ) return " Odd " ; else return " Even " ; }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; Console . Write ( num + " ▁ " ) ; } }
void findEquation ( int a , int b ) { int sum = ( a + b ) ; int product = ( a * b ) ; Console . WriteLine ( " x ^ 2 ▁ - ▁ ( " + sum + " x ) ▁ + ▁ ( " + product + " ) ▁ = ▁ 0" ) ; }
bool check ( string str ) { int n = str . Length ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
void countWaysToJump ( int [ ] arr , int n ) { int [ ] count_jump = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) count_jump [ i ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( count_jump [ i ] + " ▁ " ) ; }
void rearrange ( int [ ] a , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
int motzkin ( int n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; }
float diagonal_length ( float a ) { float L ; L = a * ( float ) Math . Sqrt ( 3 ) ; return L ; }
void printNumHavingAltBitPatrn ( int n ) { int curr_num = 1 , i = 1 ; Console . Write ( curr_num + " ▁ " ) ; while ( i != 0 ) { curr_num <<= 1 ; if ( n < curr_num ) break ; Console . Write ( curr_num + " ▁ " ) ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; Console . Write ( curr_num + " ▁ " ) ; } }
void makeArray ( int [ ] a , int n ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( i * n + " ▁ " ) ; }
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
void bestApproximate ( int [ ] x , int [ ] y ) { int n = x . Length ; double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += Math . Pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - Math . Pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; Console . WriteLine ( " m ▁ = ▁ " + m ) ; Console . WriteLine ( " c ▁ = ▁ " + c ) ; }
int minValue ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int minimum = arr [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }
void rearrange ( int [ ] arr , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
int placeValue ( int N , int num ) { int total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = N / 10 ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }
int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
int countNumbers ( int n ) { return ( n / 2520 ) ; }
int sumOfSeries ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int findMinimumAdjacentSwaps ( int [ ] arr , int N ) { bool [ ] visited = new bool [ N + 1 ] ; int minimumSwaps = 0 ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }
float hexagonside ( float a ) { if ( a < 0 ) return - 1 ; float x = a / 3 ; return x ; }
int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ 2 * n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
void findScoreSum ( int n ) { int F = n / 7 ; int D = n % 7 ; int fullWeekScore = ( 49 + 7 * F ) * F / 2 ; int lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; Console . WriteLine ( fullWeekScore + lastNonFullWeekScore ) ; }
void findSquareSum ( int [ , ] Coordinates , int N ) { long xq = 0 , yq = 0 ; long xs = 0 , ys = 0 ; long res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int a , b ; a = Coordinates [ i , 0 ] ; b = Coordinates [ i , 1 ] ; res += xq ; res -= 2 * xs * a ; res += i * ( long ) ( a * a ) ; xq += a * a ; xs += a ; res += yq ; res -= 2 * ys * b ; res += i * ( long ) b * b ; yq += b * b ; ys += b ; } Console . Write ( res ) ; }
int getMaximum ( int N , int M , int [ , ] mat ) { int global_max = int . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int row_min = int . MaxValue ; for ( int k = 0 ; k < M ; k ++ ) { int m = Math . Max ( mat [ i , k ] , mat [ j , k ] ) ; row_min = Math . Min ( row_min , m ) ; } global_max = Math . Max ( global_max , row_min ) ; } } return global_max ; }
void digitsNum ( int N ) { if ( N == 0 ) Console . Write ( "0" ) ; if ( N % 9 != 0 ) Console . Write ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) Console . Write ( "9" ) ; for ( int i = 1 ; i <= N ; ++ i ) Console . Write ( "0" ) ; Console . WriteLine ( " " ) ; }
double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . Sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . Ceiling ( d / ( 2 * r ) ) ; }
bool checkDivisbility ( int num ) { int digit ; int N = num ; while ( num != 0 ) { digit = num % 10 ; num = num / 10 ; if ( digit == 0 N % digit != 0 ) return false ; } return true ; }
void max_element ( int [ ] a , int n ) { int [ ] pre = new int [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = Math . Max ( pre [ i - 1 ] , a [ i ] ) ; int [ ] suf = new int [ n ] ; suf [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = Math . Max ( suf [ i + 1 ] , a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) Console . Write ( suf [ i + 1 ] + " ▁ " ) ; else if ( i == n - 1 ) Console . Write ( pre [ i - 1 ] + " ▁ " ) ; else Console . Write ( Math . Max ( pre [ i - 1 ] , suf [ i + 1 ] ) + " ▁ " ) ; } }
void series ( int A , int X , int n ) { int term = ( int ) Math . Pow ( A , n ) ; Console . Write ( term + " ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; Console . Write ( term + " ▁ " ) ; } }
double sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / Math . Pow ( 10 , n ) ) ; }
int maxDiff ( int [ ] arr , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }
void constructArray ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( i + " ▁ " ) ; } }
void findPairs ( int A , int B ) { for ( int i = 1 ; i <= B ; i ++ ) { int y = A ^ i ; if ( y > 0 && ( i y ) == B ) { Console . WriteLine ( i + " ▁ " + y ) ; } } }
int Pentatope_number ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }
int countOnes ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int countNumbers ( int N ) { return ( int ) ( Math . Sqrt ( N ) ) - 1 ; }
void printCombination ( int n ) { System . Console . Write ( 1 + " ▁ " ) ; if ( ( n - 2 ) % 3 == 0 ) System . Console . Write ( 2 + " ▁ " + ( n - 3 ) ) ; else System . Console . Write ( 1 + " ▁ " + ( n - 2 ) ) ; }
void countNumbers ( int n , int d ) { int total = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } Console . WriteLine ( total ) ; }
int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = ( int ) Math . Sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
bool Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return true ; return false ; }
int minimumChar ( String S1 , String S2 ) { int n = S1 . Length ; int m = S2 . Length ; int ans = Int32 . MaxValue ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . Min ( minRemovedChar , ans ) ; } return ans ; }
int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }
int xorK ( int n , int k ) { if ( k % 2 == 1 ) return n ; return 0 ; }
int seriesSum ( int n ) { int sum = 0 ; int currProd = 1 ; int currSum = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; }
void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } Console . Write ( N - Count ) ; }
int countTripletsLessThanL ( int n , int L , int [ ] arr ) { Array . Sort ( arr ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
long maximumNum ( long X , long Y , long N ) { long num = 0 ; if ( N - N % X + Y <= N ) { num = N - N % X + Y ; } else { num = N - N % X - ( X - Y ) ; } return num ; }
void findNumbers ( int aXORb , int aANDb , int aXORc , int aANDc , int bXORc , int bANDc ) { int a , b , c ; int aSUMb ; int aSUMc ; int bSUMc ; aSUMb = aXORb + aANDb * 2 ; aSUMc = aXORc + aANDc * 2 ; bSUMc = bXORc + bANDc * 2 ; a = ( aSUMb - bSUMc + aSUMc ) / 2 ; b = aSUMb - a ; c = aSUMc - a ; System . Console . Write ( " a ▁ = ▁ " + a ) ; System . Console . Write ( " , ▁ b ▁ = ▁ " + b ) ; System . Console . Write ( " , ▁ c ▁ = ▁ " + c ) ; }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; }
int maxCountAB ( string [ ] s , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . Length ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S [ j ] == ' A ' && S [ j + 1 ] == ' B ' ) { ans ++ ; } } if ( S [ 0 ] == ' B ' && S [ L - 1 ] == ' A ' ) BA ++ ; else if ( S [ 0 ] == ' B ' ) B ++ ; else if ( S [ L - 1 ] == ' A ' ) A ++ ; } if ( BA == 0 ) ans += Math . Min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . Min ( B , A ) ; return ans ; }
double hexagonside ( double a ) { if ( a < 0 ) return - 1 ; double x = ( 0.5176 * a ) ; return x ; }
int min_steps_required ( int n , int m , int r , int c ) { int i , j ; int corner_steps_req = int . MaxValue ; i = 1 ; j = 1 ; corner_steps_req = Math . Min ( corner_steps_req , Math . Abs ( r - i ) + Math . Abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = Math . Min ( corner_steps_req , Math . Abs ( r - i ) + Math . Abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = Math . Min ( corner_steps_req , Math . Abs ( r - i ) + Math . Abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = Math . Min ( corner_steps_req , Math . Abs ( r - i ) + Math . Abs ( j - c ) ) ; int minimum_steps = Math . Min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }
void removeRepeating ( string s1 , string s2 ) { string s3 = s1 + " ▁ " + s2 + " ▁ " ; string words = " " ; int i = 0 ; foreach ( char x in s3 . ToCharArray ( ) ) { if ( x == ' ▁ ' ) { if ( ! s1 . Contains ( words ) || ! s2 . Contains ( words ) ) Console . Write ( words ) ; words = " ▁ " ; } else { words = words + x ; } } }
void countOccurrences ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } Console . WriteLine ( count ) ; }
int minSteps ( string str , int n , int k ) { if ( str [ n - 1 ] == '0' ) return - 1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( int i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) continue ; int steps = INT_MAX ; if ( i + k < n && str [ i + k ] == '1' ) steps = Math . Min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == '1' ) steps = Math . Min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == '1' ) steps = Math . Min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == INT_MAX ) ? steps : 1 + steps ; } if ( dp [ 0 ] == INT_MAX ) return - 1 ; return dp [ 0 ] ; }
void printRepeating ( int [ ] arr , int size ) { int i ; Console . Write ( " The ▁ repeating ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . Abs ( arr [ i ] ) ] > 0 ) arr [ Math . Abs ( arr [ i ] ) ] = - arr [ Math . Abs ( arr [ i ] ) ] ; else Console . Write ( Math . Abs ( arr [ i ] ) + " ▁ " ) ; } }
int longestUniqueSubsttr ( string str ) { int n = str . Length ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool [ ] visited = new bool [ 256 ] ; for ( int j = i ; j < n ; j ++ ) { if ( visited [ str [ j ] ] == true ) break ; else { res = Math . Max ( res , j - i + 1 ) ; visited [ str [ j ] ] = true ; } } visited [ str [ i ] ] = false ; } return res ; }
bool checkZeroArray ( int [ ] arr , int n ) { int sum = 0 , maximum = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] ; maximum = Math . Max ( maximum , arr [ i ] ) ; } if ( sum % 2 == 0 && maximum <= sum / 2 ) return true ; return false ; }
int maxProfit ( int [ ] price , int n ) { int buy1 , profit1 , buy2 , profit2 ; buy1 = buy2 = int . MaxValue ; profit1 = profit2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { buy1 = Math . Min ( buy1 , price [ i ] ) ; profit1 = Math . Max ( profit1 , price [ i ] - buy1 ) ; buy2 = Math . Min ( buy2 , price [ i ] - profit1 ) ; profit2 = Math . Max ( profit2 , price [ i ] - buy2 ) ; } return profit2 ; }
int subset ( int [ ] ar , int n ) { int res = 0 ; Array . Sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . Max ( res , count ) ; } return res ; }
void maximumSum ( int [ ] arr , int N ) { int sum ; Array . Sort ( arr ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; Console . Write ( sum ) ; }
int Pentadecagonal_num ( int n ) { return ( 13 * n * n - 11 * n ) / 2 ; }
int cntOnesArrWithGivenOp ( int [ ] arr , int N ) { int cntOnes = 0 ; cntOnes = ( int ) Math . Sqrt ( N ) ; return cntOnes ; }
int maximumSegments ( int n , int a , int b , int c ) { int [ ] dp = new int [ n + 10 ] ; for ( int i = 0 ; i < n + 10 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . Max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . Max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . Max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
bool isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
void productOfTwoPerfectCubes ( double N ) { double cube_root ; cube_root = Math . Round ( Math . Cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { Console . Write ( " Yes " ) ; return ; } else { Console . Write ( " No " ) ; return ; } }
int minimumLength ( String s ) { int maxOcc = 0 , n = s . Length ; int [ ] arr = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }
> ConstructList ( int [ , ] Q ) { int xor = 0 ; List < int > ans = new List < int > ( ) ; for ( int i = Q . GetLength ( 0 ) - 1 ; i >= 0 ; i -- ) { if ( Q [ i , 0 ] == 0 ) ans . Add ( Q [ i , 1 ] ^ xor ) ; else xor ^= Q [ i , 1 ] ; } ans . Add ( xor ) ; ans . Sort ( ) ; return ans ; }
void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { Console . Write ( ( 10 * rem ) / n ) ; rem = ( 10 * rem ) % n ; } }
int product ( int [ ] a , int n ) { int ans = 1 ; int val = ( int ) Math . Pow ( 2 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans *= ( int ) Math . Pow ( a [ i ] , val ) ; } return ans ; }
int numberofterm ( int n , int number ) { int firstnum = ( int ) Math . Pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
int minimumSteps ( int a , int b ) { int cnt = 0 ; a = Math . Abs ( a - b ) ; cnt = ( a / 5 ) + ( a % 5 ) / 2 + ( a % 5 ) % 2 ; return cnt ; }
void merge_and_sort ( int [ ] output , int [ , ] arr , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i , j ] ; } } Array . Sort ( output ) ; }
int findSum ( int n ) { return ( int ) Math . Pow ( n , 3 ) ; }
void String_palindrome ( int N , int K ) { for ( int i = 0 ; i < K ; i ++ ) Console . Write ( " a " ) ; string s = " bcd " ; for ( int i = 0 ; i < N - K ; i ++ ) Console . Write ( s [ i % 3 ] ) ; }
float maxVol ( float P , float A ) { float l = ( float ) ( P - Math . Sqrt ( P * P - 24 * A ) ) / 12 ; float V = ( float ) ( l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ) ; return V ; }
int maxPeople ( int p ) { int tmp = 0 , count = 0 ; for ( int i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
void moveSpaceInFront ( char [ ] str ) { int i = str . Length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ▁ ' ; }
String make_String_S_to_T ( String S , String T ) { bool possible = false ; int M = T . Length ; int N = S . Length ; for ( int i = 0 ; i <= M ; i ++ ) { int prefix_length = i ; int suffix_length = M - i ; String prefix = S . Substring ( 0 , prefix_length ) ; String suffix = S . Substring ( N - suffix_length , suffix_length ) ; if ( ( prefix + suffix ) . Equals ( T ) ) { possible = true ; break ; } } if ( possible ) return " YES " ; else return " NO " ; }
long findNum ( long x ) { for ( int i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } return long . MinValue ; }
int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] < ' A ' s [ i ] > ' Z ' && s [ i ] < ' a ' s [ i ] > ' z ' ) { s = s . Remove ( i , 1 ) ; i -- ; } } Console . Write ( s ) ; }
int floorDifference ( int [ ] A , int N , int X ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += A [ i ] / X ; } int totalFloorSum = totalSum / X ; return Math . Abs ( totalFloorSum - perElementSum ) ; }
int lastDigitFactorial ( int n ) { if ( n == 0 ) return 1 ; else if ( n <= 2 ) return n ; else if ( n == 3 ) return 6 ; else if ( n == 4 ) return 4 ; else return 0 ; }
bool isScalarMatrix ( int [ , ] mat ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i , j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i , i ] != mat [ i + 1 , i + 1 ] ) return false ; return true ; }
void findMaxDifference ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int Leftsum = 0 ; int Totalsum = 0 ; int Minn = Int32 . MaxValue , Maxx = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int leftNumbers = i ; int rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; int sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Minn = Math . Min ( Minn , sum ) ; Maxx = Math . Max ( Maxx , sum ) ; Leftsum += arr [ i ] ; } Console . WriteLine ( Maxx - Minn ) ; }
void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) Console . Write ( " y ▁ = ▁ " + dif + " x " + ( x * dif + y ) + " STRNEWLINE " ) ; else if ( dif > 0 ) Console . Write ( " y ▁ = ▁ " + dif + " x + " + - x * dif + y + " STRNEWLINE " ) ; else Console . Write ( " Not ▁ possible " + " STRNEWLINE " ) ; } }
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
bool isPower ( int N , int K ) { int res1 = ( int ) ( Math . Log ( N ) / Math . Log ( K ) ) ; double res2 = Math . Log ( N ) / Math . Log ( K ) ; return ( res1 == res2 ) ; }
float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return - 1 ; float A = ( a * a * n ) / ( float ) ( 4 * Math . Tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
void closestsAngle ( int N , int A ) { double mi = Int32 . MaxValue ; int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { double angle = 180.0 * i / N ; if ( Math . Abs ( angle - A ) < Math . Abs ( mi - A ) ) { mi = angle ; ans = i ; } } Console . Write ( 2 + " ▁ " + 1 + " ▁ " + ( 2 + ans ) ) ; }
int countTriplets ( int [ ] arr , int n , int m ) { int count = 0 ; Array . Sort ( arr ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { long prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
String replace ( String s , char c1 , char c2 ) { int l = s . Length ; char [ ] arr = s . ToCharArray ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return string . Join ( " " , arr ) ; }
Boolean function ( char [ ] str ) { int l = str . Length ; Array . Sort ( str , 0 , ( l / 2 ) ) ; Array . Sort ( str , ( l / 2 ) , l - ( l / 2 ) ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) if ( str [ i ] != str [ l / 2 + i ] ) return true ; return false ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }
int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
int maxIndexDiff ( int [ ] arr , int n ) { int maxDiff = - 1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }
int nthTerm ( int N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
int countIncreasing ( int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; }
bool isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; }
void printSubsequences ( String s ) { char [ ] str = s . ToCharArray ( ) ; int n = str . Length ; int opsize = ( int ) ( Math . Pow ( 2 , n - 1 ) ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) Console . Write ( " ▁ " ) ; } Console . WriteLine ( ) ; } }
long cen_octagonalnum ( long n ) { return ( 4 * n * n - 4 * n + 1 ) ; }
int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
Boolean isPossible ( int [ ] elements , int sum ) { int [ ] dp = new int [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < elements . Length ; i ++ ) { for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; }
int findNumber ( int n ) { int num = n - 1 ; num = 2 * ( int ) Math . Pow ( 4 , num ) ; num = ( int ) Math . Floor ( num / 3.0 ) ; return num ; }
int numberofpairs ( int [ ] arr , int N ) { int answer = 0 ; Array . Sort ( arr ) ; int minDiff = 10000000 ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . Min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }
void minimumTime ( int [ ] arr , int n ) { int sum = 0 ; int T = arr . Min ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } Console . WriteLine ( Math . Max ( 2 * T , sum ) ) ; }
bool is_possible ( String s ) { int l = s . Length ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . Abs ( one - zero ) == 1 ) ; }
float sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return ( float ) s ; }
int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; }
int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; }
int naive_find_x ( int N ) { int c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; }
int findNature ( int a , int b , int n ) { int [ ] seq = new int [ 100 ] ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; if ( ( seq [ n ] & 1 ) != 0 ) return 1 ; else return 0 ; }
int center_nonadecagon_num ( int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
void print ( int n ) { Console . WriteLine ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) Console . Write ( i + " ▁ " ) ; for ( int i = 1 ; i <= n ; i += 2 ) Console . Write ( i + " ▁ " ) ; for ( int i = 2 ; i <= n ; i += 2 ) Console . Write ( i + " ▁ " ) ; }
Boolean canBeBalanced ( String s , int n ) { int count = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) count ++ ; else count -- ; count_1 = Math . Min ( count_1 , count ) ; } if ( count_1 >= - 1 && count == 0 ) return true ; return false ; }
int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; }
bool isSumSquare ( int N ) { double n = ( 2 + Math . Sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - ( int ) n ) == 0 ; }
string removeOuterParentheses ( string S ) { string res = " " ; int count = 0 ; for ( int c = 0 ; c < S . Length ; c ++ ) { if ( S == ' ( ' && count ++ > 0 ) res += S ; if ( S == ' ) ' && count -- > 1 ) res += S ; } return res ; }
int minSum ( int [ ] ar , int n ) { if ( n <= 4 ) return ar . Min ( ) ; int [ ] sum = new int [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; int [ ] tempArr ; for ( int i = 4 ; i < n ; i ++ ) { tempArr = new int [ 4 ] ; Array . Copy ( sum , i - 4 , tempArr , 0 , 4 ) ; sum [ i ] = ar [ i ] + tempArr . Min ( ) ; } tempArr = new int [ 4 ] ; Array . Copy ( sum , n - 4 , tempArr , 0 , 4 ) ; return tempArr . Min ( ) ; }
bool isenneadecagonal ( int N ) { float n = ( float ) ( 15 + Math . Sqrt ( 136 * N + 225 ) ) / 34 ; return ( n - ( int ) n ) == 0 ; }
int StepstoReachTarget ( int target ) { target = Math . Abs ( target ) ; int n = ( int ) Math . Ceiling ( ( - 1.0 + ( int ) Math . Sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
double minAnglRot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; }
String flip ( char [ ] s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { while ( s [ i ] == '0' ) { s [ i ] = '1' ; i ++ ; } break ; } } return new String ( s ) ; }
void max_valid_triplet ( int [ ] A , int n ) { int ans = - 1 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { int value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } Console . WriteLine ( ans ) ; }
void countFreq ( String str ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < str . Length ; i ++ ) count [ str [ i ] - ' A ' ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) Console . WriteLine ( ( char ) ( i + ' A ' ) + " ▁ " + count [ i ] ) ; }
int findSubArray ( int [ ] arr , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) Console . WriteLine ( " No ▁ such ▁ subarray " ) ; else Console . WriteLine ( startindex + " ▁ to ▁ " + endindex ) ; return maxsize ; }
int countKAverageSubarrays ( int [ ] arr , int n , int k ) { int res = 0 ; for ( int L = 0 ; L < n ; L ++ ) { int sum = 0 ; for ( int R = L ; R < n ; R ++ ) { sum += arr [ R ] ; int len = ( R - L + 1 ) ; if ( sum % len == 0 ) { int avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }
int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
void record_sum ( int [ ] record , int l , int r , int n , int adder ) { for ( int i = l ; i <= r ; i ++ ) { record [ i ] += adder ; } }
int totalFlips ( string A , string B , string C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == '1' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == '0' ) ++ count ; } return count ; }
double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
int swapBits ( int num , int p1 , int p2 , int n ) { int shift1 , shift2 , value1 , value2 ; while ( n -- > 0 ) { shift1 = 1 << p1 ; shift2 = 1 << p2 ; value1 = ( ( num & shift1 ) ) ; value2 = ( ( num & shift2 ) ) ; if ( ( value1 == 0 && value2 != 0 ) || ( value2 == 0 && value1 != 0 ) ) { if ( value1 != 0 ) { num = num & ( ~ shift1 ) ; num = num | shift2 ; } else { num = num & ( ~ shift2 ) ; num = num | shift1 ; } } p1 ++ ; p2 ++ ; } return num ; }
double Nth_Term ( int n ) { return ( 2 * Math . Pow ( n , 3 ) - 3 * Math . Pow ( n , 2 ) + n + 6 ) / 6 ; }
int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; }
void solve ( int n ) { for ( int x = 1 ; x <= Math . Sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { int small = x ; int big = n / x ; if ( small % 2 == big % 2 ) { int a = ( small + big ) / 2 ; int b = ( big - small ) / 2 ; Console . WriteLine ( a + " ▁ " + b ) ; return ; } } } Console . WriteLine ( - 1 ) ; }
int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . Length ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }
int solve ( int [ ] p , int n ) { int G = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; G ^= ( p [ i ] - 1 ) ; } return G ; }
void insertNames ( String [ ] arr , int n ) { HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! set . Contains ( arr [ i ] ) ) { Console . Write ( " No STRNEWLINE " ) ; set . Add ( arr [ i ] ) ; } else { Console . Write ( " Yes STRNEWLINE " ) ; } } }
int findMinInsertions ( char [ ] str , int l , int h ) { if ( l > h ) return int . MaxValue ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . Min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
void Main ( String [ ] args ) { char [ ] str = " geeksforgeeks " . ToCharArray ( ) ; int n = str . Length ; Console . Write ( removeDuplicate ( str , n ) ) ; } }
void getResult ( int n ) { int proOdd = 1 ; int proEven = 1 ; String num = String . Join ( " " , n ) ; for ( int i = 0 ; i < num . Length ; i ++ ) if ( i % 2 == 0 ) proOdd = proOdd * ( num [ i ] - '0' ) ; else proEven = proEven * ( num [ i ] - '0' ) ; if ( proOdd == proEven ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
int areaSquare ( int L , int B ) { int large = Math . Max ( L , B ) ; int small = Math . Min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } }
int countXor ( int N ) { int cnt = ( int ) N / 2 + 1 ; return cnt ; }
double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . Sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
void shortdis ( double r , double d ) { Console . WriteLine ( " The ▁ shortest ▁ distance ▁ " + " from ▁ the ▁ chord ▁ to ▁ centre ▁ " + ( Math . Sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) ) ) ; }
int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . Min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
void findRealAndImag ( String s ) { int l = s . Length ; int i ; if ( s . IndexOf ( ' + ' ) != - 1 ) { i = s . IndexOf ( ' + ' ) ; } else { i = s . IndexOf ( ' - ' ) ; } String real = s . Substring ( 0 , i ) ; String imaginary = s . Substring ( i + 1 , l - i - 2 ) ; Console . WriteLine ( " Real ▁ part : ▁ " + real ) ; Console . WriteLine ( " Imaginary ▁ part : ▁ " + imaginary ) ; }
void getSum ( int n ) { int sumOdd = 0 ; int sumEven = 0 ; String num = n . ToString ( ) ; for ( int i = 0 ; i < num . Length ; i ++ ) if ( i % 2 == 0 ) sumOdd = sumOdd + ( num [ i ] - '0' ) ; else sumEven = sumEven + ( num [ i ] - '0' ) ; Console . WriteLine ( " Sum ▁ odd ▁ = ▁ " + sumOdd ) ; Console . WriteLine ( " Sum ▁ even ▁ = ▁ " + sumEven ) ; }
void maximumValue ( int [ ] arr , int n ) { int maxvalue = arr [ 0 ] ; int result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { result = Math . Max ( result , maxvalue + arr [ i ] - i ) ; maxvalue = Math . Max ( maxvalue , arr [ i ] + i ) ; } Console . Write ( result ) ; }
bool isPanalphabeticWindow ( string s , int n ) { char ch = ' a ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch ++ ; if ( ch == ' z ' + 1 ) return true ; } return false ; }
void findSum ( int [ ] a ) { int ans = 0 ; for ( int low = 0 ; low < a . Length ; low ++ ) { for ( int high = low ; high < a . Length ; high ++ ) { int count = 0 ; int maxNumber = 0 ; for ( int i = low ; i <= high ; i ++ ) { if ( a [ i ] == maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( ( count % 2 == 0 ) ? 2 : 1 ) ; } } Console . WriteLine ( ans ) ; }
String check ( int [ ] Arr , int n , int M , int K ) { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Arr [ i ] == 0 ) flag = 1 ; } if ( K % 2 != 0 && flag == 0 ) return " No " ; else return " Yes " ; }
void minModulo ( int L , int R , int N ) { if ( R - L < N ) { int ans = Int32 . MaxValue ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( i != j ) ans = Math . Min ( ans , ( i * j ) % N ) ; Console . WriteLine ( ans ) ; } else { Console . WriteLine ( 0 ) ; } }
int findMinSwaps ( string s , int k ) { int ans = 0 ; int c_one = 0 , c_zero = 0 ; for ( int i = s . Length - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) c_one ++ ; if ( s [ i ] == '0' ) { c_zero ++ ; ans += c_one ; } if ( c_zero == k ) break ; } if ( c_zero < k ) return - 1 ; return ans ; }
void swap ( int a , int b , int c , int d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; Console . WriteLine ( " values ▁ after ▁ " + " swapping ▁ are ▁ : ▁ " ) ; Console . WriteLine ( " a ▁ = ▁ " + a ) ; Console . WriteLine ( " b ▁ = ▁ " + b ) ; Console . WriteLine ( " c ▁ = ▁ " + c ) ; Console . WriteLine ( " d ▁ = ▁ " + d ) ; }
bool isSubsetSum ( int [ ] arr , int n , int sum ) { bool [ , ] subset = new bool [ 2 , sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 , j ] = true ; else if ( i == 0 ) subset [ i % 2 , j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 , j ] = subset [ ( i + 1 ) % 2 , j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 , j ] ; else subset [ i % 2 , j ] = subset [ ( i + 1 ) % 2 , j ] ; } } return subset [ n % 2 , sum ] ; }
int maxXOR ( int [ ] arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . Max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }
void isKthBitSet ( int n , int k ) { if ( ( ( n >> ( k - 1 ) ) & 1 ) > 0 ) Console . WriteLine ( " SET " ) ; else Console . WriteLine ( " NOT ▁ SET " ) ; }
void countNumEnds ( int A , int L , int R ) { int temp , count = 0 , digits ; int cycle ; digits = ( int ) ( Math . Log10 ( A ) + 1 ) ; temp = ( int ) Math . Pow ( 10 , digits ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } Console . Write ( count ) ; }
double cone ( double a ) { if ( a < 0 ) return - 1 ; double r = ( double ) ( a * Math . Sqrt ( 2 ) ) / 3 ; double h = ( 2 * a ) / 3 ; double V = ( double ) ( 3.14 * Math . Pow ( r , 2 ) * h ) ; return Math . Round ( V , 4 ) ; }
int findDistinctSums ( int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . Add ( i + j ) ; } } return s . Count ; }
int greatestOddFactor ( int n ) { int pow_2 = ( int ) ( Math . Log ( n ) ) ; int i = 1 ; while ( i <= pow_2 ) { int fac_2 = ( 2 * i ) ; if ( n % fac_2 == 0 ) { if ( ( n / fac_2 ) % 2 == 1 ) { return ( n / fac_2 ) ; } } i += 1 ; } return 0 ; }
int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * ( int ) Math . Pow ( m - 2 , n - 2 ) ; }
int totalDigits ( int n ) { int number_of_digits = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; dp [ i , curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i , curr ] ; }
void count_minimum ( string s ) { int n = s . Length ; int ans = 0 ; int i = 0 ; while ( i < n ) { int j = i ; while ( j < n && s [ j ] == s [ i ] ) { j ++ ; } int diff = j - i ; ans += diff / 2 ; i = j ; } Console . WriteLine ( ans ) ; }
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { Console . Write ( C + " ▁ " ) ; C = C * ( line - i ) / i ; } Console . Write ( " STRNEWLINE " ) ; } }
long ispowerof2 ( long num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }
bool isPossible ( int A , int B , int N , int K , int L ) { int needa , needb ; if ( A % K == 0 ) needa = A / K ; else needa = A / K + 1 ; if ( B % L == 0 ) needb = B / L ; else needb = B / L + 1 ; int total = needa + needb ; if ( total > N ) return false ; else return true ; }
void maxAverage ( int [ ] A , int N , int X , int Y ) { Array . Sort ( A ) ; int sum = 0 ; double res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; int cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += ( double ) sum / ( double ) ( X ) ; break ; } res += ( double ) sum / ( double ) ( X ) ; sum = 0 ; count = 0 ; } } Console . WriteLine ( res ) ; }
void PrintReverseOrder ( int N ) { if ( N <= 0 ) { return ; } else { Console . Write ( N + " ▁ " ) ; PrintReverseOrder ( N - 1 ) ; } }
void printRepeating ( int [ ] arr , int size ) { SortedSet < int > s = new SortedSet < int > ( arr ) ; foreach ( var n in s ) { Console . Write ( n + " ▁ " ) ; } }
bool isDvisibleBy12 ( string num ) { if ( num . Length >= 3 ) { int d1 = ( int ) num [ num . Length - 1 ] ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num [ num . Length - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = int . Parse ( num ) ; return ( number % 12 == 0 ) ; } }
void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = Math . Abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = ( float ) Math . Sqrt ( a * a + b * b + c * c ) ; Console . Write ( " Perpendicular ▁ distance ▁ " + " is ▁ " + d / e ) ; }
void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = Math . Min ( Math . Min ( i , j ) , Math . Min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) Console . Write ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + " TABSYMBOL " ) ; else Console . Write ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + " TABSYMBOL " ) ; } Console . WriteLine ( ) ; } }
int MaxRearrngeSum ( int [ ] A , int [ ] B , int N ) { Array . Sort ( A ) ; Array . Sort ( B ) ; Array . Reverse ( B ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxSum += Math . Abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
int countBits ( int a , int b ) { int count = 0 ; while ( a > 0 b > 0 ) { int last_bit_a = a & 1 ; int last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; }
String findStr ( char [ ] S ) { int n = S . Length ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( S [ i ] != ' a ' ) { S [ i ] = ' a ' ; return new String ( S ) ; } } S [ n - 1 ] = ' b ' ; return n < 2 ? " ▁ - 1 ▁ " : new String ( S ) ; }
bool checkDuplicatesWithinK ( int [ ] arr , int k ) { HashSet < int > set = new HashSet < int > ( ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( set . Contains ( arr [ i ] ) ) return true ; set . Add ( arr [ i ] ) ; if ( i >= k ) set . Remove ( arr [ i - k ] ) ; } return false ; }
int minimumAdditionOperation ( int N ) { int count = 0 ; while ( N != 0 ) { if ( ( N & 1 ) == 1 ) { count ++ ; } N = N >> 1 ; } return count ; }
bool findWinner ( int x , int y , int n ) { bool [ ] dp = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = false ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
int CtSubarr ( int [ ] arr , int N , int K ) { HashSet < int > st = new HashSet < int > ( ) ; int prefixSum = 0 ; st . Add ( prefixSum ) ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefixSum += arr [ i ] ; if ( st . Contains ( prefixSum - K ) ) { res += 1 ; prefixSum = 0 ; st . Clear ( ) ; st . Add ( 0 ) ; } st . Add ( prefixSum ) ; } return res ; }
int count_numbers ( int k , int n ) { int [ , ] dp = new int [ n + 1 , 2 ] ; dp [ 1 , 0 ] = 0 ; dp [ 1 , 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i , 0 ] = dp [ i - 1 , 1 ] ; dp [ i , 1 ] = ( dp [ i - 1 , 0 ] + dp [ i - 1 , 1 ] ) * ( k - 1 ) ; } return dp [ n , 0 ] + dp [ n , 1 ] ; }
int maximumSum ( int [ ] arr , int N ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & ( 1 << bit ) ) != 0 ) { sum += arr [ i ] ; } } ans = Math . Max ( ans , sum ) ; } return ans ; }
int findMin ( int [ ] arr , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
bool isIdoneal ( int n ) { for ( int a = 1 ; a <= n ; a ++ ) { for ( int b = a + 1 ; b <= n ; b ++ ) { for ( int c = b + 1 ; c <= n ; c ++ ) { if ( a * b + b * c + c * a == n ) return false ; } } } return true ; }
void findLastElement ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { Console . WriteLine ( " - 1" ) ; return ; } } Console . WriteLine ( arr [ N - 1 ] ) ; }
int countSymmetric ( int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
int findkey ( int A , int B , int C ) { int ans = 0 ; int cur = 1 ; while ( A > 0 ) { int a = A % 10 ; int b = B % 10 ; int c = C % 10 ; A = A / 10 ; B = B / 10 ; C = C / 10 ; int m = Math . Max ( a , Math . Max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
int getCount ( int l , int r , int p ) { int cnt = 0 ; int val = p ; while ( true ) { int a = r / val ; int b = ( l - 1 ) / val ; val *= p ; if ( ( a - b ) > 0 ) { cnt += ( a - b ) ; } else break ; } return cnt ; }
void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; Console . Write ( r ) ; }
void minCost ( int [ ] arr , int N , int X ) { Array . Sort ( arr ) ; int sum = 0 ; int cost = 0 ; int INT_MAX = Int32 . MaxValue ; int min_cost = Int32 . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { cost = Math . Abs ( arr [ i ] ) * X + ( sum - Math . Abs ( arr [ i ] ) * i ) ; sum += Math . Abs ( arr [ i ] ) ; min_cost = Math . Min ( min_cost , cost ) ; } } Console . Write ( min_cost ) ; }
void Main ( String [ ] args ) { String str = " geeksforgeeks " ; Console . WriteLine ( removeDuplicatesFromString ( str ) ) ; } }
void operations ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 , sum = 0 ; while ( k -- > 0 ) { while ( i < n && arr [ i ] - sum == 0 ) i ++ ; if ( i < n && arr [ i ] - sum > 0 ) { Console . Write ( arr [ i ] - sum + " ▁ " ) ; sum = arr [ i ] ; } else Console . WriteLine ( "0" ) ; } }
int maxProfit ( int [ ] prices , int n ) { int profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { int day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; }
int countFriendsPairings ( int n ) { int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
int maxCount ( int [ ] arr , int m , int V ) { int [ ] table = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = - 1 ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ j ] <= i ) { int sub_res = table [ i - arr [ j ] ] ; if ( sub_res != - 1 && sub_res + 1 > table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += Math . Log10 ( i ) ; ans = ans * n ; return 1 + ( int ) Math . Floor ( ans ) ; }
int calculateEnergy ( int [ , ] mat , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i , j ] / n ; i_des = q ; j_des = mat [ i , j ] - ( n * q ) ; tot_energy += Math . Abs ( i_des - i ) + Math . Abs ( j_des - j ) ; } } return tot_energy ; }
int maximumK ( String S ) { int N = S . Length ; int ans = N ; int flag = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) { flag = 1 ; ans = Math . Min ( ans , Math . Max ( i + 1 , N - i - 1 ) ) ; } } if ( flag == 0 ) return 0 ; return ans ; }
int count ( int [ ] S , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
void possibleNumbers ( HashSet < int > numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . Add ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; }
void printClosest ( int [ ] ar1 , int [ ] ar2 , int m , int n , int x ) { int diff = int . MaxValue ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . Abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . Abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } Console . Write ( " The ▁ closest ▁ pair ▁ is ▁ [ " + ar1 [ res_l ] + " , ▁ " + ar2 [ res_r ] + " ] " ) ; }
int TetracontadigonalNum ( int n ) { return ( 40 * n * n - 38 * n ) / 2 ; }
void possibleAcyclicGraph ( int N ) { Console . Write ( ( int ) Math . Pow ( 2 , N - 1 ) ) ; return ; }
int countOfSubstringWithOnlyOnes ( string s ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { count = s [ i ] == '1' ? count + 1 : 0 ; res = ( res + count ) ; } return res ; }
int nthElement ( int a , int b , int n ) { ArrayList seq = new ArrayList ( ) ; for ( int i = 1 ; i <= n ; i ++ ) seq . Add ( a * i ) ; seq . Sort ( ) ; for ( int i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . Contains ( b * i ) ) { seq . Add ( b * i ) ; seq . Sort ( ) ; k -- ; } } return ( int ) seq [ n - 1 ] ; }
int getSum ( int n , int d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; int k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }
int findCount ( int [ ] arr , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( ( int ) Math . Pow ( ( x - h ) , 2 ) / ( int ) Math . Pow ( a , 2 ) ) + ( ( int ) Math . Pow ( ( y - k ) , 2 ) / ( int ) Math . Pow ( b , 2 ) ) ; return p ; }
int get_last_two_digit ( long N ) { if ( N <= 10 ) { long ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ( int ) ans % 100 ; } return 13 ; }
int findMean ( int [ ] arr , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = ( int ) Math . Floor ( ( double ) sum / count ) ; return mean ; }
int Moves_Calculator ( int x , int y , int row , int col ) { int total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += Math . Min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += Math . Min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += Math . Min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += Math . Min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; int king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; }
int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = ( int ) Math . Pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
int kthgroupsum ( int k ) { return k * k * k ; }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + Math . Min ( Math . Max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
double calcDeterminant ( int [ ] arr ) { double determinant = 0 ; for ( int i = 0 ; i < N ; i ++ ) { determinant += Math . Pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; }
void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { double a = x2 - x1 ; double b = y2 - y1 ; double c = z2 - z1 ; int A = ( int ) ( b * f - c * e ) ; int B = ( int ) ( a * f - c * d ) ; int C = ( int ) ( a * e - b * d ) ; int D = - ( int ) ( A * d - B * e + C * f ) ; Console . Write ( A + " x ▁ + ▁ " + B + " y ▁ + ▁ " + C + " z ▁ + ▁ " + D + " = ▁ 0 ▁ " ) ; }
int Min_Replace ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int [ ] freq = new int [ MAX ] ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } Array . Sort ( freq ) ; Array . Reverse ( freq ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }
long squareDigitSum ( String s ) { long lengthN = s . Length ; long result = ( lengthN / 9 ) * 81 + ( long ) Math . Pow ( ( lengthN % 9 ) , 2 ) ; return result ; }
int counLastDigitK ( int low , int high , int k ) { int mlow = 10 * Convert . ToInt32 ( Math . Ceiling ( low / 10.0 ) ) ; int mhigh = 10 * Convert . ToInt32 ( Math . Floor ( high / 10.0 ) ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; }
int No_of_rectangles ( int L , int B , int l , int b ) { if ( ( l > L ) || ( b > B ) ) { return - 1 ; } else { return ( L - l + 1 ) * ( B - b + 1 ) ; } }
int getGreatestSum ( int [ , ] a ) { int prev_max = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 , j ] ) prev_max = a [ N - 1 , j ] ; int sum = prev_max ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int curr_max = - 2147483648 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i , j ] && a [ i , j ] > curr_max ) curr_max = a [ i , j ] ; if ( curr_max == - 2147483648 ) return - 1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; }
int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
uint countBits ( uint number ) { return ( uint ) Math . Log ( number , 2.0 ) + 1 ; }
void findSymPairs ( int [ , ] arr ) { Dictionary < int , int > hM = new Dictionary < int , int > ( ) ; int val = 0 ; for ( int i = 0 ; i < arr . GetLength ( 0 ) ; i ++ ) { int first = arr [ i , 0 ] ; int sec = arr [ i , 1 ] ; if ( hM . ContainsKey ( sec ) ) val = hM [ sec ] ; if ( val != 0 && val == first ) Console . WriteLine ( " ( " + sec + " , ▁ " + first + " ) " ) ; else hM . Add ( first , sec ) ; } }
void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( int i = 1 ; i <= a ; i ++ ) Console . Write ( " ( ( " ) ; for ( int i = 1 ; i <= c ; i ++ ) Console . Write ( " ) ( " ) ; for ( int i = 1 ; i <= d ; i ++ ) Console . Write ( " ) ) " ) ; for ( int i = 1 ; i <= b ; i ++ ) Console . Write ( " ( ) " ) ; } else Console . Write ( - 1 ) ; }
bool findNoIsDivisibleOrNot ( int [ ] a , int n ) { for ( int i = 0 ; i < a . Length ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
int Next_greater ( int [ ] a , int n , int x ) { Array . Sort ( a ) ; int low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
void findShifts ( int [ ] A , int N ) { int [ ] shift = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( shift [ i ] + " ▁ " ) ; }
double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; }
bool isicositrigonal ( int N ) { float n = ( float ) ( 19 + Math . Sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - ( int ) n ) == 0 ; }
int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return - 1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; }
void sentinelSearch ( int [ ] arr , int n , int key ) { int last = arr [ n - 1 ] ; arr [ n - 1 ] = key ; int i = 0 ; while ( arr [ i ] != key ) i ++ ; arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) Console . WriteLine ( key + " ▁ is ▁ present " + " ▁ at ▁ index ▁ " + i ) ; else Console . WriteLine ( " Element ▁ Not ▁ found " ) ; }
int minOperation ( string s , int i , int j , int count ) { if ( ( i >= s . Length && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] ) return count ; if ( i >= s . Length ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return Math . Min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; }
bool isLowerTriangularMatrix ( int [ , ] mat ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i , j ] != 0 ) return false ; return true ; }
bool isInGivenBase ( String str , int bas ) { if ( bas > 16 ) return false ; else if ( bas <= 10 ) { for ( int i = 0 ; i < str . Length ; i ++ ) if ( ! ( str [ i ] >= '0' && str [ i ] < ( '0' + bas ) ) ) return false ; } else { for ( int i = 0 ; i < str . Length ; i ++ ) if ( ! ( ( str [ i ] >= '0' && str [ i ] < ( '0' + bas ) ) || ( str [ i ] >= ' A ' && str [ i ] < ( ' A ' + bas - 10 ) ) ) ) return false ; } return true ; }
int LowerInsertionPoint ( int [ ] arr , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
int getInvCount ( int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }
int cntSubSets ( int [ ] arr , int n ) { int maxVal = arr . Max ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( int ) ( Math . Pow ( 2 , cnt ) - 1 ) ; }
double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . Sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
Fraction maxFraction ( Fraction first , Fraction sec ) { int a = first . num ; int b = first . den ; int c = sec . num ; int d = sec . den ; int Y = a * d - b * c ; return ( Y > 0 ) ? first : sec ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; }
long countMaxIntersect ( long n ) { return ( n ) * ( n - 1 ) / 2 ; }
void lexNumbers ( int n ) { List < String > s = new List < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . Add ( String . Join ( " " , i ) ) ; } s . Sort ( ) ; List < int > ans = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . Add ( Int32 . Parse ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ans [ i ] + " ▁ " ) ; }
String check ( int k , int d0 , int d1 ) { int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x = 0 ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } int sum = d0 + d1 + ( ( ( k - 3 ) / 4 ) * s + x ) ; if ( sum % 3 == 0 ) return " YES " ; return " NO " ; }
float maxDivision ( int [ ] arr , int n ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; float mxdiv = arr [ 1 ] ; for ( int i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }
void incrementCount ( int [ ] arr , int N ) { int mini = arr [ 0 ] - arr [ 1 ] ; for ( int i = 2 ; i < N ; i ++ ) { mini = Math . Min ( mini , arr [ i - 1 ] - arr [ i ] ) ; } Console . WriteLine ( mini ) ; }
string largestPalinSub ( string s ) { string res = " " ; char mx = s [ 0 ] ; for ( int i = 1 ; i < s . Length ; i ++ ) mx = ( char ) Math . Max ( ( int ) mx , ( int ) s [ i ] ) ; for ( int i = 0 ; i < s . Length ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; }
int countKeyPressed ( String str , int len ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) count = count + arr [ str [ i ] - ' a ' ] ; return count ; }
char increment ( char i ) { int i1 = - ( ~ ( int ) ( i ) ) ; return ( char ) ( i1 ) ; }
int gonNum360 ( int n ) { return ( 358 * n * n - 356 * n ) / 2 ; }
bool onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }
int nthTerm ( int n ) { return ( int ) Math . Pow ( n , 2 ) + 4 * n ; }
string convert ( string str ) { string w = " " , z = " " ; str = str . ToUpper ( ) + " ▁ " ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ▁ ' ) w = w + ch ; else { z = z + ( Char . ToLower ( w [ 0 ] ) ) + w . Substring ( 1 ) + " ▁ " ; w = " " ; } } return z ; }
bool isCheck ( string str ) { int len = str . Length ; string lowerStr = " " , upperStr = " " ; char [ ] str1 = str . ToCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( int ) ( str1 [ i ] ) >= 65 && ( int ) str1 [ i ] <= 91 ) upperStr = upperStr + str1 [ i ] ; else lowerStr = lowerStr + str1 [ i ] ; } String transformStr = lowerStr . ToUpper ( ) ; return ( transformStr . Equals ( upperStr ) ) ; }
void printCharWithFreq ( String str ) { int n = str . Length ; int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] != 0 ) { Console . Write ( str [ i ] ) ; Console . Write ( freq [ str [ i ] - ' a ' ] + " ▁ " ) ; freq [ str [ i ] - ' a ' ] = 0 ; } } }
bool checkIsAP ( int [ ] arr , int n ) { if ( n == 1 ) return true ; Array . Sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
int findMaxNum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int num = arr [ 0 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { num = num * 10 + arr [ i ] ; } return num ; }
void bin ( int n ) { if ( n > 1 ) bin ( n >> 1 ) ; Console . Write ( n & 1 ) ; }
int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( ( ~ a & 1 ) == 1 ) { if ( ( b & 1 ) == 1 ) return gcd ( a >> 1 , b ) ; else return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
int percent ( int a , int b ) { float result = 0 ; result = ( ( b - a ) * 100 ) / a ; return ( int ) result ; }
int pairsInSortedRotated ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . Sqrt ( a ) / 6 ; return area ; }
long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
int maxLength ( string s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = int . MinValue ; s = s + '1' ; for ( int i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == ' o ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == ' x ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == ' x ' ) ) left = 1 ; coun = ( int ) Math . Ceiling ( ( double ) coun / ( right + left ) ) ; max_length = Math . Max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; }
int k_sum ( int [ ] a , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; }
int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
int interpolationSearch ( int [ ] arr , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ; if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return - 1 ; }
> FractionSplit ( long n , long d ) { List < string > UnitFactions = new List < string > ( ) ; while ( n > 0 ) { long x = ( d + n - 1 ) / n ; string s = "1 / " + x . ToString ( ) ; UnitFactions . Add ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }
int minDiff ( int n , int x , int [ ] A ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = Math . Min ( mn , A [ i ] ) ; mx = Math . Max ( mx , A [ i ] ) ; } return Math . Max ( 0 , mx - mn - 2 * x ) ; }
bool sumSquare ( int n ) { for ( long i = 1 ; i * i <= n ; i ++ ) for ( long j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { Console . Write ( i + " ^ 2 ▁ + ▁ " + j + " ^ 2" ) ; return true ; } return false ; }
int minNumber ( int [ ] a , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( true ) { flag = 1 ; x = ( int ) ( Math . Pow ( 2 , i ) ) ; p1 = x * p0 + ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; Console . Write ( " ▁ " + p1 ) ; i ++ ; } }
string getString ( int N ) { string ans = " " ; while ( N >= 26 ) { ans += ' z ' ; N -= 26 ; } ans += ( char ) ( N + ' a ' - 1 ) ; return ans ; }
double areaOftriangle ( int side ) { double a = Math . Sqrt ( Math . Pow ( side / 2 , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double b = Math . Sqrt ( Math . Pow ( side , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double c = Math . Sqrt ( Math . Pow ( side , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double s = ( a + b + c ) / 2 ; double area = Math . Sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area ; }
int lcs ( string X , string Y ) { int m = X . Length , n = Y . Length ; int [ , ] L = new int [ 2 , n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi , j ] = L [ 1 - bi , j - 1 ] + 1 ; else L [ bi , j ] = Math . Max ( L [ 1 - bi , j ] , L [ bi , j - 1 ] ) ; } } return L [ bi , n ] ; }
int stringToInt ( String str ) { if ( str . Length == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . Substring ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * Math . Pow ( 10 , str . Length - 1 ) + y ; return ( int ) ( x ) ; }
int nthSquareCube ( int n ) { return n * n * n * n * n * n ; }
int maxAbsDiff ( int [ ] arr , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . Min ( minEle , arr [ i ] ) ; maxEle = Math . Max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
int findMissing ( int [ ] arr , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; }
void longestSubsequence ( int N , int Q , int [ ] arr , int [ , ] Queries ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i , 0 ] ; int y = Queries [ i , 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } Console . Write ( count + " ▁ " ) ; } }
void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { Console . Write ( ( i * i * i ) + " ▁ " ) ; i ++ ; } }
bool checkEquall ( int [ ] arr , int N ) { int sumEven = 0 , sumOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }
void findNumbers ( int N , int M ) { int m = M ; Dictionary < int , int > remLen = new Dictionary < int , int > ( ) ; int len , remainder = 0 ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( ! remLen . ContainsKey ( remainder ) ) { remLen . Add ( remainder , len ) ; } else { break ; } M = M * 10 + m ; M = M % N ; } int LenA = len ; int LenB = remLen [ remainder ] ; for ( int i = 0 ; i < LenB ; ++ i ) Console . Write ( m ) ; Console . Write ( " ▁ " ) ; for ( int i = 0 ; i < LenA ; ++ i ) Console . Write ( m ) ; }
int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; }
void canSplit ( string S ) { int [ ] frequency = new int [ 26 ] ; int cnt_singles = 0 ; int k = 0 ; for ( int i = 0 ; i < S . Length ; i ++ ) frequency [ S [ i ] - ' a ' ] ++ ; int odd = 0 , eve = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] != 0 ) { odd += ( frequency [ i ] & 1 ) ; eve += frequency [ i ] / 2 ; } } if ( eve >= odd ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int minOperations ( String S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . Length ; j += K ) { if ( S [ j ] == '0' ) zero ++ ; else one ++ ; } ans += Math . Min ( zero , one ) ; } return ans ; }
int maxSumSubarray ( int [ ] arr ) { int i = 0 , j = 1 ; HashSet < int > set = new HashSet < int > ( ) ; set . Add ( arr [ 0 ] ) ; int sum = arr [ 0 ] ; int maxsum = sum ; while ( i < arr . Length - 1 && j < arr . Length ) { if ( ! set . Contains ( arr [ j ] ) ) { sum = sum + arr [ j ] ; maxsum = Math . Max ( sum , maxsum ) ; set . Add ( arr [ j ++ ] ) ; } else { sum -= arr [ i ] ; set . Remove ( arr [ i ++ ] ) ; } } return maxsum ; }
int squaresum ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) for ( int j = i + 1 ; j < arr . Length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; Console . WriteLine ( " Count ▁ of ▁ pairs ▁ is ▁ " + count ) ; }
bool isCenteredpentagonal ( int N ) { float n = ( float ) ( ( 5 + Math . Sqrt ( 40 * N - 15 ) ) / 10 ) ; return ( n - ( int ) n ) == 0 ; }
void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) Console . Write ( " No " ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; Console . WriteLine ( " Yes ▁ " + days ) ; } }
char findExtraCharcter ( char [ ] strA , char [ ] strB ) { int [ ] m1 = new int [ 256 ] ; for ( int i = 0 ; i < strB . Length ; i ++ ) m1 [ strB [ i ] ] ++ ; for ( int i = 0 ; i < strA . Length ; i ++ ) m1 [ strA [ i ] ] -- ; for ( int i = 0 ; i < m1 . Length ; i ++ ) { if ( m1 [ i ] == 1 ) return ( char ) i ; } return char . MinValue ; }
float areacircumscribed ( float a ) { return ( a * a * ( float ) ( PI / 2 ) ) ; }
int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
double Probability ( double [ ] p , int n ) { double [ , ] dp = new double [ n + 1 , n + 1 ] ; dp [ 0 , 0 ] = 1.0 ; for ( int i = 1 ; i <= n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( j == 0 ) dp [ i , j ] = dp [ i - 1 , j ] * ( 1.0 - p [ i ] ) ; else dp [ i , j ] = dp [ i - 1 , j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 , j - 1 ] * p [ i ] ; } } double ans = 0.0 ; for ( int i = ( n + 1 ) / 2 ; i <= n ; i += 1 ) ans += dp [ n , i ] ; return ans ; }
int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }
int powerOfJump ( String s ) { int count = 1 ; int max_so_far = int . MinValue ; char ch = s [ s . Length - 1 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
void replaceOriginal ( String s , int n ) { char [ ] r = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != ' a ' && s [ i ] != ' e ' && s [ i ] != ' i ' && s [ i ] != ' o ' && s [ i ] != ' u ' ) { Console . Write ( r [ i ] ) ; } } Console . WriteLine ( " " ) ; }
void findScoreSum ( int n ) { int total = 0 ; int prev_monday = 0 , curr_day = 0 ; for ( int day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } Console . Write ( total ) ; }
long countWays ( int n ) { long [ , ] dp = new long [ 2 , n + 1 ] ; dp [ 0 , 1 ] = 1 ; dp [ 1 , 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 , i ] = dp [ 0 , i - 1 ] + dp [ 1 , i - 1 ] ; dp [ 1 , i ] = dp [ 0 , i - 1 ] * 2 + dp [ 1 , i - 1 ] ; } return dp [ 0 , n ] + dp [ 1 , n ] ; }
void printDiagonalSums ( int [ , ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i , i ] ; secondary += mat [ i , n - i - 1 ] ; } Console . WriteLine ( " Principal ▁ Diagonal : " + principal ) ; Console . WriteLine ( " Secondary ▁ Diagonal : " + secondary ) ; }
void section ( double x1 , double x2 , double y1 , double y2 , double z1 , double z2 , double m , double n ) { double x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; double y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; double z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; Console . Write ( " ( " + x + " , ▁ " ) ; Console . Write ( y + " , ▁ " ) ; Console . WriteLine ( z + " ) " ) ; }
int maxArea ( float perimeter ) { int length = ( int ) Math . Ceiling ( perimeter / 4 ) ; int breadth = ( int ) Math . Floor ( perimeter / 4 ) ; return length * breadth ; }
int numberOfPairs ( int n ) { int count = 0 ; int i = 1 , j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; }
void pushZerosToEnd ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
int countRotations ( int [ ] arr , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
int sum ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; }
int countPairs ( int [ ] arr , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
int minimumLength ( int x , int y , int z ) { return 1 + Math . Abs ( x - y ) + Math . Abs ( y - z ) ; }
void printNGE ( int [ ] arr , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } Console . WriteLine ( arr [ i ] + " ▁ - - ▁ " + next ) ; } }
void findElements ( int [ ] arr , int n ) { int first = int . MinValue ; int second = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) Console . Write ( arr [ i ] + " ▁ " ) ; }
int KvisibleFromLeft ( int N , int K ) { if ( N == K ) return 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
int maxSubarray ( int [ ] a , int k ) { int n = a . Length ; int answer = 0 ; int start = 0 ; long s = 0 ; Queue < int > dq = new Queue < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; while ( dq . Count != 0 && a [ dq . Peek ( ) ] <= x ) dq . Dequeue ( ) ; dq . Enqueue ( i ) ; s += x ; long cost = ( long ) a [ dq . Peek ( ) ] * ( answer + 1 ) - s ; if ( cost <= ( long ) k ) answer ++ ; else { if ( dq . Peek ( ) == start ) dq . Dequeue ( ) ; s -= a [ start ++ ] ; } } return answer ; }
int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( int ) ( ( ( S - S1 ) / Math . Floor ( ( double ) S ) ) * 60 ) ; return Min ; }
bool isOverflow ( long a , long b ) { if ( a == 0 b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }
int countIncreasing ( int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
void segregate0and1 ( int [ ] arr ) { int type0 = 0 ; int type1 = arr . Length - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else { type0 ++ ; } } }
void check_string_exist ( String S ) { int size = S . Length ; bool check = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( S [ i ] != S [ ( i + 2 ) % size ] ) { check = false ; break ; } } if ( check ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = ( a > b ) ? ( ( a > c ) ? a : c ) : ( ( b > c ) ? b : c ) ; int smallest = ( a < b ) ? ( ( a < c ) ? a : c ) : ( ( b < c ) ? b : c ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } return - 1 ; }
int countkDist ( string str , int k ) { int res = 0 ; int n = str . Length ; int [ ] cnt = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; Array . Clear ( cnt , 0 , cnt . Length ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - ' a ' ] == 0 ) dist_count ++ ; cnt [ str [ j ] - ' a ' ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }
int posOfRightMostDiffBit ( int m , int n ) { return ( int ) Math . Floor ( Math . Log10 ( Math . Pow ( m ^ n , 2 ) ) ) + 2 ; }
void NthTerm ( int n ) { int numerator = ( ( int ) Math . Pow ( n , 2 ) ) - 1 ; int denomeanator = 2 * n - 3 ; Console . WriteLine ( numerator + " / " + denomeanator ) ; }
int minIndex ( int [ ] arr , int n , int pos ) { int num = arr [ pos ] ; int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
int countAPs ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }
int slopeOfNum ( string num , int n ) { int slope = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ; else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; } return slope ; }
void winner ( int [ ] arr , int N ) { if ( N % 2 == 1 ) { Console . Write ( " A " ) ; } else { Console . Write ( " B " ) ; } }
bool isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
int search ( int [ , ] mat , int n , int x ) { if ( n == 0 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( mat [ i , j ] == x ) { Console . Write ( " Element ▁ found ▁ at ▁ ( " + i + " , ▁ " + j + " ) STRNEWLINE " ) ; return 1 ; } } Console . Write ( " ▁ Element ▁ not ▁ found " ) ; return 0 ; }
void findMax ( int [ ] a , int n ) { int [ , ] dp = new int [ n , 2 ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) dp [ i , j ] = 0 ; dp [ 0 , 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 , 1 ] = a [ 0 ] * a [ 1 ] ; for ( i = 1 ; i <= n - 2 ; i ++ ) { dp [ i , 0 ] = Math . Max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) + a [ i + 1 ] ; dp [ i , 1 ] = dp [ i - 1 , 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } Console . WriteLine ( Math . Max ( dp [ n - 2 , 0 ] , dp [ n - 2 , 1 ] ) ) ; }
int sortExceptK ( int [ ] arr , int k , int n ) { int temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; Array . Sort ( arr , 0 , n - 1 ) ; int last = arr [ n - 1 ] ; for ( int i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; return 0 ; }
int findMissing ( int [ ] arr , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return - 1 ; return ( int ) ( num / den ) ; }
void solve ( int n ) { int upper_limit = ( int ) ( Math . Ceiling ( Math . Pow ( n , 1.0 / 4 ) ) ) ; for ( int x = 0 ; x <= upper_limit ; x ++ ) { for ( int y = 0 ; y <= upper_limit ; y ++ ) { int num1 = x * x * x * x ; int num2 = y * y * y * y ; if ( num1 - num2 == n ) { Console . Write ( " x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; return ; } } } Console . Write ( - 1 ) ; }
int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c ; for ( int i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
void bcdToHexaDecimal ( char [ ] s ) { int len = s . Length , check = 0 ; int num = 0 , sum = 0 , mul = 1 ; List < char > ans = new List < char > ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { sum += ( s [ i ] - '0' ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum <= 9 ) ans . Add ( ( char ) ( sum + '0' ) ) ; else ans . Add ( ( char ) ( sum + 55 ) ) ; check = 0 ; sum = 0 ; mul = 1 ; } } len = ans . Count ; for ( int i = len - 1 ; i >= 0 ; i -- ) Console . Write ( ans [ i ] ) ; }
int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
void findNumberOfDigits ( long n , int b ) { int dig = ( int ) ( Math . Floor ( Math . Log ( n ) / Math . Log ( b ) ) + 1 ) ; Console . Write ( " The ▁ Number ▁ of ▁ digits " + " ▁ of ▁ Number ▁ " + n + " ▁ in ▁ base ▁ " + b + " ▁ is ▁ " + dig ) ; }
String checkSameDigits ( int N ) { int length = ( ( int ) Math . Log10 ( N ) ) + 1 ; int M = ( ( int ) Math . Pow ( 10 , length ) - 1 ) / ( 10 - 1 ) ; M *= N % 10 ; if ( M == N ) return " Yes " ; return " No " ; }
void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = Math . Max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; Console . WriteLine ( ans ) ; } else { Console . WriteLine ( ( budget / plastic ) ) ; } }
bool isSubSequence ( string str1 , string str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
int findMinZero ( int p ) { int first = 1 , second = 1 ; int number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
int longestEvenOddSubarray ( int [ ] a , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = Math . Max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return Math . Max ( cnt , longest ) ; }
int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += ( int ) Math . Pow ( i , i ) ; } return nth ; }
int CountMaximum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
int cntSubXor ( int [ ] arr , int N ) { int prefixXor = 0 ; int [ ] Even = new int [ M ] ; int [ ] Odd = new int [ M ] ; int cntSub = 0 ; Odd [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { prefixXor ^= arr [ i ] ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }
bool containsElement ( int [ ] arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; ++ i ) xorArr ^= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { int x = xorArr ^ arr [ i ] ; if ( arr [ i ] == x ) return true ; } return false ; }
int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( int ) ( Math . Pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }
int maxLenSub ( int [ ] arr , int n ) { int [ ] mls = new int [ n ] ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . Abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
int getMinCost ( int [ ] arr , int n ) { int min_ele = arr . Min ( ) ; return min_ele * ( n - 1 ) ; }
string getResult ( string st ) { int sum = 0 ; int length = st . Length ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + ( int ) Math . Pow ( st [ i ] - '0' , length ) ; } int number = int . Parse ( st ) ; if ( number == sum ) return " yes " ; else return " no " ; }
bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
void printSeries ( int n ) { int k = 2 ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( k * ( 2 * k - 1 ) + " ▁ " ) ; k += 2 ; } Console . WriteLine ( ) ; }
void findCommon ( int [ ] ar1 , int [ ] ar2 , int [ ] ar3 ) { int i = 0 , j = 0 , k = 0 ; while ( i < ar1 . Length && j < ar2 . Length && k < ar3 . Length ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { Console . Write ( ar1 [ i ] + " ▁ " ) ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } }
bool isEditDistanceOne ( String s1 , String s2 ) { int m = s1 . Length , n = s2 . Length ; if ( Math . Abs ( m - n ) > 1 ) return false ; int count = 0 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; else { i ++ ; j ++ ; } count ++ ; } else { i ++ ; j ++ ; } } if ( i < m < n ) count ++ ; return count == 1 ; }
int maxSubStrings ( String s , int k ) { int maxSubStr = 0 , n = s . Length ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ( char ) ( ( int ) ' a ' + c ) ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s [ i ] != ch ) continue ; int cnt = 0 ; while ( i < n && s [ i ] == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = Math . Max ( maxSubStr , curr ) ; } return maxSubStr ; }
int largestSubset ( int [ ] a , int n ) { int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) mxm = Math . Max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; } return dp . Max ( ) ; }
bool checking ( string s ) { int c = 0 ; int n = s . Length ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' ) c ++ ; if ( c >= 6 && s [ i ] == '1' ) return true ; } return false ; }
int mininsert ( int [ ] arr , int K , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = Math . Min ( arr [ i ] , arr [ i + 1 ] ) ; int b = Math . Max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }
int findMaxValByRearrArr ( int [ ] arr , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; }
int nthTerm ( int n ) { return 4 * ( int ) Math . Pow ( n , 2 ) - 7 * n + 3 ; }
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
double find_Variance ( int n ) { long numerator = n * n - 1 ; double ans = ( numerator * 1.0 ) / 12 ; return ans ; }
int solve ( int [ ] a , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . Abs ( min1 - max1 ) ; }
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( true ) { flag = 1 ; x = ( int ) ( Math . Pow ( 2 , i ) ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; Console . Write ( p1 + " ▁ " ) ; i ++ ; } }
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }
void makePolygon ( double a ) { double n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
int minOperations ( int [ ] arr , int n ) { int oddcount = 0 , evencount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return Math . Min ( oddcount , evencount ) ; }
int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
void count ( string str1 , string str2 ) { int c = 0 , j = 0 ; for ( int i = 0 ; i < str1 . Length ; i ++ ) { if ( str2 . IndexOf ( str1 [ i ] ) >= 0 ) { c += 1 ; } } Console . WriteLine ( " No . ▁ of ▁ matching ▁ characters ▁ are : ▁ " + c ) ; }
int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
void printSeriesSum ( int N ) { double sum = 0 ; int a = 1 ; int cnt = 0 ; bool flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag == true ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } Console . WriteLine ( sum ) ; }
void printAllSubStrings ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { char [ ] temp = new char [ n - i + 1 ] ; int tempindex = 0 ; for ( int j = i ; j < n ; j ++ ) { temp [ tempindex ++ ] = s [ j ] ; temp [ tempindex ] = ' \0' ; Console . WriteLine ( temp ) ; } } }
int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
void printSubsequences ( int [ ] arr , int n ) { int opsize = ( int ) Math . Pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) Console . Write ( arr [ j ] + " ▁ " ) ; } Console . WriteLine ( ) ; } }
void printLastChar ( string str ) { str = str + " ▁ " ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( str [ i ] == ' ▁ ' ) Console . Write ( str [ i - 1 ] + " ▁ " ) ; } }
void rad ( double d , double h ) { Console . WriteLine ( " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; }
int maxDiff ( int [ ] arr , int n ) { int maxDiff = - 1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
int countDivisibleSubseq ( string str , int n ) { int len = str . Length ; int [ , ] dp = new int [ len , n ] ; dp [ 0 , ( str [ 0 ] - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i , ( str [ i ] - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i , j ] += dp [ i - 1 , j ] ; dp [ i , ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 , j ] ; } } return dp [ len - 1 , 0 ] ; }
void printDivisors ( int n ) { for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) Console . Write ( i + " ▁ " ) ; else Console . Write ( i + " ▁ " + n / i + " ▁ " ) ; } } }
int countDecreasing ( int [ ] A , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; Console . Write ( count ) ; }
int minSteps ( int N ) { int count = 1 , res = 0 ; for ( int i = 1 ; i <= N ; i += count ) { res = Math . Max ( res , count ) ; count ++ ; } return res ; }
int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) { int [ ] maxRev = new int [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . Max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . Max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
int countSticks ( string str ) { int cnt = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( ch >= ' A ' && ch <= ' Z ' ) { cnt += sticks [ ch - ' A ' ] ; } else { cnt += number [ ch - '0' ] ; } } return cnt ; }
long product ( int [ , ] mat , int n ) { long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i , i ] ; d2 += mat [ i , n - i - 1 ] ; } return 1L * d1 * d2 ; }
bool isPerfectSquareString ( string str ) { int sum = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] ; double squareRoot = Math . Sqrt ( sum ) ; double F = Math . Floor ( squareRoot ) ; return ( ( squareRoot - F ) == 0 ) ; }
int countTrailingZeroes ( int N ) { int res = ( int ) Math . Log ( N ^ ( N - 1 ) , 2.0 ) ; if ( res >= 0 ) return res ; else return 0 ; }
int subArraySum ( int [ ] arr , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; Console . Write ( " Sum ▁ found ▁ between ▁ " + " indexes ▁ " + i + " ▁ and ▁ " + p ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } Console . Write ( " No ▁ subarray ▁ found " ) ; return 0 ; }
void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) Console . Write ( y + " ▁ " + x + " ▁ " ) ; else Console . Write ( x + " ▁ " + y + " ▁ " ) ; } }
void findX ( int targetValue ) { int start = 0 , end = targetValue ; int mid = 0 , result = 0 ; while ( start <= end ) { mid = start + ( end - start ) / 2 ; if ( mid * mid <= targetValue ) { result = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } Console . Write ( result + " STRNEWLINE " ) ; }
double area ( int R ) { double Base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * Base * height ; return area ; }
int maximum_toys ( int [ ] cost , int N , int K ) { int count = 0 , sum = 0 ; Array . Sort ( cost ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
void minCost ( int [ ] arr ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } Console . Write ( Math . Min ( even , odd ) ) ; }
double trianglearea ( double a ) { if ( a < 0 ) return - 1 ; double area = ( 3 * Math . Sqrt ( 3 ) * Math . Pow ( a , 2 ) ) / 4 ; return Math . Round ( area , 4 ) ; }
int maxEvenIntegers ( int [ ] arr , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . Max ( ans , cnt ) ; } return ans ; }
int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; }
int lengthOfLastWord ( string a ) { int len = 0 ; string x = a . Trim ( ) ; for ( int i = 0 ; i < x . Length ; i ++ ) { if ( x [ i ] == ' ▁ ' ) { len = 0 ; } else { len ++ ; } } return len ; }
int repUnitValue ( int n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return ( sum / n ) ; }
int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
int maxSum ( int [ ] a , int n , int k ) { if ( n <= 0 ) return 0 ; int option = maxSum ( a , n - 1 , k ) ; if ( k >= a [ n - 1 ] ) option = Math . Max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) ; return option ; }
new StringBuilder ( ) ; public static String processWords ( String input ) { String [ ] s = input . Split ( ' ▁ ' ) ; foreach ( String values in s ) { charBuffer . Append ( values [ 0 ] ) ; } return charBuffer . ToString ( ) ; }
int countPairs ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
int get_max_splits ( String num_String ) { int count = 0 , current_num ; int running_sum = 0 ; for ( int i = 0 ; i < num_String . Length ; i ++ ) { current_num = num_String [ i ] - '0' ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; }
bool isicosihenagonal ( int N ) { float n = ( float ) ( ( 17 + Math . Sqrt ( 152 * N + 289 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; }
int calculateTriangles ( int [ ] sides ) { double count = Math . Pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= Math . Pow ( sides [ 0 ] , 2 ) ; count -= Math . Pow ( sides [ 2 ] , 2 ) ; count -= Math . Pow ( sides [ 4 ] , 2 ) ; return ( int ) ( count ) ; }
int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . Max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . Pow ( i , i ) ; int numerator = ( int ) Math . Pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
int findMinSum ( int [ ] arr , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * ( int ) Math . Pow ( 2 , occ ) ; occ -- ; } return sum ; }
int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }
int sumBetweenTwoKth ( int [ ] arr , int n , int k1 , int k2 ) { Array . Sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
long minOperations ( long n ) { long count = 0 ; long d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = Math . Max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = Math . Max ( d , n - 1 ) ; count += Math . Abs ( d ) ; return count - 1 ; }
void findNumbers ( int n ) { int odd = ( int ) Math . Pow ( 10 , n ) - 1 ; int even = odd - 1 ; Console . WriteLine ( " Even ▁ = ▁ " + even ) ; Console . Write ( " Odd ▁ = ▁ " + odd ) ; }
void RemoveHTMLTags ( String str ) { System . Text . RegularExpressions . Regex rx = new System . Text . RegularExpressions . Regex ( " < [ ^ > ] * > " ) ; str = rx . Replace ( str , " " ) ; Console . WriteLine ( str ) ; }
Node deleteAlt ( Node head ) { if ( head == null ) return ; Node node = head . next ; if ( node == null ) return ; head . next = node . next ; head . next = deleteAlt ( head . next ) ; }
void findXOR ( int [ , , ] mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i , i , i ] ; XOR ^= mat [ i , i , N - i - 1 ] ; } Console . Write ( XOR ) ; }
int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }
int countSegments ( int [ ] a , int n , int x ) { bool flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
void sumOfInfiniteAGP ( double a , double d , double r ) { double ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; Console . Write ( ans ) ; }
int findSubstrings ( string s , int k ) { int ans = 0 ; int [ ] cnt = new int [ 26 ] ; int i , j , n = s . Length ; for ( i = 0 ; i < n ; i ++ ) { Array . Clear ( cnt , 0 , cnt . Length ) ; for ( j = i ; j < n ; j ++ ) { cnt [ s [ j ] - ' a ' ] ++ ; if ( cnt [ s [ j ] - ' a ' ] <= k ) ans ++ ; else break ; } } return ans ; }
bool isRefactorableNumber ( int n ) { int divCount = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
void countSubString ( String s ) { int res = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { int x = 0 ; for ( int j = i ; j < s . Length ; j ++ ) { int temp = 1 << s [ j ] - ' a ' ; x ^= temp ; if ( ( x & ( x - 1 ) ) == 0 ) res ++ ; } } Console . Write ( res ) ; }
void LCMPairs ( int [ ] arr , int N ) { int total_pairs = ( N * ( N - 1 ) ) / 2 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; Console . Write ( " Even ▁ = ▁ " + ( total_pairs - odd ) + " , ▁ Odd ▁ = ▁ " + odd ) ; }
void rotate90Clockwise ( int [ , ] arr ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) Console . Write ( arr [ i , j ] + " ▁ " ) ; Console . WriteLine ( ) ; } }
int nthTerm ( int n ) { int An = ( ( int ) Math . Pow ( 1 , n ) + ( int ) Math . Pow ( 2 , n ) ) * ( int ) Math . Pow ( 3 , n ) ; return An ; }
string minInt ( char [ ] str ) { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( ( int ) str [ i ] >= ( int ) ( '5' ) ) { str [ i ] = ( char ) ( ( ( int ) ( '9' ) - ( int ) ( str [ i ] ) ) + ( int ) ( '0' ) ) ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '9' ; string s = new string ( str ) ; return s ; }
bool checkFibinnary ( int n ) { int prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; }
int MinimumMoves ( int [ ] A , int [ ] B , int N ) { int totalOperations = 0 ; int carry = 0 ; int K = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int nearestMultiple = ( int ) ( Math . Ceiling ( ( double ) ( A [ i ] + carry ) / ( double ) ( B [ i ] ) ) * B [ i ] ) ; K = nearestMultiple - ( A [ i ] + carry ) ; totalOperations += K ; carry += K ; } return totalOperations ; }
int countConsecutive ( String s ) { int count = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { i ++ ; } else { count ++ ; } } return count ; }
bool ishendecagonal ( int N ) { double n = ( 7 + Math . Sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; else cnt = cnt + 2 ; } } return cnt ; }
int countTriplets ( int [ ] a , int n ) { List < int > s = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . Add ( a [ i ] ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int xr = a [ i ] ^ a [ j ] ; if ( s . Exists ( item => item == xr ) && xr != a [ i ] && xr != a [ j ] ) count ++ ; } } return count / 3 ; }
float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
String make_palindrome ( String S1 , String S2 , String S3 ) { int maskA = 0 , maskC = 0 ; foreach ( char i in S1 . ToCharArray ( ) ) maskA |= ( 1 << ( i - ' a ' ) ) ; foreach ( char i in S3 . ToCharArray ( ) ) maskC |= ( 1 << ( i - ' a ' ) ) ; if ( ( maskA & maskC ) > 0 ) return " YES " ; return " NO " ; }
void countPermutations ( int N , int B ) { int x = ( int ) Math . Pow ( B , N ) ; int y = ( int ) Math . Pow ( B , N - 1 ) ; Console . WriteLine ( x - y ) ; }
double Perimeter ( double s , int n ) { double perimeter = 1 ; perimeter = n * s ; return perimeter ; }
int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }
int countOfBinaryNumberLessThanN ( int N ) { Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( 1 ) ; int cnt = 0 ; int t ; while ( q . Count > 0 ) { t = q . Peek ( ) ; q . Dequeue ( ) ; if ( t <= N ) { cnt ++ ; q . Enqueue ( t * 10 ) ; q . Enqueue ( t * 10 + 1 ) ; } } return cnt ; }
void convertToDecimal ( int N ) { Console . Write ( " Decimal ▁ number ▁ of ▁ " + N + " ▁ is : ▁ " ) ; if ( N != 0 ) { int decimalNumber = 0 ; int i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N /= 10 ; decimalNumber += remainder * ( int ) Math . Pow ( 3 , i ) ; ++ i ; } Console . Write ( decimalNumber + " STRNEWLINE " ) ; } else Console . Write ( "0" + " STRNEWLINE " ) ; }
int minApples ( int M , int K , int N , int S , int W , int E ) { if ( M <= S * K ) return M ; else if ( M <= S * K + E + W ) return S * K + ( M - S * K ) * K ; else return - 1 ; }
String getMinNumberForPattern ( String seq ) { int n = seq . Length ; if ( n >= 9 ) return " - 1" ; char [ ] result = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return new String ( result ) ; }
float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }
bool pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; Console . WriteLine ( " Odd ▁ = ▁ " + odd_count ) ; Console . WriteLine ( " Even ▁ = ▁ " + even_count ) ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . Max ( l , a ) ; int R = Math . Min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( int ) Math . Pow ( i , i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
int countRotation ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }
float circlearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( float ) ( 3.14 * Math . Pow ( l / 2 , 2 ) ) ; else return ( float ) ( 3.14 * Math . Pow ( b / 2 , 2 ) ) ; }
void printPascal ( int n ) { int [ , ] arr = new int [ n , n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line , i ] = 1 ; else arr [ line , i ] = arr [ line - 1 , i - 1 ] + arr [ line - 1 , i ] ; Console . Write ( arr [ line , i ] ) ; } Console . WriteLine ( " " ) ; } }
int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; }
int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return - 1 ; }
int equvInverse ( int [ ] arr , int N , int P ) { int cntElem = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; }
int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = Math . Min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
int search ( int [ ] arr , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
void minOpsToEmptyString ( string S , int N ) { int one = 0 , zero = 0 ; int x0 = 0 , x1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '0' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = Math . Max ( x0 , zero ) ; one = Math . Max ( x1 , one ) ; } Console . WriteLine ( Math . Max ( one , zero ) ) ; }
int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
int getOccurence ( int n , int d ) { int result = 0 ; int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
int rankLessThanK ( int [ ] arr , int k , int n ) { int rank = 1 ; int position = 1 ; Array . Sort ( arr ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
void getMax ( int [ ] arr , int N , int K ) { for ( int i = 1 ; i < N ; i ++ ) { int cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } Console . Write ( arr [ 0 ] ) ; }
int findMinimumK ( int [ ] a , int n , int S ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return ( int ) Math . Ceiling ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) ; }
bool isPath ( int [ , ] arr ) { arr [ 0 , 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ i , 0 ] != - 1 ) arr [ i , 0 ] = arr [ i - 1 , 0 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 , j ] != - 1 ) arr [ 0 , j ] = arr [ 0 , j - 1 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i , j ] != - 1 ) arr [ i , j ] = Math . Max ( arr [ i , j - 1 ] , arr [ i - 1 , j ] ) ; return ( arr [ 5 - 1 , 5 - 1 ] == 1 ) ; }
int getResult ( int n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; }
int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
int TotalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . Max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
float Depreciation ( float v , float r , float t ) { float D = ( float ) ( v * Math . Pow ( ( 1 - r / 100 ) , t ) ) ; return D ; }
float geometricMean ( int [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) Math . Log ( arr [ i ] ) ; sum = sum / n ; return ( float ) Math . Exp ( sum ) ; }
bool isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
int Octadecagonal_num ( int n ) { return ( 16 * n * n - 14 * n ) / 2 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
bool isDivisible ( int n ) { int d ; while ( n / 100 > 0 ) { d = n % 10 ; n /= 10 ; n = Math . Abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
bool checkIsFibonacci ( int [ ] arr , int n ) { if ( n == 1 n == 2 ) return true ; Array . Sort ( arr ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; } return true ; }
int truncMod ( int a , int n ) { int q = a / n ; return a - n * q ; }
int angle ( int n ) { return 2 * n ; }
int smallestNumber ( int N ) { return ( int ) ( N * Math . Ceiling ( Math . Pow ( 10 , ( N - 1 ) ) / N ) ) ; }
int checkArray ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }
void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; Console . Write ( f1 + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) Console . Write ( f3 + " ▁ " ) ; f1 = f2 ; f2 = f3 ; } }
String findWinner ( int [ ] A , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " Alice " ; else return " Bob " ; }
void expectedValue ( int P , int a , int b , int N ) { double expValue = P + ( N * 0.5 * ( a + b ) ) ; Console . Write ( expValue ) ; }
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; }
String FirstAndLast ( String str ) { char [ ] ch = str . ToCharArray ( ) ; for ( int i = 0 ; i < ch . Length ; i ++ ) { int k = i ; while ( i < ch . Length && ch [ i ] != ' ▁ ' ) i ++ ; ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return new String ( ch ) ; }
int countWays ( int N ) { if ( N < 4 ) return 0 ; int ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; int s = 0 ; for ( int i = 2 ; i <= N - 3 ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }
int minProd ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return Math . Max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return Math . Max ( X - ( N - Y + 1 ) , 1 ) ; }
void checksum ( int n , int k ) { float first_term = ( float ) ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - ( int ) ( first_term ) == 0 ) { for ( int i = ( int ) first_term ; i <= first_term + k - 1 ; i ++ ) { Console . Write ( i + " ▁ " ) ; } } else Console . Write ( " - 1" ) ; }
void maxSubsequenceLen ( string s , int K ) { int N = s . Length ; int start = 0 , end = 0 ; char [ ] S = s . ToCharArray ( ) ; Array . Sort ( S ) ; int ans = Int32 . MinValue , sum = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum = sum + ( S [ end ] - ' a ' ) ; while ( sum + K < ( S [ end ] - ' a ' ) * ( end - start + 1 ) ) { sum = sum - ( S [ start ] - ' a ' ) ; start ++ ; } ans = Math . Max ( ans , end - start + 1 ) ; } Console . WriteLine ( ans ) ; }
float cyl ( float a ) { if ( a < 0 ) return - 1 ; float r = ( 2 * a * ( float ) ( Math . Sqrt ( 2 ) ) / 3 ) ; float h = ( 2 * a ) / 3 ; float V = ( 3.14f * ( float ) ( Math . Pow ( r , 2 ) * h ) ) ; return V ; }
int findNumber ( int N ) { int count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }
int lastElement ( int [ ] a , int n ) { int steps = 1 ; List < int > [ ] v = new List < int > [ N ] ; for ( int i = 0 ; i < N ; i ++ ) v [ i ] = new List < int > ( ) ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . Add ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . Count > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . Count ; i += 2 ) { if ( steps % 2 == 1 ) v [ steps ] . Add ( v [ steps - 1 ] [ i ] v [ steps - 1 ] [ i + 1 ] ) ; v [ steps ] . Add ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) ; } } return v [ steps ] [ 0 ] ; }
void prevGreater ( int [ ] arr , int n ) { Stack < int > s = new Stack < int > ( ) ; s . Push ( arr [ 0 ] ) ; Console . Write ( " - 1 , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( s . Count != 0 && s . Peek ( ) < arr [ i ] ) s . Pop ( ) ; if ( s . Count == 0 ) Console . Write ( " - 1 , ▁ " ) ; else Console . Write ( s . Peek ( ) + " , ▁ " ) ; s . Push ( arr [ i ] ) ; } }
bool checkrules ( String s ) { if ( s . Length == 0 ) return true ; if ( s [ 0 ] != '1' ) return false ; if ( s . Length > 2 ) { if ( s [ 1 ] == '0' && s [ 2 ] == '0' ) return checkrules ( s . Substring ( 3 ) ) ; } return checkrules ( s . Substring ( 1 ) ) ; }
String printDemlo ( String str ) { int len = str . Length ; String res = " " ; for ( int i = 1 ; i <= len ; i ++ ) res += i . ToString ( ) ; for ( int i = len - 1 ; i >= 1 ; i -- ) res += i . ToString ( ) ; return res ; }
String encryptString ( String str , int n ) { int i = 0 , cnt = 0 ; String encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; }
bool isReachable ( long x1 , long y1 , long x2 , long y2 ) { while ( x2 > x1 && y2 > y1 ) { if ( x2 > y2 ) x2 %= y2 ; else y2 %= x2 ; } if ( x2 == x1 ) return ( y2 - y1 ) >= 0 && ( y2 - y1 ) % x1 == 0 ; else if ( y2 == y1 ) return ( x2 - x1 ) >= 0 && ( x2 - x1 ) % y1 == 0 ; else return false ; }
bool isEven ( string s1 ) { int l = s1 . Length ; bool dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( s1 [ i ] == '0' && dotSeen == false ) continue ; if ( s1 [ i ] == ' . ' ) { dotSeen = true ; continue ; } if ( ( s1 [ i ] - '0' ) % 2 == 0 ) return true ; return false ; } return false ; }
int sum ( int n ) { int ans = ( n * ( n - 1 ) ) / 2 ; return ans ; }
void checkString ( string s , int k ) { int n = s . Length ; if ( 2 * k + 1 > n ) { Console . Write ( " No " ) ; return ; } string a = s . Substring ( 0 , k ) ; string b = s . Substring ( n - k , k ) ; char [ ] arr = b . ToCharArray ( ) ; Array . Reverse ( arr ) ; b = new String ( arr ) ; if ( a == b ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- > 0 ) { result = ( int ) Math . Pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
void findUniqueElements ( int [ ] arr , int N , int K ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) s . Add ( arr [ i ] ) ; int arr_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr_sum += arr [ i ] ; int set_sum = 0 ; foreach ( int i in s ) set_sum += i ; Console . WriteLine ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ; }
int printOddFactorNumber ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) Console . Write ( i + " ▁ " ) ; } return 0 ; }
int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
void meanVector ( int [ , ] mat ) { Console . Write ( " [ ▁ " ) ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j , i ] ; mean = sum / rows ; Console . Write ( ( int ) mean + " ▁ " ) ; } Console . Write ( " ] " ) ; }
int nextPowerOfFour ( int n ) { int x = ( int ) Math . Floor ( Math . Sqrt ( Math . Sqrt ( n ) ) ) ; if ( Math . Pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return ( int ) Math . Pow ( x , 4 ) ; } }
bool isPossibleToZero ( int [ ] a , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
double getSum ( int a , int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . Pow ( a , i ) ) ; } return sum ; }
int findCount ( string s , int n , int a , int b ) { int res = 0 ; for ( int i = 0 ; i < b ; i ++ ) { if ( i == a ) { if ( s [ n - i - 1 ] != '1' ) res += 1 ; } else { if ( s [ n - i - 1 ] != '0' ) res += 1 ; } } return res ; }
bool areSame ( List < int > a , List < int > b ) { a . Sort ( ) ; b . Sort ( ) ; return ( a == b ) ; }
int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
int countPairs ( int [ ] A , int n ) { int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }
int find_maximum_value ( int [ ] a , int n ) { int sum = 0 ; int minimum = int . MaxValue ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = Math . Min ( minimum , Math . Abs ( a [ i ] ) ) ; sum += Math . Abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }
bool iszygodromeNum ( int N ) { String s = N . ToString ( ) ; s = ' ▁ ' + s + ' ▁ ' ; for ( int i = 1 ; i < s . Length - 1 ; i ++ ) { if ( s [ i ] != s [ i - 1 ] && s [ i ] != s [ i + 1 ] ) { return false ; } } return true ; }
String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return " Yes " ; return " No " ; }
int maximumXOR ( int [ ] arr , int n , int K ) { K ++ ; int maxXor = Int32 . MinValue ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { if ( Convert . ToString ( i , 2 ) . Count ( c => c == '1' ) == K ) { int cur_xor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) cur_xor = cur_xor ^ arr [ j ] ; } maxXor = Math . Max ( maxXor , cur_xor ) ; } } return maxXor ; }
int rotateRec ( int n , int [ ] L , int [ ] B ) { int m = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . Max ( L [ i ] , B [ i ] ) <= m ) m = Math . Max ( L [ i ] , B [ i ] ) ; else if ( Math . Min ( L [ i ] , B [ i ] ) <= m ) m = Math . Min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
int minMaxProduct ( int [ ] arr1 , int [ ] arr2 , int n1 , int n2 ) { Array . Sort ( arr1 ) ; Array . Sort ( arr2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }
> calculate ( int [ ] arr ) { int n = arr . Length ; List < int > ans = new List < int > ( ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < arr . Length ; j ++ ) { sum += Math . Abs ( arr [ i ] - arr [ j ] ) ; } ans . Add ( sum ) ; } return ans ; }
void predictTheWinner ( int K , int N ) { if ( N % ( K + 1 ) == 0 ) Console . WriteLine ( " Bob " ) ; else Console . WriteLine ( " Alice " ) ; }
long findF_N ( long n ) { long ans = 0 ; for ( long i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
bool check ( String str ) { int n = str . Length ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - '0' ) * 100 + ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; int fourth_last = str [ n - 4 ] - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
void printArray ( int [ ] a , int n ) { Array . Sort ( a ) ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( i == j ) { Console . Write ( a [ i ] + " ▁ " ) ; } else { Console . Write ( a [ j ] + " ▁ " ) ; Console . Write ( a [ i ] + " ▁ " ) ; } i = i + 1 ; j = j - 1 ; } Console . WriteLine ( ) ; }
int setKthBit ( int n , int k ) { return ( ( 1 << k ) n ) ; }
int findMaxValue ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int ans = arr [ n - 1 ] ; int maxPossible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }
int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
int countDirectPath ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; }
void minimumOperations ( int [ ] arr , int N ) { int oddCnt = 0 , evenCnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } Console . Write ( Math . Min ( oddCnt , evenCnt ) ) ; }
void allCharactersSame ( string s ) { HashSet < char > s1 = new HashSet < char > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) s1 . Add ( s [ i ] ) ; if ( s1 . Count == 1 ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
double getSum ( int n ) { double sum = 0 ; int k = ( int ) Math . Sqrt ( n ) ; for ( int i = 1 ; i <= k ; i ++ ) { sum += Math . Floor ( ( double ) n / i ) ; } sum *= 2 ; sum -= Math . Pow ( k , 2 ) ; return sum ; }
String lexNext ( String str , int n ) { char [ ] s = str . ToCharArray ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return new String ( s ) ; } s [ i ] = ' a ' ; } return null ; }
int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . Min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
void UpperHessenbergMatrix ( int n ) { Random rand = new Random ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i > j + 1 ) Console . Write ( 0 + " ▁ " ) ; else Console . Write ( rand . Next ( 1 , 10 ) + " ▁ " ) ; } Console . WriteLine ( ) ; } }
void CountTriangles ( int [ ] A ) { int n = A . Length ; Array . Sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } Console . Write ( " No ▁ of ▁ possible ▁ solutions : ▁ " + count ) ; }
void checkEvenOdd ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { Console . Write ( " Even " ) ; return ; } } Console . Write ( " Odd " ) ; }
void countSubsequence ( string s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s [ i ] ) { case ' G ' : cntG ++ ; result += C ; break ; case ' F ' : cntF ++ ; C += cntG ; break ; default : continue ; } } Console . WriteLine ( result ) ; }
int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }
bool isPower ( int x , int y ) { int res1 = ( int ) Math . Log ( y ) / ( int ) Math . Log ( x ) ; double res2 = Math . Log ( y ) / Math . Log ( x ) ; return ( res1 == res2 ) ; }
int search ( int [ ] arr , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . Abs ( arr [ i ] - x ) ; } Console . WriteLine ( " number ▁ is ▁ not " + " ▁ present ! " ) ; return - 1 ; }
bool isPerfectCubeString ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) sum += ( int ) str [ i ] ; double cr = Math . Round ( Math . Pow ( sum , ( double ) 1 / 3 ) ) ; return ( cr * cr * cr == sum ) ; }
bool isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
int absSumDidd ( int [ ] a ) { Array . Sort ( a ) ; int midValue = a [ a . Length / 2 ] ; int sum = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { sum = sum + Math . Abs ( a [ i ] - midValue ) ; } return sum ; }
bool is_rtol ( String s ) { int tmp = ( int ) ( Math . Sqrt ( s . Length ) ) - 1 ; char first = s [ tmp ] ; for ( int pos = tmp ; pos < s . Length - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
int maxXOR ( int n , int k ) { int c = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
bool isAlphabaticOrder ( string s ) { int n = s . Length ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; }
void findEquation ( int S , int M ) { Console . Write ( "1 ▁ " + ( ( - 1 ) * S ) + " ▁ " + M ) ; }
void printMaxOfMin ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = int . MinValue ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } Console . Write ( maxOfMin + " ▁ " ) ; } }
int minStepToDeleteString ( string str ) { int N = str . Length ; int [ , ] dp = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i , j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i , j ] = 1 ; else { dp [ i , j ] = 1 + dp [ i + 1 , j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i , j ] = Math . Min ( 1 + dp [ i + 2 , j ] , dp [ i , j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i , j ] = Math . Min ( dp [ i + 1 , K - 1 ] + dp [ K + 1 , j ] , dp [ i , j ] ) ; } } } return dp [ 0 , N - 1 ] ; }
double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
float harmonicMean ( int [ ] arr , int [ ] freq , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return ( frequency_sum / sum ) ; }
int number_of_tower ( int [ ] house , int range , int n ) { Array . Sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
double calculate_angle ( double n ) { double total_angle = 360 ; return total_angle / n ; }
int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = Math . Min ( c2 , Math . Min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . Min ( c2 , c1 ) * 12 ; return sum ; }
int findCount ( string str1 , string str2 ) { int len = str1 . Length ; int len2 = str2 . Length ; int ans = Int32 . MaxValue ; int [ ] hash1 = new int [ 26 ] ; int [ ] hash2 = new int [ 26 ] ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] != 0 ) ans = Math . Min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
void transpose ( int [ , ] A , int [ , ] B ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i , j ] = A [ j , i ] ; }
String maxValue ( char [ ] a , char [ ] b ) { Array . Sort ( b ) ; int n = a . Length ; int m = b . Length ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return String . Join ( " " , a ) ; }
long minSum ( int n , int [ ] num , int [ ] price ) { long [ ] dp = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = int . MaxValue ; long ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = ( long ) Math . Min ( ( long ) dp [ j ] , ( long ) price [ i ] + ( long ) price [ j ] ) ; ans = Math . Min ( ans , ( long ) dp [ i ] + ( long ) price [ j ] ) ; } } } return ans != int . MaxValue ? ans : - 1 ; }
void nearestPowerOfTwo ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int lg = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ; int a = ( int ) ( Math . Pow ( 2 , lg ) ) ; int b = ( int ) ( Math . Pow ( 2 , lg + 1 ) ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) Console . Write ( a + " ▁ " ) ; else Console . Write ( b + " ▁ " ) ; } }
void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { z1 = - d1 / c1 ; d = Math . Abs ( ( c2 * z1 + d2 ) ) / ( float ) ( Math . Sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; Console . Write ( " Perpendicular ▁ distance ▁ is ▁ " + d ) ; } else Console . Write ( " Planes ▁ are ▁ not ▁ parallel " ) ; }
void printClosest ( int [ ] arr , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = int . MaxValue ; while ( r > l ) { if ( Math . Abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . Abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } Console . Write ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; }
void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { Console . WriteLine ( " The ▁ shortest ▁ distance ▁ " + " between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " + ( Math . Sqrt ( ( Math . Pow ( ( x2 - x1 ) , 2 ) ) + ( Math . Pow ( ( y2 - y1 ) , 2 ) ) ) - r ) ) ; }
int calculateSum ( int n ) { return ( int ) Math . Pow ( n * ( n + 1 ) / 2 , 2 ) ; }
int solve ( int X , int Y ) { if ( X > Y ) { int temp = X ; X = Y ; Y = temp ; } if ( X == Y ) Console . WriteLine ( 0 ) ; else if ( Y % X == 0 ) Console . WriteLine ( 1 ) ; else Console . WriteLine ( 2 ) ; return 0 ; }
float Area_of_Triangle ( int a , int b , int k ) { float area = ( float ) ( ( 1 / 2.0 ) * a * b * Math . Sin ( k ) ) ; return area ; }
int findMaxCock ( int [ , ] ar ) { if ( R < 3 C < 3 ) return - 1 ; int max_sum = int . MinValue ; for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) { int sum = ( ar [ i , j ] + ar [ i , j + 2 ] ) + ( ar [ i + 1 , j + 1 ] ) + ( ar [ i + 2 , j ] + ar [ i + 2 , j + 1 ] + ar [ i + 2 , j + 2 ] ) ; max_sum = Math . Max ( max_sum , sum ) ; } } return max_sum ; }
int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
void minAdjDifference ( int [ ] arr , int n ) { if ( n < 2 ) return ; int res = Math . Abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = Math . Min ( res , Math . Abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . Min ( res , Math . Abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; Console . Write ( " Min ▁ Difference ▁ = ▁ " + res ) ; }
int getInvCount ( int [ ] arr , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
int Segment ( int [ ] x , int [ ] l , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; }
void countCharacterType ( string str ) { int vowels = 0 , consonant = 0 , specialChar = 0 , digit = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) { ch = char . ToLower ( ch ) ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) vowels ++ ; else consonant ++ ; } else if ( ch >= '0' && ch <= '9' ) digit ++ ; else specialChar ++ ; } Console . WriteLine ( " Vowels : ▁ " + vowels ) ; Console . WriteLine ( " Consonant : ▁ " + consonant ) ; Console . WriteLine ( " Digit : ▁ " + digit ) ; Console . WriteLine ( " Special ▁ Character : ▁ " + specialChar ) ; }
bool isoctagonal ( int N ) { double n = ( 2 + Math . Sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
int findValue ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) ans = Math . Max ( ans , Math . Abs ( arr [ i ] - arr [ j ] ) + Math . Abs ( i - j ) ) ; return ans ; }
void findLarger ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) Console . Write ( arr [ i ] + " ▁ " ) ; }
int countSol ( int [ ] coeff , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
int maxLengthSquare ( int row , int column , int [ , ] arr , int k ) { int [ , ] sum = new int [ row + 1 , column + 1 ] ; int cur_max = 1 ; int max = 0 ; for ( int i = 1 ; i <= row ; i ++ ) { for ( int j = 1 ; j <= column ; j ++ ) { sum [ i , j ] = sum [ i - 1 , j ] + sum [ i , j - 1 ] + arr [ i - 1 , j - 1 ] - sum [ i - 1 , j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i , j ] - sum [ i - cur_max , j ] - sum [ i , j - cur_max ] + sum [ i - cur_max , j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; }
int Minimum ( int N , int K ) { int sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return - 1 ; if ( K <= N ) return 1 ; sum = 0 ; int count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }
void findMissing ( int [ ] a , int [ ] b , int n , int m ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . Add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . Contains ( a [ i ] ) ) Console . Write ( a [ i ] + " ▁ " ) ; }
void newvol ( double x ) { Console . WriteLine ( " percentage ▁ increase ▁ " + " in ▁ the ▁ volume ▁ of ▁ the ▁ cylinder ▁ is ▁ " + x + " % " ) ; }
int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
int clearLastBit ( int N , int K ) { int mask = ( - 1 << K + 1 ) ; return N = N & mask ; }
float rainDayProbability ( int [ ] a , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
void findPair ( int A , int B , int N ) { int X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { Console . Write ( " - 1" ) ; } else { X = X / 2 ; Y = N - X ; Console . Write ( X + " ▁ " + Y ) ; } }
int findRectNum ( int n ) { return n * ( n + 1 ) ; }
void findTriangle ( int [ ] a , int n ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; Array . Sort ( a ) ; Array . Sort ( b ) ; int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . Max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . Max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . Max ( p - j , 0 ) ; z += q - p ; } } } Console . Write ( " Acute ▁ Triangle : ▁ " + x + " STRNEWLINE " ) ; Console . Write ( " Right ▁ Triangle : ▁ " + y + " STRNEWLINE " ) ; Console . Write ( " Obtuse ▁ Triangle : ▁ " + z + " STRNEWLINE " ) ; }
int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
int findEvenPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
int sum_all_divisors ( int num ) { int sum = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( num ) ; i ++ ) { sum += t1 + t2 ; } return sum ; }
double ReuleauxArea ( float a ) { if ( a < 0 ) return - 1 ; double A = ( double ) 0.70477 * Math . Pow ( a , 2 ) ; return A ; }
int pairCount ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= Math . Sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }
int countPairs ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; if ( i == j ) return dp [ i , j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i , j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i , j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
void splitString ( string S , int N ) { char c = S [ N - 1 ] ; int f = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] == c ) { f = 1 ; break ; } } if ( f != 0 ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
double Avgdifference ( double [ ] arr , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
int TotalBitwiseORPair ( int [ ] arr , int N ) { int totalOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalOR |= arr [ i ] ; } return totalOR ; }
int count_special ( int n ) { int [ ] fib = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; }
void solve ( long n ) { long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = ( int ) ( n / ( Math . Floor ( ( double ) n / l ) ) ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( int ) ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } Console . Write ( ( s + m ) % m ) ; }
int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
int findMaxK ( int N ) { int p = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) ; return ( int ) Math . Pow ( 2 , p ) ; }
void countsort ( char [ ] arr ) { int n = arr . Length ; char [ ] output = new char [ n ] ; int [ ] count = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; ++ i ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; for ( int i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; }
int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
int minCount ( int [ ] A , int [ ] B , int N ) { int i = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) { i ++ ; } } return N - i ; }
void add ( int [ , ] A , int [ , ] B , int [ , ] C ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i , j ] = A [ i , j ] + B [ i , j ] ; }
void factorsOf3 ( int [ ] arr , int N ) { int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 3 == 0 ) a ++ ; else if ( arr [ i ] % 3 == 1 ) b ++ ; else if ( arr [ i ] % 3 == 2 ) c ++ ; } if ( a >= 1 && a <= b + c + 1 ) Console . Write ( " Yes " + " STRNEWLINE " ) ; else if ( a == 0 && b == 0 && c > 0 ) Console . Write ( " Yes " + " STRNEWLINE " ) ; else if ( a == 0 && c == 0 && b > 0 ) Console . Write ( " Yes " + " STRNEWLINE " ) ; else Console . Write ( " No " + " STRNEWLINE " ) ; }
void findUniquePair ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } Console . WriteLine ( " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , ▁ " + y + " ) " ) ; }
int countChars ( string str , int n ) { int i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == '0' ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; }
int distinctSubString ( String P , String Q , int K , int N ) { HashSet < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; String s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; sum += Q [ pos ] - '0' ; s += P [ j ] ; if ( sum <= K ) { S . Add ( s ) ; } else { break ; } } } return S . Count ; }
int boost_hyperfactorial ( int num ) { int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
int bitwiseOrTillN ( int n ) { int result = 2 ; for ( int i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; }
void findNthTerm ( int n ) { Console . Write ( n * ( 2 * n + 1 ) ) ; }
float angle ( float R1 , float R2 , float D ) { float ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }
int minsteps ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += Math . Abs ( arr [ i ] - ( int ) ( Math . Pow ( 2 , i ) ) ) ; } return ans ; }
int smallest ( int x , int y , int z ) { if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ; return ( ( x / z ) != 1 ) ? x : z ; }
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
int findCount ( int d ) { return 9 * ( ( int ) ( Math . Pow ( 10 , d - 1 ) ) - ( int ) ( Math . Pow ( 9 , d - 1 ) ) ) ; }
int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
int maxLen ( int [ ] arr , int n ) { int min_val = arr . Min ( ) ; int freq = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
int KthMinValAfterMconcatenate ( int [ ] A , int N , int M , int K ) { Array . Sort ( A ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; }
int sum ( int A , int B , int R ) { int sum = 0 ; for ( int i = 1 ; i <= R ; i ++ ) { sum = sum + ( i * A ) ; A = A + B ; } return sum ; }
long centeredTridecagonalNum ( long n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
void findSubsequence ( string str , int k ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . Length ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( a [ str [ i ] - ' a ' ] >= k ) Console . Write ( str [ i ] ) ; }
void longestAlternating ( int [ ] arr , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( count [ i ] + " ▁ " ) ; }
double getSum ( int n ) { double sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * Math . Pow ( 10 , n - 1 ) * Math . Pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; }
int icosidigonal_num ( int n ) { return ( 20 * n * n - 18 * n ) / 2 ; }
string largestMerge ( string word1 , string word2 ) { string merge = " " ; while ( word1 . Length != 0 word2 . Length != 0 ) { if ( String . Compare ( word1 , word2 ) == 0 || String . Compare ( word1 , word2 ) > 0 ) { merge = merge + word1 [ 0 ] ; word1 = word1 . Substring ( 1 ) ; } else { merge = merge + word2 [ 0 ] ; word2 = word2 . Substring ( 1 ) ; } } return merge ; }
int cntElements ( int [ ] arr , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }
int clstNum ( int N ) { return ( N - 1 ) ; }
int findSubarraySum ( int [ ] arr , int n , int sum ) { Dictionary < int , int > prevSum = new Dictionary < int , int > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . ContainsKey ( currsum - sum ) ) res += prevSum [ currsum - sum ] ; if ( ! prevSum . ContainsKey ( currsum ) ) prevSum . Add ( currsum , 1 ) ; else { int count = prevSum [ currsum ] ; prevSum [ currsum ] = count + 1 ; } } return res ; }
int find ( List < int > arr , int N ) { int Sum = 0 ; foreach ( int item in arr ) Sum += item ; if ( Sum % N == 1 ) return - 1 ; int k = Sum / N ; int ans = 0 ; int i = 0 ; while ( i < N ) { ans = ans + Math . Abs ( k - arr [ i ] ) ; i += 1 ; } return ans / 2 ; }
int findK ( int n , int k ) { ArrayList a = new ArrayList ( n ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . Add ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . Add ( i ) ; return ( int ) ( a [ k - 1 ] ) ; }
int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
bool isPossible ( int r , int b , int g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } }
void printSeriesSum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ( i & 1 ) == 0 ) { sum += ( double ) i / ( i + 1 ) ; } else { sum -= ( double ) i / ( i + 1 ) ; } } Console . WriteLine ( sum ) ; }
void printPattern ( string str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { if ( ( i == j ) || ( i + j == len - 1 ) ) Console . Write ( str [ j ] ) ; else Console . Write ( " ▁ " ) ; } Console . WriteLine ( ) ; } }
int countDistinct ( int [ ] arr , int n ) { HashSet < int > hs = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hs . Add ( arr [ i ] ) ; } return hs . Count ; }
int findMin ( int [ ] arr , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; ans = Math . Max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int ans = 1 ; while ( n % 2 == 0 ) { n /= 2 ; ans *= 2 ; } return ans ; }
long oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
long countBT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
String intToRoman ( int num ) { String [ ] m = { " " , " M " , " MM " , " MMM " } ; String [ ] c = { " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM " } ; String [ ] x = { " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " } ; String [ ] i = { " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " } ; String thousands = m [ num / 1000 ] ; String hundereds = c [ ( num % 1000 ) / 100 ] ; String tens = x [ ( num % 100 ) / 10 ] ; String ones = i [ num % 10 ] ; String ans = thousands + hundereds + tens + ones ; return ans ; }
int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; }
int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
void mindigits ( int n ) { if ( n % 9 == 0 ) { Console . WriteLine ( n / 9 ) ; } else { Console . WriteLine ( ( n / 9 ) + 1 ) ; } }
void Bubble_Sort ( int [ ] arr , int n ) { bool flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } }
int findLen ( int [ ] arr , int n , int m ) { List < int > filter = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . Add ( arr [ i ] ) ; if ( filter . Count == 0 ) return 0 ; int c_and = filter [ 0 ] ; for ( int i = 1 ; i < filter . Count ; i ++ ) c_and &= filter [ i ] ; if ( c_and == m ) return filter . Count ; return 0 ; }
int sumOfDigits ( string s ) { int curr = 0 ; int ret = 0 ; foreach ( char ch in s ) { if ( ch >= 48 && ch <= 57 ) { curr = curr * 10 + ch - '0' ; } else { ret += curr ; curr = 0 ; } } ret += curr ; return ret ; }
void rangeSum ( int [ ] arr , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } Console . Write ( sum ) ; }
int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . Length ; i ++ ) { if ( count == s . Length ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
double Volume_of_cone ( double R ) { double V = ( double ) ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; }
int CalculateMax ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . Abs ( max_sum - min_sum ) ) ; }
int min_operation ( int [ ] a , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += Math . Abs ( a [ i ] - a [ i - 1 ] ) ; else ans += Math . Abs ( a [ i ] ) ; } return ans ; }
Boolean ContinuousElements ( int [ ] a , int n ) { if ( n == 1 ) return false ; int curr = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { if ( curr == 1 ) return false ; else curr = 0 ; } curr ++ ; } if ( curr == 1 ) return false ; return true ; }
int count ( int x , int y ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . ContainsKey ( x ) ) return - 1 ; m . Add ( x , 1 ) ; x = x * 10 ; } return ans ; }
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
void SternSequenceFunc ( List < int > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . Count < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . Add ( considered_element + precedent ) ; BrocotSequence . Add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) Console . Write ( BrocotSequence [ i ] + " ▁ " ) ; }
int TotalXorPair ( int [ ] arr , int N ) { int totalXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; }
bool checkPandigital ( int b , string n ) { if ( n . Length < b ) return false ; bool [ ] hash = new bool [ b ] ; for ( int i = 0 ; i < b ; i ++ ) hash [ i ] = false ; for ( int i = 0 ; i < n . Length ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
void shortestLength ( int n , int [ ] x , int [ ] y ) { int answer = 0 ; int i = 0 ; while ( n != 0 && i < x . Length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } Console . WriteLine ( " Length ▁ - > ▁ " + answer ) ; Console . WriteLine ( " Path ▁ - > ▁ " + " ( ▁ 1 , ▁ " + answer + " ▁ ) " + " and ▁ ( ▁ " + answer + " , ▁ 1 ▁ ) " ) ; }
int numberOfWays ( int N , int X , int Y ) { int S1 = ( N - 1 ) * X + Y ; int S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }
int findWater ( int [ ] arr , int n ) { int result = 0 ; int left_max = 0 , right_max = 0 ; int lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; }
int maxAndXor ( int [ ] arr , int n ) { int ans = 9999999 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . Min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }
int number_of_digits ( int n ) { int i ; int res ; int sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
int segments ( int n , int [ ] p , int m ) { Dictionary < int , int > c = new Dictionary < int , int > ( ) ; c . Add ( 0 , 1 ) ; bool has = false ; int sum = 0 ; int ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) has = true ; if ( has ) ans += ( ! c . ContainsKey ( sum ) ? 0 : c [ sum ] ) + ( ! c . ContainsKey ( sum - 1 ) ? 0 : c [ sum - 1 ] ) ; else c . Add ( sum , ! c . ContainsKey ( sum ) ? 1 : c [ sum ] + 1 ) ; } return ans ; }
bool isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
void printGroups ( int n ) { int x = 1 ; int y = n * n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n / 2 ; j ++ ) { Console . Write ( " { ▁ " + x + " , ▁ " + y + " } ▁ " ) ; x ++ ; y -- ; } Console . WriteLine ( ) ; } }
int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
int countOddPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 != 1 ) ) { count ++ ; } } int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }
int maxCost ( int [ , ] mat , int N ) { int [ , ] dp = new int [ N , N ] ; dp [ 0 , 0 ] = mat [ 0 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i , 0 ] = mat [ i , 0 ] + dp [ i - 1 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i , j ] = mat [ i , j ] + Math . Max ( dp [ i - 1 , j - 1 ] , dp [ i - 1 , j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 , i ] ) result = dp [ N - 1 , i ] ; return result ; }
void sortSquares ( int [ ] arr ) { int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] * arr [ i ] ; Array . Sort ( arr ) ; }
double Length_Diagonal ( int a , int b , double theta ) { double diagonal = Math . Sqrt ( ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) - 2 * a * b * Math . Cos ( theta * ( Math . PI / 180 ) ) ) ; return diagonal ; }
void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) Console . WriteLine ( " STRNEWLINE Equal " ) ; else if ( ( x & ( ~ y ) ) > y ) Console . WriteLine ( y ) ; else Console . WriteLine ( x ) ; }
int minSum ( int [ ] A , int [ ] B , int [ ] C , int i , int n , int curr , int [ , ] dp ) { if ( n <= 0 ) return 0 ; if ( dp [ n , curr ] != - 1 ) return dp [ n , curr ] ; if ( curr == 0 ) { return dp [ n , curr ] = Math . Min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n , curr ] = Math . Min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n , curr ] = Math . Min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; }
float rectanglearea ( float r ) { if ( r < 0 ) return - 1 ; float a = r * r ; return a ; }
int canReplace ( int [ ] array ) { int i = 0 , count = 0 ; while ( i < array . Length ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == array . Length - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; }
int maxCostToRemove ( int [ ] arr , int N , int K ) { int maxCost = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < N ; i += K ) { maxCost += arr [ i + 1 ] ; } return maxCost ; }
void complement ( string number1 ) { char [ ] number = number1 . ToCharArray ( ) ; for ( int i = 0 ; i < number . Length ; i ++ ) if ( number [ i ] != ' . ' ) number [ i ] = ( char ) ( ( int ) ( '9' ) - ( int ) ( number [ i ] ) + ( int ) ( '0' ) ) ; System . Console . WriteLine ( "9 ' s ▁ complement ▁ is ▁ : ▁ " + new string ( number ) ) ; }
double polyarea ( double n , double r ) { if ( r < 0 && n < 0 ) return - 1 ; double A = ( ( r * r * n ) * Math . Sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
int IcositrigonalNum ( int n ) { return ( 21 * n * n - 19 * n ) / 2 ; }
double sumOfSeries ( int n ) { return 0.0246 * ( Math . Pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
int possibleTriplets ( int [ ] arr , int N ) { int freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( int ) ( ( freq * 1L * ( freq - 1 ) * ( freq - 2 ) ) / 6 ) ; }
void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr = 0 ; if ( n == 0 ) Console . Write ( first ) ; else if ( n == 1 n == 2 ) Console . Write ( second ) ; else if ( n == 3 ) Console . Write ( fourth ) ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } Console . Write ( curr ) ; } }
void split ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { count = 2 ; break ; } } Console . Write ( count ) ; }
bool makeAndCheckString ( List < String > words , String str ) { int n = words . Count ; bool first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; }
int findSum ( String str ) { String temp = "0" ; int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( char . IsDigit ( ch ) ) temp += ch ; else { sum += int . Parse ( temp ) ; temp = "0" ; } } return sum + int . Parse ( temp ) ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = Math . Max ( max_sum , a + b ) ; } } return max_sum ; }
int calculateMoves ( int n ) { int count = 0 ; int layers = n / 2 ; for ( int k = 1 ; k < layers + 1 ; k ++ ) { count += 8 * k * k ; } return count ; }
int oddFib ( int n ) { n = ( 3 * n + 1 ) / 2 ; int a = - 1 , b = 1 , c = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
void minDistance ( int n , int k , int [ ] [ ] point ) { for ( int i = 0 ; i < k ; i ++ ) Array . Sort ( point [ i ] ) ; for ( int i = 0 ; i < k ; i ++ ) System . Console . Write ( point [ i ] [ ( int ) Math . Ceiling ( ( double ) ( n / 2 ) - 1 ) ] + " ▁ " ) ; }
int findArea ( int [ ] arr , int n ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int [ ] dimension = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . Length ; for ( int i = 0 ; i < l ; i ++ ) { sum += ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }
void circle_equation ( double x1 , double y1 , double r ) { double a = - 2 * x1 ; double b = - 2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; Console . Write ( " x ^ 2 ▁ + ▁ ( " + a + " ▁ x ) ▁ + ▁ " ) ; Console . Write ( " y ^ 2 ▁ + ▁ ( " + b + " ▁ y ) ▁ = ▁ " ) ; Console . WriteLine ( c + " . " ) ; }
int maxValue ( int [ ] arr , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = Math . Min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
void sortBinaryArray ( int [ ] a , int n ) { int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; int temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } }
int superSeq ( String X , String Y , int m , int n ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i , j ] = j ; else if ( j == 0 ) dp [ i , j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = 1 + Math . Min ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) ; } } return dp [ m , n ] ; }
void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; Console . WriteLine ( first_3 + " ▁ " + last_3 ) ; }
int distinct ( int [ ] arr , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }
int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
int times ( int [ ] steps , int n ) { int current_level = 0 ; int previous_level = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; }
String SmallestString ( String s , char c ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] > c ) { String temp = s ; s = s . Substring ( 0 , i ) ; s += c ; s += temp . Substring ( i , temp . Length - 1 ) ; return s ; } } s += c ; return s ; }
int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { int n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }
bool checkSuffix ( int A , int B ) { int digit_B = ( int ) ( Math . Log10 ( B ) + 1 ) ; A -= B ; return ( A % ( int ) ( Math . Pow ( 10 , digit_B ) ) > 0 ) ; }
int uncrossedLines ( int [ ] a , int [ ] b , int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i , j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) ; } } return dp [ n , m ] ; }
int minSteps ( int m , int n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; int min_cost = inf ; for ( int i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = Math . Min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }
int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
int ways ( int n ) { return n / 2 ; }
double findSum ( long n ) { return Math . Sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }
void minSteps ( string S ) { string new_str = " " ; int N = S . Length ; int i = 0 ; while ( i < N ) { new_str += S [ i ] ; int j = i ; while ( i < N && S [ i ] == S [ j ] ) ++ i ; } Console . Write ( ( int ) Math . Ceiling ( ( new_str . Length + 1 ) / 2.0 ) ) ; }
int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
void printCase ( int n ) { if ( n <= 2 ) { Console . Write ( - 1 ) ; return ; } for ( int i = n ; i >= 1 ; i -- ) Console . Write ( i + " ▁ " ) ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
int maxProfit ( int [ ] arr ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( ( arr [ i ] - ( 1 * i ) ) > 0 ) ans += ( arr [ i ] - ( 1 * i ) ) ; if ( ( arr [ i ] - ( 1 * i ) ) == 0 ) break ; } return ans ; }
void maxPairs ( int [ ] nums , int k ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int result = 0 ; foreach ( int i in nums ) { if ( map . ContainsKey ( i ) && map [ i ] > 0 ) { map [ i ] = map [ i ] - 1 ; result ++ ; } else { if ( ! map . ContainsKey ( k - i ) ) map . Add ( k - i , 1 ) ; else map [ i ] = map [ i ] + 1 ; } } Console . WriteLine ( result ) ; }
int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2 ) ; twentyfive = ( ( Z * 1 ) / 4 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return ( int ) result ; }
int countSortedArrays ( int start , int m , int size , int n ) { if ( size == m ) return 1 ; if ( start > n ) return 0 ; int notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }
int solve ( int n , int k , int mod , int [ ] dp ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; int cnt = 0 ; for ( int i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; }
double Area ( double l , double b , double h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; double x = ( l * b ) / ( l + b ) ; double A = 0.70477 * Math . Pow ( x , 2 ) ; return A ; }
void Loss ( int SP , int P ) { double loss = 0 ; loss = ( double ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . Console . WriteLine ( " Loss ▁ = ▁ " + System . Math . Round ( loss , 3 ) ) ; }
double probability ( int [ ] arr1 , int [ ] arr2 ) { int N = arr1 . Length ; int M = arr2 . Length ; double res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int y = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr2 [ j ] > arr1 [ i ] ) y ++ ; } res += y ; } res = ( double ) res / ( double ) ( N * M ) ; return res ; }
void conVowUpp ( char [ ] str ) { int N = str . Length ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { char c = char . ToUpperInvariant ( str [ i ] ) ; str [ i ] = c ; } } foreach ( char c in str ) Console . Write ( c ) ; }
int solve ( double M , double N , double s ) { int ans = ( ( int ) ( Math . Ceiling ( M / s ) ) * ( int ) ( Math . Ceiling ( N / s ) ) ) ; return ans ; }
int maxSize ( List < int > v , int n ) { v . Add ( 0 ) ; v . Add ( 100001 ) ; n += 2 ; v . Sort ( ) ; int mx = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int L = v [ i - 1 ] + 1 ; int R = v [ i + 1 ] - 1 ; int cnt = R - L + 1 ; mx = Math . Max ( mx , cnt ) ; } return mx ; }
void maxMin ( int [ , ] arr , int n ) { int min = + 2147483647 ; int max = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i , j ] > arr [ i , n - j - 1 ] ) { if ( min > arr [ i , n - j - 1 ] ) min = arr [ i , n - j - 1 ] ; if ( max < arr [ i , j ] ) max = arr [ i , j ] ; } else { if ( min > arr [ i , j ] ) min = arr [ i , j ] ; if ( max < arr [ i , n - j - 1 ] ) max = arr [ i , n - j - 1 ] ; } } } Console . Write ( " Maximum ▁ = ▁ " + max + " , ▁ Minimum ▁ = ▁ " + min ) ; }
int countWays ( int index , int cnt , int [ , ] dp , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index , cnt ] != - 1 ) return dp [ index , cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index , cnt ] = ans ; }
int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
bool isMyriagon ( int N ) { double n = ( 9996 + Math . Sqrt ( 79984 * N + 99920016 ) ) / 19996 ; return ( n - ( int ) n ) == 0 ; }
int findWater ( int n ) { int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; int water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) left [ i ] = Math . Max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) right [ i ] = Math . Max ( right [ i + 1 ] , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) water += Math . Min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; }
double findDiagonal ( double s ) { return ( double ) Math . Sqrt ( 2 ) * s ; }
int myXOR ( int x , int y ) { return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) ; }
int countQuadruples ( int [ ] A , int N ) { int ans = 0 ; Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . ContainsKey ( A [ i ] ) ) ans += freq [ A [ i ] ] ; else freq . Add ( A [ i ] , 0 ) ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { if ( freq . ContainsKey ( A [ i ] * A [ j ] * A [ k ] ) ) freq [ A [ i ] * A [ j ] * A [ k ] ] ++ ; else freq . Add ( A [ i ] * A [ j ] * A [ k ] , 1 ) ; } } } return ans ; }
int distinctSubstring ( string P , string Q , int K , int N ) { HashSet < string > S = new HashSet < string > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; string s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; sum += Q [ pos ] - '0' ; s += P [ j ] ; if ( sum <= K ) { S . Add ( s ) ; } else { break ; } } } return S . Count ; }
int possibleBinaries ( int pos , int ones , int sum , int k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos , ones , sum ] != - 1 ) return dp [ pos , ones , sum ] ; int ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos , ones , sum ] = ret ; return dp [ pos , ones , sum ] ; }
int bellNumber ( int n ) { int [ , ] bell = new int [ n + 1 , n + 1 ] ; bell [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i , 0 ] = bell [ i - 1 , i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i , j ] = bell [ i - 1 , j - 1 ] + bell [ i , j - 1 ] ; } return bell [ n , 0 ] ; }
int countSquares ( int n ) { int r = ( int ) Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n ) ) ) ; int l = ( int ) Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n - 1 ) ) ) ; return r - l ; }
bool isTridecagon ( int N ) { float n = ( float ) ( ( 9 + Math . Sqrt ( 88 * N + 81 ) ) / 22 ) ; return ( n - ( int ) n ) == 0 ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
void countPairs ( int N , int [ ] arr ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } Console . Write ( count / 2 ) ; }
int cntSplits ( String s ) { if ( s [ s . Length - 1 ] == '1' ) return - 1 ; int ans = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) ans += ( s [ i ] == '0' ) ? 1 : 0 ; return ans ; }
int longestSubseq ( String s ) { int n = s . Length ; int [ ] pre_count_0 = new int [ n + 2 ] ; int [ ] pre_count_1 = new int [ n + 1 ] ; int [ ] post_count_0 = new int [ n + 2 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s [ j - 1 ] == '0' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s [ n - j ] == '0' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = Math . Max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; }
int FlipBits ( int n ) { return n -= ( n & ( - n ) ) ; }
Boolean check ( String [ ] v , int len ) { int n = v . Length ; char [ ] tempArray ; for ( int i = 0 ; i < n ; i ++ ) { tempArray = v [ i ] . ToCharArray ( ) ; Array . Sort ( tempArray ) ; v [ i ] = new String ( tempArray ) ; } for ( int i = 0 ; i < len - 1 ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( v [ i ] [ j ] > v [ i + 1 ] [ j ] ) return false ; return true ; }
int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . Log ( n ) / Math . Log ( 10 ) ) ; int [ ] a = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . Ceiling ( Math . Pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . Ceiling ( Math . Pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; }
int XorAscii ( String str , int len ) { int ans = ( str [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( ( str [ i ] ) ) ) ; } return ans ; }
String getResult ( int n ) { string st = n . ToString ( ) ; for ( int i = 0 ; i < st . Length ; i ++ ) { int d = st [ i ] - 48 ; if ( n % d == 0 ) { return " Yes " ; } } return " No " ; }
string toggleCase ( char [ ] a ) { for ( int i = 0 ; i < a . Length ; i ++ ) { a [ i ] ^= ( char ) 32 ; } return new string ( a ) ; }
void printNumber ( int holes ) { if ( holes == 0 ) Console . Write ( "1" ) ; else if ( holes == 1 ) Console . Write ( "0" ) ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) Console . Write ( "4" ) ; for ( int i = 0 ; i < quo ; i ++ ) Console . Write ( "8" ) ; } }
void findTriplets ( int [ ] arr , int n , int sum ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = sum - ( arr [ i ] + arr [ j ] ) ; if ( s . Contains ( x ) ) Console . Write ( " { 0 } ▁ { 1 } ▁ { 2 } STRNEWLINE " , x , arr [ i ] , arr [ j ] ) ; else s . Add ( arr [ j ] ) ; } } }
int calculate ( int [ ] a , int n ) { Array . Sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }
bool isMultipleOf4 ( int n ) { if ( n == 1 ) return false ; int XOR = 0 ; for ( int i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; }
int calculate_minimum_split ( int n , int [ ] a , int k ) { int [ ] p = new int [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) p [ i - 1 ] = a [ i ] - a [ i - 1 ] ; Array . Sort ( p ) ; Array . Reverse ( p ) ; int min_sum = 0 ; for ( int i = 0 ; i < k - 1 ; i ++ ) min_sum += p [ i ] ; int res = a [ n - 1 ] - a [ 0 ] - min_sum ; return res ; }
int search ( int [ ] ar , int size ) { int a = 0 , b = size - 1 ; int mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; }
void findPair ( int x ) { int lim = 120 ; for ( int i = - lim ; i <= lim ; i ++ ) { for ( int j = - lim ; j <= lim ; j ++ ) { if ( Math . Pow ( i , 5 ) - Math . Pow ( j , 5 ) == x ) { Console . Write ( i + " ▁ " + j + " STRNEWLINE " ) ; return ; } } } Console . Write ( " - 1" ) ; }
void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
int nthOdd ( int n ) { return ( 2 * n - 1 ) ; }
double find ( double p ) { return Math . Ceiling ( Math . Sqrt ( 2 * 365 * Math . Log ( 1 / ( 1 - p ) ) ) ) ; }
Boolean canBecomeEmpty ( String str , String sub_str ) { while ( str . Length > 0 ) { int idx = str . IndexOf ( sub_str ) ; if ( idx == - 1 ) { break ; } str = str . Replace ( sub_str , " " ) ; } return ( str . Length == 0 ) ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
int countMinReversals ( String expr ) { int len = expr . Length ; if ( len % 2 != 0 ) return - 1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) open ++ ; else { if ( open == 0 ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close != 0 ) ans += 2 ; return ans ; }
bool linearSearch ( int [ ] a , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == key ) return true ; } return false ; }
int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; }
string isAnBn ( string str ) { int n = str . Length ; if ( ( n & 1 ) != 0 ) return " No " ; int i ; for ( i = 0 ; i < n / 2 ; i ++ ) if ( str [ i ] != ' a ' str [ n - i - 1 ] != ' b ' ) return " No " ; return " Yes " ; }
int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + ( n ^ x ) ) ++ c ; return c ; }
int findMinRec ( int [ ] A , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . Min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
void bitonicSequence ( int num , int lower , int upper ) { if ( num > ( upper - lower ) * 2 + 1 ) { Console . WriteLine ( - 1 ) ; return ; } List < int > ans = new List < int > ( ) ; for ( int i = 0 ; i < Math . Min ( upper - lower + 1 , num - 1 ) ; i ++ ) ans . Add ( upper - i ) ; for ( int i = 0 ; i < num - ans . Count ; i ++ ) ans . Insert ( 0 , upper - i - 1 ) ; Console . Write ( " [ " ) ; foreach ( int x in ans ) Console . Write ( x + " , ▁ " ) ; Console . Write ( " ] " ) ; }
int findMinInsertions ( char [ ] str , int l , int h ) { if ( l > h ) return int . MaxValue ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . Min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
bool isEven ( int n ) { bool isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
int sizeSubSet ( int [ ] a , int k , int n ) { Array . Sort ( a ) ; Dictionary < int , int > s = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || ! s . ContainsKey ( a [ i ] / k ) ) { if ( s . ContainsKey ( a [ i ] ) ) { var val = s [ a [ i ] ] ; s . Remove ( a [ i ] ) ; s . Add ( a [ i ] , val + 1 ) ; } else { s . Add ( a [ i ] , 1 ) ; } } } return s . Count ; }
void printRepeating ( int [ ] arr , int size ) { int [ ] count = new int [ size ] ; int i ; Console . Write ( " Repeated ▁ elements ▁ are : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) Console . Write ( arr [ i ] + " ▁ " ) ; else count [ arr [ i ] ] ++ ; } }
int minOperation ( bool [ ] [ ] arr ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
void countPairs ( int [ ] arr , int N , int K ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( K - arr [ i ] ) ) cnt += mp [ K - arr [ i ] ] ; if ( mp . ContainsKey ( arr [ i ] ) ) { var val = mp [ arr [ i ] ] ; mp . Remove ( arr [ i ] ) ; mp . Add ( arr [ i ] , val + 1 ) ; } else { mp . Add ( arr [ i ] , 1 ) ; } } Console . WriteLine ( cnt ) ; }
int findPermutation ( int n ) { int len = ( int ) Math . Ceiling ( Math . Log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * ( int ) Math . Pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; }
int totalSumDivisibleByNum ( int n , int number ) { int firstnum = ( int ) Math . Pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
int maxcntPairsSumKRemoved ( int [ ] arr , int k ) { int cntPairs = 0 ; if ( arr . Length <= 1 ) return cntPairs ; Array . Sort ( arr ) ; int left = 0 ; int right = arr . Length - 1 ; while ( left < right ) { int s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }
void SubString ( String str , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j <= n - i ; j ++ ) Console . WriteLine ( str . Substring ( i , j ) ) ; }
void findsolution ( long n , long x , long y ) { if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x y < n ) { Console . WriteLine ( " No ▁ solution " ) ; return ; } Console . WriteLine ( y - n + 1 ) ; while ( n -- > 1 ) Console . WriteLine ( "1" ) ; }
int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) Math . Pow ( i , res ) % mod ; return res ; }
bool checkPointRange ( int [ , ] arr , int X , int Y , int N ) { for ( int i = 0 ; i < N ; i ++ ) { double dist = Math . Sqrt ( ( arr [ i , 0 ] - X ) * ( arr [ i , 0 ] - X ) + ( arr [ i , 1 ] - Y ) * ( arr [ i , 1 ] - Y ) ) ; if ( dist <= arr [ i , 2 ] ) { return true ; } } return false ; }
int missingK ( int [ ] a , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; }
void occurredOnce ( int [ ] arr , int n ) { int i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else Console . Write ( arr [ i - 1 ] + " ▁ " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) Console . Write ( arr [ n - 1 ] ) ; }
int negProdSubArr ( int [ ] arr , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
bool isPrime ( int p ) { double checkNumber = Math . Pow ( 2 , p ) - 1 ; double nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
void minOperations ( string S ) { int count = 0 ; for ( int i = 1 ; i < S . Length ; i ++ ) { if ( S [ i ] != S [ i - 1 ] ) { count += 1 ; } } Console . Write ( count ) ; }
int distribution ( int [ ] arr , int n ) { HashSet < int > resources = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) resources . Add ( arr [ i ] ) ; return Math . Min ( resources . Count , n / 2 ) ; }
int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . Pow ( N , ( 1.0 / 3.0 ) ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = ( int ) Math . Pow ( diff , ( 1.0 / 3.0 ) ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
double nthHarmonic ( int N ) { float harmonic = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }
bool isTriplet ( int [ ] ar , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( Math . Abs ( ar [ i ] - ar [ j ] ) == 1 || Math . Abs ( ar [ j ] - ar [ k ] ) == 1 || Math . Abs ( ar [ i ] - ar [ k ] ) == 1 ) { int x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; }
int minimumReverse ( String s , int n ) { int k = 0 , l = 0 ; int sum1 = 0 , sum0 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) sum1 ++ ; else sum0 ++ ; if ( s [ i ] == s [ i - 1 ] && s [ i ] == '0' ) k ++ ; else if ( s [ i ] == s [ i - 1 ] && s [ i ] == '1' ) l ++ ; } if ( s [ 0 ] == '1' ) sum1 ++ ; sum0 ++ ; if ( Math . Abs ( sum1 - sum0 ) > 1 ) return - 1 ; return Math . Max ( k , l ) ; }
int highestPowerof2 ( int n ) { int p = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; return ( int ) Math . Pow ( 2 , p ) ; }
void checkArrangement ( int [ ] A1 , int [ ] A2 , int n , int k ) { Array . Sort ( A1 ) ; Array . Sort ( A2 ) ; Array . Reverse ( A2 ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) Console . WriteLine ( " No " ) ; else Console . WriteLine ( " Yes " ) ; }
void findFactors ( int a , int b ) { int c ; c = a + b - 1 ; Console . Write ( c ) ; }
int maximumSum ( int [ ] a , int count , int index , int n , int [ , ] dp ) { if ( index == n ) return 0 ; if ( dp [ index , count ] != - 1 ) return dp [ index , count ] ; int take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; int dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index , count ] = Math . Max ( take_element , dont_take ) ; }
int twoEggDrop ( int k ) { return ( int ) System . Math . Ceiling ( ( - 1.0 + System . Math . Sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
int minCost ( int [ , ] cost ) { int [ ] dist = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i , j ] ) dist [ j ] = dist [ i ] + cost [ i , j ] ; return dist [ N - 1 ] ; }
bool isPower ( int n ) { for ( int x = 2 ; x <= ( int ) Math . Sqrt ( n ) ; x ++ ) { float f = ( float ) Math . Log ( n ) / ( float ) Math . Log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
void checkType ( int [ ] arr , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) Console . Write ( " Increasing " ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) Console . Write ( " Decreasing " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) Console . Write ( " Increasing ▁ then ▁ decreasing " ) ; else Console . Write ( " Decreasing ▁ then ▁ increasing " ) ; }
int term ( int n ) { int x = ( ( ( 1 ) + ( int ) Math . Sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }
int minCoins ( int [ ] coins , int m , int V ) { if ( V == 0 ) return 0 ; int res = int . MaxValue ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != int . MaxValue && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
void printRectPattern ( int c1 , int c2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( ( Math . Max ( Math . Abs ( c1 - i ) , Math . Abs ( c2 - j ) ) ) + " ▁ " ) ; } Console . WriteLine ( ) ; } }
void reverseorder ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = n ; i >= 2 ; i -- ) if ( prime [ i ] == true ) Console . Write ( i + " ▁ " ) ; }
int sumOfParts ( int [ , ] arr , int N ) { int sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; int totalsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j && i != j && i + j > 0 ) sum_part1 += arr [ i , j ] ; else if ( i != j ) sum_part2 += arr [ i , j ] ; } else { if ( i > j && i + j != N - 1 ) sum_part3 += arr [ i , j ] ; else { if ( i + j != N - 1 && i != j ) sum_part4 += arr [ i , j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }
String get_maximum ( char [ ] s , int [ ] a ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = ( char ) ( '0' + a [ s [ j ] - '0' ] ) ; j ++ ; } return String . Join ( " " , s ) ; } } return String . Join ( " " , s ) ; }
float circlearea ( float R ) { if ( R < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * R * R ) / 4 ) ; return a ; }
double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; }
int countSwaps ( int [ ] A , int n ) { Array . Sort ( A ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }
ArrayList smallestSumpair ( int [ ] arr , int n ) { ArrayList pair = new ArrayList ( ) ; int min_sum = int . MaxValue , i ; for ( i = 1 ; i < n ; i ++ ) { if ( min_sum > ( arr [ i ] + arr [ i - 1 ] ) ) { min_sum = arr [ i ] + arr [ i - 1 ] ; if ( pair . Count == 0 ) { pair . Add ( arr [ i - 1 ] ) ; pair . Add ( arr [ i ] ) ; } else { pair [ 0 ] = arr [ i - 1 ] ; pair [ 1 ] = arr [ i ] ; } } } return pair ; }
int Balanced_Substring ( String str , int n ) { int ans = 0 ; int [ ] arr = new int [ n / 2 + 1 ] ; int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) d ++ ; else { if ( d == 1 ) { for ( int j = 2 ; j <= n / 2 + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; }
void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) Console . Write ( 1 + " ▁ " ) ; Console . Write ( N - K + 1 ) ; }
void interchangeFirstLast ( int [ ] [ ] m ) { int rows = m . Length ; for ( int i = 0 ; i < m [ 0 ] . Length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
bool isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }
double pairProductMean ( int [ ] arr , int N ) { List < int > pairArray = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . Add ( pairProduct ) ; } } int length = pairArray . Count ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; }
int maxSum ( int [ , ] grid , int n ) { int incl = Math . Max ( grid [ 0 , 0 ] , grid [ 1 , 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = Math . Max ( excl , incl ) ; incl = excl + Math . Max ( grid [ 0 , i ] , grid [ 1 , i ] ) ; excl = excl_new ; } return Math . Max ( excl , incl ) ; }
int minimum_sum ( int n , int k ) { if ( k % n == 0 ) return 0 ; return 1 ; }
int countIndices ( int [ ] arr , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; }
void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . Max ( x1 , x3 ) ; int y5 = Math . Max ( y1 , y3 ) ; int x6 = Math . Min ( x2 , x4 ) ; int y6 = Math . Min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { Console . WriteLine ( " No ▁ intersection " ) ; return ; } Console . Write ( " ( " + x5 + " , ▁ " + y5 + " ) ▁ " ) ; Console . Write ( " ( " + x6 + " , ▁ " + y6 + " ) ▁ " ) ; int x7 = x5 ; int y7 = y6 ; Console . Write ( " ( " + x7 + " , ▁ " + y7 + " ) ▁ " ) ; int x8 = x6 ; int y8 = y5 ; Console . Write ( " ( " + x8 + " , ▁ " + y8 + " ) ▁ " ) ; }
int calculateSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; }
void converthenumber ( int n ) { String s = n . ToString ( ) ; String res = " " ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' s [ i ] == '3' s [ i ] == '5' s [ i ] == '7' s [ i ] == '9' ) res += s [ i ] ; if ( res . Length == 2 ) break ; } if ( res . Length == 2 ) Console . WriteLine ( res ) ; else Console . WriteLine ( - 1 ) ; }
void decimalToBinary ( int n ) { if ( n == 0 ) { Console . Write ( "0" ) ; return ; } decimalToBinary ( n / 2 ) ; Console . Write ( n % 2 ) ; }
int sumOfSeries ( int n ) { int ans = ( int ) Math . Pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
void findNthTerm ( int n ) { Console . Write ( n * n - n + 1 ) ; }
int minMaxDiff ( int [ ] arr , int n , int k ) { int max_adj_dif = int . MinValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = Math . Max ( max_adj_dif , Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( Math . Abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; }
void printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { Console . Write ( m + " ▁ " ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; Console . Write ( binom + " ▁ " ) ; } Console . WriteLine ( ) ; } }
int MaximumSides ( int n ) { if ( n < 4 ) return - 1 ; return n % 2 == 0 ? n / 2 : - 1 ; }
long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
int OR ( int [ ] a , int n ) { int ans = a [ 0 ] ; int i ; for ( i = 1 ; i < n ; i ++ ) { ans |= a [ i ] ; } return ans ; }
int cost ( String str ) { int len = str . Length ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str [ i ] != str [ j ] ) res += Math . Min ( str [ i ] , str [ j ] ) - ' a ' + 1 ; return res ; }
int findFirstMissing ( int [ ] array , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
void encrypt ( char [ ] input ) { char evenPos = ' @ ' , oddPos = ' ! ' ; int repeat , ascii ; for ( int i = 0 ; i < input . Length ; i ++ ) { ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) Console . Write ( " { 0 } " , oddPos ) ; else Console . Write ( " { 0 } " , evenPos ) ; } } }
int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
String separateChar ( String str ) { int n = str . Length , digitSum = 0 ; int alphabetSum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] >= '0' && str [ i ] <= '9' ) { digitSum += ( int ) ( str [ i ] - '0' ) ; } else { alphabetSum += str [ i ] - ' a ' + 1 ; alphabetSum %= 26 ; } } String sumStr = " " + ( digitSum ) ; char alphabetStr = ( char ) ( alphabetSum + ' a ' - 1 ) ; sumStr += alphabetStr ; return sumStr ; }
float findAreaShaded ( float a ) { float sqArea = a * a ; float semiCircleArea = ( float ) ( 3.14 * ( a * a ) / 8 ) ; float ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; }
int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
int findLastIndex ( string str , char x ) { int index = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
double squareRoot ( double n , double l ) { double x = n ; double root ; int count = 0 ; while ( true ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( Math . Abs ( root - x ) < l ) break ; x = root ; } return root ; }
void countPairs ( int [ ] arr , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } Console . Write ( answer ) ; }
int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }
void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) Console . Write ( " NO " ) ; else Console . Write ( " YES " ) ; }
int fib ( int n ) { int [ ] term = new int [ 1000 ] ; if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } }
bool canFormPalindrome ( string a ) { int bitvector = 0 , mask = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { int x = a [ i ] - ' a ' ; mask = 1 << x ; bitvector = bitvector ^ mask ; } return ( bitvector & ( bitvector - 1 ) ) == 0 ; }
long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
void distinct ( string [ ] S , int M ) { int count = 0 ; for ( int i = 0 ; i < S . Length ; i ++ ) { HashSet < char > set = new HashSet < char > ( ) ; for ( int j = 0 ; j < S [ i ] . Length ; j ++ ) { if ( ! set . Contains ( S [ i ] [ j ] ) ) set . Add ( S [ i ] [ j ] ) ; } int c = set . Count ; if ( c <= M ) count += 1 ; } Console . Write ( count ) ; }
float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
int count ( string S , int X ) { int count = 0 ; int N = S . Length ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] != '0' ) { for ( int len = 1 ; ( i + len ) <= N ; ++ len ) { int num = Int32 . Parse ( S . Substring ( i , len ) ) ; if ( num > X ) count ++ ; } } } return count ; }
int maxRemainingSum ( int [ ] arr , int n ) { int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; i = 0 ; int j = n - 1 ; int result = 0 ; while ( i < j ) { if ( arr [ i ] < arr [ j ] ) { sum -= arr [ i ] ; i ++ ; } else { sum -= arr [ j ] ; j -- ; } result += sum ; } return result ; }
int findValue ( int R , int C ) { int k = ( R * ( R - 1 ) ) / 2 + 1 ; int diff = R + 1 ; for ( int i = 1 ; i < C ; i ++ ) { k = ( k + diff ) ; diff ++ ; } return k ; }
void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { Console . WriteLine ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }
int getProduct ( int [ ] a , int n ) { int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { p *= Math . Abs ( a [ i ] - a [ j ] ) ; } } return p ; }
char stringPalindrome ( string A , string B ) { int [ ] countA = new int [ MAX_CHAR ] ; int [ ] countB = new int [ MAX_CHAR ] ; int l1 = A . Length ; int l2 = B . Length ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' A ' ; return ' B ' ; }
int findNumberOfStrings ( int n ) { int [ , ] DP = new int [ n + 1 , 6 ] ; DP [ 1 , 1 ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i , j ] = DP [ i , j - 1 ] + 1 ; } else { DP [ i , j ] = DP [ i , j - 1 ] + DP [ i - 1 , j ] ; } } } return DP [ n , 5 ] ; }
void smallestNumber ( int N ) { Console . Write ( N * Math . Floor ( ( Math . Pow ( 10 , N ) - 1 ) / N ) ) ; }
int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; }
int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; }
int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . Max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . Max ( max_so_far , curr_max ) ; } return max_so_far ; }
void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { Console . Write ( ( ( 1 << x ) + ( 1 << y ) ) + " ▁ " ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
void countEle ( Stack < int > s , int [ ] a , int N ) { Dictionary < int , bool > mp = new Dictionary < int , bool > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int num = a [ i ] ; if ( mp . ContainsKey ( num ) ) Console . Write ( "0 ▁ " ) ; else { int cnt = 0 ; while ( s . Peek ( ) != num ) { mp . Add ( s . Peek ( ) , true ) ; s . Pop ( ) ; cnt ++ ; } s . Pop ( ) ; cnt ++ ; Console . Write ( cnt + " ▁ " ) ; } } }
void printXYZ ( int n ) { if ( n == 1 ) Console . WriteLine ( - 1 ) ; else { Console . WriteLine ( " x ▁ is ▁ " + n ) ; Console . WriteLine ( " y ▁ is ▁ " + ( n + 1 ) ) ; Console . WriteLine ( " z ▁ is ▁ " + ( n * ( n + 1 ) ) ) ; } }
float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float R = ( float ) ( ( h * r * Math . Sqrt ( 2 ) ) / ( h + Math . Sqrt ( 2 ) * r ) ) / 2 ; return R ; }
void countPairs ( int [ ] arr , int N ) { int countPowerof2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( Convert . ToString ( arr [ i ] , 2 ) ) . Count ( f => ( f == '1' ) ) == 1 ) countPowerof2 ++ ; } int desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) / 2 ; Console . WriteLine ( desiredPairs + " ▁ " ) ; }
int setRightmostUnsetBit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
void convertBfromA ( int a , int b ) { int moves = 0 ; int x = Math . Abs ( a - b ) ; for ( int i = 10 ; i > 0 ; i -- ) { moves += x / i ; x = x % i ; } Console . Write ( moves + " ▁ " ) ; }
int maxLength ( String s , int n ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ( ' && s [ i + 1 ] == ' ) ' ) dp [ i , i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ( ' && s [ j ] == ' ) ' ) dp [ i , j ] = 2 + dp [ i + 1 , j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i , k ] + dp [ k + 1 , j ] ) ; } } return dp [ 0 , n - 1 ] ; }
int minFallingPathSum ( int [ , ] A ) { for ( int R = n - 2 ; R >= 0 ; -- R ) { for ( int C = 0 ; C < n ; ++ C ) { int best = A [ R + 1 , C ] ; if ( C > 0 ) best = Math . Min ( best , A [ R + 1 , C - 1 ] ) ; if ( C + 1 < n ) best = Math . Min ( best , A [ R + 1 , C + 1 ] ) ; A [ R , C ] = A [ R , C ] + best ; } } int ans = int . MaxValue ; for ( int i = 0 ; i < n ; ++ i ) ans = Math . Min ( ans , A [ 0 , i ] ) ; return ans ; }
void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; Console . WriteLine ( ( float ) time ) ; }
int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
bool isSaintExuperyNum ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; } } } return false ; }
void KthCharacter ( string S , int N , int K ) { char [ ] strarray = S . ToCharArray ( ) ; Array . Sort ( strarray ) ; char ch = strarray [ K - 1 ] ; int count = 0 ; foreach ( char c in strarray ) { if ( c == ch ) count ++ ; } Console . Write ( count ) ; }
int findHours ( int a , int b , int k ) { if ( a >= b ) return - 1 ; int time = k / ( b - a ) ; time = time + 1 ; return time ; }
int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; }
float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = ( int ) ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0f * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0f * A ) ) ; return sqrt_of_s ; }
void sequence ( int n ) { int [ ] f = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; Console . Write ( f [ 1 ] + " ▁ " + f [ 2 ] + " ▁ " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; Console . Write ( f [ i ] + " ▁ " ) ; } }
int summation ( int n ) { int abs_sum = ( int ) ( n * ( n + 1 ) / 2 ) ; int sign = n + 1 % 2 == 0 ? 1 : - 1 ; int result_sum = sign * abs_sum ; return result_sum ; }
int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= Math . Min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
int countPermutations ( int N ) { List < List < int > > adj = new List < List < int > > ( 105 ) ; for ( int i = 0 ; i < 105 ; i ++ ) adj . Add ( new List < int > ( ) ) ; int indeg = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; int sum = i + j ; if ( Math . Ceiling ( Math . Sqrt ( sum ) ) == Math . Floor ( Math . Sqrt ( sum ) ) ) { adj [ i ] . Add ( j ) ; } } if ( adj [ i ] . Count == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }
void findLargestRotation ( int num ) { int ans = num ; double lg = ( double ) ( Math . Log10 ( num ) + 1 ) ; int len = ( int ) ( Math . Floor ( lg ) ) ; int x = ( int ) Math . Pow ( 10 , len - 1 ) ; for ( int i = 1 ; i < len ; i ++ ) { int lastDigit = num % 10 ; num = num / 10 ; num += ( lastDigit * x ) ; if ( num > ans ) { ans = num ; } } Console . Write ( ans ) ; }
void countDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) Console . Write ( " Even " ) ; else Console . Write ( " Odd " ) ; }
double Area_of_Rhombus ( int a , int theta ) { double area = ( a * a ) * Math . Sin ( ( RADIAN * theta ) ) ; return area ; }
int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
int getChicks ( int n ) { int chicks = ( int ) Math . Pow ( 3 , n - 1 ) ; return chicks ; }
int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; }
int countSubstrig ( String str1 , String str2 ) { int n1 = str1 . Length ; int n2 = str2 . Length ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . Substring ( 0 , n2 ) . Equals ( str2 ) ) return countSubstrig ( str1 . Substring ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . Substring ( n2 - 1 ) , str2 ) ; }
void findMissing ( int [ ] arr1 , int [ ] arr2 , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { Console . WriteLine ( " Invalid ▁ Input " ) ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; Console . WriteLine ( " Missing ▁ element ▁ is ▁ " + res ) ; }
double calculateArea ( int x , int y ) { double pi = 3.1415926536 ; double arx = pi * x * x ; double ary = pi * y * y ; return arx - ary ; }
int find ( int index , int openbrk , int n , int [ , ] adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index , openbrk ] != - 1 ) return dp [ index , openbrk ] ; dp [ index , openbrk ] = Math . Min ( adj [ index , 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index , 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index , openbrk ] ; }
int maxPartition ( string s ) { int n = s . Length , P = 0 ; string current = " " , previous = " " ; for ( int i = 0 ; i < n ; i ++ ) { current += s [ i ] ; if ( ! current . Equals ( previous ) ) { previous = current ; current = " " ; P ++ ; } } return P ; }
int condition ( int a , int b ) { int d = Math . Abs ( a - b ) , count = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; }
int countPairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int maxP = Math . Min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; int cnt = maxP - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }
int findExtra ( int [ ] arr1 , int [ ] arr2 , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; }
bool ifPossible ( int [ ] arr , int n ) { int [ ] cp = new int [ n ] ; Array . Copy ( arr , cp , n ) ; Array . Sort ( cp ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false ; } return true ; }
int maxDifference ( int [ ] arr , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . Max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left + 1 ; int d = arr [ 1 ] / arr [ 0 ] ; int ans = arr [ left - 1 ] ; if ( d == 1 ) ans = ans * d * k ; else ans = ans * ( ( int ) Math . Pow ( d , k ) - 1 / ( d - 1 ) ) ; return ans ; }
int digSum ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; }
int MinOperation ( int [ ] a , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . Min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
void lcmpair ( int l , int r ) { int x , y ; x = l ; y = 2 * l ; if ( y > r ) { Console . Write ( " - 1 STRNEWLINE " ) ; } else { Console . Write ( " X ▁ = ▁ " + x + " ▁ Y ▁ = ▁ " + y + " STRNEWLINE " ) ; } }
int binarySearch ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; }
int minOccupiedPosition ( int [ ] A , int n ) { int minPos = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; }
double findArea ( double d ) { return ( d * d ) / 2 ; }
bool isCornerPresent ( string str , string corner ) { int n = str . Length ; int cl = corner . Length ; if ( n < cl ) return false ; return ( str . Substring ( 0 , cl ) . Equals ( corner ) && str . Substring ( n - cl , cl ) . Equals ( corner ) ) ; }
int minimum_deci_binary_number ( string s ) { int m = int . MinValue ; for ( int i = 0 ; i < s . Length ; i ++ ) { int temp = s [ i ] - '0' ; if ( temp > m ) { m = temp ; } } return m ; }
bool modularSum ( int [ ] arr , int n , int m ) { if ( n > m ) return true ; bool [ ] DP = new bool [ m ] ; for ( int l = 0 ; l < DP . Length ; l ++ ) DP [ l ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool [ ] temp = new bool [ m ] ; for ( int l = 0 ; l < temp . Length ; l ++ ) temp [ l ] = false ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . Length ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
int maxTripletSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
void countPairs ( int [ ] arr , int k , int size ) { int count = 0 , x ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < size ; j ++ ) { x = arr [ i ] | arr [ j ] ; if ( x == k ) count ++ ; } } Console . WriteLine ( count ) ; }
int minCost ( List < List < int > > costs , int N ) { if ( N == 0 ) return 0 ; List < int > temp = new List < int > ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) temp . Add ( 0 ) ; List < List < int > > dp = new List < List < int > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) dp . Add ( temp ) ; dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = Math . Min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = Math . Min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = Math . Min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } return ( Math . Min ( dp [ N - 1 ] [ 0 ] , Math . Min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) - 11 ; }
int cntSubSeq ( int [ ] arr , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . Pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= ( int ) Math . Pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }
long findMinSum ( long [ ] a , long [ ] b , long n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . Abs ( a [ i ] - b [ i ] ) ; return sum ; }
int multiplyByMersenne ( int N , int M ) { int x = ( int ) ( Math . Log ( M + 1 ) / Math . Log ( 2 ) ) ; return ( ( N << x ) - N ) ; }
int CntDivbyX ( int [ ] arr , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
long sumOfSumSeries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int evenNumSubstring ( string str ) { int len = str . Length ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
int countOpenDoors ( int N ) { int doorsOpen = ( int ) Math . Sqrt ( N ) ; return doorsOpen ; }
int maxSubarrayProduct ( int [ ] arr ) { int result = arr [ 0 ] ; int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) { int mul = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { result = Math . Max ( result , mul ) ; mul *= arr [ j ] ; } result = Math . Max ( result , mul ) ; } return result ; }
void findWinner ( int [ ] a , int n ) { int win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) Console . Write ( " A " ) ; else Console . Write ( " B " ) ; }
int icosikaiheptagonal ( int n ) { return ( 25 * n * n - 23 * n ) / 2 ; }
double average ( int [ ] arr , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; Array . Sort ( arr ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
int nextPerfectCube ( int N ) { int nextN = ( int ) Math . Floor ( Math . Pow ( N , ( double ) 1 / 3 ) ) + 1 ; return nextN * nextN * nextN ; }
int cost ( int [ ] a , int n ) { return ( n - 1 ) * a . Min ( ) ; }
long operation ( int [ ] arr , int N ) { int right = 0 ; int num = 0 ; long ans = 0 ; for ( int left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }
void occurredOnce ( int [ ] arr , int n ) { Array . Sort ( arr ) ; if ( arr [ 0 ] != arr [ 1 ] ) Console . Write ( arr [ 0 ] + " ▁ " ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) Console . Write ( arr [ i ] + " ▁ " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) Console . Write ( arr [ n - 1 ] + " ▁ " ) ; }
void findNums ( int n ) { if ( n <= 11 ) { if ( n == 8 ) Console . Write ( "4 ▁ 4" ) ; if ( n == 10 ) Console . Write ( "4 ▁ 6" ) ; else Console . Write ( " - 1" ) ; return ; } if ( n % 2 == 0 ) Console . Write ( "4 ▁ " + ( n - 4 ) ) ; else Console . Write ( "9 ▁ " + ( n - 9 ) ) ; }
int isvalid ( int s ) { double k = ( - 1.0 + Math . Sqrt ( 1 + 8 * s ) ) / 2 ; if ( Math . Ceiling ( k ) == Math . Floor ( k ) ) return ( int ) k ; else return - 1 ; }
int lds ( int [ ] arr , int n ) { int [ ] lds = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
int solve ( int [ ] a ) { int n = a . Length ; int [ ] dp = new int [ n + 1 ] ; int [ ] val = new int [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int sum = a [ i ] ; int j = i ; while ( j + 1 < n && sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }
int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
int MinimumNoOfWays ( int [ ] arr , int n ) { int mini_no_of_ways ; if ( n % 2 == 0 ) { mini_no_of_ways = n / 2 ; } else { mini_no_of_ways = n / 2 + 1 ; } return mini_no_of_ways ; }
int countTriplets ( int [ ] arr , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) { ans ++ ; } } } } return ans ; }
int subarray ( int [ ] arr , int n ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = Math . Max ( ans , temp ) ; temp = 1 ; } } ans = Math . Max ( ans , temp ) ; return ans ; }
int firstNonRepeating ( String str ) { int NO_OF_CHARS = 256 ; int [ ] arr = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( arr [ str [ i ] ] == - 1 ) arr [ str [ i ] ] = i ; else arr [ str [ i ] ] = - 2 ; } int res = int . MaxValue ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = Math . Min ( res , arr [ i ] ) ; return res ; }
int minvalue_y ( int x ) { int n = ( int ) Math . Sqrt ( x ) ; if ( n * n == x ) return x + 1 ; return ( int ) Math . Pow ( n + 1 , 2 ) ; }
bool isSumEqual ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
void longestSubSequence ( int [ , ] A , int N ) { int [ ] dp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j , 0 ] < A [ i , 0 ] && A [ j , 1 ] > A [ i , 1 ] ) { dp [ i ] = Math . Max ( dp [ i ] , dp [ j ] + 1 ) ; } } } Console . Write ( dp [ N - 1 ] ) ; }
int sum ( int h ) { return ( int ) Math . Pow ( 2 , h - 1 ) ; }
bool isPowerOfTwo ( int n ) { return ( Math . Ceiling ( Math . Log ( n ) / Math . Log ( 2 ) ) == Math . Floor ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; }
int MaximumPath ( int [ , ] grid ) { int N = grid . GetLength ( 0 ) ; int M = grid . GetLength ( 1 ) ; int [ , ] sum = new int [ N + 1 , M + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { sum [ i , j ] = Math . Max ( sum [ i - 1 , j ] , sum [ i , j - 1 ] ) + grid [ i - 1 , j - 1 ] ; } } return sum [ N , M ] ; }
int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; }
int maxSelections ( int [ ] A , int n , int k ) { Array . Sort ( A ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }
int countNumber ( int N , int S ) { int countElements = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; }
int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( int ) ( ( a + ( i - 1 ) * d ) * ( b * Math . Pow ( r , i - 1 ) ) ) ; return sum ; }
bool areSetBitsIncreasing ( int n ) { int prev_count = int . MaxValue ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
bool isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }
bool find3Numbers ( int [ ] A , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { Console . WriteLine ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ j ] + " , ▁ " + A [ k ] ) ; return true ; } } } } return false ; }
int countInscribed ( int R1 , int R2 ) { if ( R2 > R1 ) return 0 ; double angle ; double ratio ; int number_of_circles = 0 ; ratio = R2 / ( double ) ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = Math . Abs ( Math . Asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = ( int ) ( 360 / ( 2 * Math . Floor ( angle ) ) ) ; } return number_of_circles ; }
bool checkHankelMatrix ( int n , int [ , ] m ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i , j ] != m [ i + j , 0 ] ) return false ; } else { if ( m [ i , j ] != m [ i + j - n + 1 , n - 1 ] ) return false ; } } } return true ; }
bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
int AND ( int [ ] a , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
void lowerWythoff ( int n ) { double phi = ( 1 + Math . Sqrt ( 5 ) ) / 2.0 ; for ( int i = 1 ; i <= n ; i ++ ) { double ans = Math . Floor ( i * phi ) ; Console . Write ( ( int ) ans ) ; if ( i != n ) Console . Write ( " ▁ , ▁ " ) ; } }
int find ( int A , int B , int C , int N ) { int [ ] arr = new int [ N ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; for ( int i = 3 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 3 ] ; } return arr [ N - 1 ] ; }
void findLine ( int distance , float degree ) { float x = ( float ) ( degree * 3.14159 / 180 ) ; if ( degree > 90 ) { Console . WriteLine ( " Not ▁ Possible " ) ; return ; } float result_1 = ( float ) ( Math . Sin ( x ) ) ; float result_2 = ( float ) ( Math . Cos ( x ) ) ; Console . WriteLine ( result_2 . ToString ( "0.00" ) + " x ▁ + " + result_1 . ToString ( "0.00" ) + " y ▁ = ▁ " + distance ) ; }
void findNumbers ( int n , int b ) { double even = 0 , odd = 0 ; if ( b % 2 == 0 ) { even = Math . Pow ( b , n ) - 2 ; odd = Math . Pow ( b , n ) - 1 ; } else { even = Math . Pow ( b , n ) - 1 ; odd = Math . Pow ( b , n ) - 2 ; } Console . WriteLine ( " Even ▁ Number ▁ = ▁ " + ( int ) even ) ; Console . Write ( " Odd ▁ Number ▁ = ▁ " + ( int ) odd ) ; }
void countPairs ( long L , long R ) { long firstNum = 2 * L ; long lastNum = 2 * R ; long Cntpairs = lastNum - firstNum + 1 ; Console . WriteLine ( Cntpairs ) ; }
int findMaxRec ( int [ ] A , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . Max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
bool checkSame ( int n ) { int set = 0 ; int unset = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; }
int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }
int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }
int singleelement ( int [ ] arr , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; }
void cal_cos ( float n ) { float accuracy = ( float ) 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( float ) ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . Cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= cosval - cosx ) ; Console . WriteLine ( cosx ) ; }
void splitString ( string str ) { StringBuilder alpha = new StringBuilder ( ) ; StringBuilder num = new StringBuilder ( ) ; StringBuilder special = new StringBuilder ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( Char . IsDigit ( str [ i ] ) ) num . Append ( str [ i ] ) ; else if ( ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) ) alpha . Append ( str [ i ] ) ; else special . Append ( str [ i ] ) ; } Console . WriteLine ( alpha ) ; Console . WriteLine ( num ) ; Console . WriteLine ( special ) ; }
int printCountDP ( int dist ) { int [ ] ways = new int [ 3 ] ; int n = dist ; ways [ 0 ] = 1 ; ways [ 1 ] = 1 ; ways [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] ; return ways [ n % 3 ] ; }
int calculateSum ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; }
int largest_subarray ( int [ ] a , int n ) { Dictionary < int , int > index = new Dictionary < int , int > ( ) ; int ans = 0 ; for ( int i = 0 , j = 0 ; i < n ; i ++ ) { j = Math . Max ( index . ContainsKey ( a [ i ] ) ? index [ a [ i ] ] : 0 , j ) ; ans = Math . Max ( ans , i - j + 1 ) ; if ( index . ContainsKey ( a [ i ] ) ) index [ a [ i ] ] = i + 1 ; else index . Add ( a [ i ] , i + 1 ) ; } return ans ; }
void permute ( String input ) { int n = input . Length ; int max = 1 << n ; input = input . ToLower ( ) ; for ( int i = 0 ; i < max ; i ++ ) { char [ ] combination = input . ToCharArray ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = ( char ) ( combination [ j ] - 32 ) ; } Console . Write ( combination ) ; Console . Write ( " ▁ " ) ; } }
int minimumSwaps ( int [ ] arr ) { int count = 0 ; int i = 0 ; while ( i < arr . Length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; }
int countSubarrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { long product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
void findSumOfGP ( double a , double r ) { if ( Math . Abs ( r ) >= 1 ) { Console . Write ( " Infinite " ) ; return ; } double sum = a / ( 1 - r ) ; Console . Write ( sum ) ; }
double area_of_tetrahedron ( int side ) { return ( Math . Sqrt ( 3 ) * ( side * side ) ) ; }
int countGroups ( int position , int previous_sum , int length , char [ ] num ) { if ( position == length ) return 1 ; if ( dp [ position , previous_sum ] != - 1 ) return dp [ position , previous_sum ] ; dp [ position , previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position , previous_sum ] = res ; return res ; }
void minXOR ( int [ ] Arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { Console . Write ( ( Arr [ i ] ^ 3 ) + " ▁ " ) ; } else { Console . Write ( ( Arr [ i ] ^ 2 ) + " ▁ " ) ; } } }
int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . Pow ( 2 , E - 1 ) ; }
int countSubstrings ( string s , char c ) { int n = s . Length ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
int countOccurrances ( int n , int d ) { int count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = n / 10 ; } return count ; }
String LexicographicalMaxString ( String str ) { String mx = " " ; for ( int i = 0 ; i < str . Length ; ++ i ) { if ( mx . CompareTo ( str . Substring ( i ) ) <= 0 ) { mx = str . Substring ( i ) ; } } return mx ; }
double nDigitPerfectSquares ( int n , int b ) { double largest = Math . Pow ( Math . Ceiling ( Math . Sqrt ( Math . Pow ( b , n ) ) ) - 1 , 2 ) ; return largest ; }
bool checkOverlap ( int R , int Xc , int Yc , int X1 , int Y1 , int X2 , int Y2 ) { int Xn = Math . Max ( X1 , Math . Min ( Xc , X2 ) ) ; int Yn = Math . Max ( Y1 , Math . Min ( Yc , Y2 ) ) ; int Dx = Xn - Xc ; int Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; }
int transformSubsequence ( int n , int m , int [ ] A , int [ ] B ) { if ( B . Length == 0 ) return n ; int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) dp [ i , j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) ; } } return n - dp [ n , m ] ; }
void multiplicativeCongruentialMethod ( int Xo , int m , int a , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } }
int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . Sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . Ceiling ( eq_root ) + l ) ; }
int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
int maxDistance ( int [ ] arr , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . ContainsKey ( arr [ i ] ) ) map . Add ( arr [ i ] , i ) ; else max_dist = Math . Max ( max_dist , i - map [ arr [ i ] ] ) ; } return max_dist ; }
bool check ( String str ) { int n = str . Length ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 8 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
int countCrossLine ( int [ ] arr , int n ) { int count_crossline = 0 ; int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
int knapSack ( int [ ] nums , int S ) { int sum = 0 ; foreach ( int i in nums ) sum += i ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; int [ ] dp = new int [ ( S + sum ) / 2 + 1 ] ; dp [ 0 ] = 1 ; foreach ( int num in nums ) { for ( int i = dp . Length - 1 ; i >= num ; i -- ) { dp [ i ] += dp [ i - num ] ; } } return dp [ dp . Length - 1 ] ; }
long minPerimeter ( int n ) { int l = ( int ) Math . Sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
long maxOR ( long [ ] arr , int n , int k , int x ) { long [ ] preSum = new long [ n + 1 ] ; long [ ] suffSum = new long [ n + 1 ] ; long res = 0 , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; }
int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return ( n & 1 ) > 0 ? 1 : 6 ; }
void countSubstrings ( string s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; foreach ( char i in s ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } Console . WriteLine ( ans ) ; }
int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
int maxConsecutiveCnt ( int [ ] arr ) { int X = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] <= ( X + 1 ) ) { X = X + arr [ i ] ; } else { break ; } } return X + 1 ; }
int findOddPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 1 ) ) { count ++ ; } } return count * ( count - 1 ) / 2 ; }
double sumOfTheSeries ( int n ) { double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
int numberofways ( int n , int m ) { int [ , ] dp = new int [ n + 2 , n + 2 ] ; dp [ 0 , n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i , k ] = dp [ i , k + 1 ] ; if ( i - k >= 0 ) dp [ i , k ] = ( dp [ i , k ] + dp [ i - k , k ] ) ; } } return dp [ n , m ] ; }
bool checkFittingArrays ( int [ ] A , int [ ] B , int N ) { Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
int getSum ( int n ) { return ( ( n - 1 ) + ( int ) Math . Pow ( n , 2 ) ) ; }
void recaman ( int n ) { int [ ] arr = new int [ n ] ; arr [ 0 ] = 0 ; Console . Write ( arr [ 0 ] + " ▁ , " ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; Console . Write ( arr [ i ] + " , ▁ " ) ; } }
bool divisorsSame ( int n ) { return ( n - 2 ) % 4 == 0 ; }
int maxDistance ( int [ ] array ) { int max1 = int . MinValue ; int min1 = int . MaxValue ; int max2 = int . MinValue ; int min2 = int . MaxValue ; for ( int i = 0 ; i < array . Length ; i ++ ) { max1 = Math . Max ( max1 , array [ i ] + i ) ; min1 = Math . Min ( min1 , array [ i ] + i ) ; max2 = Math . Max ( max2 , array [ i ] - i ) ; min2 = Math . Min ( min2 , array [ i ] - i ) ; } return Math . Max ( max1 - min1 , max2 - min2 ) ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
int fun ( int n ) { return n & ( n - 1 ) ; }
int findSum ( int n , int k ) { int val = ( k / ( n - 1 ) ) * n ; int rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } int sum = ( val * ( val + 1 ) ) / 2 ; int x = k / ( n - 1 ) ; int sum_of_multiples = ( x * ( x + 1 ) * n ) / 2 ; sum -= sum_of_multiples ; return sum ; }
int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; return solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
int findCount ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }
bool isdodecagonal ( int N ) { float n = ( float ) ( ( 4 + Math . Sqrt ( 20 * N + 16 ) ) / 10 ) ; return ( n - ( int ) n ) == 0 ; }
int solve ( int n , int k , int m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) return 0 ; if ( n < 0 k < 0 ) return 0 ; if ( dp [ n , k ] > 0 ) return dp [ n , k ] ; int ans = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n , k ] = ans ; }
void findTriplets ( int [ ] arr , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { Console . WriteLine ( arr [ i ] + " ▁ " + arr [ j ] + " ▁ " + arr [ k ] ) ; } } } } }
int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; }
int maxSum ( int [ ] arr , int i , int n , int k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = true ; int tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( int j = i ; j < ( i + k ) && ( j < n ) ; j ++ ) { tot += arr [ j ] ; dp [ i ] = Math . Max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; }
int countNonEmptySubstr ( string str ) { int n = str . Length ; return n * ( n + 1 ) / 2 ; }
void dfs ( int [ ] val , int [ ] cost , List < int > [ ] tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . Count ; i ++ ) { dfs ( val , cost , tr , tr [ u ] [ i ] , s ) ; } }
int nthTerm ( int n ) { return ( int ) Math . Pow ( n , 2 ) + 2 * n + 2 ; }
int numOfCombinations ( int [ ] arr , int N ) { int [ ] C = { 0 , 0 , 0 } ; for ( int i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
int minToggle ( int [ ] arr , int n ) { int [ ] zero = new int [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = Math . Min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
int XorSum ( int [ ] A , int [ ] B , int N , int M ) { int ans = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ans == - 1 ) ans = ( A [ i ] & B [ j ] ) ; else ans ^= ( A [ i ] & B [ j ] ) ; } } return ans ; }
void printSpiral ( int [ , ] mat , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) Console . Write ( mat [ low_row , i ] + " ▁ " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) Console . Write ( mat [ i , high_column ] + " ▁ " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) Console . Write ( mat [ high_row , i ] + " ▁ " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) Console . Write ( mat [ i , low_column ] + " ▁ " ) ; low_column -= 1 ; } Console . WriteLine ( ) ; }
void lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } Console . WriteLine ( ans ) ; }
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . Abs ( a * x + b * y + c ) ) / Math . Sqrt ( a * a + b * b ) ; if ( radius == dist ) Console . WriteLine ( " Touch " ) ; else if ( radius > dist ) Console . WriteLine ( " Intersect " ) ; else Console . WriteLine ( " Outside " ) ; }
int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; }
int countDe ( int [ ] arr , int n ) { int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; Array . Sort ( arr ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; Array . Reverse ( arr ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . Min ( count1 , count2 ) ) ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + ( float ) Math . Sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - ( float ) Math . Sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . Floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . Floor ( root2 ) == root2 ) return true ; return false ; }
int countPairs ( int [ ] arr , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; int res = 0 ; foreach ( KeyValuePair < int , int > x in map ) { int cnt = x . Value ; res += ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } return res ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = ( int ) ( Math . Pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) Console . Write ( ans ) ; else Console . Write ( 2 * ans ) ; }
int getMaxOnes ( int n , int x ) { int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; int total = n * n ; int ans = total - zeroes ; return ans ; }
int findCost ( string s1 , string s2 , int a , int b , int c , int d , int n ) { int cost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; else { if ( ( s1 [ i ] == '1' && s2 [ i ] == '2' ) || ( s2 [ i ] == '1' && s1 [ i ] == '2' ) ) cost += Math . Min ( d , Math . Min ( a , b + c ) ) ; else if ( ( s1 [ i ] == '2' && s2 [ i ] == '3' ) || ( s2 [ i ] == '2' && s1 [ i ] == '3' ) ) cost += Math . Min ( d , Math . Min ( b , a + c ) ) ; else if ( ( s1 [ i ] == '1' && s2 [ i ] == '3' ) || ( s2 [ i ] == '1' && s1 [ i ] == '3' ) ) cost += Math . Min ( d , Math . Min ( c , a + b ) ) ; } } return cost ; }
String canSplitArray ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= k ) { return " No " ; } } return " Yes " ; }
int getMaxGold ( int [ , ] gold , int m , int n ) { int [ , ] goldTable = new int [ m , n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) goldTable [ i , j ] = 0 ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row , col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 , col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 , col + 1 ] ; goldTable [ row , col ] = gold [ row , col ] + Math . Max ( right , Math . Max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 , 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . Max ( res , goldTable [ i , 0 ] ) ; return res ; }
int maximumChars ( string str ) { int n = str . Length ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str [ i ] ] ; if ( first_ind == - 1 ) firstInd [ str [ i ] ] = i ; else res = Math . Max ( res , Math . Abs ( i - first_ind - 1 ) ) ; } return res ; }
int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . Log10 ( i ) ; return ( int ) Math . Floor ( digits ) + 1 ; }
int minimumValue ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }
int maxGCD ( int n ) { return ( n / 2 ) ; }
float trianglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = ( float ) ( 3 * Math . Sqrt ( 3 ) * Math . Pow ( a , 2 ) ) / ( 4 * b ) ; return area ; }
int countPairsWithDiffK ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) Console . WriteLine ( first ) ; else if ( n == 6 ) Console . WriteLine ( sixth ) ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } Console . WriteLine ( curr ) ; }
bool isConvertible ( string str1 , string str2 , int k ) { if ( ( str1 . Length + str2 . Length ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . Min ( str1 . Length , str2 . Length ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . Length - str2 . Length + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
void poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { Console . WriteLine ( ( int ) Math . Ceiling ( Math . Log ( buckets ) / Math . Log ( ( minutesToTest / minutesToDie ) + 1 ) ) ) ; }
bool possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
void query ( string s , int i , int j ) { int n = s . Length ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
int findSum ( int [ ] arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l , r ] == 1 ) return dp [ l , r ] ; vis [ l , r ] = 1 ; dp [ l , r ] = Math . Min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; return dp [ l , r ] ; }
int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 ; int ans = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }
int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . ToCharArray ( ) ; for ( int i = 0 ; i < new_str . Length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
double distance ( int x1 , int y1 , int x2 , int y2 ) { return Math . Sqrt ( Math . Pow ( x2 - x1 , 2 ) + Math . Pow ( y2 - y1 , 2 ) * 1.0 ) ; }
void printArr ( int n ) { if ( n % 4 == 0 ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) Console . Write ( i * 2 + " ▁ " ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) Console . Write ( i * 2 - 1 + " ▁ " ) ; Console . WriteLine ( n + n / 2 - 1 ) ; } else Console . Write ( " - 1" ) ; }
int count ( int n ) { Dictionary < int , int > dp = new Dictionary < int , int > ( ) ; dp . Add ( 0 , 0 ) ; dp . Add ( 1 , 1 ) ; if ( ! dp . ContainsKey ( n ) ) dp . Add ( n , 1 + Math . Min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ) ; return dp [ n ] ; }
void nearestPerfectSquare ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = ( int ) Math . Sqrt ( arr [ i ] ) ; if ( ( sr & 1 ) == ( arr [ i ] & 1 ) ) Console . Write ( ( sr * sr ) + " ▁ " ) ; else { sr ++ ; Console . Write ( ( sr * sr ) + " ▁ " ) ; } } }
int find_next ( int n , int k ) { int M = n + 1 ; while ( true ) { if ( ( M & ( 1L << k ) ) > 0 ) break ; M ++ ; } return M ; }
int countCompositions ( int n ) { return 1 << ( n - 1 ) ; }
int rhombusAreaPeri ( int d1 , int d2 ) { int area , perimeter ; area = ( d1 * d2 ) / 2 ; perimeter = ( int ) ( 2 * Math . Sqrt ( Math . Pow ( d1 , 2 ) + Math . Pow ( d2 , 2 ) ) ) ; Console . WriteLine ( " The ▁ area ▁ of ▁ rhombus ▁ with ▁ " + " diagonals ▁ " + d1 + " ▁ and ▁ " + d2 + " ▁ is ▁ " + area + " . " ) ; Console . WriteLine ( " The ▁ perimeter ▁ of ▁ rhombus ▁ " + " with ▁ diagonals ▁ " + d1 + " ▁ and ▁ " + d2 + " ▁ is ▁ " + perimeter + " . " ) ; return 0 ; }
bool check ( String str ) { int n = str . Length ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 9 == 0 ) ; }
long productAscii ( String str ) { long prod = 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { prod *= str [ i ] ; } return prod ; }
int ways ( int [ ] arr , int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; }
int steps ( int source , int step , int dest ) { if ( Math . Abs ( source ) > ( dest ) ) return int . MaxValue ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . Min ( pos , neg ) ; }
int findCount ( string str ) { int result = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( i == ( str [ i ] - ' a ' ) || i == ( str [ i ] - ' A ' ) ) result ++ ; return result ; }
int shortestChainLen ( String start , String target , HashSet < String > D ) { if ( start == target ) return 0 ; if ( ! D . Contains ( target ) ) return 0 ; int level = 0 , wordlength = start . Length ; List < String > Q = new List < String > ( ) ; Q . Add ( start ) ; while ( Q . Count != 0 ) { ++ level ; int sizeofQ = Q . Count ; for ( int i = 0 ; i < sizeofQ ; ++ i ) { char [ ] word = Q [ 0 ] . ToCharArray ( ) ; Q . RemoveAt ( 0 ) ; for ( int pos = 0 ; pos < wordlength ; ++ pos ) { char orig_char = word [ pos ] ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) { word [ pos ] = c ; if ( String . Join ( " " , word ) . Equals ( target ) ) return level + 1 ; if ( ! D . Contains ( String . Join ( " " , word ) ) ) continue ; D . Remove ( String . Join ( " " , word ) ) ; Q . Add ( String . Join ( " " , word ) ) ; } word [ pos ] = orig_char ; } } } return 0 ; }
bool checkEvenPower ( int n ) { int x = 0 ; while ( x < n ) { int value = ( int ) Math . Pow ( 2 , x ) ; if ( value == n ) { if ( x % 2 == 0 ) return true ; else return false ; } x ++ ; } return false ; }
float Cel_To_Fah ( float n ) { return ( ( n * 9.0f / 5.0f ) + 32.0f ) ; }
void printpenta ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 1 ; int curr = 0 ; if ( n == 0 n == 1 n == 2 n == 3 ) Console . Write ( first + " STRNEWLINE " ) ; else if ( n == 5 ) Console . Write ( fifth + " STRNEWLINE " ) ; else { for ( int i = 5 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = curr ; } Console . Write ( curr + " STRNEWLINE " ) ; } }
int getSingle ( int [ ] arr , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
long countEvenSum ( int [ ] a , int n ) { long res = 0 ; int s = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] % 2 == 1 ) { s = n - i - 1 - s ; } else { s = s + 1 ; } res = res + s ; } return res ; }
float areaOfKite ( int a , int b , double angle ) { angle = angle * PI ; double area = a * b * Math . Sin ( angle ) ; return ( float ) area ; }
int minSumDifference ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; int rem = sum % n ; return rem * ( n - rem ) ; }
int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
void sum_of_elements ( int [ ] arr , int n ) { int sumfirst = 0 , sumsecond = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { sumfirst += arr [ i ] ; } else { sumsecond += arr [ i ] ; } } Console . WriteLine ( " Sum ▁ of ▁ first ▁ half ▁ elements ▁ is ▁ " + sumfirst ) ; Console . WriteLine ( " Sum ▁ of ▁ second ▁ half ▁ elements ▁ is ▁ " + sumsecond ) ; }
bool isUnique ( int [ ] a , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
bool check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
int sum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * ( int ) Math . Pow ( 2 , n - 1 ) ; return sum ; }
int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; }
bool isFancy ( String num ) { Dictionary < char , char > fp = new Dictionary < char , char > ( ) ; fp . Add ( '0' , '0' ) ; fp . Add ( '1' , '1' ) ; fp . Add ( '6' , '9' ) ; fp . Add ( '8' , '8' ) ; fp . Add ( '9' , '6' ) ; int n = num . Length ; int l = 0 , r = n - 1 ; while ( l <= r ) { if ( ! fp . ContainsKey ( num [ l ] ) fp [ num [ l ] ] != num [ r ] ) return false ; l ++ ; r -- ; } return true ; }
void check ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
bool almostSort ( int [ ] A , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
int no_of_digit ( int a , int b ) { return ( ( int ) ( b * Math . Log10 ( a ) ) + 1 ) ; }
void SubarraysWithSumS ( int n , int k , int s ) { for ( int i = 0 ; i < k ; i ++ ) Console . Write ( s + " ▁ " ) ; for ( int i = k ; i < n ; i ++ ) Console . Write ( s + 1 + " ▁ " ) ; }
int maxSum ( int p0 , int p1 , int [ ] a , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . Max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . Max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) + 2 * n - 5 ; }
void isEqualFactors ( int N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
int maxSum ( int [ ] a , int n ) { Array . Sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; }
int MaxTraceSub ( int [ ] [ ] mat ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . Max ( trace , max_trace ) ; } } } return max_trace ; }
int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
int maxCandies ( int [ ] arr , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = Math . Min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
int multiply ( int x , int n ) { return x << n ; }
int countDistinctCode ( String str ) { HashSet < String > codes = new HashSet < String > ( ) ; for ( int i = 0 ; i < str . Length - 1 ; i ++ ) codes . Add ( str . Substring ( i , 2 ) ) ; return codes . Count ; }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }
int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . Floor ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; int right = left * 2 ; return Math . Min ( ( n - left ) , ( right - n ) ) ; }
float hexadiagonal ( float a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }
void print_triplet ( int [ ] arr , int n ) { for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { Console . Write ( i - 1 + " ▁ " + i + " ▁ " + ( i + 1 ) ) ; return ; } } Console . Write ( - 1 ) ; }
void canBeReduced ( int x , int y ) { int maxi = Math . Max ( x , y ) ; int mini = Math . Min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) { return - 1 ; } Array . Sort ( arr ) ; return Math . Max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
void maxProductSum ( string str , int m ) { int n = str . Length ; int maxProd = int . MinValue , maxSum = int . MinValue ; for ( int i = 0 ; i <= n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str [ j ] - '0' ) ; sum = sum + ( str [ j ] - '0' ) ; } maxProd = Math . Max ( maxProd , product ) ; maxSum = Math . Max ( maxSum , sum ) ; } Console . WriteLine ( " Maximum ▁ Product ▁ = ▁ " + maxProd ) ; Console . Write ( " STRNEWLINE Maximum ▁ Sum ▁ = ▁ " + maxSum ) ; }
int maxLenSubStr ( String s ) { if ( s . Length < 3 ) return s . Length ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . Length ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = Math . Max ( temp , ans ) ; temp = 2 ; } } ans = Math . Max ( temp , ans ) ; return ans ; }
void printGMeans ( int A , int B , int N ) { float R = ( float ) Math . Pow ( ( float ) ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( A * Math . Pow ( R , i ) + " ▁ " ) ; }
int Maxlen ( int [ ] arr , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = Math . Max ( ans , count ) ; } return ans ; }
float normal ( float m , float n ) { float N = ( float ) ( ( Math . Abs ( m ) * Math . Abs ( n ) ) / Math . Sqrt ( ( Math . Abs ( m ) * Math . Abs ( m ) ) + ( Math . Abs ( n ) * Math . Abs ( n ) ) ) ) ; return N ; }
void getPairs ( int [ ] arr , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } Console . Write ( count ) ; }
int countEvenSum ( int [ ] arr , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
int countWords ( String str ) { int state = OUT ; int wc = 0 ; int i = 0 ; while ( i < str . Length ) { if ( str [ i ] == ' ▁ ' str [ i ] == ' STRNEWLINE ' str [ i ] == ' TABSYMBOL ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }
int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
void construct_Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( K * i + " ▁ " ) ; } }
void minSum ( int N ) { int ans = ( int ) Math . Ceiling ( 2 * Math . Sqrt ( N + 1 ) ) ; Console . WriteLine ( ans ) ; }
int concentric_Hexagon ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) / 2 ; }
int getValue ( int [ ] arr , int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int min = arr [ i ] ; int max = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { min = Math . Min ( arr [ j ] , min ) ; max = Math . Max ( arr [ j ] , max ) ; dp [ i ] = Math . Max ( dp [ i ] , max - min + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; }
int nthTerm ( int n ) { return 6 * ( int ) Math . Pow ( n , 2 ) - 4 * n - 2 ; }
int minInsertionStepToSortArray ( int [ ] arr , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
bool isIdentity ( int [ , ] mat , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row , col ] != 1 ) return false ; else if ( row != col && mat [ row , col ] != 0 ) return false ; } } return true ; }
int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
int largestKSubmatrix ( int [ , ] a ) { int [ , ] dp = new int [ Row , Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i , j ] = 1 ; else { if ( a [ i , j ] == a [ i - 1 , j ] && a [ i , j ] == a [ i , j - 1 ] && a [ i , j ] == a [ i - 1 , j - 1 ] ) { dp [ i , j ] = ( dp [ i - 1 , j ] > dp [ i , j - 1 ] && dp [ i - 1 , j ] > dp [ i - 1 , j - 1 ] + 1 ) ? dp [ i - 1 , j ] : ( dp [ i , j - 1 ] > dp [ i - 1 , j ] && dp [ i , j - 1 ] > dp [ i - 1 , j - 1 ] + 1 ) ? dp [ i , j - 1 ] : dp [ i - 1 , j - 1 ] + 1 ; } else dp [ i , j ] = 1 ; } result = result > dp [ i , j ] ? result : dp [ i , j ] ; } } return result ; }
int nobleInteger ( int [ ] arr ) { int size = arr . Length ; for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }
int minCost ( string A , string B ) { int n = A . Length ; int i = 0 ; int maxlen = 0 ; while ( i < n ) { int length = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ] == B [ j ] ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = Math . Max ( maxlen , length ) ; } return n - maxlen ; }
void equation_parabola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; float e1 = - 2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; Console . WriteLine ( " equation ▁ of ▁ parabola ▁ is ▁ " + a1 + " ▁ x ^ 2 ▁ + ▁ " + b1 + " ▁ y ^ 2 ▁ + ▁ " + c1 + " ▁ x ▁ + ▁ " + d1 + " ▁ y ▁ + ▁ " + e1 + " ▁ xy ▁ + ▁ " + f1 + " ▁ = ▁ 0 . " ) ; }
int nthTerm ( int n ) { return 5 * ( int ) Math . Pow ( n , 2 ) - 5 * n ; }
int findNthNonSquare ( int n ) { double x = ( double ) n ; double ans = x + Math . Floor ( 0.5 + Math . Sqrt ( x ) ) ; return ( int ) ans ; }
void isEqualFactors ( int N ) { int ev_count = 0 , od_count = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count == od_count ) Console . Write ( " YES " + " STRNEWLINE " ) ; else Console . Write ( " NO " + " STRNEWLINE " ) ; }
long SubArraySum ( int [ ] arr , int n ) { long result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
int countsubarray ( int [ ] array , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
void oddDivisors ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int powerOfTwo = 2 ; int count = 0 ; while ( powerOfTwo <= arr [ i ] ) { count ++ ; powerOfTwo = 2 * powerOfTwo ; } Console . Write ( count + " ▁ " ) ; } return ; }
int printKDistinct ( int [ ] arr , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } Console . WriteLine ( " Number ▁ of ▁ different ▁ bits ▁ : ▁ " + count ) ; }
int getMissingNo ( int [ ] a , int n ) { int i , total = 1 ; for ( i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
void sumOfSubarrayProd ( int [ ] arr , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } Console . WriteLine ( ans ) ; }
void convert ( string str ) { int n = str . Length ; string str1 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ▁ ' ) str1 = str1 + ' _ ' ; else str1 = str1 + Char . ToLower ( str [ i ] ) ; } Console . Write ( str1 ) ; }
void perfectSquares ( float l , float r ) { int number = ( int ) Math . Ceiling ( Math . Sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { Console . Write ( n2 + " ▁ " ) ; n2 = n2 + number ; number += 2 ; } }
float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . Sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
void printDistinct ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . Length ; i ++ ) if ( str [ i ] != ' ▁ ' ) count [ ( int ) str [ i ] ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ ( int ) str [ i ] ] == 1 ) Console . Write ( str [ i ] ) ; }
void reverse ( String str ) { if ( ( str == null ) || ( str . Length <= 1 ) ) Console . Write ( str ) ; else { Console . Write ( str [ str . Length - 1 ] ) ; reverse ( str . Substring ( 0 , ( str . Length - 1 ) ) ) ; } }
int countZeros ( int x ) { int total_bits = sizeofInt * 8 ; int res = 0 ; while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) { x = ( x << 1 ) ; res ++ ; } return res ; }
int smallestOdd ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
bool isSubsetSum ( int [ ] set , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int minMergeCost ( int i , int j , int [ ] arr ) { if ( i == j ) return 0 ; if ( v [ i , j ] ) return dp [ i , j ] ; v [ i , j ] = true ; int x = dp [ i , j ] ; x = int . MaxValue ; int tot = 0 ; for ( int k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { x = Math . Min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }
String compute ( string str , int n ) { string reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " ; int l = str . Length ; String answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer = answer + str [ i ] ; for ( int i = n ; i < l ; i ++ ) answer = answer + reverseAlphabet [ str [ i ] - ' a ' ] ; return answer ; }
int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
float CubeVolume ( float d ) { float Volume ; Volume = ( float ) ( Math . Sqrt ( 3 ) * Math . Pow ( d , 3 ) ) / 9 ; return Volume ; }
void printRotatedString ( String str ) { int n = str . Length ; StringBuilder sb = new StringBuilder ( str ) ; sb . Append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) Console . Write ( sb [ i + j ] ) ; Console . WriteLine ( ) ; } }
bool checkArrInStack ( Stack < int > s , int [ ] arr , int n ) { Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( freq . ContainsKey ( arr [ i ] ) ) freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 ; else freq . Add ( arr [ i ] , 1 ) ; while ( s . Count != 0 ) { int poppedEle = s . Peek ( ) ; s . Pop ( ) ; if ( freq . ContainsKey ( poppedEle ) ) freq [ poppedEle ] = freq [ poppedEle ] - 1 ; } if ( freq . Count == 0 ) return false ; return true ; }
void maxValueAtIndexK ( int N , int K , int M ) { int S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; int X = ( M + S1 + S2 ) / N ; Console . WriteLine ( X ) ; }
float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; }
bool flipsPossible ( int [ ] a , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }
void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) Console . Write ( i + " ▁ " ) ; }
int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; }
int geometricMean ( int n ) { return ( int ) Math . Sqrt ( n ) ; }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; Console . Write ( ith_term + " , ▁ " ) ; } }
int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
bool checkEvenPower ( long N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; }
int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
int maximumSum ( List < int > A , int N , int K , int D ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) { int sum = 0 ; int c = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( i >> j & 1 ) != 0 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = Math . Max ( ans , sum ) ; } return ans ; }
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
int distribution ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . Min ( count , n / 2 ) ; }
int nondecdigits ( int n ) { int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; bool flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; }
bool checkRectangles ( int [ ] arr , int n ) { bool ans = true ; Array . Sort ( arr ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }
bool isKAlternating ( String s , int k ) { if ( s . Length < k ) return false ; int checker = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int bitAtIndex = s [ i ] - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( int i = k ; i < s . Length ; i ++ ) if ( s [ i - k ] != s [ i ] ) return false ; return true ; }
int noOfTriangles ( int n ) { return ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
void printORSumforEachElement ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int req_sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { req_sum += ( arr [ i ] arr [ j ] ) ; } Console . Write ( req_sum + " ▁ " ) ; } }
bool isCenteredOctadecagonal ( int N ) { double n = ( 9 + Math . Sqrt ( 36 * N + 45 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
bool isPossible ( int w , int h , int x , int y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }
string isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + 3 * n - 5 ; }
int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; } return 2 * cnt ; }
int countPS ( string str ) { int N = str . Length ; int [ , ] cps = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i , i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( k < N ) { if ( str [ i ] == str [ k ] ) cps [ i , k ] = cps [ i , k - 1 ] + cps [ i + 1 , k ] + 1 ; else cps [ i , k ] = cps [ i , k - 1 ] + cps [ i + 1 , k ] - cps [ i + 1 , k - 1 ] ; } } } return cps [ 0 , N - 1 ] ; }
String convert ( String s ) { int n = s . Length ; String s1 = " " ; s1 = s1 + Char . ToLower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s1 = s1 + " ▁ " + Char . ToLower ( s [ i + 1 ] ) ; i ++ ; } else s1 = s1 + Char . ToUpper ( s [ i ] ) ; } return s1 ; }
void divParts ( int N ) { if ( N % 2 == 0 ) Console . WriteLine ( ( N / 2 ) - 1 ) ; else Console . WriteLine ( ( N / 2 ) ) ; }
String sortString ( String str , int n ) { int i ; char [ ] arr = new char [ 26 ] ; String new_str = " " ; for ( i = 0 ; i < n ; i ++ ) ++ arr [ str [ i ] - ' a ' ] ; for ( i = 0 ; i < 26 ; i ++ ) while ( arr [ i ] -- > 0 ) { new_str += String . Join ( " " , ( char ) ( i + ' a ' ) ) ; } return new_str ; }
void compute ( int [ ] query ) { int [ ] v = new int [ 100001 ] ; int [ ] dp = new int [ 100001 ] ; v [ 1 ] = 1 ; v [ 2 ] = 0 ; dp [ 1 ] = 0 ; dp [ 2 ] = 0 ; for ( int i = 3 ; i < 100001 ; i ++ ) { if ( i % 2 != 0 ) { if ( ( i / 2 ) % 2 == 0 ) { v [ i ] = 1 ; dp [ i ] = dp [ i - 1 ] ; } else { v [ i ] = v [ i / 2 ] + 1 ; dp [ i ] = dp [ i - 1 ] + v [ i ] - 1 ; } } else { v [ i ] = 0 ; dp [ i ] = dp [ i - 1 ] ; } } foreach ( int x in query ) Console . Write ( dp [ x ] + " STRNEWLINE " ) ; }
int number_of_ways ( int [ ] arr , int n , int k ) { if ( k == 1 ) return 1 ; int [ ] dp = new int [ k + 1 ] ; int i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }
bool isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
double Avgdifference ( double [ ] arr , int N , int K ) { double min = 1000000 , max = - 1 ; for ( int i = 0 ; i <= N - K ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < K ; j ++ ) { sum += arr [ i + j ] ; } if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
bool isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; }
bool unique ( String s ) { Array . Sort ( s . ToCharArray ( ) ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { return false ; } } return true ; }
int maxArea ( int [ ] A , int len ) { int l = 0 ; int r = len - 1 ; int area = 0 ; while ( l < r ) { area = Math . Max ( area , Math . Min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; }
int countSquares ( int row , int column ) { int topLeft = Math . Min ( row , column ) - 1 ; int bottomRight = 8 - Math . Max ( row , column ) ; int topRight = Math . Min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - Math . Max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; }
float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; float r1 = r ; float h1 = h ; float V = ( float ) ( 3.14 * Math . Pow ( r1 , 2 ) * h1 ) ; return V ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = Math . Max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }
bool isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; }
void countCountries ( int [ ] ans , int N ) { int total_countries = 0 , i = 0 ; while ( i < N ) { int curr_size = ans [ i ] ; int num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { Console . Write ( " Invalid ▁ Answer STRNEWLINE " ) ; return ; } else num -- ; i ++ ; } total_countries ++ ; } Console . Write ( " There ▁ are ▁ " + total_countries + " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . STRNEWLINE " ) ; }
double vol_tetra ( int side ) { double volume = ( Math . Pow ( side , 3 ) / ( 6 * Math . Sqrt ( 2 ) ) ) ; return volume ; }
bool isicositetragonal ( int N ) { float n = ( float ) ( ( 10 + Math . Sqrt ( 44 * N + 100 ) ) / 22 ) ; return ( n - ( int ) n ) == 0 ; }
int squareSum ( int n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
String checkNumber ( int N ) { int temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp /= 1000 ; else if ( temp % 100 == 14 ) temp /= 100 ; else if ( temp % 10 == 1 ) temp /= 10 ; else { return " NO " ; } } return " YES " ; }
long center_pentadecagonal_num ( long n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
long cntEvenSumPairs ( long X , long Y ) { long cntXEvenNums = X / 2 ; long cntXOddNums = ( X + 1 ) / 2 ; long cntYEvenNums = Y / 2 ; long cntYOddNums = ( Y + 1 ) / 2 ; long cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; }
void printRLE ( String s ) { for ( int i = 0 ; i < s . Length - 1 ; i ++ ) { int count = 1 ; while ( s [ i ] == s [ i + 1 ] ) { i ++ ; count ++ ; if ( i + 1 == s . Length ) break ; } Console . Write ( s [ i ] + " " + count + " ▁ " ) ; } Console . WriteLine ( ) ; }
string getCount ( int N ) { if ( N % 2 == 1 ) return "0" ; string result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
bool isKPartitionPossible ( int [ ] arr , int N , int K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; int target = sum / K ; int [ ] dp = new int [ ( 1 << 15 ) ] ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == - 1 ) continue ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( ( mask & ( 1 << i ) ) == 0 ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; }
void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) Console . WriteLine ( "2 ▁ solutions " ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) Console . WriteLine ( "1 ▁ solution " ) ; else Console . WriteLine ( " No ▁ solutions " ) ; }
int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; }
int minOperations ( int [ ] arr , int n ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . ContainsKey ( arr [ i ] ) ) { var val = m [ arr [ i ] ] ; m . Remove ( arr [ i ] ) ; m . Add ( arr [ i ] , val + 1 ) ; } else { m . Add ( arr [ i ] , 1 ) ; } } int maxFreq = int . MinValue ; maxFreq = m . Values . Max ( ) ; return ( n - maxFreq ) ; }
float slope ( float x1 , float y1 , float x2 , float y2 ) { if ( x1 == x2 ) return 1000000000 ; return ( y2 - y1 ) / ( x2 - x1 ) ; }
int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; }
int smallestMaximum ( int N , int K ) { int sum = ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return ( sum / N ) + 1 ; else return sum / N ; }
int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } }
int countDigit ( int n ) { bool [ ] prime = new bool [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) prime [ i ] = false ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] == true ) count ++ ; } return count ; }
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
void make_sequence ( int N ) { int [ ] arr = new int [ N + 1 ] ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; }
float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . Pow ( ( a * Math . Sqrt ( 3 ) ) / ( Math . Sqrt ( 2 ) ) , 2 ) ; return area ; }
int findBucketNo ( int p ) { return ( int ) Math . Ceiling ( ( Math . Sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
int min_cost ( String S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; foreach ( char c in S . ToCharArray ( ) ) if ( c == ' ▁ ' ) count ++ ; int n = S . Length - count ; if ( n == 1 ) return cost ; foreach ( char inn in S . ToCharArray ( ) ) { if ( inn != ' ▁ ' ) { if ( B != 0 ) { cost += Math . Min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }
float sph ( float r , float h ) { if ( r < 0 && h < 0 ) return - 1 ; float R = r ; return R ; }
int printTriplets ( int [ ] arr , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) Console . WriteLine ( arr [ i ] + " , ▁ " + arr [ j ] + " , ▁ " + arr [ k ] ) ; } } return 0 ; }
void translate ( char [ ] str ) { for ( int i = 1 ; i < str . Length ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; int j ; for ( j = i ; j < str . Length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ▁ ' ; } } return ; }
int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
int largestArea ( int [ ] arr1 , int n , int [ ] arr2 , int m ) { int end = 0 , start = 0 , i = 0 , j = 0 ; Array . Sort ( arr1 ) ; Array . Sort ( arr2 ) ; while ( i < n && j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 start == 0 ) return 0 ; else return ( end - start ) ; }
int xorPairCount ( int [ ] arr , int n , int x ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . Contains ( x ^ arr [ i ] ) ) { result ++ ; } s . Add ( arr [ i ] ) ; } return result ; }
void perfectSquares ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( Math . Sqrt ( i ) == ( int ) Math . Sqrt ( i ) ) Console . Write ( i + " ▁ " ) ; } }
int getCount ( String a , String b ) { if ( b . Length % a . Length != 0 ) return - 1 ; int count = b . Length / a . Length ; String str = " " ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str . Equals ( b ) ) return count ; return - 1 ; }
bool areVowelsInOrder ( string s ) { int n = s . Length ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { if ( s [ i ] < c ) { return false ; } else { c = s [ i ] ; } } } return true ; }
int printNthElement ( int n ) { int [ ] arr = new int [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }
int countSub ( String str ) { int n = ( int ) str . Length ; int ans = 0 ; int [ ] cnt = new int [ 26 ] ; int i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str [ j ] - ' a ' ] == 0 ) ) { cnt [ str [ j ] - ' a ' ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str [ i ] - ' a ' ] -- ; i ++ ; } } return ans ; }
int bitwiseOrTillN ( int n ) { if ( n < 2 ) return 0 ; int bitCount = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; return ( int ) Math . Pow ( 2 , bitCount ) - 2 ; }
float largestCube ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 2 * r ) / ( float ) Math . Sqrt ( 3 ) ; return a ; }
void performQueries ( int n , int q , int k , int [ ] arr , int [ , ] query ) { for ( int i = 1 ; i <= q ; i ++ ) { int count = 0 ; if ( query [ i - 1 , 0 ] == 1 ) { for ( int j = query [ i - 1 , 1 ] ; j <= query [ i - 1 , 2 ] ; j ++ ) { if ( arr [ j ] == k ) count ++ ; } Console . WriteLine ( count ) ; } else { arr [ query [ i - 1 , 1 ] ] = query [ i - 1 , 2 ] ; } } }
bool isDivisible ( String str , int k ) { int n = str . Length ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; }
float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float area = ( l * b ) / 2 ; return area ; }
int kthNum ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; }
double area ( double a , double b , double c ) { double d = Math . Abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
int cntSubarr ( int [ ] arr , int N ) { int res = 0 ; int prefixXor = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }
int findMaxValue ( int N , int [ , ] mat ) { int maxValue = int . MinValue ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d , e ] - mat [ a , b ] ) ) maxValue = mat [ d , e ] - mat [ a , b ] ; return maxValue ; }
void find_set ( int n ) { if ( n <= 2 ) { Console . WriteLine ( " - 1" ) ; return ; } int sum1 = ( n * ( n - 1 ) ) / 2 ; int sum2 = n ; Console . WriteLine ( sum1 + " ▁ " + sum2 ) ; }
bool uniqueCharacters ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { int bitAtIndex = str [ i ] - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; }
int breakEvenPoint ( int exp1 , int S , int M ) { double earn = S - M ; double exp = exp1 ; double res = Math . Ceiling ( exp / earn ) ; int res1 = ( int ) res ; return res1 ; }
int closetAND ( int [ ] arr , int n , int k ) { int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . Min ( ans , Math . Abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; }
int longestPalSubstr ( string str ) { int n = str . Length ; int maxLength = 1 , start = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { for ( int j = i ; j < str . Length ; j ++ ) { int flag = 1 ; for ( int k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str [ i + k ] != str [ j - k ] ) flag = 0 ; if ( flag != 0 && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }
int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; }
int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; }
int getNumToAdd ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; int numToAdd = - 1 ; bool numAdded = false ; for ( int i = 2 ; i < n ; i ++ ) { int diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; }
int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
float vol_of_dodecahedron ( int side ) { return ( float ) ( ( ( 15 + ( 7 * ( Math . Sqrt ( 5 ) ) ) ) / 4 ) * ( Math . Pow ( side , 3 ) ) ) ; }
bool CheckArray ( int [ ] arr , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) Console . Write ( i + " ▁ " ) ; }
long nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m % 2 != 0 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; }
int Nth_Term ( int n ) { return ( int ) ( 3 * System . Math . Pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int minDiffSubArray ( int [ ] arr , int n ) { int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) total_sum += arr [ i ] ; int prefix_sum = 0 ; int minDiff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix_sum += arr [ i ] ; int diff = Math . Abs ( ( total_sum - prefix_sum ) - prefix_sum ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
void countOfNumbers ( int N ) { int ans = 1 ; for ( int index = 1 ; index <= N ; ++ index ) { int choices = 0 ; for ( int digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * choices ) % mod ; } Console . Write ( ans ) ; }
int maxSum ( int [ ] arr , int n ) { int res = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . Max ( res , curr_sum ) ; } return res ; }
void printMultiples ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { Console . Write ( ( i * j ) + " ▁ " ) ; } Console . WriteLine ( ) ; } }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; Console . WriteLine ( edges_max_secondary + 3 ) ; } else Console . WriteLine ( " Not ▁ Possible " ) ; }
bool check ( int [ ] a , int n ) { bool flag = false ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = true ; } if ( flag ) return false ; else return true ; }
int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) ( 7 * Math . Pow ( 8 , i - 1 ) ) ; } return sum ; }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
int isSumDivides ( int N ) { int temp = N , sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
void possibleOrNot ( long a1 , long a2 , long b1 , long b2 , long c1 , long c2 ) { long dis1 = ( long ) Math . Pow ( b1 - a1 , 2 ) + ( long ) Math . Pow ( b2 - a2 , 2 ) ; long dis2 = ( long ) Math . Pow ( c1 - b1 , 2 ) + ( long ) Math . Pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) Console . Write ( " No " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) Console . Write ( " No " ) ; else Console . Write ( " Yes " ) ; }
void numberOfGates ( string s ) { int N = s . Length ; int ans = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' . ' s [ i ] == ' + ' s [ i ] == '1' ) { ans ++ ; } } Console . WriteLine ( ans ) ; }
bool areSumSame ( int [ , ] a , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i , j ] ; sum2 += a [ j , i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
int minRemoval ( string str ) { int [ ] hash = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) hash [ i ] = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) hash [ str [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( hash [ i ] % 2 == 1 ) count ++ ; return ( count == 0 ) ? 0 : count - 1 ; }
string areBookingsPossible ( int [ ] A , int [ ] B , int K ) { Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < A . Length ; i ++ ) { if ( i + K < A . Length && A [ i + K ] < B [ i ] ) { return " No " ; } } return " Yes " ; }
int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . Pow ( b , 2 ) ; }
void countPairsWithDiffK ( int [ ] arr , int N , int K ) { int [ ] vis = new int [ N ] ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( vis [ i ] == 1 ) continue ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( vis [ j ] == 1 ) continue ; if ( Math . Abs ( arr [ i ] - arr [ j ] ) >= K ) { count ++ ; vis [ i ] = 1 ; vis [ j ] = 1 ; break ; } } } Console . Write ( count ) ; }
int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
void checkPoint ( int radius , int x , int y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; float polarradius = ( float ) Math . Sqrt ( x * x + y * y ) ; float Angle = ( float ) Math . Atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) Console . Write ( " Point ▁ ( { 0 } , ▁ { 1 } ) ▁ exist ▁ in ▁ " + " the ▁ circle ▁ sector " , x , y ) ; else Console . Write ( " Point ▁ ( { 0 } , ▁ { 1 } ) ▁ does ▁ not ▁ " + " exist ▁ in ▁ the ▁ circle ▁ sector " , x , y ) ; }
void addAP ( int [ ] A , int Q , int [ , ] operations ) { for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j , 0 ] , R = operations [ j , 1 ] , a = operations [ j , 2 ] , d = operations [ j , 3 ] ; int curr = a ; for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr ; curr += d ; } } for ( int i = 0 ; i < 4 ; ++ i ) Console . Write ( A [ i ] + " ▁ " ) ; }
int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
bool SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }
void getBuckets ( int [ ] arr , int N ) { int availableWater = N * ( N - 1 ) / 2 ; Array . Sort ( arr ) ; int i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } Console . Write ( i - 1 ) ; }
void constructXORArray ( int [ ] A , int n , int K ) { int [ ] B = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) B [ i ] = A [ i ] ^ K ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( B [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; }
int countElements ( int [ ] p , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }
int largestGCDSubsequence ( int [ ] arr , int n ) { int ans = 0 ; int maxele = arr . Max ( ) ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . Max ( ans , count ) ; } return ans ; }
int CountTriangles ( int n ) { int curr = 1 ; int Tri_count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { Tri_count = ( curr * 3 ) + 2 ; curr = Tri_count ; } return Tri_count ; }
int findPermutation ( HashSet < int > arr , int N ) { int pos = arr . Count + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! arr . Contains ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . Add ( i ) ; res += findPermutation ( arr , N ) ; arr . Remove ( i ) ; } } } return res ; }
int intersection ( int n ) { return n * ( n - 1 ) ; }
void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; Console . Write ( Median ) ; }
void find_winner ( String str , int n ) { String str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str [ i ] ; } else { str2 += str [ i ] ; } } char [ ] a = str1 . ToCharArray ( ) ; Array . Sort ( a ) ; char [ ] b = str2 . ToCharArray ( ) ; Array . Sort ( b ) ; str1 = new String ( a ) ; str2 = new String ( b ) ; if ( str1 . CompareTo ( str2 ) < 0 ) Console . Write ( " A " ) ; else if ( str1 . CompareTo ( str2 ) > 0 ) Console . Write ( " B " ) ; else Console . Write ( " Tie " ) ; }
bool checkIndices ( int [ ] Arr , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
void largestSquare ( int [ , ] matrix , int R , int C , int [ ] q_i , int [ ] q_j , int K , int Q ) { int [ , ] countDP = new int [ R , C ] ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) countDP [ i , j ] = 0 ; countDP [ 0 , 0 ] = matrix [ 0 , 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i , 0 ] = countDP [ i - 1 , 0 ] + matrix [ i , 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 , j ] = countDP [ 0 , j - 1 ] + matrix [ 0 , j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i , j ] = matrix [ i , j ] + countDP [ i - 1 , j ] + countDP [ i , j - 1 ] - countDP [ i - 1 , j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . Min ( Math . Min ( i , j ) , Math . Min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 , y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 , y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 , y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 , y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } Console . WriteLine ( ans ) ; } }
int numPairs ( int [ ] a , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . Abs ( a [ i ] ) ; Array . Sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; }
int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
int findMaxPairs ( int [ ] a , int [ ] b , int n , int k ) { Array . Sort ( a ) ; Array . Sort ( b ) ; int result = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { if ( Math . Abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }
void commonSubstring ( string s ) { int n = s . Length ; int i = 0 ; int j = n - 1 ; string ans = " " ; while ( j >= 0 ) { if ( s [ i ] == s [ j ] ) { ans += s [ i ] ; i ++ ; j -- ; } else { break ; } } if ( ans . Length == 0 ) Console . WriteLine ( " False " ) ; else { Console . WriteLine ( " True ▁ " ) ; Console . WriteLine ( ans ) ; } }
int countTriplets ( int n , int sum ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) ans ++ ; } } return ans ; }
int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
int countOddSum ( int [ ] ar , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
void solve ( int n ) { int n_2 = n / 2 ; String den ; den = "1" ; while ( n_2 -- > 0 ) den += '0' ; Console . WriteLine ( 1 + " / " + den ) ; }
int findNthDigit ( int p , int q , int N ) { int res = 0 ; while ( N > 0 ) { N -- ; p *= 10 ; res = p / q ; p %= q ; } return res ; }
int countWays ( int n , int m ) { int [ ] count = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
void isKthBitSet ( int n , int k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) Console . Write ( " SET " ) ; else Console . Write ( " NOT ▁ SET " ) ; }
int countXorPair ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
void divide ( int n , int m ) { Console . WriteLine ( " Remainder ▁ = ▁ " + ( ( n ) & ( m - 1 ) ) ) ; Console . WriteLine ( " Quotient ▁ = ▁ " + ( n >> ( int ) ( Math . Log ( m ) ) ) ) ; }
int subString ( string s , int n ) { Dictionary < int , int > hash = new Dictionary < int , int > ( ) ; hash [ 0 ] = 1 ; int pre = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << ( int ) ( s [ i ] ) - 97 ) ; if ( hash . ContainsKey ( pre ) ) count += hash [ pre ] ; else count += 0 ; if ( hash . ContainsKey ( pre ) ) hash [ pre ] = hash [ pre ] + 1 ; else hash . Add ( pre , 1 ) ; } return count ; }
int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . Sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
int binarySearch ( String [ ] arr , String x ) { int l = 0 , r = arr . Length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; int res = x . CompareTo ( arr [ m ] ) ; if ( res == 0 ) return m ; if ( res > 0 ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) Console . Write ( i + " ▁ " ) ; }
int positionAfterKJumps ( int X , int Y , int K ) { int addY = Y * ( K / 2 ) ; int reduceX = - 1 * X * ( K / 2 + K % 2 ) ; return addY + reduceX ; }
void printAlter ( int [ ] arr , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex += 2 ) { Console . Write ( arr [ currIndex ] + " ▁ " ) ; } }
char maxRepeating ( string str ) { int n = str . Length ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
long powerNumbers ( int n ) { HashSet < long > v = new HashSet < long > ( ) ; for ( long i = 2 ; i * i * i <= n ; i ++ ) { long j = i * i ; while ( j * i <= n ) { j *= i ; long s = ( long ) Math . Sqrt ( j ) ; if ( s * s != j ) v . Add ( j ) ; } } return v . Count + ( long ) Math . Sqrt ( n ) ; }
int sumOfTermsInNthRow ( int n ) { int sum = ( int ) ( n * ( 2 * Math . Pow ( n , 2 ) + 1 ) ) ; return sum ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . Ceiling ( Math . Sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; }
String isDivisible ( int n ) { int temp = n ; while ( n > 0 ) { int k = n % 10 ; if ( temp % k == 0 ) { return " YES " ; } n /= 10 ; } return " NO " ; }
int minDiff ( int [ ] A , int K ) { Array . Sort ( A ) ; int n = A . Length ; if ( n <= K ) return 0 ; int mindiff = A [ n - 1 ] - A [ 0 ] ; if ( K == 0 ) return mindiff ; for ( int i = 0 , j = n - 1 - K ; j < n ; ) { mindiff = Math . Min ( mindiff , A [ j ] - A [ i ] ) ; i ++ ; j ++ ; } return mindiff ; }
void addASCII ( char [ ] S , char [ ] N ) { for ( int i = 0 ; i < S . Length ; i ++ ) { int a = ( int ) ( N [ i ] ) - '0' ; int b = ( int ) ( S [ i ] ) + a ; if ( b > 122 ) b -= 26 ; S [ i ] = ( char ) ( b ) ; } Console . Write ( S ) ; }
void maxSum ( int [ , ] arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = Math . Max ( r1 , r2 + arr [ 0 , i ] ) ; r2 = Math . Max ( r2 , temp + arr [ 1 , i ] ) ; } Console . WriteLine ( Math . Max ( r1 , r2 ) ) ; }
void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { Console . Write ( " a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b ) ; } else Console . WriteLine ( - 1 ) ; }
int minCountOfNumbers ( int N ) { int k = N % 10 ; int z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else return - 1 ; }
int MinimumCost ( int [ ] A , int [ ] B , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = Math . Min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = Math . Min ( mod_B , B [ i ] - mod_B ) ; totalCost += Math . Min ( totalCost_A , totalCost_B ) ; } return totalCost ; }
void checkWinner ( int N , int K ) { if ( N % ( K + 1 ) > 0 ) { Console . Write ( " A " ) ; } else { Console . Write ( " B " ) ; } }
void findNumbers ( String s ) { int n = s . Length ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) count ++ ; else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; Console . WriteLine ( result ) ; }
double Area ( double a , double b ) { if ( a < 0 && b < 0 ) return - 1 ; double h = ( double ) Math . Sqrt ( ( ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) / ( Math . Pow ( a , 2 ) * Math . Pow ( b , 2 ) ) ) ) ; double A = ( double ) ( 0.70477 * Math . Pow ( h , 2 ) ) ; return A ; }
int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; }
void search ( string pat , string txt ) { int M = pat . Length ; int N = txt . Length ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; { Console . WriteLine ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j = = 0 ) i = i + 1 ; else i = i + j ; } }
void Main ( String [ ] args ) { String Str = " IDID " ; int N = Str . Length ; int [ ] ptr = DiStirngMatch ( Str ) ; for ( int i = 0 ; i <= N ; i ++ ) Console . Write ( ptr [ i ] + " ▁ " ) ; } }
int maximizeExpression ( int a , int b ) { int result = a ; for ( int bit = MAX - 1 ; bit >= 0 ; bit -- ) { int bitOfD = 1 << bit ; int x = b & bitOfD ; if ( x == bitOfD ) { int y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }
int countTriplets ( int [ ] A ) { int cnt = 0 ; Dictionary < int , int > tuples = new Dictionary < int , int > ( ) ; foreach ( int a in A ) foreach ( int b in A ) { if ( tuples . ContainsKey ( a & b ) ) tuples [ a & b ] = tuples [ a & b ] + 1 ; else tuples . Add ( a & b , 1 ) ; } foreach ( int a in A ) foreach ( KeyValuePair < int , int > t in tuples ) if ( ( t . Key & a ) == 0 ) cnt += t . Value ; return cnt ; }
int countNums ( int n , int x , int y ) { bool [ ] arr = new bool [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . Min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
int FindMaxS ( int X , int Y , int Z , int n , int [ ] A , int [ ] B , int [ ] C ) { if ( X < 0 Y < 0 Z < 0 ) return int . MinValue ; if ( n < 0 ) return 0 ; int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = Math . Max ( ch , Math . Max ( ca , Math . Max ( co , no ) ) ) ; return maximum ; }
bool isCubeSum ( int n ) { for ( int i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }
int next ( int [ ] arr , int target ) { int start = 0 , end = arr . Length - 1 ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }
int countSubStr ( string str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) ans += ( i + 1 ) ; } return ans ; }
void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( div [ i ] + " ▁ " ) ; }
float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { Console . Write ( square + " ▁ " ) ; square = square + odd ; odd = odd + 2 ; } }
void printRLE ( String str ) { int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count ++ ; i ++ ; } Console . Write ( str [ i ] ) ; Console . Write ( count ) ; } }
void FindRank ( int [ ] arr , int length ) { Console . Write ( "1" + " ▁ " ) ; for ( int i = 1 ; i < arr . Length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } Console . Write ( rank + " ▁ " ) ; } }
String removeDuplicates ( String S ) { String ans = " " ; for ( int i = 0 ; i < S . Length ; i ++ ) { if ( ans == " " ans [ ans . Length - 1 ] != S [ i ] ) ans += S [ i ] ; else if ( ans [ ans . Length - 1 ] == S [ i ] ) ans = ans . Substring ( 0 , ans . Length - 1 ) ; } return ans ; }
int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
void foot ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; NumberFormatInfo form = new NumberFormatInfo ( ) ; form . NumberDecimalSeparator = " . " ; Console . Write ( " ▁ x2 ▁ = ▁ " + x2 . ToString ( form ) ) ; Console . Write ( " ▁ y2 ▁ = ▁ " + y2 . ToString ( form ) ) ; Console . Write ( " ▁ z2 ▁ = ▁ " + z2 . ToString ( form ) ) ; }
void isPerfectSquare ( int x ) { int sr = ( int ) Math . Sqrt ( x ) ; if ( sr * sr == x ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
bool areChractersUnique ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
void lengtang ( double r1 , double r2 , double d ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ direct " + " ▁ common ▁ tangent ▁ is ▁ " + ( Math . Sqrt ( Math . Pow ( d , 2 ) - Math . Pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }
int maxGCD ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
void countNo ( int A , int N , int L , int R ) { int ans = L - 1 + N + ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } Console . WriteLine ( ans ) ; }
float median ( int a , int b , int c ) { float n = ( float ) ( Math . Sqrt ( 2 * b * b + 2 * c * c - a * a ) / 2 ) ; return n ; }
bool isPossible ( int A , int B ) { return ( A - B > 1 ) ; }
void pendulumArrangement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int [ ] op = new int [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; Console . Write ( " Pendulum ▁ arrangement : " ) ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( op [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; }
int andSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ , , ] L = new int [ m + 1 , n + 1 , o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i , j , k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i , j , k ] = L [ i - 1 , j - 1 , k - 1 ] + 1 ; else L [ i , j , k ] = Math . Max ( Math . Max ( L [ i - 1 , j , k ] , L [ i , j - 1 , k ] ) , L [ i , j , k - 1 ] ) ; } } } return L [ m , n , o ] ; }
void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; Console . WriteLine ( ratio ) ; }
int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
void minimumTriangleArea ( int a , int b ) { int area = a * b ; Console . WriteLine ( area ) ; }
int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
int cntRect ( int [ , ] points , int N , int [ , ] rectangle ) { HashSet < int > cntHor = new HashSet < int > ( ) ; HashSet < int > cntVer = new HashSet < int > ( ) ; cntHor . Add ( 0 ) ; cntVer . Add ( 0 ) ; cntHor . Add ( rectangle [ 3 , 0 ] ) ; cntVer . Add ( rectangle [ 3 , 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . Add ( points [ i , 0 ] ) ; cntVer . Add ( points [ i , 1 ] ) ; } return ( cntHor . Count - 1 ) * ( cntVer . Count - 1 ) ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int sum = 0 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += i ; if ( sum <= K ) res ++ ; else break ; } return res ; }
void preprocess ( int [ ] list ) { ways [ 0 , 8 , 8 ] = 1 ; for ( int N = 1 ; N <= 14 ; N ++ ) { for ( int i = 1 ; i < depth ; i ++ ) { for ( int j = 1 ; j < depth ; j ++ ) { ways [ N , i , j ] = ways [ N - 1 , i , j + 1 ] + ways [ N - 1 , i , j - 1 ] + ways [ N - 1 , i + 1 , j ] + ways [ N - 1 , i - 1 , j ] + ways [ N - 1 , i + 1 , j - 1 ] + ways [ N - 1 , i - 1 , j + 1 ] ; } } list [ N ] = ways [ N , 8 , 8 ] ; } }
bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . Sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
string sumBaseB ( string a , string b , int base_var ) { int len_a , len_b ; len_a = a . Length ; len_b = b . Length ; string sum , s ; s = " " ; sum = " " ; int diff ; diff = Math . Abs ( len_a - len_b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len_a < len_b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = Math . Max ( len_a , len_b ) - 1 ; i > - 1 ; i -- ) { curr = carry + ( a [ i ] - '0' ) + ( b [ i ] - '0' ) ; carry = curr / base_var ; curr = curr % base_var ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; }
String GeberateDefangIP ( string str ) { string defangIP = " " ; for ( int i = 0 ; i < str . Length ; i ++ ) { char c = str [ i ] ; if ( c == ' . ' ) { defangIP += " [ . ] " ; } else { defangIP += c ; } } return defangIP ; }
int maxWeight ( int [ ] arr , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i , w1_r , w2_r ] != - 1 ) return dp [ i , w1_r , w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i , w1_r , w2_r ] = Math . Max ( fill_none , Math . Max ( fill_w1 , fill_w2 ) ) ; return dp [ i , w1_r , w2_r ] ; }
int maximumSubarrays ( int [ ] arr , int N , int target ) { int ans = 0 ; int availIdx = - 1 ; int cur_sum = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; mp . Add ( 0 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { cur_sum += arr [ i ] ; if ( mp . ContainsKey ( cur_sum - target ) && mp [ cur_sum - target ] >= availIdx ) { ans ++ ; availIdx = i ; } if ( mp . ContainsKey ( cur_sum ) ) mp [ cur_sum ] = i ; else mp . Add ( cur_sum , i ) ; } return ans ; }
bool check ( int [ ] arr , int n ) { int count = 0 ; int index = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) { count ++ ; index = i ; } } if ( count > 1 ) return false ; if ( count == 0 ) return true ; if ( index == n - 1 index == 1 ) return true ; if ( arr [ index - 1 ] < arr [ index + 1 ] ) return true ; if ( arr [ index - 2 ] < arr [ index ] ) return true ; return false ; }
float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
void maxSumAfterKReverse ( int [ ] arr , int K , int N ) { int sum = Int32 . MinValue ; if ( K % 2 != 0 ) Array . Reverse ( arr ) ; int currsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = Math . Max ( sum , currsum ) ; } Console . Write ( sum ) ; }
void generateLetters ( string S , int P , Dictionary < char , char > M ) { if ( P == S . Length ) { Console . WriteLine ( S ) ; return ; } generateLetters ( S , P + 1 , M ) ; S = S . Substring ( 0 , P ) + M [ S [ P ] ] + S . Substring ( P + 1 ) ; generateLetters ( S , P + 1 , M ) ; return ; }
int previousFibonacci ( int n ) { double a = n / ( ( 1 + Math . Sqrt ( 5 ) ) / 2.0 ) ; return ( int ) Math . Round ( a ) ; }
void parallel ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } }
int solve ( int N , int M , int [ ] cp , int [ ] sp ) { int [ ] profit = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; Array . Sort ( profit ) ; Array . Reverse ( profit ) ; int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
int minLength ( String S ) { Stack < char > st = new Stack < char > ( ) ; foreach ( char ch in S . ToCharArray ( ) ) { if ( st . Count == 0 ) st . Push ( ch ) ; else { char top = st . Peek ( ) ; if ( Math . Abs ( ch - top ) == 1 ) st . Pop ( ) ; else { st . Push ( ch ) ; } } } return st . Count ; }
int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . Abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . Abs ( arr [ n - 1 ] ) ; return result ; }
int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . Pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
int DecreasingArray ( int [ ] a , int n ) { int sum = 0 , dif = 0 ; List < int > pq = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( pq . Count > 0 && pq [ 0 ] < a [ i ] ) { dif = a [ i ] - pq [ 0 ] ; sum += dif ; pq . RemoveAt ( 0 ) ; } pq . Add ( a [ i ] ) ; pq . Sort ( ) ; } return sum ; }
int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; }
void minOpsToTurnArrToZero ( int [ ] arr , int N ) { HashSet < int > st = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . Contains ( arr [ i ] ) arr [ i ] == 0 ) { continue ; } else { st . Add ( arr [ i ] ) ; } } Console . WriteLine ( st . Count ) ; }
int countDistinctSums ( int N , int L , int R ) { int minSum = L * N ; int maxSum = R * N ; return maxSum - minSum + 1 ; }
void solve ( int A , int B ) { double p = B / 2.0 ; double M = Math . Ceiling ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; double Q = Math . Ceiling ( A * A + 4 * p * p ) ; Console . Write ( M + " ▁ " + N + " ▁ " + O + " ▁ " + Q ) ; }
int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = Math . Max ( maximum , ( i & j ) ) ; return maximum ; }
void findAandB ( double N ) { if ( N == 1 ) { Console . Write ( " No " ) ; return ; } double a = N * N / ( N - 1 ) ; double b = a / N ; Console . Write ( " a ▁ = ▁ " + a + " STRNEWLINE " ) ; Console . Write ( " b ▁ = ▁ " + b + " STRNEWLINE " ) ; }
void highestPowerOfTwo ( int num ) { String s = num . ToString ( ) ; for ( int i = 0 ; i < ( int ) s . Length ; i ++ ) { if ( s [ i ] == '0' ) { Console . Write ( "0" ) ; continue ; } int lg = ( int ) ( Math . Log ( s [ i ] - '0' ) / Math . Log ( 2 ) ) ; int p = ( int ) Math . Pow ( 2 , lg ) ; Console . Write ( ( char ) ( p + 48 ) ) ; } }
int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }
int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
String checkEvenPower ( int n ) { int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int value = ( int ) Math . Pow ( 2 , mid ) ; if ( value == n ) { if ( mid % 2 == 1 ) return " No " ; else return " Yes " ; } else if ( value < n ) low = mid + 1 ; else high = mid - 1 ; } return " No " ; }
long product ( int [ ] arr ) { double occurrence = Math . Pow ( 2 , arr . Length - 1 ) ; double product = 1 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { product *= Math . Pow ( arr [ i ] , occurrence ) ; } return ( long ) product ; }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
void genSequence ( int n , int val ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int x = i ^ ( i >> 1 ) ^ val ; Console . Write ( x + " ▁ " ) ; } }
void minMoves ( int [ ] arr , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; Console . Write ( moves ) ; }
int count_triangles ( int a , int b , int c , int d ) { int ans = 0 ; for ( int x = a ; x <= b ; ++ x ) { int num_greater_than_d = Math . Max ( d , c + x ) - Math . Max ( d , b + x - 1 ) ; ans += num_greater_than_d * ( d - c + 1 ) ; int r = Math . Min ( Math . Max ( c , c + x ) , d ) - c ; int l = Math . Min ( Math . Max ( c , b + x - 1 ) , d ) - c ; int x1 = ( r * ( r + 1 ) ) / 2 ; int x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; }
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . Max ( Math . Max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
void printCollatz ( int n ) { while ( n != 1 ) { Console . Write ( n + " ▁ " ) ; if ( ( n & 1 ) == 1 ) n = 3 * n + 1 ; else n = n / 2 ; } Console . Write ( n ) ; }
int MinCost ( int [ ] days , int [ ] cost , int N ) { int size = days [ N - 1 ] + 1 ; int [ ] dp = new int [ size ] ; dp [ size - 1 ] = Math . Min ( cost [ 0 ] , Math . Min ( cost [ 1 ] , cost [ 2 ] ) ) ; int ptr = N - 2 ; for ( int i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { int val1 = dp [ i + 1 ] + cost [ 0 ] ; int val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; int val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = Math . Min ( val1 , Math . Min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }
int maximumDifferenceSum ( int [ ] arr , int N ) { int [ , ] dp = new int [ N , 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i , 0 ] = dp [ i , 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 , 0 ] = Math . Max ( dp [ i , 0 ] , dp [ i , 1 ] + Math . Abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 , 1 ] = Math . Max ( dp [ i , 0 ] + Math . Abs ( arr [ i + 1 ] - 1 ) , dp [ i , 1 ] + Math . Abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . Max ( dp [ N - 1 , 0 ] , dp [ N - 1 , 1 ] ) ; }
bool isTrimorphic ( int N ) { int cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N /= 10 ; cube /= 10 ; } return true ; }
void checkValidPolygon ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
void find ( int N ) { int T , F , O ; F = ( int ) ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = ( int ) Math . Floor ( ( double ) ( N - 5 * F - O ) / 2 ) ; Console . WriteLine ( " Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ " + F ) ; Console . WriteLine ( " Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ " + T ) ; Console . WriteLine ( " Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ " + O ) ; }
bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
int longOddEvenIncSeq ( int [ ] arr , int n ) { int [ ] lioes = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
void countString ( string S ) { int count = 0 ; foreach ( char it in S ) { if ( it == '0' && count > 0 ) { count -- ; } else { count ++ ; } } Console . Write ( ( 1 << count ) - 1 ) ; }
double Area_of_Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * Math . Sqrt ( x ) ; return area ; }
int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) == 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
long numbers ( int n ) { return ( long ) ( Math . Pow ( 2 , n + 1 ) ) - 2 ; }
int maxRightmostElement ( int N , int k , int p , int [ ] arr ) { int ans = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int d = Math . Min ( arr [ i ] / p , k / ( N - 1 - i ) ) ; k -= d * ( N - 1 - i ) ; ans += d * p ; } return ans ; }
int findFlips ( String str , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) res ++ ; last = str [ i ] ; } return res / 2 ; }
int items ( int n , int [ ] a ) { Array . Sort ( a ) ; int z = a [ n - 1 ] ; int x = 1 ; int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }
int submatrixXor ( int [ , ] arr ) { int n = 3 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i , j ] ) ; } } return ans ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) + n - 2 ; }
int findLen ( int [ ] arr , int n , int m ) { List < int > filter = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . Add ( arr [ i ] ) ; if ( filter . Count == 0 ) return 0 ; int c_or = filter [ 0 ] ; for ( int i = 1 ; i < filter . Count ; i ++ ) c_or |= filter [ i ] ; if ( c_or == m ) return filter . Count ; return 0 ; }
double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( - 1 * b ) / a ; double rootProduct = ( double ) e / a ; return Math . Abs ( rootSum - rootProduct ) ; }
float geometricMean ( int [ ] arr , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = ( float ) Math . Pow ( product , ( float ) 1 / n ) ; return gm ; }
int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
double countNumbers ( int N ) { return ( Math . Pow ( 10 , N ) - 1 ) - ( Math . Pow ( 10 , N ) - Math . Pow ( 8 , N ) ) / 2 ; }
int eggDrop ( int n , int k ) { int [ , ] dp = new int [ k + 1 , n + 1 ] ; int x = 0 ; while ( dp [ x , n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x , i ] = dp [ x - 1 , i - 1 ] + dp [ x - 1 , i ] + 1 ; } return x ; }
void minimumCost ( string a , string b ) { int [ ] fre1 = new int [ 256 ] ; int [ ] fre2 = new int [ 256 ] ; foreach ( char c in a . ToCharArray ( ) ) fre1 [ ( int ) ( c ) ] ++ ; foreach ( char c in b . ToCharArray ( ) ) fre2 [ ( int ) ( c ) ] ++ ; int mincost = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { mincost += Math . Abs ( fre1 [ i ] - fre2 [ i ] ) ; } Console . Write ( mincost ) ; }
int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . Pow ( 10 , n ) - 1 ) - 0.55 * n ) ; }
void Vertices ( int x , int y ) { int val = Math . Abs ( x ) + Math . Abs ( y ) ; Console . Write ( val * ( x < 0 ? - 1 : 1 ) + " ▁ 0 ▁ " ) ; Console . Write ( "0 ▁ " + val * ( y < 0 ? - 1 : 1 ) ) ; }
int minServerLoads ( int n , int [ ] servers ) { int totalLoad = 0 ; for ( int i = 0 ; i < servers . Length ; i ++ ) totalLoad += servers [ i ] ; int requiredLoad = totalLoad / 2 ; int [ , ] dp = new int [ n + 1 , requiredLoad + 1 ] ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i , j ] = dp [ i - 1 , j ] ; else dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , servers [ i - 1 ] + dp [ i - 1 , j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n , requiredLoad ] ; }
void countSubString ( String s ) { int answer = 0 ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; m . Add ( 0 , 1 ) ; int x = 0 ; for ( int j = 0 ; j < s . Length ; j ++ ) { x ^= 1 << ( s [ j ] - ' a ' ) ; answer += m . ContainsKey ( x ) ? m [ x ] : 0 ; for ( int i = 0 ; i < 26 ; ++ i ) { answer += m . ContainsKey ( x ^ ( 1 << i ) ) ? m [ x ^ ( 1 << i ) ] : 0 ; } if ( m . ContainsKey ( x ) ) m [ x ] = m [ x ] + 1 ; else m . Add ( x , 1 ) ; } Console . Write ( answer ) ; }
String smallest ( String s ) { int l = s . Length ; String ans = " " ; for ( int i = 0 ; i < l - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) { for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { ans += s [ j ] ; } } return ans ; } } ans = s . Substring ( 0 , l - 1 ) ; return ans ; }
void digit_product_Sum ( int N ) { int [ ] a = new int [ N + 1 ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; }
bool canBeBalanced ( string s , int n ) { if ( n % 2 == 1 ) return false ; string k = " ( " ; k += s + " ) " ; List < string > d = new List < string > ( ) ; for ( int i = 0 ; i < k . Length ; i ++ ) { if ( k [ i ] == ' ( ' ) d . Add ( " ( " ) ; else { if ( d . Count != 0 ) d . RemoveAt ( d . Count - 1 ) ; else return false ; } } if ( d . Count == 0 ) return true ; return false ; }
void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) Console . WriteLine ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ identical " ) ; else Console . WriteLine ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ not ▁ identical " ) ; }
String search ( int [ ] arr , int n , int x ) { if ( arr [ n - 1 ] == x ) return " Found " ; int backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( int i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " Found " ; return " Not ▁ Found " ; } } }
int minIndex ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }
float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int minSum ( int [ ] a , int n ) { Array . Sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n != 0 ; n = n >> 1 ) inv ^= n ; return inv ; }
int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = Math . Abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += ( int ) Math . Ceiling ( diff / K ) - 1 ; } return inser ; }
int minJumps ( int [ ] arr , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return int . MaxValue ; int min = int . MaxValue ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != int . MaxValue && jumps + 1 < min ) min = jumps + 1 ; } return min ; }
void printCoins ( int [ ] arr , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) Console . Write ( arr [ i ] + " ▁ " ) ; }
int MaximumSum ( int [ ] a , int [ ] b , int n ) { int [ , ] dp = new int [ n , 2 ] ; dp [ 0 , 0 ] = a [ 0 ] ; dp [ 0 , 1 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i , 0 ] = Math . Max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) + a [ i ] ; dp [ i , 1 ] = Math . Max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , Math . Max ( dp [ i - 2 , 0 ] , dp [ i - 2 , 1 ] ) + b [ i ] ) ; } else { dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , b [ i ] ) ; } } return Math . Max ( dp [ n - 1 , 0 ] , dp [ n - 1 , 1 ] ) ; }
int nthTerm ( int n ) { int d = 2 ; int a1 = 0 ; int An = a1 + ( n - 1 ) * d ; return ( int ) Math . Pow ( An , 3 ) ; }
void middlesum ( int [ , ] mat , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 , i ] ; Console . WriteLine ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i , n / 2 ] ; Console . WriteLine ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " + col_sum ) ; }
long count ( int N , int K , int R ) { long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
int countSquareMatrices ( int [ , ] a , int N , int M ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i , j ] == 0 ) continue ; a [ i , j ] = Math . Min ( Math . Min ( a [ i - 1 , j ] , a [ i , j - 1 ] ) , a [ i - 1 , j - 1 ] ) + 1 ; } } for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) count += a [ i , j ] ; return count ; }
float Time ( float [ ] arr , int n , float Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; }
bool isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; }
void amendSentence ( string sstr ) { char [ ] str = sstr . ToCharArray ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { str [ i ] = ( char ) ( str [ i ] + 32 ) ; if ( i != 0 ) Console . Write ( " ▁ " ) ; Console . Write ( str [ i ] ) ; } else Console . Write ( str [ i ] ) ; } }
int findLongestRepeatingSubSeq ( string str ) { int n = str . Length ; int [ , ] dp = new int [ n + 1 , n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = Math . Max ( dp [ i , j - 1 ] , dp [ i - 1 , j ] ) ; } } return dp [ n , n ] ; }
void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) Console . Write ( i + " ▁ " ) ; Console . WriteLine ( "0" ) ; }
int maximumSum ( int [ ] arr , int N ) { int Sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }
int longestSubsequence ( String s ) { int n = s . Length ; int answer = 0 ; char prev = ' - ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( prev != s [ i ] ) { prev = s [ i ] ; answer ++ ; } } return answer ; }
String printSequence ( string [ ] arr , string input ) { string output = " " ; int n = input . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( input [ i ] == ' ▁ ' ) output = output + "0" ; else { int position = input [ i ] - ' A ' ; output = output + arr [ position ] ; } } return output ; }
int deleteElement ( int [ ] A , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
void BalancedNumber ( string s ) { int Leftsum = 0 ; int Rightsum = 0 ; for ( int i = 0 ; i < s . Length / 2 ; i ++ ) { Leftsum += ( int ) ( Char . GetNumericValue ( s [ i ] ) - Char . GetNumericValue ( '0' ) ) ; Rightsum += ( int ) ( Char . GetNumericValue ( s [ s . Length - 1 - i ] ) - Char . GetNumericValue ( '0' ) ) ; } if ( Leftsum == Rightsum ) Console . WriteLine ( " Balanced " ) ; else Console . WriteLine ( " Not ▁ Balanced " ) ; }
long NthTerm ( long n ) { long x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
int log_a_to_base_b ( int a , int b ) { return ( int ) ( Math . Log ( a ) / Math . Log ( b ) ) ; }
int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; }
double Circumradius ( int a , int b , int c , int d ) { double s = ( a + b + c + d ) / 2.0 ; double radius = Math . Sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }
void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { Console . WriteLine ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; } else { Console . WriteLine ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; } }
int maximumSumSubarray ( int [ ] arr , int n ) { int min_prefix_sum = 0 ; int res = int . MinValue ; int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . Max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . Min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
bool isNumber ( string s ) { for ( int i = 0 ; i < s . Length ; i ++ ) if ( char . IsDigit ( s [ i ] ) == false ) return false ; return true ; }
void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) Console . Write ( hexaDeciNum [ j ] ) ; }
void printLeaders ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
void removeLeadingZeros ( string str ) { string regex = " ^ 0 + ( ? ! $ ) " ; str = Regex . Replace ( str , regex , " " ) ; Console . WriteLine ( str ) ; }
long fourthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
int Occurrence ( String s , int position ) { int count = 0 ; for ( int i = 0 ; i < position - 1 ; i ++ ) if ( s [ i ] == s [ position - 1 ] ) count ++ ; return count ; }
int longestSubseqWithDiffOne ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . Max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
void countOfSubarray ( int [ ] arr , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int answer = 0 ; int sum = 0 ; mp [ 1 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( mp . ContainsKey ( sum - i ) ) answer += mp [ sum - i ] ; if ( mp . ContainsKey ( sum - 1 ) ) mp [ sum - 1 ] ++ ; else mp [ sum - 1 ] = 1 ; } Console . Write ( answer - 2 ) ; }
void subArray ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) Console . Write ( arr [ k ] + " ▁ " ) ; Console . WriteLine ( " " ) ; } } }
int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return Math . Min ( c1 , c2 ) ; }
void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
void printGolomb ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 1 ; Console . Write ( dp [ 1 ] + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; Console . Write ( dp [ i ] + " ▁ " ) ; } }
int smallSumSubset ( List < int > data , int target , int maxVal ) { int sum = 0 ; foreach ( int i in data ) sum += i ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . Count ; else if ( data [ 0 ] >= target ) return 1 ; else if ( data [ 0 ] < target ) { List < int > temp = new List < int > ( ) ; for ( int i = 1 ; i < data . Count ; i ++ ) temp . Add ( data [ i ] ) ; return Math . Min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data [ 0 ] , maxVal ) ) ; } return 0 ; }
int findKHCF ( int x , int y , int k ) { int small = Math . Min ( x , y ) ; int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; }
int greyConverter ( int n ) { return n ^ ( n >> 1 ) ; }
bool isheptagonal ( int N ) { double n = ( 3 + Math . Sqrt ( 40 * N + 9 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }
void computePair ( double K ) { if ( K == 1 ) { Console . Write ( " No " ) ; return ; } else { Console . Write ( K * K / ( K - 1 ) + " ▁ " ) ; Console . Write ( K / ( K - 1 ) + " STRNEWLINE " ) ; } }
void minimumOperations ( int [ ] arr , int N ) { int mx = 0 , pos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } Console . Write ( ( mx - 1 ) * N + pos + 1 ) ; }
int maxSumPairWithDifferenceLessThanK ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int [ ] dp = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . Max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . Max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) Console . WriteLine ( " Coplanar " ) ; else Console . WriteLine ( " Not ▁ Coplanar " ) ; }
void countSmaller ( String str ) { int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] < str [ i ] ) { cnt += 1 ; } } Console . Write ( cnt + " ▁ " ) ; } }
void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? Math . Min ( l1 , l2 ) : - 1 ; int y = ( r1 != r2 ) ? Math . Max ( r1 , r2 ) : - 1 ; Console . WriteLine ( x + " ▁ " + y ) ; }
int minCost ( string s , int n ) { int minValue = 100000000 ; for ( int i = 0 ; i <= 25 ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { cnt += Math . Min ( Math . Abs ( i - ( s [ j ] - ' a ' ) ) , 26 - Math . Abs ( i - ( s [ j ] - ' a ' ) ) ) ; } minValue = Math . Min ( minValue , cnt ) ; } return minValue ; }
void findElements ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
int proizvolov ( int [ ] a , int [ ] b , int n ) { return n * n ; }
void findString ( int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( ( char ) ( ' A ' + i % K ) ) ; } }
int countOfSubarray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] -- ; int [ ] pref = new int [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + arr [ i ] ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int answer = 0 ; mp . Add ( 0 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( pref [ i ] ) ) { answer += mp [ pref [ i ] ] ; mp [ pref [ i ] ] = mp [ pref [ i ] ] + 1 ; } else { mp . Add ( pref [ i ] , 1 ) ; } } return answer ; }
double Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; Console . WriteLine ( pixels ) ; return 0 ; }
int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx , diff ] != - 1 ) return dp [ idx , diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx , diff ] = ans % MOD ; }
int findSum ( int L , int R ) { ArrayList arr = new ArrayList ( ) ; int i = 0 ; int x = 2 ; while ( i <= R ) { arr . Add ( i + x ) ; if ( i + 1 <= R ) arr . Add ( i + 1 + x ) ; x *= - 1 ; i += 2 ; } int sum = 0 ; for ( i = L ; i <= R ; ++ i ) sum += ( int ) arr [ i ] ; return sum ; }
float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float l = ( float ) ( Math . Sqrt ( Math . Pow ( h , 2 ) + 4 * Math . Pow ( r , 2 ) ) ) ; return l ; }
double getSlope ( double m ) { return m ; }
int sumOfMinAbsDifferences ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int sum = 0 ; sum += Math . Abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . Abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += Math . Min ( Math . Abs ( arr [ i ] - arr [ i - 1 ] ) , Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
bool checkArray ( int n , int k , int [ ] arr ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }
float getArea ( int a ) { float area = ( float ) ( Math . PI * a * a ) / 4 ; return area ; }
int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; bool [ ] arr = new bool [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
void constructArray ( int [ ] A , int N , int K ) { int [ ] B = new int [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( B [ i ] + " ▁ " ) ; } }
long nextFibonacci ( int n ) { double a = n * ( 1 + Math . Sqrt ( 5 ) ) / 2.0 ; return ( long ) Math . Round ( a ) ; }
void center ( int x1 , int x2 , int y1 , int y2 ) { Console . WriteLine ( ( float ) ( x1 + x2 ) / 2 + " , ▁ " + ( float ) ( y1 + y2 ) / 2 ) ; }
void find ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int b = ( int ) Math . Ceiling ( n / k * 1.0 ) ; int min_sum = 0 , max_sum = 0 ; for ( int i = 0 ; i < b ; i ++ ) min_sum += arr [ i ] ; for ( int i = 2 ; i < arr . Length ; i ++ ) max_sum += arr [ i ] ; Console . WriteLine ( " minimum ▁ " + min_sum ) ; Console . WriteLine ( " maximum ▁ " + max_sum ) ; }
int productAtKthLevel ( String tree , int k , int level ) { if ( tree [ i ++ ] == ' ( ' ) { if ( tree [ i ] == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree [ i ] - '0' ; ++ i ; int leftproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; int rightproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } return int . MinValue ; }
void primesInRange ( int n ) { int fact = 1 ; for ( int k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) System . Console . WriteLine ( k ) ; } }
bool sameLength ( int A , int B ) { while ( ( A > 0 ) && ( B > 0 ) ) { A = A / 10 ; B = B / 10 ; } if ( ( A == 0 ) && ( B == 0 ) ) return true ; return false ; }
bool getParity ( int n ) { bool parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
int day_of_the_week ( int y , int m , int d ) { int [ ] t = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
bool Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
int getInteger ( int L , int R ) { int number = 0 ; for ( int i = L ; i <= R ; i ++ ) number += ( int ) Math . Pow ( 2 , i ) ; return number ; }
float find ( int N , int a , int b ) { float probability = 0.0f ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 , i ] = ( float ) ( 1.0 / 6 ) ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i , j ] = dp [ i , j ] + dp [ i - 1 , j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N , sum ] ; return probability ; }
void calcSum ( int [ ] arr , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; Console . Write ( sum + " ▁ " ) ; for ( int i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; Console . Write ( sum + " ▁ " ) ; } }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
void printTriplets ( int [ ] arr , int n , int sum ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( int x = j + 1 ; x <= k ; x ++ ) Console . WriteLine ( arr [ i ] + " , ▁ " + arr [ j ] + " , ▁ " + arr [ x ] ) ; j ++ ; } } } }
void generateStr ( String a , String b , String s , int count , int len ) { if ( count == len ) { Console . WriteLine ( s ) ; return ; } generateStr ( a . Substring ( 1 ) , b . Substring ( 1 ) , s + a [ 0 ] , count + 1 , len ) ; generateStr ( a . Substring ( 1 ) , b . Substring ( 1 ) , s + b [ 0 ] , count + 1 , len ) ; }
int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
void scoreOfParentheses ( String s ) { Stack < int > stack = new Stack < int > ( ) ; stack . Push ( 0 ) ; foreach ( char c in s . ToCharArray ( ) ) { if ( c == ' ( ' ) stack . Push ( 0 ) ; else { int tmp = stack . Pop ( ) ; int val = 0 ; if ( tmp > 0 ) val = tmp * 2 ; else val = 1 ; stack . Push ( stack . Pop ( ) + val ) ; } } Console . WriteLine ( stack . Peek ( ) ) ; }
void findNthTerm ( int n ) { Console . Write ( Math . Pow ( 2 , n ) - 2 * n ) ; }
bool printPairs ( int [ ] arr , int n , int k ) { bool isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { Console . Write ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " ▁ " ) ; isPairFound = true ; } } } return isPairFound ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
void printBinaryString ( int [ , ] arr , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) { Console . Write ( 0 ) ; } else { Console . Write ( 1 ) ; } } }
double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }
int find ( List < int > arr , int N , int key ) { int l = 0 ; int h = N - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] >= arr [ mid ] ) { if ( arr [ l ] >= key && key >= arr [ mid ] ) h = mid - 1 ; else l = mid + 1 ; } else { if ( arr [ mid ] >= key && key >= arr [ h ] ) l = mid + 1 ; else h = mid - 1 ; } } return - 1 ; }
long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; long same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
int No_of_squares ( int N , int K ) { int no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }
int arrayDivisionByTwo ( int [ ] arr , int n ) { int cnt = 0 ; int ans = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; cnt ++ ; } ans = Math . Min ( ans , cnt ) ; } return ans ; }
bool check_order ( int [ ] arr ) { int cnt = 0 ; for ( int i = 0 ; i < arr . Length - 1 ; i ++ ) { if ( Math . Abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( Math . Abs ( arr [ 0 ] - arr [ arr . Length - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; }
double findIndex ( int n ) { double x = Math . Sqrt ( 2 * Math . Pow ( 10 , ( n - 1 ) ) ) ; return Math . Round ( x ) ; }
int countSum ( int [ ] a , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }
int min_operations ( int [ ] A , int n ) { if ( n == 0 ) return 0 ; int ans = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] > A [ i - 1 ] ) { ans += A [ i ] - A [ i - 1 ] ; } } return ans ; }
int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( float ) ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( float ) ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }
void findPairs ( int n ) { int cubeRoot = ( int ) Math . Pow ( n , 1.0 / 3.0 ) ; int [ ] cube = new int [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { Console . WriteLine ( " ( " + l + " , ▁ " + r + " ) " ) ; l ++ ; r -- ; } } }
int countPairs ( String s ) { HashSet < char > st = new HashSet < char > ( ) ; st . Add ( ' a ' ) ; st . Add ( ' e ' ) ; st . Add ( ' i ' ) ; st . Add ( ' o ' ) ; st . Add ( ' u ' ) ; int count = 0 ; int n = s . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( st . Contains ( s [ i ] ) && ! st . Contains ( s [ i + 1 ] ) ) count ++ ; } return count ; }
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
int smallestSubWithSum ( int [ ] arr , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
double calTime ( double [ ] arr , int n ) { double work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return Math . Round ( 1 / work , 5 ) ; }
void finalPosition ( String move ) { int l = move . Length ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( move [ i ] == ' U ' ) countUp ++ ; else if ( move [ i ] == ' D ' ) countDown ++ ; else if ( move [ i ] == ' L ' ) countLeft ++ ; else if ( move [ i ] == ' R ' ) countRight ++ ; } Console . WriteLine ( " Final ▁ Position : ▁ ( " + ( countRight - countLeft ) + " , ▁ " + ( countUp - countDown ) + " ) " ) ; }
double subfactorial ( int N ) { double res = 0 , fact = 1 ; int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - ( 1 / fact ) ; else res = res + ( 1 / fact ) ; count ++ ; } return fact * ( 1 + res ) ; }
void waysToPaint ( int n ) { long same = 6 ; long diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } Console . WriteLine ( same + diff ) ; }
int findSum ( int n ) { int [ , ] arr = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i , j ] = Math . Abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i , j ] ; return sum ; }
int summation ( int n ) { return n << ( n - 1 ) ; }
int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
void printDivisors ( int n ) { int [ ] v = new int [ n ] ; int t = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) Console . Write ( i + " ▁ " ) ; else { Console . Write ( i + " ▁ " ) ; v [ t ++ ] = n / i ; } } } for ( int i = t - 1 ; i >= 0 ; i -- ) Console . Write ( v [ i ] + " ▁ " ) ; }
int nswp ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }
int findMax ( int n , int [ ] a , int [ ] b , int [ ] k , int m ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { int lowerbound = a [ i ] ; int upperbound = b [ i ] ; for ( int j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } int res = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Max ( res , arr [ i ] ) ; return res ; }
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; Console . Write ( f1 + " ▁ " ) ; for ( i = 1 ; i < n ; i ++ ) { Console . Write ( f2 + " ▁ " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) Console . WriteLine ( " Angle ▁ not ▁ possible " ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; Console . WriteLine ( sector ) ; } }
long minimumMoves ( int [ ] a , int n ) { long operations = 0 ; Array . Sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) operations += ( long ) Math . Abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
int countRotations ( int [ ] arr , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { Console . WriteLine ( k * ( 6 * i + 1 ) + " ▁ " + k * ( 6 * i + 2 ) + " ▁ " + k * ( 6 * i + 3 ) + " ▁ " + k * ( 6 * i + 5 ) ) ; } }
long removeRecur ( long n ) { long prev_digit = n % 10 ; long pow = 10 ; long res = prev_digit ; while ( n > 0 ) { long curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; }
void checkperfectsquare ( int n ) { if ( Math . Ceiling ( ( double ) Math . Sqrt ( n ) ) == Math . Floor ( ( double ) Math . Sqrt ( n ) ) ) { Console . Write ( " perfect ▁ square " ) ; } else { Console . Write ( " not ▁ a ▁ perfect ▁ square " ) ; } }
void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) Console . Write ( binaryNum [ j ] ) ; }
int min_moves ( int n ) { int ans = int . MaxValue ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = Math . Min ( ans , i + n / i - 2 ) ; } } return ans ; }
string checkSameDigits ( int N ) { int digit = N % 10 ; while ( N != 0 ) { int current_digit = N % 10 ; N = N / 10 ; if ( current_digit != digit ) { return " No " ; } } return " Yes " ; }
int findCntTriplet ( int N ) { int cntTriplet = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += N / i ; } else { cntTriplet += ( N / i ) - 1 ; } } return cntTriplet ; }
int countTriplets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; }
int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; }
int MaxProfit ( int [ ] arr , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = Math . Max ( buy , sell - arr [ i ] ) ; sell = Math . Max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . Max ( sell , buy ) ; }
int countStrings ( int n , int k ) { int [ , , ] dp = new int [ n + 1 , k + 1 , 2 ] ; dp [ 1 , 0 , 0 ] = 1 ; dp [ 1 , 0 , 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i , j , 0 ] = dp [ i - 1 , j , 0 ] + dp [ i - 1 , j , 1 ] ; dp [ i , j , 1 ] = dp [ i - 1 , j , 0 ] ; if ( j - 1 >= 0 ) { dp [ i , j , 1 ] += dp [ i - 1 , j - 1 , 1 ] ; } } } return dp [ n , k , 0 ] + dp [ n , k , 1 ] ; }
int maxAND ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = res > ( arr [ i ] & arr [ j ] ) ? res : ( arr [ i ] & arr [ j ] ) ; return res ; }
void Kmultiples ( int n , int k ) { int a = n ; for ( int i = 1 ; i <= k ; i ++ ) { Console . Write ( n + " ▁ * ▁ " + i + " ▁ = ▁ " + a + " STRNEWLINE " ) ; int j = 0 ; while ( n >= ( 1 << j ) ) { a += n & ( 1 << j ) ; j ++ ; } } }
void equal_xor_sum ( int [ ] arr , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; Console . WriteLine ( num ) ; }
bool isValid ( string s ) { if ( ( s . IndexOf ( " geek " ) != - 1 ) && ( s . IndexOf ( " keeg " , s . IndexOf ( " geek " ) + 4 ) != - 1 ) ) return true ; return false ; }
bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }
bool isSortedArray ( int [ ] arr , int n ) { int l = 0 , r = ( n - 1 ) ; while ( ( l + 1 ) < r ) { if ( arr [ l ] >= Math . Max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= Math . Max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l ++ ; r -- ; } else { return false ; } } return true ; }
bool arraySortedOrNot ( int [ ] arr , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
String noAdjacentDup ( String s1 ) { int n = s1 . Length ; char [ ] s = s1 . ToCharArray ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( new String ( s ) ) ; }
bool isDivisible ( int n ) { int d ; while ( n / 100 > 0 ) { d = n % 10 ; n /= 10 ; n = Math . Abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
int countPairsWithDiffK ( int [ ] arr , int n , int k ) { int count = 0 ; Array . Sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
int findArrangement ( int N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }
void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( i * g + " ▁ " ) ; }
int countOfPairs ( int [ ] arr , int N , int X ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; }
int reachTarget ( int target ) { target = Math . Abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
int findM ( int N ) { int M = 0 ; int MSB = ( int ) Math . Log ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; }
bool pairInSortedRotated ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
int minPossibleValue ( int N , int K , int X ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }
void findMissing ( int [ ] a , int [ ] b , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) Console . Write ( a [ i ] + " ▁ " ) ; } }
int Last_set_bit ( int n ) { int p = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) { return p ; } p ++ ; n = n >> 1 ; } return - 1 ; }
void firstSubsequence ( string s ) { List < string > allsubseq = new List < string > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { string k = " " ; for ( int j = 0 ; j < s . Length ; j ++ ) { if ( i != j ) { k += s [ j ] ; } } allsubseq . Add ( k ) ; } allsubseq . Sort ( ) ; Console . WriteLine ( allsubseq [ 0 ] ) ; }
bool isPossible ( int index , int sum ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } bool placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) ; bool placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) ; if ( placeAdd placeMinus ) return true ; return false ; }
bool checkLuhn ( String cardNo ) { int nDigits = cardNo . Length ; int nSum = 0 ; bool isSecond = false ; for ( int i = nDigits - 1 ; i >= 0 ; i -- ) { int d = cardNo [ i ] - '0' ; if ( isSecond == true ) d = d * 2 ; nSum += d / 10 ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; }
bool isProductEven ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
double e ( int x , int n ) { double r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; }
void rearrange ( int [ ] arr , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }
void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) Console . WriteLine ( " NO " ) ; else Console . WriteLine ( " YES " ) ; }
void result ( long n , long k , long t ) { if ( t <= k ) Console . WriteLine ( t ) ; else if ( t <= n ) Console . WriteLine ( k ) ; else { long temp = t - n ; temp = k - temp ; Console . WriteLine ( temp ) ; } }
int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
int maxSum ( int [ ] arr , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . Max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
void print ( int n , int k ) { Console . Write ( k + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int x = ( int ) ( Math . Pow ( k , i ) - Math . Pow ( k , i - 1 ) ) ; Console . Write ( x + " ▁ " ) ; } }
bool LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }
int count_rectangles ( int N , int M ) { int p_x = ( N * ( N - 1 ) ) / 2 ; int p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }
void EditDistDP ( String str1 , String str2 ) { int len1 = str1 . Length ; int len2 = str2 . Length ; int [ , ] DP = new int [ 2 , len1 + 1 ] ; for ( int i = 0 ; i <= len1 ; i ++ ) DP [ 0 , i ] = i ; for ( int i = 1 ; i <= len2 ; i ++ ) { for ( int j = 0 ; j <= len1 ; j ++ ) { if ( j == 0 ) DP [ i % 2 , j ] = i ; else if ( str1 [ j - 1 ] == str2 [ i - 1 ] ) { DP [ i % 2 , j ] = DP [ ( i - 1 ) % 2 , j - 1 ] ; } else { DP [ i % 2 , j ] = 1 + Math . Min ( DP [ ( i - 1 ) % 2 , j ] , Math . Min ( DP [ i % 2 , j - 1 ] , DP [ ( i - 1 ) % 2 , j - 1 ] ) ) ; } } } Console . Write ( DP [ len2 % 2 , len1 ] + " STRNEWLINE " ) ; }
int CountPairs ( int [ ] arr , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }
bool check ( String str ) { int n = str . Length ; if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; 1 << i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
int max_sum ( int [ ] a , int n ) { int [ , ] dp = new int [ n + 1 , 2 ] ; dp [ 0 , 0 ] = 0 ; dp [ 0 , 1 ] = - 999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 , 0 ] = Math . Max ( dp [ i , 0 ] + a [ i ] , dp [ i , 1 ] - a [ i ] ) ; dp [ i + 1 , 1 ] = Math . Max ( dp [ i , 0 ] - a [ i ] , dp [ i , 1 ] + a [ i ] ) ; } return dp [ n , 0 ] ; }
int zigzag ( int n , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; dp [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i , 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . Min ( i , k ) ; j ++ ) dp [ i , j ] = dp [ i , j - 1 ] + dp [ i - 1 , i - j ] ; } return dp [ n , k ] ; }
double pentdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.22 * a ; return d ; }
void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { Console . Write ( " x ▁ = ▁ " + i + " , ▁ y ▁ = ▁ " + ( n - ( i * a ) ) / b ) ; return ; } } Console . Write ( " No ▁ solution " ) ; }
int minimal ( int [ ] a , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
int numberOfGP ( int [ ] L , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
int getFirstElement ( int [ ] a , int N , int K , int M ) { K %= N ; int index = ( K + M - 1 ) % N ; int result = a [ index ] ; return result ; }
bool isPalindrome ( float num ) { string s = num . ToString ( ) ; int low = 0 ; int high = s . Length - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }
int summation ( int n ) { int sum ; sum = ( int ) ( Math . Pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
int getOddOccurrence ( int [ ] arr , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
bool findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; }
int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
bool isPossible ( int [ ] a , int n ) { int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . Max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; }
int maxFreq ( string s , int a , int b ) { int [ ] fre = new int [ 10 ] ; int n = s . Length ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - '0' ] ++ ; if ( fre [ a ] == 0 && fre [ b ] == 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
int sumOfFirstM ( int [ ] A , int N , int M ) { int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { sum = sum + A [ i % N ] ; } return sum ; }
bool topsyTurvy ( char [ ] str ) { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '2' str [ i ] == '4' str [ i ] == '5' str [ i ] == '6' str [ i ] == '7' str [ i ] == '9' ) { return false ; } } return true ; }
void minAtEachIndex ( int n , int [ ] arr ) { int [ ] dp1 = new int [ n ] ; int [ ] dp2 = new int [ n ] ; int i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = Math . Min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = Math . Min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; List < int > v = new List < int > ( ) ; for ( i = 0 ; i < n ; i ++ ) v . Add ( Math . Min ( dp1 [ i ] , dp2 [ i ] ) ) ; foreach ( int x in v ) Console . Write ( x + " ▁ " ) ; }
int count_pairs ( int x ) { int ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = x / 2 ; } return ans ; }
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
int findAnswer ( int n , int [ ] arr ) { Array . Sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
int gonNum120 ( int n ) { return ( 118 * n * n - 116 * n ) / 2 ; }
void isSubsetAndZero ( int [ ] array , int length , int N ) { int arrAnd = array [ 0 ] ; for ( int i = 1 ; i < length ; i ++ ) { arrAnd = arrAnd & array [ i ] ; } if ( ( arrAnd & N ) == 0 ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { Console . Write ( j * j * j + " ▁ " ) ; break ; } } } }
int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) Math . Pow ( i , k ) ; } return sum ; }
int countPaths ( int sum , int get , int m , int n , int [ , ] dp ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum , get ] != - 1 ) return dp [ sum , get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum , get ] = res ; return dp [ sum , get ] ; }
int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N ++ ; return N ; }
void minProduct ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= ( n - 4 ) / 2 ; i ++ ) { ans = ( int ) ( 1L * ans * ( n - 2 ) ) % mod ; } ans = ( int ) ( 1L * ans * ( n - 2 ) * ( n - 1 ) ) % mod ; Console . Write ( ans + " STRNEWLINE " ) ; }
float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = ( float ) Math . Sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; }
int maxHeight ( int h1 , int h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }
void sumOfTwoPerfectCubes ( int N ) { Dictionary < int , int > cubes = new Dictionary < int , int > ( ) ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes . Add ( ( i * i * i ) , i ) ; var val = cubes . Keys . ToList ( ) ; foreach ( var key in val ) { int firstNumber = cubes [ 1 ] ; int secondNumber = N - cubes [ 1 ] ; if ( cubes . ContainsKey ( secondNumber ) ) { Console . Write ( " True " ) ; return ; } } Console . Write ( " False " ) ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int findEletobeInserted ( int [ ] A , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; }
int stepRequired ( int N ) { int cnt = 0 ; while ( N > 0 ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }
int smallestSumSubarr ( int [ ] arr , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . Min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
int calculateSum ( string [ ] arr , int n ) { if ( n == 0 ) return 0 ; string s = arr [ 0 ] ; int value = int . Parse ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = int . Parse ( s ) ; char operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
float angleOncirCumference ( float z ) { return ( z / 2 ) ; }
bool is_distinct ( long n , long k ) { HashSet < long > s = new HashSet < long > ( ) ; for ( int i = 1 ; i <= k ; i ++ ) { long tmp = n % i ; if ( s . Contains ( tmp ) ) { return false ; } s . Add ( tmp ) ; } return true ; }
int printNumber ( int N , int K , int M ) { int sum = K * ( M * ( M + 1 ) / 2 ) ; return sum - N ; }
int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; }
void printTwoOdd ( int [ ] arr , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } Console . WriteLine ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " + x + " ▁ & ▁ " + y ) ; }
void min_visible_bottles ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } ans = Math . Max ( ans , mp [ arr [ i ] ] ) ; } Console . Write ( " Minimum ▁ number ▁ of ▁ " + " Visible ▁ Bottles ▁ are : ▁ " + ans + " STRNEWLINE " ) ; }
void rearrange ( int [ ] arr ) { if ( arr == null arr . Length % 2 == 1 ) return ; int currIdx = ( arr . Length - 1 ) / 2 ; while ( currIdx > 0 ) { int count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } }
bool isLucky ( int n ) { bool [ ] arr = new bool [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; Console . Write ( " equation ▁ of ▁ plane ▁ is ▁ " + a + " x ▁ + ▁ " + b + " y ▁ + ▁ " + c + " z ▁ + ▁ " + d + " ▁ = ▁ 0" ) ; }
void findElements ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; }
void checkVantieghemsTheorem ( int limit ) { long prod = 1 ; for ( long n = 2 ; n < limit ; n ++ ) { if ( ( ( prod - n < 0 ? 0 : prod - n ) % ( ( 1 << ( int ) n ) - 1 ) ) == 0 ) Console . Write ( n + " ▁ is ▁ prime STRNEWLINE " ) ; prod *= ( ( 1 << ( int ) n ) - 1 ) ; } }
int minTrees ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . Max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
int answerQuery ( int [ ] a , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; bool isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } }
int cntSubsets ( int [ ] arr , int n ) { int max = ( int ) Math . Pow ( 2 , n ) ; int result = 0 ; for ( int i = 0 ; i < max ; i ++ ) { int counter = i ; if ( ( counter & ( counter >> 1 ) ) > 0 ) continue ; result ++ ; } return result ; }
int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool [ ] marked = new bool [ nNew + 1 ] ; for ( int i = 0 ; i < nNew + 1 ; i ++ ) marked [ i ] = false ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) Console . Write ( 2 + " ▁ " ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) Console . Write ( 2 * i + 1 + " ▁ " ) ; return - 1 ; }
void findNthTerm ( int n ) { Console . Write ( n * ( 5 * n + 3 ) / 2 ) ; }
double maxAverageOfPath ( int [ , ] cost , int N ) { int [ , ] dp = new int [ N + 1 , N + 1 ] ; dp [ 0 , 0 ] = cost [ 0 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i , 0 ] = dp [ i - 1 , 0 ] + cost [ i , 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 , j ] = dp [ 0 , j - 1 ] + cost [ 0 , j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) + cost [ i , j ] ; return ( double ) dp [ N - 1 , N - 1 ] / ( 2 * N - 1 ) ; }
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
void Bubble_Sort ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } } } }
void countDigit ( int [ , ] arr ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i , j ] ; int d = ( int ) ( Math . Floor ( Math . Log10 ( X ) * 1.0 ) + 1 ) ; Console . Write ( d + " ▁ " ) ; } Console . WriteLine ( ) ; } }
int multiplyWith4 ( int n ) { return ( n << 2 ) ; }
int productSubSeqCount ( ArrayList arr , int k ) { int n = arr . Count ; int [ , ] dp = new int [ k + 1 , n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i , j ] = dp [ i , j - 1 ] ; if ( Convert . ToInt32 ( arr [ j - 1 ] ) <= i && Convert . ToInt32 ( arr [ j - 1 ] ) > 0 ) dp [ i , j ] += dp [ i / Convert . ToInt32 ( arr [ j - 1 ] ) , j - 1 ] + 1 ; } } return dp [ k , n ] ; }
void Alphabet_N_Pattern ( int N ) { int index , side_index ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { Console . Write ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) Console . Write ( " ▁ " ) ; if ( index != 0 && index != N - 1 ) Console . Write ( Diagonal ++ ) ; else Console . Write ( " ▁ " ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) Console . Write ( " ▁ " ) ; Console . Write ( Right ++ ) ; Console . Write ( " STRNEWLINE " ) ; } }
int cntSubsets ( int [ ] arr , int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } int result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
void mirrorMatrix ( int [ , ] mat1 , int [ , ] mat2 , int N ) { int row = 0 ; int col = 0 ; bool isMirrorImage = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row , col ] != mat1 [ i , j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
int countStrings ( String s ) { int sum = 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( i % 2 == 0 && s [ i ] == ' $ ' ) sum *= 21 ; else if ( s [ i ] == ' $ ' ) sum *= 5 ; } return sum ; }
int nDigitPalindromes ( int n ) { return ( 9 * ( int ) Math . Pow ( 10 , ( n - 1 ) / 2 ) ) ; }
int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; }
int findInGrid ( int i , int j ) { if ( i == j ) return ( i * i - ( i - 1 ) ) ; else if ( i > j ) { if ( i % 2 == 0 ) return i * i - ( j - 1 ) ; else return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ; } else { if ( j % 2 == 0 ) return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ; else return j * j - ( i - 1 ) ; } }
int findNumber ( int n ) { int x = ( int ) Math . Floor ( ( - 1 + Math . Sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int Base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - Base + 1 ; }
double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; Console . Write ( "1 ▁ " ) ; for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; Console . Write ( multi ) ; Console . Write ( " ▁ " ) ; multi = multi * x ; } Console . WriteLine ( ) ; return total ; }
int largestNum ( int [ ] arr ) { HashSet < int > set = new HashSet < int > ( ) ; int res = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { set . Add ( arr [ i ] ) ; if ( set . Contains ( - 1 * arr [ i ] ) ) { res = Math . Max ( res , Math . Abs ( arr [ i ] ) ) ; } } return res ; }
int findMinX ( int [ ] num , int [ ] rem , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
void splitArray ( int [ ] arr , int n , int K ) { Array . Sort ( arr ) ; int i = n - 1 ; int result = 0 ; while ( K -- != 0 ) { result += arr [ i - 1 ] ; i -= 2 ; } Console . Write ( result ) ; }
void printPairs ( int [ ] arr , int n ) { List < int > v = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( arr [ i ] ) == Math . Abs ( arr [ j ] ) ) v . Add ( Math . Abs ( arr [ i ] ) ) ; if ( v . Count == 0 ) return ; v . Sort ( ) ; for ( int i = 0 ; i < v . Count ; i ++ ) Console . Write ( - v [ i ] + " ▁ " + v [ i ] ) ; }
bool isPossibleToZero ( int [ ] a , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
String generateNumber ( string number ) { int temp = 0 , adding_number = 0 ; string result = " " ; int len = number . Length ; for ( int i = len - 1 ; i >= 0 ; i -- ) { int digit = ( int ) number [ i ] - ( int ) '0' ; if ( temp % 2 == 0 ) { adding_number += 1 ; digit += adding_number ; if ( digit >= 10 ) { digit %= 9 ; if ( digit == 0 ) digit = 9 ; } } result = digit + result ; temp += 1 ; } return result ; }
string findNumber ( int n , int d ) { string ans = " " ; if ( d != 10 ) { ans += d . ToString ( ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += " Impossible " ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; }
int findLUSlength ( String a , String b ) { if ( a . Equals ( b ) == true ) return 0 ; return Math . Max ( a . Length , b . Length ) ; }
void swap ( int a , int b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; Console . Write ( " After ▁ swapping : ▁ a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b ) ; }
