function changeEvenBits ( n ) { let to_subtract = 0 ; let m = 0 ; for ( x = n ; x ; x >>= 2 ) { if ( x & 1 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
function checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
function FindPairs ( n , k ) { document . write ( 1 + " " + n + " " ) ; k -- ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { document . write ( 1 + " " + i + " " ) ; k -- ; if ( k == 0 ) break ; if ( i != n / i ) { document . write ( 1 + " " + n / i + " " ) ; k -- ; } if ( k == 0 ) break ; } } }
function decrypt ( Str , Start , End ) { if ( Start > End ) { return ; } let mid = ( Start + End ) >> 1 ; document . write ( Str [ mid ] ) ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
function prefixDivisble ( n ) { let i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = parseInt ( n / 10 ) ; i ++ ; } return true ; }
function minimum_required_operations ( arr , n , k ) { let answer = 0 ; let mod = 1000000007 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
function transpose ( A ) { for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) { var temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; transpose ( A ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( A [ i ] [ j ] + " " ) ; document . write ( " \< " ) ; }
function checkFactors ( N ) { let ev_count = 0 , od_count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == Math . floor ( N / i ) ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( Math . floor ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function findevenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; let oddCount = parseInt ( ( count * ( count - 1 ) ) / 2 ) ; return parseInt ( ( N * ( N - 1 ) ) / 2 ) - oddCount ; }
function countIntegralSolutions ( n ) { let result = 0 ; for ( let i = 0 ; i <= n ; i ++ ) for ( let j = 0 ; j <= n - i ; j ++ ) for ( let k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
function EnneacontahexagonNum ( n ) { return ( 94 * n * n - 92 * n ) / 2 ; }
function CountPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
function Findpermutation ( n ) { let a = new Array ( n + 1 ) ; a [ 1 ] = n ; for ( let i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }
function countSetBits ( n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
function minTime ( arr , n ) { if ( n <= 0 ) return 0 ; let incl = arr [ 0 ] ; let excl = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let incl_new = arr [ i ] + Math . min ( excl , incl ) ; let excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
function countValues ( x ) { var count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x = parseInt ( x / 2 ) ; } return count ; }
function countPairs ( arr , n ) { let ans = 0 ; let count = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( count . has ( arr [ i ] ) ) { ans += count . get ( arr [ i ] ) ; count . set ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; } else { count . set ( arr [ i ] , 1 ) ; } } return ans ; }
function findRadius ( r1 , r2 ) { let a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . sqrt ( a3 / 3.14 ) ; return r3 ; }
function BeattySequence ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { let ans = parseInt ( Math . floor ( i * Math . sqrt ( 2 ) ) ) ; document . write ( ans + " " ) ; } }
function testSomeNumbers ( limit , n ) { if ( n < 3 ) return ; for ( let a = 1 ; a <= limit ; a ++ ) for ( let b = a ; b <= limit ; b ++ ) { let pow_sum = ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; let c = Math . pow ( pow_sum , 1.0 / n ) ; let c_pow = Math . pow ( Math . round ( c ) , n ) ; if ( c_pow == pow_sum ) { document . write ( " " ) ; return ; } } document . write ( " " + " " ) ; }
function freq ( ar , m , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < m ; ++ i ) { for ( let j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } document . write ( " " + odd + " " ) ; document . write ( " " + even + " " ) ; }
function findSum ( arr , n , k ) { var ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( var i = 1 ; i <= k ; i ++ ) { ans = Math . min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
function countSubStr ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) m ++ ; } return m * Math . floor ( ( m - 1 ) / 2 ) ; }
function search ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
function findPairs ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; arr . sort ( ( a , b ) => a - b ) ; let left = 0 ; let ans = 0 ; for ( let right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } document . write ( ans ) ; }
function possibleStrings ( n , r , b , g ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; let left = n - ( r + g + b ) ; let sum = 0 ; for ( let i = 0 ; i <= left ; i ++ ) { for ( let j = 0 ; j <= left - i ; j ++ ) { let k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
function pairStar ( input , i ) { output = output + input [ i ] ; if ( i == input . length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' ' ; pairStar ( input , i + 1 ) ; }
function findLCMPrime ( a , b ) { if ( a == b ) { return a ; } return a * b ; }
function getFinalElement ( n ) { let finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
function get ( x , y , z ) { if ( x > z ) return - 1 ; let val = z - x ; let div = Math . floor ( ( z - x ) / y ) ; let ans = div * y + x ; return ans ; }
function checkForSorting ( arr , n ) { let temp = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
function printModulus ( X , Y ) { var n = Math . max ( X , Y ) ; for ( var i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) document . write ( i + " " ) ; } }
function findMinLength ( arr ) { let index = parseInt ( arr . length ) - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }
function countCon ( ar , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; }
function factorial ( n ) { let M = 1000000007 ; let f = 1 ; for ( let i = 1 ; i <= n ; i ++ ) return f ; }
function possibleToReach ( x , y , z ) { if ( z < Math . abs ( x ) + Math . abs ( y ) || ( z - Math . abs ( x ) - Math . abs ( y ) ) % 2 == 1 ) { document . write ( " " + " " ) ; } else document . write ( " " + " " ) ; }
function sum ( x , y , n ) { sum1 = ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ; sum2 = ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }
function flipBitsOfAandB ( A , B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; document . write ( A + " " + B ) ; }
function countStrings ( s ) { let cnt = 0 ; for ( let i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
function findLargestString ( s , i , r ) { if ( i == s . length ) { if ( r == 0 ) return 0 ; else return - 1000000000 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = Math . max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
function productPairs ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 2 ; i ++ ) for ( let j = i + 1 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
function getCount ( arr , n , num1 , num2 ) { let i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; let j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = parseInt ( n / i , 10 ) ; let num1 = fir * k + sec ; let res = parseInt ( ( num1 / k ) , 10 ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = parseInt ( ( num2 / k ) , 10 ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }
function NumberofTimes ( str ) { var temporary_sum = 0 , count = 0 ; while ( str . length > 1 ) { temporary_sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) temporary_sum += ( str . charAt ( i ) - ' ' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
function ReuleauxArea ( r ) { if ( r < 0 ) return - 1 ; var A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }
function findMinRooms ( slots , n , m ) { let counts = Array ( m ) . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == ' ' ) counts [ j ] ++ ; let max = - 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
function thirdLargest ( arr , arr_size ) { if ( arr_size < 3 ) { document . write ( " " ) ; return ; } let first = arr [ 0 ] ; for ( let i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; let second = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; let third = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; document . write ( " " + " " , third ) ; }
function isMember ( a , d , x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
function printSeriesSum ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += Math . pow ( i , i - 1 ) ; } document . write ( sum ) ; }
function validQuadruple ( arr , n ) { if ( n >= MAX ) return true ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
function hexadecagonalNum ( n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
function isDivisibleBy5 ( str ) { n = str . length ; return ( ( ( str [ n - 1 ] - ' ' ) == 0 ) || ( ( str [ n - 1 ] - ' ' ) == 5 ) ) ; }
function minTimeForWritingChars ( N , insert , remove , copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 1 ] = insert ; for ( let i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ parseInt ( i / 2 , 10 ) ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + copy + remove ) ; } return dp [ N ] ; }
function getTotalNumberOfSequences ( m , n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
function numberSequence ( n ) { let num = Math . pow ( 4 , n ) - Math . pow ( 2 , n ) - 1 ; return num ; }
function findSubarrays ( arr , N , K ) { return N - K + 1 ; }
function FindTrip ( arr , N ) { for ( let i = 1 ; i < N - 1 ; i ++ ) { let p = arr [ i - 1 ] ; let q = arr [ i ] ; let r = arr [ i + 1 ] ; if ( p < q && q > r ) { document . write ( ( i - 1 ) + " " + ( i ) + " " + ( i + 1 ) ) ; return ; } } document . write ( - 1 ) ; }
function polyapothem ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
function reverse ( str , len , l , r ) { if ( l < 0 r >= len l > r ) return " " ; while ( l < r ) { let c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } return str . join ( " " ) ; }
function divide ( dividend , divisor ) { var sign = ( ( dividend < 0 ) ? 1 : 0 ^ ( divisor < 0 ) ? 1 : 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; var quotient = 0 , temp = 0 ; while ( dividend >= divisor ) { dividend -= divisor ; ++ quotient ; } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
function MinimumMoves ( a , n , x ) { var ans = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { var p = parseInt ( ( a [ i - 1 ] - a [ i ] ) / x + 1 ) ; ans += p ; a [ i ] += p * x ; } } return ans ; }
function power ( n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
function subsequence ( S , T , n , m ) { let dp = new Array ( ) for ( let i = 0 ; i < n + 1 ; i ++ ) { let temp = [ ] ; for ( let j = 0 ; j < m + 1 ; j ++ ) { temp . push ( [ ] ) } dp . push ( temp ) } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( let j = 0 ; j <= m ; j ++ ) dp [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j <= m ; ++ j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; dp [ i ] [ j ] += mod ; dp [ i ] [ j ] %= mod ; } } return dp [ n ] [ m ] ; }
function findMaxSum ( arr , n ) { let preSum = new Array ( n ) ; preSum . fill ( 0 ) ; let suffSum = new Array ( n ) ; suffSum . fill ( 0 ) ; let ans = Number . MIN_VALUE ; preSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }
function minMoves ( arr ) { let N = arr . length ; if ( N <= 2 ) return 0 ; let ans = Number . MAX_VALUE ; for ( let i = - 1 ; i <= 1 ; i ++ ) { for ( let j = - 1 ; j <= 1 ; j ++ ) { let num1 = arr [ 0 ] + i ; let num2 = arr [ 1 ] + j ; let flag = 1 ; let moves = Math . abs ( i ) + Math . abs ( j ) ; for ( let idx = 2 ; idx < N ; idx ++ ) { let num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Number . MAX_VALUE ) return - 1 ; return ans ; }
function length_of_chord ( r , x ) { document . write ( " " + " " + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) + " " ) ; }
function max_min ( a , n ) { a . sort ( ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
function Permutation ( n , k ) { let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( let i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( let i = 1 ; i <= n ; i ++ ) document . write ( p [ i ] + " " ) ; }
function countElement ( A , N , B , M , K ) { let cnt = 0 ; for ( let i = 0 ; i < M ; i ++ ) { let currentElement = B [ i ] ; for ( let j = 0 ; j < N ; j ++ ) { let diff = Math . abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } document . write ( cnt ) ; }
function findFreq ( str , N ) { let freq = new Array ( 256 ) . fill ( 0 ) ; let max = 0 ; let charMax = ' ' ; for ( let i = 0 ; i < N ; i ++ ) { let ch = str [ i ] . charCodeAt ( 0 ) ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; charMax = ch ; } document . write ( String . fromCharCode ( charMax ) + " " + max + " " ) ; } }
function maxvolume ( s ) { let maxvalue = 0 ; for ( let i = 1 ; i <= s - 2 ; i ++ ) { for ( let j = 1 ; j <= s - 1 ; j ++ ) { let k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
function minLettersNeeded ( n ) { if ( n % 26 == 0 ) return parseInt ( n / 26 ) ; else return ( parseInt ( n / 26 ) + 1 ) ; }
function evenXorSubarray ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let XOR = 0 ; for ( let j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } document . write ( ans ) ; }
function equilibrium ( arr , n ) { sum = 0 ; leftsum = 0 ; for ( let i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
function countSubStr ( str , n , x ) { let res = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
function PrletBothArrays ( a , n ) { let v1 = [ ] , v2 = [ ] ; let mpp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { mpp . set ( a [ i ] , ( mpp . get ( a [ i ] ) == null ? 0 : mpp . get ( a [ i ] ) ) + 1 ) ; if ( mpp . get ( a [ i ] ) == 1 ) v1 . push ( a [ i ] ) ; else if ( mpp . get ( a [ i ] ) == 2 ) v2 . push ( a [ i ] ) ; else { document . write ( " " ) ; return ; } } v1 . sort ( ) ; document . write ( " " + " " ) ; for ( let i = 0 ; i < v1 . length ; i ++ ) document . write ( v1 [ i ] + " " ) ; v2 . sort ( ) ; v2 . reverse ( ) ; document . write ( " " + " " + " " ) ; for ( let i = 0 ; i < v2 . length ; i ++ ) document . write ( v2 [ i ] + " " ) ; }
function findTrailingZeros ( n ) { if ( n & 1 ) return 0 ; else { let ans = 0 ; n = parseInt ( n / 2 ) ; while ( n ) { ans += parseInt ( n / 5 ) ; n = parseInt ( n / 5 ) ; } return ans ; } }
function checkWord ( board , word , index , row , col ) { if ( row < 0 col < 0 row >= board . length col >= board [ 0 ] . length ) return false ; if ( board [ row ] [ col ] !== word [ index ] ) return false ; else if ( index === word . length - 1 ) return true ; var temp = board [ row ] [ col ] ; board [ row ] [ col ] = " " ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row ] [ col ] = temp ; return true ; } board [ row ] [ col ] = temp ; return false ; } var board = [ [ " " , " " , " " , " " ] , [ " " , " " , " " , " " ] , [ " " , " " , " " , " " ] , ] ; var word = " " ; var f = 0 ; for ( var i = 0 ; i < board . length ; i ++ ) { for ( var j = 0 ; j < board [ 0 ] . length ; j ++ ) { if ( board [ i ] [ j ] === word [ 0 ] && checkWord ( board , word , 0 , i , j ) ) { document . write ( " " ) ; f = 1 ; } } if ( f === 1 ) { i = board . length + 1 ; } } if ( f === 0 ) { document . write ( " " ) ; }
function printRoots ( a , b , c ) { document . write ( 1 + " " + c / ( a * 1.0 ) ) ; }
function findStarNum ( n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
function hexDiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.73 * a ; return d ; }
function countDigit ( n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( parseInt ( n / 10 ) ) ; }
function printLastElement ( arr , N ) { var leftTurn = true ; var remainElements = N ; var step = 1 ; var head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } document . write ( arr [ head - 1 ] ) ; }
function countDer ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
function countFreq ( arr , n ) { let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; let count = 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } document . write ( arr [ i ] + " " + count + " " ) ; } }
function calc_distance ( A , B , n ) { var distance_traveled_A = 0 ; var distance_traveled_B = 0 ; var answer = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
function pairs ( n ) { let c = new Array ( 10 ) ; for ( var i = 0 ; i < c . length ; i ++ ) { c [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < c . length ; i ++ ) { for ( var j = 0 ; j < c . length ; j ++ ) { c [ i ] [ j ] = 0 ; } } let tmp = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ Math . floor ( i / tmp ) ] [ i % 10 ] ++ ; } let ans = 0 ; for ( let i = 1 ; i < 10 ; i ++ ) for ( let j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
function linearSearch ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
function minOperations ( str , n ) { var count = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; }
function minOperation ( arr ) { let minOp = Number . MIN_VALUE ; let minNeg = 0 , maxPos = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return Math . abs ( minNeg ) + maxPos ; }
function maxHamming ( arr , n ) { let brr = new Array ( 2 * n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; let maxHam = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let currHam = 0 ; for ( let j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
function mod ( a , m ) { return ( a % m + m ) % m ; }
function check ( arr , N ) { let even = 0 ; let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) document . write ( " " ) ; else document . write ( " " ) ; }
function count ( n , k ) { let count = Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ; document . write ( count ) ; }
function sumOfInternalAngles ( n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; }
function countNumbers ( N ) { return parseInt ( ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 , 10 ) ; }
function countToMake0lternate ( s ) { let result = 0 ; for ( let i = 0 ; i < ( s . length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
function check ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) { var hm = new Map ( ) ; var count = 0 ; for ( var j = i ; j < n ; j ++ ) { if ( hm . has ( arr [ j ] ) ) hm . set ( arr [ j ] , hm . get ( arr [ j ] ) + 1 ) else hm . set ( arr [ j ] , 1 ) if ( hm . get ( arr [ j ] ) == 1 ) count ++ ; if ( hm . get ( arr [ j ] ) == 2 ) count -- ; if ( count == 0 ) return " " ; } } return " " ; }
function findSubstringCount ( str ) { var result = 0 ; var n = str . length ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) + 1 ) == str [ i + 1 ] ) { result ++ ; while ( String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) + 1 ) === str [ i + 1 ] ) { i ++ ; } } } return result ; }
function countDigits ( n ) { return ( n * Math . log10 ( 2 ) + 1 ) ; }
function findPeak ( arr , n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } }
function countNumberOfStrings ( s ) { let n = s . length - 1 ; let count = ( Math . pow ( 2 , n ) ) ; return count ; }
function posOfRightMostSameBit ( m , n ) { let loopCounter = 1 ; while ( m > 0 n > 0 ) { let a = m % 2 == 1 ; let b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return - 1 ; }
function closestMultiple ( n , x ) { if ( x > n ) return x ; n = n + parseInt ( x / 2 , 10 ) ; n = n - ( n % x ) ; return n ; }
function pairExists ( arr1 , m , arr2 , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( s . has ( arr2 [ j ] - arr1 [ i ] ) ) return true ; } s . add ( arr1 [ i ] ) ; } return false ; }
function largest ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] ; }
function countX ( a , b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { let x = a - b , ans = 0 ; for ( let i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { let d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = parseInt ( x / i ) ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
function findEquation ( A , B , C ) { document . write ( " " + C + " " + " " + B + " " + A + " " ) }
function minSum ( arr , n ) { let sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
function getM ( n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
function subtract ( A , B , C ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var C = Array . from ( Array ( N ) , ( ) => Array ( N ) ) ; var i , j ; subtract ( A , B , C ) ; document . write ( " " + " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + n - 3 ; }
function volumeRec ( a , b , e , h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
function findNthNumber ( N ) { let result = 0 ; let p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = parseInt ( N / 9 , 10 ) ; p = p * 10 ; } return result ; }
function countSquares ( n ) { return ( Math . pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
function lis ( arr , n ) { let lis = Array ( n ) . fill ( 0 ) ; let i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
function isPossible ( a , n ) { var cur = a [ 0 ] ; cur -- ; for ( var i = 1 ; i < n ; i ++ ) { var nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }
function circle_inscribed ( a ) { return PI * ( a * a ) / 12 ; }
function spiralDiaSum ( n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
function getMin ( arr , n ) { var minVal = Math . min . apply ( Math , arr ) ; return minVal ; }
function colMaxDiff ( mat ) { let max_diff = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( let j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; }
function findSmallestNumK ( n ) { let cummAnd = n ; let i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
function area ( d1 , a ) { var d2 = Math . sqrt ( 4 * ( a * a ) - d1 * d1 ) ; var area = 0.5 * d1 * d2 ; return area ; }
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
function printChar ( str , n ) { let freq = [ ] ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq . push ( 0 ) ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str . charCodeAt ( i ) - 97 ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str . charCodeAt ( i ) - 97 ] % 2 == 1 ) { document . write ( str [ i ] ) ; } } }
function isPossible ( A , B , n , m , x , y ) { if ( x > n y > m ) return false ; A . sort ( ) ; B . sort ( ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
function getMinOps ( arr ) { let ans = 0 ; for ( let i = 0 ; i < arr . length - 1 ; i ++ ) { ans += Math . max ( arr [ i ] - arr [ i + 1 ] , 0 ) ; } return ans ; }
function MinimumMail ( n , k , x ) { let m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
function can_empty ( a , b , c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { let m = Math . min ( a , Math . min ( b , c ) ) ; if ( m < Math . floor ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
function removeDuplicatesFromString ( string ) { let counter = 0 ; let str = string . split ( " " ) ; let i = 0 ; let size = str . length ; let x ; let length = 0 ; while ( i < size ) { x = str [ i ] . charCodeAt ( 0 ) - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = String . fromCharCode ( ' ' . charCodeAt ( 0 ) + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return str . join ( " " ) . slice ( 0 , length ) ; }
function centeredDodecagonal ( n ) { return 6 * n * ( n - 1 ) + 1 ; }
function summation ( N ) { var co = parseInt ( ( N + 1 ) / 2 ) ; var ce = parseInt ( ( N ) / 2 ) ; var se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; var so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
function smallestMultiple ( n ) { if ( n == 1 ) return 5 ; return Math . pow ( 10 , n - 1 ) ; }
function rectCount ( n , m ) { return parseInt ( ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 , 10 ) ; }
function countUnique ( mat , n , m ) { let rowsum = new Array ( n ) ; rowsum . fill ( 0 ) ; let colsum = new Array ( m ) ; colsum . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } let uniquecount = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
function maxItems ( x , y , z ) { let type1 = parseInt ( x / COST ) ; x %= COST ; let type2 = parseInt ( y / COST ) ; y %= COST ; let type3 = parseInt ( z / COST ) ; z %= COST ; let type4 = Math . min ( x , Math . min ( y , z ) ) ; let maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
function center_octadecagon_num ( n ) { return 9 * n * n - 9 * n + 1 ; }
function polynomialRollingHash ( str ) { let p = 31 ; let m = ( 1e9 + 9 ) ; let power_of_p = 1 ; let hash_val = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { hash_val = ( hash_val + ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
function isFibbinaryNum ( n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
function calculate ( n , power ) { sum = 0 ; bp = Math . pow ( n , power ) ; while ( bp != 0 ) { d = bp % 10 ; sum = sum + d ; bp = Math . floor ( bp / 10 ) ; } return sum ; }
function maxPossibleSum ( arr , N ) { arr . sort ( ) ; let sum = 0 ; let j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } document . write ( sum ) ; }
function maxWater ( arr , n ) { let left = 0 ; let right = n - 1 ; let l_max = 0 ; let r_max = 0 ; let result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += Math . max ( 0 , r_max - arr [ right ] ) ; r_max = Math . max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += Math . max ( 0 , l_max - arr [ left ] ) ; l_max = Math . max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
function maxArea ( polet_x , polet_y , n , length , width ) { polet_x . sort ( ( a , b ) => a - b ) ; ; polet_y . sort ( ( a , b ) => a - b ) ; ; let dx = polet_x [ 0 ] ; let dy = polet_y [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { dx = Math . max ( dx , polet_x [ i ] - polet_x [ i - 1 ] ) ; dy = Math . max ( dy , polet_y [ i ] - polet_y [ i - 1 ] ) ; } dx = Math . max ( dx , ( length + 1 ) - polet_x [ n - 1 ] ) ; dy = Math . max ( dy , ( width + 1 ) - polet_y [ n - 1 ] ) ; document . write ( ( dx - 1 ) * ( dy - 1 ) ) ; }
function sumNodes ( l ) { let leafNodeCount = Math . pow ( 2 , l - 1 ) ; let sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; let sum = sumLastLevel * l ; return sum ; }
function eccHyperbola ( A , B ) { let r = B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; }
function Kroneckerproduct ( A , B ) { let C = new Array ( rowa * rowb ) for ( let i = 0 ; i < ( rowa * rowb ) ; i ++ ) { C [ i ] = new Array ( cola * colb ) ; for ( let j = 0 ; j < ( cola * colb ) ; j ++ ) { C [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < rowa ; i ++ ) { for ( let k = 0 ; k < rowb ; k ++ ) { for ( let j = 0 ; j < cola ; j ++ ) { for ( let l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; document . write ( C [ i + l + 1 ] [ j + k + 1 ] + " " ) ; } } document . write ( " " ) ; } } }
function Survives ( n ) { let i ; for ( let i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= parseInt ( n / i ) ; } }
function countSwaps ( A , n ) { var mp = new Map ( ) ; var max_frequency = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( A [ i ] ) ) mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) else mp . set ( A [ i ] , 1 ) ; max_frequency = Math . max ( max_frequency , mp . get ( A [ i ] ) ) ; } return n - max_frequency ; }
function maxLength ( arr , n ) { let maxLen = 0 ; let i = 0 ; let j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . max ( maxLen , 2 ) ; let l = i - 1 ; let r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
function No_of_cubes ( N , K ) { let No = 0 ; No = ( N - K + 1 ) ; No = Math . pow ( No , 3 ) ; return No ; }
function maxModProdSubarr ( arr , n , M ) { var ans = 0 ; var length = n ; for ( i = 0 ; i < n ; i ++ ) { var product = 1 ; for ( j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } document . write ( " " + ans + " " ) ; document . write ( " " + " " + length ) ; }
function printNSE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next + " " ) ; } }
function isPowerOfK ( n , k ) { let oneSeen = false ; while ( n > 0 ) { let digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n = Math . floor ( n / k ) ; } return true ; }
function computeMaxValue ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var val = Math . max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = Math . max ( ans , val ) ; } } return ans ; }
function distance ( x1 , y1 , z1 , x2 , y2 , z2 ) { var d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; document . write ( " " + d . toFixed ( 10 ) ) ; return ; }
function isLoeschian ( n ) { for ( let x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { for ( let y = 1 ; y <= Math . sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
function countNegative ( M , n , m ) { let count = 0 ; let i = 0 ; let j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
function heightCalculate ( H , n , m ) { let N = n * 1.0 ; let M = m * 1.0 ; let h = H * Math . sqrt ( N / ( N + M ) ) ; return h ; }
function Nonagonal ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { document . write ( parseInt ( i * ( 7 * i - 5 ) / 2 ) + " " ) ; } }
function eulerian ( n , m ) { var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
function findDecimal ( arr , N ) { let bit , power = 0 , result = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { bit = Math . abs ( Math . floor ( arr [ i ] ) - Math . round ( arr [ i ] ) ) ; if ( bit != 0 ) result += Math . pow ( 2 , power ) ; power ++ ; } document . write ( result ) ; }
function MatrixChainOrder ( p , n ) { var dp = Array . from ( Array ( n ) , ( ) => Array ( n ) ) ; for ( var i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( var L = 1 ; L < n - 1 ; L ++ ) for ( var i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
function maxPointOfIntersection ( x , y ) { let k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
function findMinSum ( num ) { let sum = 0 ; for ( let i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
function findOccurrences ( str1 , substr1 ) { let counter = 0 ; for ( let i = 0 ; i < str1 . length ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) { for ( let j = i + 1 ; j < str1 . length ; j ++ ) { if ( str1 [ j ] == substr1 [ 1 ] ) { for ( let k = j + 1 ; k < str1 . length ; k ++ ) { if ( str1 [ k ] == substr1 [ 2 ] ) counter ++ ; } } } } } return counter ; }
function lenOfLongSubarr ( arr , n ) { var um = new Map ( ) ; var sum = 0 , maxLen = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . has ( sum ) ) um . set ( sum , i ) ; if ( um . has ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function maxResult ( n , a , b , c ) { let maxVal = 0 ; for ( let i = 0 ; i <= n ; i += a ) for ( let j = 0 ; j <= n - i ; j += b ) { let z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { let x = i / a ; let y = j / b ; maxVal = Math . max ( maxVal , x + y + z ) ; } } return maxVal ; }
function expectedSteps ( x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
function isTwoAlter ( s ) { for ( let i = 0 ; i < s . length - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }
function count9s ( number ) { let count = 0 ; let n = ( number . length ) ; for ( let i = 0 ; i < n ; i ++ ) { let sum = number [ i ] - ' ' ; if ( number [ i ] == ' ' ) { count ++ ; } for ( let j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - ' ' ) % 9 ; if ( sum == 0 ) { count ++ ; } } } return count ; }
function printDuplicates ( arr , n ) { let i ; let fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { document . write ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) document . write ( " " ) ; }
function countSubsequences ( arr ) { let odd = 0 ; for ( let x = 0 ; x < arr . length ; x ++ ) { if ( arr [ x ] & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; }
function getPairsCount ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . abs ( i - j ) ) count ++ ; } } return count ; }
function answer ( L , R ) { if ( 2 * L <= R ) document . write ( L + " " + 2 * L + " " ) ; else document . write ( - 1 ) ; }
function precompute ( s , K ) { var n = s . length ; for ( var i = 0 ; i < n - 1 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] + ( s . substring ( i , i + K . length ) == K ) ; } } var s = " " ; var K = " " ; precompute ( s , K ) ; var Q = [ [ 1 , 6 ] , [ 5 , 11 ] ] ; Q . forEach ( ( it ) => { document . write ( cnt [ it [ 1 ] - 1 ] - cnt [ it [ 0 ] - 1 ] + " " ) ; }
function check ( n , m ) { if ( m % n == 0 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } return 0 ; }
function det ( d ) { let Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) ; Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) ; Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) ; return Sum ; }
function countEvenPairs ( N , M ) { let count = 0 ; nEven = parseInt ( Math . floor ( N / 2 ) ) ; nOdd = parseInt ( Math . ceil ( N / 2 ) ) ; mEven = parseInt ( Math . floor ( M / 2 ) ) ; mOdd = parseInt ( Math . ceil ( M / 2 ) ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
function solve ( n , d , input ) { let a = new Array ( N ) ; let cnt = new Array ( V + 1 ) ; for ( let i = 0 ; i < n ; ++ i ) a [ i ] = input [ i ] ; let answer = 0 ; for ( let i = 0 ; i < d ; ++ i ) cnt [ a [ i ] ] ++ ; for ( let i = d ; i <= n - 1 ; ++ i ) { let acc = 0 ; let low_median = - 1 , high_median = - 1 ; for ( let v = 0 ; v <= V ; ++ v ) { acc += cnt [ v ] ; if ( low_median == - 1 && acc >= parseInt ( Math . floor ( ( d + 1 ) / 2.0 ) ) ) low_median = v ; if ( high_median == - 1 && acc >= parseInt ( Math . ceil ( ( d + 1 ) / 2.0 ) ) ) high_median = v ; } let double_median = low_median + high_median ; if ( a [ i ] >= double_median ) answer ++ ; cnt [ a [ i - d ] ] -- ; cnt [ a [ i ] ] ++ ; } document . write ( answer ) ; }
function maximumValue ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { ans = Math . max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } document . write ( ans ) ; }
function alternate ( a , b , x ) { return x = a ^ b ^ x ; }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function findPairs ( arr1 , arr2 , n , m , x ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) document . write ( arr1 [ i ] + " " + arr2 [ j ] + " " ) ; }
function smallest_pair ( a , n ) { let min = Number . MAX_VALUE , secondMin = Number . MAX_VALUE ; for ( let j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
function maxSum ( N ) { var ans = 0 ; for ( var u = 1 ; u <= N ; u ++ ) { for ( var v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; var degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; var degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let sum = arr [ 0 ] ; for ( let i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; let max_sum = sum ; let max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
function minMovesToSort ( arr , n ) { var moves = 0 ; var i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; mn = arr [ i ] ; } return moves ; }
function CalPeri ( ) { var S = 5 , Perimeter ; Perimeter = 10 * S ; document . write ( " " + Perimeter ) ; }
function sum ( n ) { if ( n == 1 ) return 1 ; else return ( Math . pow ( n , n ) + sum ( n - 1 ) ) ; }
function path_to_root ( node ) { while ( node >= 1 ) { document . write ( node + " " ) ; node = parseInt ( node / 2 , 10 ) ; } }
function check ( current_row , current_col , destination_row , destination_col ) { if ( current_row == destination_row ) return " " ; else if ( current_col == destination_col ) return " " ; else return " " ; }
function findSumOfAllSubsets ( arr , n , k ) { let factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( let i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( let i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( let i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; let freq = factorial_N / ( factorial_d * factorial_D ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; document . write ( " " + k + " " + sum + " " ) ; }
function maximumCandy ( candies , safety , N , M ) { let total = 0 ; let ans = Number . MAX_VALUE ; let all_safe = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . min ( ans , safety [ i ] ) ; } else { ans = Math . min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
function getSetBitsFromOneToN ( N ) { var two = 2 var ans = 0 var n = N while ( n != 0 ) { ans += Math . floor ( N / two ) * ( two >> 1 ) if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 two <<= 1 ; n >>= 1 ; } return ans }
function sphere ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; return r ; }
function productOfGP ( a , r , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
function fib ( n ) { if ( n < 6 ) return f [ n ] ; let t = 5 , fn = 5 ; while ( t < n ) { fn = Math . round ( fn * PHI ) ; t ++ ; } return fn ; }
function bin ( n ) { let i ; document . write ( " " ) ; for ( i = 1 << 30 ; i > 0 ; i = Math . floor ( i / 2 ) ) { if ( ( n & i ) != 0 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } } }
function ispalindrome ( s ) { let l = s . length ; let j ; for ( let i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) return false ; } return true ; } let s = " " ; let cnt = 0 ; let flag = 0 ; while ( s . length > 0 ) { if ( ispalindrome ( s ) ) { flag = 1 ; break ; } else { cnt ++ ; s = s . substring ( 0 , s . length - 1 ) ; } }
function Length_Diagonals ( a , theta ) { let p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; let q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return [ p , q ] ; }
function solve ( n ) { var ans = 0 ; for ( y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } document . write ( ans ) ; }
function maximizeFinalElement ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; }
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 3 * n + 2 ; }
function findOddPair ( A , N ) { let i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
function fractionToDecimal ( numr , denr ) { let res = " " ; let mp = new Map ( ) ; mp . clear ( ) ; let rem = numr % denr ; while ( ( rem != 0 ) && ( ! mp . has ( rem ) ) ) { mp . set ( rem , res . length ) ; rem = rem * 10 ; let res_part = Math . floor ( rem / denr ) ; res += res_part . toString ( ) ; rem = rem % denr ; } if ( rem == 0 ) return " " ; else if ( mp . has ( rem ) ) return res . substr ( mp . get ( rem ) ) ; return " " ; }
function find ( n , k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; }
function minSteps ( arr , n , k ) { let i , cnt = 0 ; let flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
function waysOfDecoding ( s ) { let dp = new Array ( s . length + 1 ) ; for ( let i = 0 ; i < s . length + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' ' ? 9 : s [ 0 ] == ' ' ? 0 : 1 ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != ' ' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' && s [ i ] <= ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= ' ' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ s . length ] ; }
function lengtang ( r1 , r2 , d ) { document . write ( " " + " " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) . toFixed ( 5 ) ) ; }
function majorityNumber ( arr , n ) { let ans = - 1 ; let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) } else { freq . set ( arr [ i ] , 1 ) } if ( freq . get ( arr [ i ] ) > n / 2 ) ans = arr [ i ] ; } return ans ; }
function minCost ( cost , n ) { var totalCost = 0 ; var boardingBus = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
function countCubes ( a , b ) { return ( Math . floor ( b ** ( 1. / 3. ) ) - Math . ceil ( a ** ( 1. / 3. ) ) + 1 ) }
function largestSubStr ( s ) { while ( s . length && s [ s . length - 1 ] == ' ' ) s = s . substring ( 0 , s . length - 1 ) ; ; if ( s . length == 0 ) return " " ; else return s ; }
function maxSum ( mat , n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let maxSum = Number . MIN_VALUE , max ; for ( let j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { max = Number . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( let j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
function areElementsContiguous ( arr , n ) { let max = Number . MIN_VALUE ; let min = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } let m = max - min + 1 ; if ( m > n ) return false ; let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( let i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
function getSum ( arr , p ) { return arr . length ; }
function fun ( marks , n ) { let dp = new Array ( n ) ; let temp ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
function findMinValue ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( parseInt ( sum / n ) + 1 ) ; }
function count ( a , n ) { let countElements = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let flag = true ; for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; }
function countDigit ( n ) { return Math . floor ( Math . log10 ( n ) + 1 ) ; }
function line ( x0 , y0 ) { var c = parseInt ( 2 * y0 * x0 ) ; document . write ( y0 + " " + " " + x0 + " " + c ) ; }
function find_angle ( x , y , z ) { var volume = x * x * y ; var ans = 0 ; if ( z < volume / 2 ) { var d = ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = Math . atan ( d ) ; } else { z = volume - z ; var d = ( 2 * z ) / ( x * x * x ) ; ans = Math . atan ( d ) ; } ans = ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }
function findX ( A , B ) { let j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
function asciiToSentence ( str , len ) { var num = 0 ; for ( var i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - ' ' ) ; if ( num >= 32 && num <= 122 ) { var ch = String . fromCharCode ( num ) ; document . write ( ch ) ; num = 0 ; } } }
function countWords ( str ) { let count = 1 ; for ( let i = 1 ; i < str . length - 1 ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) count ++ ; } return count ; }
function modifiedBinaryPattern ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) document . write ( 1 ) ; else document . write ( 0 ) ; } document . write ( " " ) ; } }
function isPossible ( x , y ) { if ( ( x - y ) == 1 ) return false ; return true ; }
function maxSumArray ( arr , n ) { var sum = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) } var minimum = 1000000000 ; mp . forEach ( ( value , key ) => { minimum = Math . min ( minimum , value * key ) ; } ) ; return ( sum - minimum ) ; }
function minRemove ( arr , n ) { let LIS = new Array ( n ) . fill ( 0 ) ; let len = 0 ; for ( let i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }
function print_product ( a , b , c , d ) { let prod1 = a * c ; let prod2 = b * d ; let prod3 = ( a + b ) * ( c + d ) ; let real = prod1 - prod2 ; let imag = prod3 - ( prod1 + prod2 ) ; document . write ( real + " " + imag + " " ) ; }
function numSeq ( n ) { return Math . floor ( ( Math . pow ( 3 , n ) + 3 * Math . pow ( - 1 , n ) ) / 4 ) ; }
function getCount ( a , b , c ) { let count = 0 ; for ( let i = 1 ; i <= 81 ; i ++ ) { let cr = b * Math . pow ( i , a ) + c ; let tmp = cr ; let sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp = Math . floor ( tmp / 10 ) ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
function pairs_count ( arr , n , sum ) { let ans = 0 ; arr . sort ( ) ; let i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { let x = arr [ i ] , xx = i ; while ( i < j && arr [ i ] == x ) i ++ ; let y = arr [ j ] , yy = j ; while ( j >= i && arr [ j ] == y ) j -- ; if ( x == y ) { let temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
function DecakismyriagonNum ( N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
function insertAfter ( prev_node , new_data ) { if ( prev_node == null ) { document . write ( " " ) ; return ; } var new_node = new Node ( new_data ) ; new_node . next = prev_node . next ; prev_node . next = new_node ; }
function judgeSquareSum ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) { var count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n = parseInt ( n / i ) ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
function LeftRightNode ( preorder , n ) { var min = 1000000000 , max = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { if ( min > preorder [ i ] ) min = preorder [ i ] ; if ( max < preorder [ i ] ) max = preorder [ i ] ; } document . write ( " " + min + " " ) ; document . write ( " " + max ) ; }
function sumOfAP ( a , d , n ) { let sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
function Substring ( s ) { var ans = 1 , temp = 1 ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
function RightRotate ( a , n , k ) { k = k % n ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < k ) { document . write ( a [ n + i - k ] + " " ) ; } else { document . write ( ( a [ i - k ] ) + " " ) ; } } document . write ( " " ) ; }
function squareSide ( a ) { if ( a < 0 ) return - 1 ; var x = ( 0.423 * a ) ; return x ; }
function solve ( s1 , s2 ) { let flag1 = 0 , flag2 = 0 ; if ( s1 . length != s2 . length ) return false ; let l = s1 . length ; for ( let i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == ' ' ) flag1 = 1 ; if ( s2 [ i ] == ' ' ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
function getPosition ( N , M ) { if ( M > parseInt ( N / 2 ) ) { return ( M - parseInt ( N / 2 ) ) ; } return ( M + parseInt ( N / 2 ) ) ; }
function distributeN ( A , B , C , n ) { let max1 = Math . max ( A , B ) ; let max2 = Math . max ( B , C ) ; let maximum = Math . max ( max1 , max2 ) ; let sum = A + B + C ; let p = ( 3 * maximum ) - sum ; let diff = n - p ; if ( diff < 0 diff % 3 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findSum ( N ) { var sum = ( N ) * ( N + 1 ) / 2 ; var r = ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; var expSum = ( Math . pow ( 2 , r ) ) - 1 ; document . write ( sum - expSum ) ; }
function prletMissingElements ( arr , N ) { let diff = arr [ 0 ] - 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { document . write ( ( i + diff ) + " " ) ; diff ++ ; } } } }
function maxsubStringLength ( S , N ) { let arr = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; let maxLen = 0 ; let curr_sum = 0 ; let hash = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = Math . max ( maxLen , i + 1 ) ; if ( hash . has ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ; else hash . set ( curr_sum , i ) ; } return maxLen ; }
function countSubString ( S , C ) { var count = 0 ; var conCount = 0 ; for ( var i = 0 ; i < S . length ; i ++ ) { var ch = S [ i ] ; if ( ch === C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; document . write ( count ) ; }
function exponential ( n , x ) { var sum = 1 ; for ( i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
function findNature ( a , b , n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
function count_square ( n ) { let count = 0 ; for ( let i = 1 ; i <= n ; i = i + 2 ) { let k = n - i + 1 ; count += ( k * k ) ; } return count ; }
function check ( a , b , Na , Nb , k , m ) { if ( Na < k Nb < m ) return " " ; a . sort ( ) ; b . sort ( ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return " " ; } return " " ; }
function completeSequence ( s ) { let n = s . length ; let open = 0 , close = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) open ++ ; else close ++ ; if ( close > open ) { document . write ( " " ) ; return ; } } document . write ( s ) ; for ( let i = 0 ; i < open - close ; i ++ ) document . write ( " " ) ; }
function maximumArea ( l , b , x , y ) { var left = x * b ; var right = ( l - x - 1 ) * b ; var above = l * y ; var below = ( b - y - 1 ) * l ; document . write ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }
function printNum ( L , R ) { for ( let i = L ; i <= R ; i ++ ) { let temp = i ; let c = 10 ; let flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) document . write ( i + " " ) ; } }
function averageRuns ( runs , matches , notout ) { let out1 ; out1 = matches - notout ; if ( out1 == 0 ) return - 1 ; let avg = parseInt ( ( runs ) / out1 , 10 ) ; return avg ; }
function multiplyBySevenByEight ( n ) { return ( n - ( n >> 3 ) ) ; }
function maxSelectionCount ( a , n ) { var res = 0 ; a . sort ( ) ; var select = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
function calculateSum ( n ) { return ( Math . pow ( 2 , n + 1 ) + n - 2 ) ; }
function minParentheses ( p ) { var bal = 0 ; var ans = 0 ; for ( var i = 0 ; i < p . length ; ++ i ) { bal += p [ i ] == ' ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
function minSwaps ( N , M , A , B ) { let count01 = 0 ; let count10 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return - 1 ; }
function findTrailingZeros ( n ) { let count = 0 ; for ( let i = 5 ; Math . floor ( n / i ) >= 1 ; i *= 5 ) count += Math . floor ( n / i ) ; return count ; }
function countNum ( arr , n ) { let count = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
function printModulus ( X , Y ) { var d = Math . abs ( X - Y ) ; var i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { document . write ( i + " " ) ; if ( d / i != i ) document . write ( parseInt ( d / i ) + " " ) ; } i ++ ; } }
function SubseqWidths ( A , n ) { A . sort ( ( a , b ) => a - b ) var pow2 = Array ( n ) . fill ( 0 ) ; pow2 [ 0 ] = 1 ; for ( var i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; var ans = 0 ; for ( var i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }
function find_Numb_ways ( n ) { var odd_indices = n / 2 ; var even_indices = ( n / 2 ) + ( n % 2 ) ; var arr_odd = Math . pow ( 4 , odd_indices ) ; var arr_even = Math . pow ( 5 , even_indices ) ; return arr_odd * arr_even ; }
function balancedTernary ( n ) { var output = " " ; while ( n > 0 ) { var rem = n % 3 ; n = parseInt ( n / 3 ) ; if ( rem == 2 ) { rem = - 1 ; n ++ ; } output = ( rem == 0 ? ' ' : ( rem == 1 ) ? ' ' : ' ' ) + output ; } return output ; }
function MinOfCubedDP ( k ) { let DP = new Array ( k + 1 ) ; DP . fill ( 0 ) ; let j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= k ; i ++ ) { DP [ i ] = Number . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
function Mixture ( X , Y , Z ) { var result = 0.0 , result1 = 0.0 ; result1 = ( ( X - Y ) / X ) ; result = Math . pow ( result1 , Z ) ; result = result * X ; return result ; }
function cntWays ( str , n ) { var x = n + 1 ; var ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
function SumofInverseDivisors ( N , Sum ) { let ans = ( Sum ) * 1.0 / ( N ) ; return ans ; }
function vectorMagnitude ( x , y , z ) { var sum = x * x + y * y + z * z ; return Math . sqrt ( sum ) ; }
function countSubSeq ( str , len ) { var ans = 0 ; var mul = 1 ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) ans += mul ; mul *= 2 ; } return ans ; }
function isPentadecagon ( N ) { var n = ( 11 + Math . sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - parseInt ( n ) ) == 0 ; } var N = 15 ; if ( isPentadecagon ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isSubSeqDivisible ( str ) { let i , j , k , l = str . length ; let arr = [ ] ; for ( i = 0 ; i < l ; i ++ ) arr [ i ] = str [ i ] - ' ' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
function EqualNumber ( A , B ) { return ( A ^ B ) ; }
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( new_num == 0 ) return " " ; return " " ; }
function findUnique ( a , n , k ) { let sizeof_let = 4 ; let LET_SIZE = 8 * sizeof_let ; let count = Array . from ( { length : LET_SIZE } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; let res = 0 ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
function Maxcost ( s , cost ) { let maxcost = 0 ; let i = 0 ; while ( i < s . length - 1 ) { if ( s [ i ] == s [ i + 1 ] ) { if ( cost [ i ] > cost [ i + 1 ] ) maxcost += cost [ i ] ; else { maxcost += cost [ i + 1 ] ; cost [ i + 1 ] = cost [ i ] ; } } i ++ ; } return maxcost ; }
function find ( N , sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } let s = 0 ; for ( let i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
function GenerateArray ( N , X ) { let prev_xor = X ; for ( let i = 1 ; i <= N ; i ++ ) { document . write ( ( i ^ prev_xor ) ) ; if ( i != N ) { document . write ( " " ) ; } prev_xor = i ; } }
function MinOperation ( a , b , n ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
function LCIS ( arr1 , n , arr2 , m ) { let table = [ ] ; for ( let j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let current = 0 ; for ( let j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } let result = 0 ; for ( let i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
function distinctCount ( arr , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) s . add ( Math . abs ( arr [ i ] ) ) ; return s . size ; }
function nthTerm ( N ) { let nth = 0 , first_term = 4 ; let pi = 1 , po = 1 ; let n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
function countWays ( n ) { if ( n <= 2 ) document . write ( " " ) ; else { var ans = ( n - 1 ) * ( n - 2 ) / 2 ; document . write ( ans ) ; } }
function findMinLength ( arr , N ) { let front = 0 , back = N - 1 ; while ( front < back ) { let x = arr [ front ] ; if ( arr [ front ] != arr [ back ] ) break ; while ( arr [ front ] == x && front <= back ) front ++ ; while ( arr [ back ] == x && front <= back ) back -- ; } document . write ( back - front + 1 ) ; document . write ( " " ) ; }
function TetracontaoctagonalNum ( n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
function sumBitDifferences ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
function distance ( r , R ) { let d = Math . sqrt ( Math . pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
function findMinimumTime ( tasks , K ) { var map = new Map ( ) ; var curr_time = 0 ; tasks . split ( ' ' ) . forEach ( c => { if ( map . has ( c ) ) { if ( curr_time - map . get ( c ) <= K ) { curr_time += K - ( curr_time - map . get ( c ) ) + 1 ; } } map . set ( c , curr_time ) ; curr_time ++ ; } ) ; document . write ( curr_time ) ; }
function centered_heptagonal_num ( n ) { return parseInt ( ( 7 * n * n - 7 * n + 2 ) / 2 ) ; }
function smallestNumber ( N ) { document . write ( N * parseInt ( Math . ceil ( Math . pow ( 2 , ( N - 1 ) ) / N ) ) ) ; }
function findRepeatFirstN2 ( s ) { let p = - 1 , i , j ; for ( i = 0 ; i < s . length ; i ++ ) { for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
function maxSubarrayXOR ( arr , n ) { let ans = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = 0 ; for ( let j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
function isStar ( N ) { let n = ( 6 + Math . sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - parseInt ( n ) ) == 0 ; } let i = 13 ; if ( isStar ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function solve ( a , n ) { let mx = 0 ; for ( let j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = Math . max ( mx , a [ j - 1 ] ) ; } return true ; }
function longestSubstring ( s ) { var cnt = 1 , maxi = 1 ; var n = s . length ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
function Colour_Combination ( s ) { let temp = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else temp = ' ' ; } } return temp ; }
function totalTriangles ( h , v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; var total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
function lucas ( n ) { let a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
function checkJumbled ( num ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; while ( num != 0 ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; let digit1 = num % 10 ; let digit2 = parseInt ( num / 10 , 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = parseInt ( num / 10 , 10 ) ; } return true ; }
function createArray ( n , s ) { if ( 2 * n <= s ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { document . write ( 2 + " " ) ; s -= 2 ; } document . write ( s + " " ) ; document . write ( 1 ) ; } else document . write ( " " ) ; }
function solve ( arr , n ) { var countzeroes = 0 ; var countones = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( Math . abs ( countzeroes - countones ) == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function sumoflength ( arr , n ) { let s = new Set ( ) ; let j = 0 , ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . has ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += Math . floor ( ( ( j - i ) * ( j - i + 1 ) ) / 2 ) ; s . delete ( arr [ i ] ) ; } return ans ; }
function prodSquare ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) for ( j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
function findCountOfPairs ( a , b , n ) { let ans = 0 ; for ( let i = 1 ; i <= a ; i ++ ) { ans += parseInt ( b / n , 10 ) ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
function isOsiris ( n ) { let a = n % 10 ; let b = parseInt ( ( n / 10 ) % 10 ) ; let c = parseInt ( n / 100 ) ; let digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
function checkEVENodd ( arr , n , l , r ) { if ( arr [ r ] == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function sumSquare ( n ) { let s = new Map ( ) ; for ( let i = 0 ; i * i <= n ; ++ i ) { s . set ( i * i , 1 ) ; if ( s . has ( n - i * i ) ) { document . write ( Math . sqrt ( n - i * i ) + " " + i + " " ) ; return true ; } } return false ; }
function isCentereddecagonal ( N ) { let n = ( 5 + Math . sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 11 ; if ( isCentereddecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isConversionPossible ( s1 , s2 , x ) { let diff = 0 , n ; n = s1 . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( ( s2 [ i ] . charCodeAt ( 0 ) - s1 [ i ] . charCodeAt ( 0 ) ) + 26 ) % 26 ; if ( diff > x ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function isDefeat ( s1 , s2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else { return true ; } } return false ; }
function nearest ( n ) { var prevSquare = parseInt ( Math . sqrt ( n ) ) ; var nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; if ( ( n - prevSquare ) < ( nextSquare - n ) ) { ans = parseInt ( ( prevSquare - n ) ) ; } else ans = parseInt ( ( nextSquare - n ) ) ; return ans ; }
function printSorted ( a , b , c ) { let get_max = Math . max ( a , Math . max ( b , c ) ) ; let get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; let get_mid = ( a + b + c ) - ( get_max + get_min ) ; document . write ( get_min + " " + get_mid + " " + get_max ) ; }
function firstSetBit ( n ) { let x = n & ( n - 1 ) ; return ( n ^ x ) ; }
function dealnnoy ( n , m ) { var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( var i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( var i = 1 ; i <= m ; i ++ ) for ( var j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
function totalSubSets ( n , l , r ) { let zero = Math . floor ( r / 3 ) - Math . ceil ( l / 3 ) + 1 ; let one = Math . floor ( ( r - 1 ) / 3 ) - Math . ceil ( ( l - 1 ) / 3 ) + 1 ; let two = Math . floor ( ( r - 2 ) / 3 ) - Math . ceil ( ( l - 2 ) / 3 ) + 1 ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( let i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
function minimumflip ( mat , n ) { let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
function findLast ( mat ) { let m = mat . length ; let n = mat [ 0 ] . length ; let rows = new Set ( ) ; let cols = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . add ( i ) ; cols . add ( j ) ; } } } let avRows = m - rows . size ; let avCols = n - cols . size ; let choices = Math . min ( avRows , avCols ) ; if ( choices & 1 ) document . write ( " " ) else document . write ( " " ) }
function count ( N , X , subStr , index , n ) { if ( index == n ) return 0 ; let a = subStr + N [ index ] ; let b = 0 ; if ( parseInt ( a ) % X == 0 ) b = 1 ; let m1 = count ( N , X , a , index + 1 , n ) ; let m2 = b + count ( N , X , " " , index + 1 , n ) ; return Math . max ( m1 , m2 ) ; }
function evenFib ( n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
function permutationCoeff ( n , k ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return parseInt ( fact [ n ] / fact [ n - k ] , 10 ) ; }
function Centered_Triangular_num ( n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
function findMedian ( a , n ) { a . sort ( ) ; if ( n % 2 != 0 ) return a [ parseInt ( n / 2 ) ] ; return ( a [ parseInt ( ( n - 1 ) / 2 ) ] + a [ parseInt ( n / 2 ) ] ) / 2.0 ; }
function count ( head , key ) { if ( head == null ) return 0 ; if ( head . data == key ) return 1 + count ( head . next , key ) ; return count ( head . next , key ) ; }
function findRadiusOfcircumcircle ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var radius = Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
function longestSubArray ( arr , n ) { var isZeroPresent = false ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
function checkSolution ( a , b , c ) { if ( a == c ) document . write ( " " ) ; else document . write ( " " ) ; }
function mulsum ( arr , n , N ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } document . write ( sum ) ; }
function divisibleBy36 ( num ) { let l = num . length ; if ( l == 0 ) return " " ; if ( l == 1 && num [ 0 ] != ' ' ) return " " ; let two_digit_num = ( num [ l - 2 ] - ' ' ) * 10 + ( num [ l - 1 ] - ' ' ) ; if ( two_digit_num % 4 != 0 ) return " " ; let sum = 0 ; for ( let i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - ' ' ) ; if ( sum % 9 != 0 ) return " " ; return " " ; }
function isRepdigit ( num , b ) { let prev = - 1 ; while ( num != 0 ) { let digit = num % b ; num = parseInt ( num / b ) ; if ( prev != - 1 && digit != prev ) return false ; prev = digit ; } return true ; } let num = 2000 , base1 = 7 ; if ( isRepdigit ( num , base1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function CountTriplets ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let first = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
function findAns ( mat , x , y , n , m ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += Math . abs ( x - i ) + Math . abs ( y - j ) ; } } } return ans ; }
function maxRepeating ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; let max = arr [ 0 ] , result = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
function FindMaxS ( X , Y , Z , n , A , B , C ) { if ( X < 0 Y < 0 Z < 0 ) return Number . MIN_VALUE ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } let ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; let ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; let co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; let no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; let maximum = Math . max ( ch , Math . max ( ca , Math . max ( co , no ) ) ) ; dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; return dp [ n ] [ X ] [ Y ] [ Z ] ; } let X = 1 ; let Y = 1 ; let Z = 1 ; let A = [ 10 , 0 , 5 ] ; let B = [ 5 , 10 , 0 ] ; let C = [ 0 , 5 , 10 ] ; let n = B . length ; for ( let i = 0 ; i < 50 ; i ++ ) { dp [ i ] = new Array ( 50 ) ; for ( let j = 0 ; j < 50 ; j ++ ) { dp [ i ] [ j ] = new Array ( 50 ) ; for ( let k = 0 ; k < 50 ; k ++ ) { dp [ i ] [ j ] [ k ] = new Array ( 50 ) ; for ( let l = 0 ; l < 50 ; l ++ ) { dp [ i ] [ j ] [ k ] [ l ] = - 1 ; } } } }
function count ( n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; let table = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; let i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
function FindMinimumCost ( ind , a , n , k , dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { var ans = Number . MAX_VALUE ; for ( var i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
function MatrixChainOrder ( p , i , j ) { if ( i == j ) return 0 ; var min = Number . MAX_VALUE ; var k = 0 ; for ( k = i ; k < j ; k ++ ) { var count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
function closestNumber ( n , m ) { let q = parseInt ( n / m ) ; let n1 = m * q ; let n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; }
function maxTripletSum ( arr , n ) { let sum = - 1000000 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
function adjacentSet ( n ) { let x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }
function maxGcd ( a , b ) { document . write ( Math . abs ( a - b ) ) ; }
function towerOfHanoi ( n , from_rod , to_rod , aux_rod ) { if ( n == 1 ) { document . write ( " " + from_rod + " " + to_rod + " " ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; document . write ( " " + n + " " + from_rod + " " + to_rod + " " ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; }
function sortExceptUandL ( a , l , u , n ) { let b = [ ] ; for ( let i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; b . sort ( ) ; for ( let i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
function maxOR ( arr , n ) { let max_value = Math . max ( ... arr ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; }
function inProportion ( arr ) { var n = 4 ; arr . sort ( ) ; var extremes = arr [ 0 ] * arr [ 3 ] ; var means = arr [ 1 ] * arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
function findWaysToPair ( p ) { var dp = Array ( p + 1 ) ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( var i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }
function decdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.902 * a ; return d ; }
function doMatch ( A , B ) { for ( i = 0 ; i < A . length ; i ++ ) { if ( A . charAt ( i ) != ' ' && B . charAt ( i ) != ' ' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }
function countTriplets ( N ) { let cnt = 0 ; for ( let A = 1 ; A <= N ; ++ A ) { for ( let B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
function findMinSum ( mat , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var res = 0 ; for ( var j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }
function generatepermutation ( N ) { var answer = [ ] ; answer . push ( N ) ; console . log ( answer ) ; for ( var i = 1 ; i < N ; i ++ ) { console . log ( answer ) ; answer . push ( i ) ; } for ( var i in answer ) document . write ( answer [ i ] + " " ) ; }
function minimumCost ( cost , n ) { let dp1 = 0 , dp2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
function countSubstrs ( str , i , j , n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; let res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
function lastDigit2PowerN ( n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
function IsPrime ( i ) { if ( i % 2 == 0 && i != 2 ) return false ; else { for ( j = 3 ; j <= Math . sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) return false ; } return true ; } } var c = 0 ; var N = 72 ; for ( i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( IsPrime ( i ) ) { if ( N % i == 0 ) { c ++ ; if ( IsPrime ( N / i ) && i != ( N / i ) ) c ++ ; } } }
function MaximumPath ( Mat ) { let result = 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N + 2 ) ; for ( let j = 0 ; j < N + 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( let i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
function allBitsSetInTheGivenRange ( n , l , r ) { let num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; let new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
function findTemperature ( x , y , s ) { let Day1 , Day2 ; let diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; document . write ( " " + Day1 + " " ) ; document . write ( " " + Day2 + " " ) ; }
function numberOfTriangles ( n ) { var ans = 2 * ( Math . pow ( 3 , n ) ) - 1 ; return ans ; }
function areaSquare ( side ) { let area = side * side ; return area ; }
function superSeq ( X , Y , m , n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
function findNumber ( N ) { let ans = [ 1 , 2 , 4 , 8 , 7 , 5 ] ; return ans [ N % 6 ] ; }
function shuffle ( N , key ) { let NO_OF_BITS = N ; let reverse_num = 0 , temp ; for ( let i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } document . write ( reverse_num ) ; }
function FindSub ( str , res , i ) { if ( i === str . length ) { if ( res . length > 0 ) { document . write ( res + " " ) ; } return ; } var ch = str [ i ] ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + ch . charCodeAt ( 0 ) , i + 1 ) ; }
function findAngle ( M1 , M2 ) { var angle = Math . abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; var ret = Math . atan ( angle ) ; var val = ( ret * 180 ) / PI ; document . write ( val . toFixed ( 4 ) ) ; }
function binary_searched_find_x ( k ) { var l = 0 ; var r = k ; var ans = 0 ; while ( l <= r ) { var mid = parseInt ( l + ( r - l ) / 2 ) ; if ( Math . pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
function minPolets ( n , m ) { let ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = Math . floor ( ( n * m ) / 2 ) + 1 ; } else { ans = Math . floor ( ( n * m ) / 2 ) ; } return ans ; }
function sentencePalindrome ( str ) { let l = 0 ; let h = str . length - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { let getAtl = str [ l ] ; let getAth = str [ h ] ; if ( ! ( getAtl >= ' ' && getAtl <= ' ' ) ) l ++ ; else if ( ! ( getAth >= ' ' && getAth <= ' ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; }
function numberOfDays ( a , b , n ) { var Days = b * ( n + a ) / ( a + b ) ; return Days ; }
function findAnswer ( X , N ) { return ( N - 1 ) * 9 + X ; }
function findoptimal ( N ) { if ( N <= 6 ) return N ; let screen = [ ] ; let b ; let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
function maxbalancedprefix ( str , n ) { var sum = 0 ; var maxi = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
function productOfSingelDgt ( n ) { if ( n >= 0 && n <= 9 ) return true ; var prime = [ 2 , 3 , 5 , 7 ] ; for ( i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
function minimumStepReqArr ( arr , N ) { let cntStep = 0 ; N += 1 ; for ( let i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }
function twoWaySort ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
function minimumIncreasingSubsequences ( arr , N ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 ; let i = 0 ; while ( i < N ) { let x = arr [ i ] ; let freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = Math . max ( count , freqX ) ; } document . write ( count ) ; }
function countSquares ( r , c , m ) { let squares = 0 ; for ( let i = 1 ; i <= 8 ; i ++ ) { for ( let j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
function LCSubStr ( X , Y , m , n ) { var LCStuff = Array ( m + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var result = 0 ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }
function increment ( i ) { i = - ( ~ i ) ; return i ; }
function squareArea ( a ) { if ( a < 0 ) return - 1 ; var area = ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; }
function findMin ( arr , N , k ) { let pairs = 0 ; for ( let i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return - 1 ; else return 2 * k + N - 1 ; }
function nearestPerfectSquare ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let sr = parseInt ( Math . sqrt ( arr [ i ] ) ) ; let a = sr * sr ; let b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) document . write ( a + " " ) ; else document . write ( b + " " ) ; } }
function printNthElement ( n ) { var arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( var i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
function weightedMean ( X , W , n ) { let sum = 0 , numWeight = 0 ; for ( let i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( numWeight ) / sum ; }
function findSum ( n ) { let sum = 0 ; for ( let x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
function smallestNum ( n ) { res = 1 ; for ( var i = 2 ; ; i *= 2 ) { var length = parseInt ( Math . log ( i ) / Math . log ( 10 ) ) + 1 ; if ( length == n ) return parseInt ( Math . log ( i ) / Math . log ( 2 ) ) ; } }
function smallestDivisor ( n ) { if ( n % 2 == 0 ) return 2 ; for ( var i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
function findOddPair ( A , N ) { var i , j ; var oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
function maximizeProduct ( N ) { let MSB = Math . log2 ( N ) ; let X = 1 << MSB ; let Y = N - ( 1 << MSB ) ; for ( let i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } document . write ( X + " " + Y ) ; }
function kthNonDivisible ( N , K ) { return K + parseInt ( Math . floor ( ( K - 1 ) / ( N - 1 ) ) , 10 ) ; }
function Max_Sum ( n ) { return parseInt ( ( n * ( n - 1 ) ) / 2 ) ; }
function precompute ( ) { var fact = 1 ; for ( var i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m [ fact ] = i ; } }
function maxPointCount ( arr , k , size ) { let curr_points = 0 ; let max_points = 0 ; for ( let i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; let j = size - 1 ; for ( let i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = Math . max ( curr_points , max_points ) ; j -- ; } return max_points ; }
function CountSubarray ( arr , n , k ) { var temp = k , count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
function findLCS ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) != 0 ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } return mp . size ; }
function findDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 , max_count = 0 , min_count = n ; for ( let i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
function findMaximumNum ( str , n , k ) { for ( var i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str [ i ] !== " " ) { str [ i ] = " " ; k -- ; } } return str . join ( " " ) ; }
function FindKthChar ( str , K , X ) { var ans = " " ; var sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { var digit = parseInt ( str [ i ] ) ; var range = parseInt ( Math . pow ( digit , X ) ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; }
function printNumberWithDR ( k , d ) { if ( d == 0 && k != 1 ) document . write ( " " ) ; else { document . write ( d ) ; k -- ; while ( k -- > 0 ) document . write ( " " ) ; } }
function gonNum257 ( n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
function isTidy ( num ) { let prev = 10 ; while ( num != 0 ) { let rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
function minimumDiff ( arr , N ) { let res = arr [ 0 ] , sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; let min_diff = sum ; for ( let i = 0 ; i < N ; i ++ ) { if ( Math . abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = Math . abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } document . write ( res ) ; }
function sum_series ( n ) { let nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
function largestNum ( n ) { let num = 0 ; for ( let i = 0 ; i <= 32 ; i ++ ) { let x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
function gcdMax ( a , b , n , N ) { let cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let first = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let second = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; let x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; document . write ( first [ x ] + " " + second [ x ] ) ; }
function canMakeEqual ( S ) { var N = S . length ; var weightOfString = 0 ; for ( var i = 0 ; i < N ; i ++ ) { weightOfString += S . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ; } if ( weightOfString % N == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function Max_Sum ( arr1 , arr2 , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
function countNumbers ( x , n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
function findFourElements ( A , n , X ) { for ( let i = 0 ; i < n - 3 ; i ++ ) { for ( let j = i + 1 ; j < n - 2 ; j ++ ) { for ( let k = j + 1 ; k < n - 1 ; k ++ ) { for ( let l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) document . write ( A [ i ] + " " + A [ j ] + " " + A [ k ] + " " + A [ l ] ) ; } } } }
function findK ( A , i , j , n , m , k ) { if ( n < 1 m < 1 ) return - 1 ; if ( k <= m ) return A [ i + 0 ] [ j + k - 1 ] ; if ( k <= ( m + n - 1 ) ) return A [ i + ( k - m ) ] [ j + m - 1 ] ; if ( k <= ( m + n - 1 + m - 1 ) ) return A [ i + n - 1 ] [ j + m - 1 - ( k - ( m + n - 1 ) ) ] ; if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) return A [ i + n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ j + 0 ] ; return findK ( A , i + 1 , j + 1 , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) ; }
function maximumSumPermutation ( arr ) { var N = arr . length ; arr . sort ( ( a , b ) => a - b ) ; var temp = arr [ 0 ] ; arr [ 0 ] = arr [ N - 1 ] ; arr [ N - 1 ] = temp ; document . write ( arr ) ; }
function minAbsDiff ( n ) { let mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
function countMultiples ( n ) { return Math . floor ( n / 3 + n / 7 - n / 21 ) ; }
function minOps ( arr , n , k ) { var max = arr [ 0 ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
function KnapSack ( val , wt , n , W ) { let dp = new Array ( W + 1 ) ; for ( let i = 0 ; i < W + 1 ; i ++ ) { dp [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
function LIS ( a , n ) { let dp = new Array ( ) ; let d = new Array ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
function findSide ( a , B , C ) { var A = 180 - C - B ; var radA = Math . PI * ( A / 180 ) ; var radB = Math . PI * ( B / 180 ) ; var radC = Math . PI * ( C / 180 ) ; var b = a / Math . sin ( radA ) * Math . sin ( radB ) ; var c = a / Math . sin ( radA ) * Math . sin ( radC ) ; document . write ( b + " " ) ; document . write ( c ) ; }
function first_digit ( x , y ) { var length = parseInt ( Math . log ( x ) / Math . log ( y ) ) + 1 ; var first_digit = parseInt ( x / Math . pow ( y , length - 1 ) ) ; document . write ( first_digit ) ; }
function maxOperations ( X , Y ) { if ( X > Y ) return - 1 ; let diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
function findPolet ( n , h ) { for ( let i = 1 ; i < n ; i ++ ) document . write ( Math . sqrt ( i / ( n * 1.0 ) ) * h + " " ) ; }
function minValue ( A , B , n ) { A . sort ( ) ; B . sort ( ) ; let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
function find_number ( N , K ) { var r ; if ( N % 100 == 0 ) { N += 1 ; r = N . toString ( ) ; } else { r = N . toString ( ) ; } for ( var i = 1 ; i <= K ; i ++ ) r += " " ; return r ; }
function computeXOR ( n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
function seriesFunc ( n ) { let sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
function countSubStr ( str , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == ' ' ) res ++ ; } } } return res ; }
function possibleToReach ( a , b ) { let c = Math . cbrt ( a * b ) ; let re1 = a / c ; let re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
function findSubsequenceCount ( S , T ) { let m = T . length ; let n = S . length ; if ( m > n ) return 0 ; let mat = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { mat [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { mat [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( let j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
function minNum ( n ) { if ( n < 3 ) document . write ( - 1 ) ; else document . write ( ( 210 * ( parseInt ( Math . pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ) ; }
function countSubsequences ( s ) { let aCount = 0 ; let bCount = 0 ; let cCount = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
function SubArrayProdct ( arr , n ) { let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) result *= Math . pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; return result ; }
function maxSumPairWithDifferenceLessThanK ( arr , N , k ) { var maxSum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
function countTotalDistinct ( str ) { let cnt = 0 ; let items = new Set ( ) ; for ( let i = 0 ; i < str . length ; ++ i ) { let temp = " " ; let ans = new Set ( ) ; for ( let j = i ; j < str . length ; ++ j ) { temp = temp + str [ j ] ; ans . add ( str [ j ] ) ; if ( ! items . has ( temp ) ) { items . add ( temp ) ; cnt += ans . size ; } } } return cnt ; }
function canBreakN ( n ) { for ( let i = 2 ; ; i ++ ) { let m = parseInt ( i * ( i + 1 ) / 2 , 10 ) ; if ( m > n ) break ; let k = n - m ; if ( k % i != 0 ) continue ; document . write ( i ) ; return ; } document . write ( " " ) ; }
function countNegative ( M , n , m ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
function countPairs ( X , Y , m , n ) { let suffix = Array . from ( { length : 1005 } , ( _ , i ) => 0 ) ; let total_pairs = 0 ; for ( let i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( let i = 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( let i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return total_pairs ; }
function solve ( s ) { let area = ( 1.732 * Math . pow ( s , 2 ) ) / 8 ; return area ; }
function print ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j ) document . write ( a [ i ] + " " + a [ j ] + " " ) ; } } }
function nth_group ( n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; }
function minCostToMakeElementEqual ( a , n ) { let y ; if ( n % 2 == 1 ) y = a [ Math . trunc ( n / 2 ) ] ; else y = Math . trunc ( ( a [ n / 2 ] + a [ ( n - 2 ) / 2 ] ) / 2 ) ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) s += Math . abs ( a [ i ] - y ) ; return s ; }
function isProduct ( arr , n , x ) { for ( var i = 0 ; i < n - 1 ; i ++ ) for ( var j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; }
function properDivisorSum ( n ) { var sum = 0 ; for ( var i = 1 ; i <= n ; ++ i ) sum += parseInt ( n / i ) * i ; return sum - n * ( ( n + 1 ) / 2 ) ; }
function HexacontatetragonNum ( n ) { return ( 62 * n * n - 60 * n ) / 2 ; }
function Numberofways ( n ) { var count = 0 ; for ( var a = 1 ; a < n ; a ++ ) { for ( var b = 1 ; b < n ; b ++ ) { var c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; }
function no_of_moves ( Matrix , x , y ) { let moves = 0 ; for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += Math . abs ( x - i ) ; moves += Math . abs ( y - j ) ; } } } document . write ( moves ) ; }
function findSteps ( n , m , a ) { var cur = 1 ; var steps = 0 ; for ( var i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
function solve ( low , high , T ) { while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
function count ( arr , low , high , x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , Math . floor ( ( low + high ) / 2 ) , x ) + count ( arr , 1 + Math . floor ( ( low + high ) / 2 ) , high , x ) ; }
function printOdds ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; let set_bit = res & ( ~ ( res - 1 ) ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( x + " " + y ) ; }
function correlationCoefficient ( X , Y , n ) { let sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; let squareSum_X = 0 , squareSum_Y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } let corr = ( n * sum_XY - sum_X * sum_Y ) / ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
function countPairs ( n ) { let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { let val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
function solve ( values , salary ) { var ret = 1 ; var amt = 0 ; values . sort ( ( a , b ) => a - b ) ; salary . sort ( ( a , b ) => a - b ) ; while ( salary . length ) { while ( values . length && values [ values . length - 1 ] >= salary [ salary . length - 1 ] ) { amt ++ ; values . pop ( ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . pop ( ) ; } return ret ; }
function string ( l , x , y ) { var p = 97 ; for ( var j = 0 ; j < l ; j ++ ) { var ans = String . fromCharCode ( p + ( j % y ) ) ; document . write ( ans ) ; } }
function numberOfWays ( n , k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= Math . pow ( 2 , k ) ) { let curr_val = Math . pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; }
function equation_ellipse ( x1 , y1 , a , b , c , e ) { var t = a * a + b * b ; var a1 = t - e * ( a * a ) ; var b1 = t - e * ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; var e1 = - 2 * e * a * b ; var f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( " " + " " ) ; document . write ( a1 + " " + b1 + " " + c1 + " " + d1 + " " + e1 + " " + f1 + " " ) ; }
function round ( n ) { let a = parseInt ( n / 10 , 10 ) * 10 ; let b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
function find_max ( i , sum , v , k ) { if ( i == v . length ) return 0 ; if ( dp [ i ] [ sum ] != - 1 ) return dp [ i ] [ sum ] ; let ans = 0 ; if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) ans = find_max ( i + 1 , sum , v , k ) ; if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) ans = Math . max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) ; return dp [ i ] [ sum ] = ans ; } let arr = [ 43 , 1 , 17 , 26 , 15 ] ; let k = 16 ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }
function getCount ( rows , columns , A ) { var res = 0 ; for ( var i = 0 ; i < rows ; i ++ ) { for ( var j = i + 1 ; j < rows ; j ++ ) { if ( A [ i ] [ 0 ] * A [ j ] [ 1 ] == A [ i ] [ 1 ] * A [ j ] [ 0 ] ) { res ++ ; } } } return res ; }
function SubMasks ( N ) { for ( let S = N ; S > 0 ; S = ( S - 1 ) & N ) { document . write ( S + " " ) ; } }
function countWays ( n ) { for ( let i = 1 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) for ( let k = j ; k < n ; k ++ ) for ( let l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
function sortArray ( A , N ) { let x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( let i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } document . write ( " " ) ; for ( let i = 0 ; i < N ; i ++ ) document . write ( A [ i ] + " " ) ; } else { document . write ( " " ) ; } }
function getModulo ( n , d ) { return ( n & ( d - 1 ) ) ; }
function largestNumber ( N ) { if ( N > 45 ) return - 1 ; let num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
function printFourSquares ( a ) { for ( let i = 0 ; i * i <= a ; i ++ ) { for ( let j = i ; j * j <= a ; j ++ ) { for ( let k = j ; k * k <= a ; k ++ ) { for ( let l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { document . write ( a + " " + i + " " + i + " " + j + " " + j + " " ) ; document . write ( k + " " + k + " " + l + " " + l + " " ) ; } } } } } }
function countBuildings ( arr , n ) { let count = 1 ; let curr_max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
function minimumSteps ( a , b , c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
function lastRemovedCharacter ( str ) { var n = str . length ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == " " ) { return " " - str [ n - 1 ] + " " ; } else return str [ n - 1 ] ; }
function updateString ( S , A , B ) { let l = A . length ; for ( let i = 0 ; i + l <= S . length ; i ++ ) { let curr = S . substring ( i , i + l ) ; if ( curr == A ) { let new_string = S . substring ( 0 , i ) + B + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { let new_string = S . substring ( 0 , i ) + A + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; }
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
function multiple ( a , b , x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) document . write ( " " ) ; else document . write ( " " ) ; } var mul = parseInt ( Math . pow ( a , b ) ) ; var ans = mul / x ; var ans1 = x * ans ; var ans2 = x * ( ans + 1 ) ; document . write ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
function minimumMEX ( arr , N , K ) { let s = new Set ( ) ; for ( let i = 1 ; i <= N + 1 ; i ++ ) s . add ( i ) ; for ( let i = 0 ; i < K ; i ++ ) s . delete ( arr [ i ] ) ; let entry = s . entries ( ) ; let mex = 1 ; for ( let i = K ; i < N ; i ++ ) { s . delete ( arr [ i ] ) ; s . add ( arr [ i - K ] ) ; let firstElem = entry . next ( ) . value mex = Math . min ( mex , 1 ) ; } document . write ( mex + " " ) ; }
function findSolutions ( N ) { let count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( ( i + parseInt ( N / i ) ) % 2 == 0 ) { count ++ ; } } } document . write ( 4 * count + " " ) ; }
function leastValue ( P , A , N , a ) { let ans = - 1 ; let tmp = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let t = ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
function turnOnK ( n , k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
function area_fun ( side ) { let area = side * side ; return area ; }
function checkPairs ( l , r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
function group_formed ( S ) { let count = 1 ; for ( let i = 0 ; i < S . length - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } document . write ( count ) ; }
function solve ( N ) { let ans = 0 ; while ( N != 0 ) { ans += N ; N = parseInt ( N / 2 , 10 ) ; } document . write ( ans ) ; }
function segregateElements ( arr , n ) { let temp = new Array ( n ) ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
function removeAll ( arr , n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) document . write ( " " ) ; else document . write ( " " ) ; }
function printPairs ( arr , n ) { let pairs = new Set ( ) ; let pair_exists = false ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) pairs . add ( arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) if ( pairs . has ( - arr [ i ] ) ) { document . write ( arr [ i ] + " " + - arr [ i ] + " " ) ; pair_exists = true ; } } if ( pair_exists == false ) document . write ( " " ) ; }
function lenghtOfLongestAP ( A , n ) { var dp = new Map ( ) ; var res = 2 ; for ( var i = 0 ; i < n ; ++ i ) { for ( var j = i + 1 ; j < n ; ++ j ) { var d = A [ j ] - A [ i ] ; if ( dp . has ( d ) ) { if ( dp . get ( d ) . has ( i ) ) { var tmp = dp . get ( d ) ; tmp . set ( j , dp . get ( d ) . get ( i ) + 1 ) ; } else { var tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp . set ( d , tmp ) ; } } else { var tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp . set ( d , tmp ) ; } res = Math . max ( res , dp . get ( d ) . get ( j ) ) ; } } return res ; }
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
function calculateWays ( arr1 , arr2 , N ) { let A = arr2 [ 0 ] , B = arr2 [ 1 ] ; let C = arr2 [ 2 ] , D = arr2 [ 3 ] ; let ans = 0 ; for ( let b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( let c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( let d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
function areaOfSquare ( S ) { let area = S * S ; return area ; }
function noOfYears ( t1 , n1 , t2 ) { var years = ( ( t2 - 1 ) * n1 / ( t1 - 1 ) ) ; return years ; }
function graphExists ( a , n ) { while ( 1 ) { a . sort ( ( a , b ) => b - a ) if ( a [ 0 ] == 0 ) return true ; var v = a [ 0 ] ; a . shift ( ) ; if ( v > a . length ) return false ; for ( var i = 0 ; i < v ; i ++ ) { a [ i ] -- ; if ( a [ i ] < 0 ) return false ; } } }
function solve ( s , k ) { var count = 0 , length = 0 , pos = 0 ; var m = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! m . has ( s [ i ] ) ) { m . set ( s [ i ] , 0 ) ; } m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; length ++ ; if ( length > k ) { if ( ! m . has ( s [ pos ] ) ) { m . set ( s [ pos ] , 0 ) ; } m . set ( s [ pos ] , m [ s [ pos ] ] - 1 ) ; pos += 1 ; length -- ; } if ( length == k && m . get ( s [ i ] ) == length ) count ++ ; } document . write ( count ) ; }
function findCnt ( arr , i , required_sum , n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
function isPossible ( x , y , k ) { var minMoves = Math . abs ( x ) + Math . abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
function printCountRec ( dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
function ceilDifference ( arr , n , x ) { var totalSum = 0 ; var perElementSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += parseInt ( Math . ceil ( ( arr [ i ] ) / ( x ) ) ) ; } var totalCeilSum = parseInt ( Math . ceil ( ( totalSum ) / ( x ) ) ) ; return Math . abs ( perElementSum - totalCeilSum ) ; }
function print ( str1 ) { let str = str1 . split ( " " ) ; document . write ( str [ 0 ] ) ; for ( let i = 1 ; i < str . length ; i ++ ) { if ( ( str [ i ] . charCodeAt ( 0 ) == str [ i - 1 ] . charCodeAt ( 0 ) + 1 ) || ( str [ i ] . charCodeAt ( 0 ) == str [ i - 1 ] . charCodeAt ( 0 ) - 1 ) ) { document . write ( str [ i ] ) ; } else { document . write ( " " + str [ i ] ) ; } } }
function findNumbers ( arr , n ) { sumN = ( n * ( n + 1 ) ) / 2 ; sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sum = 0 ; let sumSq = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; A = sum - sumN + B ; document . write ( " " + A , " " , B ) ; }
function minimumCost ( cost , n , x ) { let dp = [ ] ; dp [ 0 ] = cost [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , Math . min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } document . write ( dp [ n - 1 ] ) ; }
function numOfWays ( a , n , i , blue ) { if ( i == n ) return 1 ; let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && ! blue . has ( j ) ) { blue . add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . delete ( j ) ; } } return count ; }
function isAutomorphic ( N ) { let sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return - 1 ; N /= 10 ; sq /= 10 ; } return 1 ; }
function countSticks ( str , n ) { var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str [ i ] - ' ' ] ) ; } return cnt ; }
function maxOR ( arr , n ) { var max_value = Math . max . apply ( Math , arr ) ; var number_of_bits = parseInt ( ( ( Math . log ( max_value ) ) ) ) + 2 ; var complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; var c = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = Math . max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
function check ( n , m ) { if ( n == 2 m == 2 n % m == 0 ) { document . write ( " " + " " ) ; } else { document . write ( " " + " " ) ; } }
function fourthPowerSum ( n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
function getMinCost ( A , B , N ) { let mini = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
function findRadiusOfcircumcircle ( n , a ) { if ( n < 0 a < 0 ) return - 1 ; var radius = ( a / Math . sqrt ( 2 - ( 2 * Math . cos ( 360 / n ) ) ) ) ; return radius ; }
function getCount ( N , M ) { let total_count = 0 total_count += Math . floor ( N / 10 ) let x = Math . floor ( N / 10 ) * 10 if ( ( N - x ) >= M ) { total_count = total_count + 1 } return total_count }
function pairAndSum ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
function getDivisors ( min , n ) { var total = 0 ; for ( var i = min ; i < n ; ++ i ) { if ( n % i == 0 && n / i >= i ) { ++ total ; if ( n / i > i ) total += getDivisors ( i , n / i ) ; } } return total ; }
function findNum ( n , k ) { let q = parseInt ( k / ( n - 1 ) ) ; let r = k % ( n - 1 ) ; let a ; if ( r != 0 ) a = ( n * q ) + r ; else a = ( n * q ) - 1 ; document . write ( a ) ; }
function wastedWater ( V , M , N ) { let wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; }
function printOriginalMatrix ( a , b , mat ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) document . write ( Math . min ( a [ i ] , b [ j ] ) + " " ) ; else document . write ( " " + " " ) ; } document . write ( " " ) ; } }
function prodSquare ( n ) { var s = new Map ( ) ; for ( var i = 2 ; i * i <= n ; ++ i ) { s . set ( i * i , 1 ) ; if ( s . has ( n / ( i * i ) ) ) return true ; } return false ; }
function haversine ( lat1 , lon1 , lat2 , lon2 ) { let dLat = ( lat2 - lat1 ) * Math . PI / 180.0 ; let dLon = ( lon2 - lon1 ) * Math . PI / 180.0 ; lat1 = ( lat1 ) * Math . PI / 180.0 ; lat2 = ( lat2 ) * Math . PI / 180.0 ; let a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; let rad = 6371 ; let c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; }
function findRadius ( r1 , r2 , r3 ) { let r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * Math . sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 . toFixed ( 6 ) ; }
function areaCircle ( b ) { let area = 3.1415926 * b * b ; return area ; }
function sieve ( ) { position [ 0 ] = - 1 , position [ 1 ] = - 1 ; var pos = 0 ; for ( var i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( var j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } }
function printBinary ( num ) { if ( num >= 1 num <= 0 ) return " " ; let binary = " " ; let frac = 0.5 ; binary += " " ; while ( num > 0 ) { if ( binary . length >= 32 ) return " " ; if ( num >= frac ) { binary += " " ; num -= frac ; } else binary += " " ; frac = frac / 2 ; } return binary ; }
function countSamePrefixSuffix ( s , n ) { var prefix = " " ; for ( let i = 0 ; i < n - 1 ; i ++ ) { prefix += s . charAt ( i ) ; var suffix = s . substring ( n - 1 - i , n ) ; if ( prefix == suffix ) { document . write ( prefix . length + " " ) ; } } }
function findMin ( a , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; var x = parseInt ( Math . exp ( sum / n ) ) ; return x + 1 ; }
function getWinner ( str , len ) { var total = 0 ; if ( str [ 0 ] == ' ' str [ len - 1 ] == ' ' ) return " " ; else { for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " " ; return " " ; } }
function FindElement ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { let m = parseInt ( sum / n ) ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return - 1 ; }
function squareArea ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; var a = ( l * b ) / ( l + b ) ; return a * a ; }
function solution ( arr , x ) { let closestSum = Number . MAX_VALUE ; for ( let i = 0 ; i < arr . length ; i ++ ) { for ( let j = i + 1 ; j < arr . length ; j ++ ) { for ( let k = j + 1 ; k < arr . length ; k ++ ) { if ( Math . abs ( x - closestSum ) > Math . abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) ; } } } return closestSum ; }
function printSubstrings ( n ) { var s = parseInt ( Math . log10 ( n ) ) ; var d = parseInt ( ( Math . pow ( 10 , s ) + 0.5 ) ) ; var k = d ; while ( n > 0 ) { while ( d > 0 ) { document . write ( parseInt ( n / d ) + " " ) ; d = parseInt ( d / 10 ) ; } n = n % k ; k = parseInt ( k / 10 ) ; d = k ; } }
function minsteps ( n , m ) { if ( m > n ) { return - 1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
function count ( n ) { let dp = [ ] ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
function sumOfDigit ( n , b ) { var unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = parseInt ( n / b ) ; } return sum ; }
function xoring ( a , b , n ) { let ans = " " ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == b [ i ] ) ans += " " ; else ans += " " ; } return ans ; }
function distinctRemainders ( n ) { if ( n % 2 == 0 ) return parseInt ( n / 2 ) ; return ( 1 + parseInt ( n / 2 ) ) ; }
function radius ( n , d ) { document . write ( " " + ( d / ( ( n - 1 ) * Math . sqrt ( 2 ) ) ) . toFixed ( 5 ) ) ; }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function decode_String ( str , K ) { let ans = " " ; for ( let i = 0 ; i < str . length ; i += K ) ans += str [ i ] ; for ( let i = str . length - ( K - 1 ) ; i < str . length ; i ++ ) ans += str [ i ] ; document . write ( ans ) ; }
function HogbenNumber ( a ) { let p = ( Math . pow ( a , 2 ) - a + 1 ) ; return p ; }
function avg_of_odd_num ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
function aredisjoint ( set1 , set2 ) { let i = 0 , j = 0 ; set1 . sort ( function ( a , b ) { return a - b } ) ; set2 . sort ( function ( a , b ) { return a - b } ) ; while ( i < set1 . length && j < set2 . length ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } return true ; }
function count_required_sequence ( n , arr ) { var total_required_subsequence = 0 ; var total_n_required_subsequence = 0 ; var dp = Array . from ( Array ( N ) , ( ) => Array ( 2 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var turn_required = 0 ; for ( var j = - 1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j ] [ 0 ] ; var required_end_i = ( total_required_subsequence + turn_required ) ; var n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] ] [ 1 ] += required_end_i ; dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; } return total_required_subsequence ; }
function findkthElement ( arr , n , K ) { var l = 0 ; var h = n - 1 , r ; while ( l + 1 < h ) { var mid = parseInt ( ( l + h ) / 2 ) ; if ( arr [ l ] >= arr [ mid ] ) l = mid ; else h = mid ; } if ( arr [ l ] < arr [ h ] ) r = l ; else r = h ; if ( K <= r + 1 ) return arr [ r + 1 - K ] ; else return arr [ n - ( K - ( r + 1 ) ) ] ; }
function countSetBits ( N ) { var count = 0 ; for ( i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }
function calculateSum ( n ) { return ( parseInt ( Math . pow ( 10 , n + 1 ) ) * ( 9 * n - 1 ) + 10 ) / parseInt ( Math . pow ( 9 , 3 ) ) - n * ( n + 1 ) / 18 ; }
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let x = ( ( n * Math . log10 ( n / Math . E ) + Math . log10 ( 2 * Math . PI * n ) / 2.0 ) ) ; return Math . floor ( x ) + 1 ; }
function countDigits ( st , n ) { if ( n > 0 ) { let cnt = 1 , i ; let st2 = " " ; for ( i = 1 ; i < st . length ; i ++ ) { if ( st [ i ] == st [ i - 1 ] ) cnt ++ ; else { st2 += String . fromCharCode ( ' ' . charCodeAt ( ) + cnt ) ; st2 += st [ i - 1 ] ; cnt = 1 ; } } st2 += String . fromCharCode ( ' ' . charCodeAt ( ) + cnt ) ; st2 += st [ i - 1 ] ; countDigits ( st2 , -- n ) ; } else document . write ( st ) ; }
function radius ( n , d ) { document . write ( " " + d / ( 2 * n - 2 ) ) ; }
function minimiseMedian ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; return Math . abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
function findSum ( n ) { n -- ; let sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
function generateString ( n ) { var s = " " ; for ( var i = 0 ; i < n ; i ++ ) s += ( ( i & 2 ) > 1 ? ' ' : ' ' ) ; document . write ( s + " " ) ; }
function precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( var i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
function checkPronic ( x ) { for ( var i = 0 ; i <= parseInt ( Math . sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
function centeredTetrahedralNumber ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
function isValid ( s ) { let n = Math . sqrt ( s . length ) ; let check = s [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = i , y = i ; while ( x >= 0 && y < n ) { if ( s [ ( n * x ) + y ] != check || s [ ( n * y ) + x ] != check ) { document . write ( " " ) ; return ; } x -- ; y ++ ; } } document . write ( " " ) ; }
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
function constructArr ( arr , pair , n ) { arr [ 0 ] = Math . floor ( ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ) ; for ( let i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
function numberOfPaths ( m , n ) { var count = Array ( m ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( i = 1 ; i < m ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; ; } return count [ m - 1 ] [ n - 1 ] ; }
function findNumbers ( n ) { var ans = " " ; for ( var i = 0 ; i < n - 1 ; i ++ ) ans += ' ' ; var even = ans + ' ' ; var odd = ans + ' ' ; document . write ( " " + even + " " ) ; document . write ( " " + odd + " " ) ; }
function DivisibleBy41 ( first , second , c , n ) { let digit = new Array ( n ) . fill ( 0 ) ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( let i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; let ans = digit [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; }
function midpoint ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + " " + ( y1 + y2 ) / 2 ) ; }
function term ( n ) { return parseInt ( n * ( n + 1 ) / 2 ) ; }
function properDivisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
function Area ( b1 , b2 , h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
function kPresentProbability ( a , n , k ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count += 1 ; return count / n ; }
function findDivisor ( x , y ) { if ( x == y ) return y ; return 2 ; }
function countTriplets ( A , B , C ) { let ans = 0 ; for ( let i = 1 ; i <= A ; i ++ ) { for ( let j = 1 ; j <= B ; j ++ ) { for ( let k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; }
function LISusingLCS ( seq ) { let n = seq . length ; let L = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < ( n + 1 ) ; j ++ ) { L [ i ] [ j ] = 0 ; } } let sortedseq = [ ... seq ] ; sortedseq . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }
function maxBottles ( n , e ) { var s = 0 , b = 0 ; var a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
function minCost ( cost , n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let min_cost = Number . MAX_VALUE ; for ( let j = 0 ; j < i ; j ++ ) if ( j < n ) min_cost = Math . min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; dp [ i ] = min_cost ; } return dp [ n ] ; }
function product_subarrays ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { for ( let k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } document . write ( product + " " ) ; }
function countSolutions ( a ) { let count = 0 ; for ( let i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
function printSeries ( N ) { let ith_term = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; document . write ( ith_term + " " ) ; } }
function findTerm ( n ) { if ( n == 1 ) return n ; else { let term = 7 ; for ( let i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
function nextGreatestAlphabet ( alphabets , K ) { var l = 0 , r = alphabets . length - 1 ; var ans = - 1 ; while ( l <= r ) { var mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
function countDigits ( a , b ) { var count = 0 ; var p = Math . abs ( parseInt ( a / b ) ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 ) ; } return count ; }
function innerCirclearea ( radius ) { if ( radius < 0 ) { return - 1 ; } let r = radius / 2 ; let Area = ( 3.14 * Math . pow ( r , 2 ) ) ; return Area ; }
function seriesSum ( n ) { let i = 1 ; let res = 0.0 ; let sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ++ i / ++ i ; } else { sign = ! sign ; res = res - ++ i / ++ i ; } } return res ; }
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
function getIndex ( n , shuffle ) { for ( i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i ] [ 0 ] == n ) n = shuffle [ i ] [ 1 ] ; else if ( shuffle [ i ] [ 1 ] == n ) n = shuffle [ i ] [ 0 ] ; } document . write ( n ) ; }
function pythagoreanTriplet ( n ) { for ( let i = 1 ; i <= n / 3 ; i ++ ) { for ( let j = i + 1 ; j <= n / 2 ; j ++ ) { let k = n - i - j ; if ( i * i + j * j == k * k ) { document . write ( i + " " + j + " " + k ) ; return ; } } } document . write ( " " ) ; }
function findSmallest ( arr , n ) { var res = 1 ; for ( i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
function findDuplicate ( arr , n , k ) { arr . sort ( ) ; let i = 0 ; while ( i < n ) { let j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; }
function calculateSum ( n ) { let sum = 0 ; for ( let row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
function first ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) if ( str [ i ] === str [ i ] . toUpperCase ( ) ) return str [ i ] ; return 0 ; } var str = " " ; var res = first ( str ) ; if ( res == 0 ) document . write ( " " ) ; else { document . write ( res ) ; document . write ( " " ) ; }
function check ( S , prices , type , n ) { for ( let j = 0 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return " " ; } } } } return " " ; }
function findAngles ( a , b , c , d ) { var numerator = a * a + d * d - b * b - c * c var denominator = 2 * ( a * b + c * d ) var x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; document . write ( " " ) ; numerator = a * a + b * b - c * c - d * d x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; document . write ( " " ) ; numerator = c * c + b * b - a * a - d * d x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; document . write ( " " ) ; numerator = d * d + c * c - a * a - b * b x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; }
function minimumAdjacentDifference ( a , n , k ) { let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i <= k ; i ++ ) { let maxDiff = Number . MIN_VALUE ; for ( let j = 0 ; j < n - k - 1 ; j ++ ) { for ( let p = i ; p <= i + j ; p ++ ) { maxDiff = Math . max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; } } minDiff = Math . min ( minDiff , maxDiff ) ; } return minDiff ; }
function multiply ( n , m ) { let ans = 0 , count = 0 ; while ( m ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m = Math . floor ( m / 2 ) ; } return ans ; }
function checkCount ( A , Q , q ) { for ( let i = 0 ; i < q ; i ++ ) { let L = Q [ i ] [ 0 ] ; let R = Q [ i ] [ 1 ] ; L -- ; R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { document . write ( " " + " " ) ; } else { document . write ( " " + " " ) ; } } }
function maxSide ( a , n ) { let sideLength = 0 ; a . sort ( ) ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } document . write ( sideLength ) ; }
function check ( a , n ) { let ma = a [ 1 ] - a [ 0 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = Math . max ( ma , Math . abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } document . write ( " " + ma ) ; document . write ( " " ) ; return true ; }
function printPalindrome ( n ) { if ( n == 1 ) { document . write ( " " ) ; document . write ( " " ) ; } else { document . write ( " " + ( parseInt ( Math . pow ( 10 , n - 1 ) ) + 1 ) ) ; document . write ( " " + parseInt ( Math . pow ( 10 , n ) - 1 ) ) ; } }
function countP ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
function countSetBits ( n ) { let i = 0 ; let ans = 0 ; while ( ( 1 << i ) <= n ) { let k = 0 ; let change = 1 << i ; for ( let j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
function findAngle ( n ) { let interiorAngle , exteriorAngle ; interiorAngle = Math . floor ( ( n - 2 ) * 180 / n ) ; exteriorAngle = Math . floor ( 360 / n ) ; document . write ( " " + interiorAngle + " " ) ; document . write ( " " + exteriorAngle ) ; }
function getHermiteNumber ( n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
function countNumbers ( l , r ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) { count ++ ; } } return count ; }
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) - 4 * n + 2 ; }
function printFactorialNums ( n ) { let fact = 1 ; let x = 2 ; while ( fact <= n ) { document . write ( fact + " " ) ; fact = fact * x ; x ++ ; } }
function getPairs ( a ) { let n = a . length ; let count = parseInt ( ( n * ( n - 1 ) ) / 2 , 10 ) ; return count ; }
function CountWays ( r , b , l , R , B , W , dp ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r ] [ b ] [ l ] != - 1 ) return dp [ r ] [ b ] [ l ] ; var ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r ] [ b ] [ l ] = ans ; }
function countPaths ( n , m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
function minJumps ( arr , N ) { let fib = new Array ( 30 ) ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( let i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; let DP = new Array ( N + 2 ) ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( let i = 1 ; i <= N + 1 ; i ++ ) { for ( let j = 1 ; j < 30 ; j ++ ) { if ( ( arr [ i - 1 ] == 1 i == N + 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = Math . min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return - 1 ; }
function lexo_small ( n , k ) { var arr = Array . from ( { length : n } , ( _ , i ) => ' ' ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { k -= i ; if ( k >= 0 ) { if ( k >= 26 ) { arr [ i ] = ' ' ; k -= 26 ; } else { arr [ i ] = String . fromCharCode ( k + 97 - 1 ) ; k -= arr [ i ] - ' ' + 1 ; } } else break ; k += i ; } return arr ; }
function isPerfect ( n ) { sum = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
function difference ( n ) { let S , res ; S = Math . floor ( ( n * ( n + 1 ) ) / 2 ) ; res = S * ( S - 1 ) ; return res ; }
function harmonicMean ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + ( 1 / arr [ i ] ) ; return n / sum ; }
function isPossible ( x , y , z ) { let a = Math . round ( x * x + y * y + z * z ) ; if ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) return true ; return false ; }
function printSumSimple ( mat , k ) { if ( k > n ) return ; for ( let i = 0 ; i < n - k + 1 ; i ++ ) { for ( let j = 0 ; j < n - k + 1 ; j ++ ) { let sum = 0 ; for ( let p = i ; p < k + i ; p ++ ) for ( let q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; document . write ( sum + " " ) ; } document . write ( " " ) ; } }
function isWoodall ( x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; x ++ ; let p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
function printIntersection ( A , B ) { for ( var i = 0 ; i < M ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) document . write ( A [ i ] [ j ] + " " ) ; else document . write ( " " ) ; } document . write ( " " ) ; } }
function findMaxSum ( arr , n ) { var res = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var prefix_sum = arr [ i ] ; for ( var j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; var suffix_sum = arr [ i ] ; for ( var j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }
function XorSum ( A , B , N , M ) { let ans1 = 0 , ans2 = 0 ; for ( let i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( let i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
function xorOfSum ( a , n ) { let answer = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
function findS ( s ) { let sum = 0 ; for ( let n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
function maxArea ( A , len ) { let area = 0 ; for ( let i = 0 ; i < len ; i ++ ) { for ( let j = i + 1 ; j < len ; j ++ ) { area = Math . max ( area , Math . min ( A [ j ] , A [ i ] ) * ( j - i ) ) ; } } return area ; }
function alter ( x , y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } document . write ( " " + x + " " + " " + y ) ; }
function sumOfSeries ( x , k ) { var y = ( ( ( x ) / 81 ) * ( 9 * k - 1 + Math . pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }
function avgOfFirstN ( n ) { return ( 1 + n ) / 2 ; }
function highestPower ( n ) { return parseInt ( Math . log ( n ) / Math . log ( 2 ) ) ; }
function ishexadecagonal ( N ) { let n = ( 12 + Math . sqrt ( 112 * N + 144 ) ) / 28 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 16 ; if ( ishexadecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function minimumMoves ( k , l , r ) { let count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
function MatrixChainOrder ( p , n ) { var m = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; var i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Number . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
function Rate ( N1 , N2 ) { var rate = ( N2 - N1 ) * 100 / N1 ; return parseInt ( rate ) ; }
function findSmallestDifference ( A , B , m , n ) { A . sort ( ( a , b ) => a - b ) ; B . sort ( ( a , b ) => a - b ) ; let a = 0 , b = 0 ; let result = Number . MAX_SAFE_INTEGER ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
function getTotalNumberOfSequences ( m , n ) { let T = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { T [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ parseInt ( i / 2 , 10 ) ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
function countBits ( n ) { var count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
function newvol ( x ) { document . write ( " " + " " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + " " ) ; }
function positions ( str , n ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( ( str [ i ] . charCodeAt ( 0 ) & NUM ) + " " ) ; } }
function leastBricks ( wall ) { let map = new Map ( ) ; let res = 0 ; for ( let list of wall ) { let width = 0 ; for ( let i = 0 ; i < list . length - 1 ; i ++ ) { width += list [ i ] ; if ( map . has ( width ) ) { map . set ( width , map . get ( width ) + 1 ) ; } else { map . set ( width , 1 ) } res = Math . max ( res , map . get ( width ) ) ; } } document . write ( wall . length - res ) ; }
function setallbitgivenrange ( n , l , r ) { let range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
function tripletAndSum ( arr , n ) { let ans = 0 ; for ( let bit = 0 ; bit < 32 ; bit ++ ) { let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; }
function evenDecimalValue ( str , n ) { var result = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { var decimalValue = 0 ; var powerOf2 = 1 ; for ( var k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - ' ' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
function isValid ( str , len ) { for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
function perfectSquare ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let p = Math . sqrt ( arr [ i ] ) ; if ( p * p != arr [ i ] ) { return " " ; } } return " " ; }
function largestCoprime ( N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
function oppositeFaceOfDice ( N ) { let ans = 7 - N ; document . write ( ans ) ; }
function countPaths ( n , m ) { var dp = Array ( n + 1 ) . fill ( 0 ) . map ( x => Array ( m + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
function findBalance ( x , bal ) { if ( x % 10 == 0 && ( x + 1.50 ) <= bal ) { document . write ( ( bal - x - 1.50 ) . toFixed ( 2 ) ) ; } else { document . write ( ( bal ) . toFixed ( 2 ) ) ; } }
function countSteps ( x , y ) { if ( x % y == 0 ) return Math . floor ( x / y ) ; return Math . floor ( x / y ) + countSteps ( y , x % y ) ; }
function aredisjoint ( set1 , set2 ) { for ( let i = 0 ; i < set1 . length ; i ++ ) { for ( let j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; }
function IsRedundantBraces ( A ) { let a = 0 , b = 0 ; for ( let i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] == ' ' && A [ i + 2 ] == ' ' ) return true ; if ( A [ i ] == ' ' A [ i ] == ' ' A [ i ] == ' ' A [ i ] == ' ' ) a ++ ; if ( A [ i ] == ' ' ) b ++ ; } if ( b > a ) return true ; return false ; } let A = " " ; if ( IsRedundantBraces ( A ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function cntCells ( n ) { var cells = Math . pow ( n , 2 ) + Math . pow ( n - 1 , 2 ) ; return cells ; }
function isPossible ( arr , p , n , m ) { var sum = 0 ; for ( var i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
function minOperation ( k ) { let dp = Array . from ( { length : k + 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
function arcLength ( diameter , angle ) { let pi = 22.0 / 7.0 ; let arc ; if ( angle >= 360 ) { document . write ( " " + " " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
function getTime ( u , v , x ) { let speed = u + v ; let time = x / speed ; return time ; }
function maxSumBitonicSubArr ( arr , n ) { let msis = new Array ( n ) ; msis . fill ( 0 ) ; let msds = new Array ( n ) ; msds . fill ( 0 ) ; let max_sum = Number . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
function ceilSearch ( arr , low , high , x ) { let i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
function isSymmetric ( mat , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
function middleOfThree ( a , b , c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
function Divisible ( arr , n ) { let count_even = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) count_even ++ ; return count_even + parseInt ( ( n - count_even ) / 2 ) ; }
function minSum ( A , n ) { let min_val = Math . min ( ... A ) ; return ( min_val * ( n - 1 ) ) ; }
function NthComposite ( N ) { let IsPrime = [ ] ; for ( let i = 0 ; i < MAX_SIZE ; i ++ ) IsPrime . push ( true ) ; for ( let p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( let i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } let Composites = [ ] ; for ( let p = 4 ; p < MAX_SIZE ; p ++ ) if ( ! IsPrime [ p ] ) Composites . push ( p ) ; return Composites [ N - 1 ] ; }
function minimumRectangleArea ( A , N ) { let ans ; A . sort ( ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( let i = 1 ; i < N ; i ++ ) ans = Math . min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
function nDigitPerfectCubes ( n ) { document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n - 1 ) ) ) ) , 3 ) + " " ) ; document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ) ; }
function countNestedPolygons ( sides ) { var count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
function countXOR ( n ) { let count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n = Math . floor ( n / 2 ) ; } return ( count0 ^ count1 ) ; }
function nthDigit ( a , n , b ) { for ( var i = 1 ; i < n ; i ++ ) a = parseInt ( a / b ) ; return a % b ; }
function minSum ( arr , n , x ) { var sum = 0 ; var largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; var sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; }
function flippingBits ( N , K ) { let X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; document . write ( N ) ; }
function CountWays ( N , M ) { var count = 1 ; count = Math . pow ( 3 , M + N ) ; count *= Math . pow ( 2 , M * N ) ; return count ; }
function enneacontagonNum ( n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
function canBeSumofConsec ( n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; }
function findMaxPoints ( A ) { let P1S = new Array ( M + 2 ) ; let P1E = new Array ( M + 2 ) ; let P2S = new Array ( M + 2 ) ; let P2E = new Array ( M + 2 ) ; for ( let i = 0 ; i < M + 2 ; i ++ ) { P1S [ i ] = new Array ( N + 2 ) ; P1E [ i ] = new Array ( N + 2 ) ; P2S [ i ] = new Array ( N + 2 ) ; P2E [ i ] = new Array ( N + 2 ) ; for ( let j = 0 ; j < N + 2 ; j ++ ) { P1S [ i ] [ j ] = 0 ; P1E [ i ] [ j ] = 0 ; P2S [ i ] [ j ] = 0 ; P2E [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= N ; i ++ ) for ( let j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( let i = N ; i >= 1 ; i -- ) for ( let j = M ; j >= 1 ; j -- ) P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( let i = N ; i >= 1 ; i -- ) for ( let j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( let i = 1 ; i <= N ; i ++ ) for ( let j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; let ans = 0 ; for ( let i = 2 ; i < N ; i ++ ) { for ( let j = 2 ; j < M ; j ++ ) { let op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ; let op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ; ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ; } } return ans ; }
function isDivisibleByDivisor ( S , D ) { S %= D ; var hashMap = [ ] ; hashMap . push ( S ) ; for ( var i = 0 ; i <= D ; i ++ ) { S += S % D ; S %= D ; if ( hashMap . includes ( S ) ) { if ( S == 0 ) { return " " ; } return " " ; } else hashMap . push ( S ) ; } return " " ; }
function findNumbers ( n , d ) { for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( " " + " " ) ; document . write ( " " + " " ) ; document . write ( n + d ) ; }
function singleDigitSubarrayCount ( arr , N ) { let res = 0 ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } document . write ( res ) ; }
function search ( txt , pat ) { let M = pat . length ; let N = txt . length ; for ( let i = 0 ; i <= N - M ; i ++ ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) document . write ( " " + i + " " ) ; } }
function maxScore ( arr ) { var N = arr . length ; N ++ ; var dp = Array . from ( Array ( N + 1 ) , ( ) => Array ( 2 * N ) . fill ( - 10000000 ) ) ; dp [ 0 ] [ 0 ] = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { for ( var s = 1 ; s <= 2 * ( N - 1 ) ; s ++ ) { for ( var j = 1 ; j <= N - 1 && j <= s ; j ++ ) { dp [ i ] [ s ] = Math . max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) ; } } } return dp [ N ] [ 2 * ( N - 1 ) ] ; }
function checkPascaltriangle ( N ) { var x = ( Math . sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( Math . ceil ( x ) - x == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function isCycleExists ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function findPair ( arr , size , n ) { let i = 0 ; let j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { document . write ( " " + arr [ i ] + " " + arr [ j ] + " " ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } document . write ( " " ) ; return false ; }
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = Math . pow ( h , 3 ) ; return a ; }
function minOpsToEmptyString ( s ) { var ans = Number . MIN_VALUE ; var cn0 = 0 ; var cn1 = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . max ( ans , Math . max ( cn0 , cn1 ) ) ; } document . write ( ans ) ; }
function isdecagonal ( N ) { let n = ( 3 + Math . sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 10 ; if ( isdecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function reduceZero ( N ) { var dp = Array ( N + 1 ) . fill ( 1000000000 ) ; dp [ 0 ] = 0 ; for ( var i = 0 ; i <= N ; i ++ ) { for ( var j = 0 ; j < i . toString ( ) . length ; j ++ ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i - ( i . toString ( ) [ j ] - ' ' ) ] + 1 ) ; } } return dp [ N ] ; }
function nthTerm ( N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
function nthTerm ( N ) { let nth = 0 , first_term = 12 ; nth = ( first_term * ( Math . pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . pow ( 2 , N - 1 ) ) - 1 ) ; return nth ; }
function minSum ( arr , n ) { let sum = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { let j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
function sameEulerTotient ( N ) { return ( N & 1 ) ; }
function isEqualSubstring ( str , x ) { let n = str . length ; let i = 0 ; while ( i < n && i < x ) { if ( str [ i ] !== str [ n - i - 1 ] ) { document . write ( " " ) ; return ; } i ++ ; } document . write ( " " ) ; }
function countTriplets ( arr , n ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; else even ++ ; } let c1 = Math . floor ( odd * ( even * ( even - 1 ) ) / 2 ) ; let c2 = Math . floor ( ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ) ; return c1 + c2 ; }
function waysToPaint ( n ) { var same = 6 ; var diff = 6 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { var sameTmp = 3 * same + 2 * diff ; var diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } document . write ( same + diff ) ; }
function find_and ( arr ) { let ans = arr [ 0 ] ; for ( let i = 0 ; i < arr . length ; i ++ ) { ans = ( ans & arr [ i ] ) ; } return ans ; }
function findString ( arr , N ) { let ans = " " ; for ( let i = 0 ; i < N ; i ++ ) { ans += arr [ i ] [ i ] == ' ' ? ' ' : ' ' ; } return ans ; }
function find_rectangle ( area ) { let l = 0 , b = 0 ; let M = Math . floor ( Math . sqrt ( area ) ) , ans ; for ( let i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = Math . floor ( area / i ) ; b = i ; break ; } } document . write ( " " + l + " " + b ) ; }
function xorPairSum ( ar , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; }
function gcd ( a , b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }
function NoCarrySum ( N , M ) { return N ^ M ; }
function findMinSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
function isPossible ( n ) { var fac = new Array ( 10 ) ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( var i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; var sum = 0 ; var x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x = parseInt ( x / 10 ) ; } if ( sum % n == 0 ) return true ; return false ; }
function leftRotate ( arr , n , k ) { for ( let i = k ; i < k + n ; i ++ ) document . write ( arr [ i % n ] + " " ) ; }
function findCount ( mat , i , j , m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
function linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( let i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } } let Xo = 5 ; let m = 7 ; let a = 3 ; let c = 3 ; let noOfRandomNums = 10 ; let randomNums = new Array ( noOfRandomNums ) . fill ( 0 ) ; linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) ; for ( let i = 0 ; i < noOfRandomNums ; i ++ ) { document . write ( randomNums [ i ] + " " ) ; }
function hasEqualBlockFrequency ( N ) { let S = N . toString ( 2 ) ; let p = new Set ( ) ; let c = 1 ; for ( let i = 0 ; i < S . length - 1 ; i ++ ) { if ( S [ i ] == S [ i + 1 ] ) c += 1 ; else { p . add ( c ) ; c = 1 ; } p . add ( c ) ; } if ( p . size == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findMaximumProfit ( arr , M , N ) { let max_heap = [ ] ; let maxProfit = 0 ; for ( let i = 0 ; i < N ; i ++ ) max_heap . push ( arr [ i ] ) ; max_heap . sort ( function ( a , b ) { return a - b } ) ; max_heap . reverse ( ) ; while ( M > 0 ) { M -- ; let X = max_heap [ 0 ] ; max_heap . shift ( ) ; maxProfit += X ; max_heap . push ( X - 1 ) ; max_heap . sort ( function ( a , b ) { return a - b } ) ; max_heap . reverse ( ) ; } document . write ( maxProfit ) ; }
function squares ( l , b , a ) { return parseInt ( Math . ceil ( l / a ) * Math . ceil ( b / a ) ) ; }
function cntSubArrays ( arr , n , k ) { var res = 0 ; var i = 0 ; while ( i < n ) { var j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; res += Math . max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }
function printFreq ( arr , N ) { let freq = 1 ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { freq ++ ; } else { document . write ( " " + parseInt ( arr [ i - 1 ] ) + " " + parseInt ( freq ) + " " ) ; freq = 1 ; } } document . write ( " " + parseInt ( arr [ N - 1 ] ) + " " + parseInt ( freq ) + " " ) ; }
function ToCheckPowerofX ( n , x ) { while ( n > 0 ) { var rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; } var N = 10 , X = 3 ; if ( ToCheckPowerofX ( N , X ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isPossible ( arr , n ) { var mini = Number . MAX_VALUE ; for ( var i = 0 ; i < n ; i ++ ) mini = Math . min ( mini , arr [ i ] ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; var Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return " " ; } return " " ; }
function FindPoint ( x1 , y1 , x2 , y2 , x , y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
function constructXOR ( A , n ) { let XOR = 0 ; for ( let i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( let i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
function subsetXOR ( arr , n , k ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; if ( k > m ) { return 0 ; } let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
function findsolution ( d , h , m , n ) { var k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return - 1 ; var ans = ( h / ( k - n ) ) ; return ans ; }
function temp_convert ( F1 , B1 , F2 , B2 , T ) { var t2 ; t2 = F2 + ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
function convertToASCII ( N ) { let num = N . toString ( ) ; for ( let ch = 0 ; ch < num . length ; ch ++ ) { document . write ( num [ ch ] + " " + num [ ch ] . charCodeAt ( 0 ) + " " ) ; } }
function sumOfTheSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let k = 1 ; for ( let j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
function count ( n ) { return parseInt ( ( - 1 + Math . sqrt ( 1 + 8 * n ) ) / 2 ) ; }
function subString ( str , n ) { for ( let len = 1 ; len <= n ; len ++ ) { for ( let i = 0 ; i <= n - len ; i ++ ) { let j = i + len - 1 ; for ( let k = i ; k <= j ; k ++ ) { document . write ( str [ k ] ) ; } document . write ( " " ) ; } } }
function Series ( n ) { let sums = 0.0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { ser = 1 / Math . pow ( i , i ) ; sums += ser ; } return sums ; }
function linearCheck ( ar , arr ) { for ( let i = 0 ; i < m ; i ++ ) { let matched = true ; for ( let j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; }
function isOctadecagon ( N ) { let n = ( 14 + Math . sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 18 ; if ( isOctadecagon ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function nextPerfectSquare ( N ) { let nextN = Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; }
function productAtKthLevel ( tree , k ) { let level = - 1 ; let product = 1 ; let n = tree . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ' ) level ++ ; else if ( tree [ i ] == ' ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; } } return product ; }
function countPoints ( n , m , a , b , x , y ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let j = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; }
function findElement ( arr , n , key ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
function performQueries ( str , n , queries , q ) { var ptr = 0 ; for ( var i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 1 ) { ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; } else { var k = queries [ i ] [ 1 ] ; var index = ( ptr + k - 1 ) % n ; document . write ( str [ index ] + " " ) ; } } }
function evenPowerSum ( n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
function is_Chiliagon ( N ) { let n = ( 996 + Math . sqrt ( 7984 * N + 992016 ) ) / 1996 ; return ( n - Math . floor ( n ) ) == 0 ; } let N = 1000 ; if ( is_Chiliagon ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function even_or_odd ( N ) { let len = N . length ; if ( N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' ) return ( " " ) ; else return ( " " ) ; }
function minimumHammingDistance ( S , K ) { let n = S . length ; let pref = new Array ( n ) ; pref [ 0 ] = S [ 0 ] - ' ' ; for ( let i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S [ i ] - ' ' ) ; let cnt = pref [ n - 1 ] ; let ans = cnt ; for ( let i = 0 ; i < n - K ; i ++ ) { let value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = Math . min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
function circumference ( r ) { let cir = 2 * 3.1415 * r ; return cir ; }
function checkArrays ( arr1 , arr2 , N ) { let count = 0 ; let flag = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = false ; break ; } } } } if ( ( flag && ( count == 0 ) ) == true ) document . write ( " " ) ; else document . write ( " " ) ; }
function checkSolution ( a , b , c ) { if ( b == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function countPairs ( n ) { let count = 0 ; for ( let x = 1 ; x < n ; x ++ ) { for ( let y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
function min_noOf_operation ( arr , n , k ) { let noOfSubtraction ; let res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
function numberOfElements ( height , n ) { var max_so_far = 0 ; var coun = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
function findK ( arr , size , N ) { arr . sort ( function ( a , b ) { return a - b } ) ; let temp_sum = 0 ; for ( let i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; }
function factors ( n , i ) { if ( i <= n ) { if ( n % i == 0 ) { document . write ( i + " " ) ; } factors ( n , i + 1 ) ; } }
function moduloMultiplication ( a , b , mod ) { let res = 0 ; a = ( a % mod ) ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; }
function findRemainders ( n ) { var vc = new Set ( ) ; for ( var i = 1 ; i <= Math . ceil ( Math . sqrt ( n ) ) ; i ++ ) vc . add ( parseInt ( n / i ) ) ; for ( var i = parseInt ( n / Math . ceil ( Math . sqrt ( n ) ) ) - 1 ; i >= 0 ; i -- ) vc . add ( i ) ; [ ... vc ] . sort ( ( a , b ) => a - b ) . forEach ( it => { document . write ( it + " " ) ; } ) ; }
function minAbsDiff ( N ) { var sumSet1 = 0 ; var sumSet2 = 0 ; for ( i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . abs ( sumSet1 - sumSet2 ) ; }
function minimumDifference ( N ) { var sum1 = ( 1 << N ) , sum2 = 0 ; for ( i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; document . write ( sum1 - sum2 ) ; }
function solve ( n ) { var ans = ( n * n / 4 ) ; return ans ; }
function maxRegions ( n ) { let num ; num = parseInt ( n * ( n + 1 ) / 2 ) + 1 ; document . write ( num ) ; }
function sum_star_num ( n ) { let summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
function countSubsequece ( a , n ) { let i , j , k , l ; let answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }
function checkValidity ( a , b , c ) { if ( a + b <= c a + c <= b b + c <= a ) return false ; else return true ; }
function maximumTurns ( arr , N ) { let Count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = Math . floor ( arr [ i ] / 2 ) ; } } return Count ; }
function findWays ( f , d , s ) { let mem = new Array ( d + 1 ) ; for ( let i = 0 ; i < ( d + 1 ) ; i ++ ) { mem [ i ] = new Array ( s + 1 ) ; for ( let j = 0 ; j < s + 1 ; j ++ ) { mem [ i ] [ j ] = 0 ; } } mem [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= d ; i ++ ) { for ( let j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
function optimalStrategyOfGame ( arr , n ) { let table = new Array ( n ) ; let gap , i , j , x , y , z ; for ( let d = 0 ; d < n ; d ++ ) { table [ d ] = new Array ( n ) ; } for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
function leftRotate ( arr , d , n ) { if ( d == 0 d == n ) return ; let i = d ; let j = n - d ; while ( i != j ) { if ( i < j ) { arr = swap ( arr , d - i , d + j - i , i ) ; j -= i ; } else { arr = swap ( arr , d - i , d , j ) ; i -= j ; } } arr = swap ( arr , d - i , d , i ) ; }
function canBeEqual ( a , b , c , k ) { var arr = Array ( 3 ) ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; arr . sort ( ( a , b ) => a - b ) ; var diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }
function pow ( a , b ) { if ( b == 0 ) return 1 ; var answer = a ; var increment = a ; var i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
function countPoints ( D ) { let count = 0 ; for ( let x = 1 ; x * x < D * D ; x ++ ) { let y = Math . floor ( Math . sqrt ( D * D - x * x ) ) ; if ( x * x + y * y == D * D ) { count += 4 ; } } count += 4 ; return count ; }
function countChar ( str , x ) { let count = 0 ; let n = 10 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) count ++ ; let repetitions = n / str . length ; count = count * repetitions ; for ( let i = 0 ; i < n % str . length ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; }
function getPercentile ( rank , students ) { var result = ( students - rank ) / students * 100 ; return result ; }
function totalSumDivisibleByNum ( digit , number ) { let firstnum = Math . pow ( 10 , digit - 1 ) ; let lastnum = Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; let count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
function check_euler_four_square_identity ( a , b , ab ) { let s = 0 ; for ( let i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( let j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( let k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( let l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { document . write ( " " + i + " " ) ; document . write ( " " + j + " " ) ; document . write ( " " + k + " " ) ; document . write ( " " + l + " " ) ; document . write ( " " + a + " " + b ) ; document . write ( " " + " " + " " + " " ) ; document . write ( ab + " " ) ; document . write ( i + " " + i + " " ) ; document . write ( j + " " + j + " " ) ; document . write ( k + " " + k + " " ) ; document . write ( l + " " + l + " " ) ; document . write ( " " ) ; } } } } } }
function minCount ( arr , n , k ) { var ans = 0 ; var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; var l = 0 ; var r = 0 ; var tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = Math . max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
function clearBit ( num , i ) { let mask = ~ ( 1 << i ) ; return num & mask ; }
function splitArr ( arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { let x = arr [ 0 ] ; for ( let j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
function TowerOfHanoi ( N ) { for ( let x = 1 ; x <= Math . pow ( 2 , N ) - 1 ; x ++ ) { document . write ( " " + ( ( x & x - 1 ) % 3 + 1 ) + " " + ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) + " " ) ; } }
function printSumSeries ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += 1.0 / ( 2 * i - 1 ) ; } document . write ( sum . toFixed ( 5 ) ) ; }
function contain ( L , U , M ) { let count = 0 ; for ( let j = L ; j < U ; j ++ ) { let num = new Set ( ) ; let str = String ( j ) ; num . add ( str ) ; if ( j % M == 0 && ! num . has ( String ( M ) ) ) { count += 1 ; } } document . write ( count - 2 ) ; }
function countDigits ( a , b ) { return Math . floor ( ( Math . log ( Math . abs ( a ) ) / Math . log ( 10 ) ) - ( Math . log ( Math . abs ( b ) ) / Math . log ( 10 ) ) ) + 1 ; }
function isStraighLineNum ( N ) { if ( N <= 99 ) return false ; let s = N . toString ( ) ; let d = s [ 1 ] - s [ 0 ] ; for ( let i = 2 ; i < s . length ; i ++ ) if ( s [ i ] - s [ i - 1 ] != d ) return false ; return true ; } let n = 135 ; if ( isStraighLineNum ( n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function replace_elements ( arr , n ) { let pos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( let i = 0 ; i < pos ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " " ; n = n >> 1 ; } return " " ; }
function countSetBits ( n ) { n ++ ; var powerOf2 = 2 ; var cnt = n / 2 ; while ( powerOf2 <= n ) { var totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
function rearrange ( arr , n ) { let temp = new Array ( n ) ; let small = 0 , large = n - 1 ; let flag = true ; for ( let i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
function removeDuplicates ( str ) { let n = str . length ; let res = " " ; for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) break ; if ( j == n ) res = res + str [ i ] ; } return res ; }
function checkCentrosymmetricted ( n , m ) { let mid_row ; if ( n & 1 ) mid_row = Math . floor ( n / 2 ) + 1 ; else mid_row = n / 2 ; for ( let i = 0 ; i < mid_row ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } let N = 3 ; let flag , k , m = 0 ; if ( ( N == 1 ) || ( N == 2 ) ) document . write ( 62 ) ; else m = 1000000000 + 7 ; if ( N % 2 == 0 ) { k = N / 2 ; flag = 1 ; } else { k = ( N - 1 ) / 2 ; flag = 0 ; } if ( flag != 0 ) { let a = power ( 62 , k , m ) ; document . write ( a ) ; } else { let a = power ( 62 , ( k + 1 ) , m ) ; document . write ( a ) ; }
function count_triples ( n , k ) { var i = 0 , j = 0 , l = 0 ; var count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { for ( l = 1 ; l <= n ; l ++ ) { if ( ( i + j ) % k == 0 && ( i + l ) % k == 0 && ( j + l ) % k == 0 ) count ++ ; } } } return count ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) - n - 1 ; }
function checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var resx = x1 + x2 + x3 ; var resy = y1 + y2 + y3 ; var resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; }
function findAverage ( N ) { let avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
function reorder ( arr , index , n ) { for ( let i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { let oldTargetI = index [ index [ i ] ] ; let oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }
function isCenterednonadecagonal ( N ) { var n = ( 19 + Math . sqrt ( 152 * N + 209 ) ) / 38 ; return ( n - parseInt ( n ) ) == 0 ; } var n = 20 ; if ( isCenterednonadecagonal ( n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function check ( n ) { var digits = new Set ( ) ; var temp = n ; var sum = 0 ; var count = 0 ; while ( temp > 0 ) { sum += temp % 10 ; digits . add ( temp % 10 ) ; count ++ ; temp = parseInt ( temp / 10 ) ; } if ( sum % count == 0 && digits . has ( sum / count ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function printValueOfPi ( N ) { let pi = 2 * Math . acos ( 0.0 ) ; document . write ( pi . toFixed ( 4 ) ) ; }
function swapBits ( x , p1 , p2 , n ) { let set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; let set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; let xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; let result = x ^ xor ; return result ; }
function canVote ( a , n , x ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( x + 1 ) ; for ( let j = 0 ; j < x + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; return ( sum - dp [ n ] [ x ] <= x ) ; } let n = 3 , x = 4 ; let a = [ 2 , 4 , 2 ] ; if ( canVote ( a , n , x ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function longestRodInCuboid ( length , breadth , height ) { let result ; let temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; }
function oddSum ( n ) { let sum = 0 ; curr = 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
function minCost ( a , n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; } dp [ 0 ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) for ( let m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
function minimum_sum ( A , N ) { A . sort ( ) ; var sum = 1000000000 ; for ( var i = 0 ; i <= N - 3 ; i ++ ) { sum = Math . min ( sum , Math . abs ( A [ i ] - A [ i + 1 ] ) + Math . abs ( A [ i + 1 ] - A [ i + 2 ] ) ) ; } document . write ( sum ) ; }
function nthMagicNo ( n ) { let pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
function getMaxMedian ( arr , n , k ) { let size = n + k ; arr . sort ( ( a , b ) => a - b ) ; if ( size % 2 == 0 ) { let median = ( arr [ Math . floor ( size / 2 ) - 1 ] + arr [ Math . floor ( size / 2 ) ] ) / 2 ; return median ; } let median = arr [ Math . floor ( size / 2 ) ] ; return median ; }
function changeTheArray ( arr , n ) { let minEle = Math . min ( ... arr ) ; let maxEle = Math . max ( ... arr ) ; let minOperations = Number . MAX_VALUE ; for ( let num = minEle ; num <= maxEle ; num ++ ) { let operations = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . min ( minOperations , operations ) ; } return minOperations ; }
function dupLastIndex ( arr , n ) { if ( arr == null n <= 0 ) return ; for ( let i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { document . write ( " " + i + " " ) ; document . write ( " " + arr [ i ] + " " ) ; return ; } } document . write ( " " ) ; }
function seriesSum ( calculated , current , N ) { let i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
function centeredNonagonal ( n ) { return parseInt ( ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ) ; }
function Remainder ( str , R ) { var len = str . length ; var Num , Rem = 0 ; for ( var i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - ' ' ) ; Rem = Num % R ; } return Rem ; }
function check ( arr , x , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let y = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( y ) == Math . ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; } let arr = [ 2 , 3 , 4 , 9 , 10 ] ; let n = arr . length ; let x = 13 ; if ( check ( arr , x , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function getMinSteps ( n , jump ) { let quotient = Math . floor ( n / jump ) ; let remainder = n % jump ; let steps = quotient + remainder ; return steps ; }
function findSides ( A , C , c ) { let B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; let a = ( c / Math . sin ( C ) ) * Math . sin ( A ) ; let b = ( c / Math . sin ( C ) ) * Math . sin ( B ) ; document . write ( a . toPrecision ( 4 ) + " " ) ; document . write ( b . toPrecision ( 4 ) + " " ) ; }
function makeZero ( x , y , a , b ) { if ( x > y ) { let temp = x ; x = y ; y = temp ; } let tot_cost = ( y - x ) * a ; let cost1 = 2 * x * a ; let cost2 = x * b ; tot_cost += Math . min ( cost1 , cost2 ) ; document . write ( tot_cost ) ; }
function countways ( n ) { let A = new Array ( n + 1 ) . fill ( 0 ) ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( let i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ; return a ; }
function getPairsCount ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
function FindMaxSum ( arr , n ) { let incl = arr [ 0 ] ; let excl = 0 ; let excl_new ; let i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
function binarySearch ( arr , left , right ) { if ( left <= right ) { var mid = parseInt ( ( left + right ) / 2 ) ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }
function countGroups ( position , previous_sum , length , num ) { if ( position == length ) return 1 ; let res = 0 ; let sum = 0 ; for ( let i = position ; i < length ; i ++ ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
function printRepeating ( arr , size ) { var i , j ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) document . write ( arr [ i ] + " " ) ; } } }
function Diagonals ( a , b , c , d ) { var p = parseFloat ( Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; var q = parseFloat ( Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return [ p , q ] ; }
function findRightAngle ( A , H ) { let D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { let root1 = ( H * H + Math . sqrt ( D ) ) / 2 ; let root2 = ( H * H - Math . sqrt ( D ) ) / 2 ; let a = Math . sqrt ( root1 ) ; let b = Math . sqrt ( root2 ) ; if ( b >= a ) document . write ( a + " " + b + " " + H + " " ) ; else document . write ( b + " " + a + " " + H + " " ) ; } else document . write ( " " ) ; }
function minOperations ( s ) { var len = s . length ; var result = 0 ; for ( var i = 0 ; i < len / 2 ; i ++ ) { var D1 = Math . max ( s [ i ] . charCodeAt ( 0 ) , s [ len - 1 - i ] . charCodeAt ( 0 ) ) - Math . min ( s [ i ] . charCodeAt ( 0 ) , s [ len - 1 - i ] . charCodeAt ( 0 ) ) ; var D2 = 26 - D1 ; result += Math . min ( D1 , D2 ) ; } return result ; }
function maxSum ( arr , n ) { let cum_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; let curr_val = 0 ; for ( let i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; let res = curr_val ; for ( let i = 1 ; i < n ; i ++ ) { let next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }
function isPossible ( a , n ) { let k = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] != i + 1 ) k ++ ; } if ( k <= 2 ) return true ; return false ; }
function nthKyneaNumber ( n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
function countNumbers ( N ) { var count = 0 ; for ( i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( parseInt ( N / i ) != i ) { count ++ ; } } } return count ; }
function findMax ( arr ) { var row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } document . write ( " " + ( row + 1 ) ) ; document . write ( " " + ( N - 1 - j ) ) ; }
function minDiffSubArray ( arr , n ) { let prefix_sum = new Array ( n ) ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; let suffix_sum = new Array ( n ) ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let diff = Math . abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
function minimumBox ( arr , n ) { var q = [ ] ; arr . sort ( ( a , b ) => a - b ) q . push ( arr [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { var now = q [ 0 ] ; if ( arr [ i ] >= 2 * now ) q . pop ( 0 ) ; q . push ( arr [ i ] ) ; } return q . length ; }
function findPrefix ( str1 , str2 ) { var pos = - 1 ; while ( str1 . length != 0 ) { if ( ! str2 . includes ( str1 ) ) str1 = str1 . substring ( 0 , str1 . length - 1 ) else { pos = str2 . includes ( str1 ) ; break ; } } if ( pos == - 1 ) return " " ; return str1 ; }
function getCount ( arr , N ) { var count = 0 ; if ( N < 3 ) return 0 ; for ( var b = 0 ; b < N ; b ++ ) { for ( var a = 0 ; a < N ; a ++ ) { if ( a == b ) continue ; for ( var c = 0 ; c < N ; c ++ ) { if ( c == a c == b ) continue ; var d = arr [ b ] * arr [ b ] / 4 ; if ( arr [ a ] * arr <= d ) count ++ ; } } } return count ; }
function permutation ( arr , n ) { let hash = new Set ( ) ; let maxEle = 0 ; for ( let i = 0 ; i < n ; i ++ ) { hash . add ( arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . length == n ) return true ; return false ; }
function XOROfElements ( arr , n ) { var FirstHalfXOR = 0 ; var SecondHalfXOR = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( i < parseInt ( n / 2 ) ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } document . write ( FirstHalfXOR + " " + SecondHalfXOR + " " ) ; }
function sum ( a , n ) { let maxSum = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) maxSum = Math . max ( maxSum , a [ i ] + a [ j ] ) ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; }
function findpos ( n ) { var pos = 0 ; for ( i = 0 ; i < n . length ; i ++ ) { switch ( n . charAt ( i ) ) { case ' ' : pos = pos * 4 + 1 ; break ; case ' ' : pos = pos * 4 + 2 ; break ; case ' ' : pos = pos * 4 + 3 ; break ; case ' ' : pos = pos * 4 + 4 ; break ; } } return pos ; }
function reorder ( arr , index , n ) { var temp = [ ... Array ( n ) ] ; for ( var i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
function sieve ( ) { let arr = new Array ( N + 1 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = 0 ; } arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( let i = 2 ; i <= Math . ceil ( Math . sqrt ( N ) + 1 ) ; i ++ ) if ( arr [ i ] == 0 ) for ( let j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; let runningPrimeSum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
function findPair ( a , n , z ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
function findMinCost ( arr , X , n , i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return Number . MAX_SAFE_INTEGER ; let inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) ; if ( inc != Number . MAX_SAFE_INTEGER ) inc += arr [ i ] [ 1 ] ; let exc = findMinCost ( arr , X , n , i + 1 ) ; return Math . min ( inc , exc ) ; }
function maxlength ( s ) { let n = s . length , i , j ; let ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s [ i ] == ' ' ) { let count = 1 ; for ( j = i + 1 ; j <= n - 1 && s [ j ] == ' ' ; j ++ ) count ++ ; ans = Math . max ( ans , count ) ; } } return ans ; }
function Check_is_possible ( l , r , k ) { var count = 0 ; for ( i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return ( count > 1 ) ; } var l = 4 , r = 12 ; var k = 5 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function count_pairs ( arr , brr , N , M , K ) { let i = 0 ; let j = 0 ; let cntPairs = 0 ; ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; ( brr ) . sort ( function ( a , b ) { return a - b ; } ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
function MaxSubsetlength ( arr , A , B ) { var dp = Array . from ( Array ( A + 1 ) , ( ) => Array ( B + 1 ) . fill ( 0 ) ) ; arr . forEach ( str => { var zeros = [ ... str ] . filter ( x => x == ' ' ) . length ; var ones = [ ... str ] . filter ( x => x == ' ' ) . length ; for ( var i = A ; i >= zeros ; i -- ) for ( var j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } ) ; return dp [ A ] [ B ] ; }
function findSum ( s ) { let sum = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { for ( let j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
function Count ( s , pos ) { let c = s [ pos - 1 ] ; let counter = 0 ; for ( let i = 0 ; i < pos - 1 ; i ++ ) { if ( s [ i ] == c ) counter = counter + 1 ; } return counter ; } let s = " " ; let pos ; let n = s . length ; let query = [ 9 , 3 , 2 ] ; let Q = query . length ; for ( let i = 0 ; i < Q ; i ++ ) { pos = query [ i ] ; document . write ( Count ( s , pos ) + " " ) ; }
function productSum ( arr , N ) { let cntOne = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) cntOne ++ ; } return cntOne * ( cntOne - 1 ) / 2 ; }
function two_sets ( a , n ) { a . sort ( ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; }
function arrayEvenAndOdd ( arr , n ) { let i = - 1 , j = 0 ; let t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function findWays ( N ) { let dp = new Array ( N + 1 ) ; dp [ 0 ] = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( let j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } document . write ( dp [ N ] ) ; }
function longestSubsequenceCommonSegment ( k , s1 , s2 ) { var n = s1 . length ; var m = s2 . length ; var lcs = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; var cnt = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( var a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
function squarearea ( r ) { if ( r < 0 ) return - 1 ; var a = 4 * ( Math . pow ( r , 2 ) / 5 ) ; return a ; }
function substringConversions ( str , k , b ) { for ( let i = 0 ; i + k <= str . length ; i ++ ) { let sub = str . substring ( i , i + k ) ; let sum = 0 , counter = 0 ; for ( let j = sub . length - 1 ; j >= 0 ; j -- ) { sum = ( sum + ( ( sub [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } document . write ( sum + " " ) ; } }
function findsubArray ( arr , N , K ) { var res = N + 1 ; for ( i = 0 ; i < N ; i ++ ) { var curr_prod = 1 ; for ( j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = Math . min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
function missingNumber ( arr1 , arr2 , n ) { let mnum = 0 ; for ( let i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
function findoptimal ( N ) { if ( N <= 6 ) return N ; let screen = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { screen [ i ] = 0 ; } let b ; let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { let curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
function numberOfUniqueOutcomes ( N , S ) { if ( S < N ) return 0 ; if ( N == 1 N == S ) return 1 ; return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) ; }
function zigzag ( n , k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
function findGreater ( x , y ) { if ( x > y ) { return false ; } else { return true ; } }
function findNumber ( n , m ) { var num = ( m - 1 ) * 9 + n ; return num ; }
function getMinNum ( a , b , c ) { if ( c < a c > b ) return c ; let x = ( parseInt ( b / c ) * c ) + c ; return x ; }
function check ( s ) { let l = s . length ; s . sort ( ) ; for ( let i = 1 ; i < l ; i ++ ) { if ( ( s [ i ] . charCodeAt ( ) - s [ i - 1 ] . charCodeAt ( ) ) != 1 ) return false ; } return true ; }
function isDivisible ( n ) { let d ; while ( Math . floor ( n / 100 ) <= 0 ) { d = n % 10 ; n = Math . floor ( n / 10 ) ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
function countRect ( n ) { let ans = 0 ; for ( let length = 1 ; length <= parseInt ( Math . sqrt ( n ) , 10 ) ; ++ length ) for ( let height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
function findMinDiff ( arr , n ) { let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
function surface_area_octahedron ( side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
function countPairs ( A , B ) { let n = A . length ; let ans = 0 ; A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
function smallestNumber ( N ) { document . write ( ( N % 9 + 1 ) * Math . pow ( 10 , parseInt ( N / 9 , 10 ) ) - 1 ) ; }
function calculate ( n , k , m , power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
function LargestString ( na ) { let N = na . length ; let c = new Array ( N ) ; let m = 1 ; for ( let j = 0 ; j < N ; j ++ ) { let character = new Array ( 26 , 0 ) ; for ( let k = 0 ; k < na [ j ] . length ; k ++ ) { let x = na [ j ] [ k ] . charCodeAt ( 0 ) - 65 ; if ( ( na [ j ] [ k ] != ' ' ) && ( character [ x ] == 0 ) ) { c [ j ] ++ ; character [ x ] = 1 ; } } if ( c [ j ] > c [ m ] ) m = j ; } document . write ( na [ m ] ) ; }
function check ( n ) { let sumOfDigit = 0 ; let prodOfDigit = 1 ; while ( n > 0 ) { let rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n = Math . floor ( n / 10 ) ; } if ( sumOfDigit > prodOfDigit ) document . write ( " " ) ; else document . write ( " " ) ; }
function longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) { let freq1 = new Array ( SIZE ) ; let freq2 = new Array ( SIZE ) ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } let len = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
function middleOfThree ( a , b , c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
function checkArray ( arr , N , k ) { if ( N < 3 ) return - 1 ; let i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; let R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; let Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
function kth_String ( n , k ) { for ( i = n - 2 ; i >= 0 ; i -- ) { if ( k <= ( n - i - 1 ) ) { for ( j = 0 ; j < n ; j ++ ) { if ( j == i j == n - k ) document . write ( ' ' ) ; else document . write ( ' ' ) ; } break ; } k -= ( n - i - 1 ) ; } }
function printNumberOfPairs ( N ) { var st = new Set ( ) ; for ( let i = 2 ; i * i <= N ; i ++ ) { let x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . add ( x ) ; } } } document . write ( st . size ) ; }
function countSetBits ( N ) { let count = 0 ; while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; } return count ; }
function subtract ( x , y ) { while ( y != 0 ) { let borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
function findTwoThreePrime ( l , r ) { if ( l == 1 ) l ++ ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; while ( num % 2 == 0 ) num = parseInt ( num / 2 , 10 ) ; while ( num % 3 == 0 ) num = parseInt ( num / 3 , 10 ) ; if ( num == 1 ) count ++ ; } return count ; }
function IcosihexagonalNum ( n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
function checkSentence ( str ) { var len = str . length ; if ( str [ 0 ] . charCodeAt ( 0 ) < " " . charCodeAt ( 0 ) || str [ 0 ] . charCodeAt ( 0 ) > " " . charCodeAt ( 0 ) ) return false ; if ( str [ len - 1 ] !== " " ) return false ; var prev_state = 0 , curr_state = 0 ; var index = 1 ; while ( index <= str . length ) { if ( str [ index ] . charCodeAt ( 0 ) >= " " . charCodeAt ( 0 ) && str [ index ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) curr_state = 0 ; else if ( str [ index ] === " " ) curr_state = 1 ; else if ( str [ index ] . charCodeAt ( 0 ) >= " " . charCodeAt ( 0 ) && str [ index ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) curr_state = 2 ; else if ( str [ index ] === " " ) curr_state = 3 ; if ( prev_state === curr_state && curr_state !== 2 ) return false ; if ( prev_state === 2 && curr_state === 0 ) return false ; if ( curr_state === 3 && prev_state !== 1 ) return index + 1 == str . length ; index ++ ; prev_state = curr_state ; } return false ; } var str = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , ] ; var str_size = str . length ; var i = 0 ; for ( i = 0 ; i < str_size ; i ++ ) { var temp = str [ i ] . split ( " " ) ; if ( checkSentence ( temp ) ) document . write ( ' ' + str [ i ] + ' ' + " " + " " ) ; else document . write ( ' ' + str [ i ] + ' ' + " " + " " ) ; }
function findCost ( a , n ) { a . sort ( ( x , y ) => y - x ) ; var count = 0 ; for ( var j = 0 ; j < n ; j ++ ) { var p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
function countPairs ( str ) { let result = 0 ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str [ i ] . charCodeAt ( ) - str [ j ] . charCodeAt ( ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
function minSum ( arr , n ) { arr . sort ( ) ; let x = arr [ Math . floor ( n / 2 ) ] ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += Math . abs ( arr [ i ] - x ) ; return sum ; }
function longLenSub ( arr , n ) { let um = new Map ( ) ; let longLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let len = 0 ; if ( um . has ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . has ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . set ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; }
function swapBits ( n , p1 , p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
function subsetCount ( arr , n ) { return 1 << n ; }
function isValidSeq ( a , n ) { var nodes = n + 2 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 a [ i ] > nodes ) return false ; } return true ; }
function LowerHessenbergMatrix ( n ) { for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) document . write ( ' ' + " " ) ; else document . write ( Math . floor ( Math . random ( ) * 10 ) + " " ) ; } document . write ( " " ) ; } }
function CountPair ( L , R ) { let x = ( R - L + 1 ) ; document . write ( x / 2 + " " ) ; }
function isEven ( n ) { return ( n % 2 == 0 ) ; }
function findTripleSum ( A , B , C ) { let sum = 0 ; for ( let i = 1 ; i <= A ; i ++ ) { for ( let j = 1 ; j <= B ; j ++ ) { for ( let k = 1 ; k <= C ; k ++ ) { let prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
function countWays ( n ) { var ans = 1 ; for ( i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
function swapBits ( n , p1 , p2 ) { var bit1 = ( n >> p1 ) & 1 ; var bit2 = ( n >> p2 ) & 1 ; var x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; var result = n ^ x ; return result ; }
function powerOf2 ( n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
function get_permutation ( arr , n ) { arr . sort ( ) ; var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { result += Math . abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
function rangeSum ( l , r ) { var a = 1 , b = 9 , res = 0 ; for ( var i = 1 ; i <= 10 ; i ++ ) { var L = Math . max ( l , a ) ; var R = Math . min ( r , b ) ; if ( L <= R ) { var sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
function countNums ( l , r ) { let cnt = 0 ; for ( let i = l ; i <= r ; i ++ ) { let lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
function isAnyNotPalindrome ( s ) { var unique = new Set ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) unique . add ( s [ i ] ) ; if ( unique . size > 1 ) return true ; else return false ; }
function findAverage ( N ) { var S = 0 ; var i ; for ( i = 1 ; i <= N ; i ++ ) { S += i * i * i * i ; } return S / N ; }
function findbitwiseOR ( a , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( let j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } document . write ( res ) ; }
function atleastkDistinctChars ( s , k ) { let n = s . length ; let mp = new Map ( ) ; let begin = 0 , end = 0 ; let ans = 0 ; while ( end < n ) { let c = s [ end ] ; if ( mp . has ( c ) ) mp . set ( c , mp . get ( c ) + 1 ) ; else mp . set ( c , 1 ) ; end ++ ; while ( mp . size >= k ) { let pre = s [ begin ] ; mp . set ( pre , mp . get ( pre ) - 1 ) ; if ( mp . get ( pre ) == 0 ) { mp . delete ( pre ) ; } ans += s . length - end + 1 ; begin ++ ; } } document . write ( ans ) ; }
function findProduct ( arr , n ) { arr . sort ( ) ; var prod = 1 * arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; }
function hIndex ( citations , n ) { let hindex = 0 ; let low = 0 , high = n - 1 ; while ( low <= high ) { let mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } document . write ( hindex ) ; return hindex ; }
function length_rope ( r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
function magicOfSequence ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
function countPairs ( A , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } document . write ( count ) ; }
function check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) { var value_1 = a * x1 + b * y1 + c * z1 + d ; var value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) document . write ( " " ) ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) document . write ( " " ) ; if ( value_1 == 0 && value_2 == 0 ) document . write ( " " ) ; if ( value_1 == 0 && value_2 != 0 ) document . write ( " " ) ; if ( value_1 != 0 && value_2 == 0 ) document . write ( " " ) ; }
function generateArray ( n , k ) { var array = Array ( k ) . fill ( 0 ) ; var remaining = n - parseInt ( k * ( k + 1 ) / 2 ) ; if ( remaining < 0 ) document . write ( " " ) ; var right_most = remaining % k ; var high = parseInt ( Math . ceil ( remaining / ( k * 1.0 ) ) ) ; var low = parseInt ( Math . floor ( remaining / ( k * 1.0 ) ) ) ; for ( i = k - right_most ; i < k ; i ++ ) array [ i ] = high ; for ( i = 0 ; i < ( k - right_most ) ; i ++ ) array [ i ] = low ; for ( i = 0 ; i < k ; i ++ ) array [ i ] += i + 1 ; if ( k - 1 != remaining k == 1 ) { for ( var u = 0 ; u < array . length ; u ++ ) document . write ( array [ u ] + " " ) ; } else if ( k == 2 k == 3 ) document . write ( " " ) ; else { array [ 1 ] -= 1 ; array [ k - 1 ] += 1 ; for ( var f = 0 ; f < array . length ; f ++ ) document . write ( array [ f ] + " " ) ; } }
function nthSHN ( n , dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
function calcCount ( arr , n , k ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 ) count ++ ; } return count ; }
function checkIfAllTogether ( s , c ) { let oneSeen = false ; let i = 0 , n = s . length ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }
function winner ( a , n , k ) { if ( k >= n - 1 ) return n ; let best = 0 , times = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
function countPairs ( P , Q , N , M ) { var A = [ 0 , 0 ] , B = [ 0 , 0 ] ; for ( var i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( var i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
function minDel ( s1 , s2 ) { var i = s1 . length ; var j = s2 . length ; while ( i > 0 && j > 0 ) { if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) { break ; } i -- ; j -- ; } return i + j ; }
function printAllAPTriplets ( arr , n ) { const s = new Set ( ) for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let diff = arr [ j ] - arr [ i ] ; if ( s . has ( arr [ i ] - diff ) ) document . write ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] + " " ) ; } s . add ( arr [ i ] ) ; } }
function maxPathSum ( tri ) { var ans = 0 ; for ( var i = N - 2 ; i >= 0 ; i -- ) { for ( var j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
function printDistSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( sum + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( var i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( var j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( var j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) document . write ( j + " " ) ; }
function find_index ( arr , n , K ) { let start = 0 ; let end = n - 1 ; while ( start <= end ) { let mid = Math . floor ( ( start + end ) / 2 ) ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
function isHexagonal ( N ) { let val = 8 * N + 1 ; let x = 1 + Math . sqrt ( val ) ; let n = ( x ) / 4 ; if ( ( n - parseInt ( n ) ) == 0 ) { return true ; } else { return false ; } } let N = 14 ; if ( isHexagonal ( N ) == true ) { document . write ( " " + " " ) ; } else { document . write ( " " ) ; }
function checkSequence ( a , b ) { if ( b . length == 0 ) return true ; if ( a . length == 0 ) return false ; if ( a [ 0 ] == b [ 0 ] ) return checkSequence ( a . substring ( 1 ) , b . substring ( 1 ) ) ; else return checkSequence ( a . substring ( 1 ) , b ) ; }
function longestCommonPrefix ( a ) { let size = a . length ; if ( size == 0 ) return " " ; if ( size == 1 ) return a [ 0 ] ; a . sort ( ) ; let end = Math . min ( a [ 0 ] . length , a [ size - 1 ] . length ) ; let i = 0 ; while ( i < end && a [ 0 ] [ i ] == a [ size - 1 ] [ i ] ) i ++ ; let pre = a [ 0 ] . substring ( 0 , i ) ; return pre ; }
function minItems ( k , r ) { for ( let i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
function printRect ( X , Y , n ) { var Xmax = X . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var Xmin = X . reduce ( ( a , b ) => Math . min ( a , b ) ) ; var Ymax = Y . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var Ymin = Y . reduce ( ( a , b ) => Math . min ( a , b ) ) ; document . write ( " " + Xmin + " " + Ymin + " " + " " ) ; document . write ( " " + Xmin + " " + Ymax + " " + " " ) ; document . write ( " " + Xmax + " " + Ymax + " " + " " ) ; document . write ( " " + Xmax + " " + Ymin + " " + " " ) ; }
function setleftmostunsetbit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; let pos = 0 ; for ( let temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
function to_upper ( In ) { let n = In . length ; for ( let i = 0 ; i < In . length ; i ++ ) if ( ' ' <= In [ i ] && In [ i ] <= ' ' ) In [ i ] = String . fromCharCode ( In [ i ] . charCodeAt ( 0 ) & ( ~ ( 1 << 5 ) ) ) ; return ( In ) . join ( " " ) ; }
function pairwiseDifference ( arr , n ) { var diff ; for ( i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; document . write ( diff + " " ) ; } }
function product ( N ) { let ans = 1 ; let val = Math . pow ( 2 , N - 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) { ans *= Math . pow ( i , val ) ; } return ans ; }
function countSetBitsRec ( num ) { var nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
function isAlphabaticOrder ( s ) { var n = s . length ; var c = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; } c . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; }
function findPairs ( N ) { for ( let i = 0 ; i <= N ; i ++ ) { document . write ( " " + i + " " + ( N - i ) + " " ) ; } }
function Convert ( radian ) { let pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
function findMinMax ( a ) { let min_val = 1000000000 ; for ( let i = 1 ; i < a . length ; ++ i ) { min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
function hasAllcodes ( s , k ) { let us = new Set ( ) ; for ( let i = 0 ; i + k <= s . length ; i ++ ) { us . add ( s . substring ( i , i + k ) ) ; } return ( us . size == ( 1 << k ) ) ; } let s = " " ; let k = 2 ; if ( hasAllcodes ( s , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function minimumSizeArr ( A , B ) { let currXor = 0 ; let reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; let minSize = A ; if ( currXor == B ) return minSize ; else if ( currXor ^ ( B == A ) ) return minSize + 2 ; else return minSize + 1 ; }
function maxEdges ( N ) { var edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
function checkSolution ( a1 , b1 , c1 , a2 , b2 , c2 ) { return ( a1 / a2 ) == ( b1 / b2 ) && ( b1 / b2 ) == ( c1 / c2 ) ; }
function MaxDotProduct ( A , B , m , n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j < m + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
function isSuffix ( s1 , s2 ) { let n1 = s1 . length , n2 = s2 . length ; if ( n1 > n2 ) return false ; for ( let i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
function maxSubArraySumRepeated ( a , n , k ) { let max_so_far = 0 ; let INT_MIN , max_ending_here = 0 ; for ( let i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
function sumOfSeries ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
function lastTwoDigits ( N ) { if ( N >= 10 ) { cout << " " ; return ; } let fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; document . write ( fac ) ; }
function maxValue ( a ) { var c = a . toString ( 2 ) ; var b = " " ; for ( var i = 0 ; i < c . length ; i ++ ) { if ( ( c [ i ] - ' ' ) == 1 ) b += ' ' ; else b += ' ' ; } document . write ( parseInt ( b , 2 ) ) ; }
function kthRoot ( n , k ) { return Math . pow ( k , ( 1.0 / k ) * ( Math . log ( n ) / Math . log ( k ) ) ) ; }
function minElements ( arr , n ) { let halfSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = parseInt ( halfSum / 2 , 10 ) ; arr . sort ( function ( a , b ) { return a - b } ) ; arr . reverse ( ) ; let res = 0 , curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
function CountCharacters ( str , l , r ) { let cnt = 0 ; let m = new Map ( ) ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) ) { cnt ++ ; if ( ! m . has ( str [ i ] ) ) { m . set ( str [ i ] , 0 ) ; document . write ( str [ i ] + " " ) ; } m . set ( str [ i ] , m . get ( str [ i ] + 1 ) ) ; } } return cnt ; }
function Solve ( N , M ) { let temp = ( N - 1 ) * ( M - 1 ) ; let ans = ( Math . pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) document . write ( ans ) ; else document . write ( 2 * ans ) ; }
function findXOR ( mat , N ) { let XOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { for ( let k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i ] [ j ] [ k ] ; XOR ^= mat [ i ] [ j ] [ N - k - 1 ] ; } } } } document . write ( XOR ) ; }
function findDistinctSums ( N ) { return ( 2 * N - 1 ) ; }
function checkSorted ( n , arr ) { var b = Array ( n ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; b . sort ( ) ; var ct = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; }
function extraElement ( A , B , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
function reArrange ( words , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) mp . set ( words [ i ] , i + 1 ) ; words . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( mp . get ( words [ i ] ) + " " ) ; } }
function findSum ( n ) { return n * ( n + 1 ) / 2 ; }
function find_Area ( a ) { var R = a * ( 2.0 - Math . sqrt ( 2 ) ) ; var area = 3.14 * R * R / 2.0 ; return area ; }
function findNum ( div , rem , N ) { var num = rem [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
function minValue ( n , x , y ) { let val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( Math . ceil ( val ) - x ) ; }
function knapSack ( W , wt , val , n ) { var maxratio = - 1000000000 ; var maxindex = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( parseInt ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
function findTriangles ( n ) { var num = n ; document . write ( num + " " ) ; document . write ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }
function sum ( n ) { let sum = 0 ; let fact = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum . toFixed ( 5 ) ; }
function k_nonzero_numbers ( s , n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = new Array ( k + 1 ) ; for ( let x = 0 ; x <= k ; x ++ ) dp [ i ] [ j ] [ x ] = 0 ; } } dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( let i = 0 ; i < n ; ++ i ) { let sm = 0 ; while ( sm < 2 ) { for ( let j = 0 ; j < k + 1 ; ++ j ) { let x = 0 ; while ( x <= ( sm != 0 ? 9 : s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) { if ( j + ( x > 0 ? 1 : 0 ) < k + 1 ) { dp [ i + 1 ] [ ( sm != 0 || x < ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ? 1 : 0 ] [ j + ( x > 0 ? 1 : 0 ) ] += dp [ i ] [ sm ] [ j ] ; } ++ x ; } } ++ sm ; } } return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] ; }
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
function is_possible ( x , y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }
function countOfMultiples ( n ) { return ( parseInt ( n / 3 , 10 ) + parseInt ( n / 5 , 10 ) - parseInt ( n / 15 , 10 ) ) ; }
function Move ( a , x , b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
function square ( a ) { if ( a < 0 ) return - 1 ; var x = 0.464 * a ; return x ; }
function isPowerOfFour ( n ) { let count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
function findPoint ( x1 , y1 , x2 , y2 ) { document . write ( " " + 2 * ( x2 - x1 ) + " " + 2 * ( y2 - y1 ) + " " ) ; }
function FirstDigit ( arr , n ) { let S = 0 ; for ( let i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; let fract_S = S - Math . floor ( S ) ; let ans = parseInt ( Math . pow ( 10 , fract_S ) , 10 ) ; return ans ; }
function findIndex ( arr , len ) { let maxIndex = 0 ; for ( let i = 0 ; i < len ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( let i = 0 ; i < len ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return - 1 ; return maxIndex ; }
function areaSquare ( side , fold ) { var area = side * side ; return ( area * 1.0 ) / ( Math . pow ( 2 , fold ) ) ; }
function countP ( n , k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
function maxOnesIndex ( arr , n ) { let max_count = 0 ; let max_index = 0 ; let prev_zero = - 1 ; let prev_prev_zero = - 1 ; for ( let curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
function countPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
function findIntersection ( intervals , N ) { let l = intervals [ 0 ] [ 0 ] ; let r = intervals [ 0 ] [ 1 ] ; for ( let i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { document . write ( - 1 + " " ) ; return ; } else { l = Math . max ( l , intervals [ i ] [ 0 ] ) ; r = Math . min ( r , intervals [ i ] [ 1 ] ) ; } } document . write ( " " + l + " " + r + " " + " " ) ; }
function movesRequired ( a , b ) { let total_moves = a % b ; document . write ( total_moves ) ; }
function countDigits ( a , b ) { if ( a == 0 b == 0 ) return 1 ; return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
function PointInKSquares ( n , a , k ) { a . sort ( ) ; return a [ n - k ] ; }
function findCount ( arr , N , K ) { arr . sort ( ) ; let result = 1 ; let cur_max = arr [ 0 ] ; let cur_min = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
function findRadiusOfIncircle ( a , b , c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; var p = ( a + b + c ) / 2 ; var area = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; var radius = area / p ; return radius ; }
function Race ( B , C ) { var result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
function nCycle ( N ) { return ( N ) * ( N - 1 ) + 1 ; }
function area_cicumscribed ( c ) { return ( c * c * ( PI / 4 ) ) ; }
function maxLen ( arr , n ) { var c_sum = 0 ; arr . sort ( ( a , b ) => b - a ) for ( var i = 0 ; i < n ; i ++ ) { c_sum += arr [ i ] ; if ( c_sum < 0 ) return i ; } return n ; }
function findArea ( a , b ) { var Area ; Area = 3.142 * a * b ; document . write ( " " + Area . toFixed ( 2 ) ) ; }
function right_angled ( n ) { var count = 0 ; for ( z = 1 ; z <= n ; z ++ ) { for ( y = 1 ; y <= z ; y ++ ) { for ( x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
function isUpperTriangularMatrix ( mat ) { for ( let i = 1 ; i < N ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
function findPairs ( arr , n ) { let cntEven = 0 , cntOdd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } let evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; let oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; document . write ( " " + oddPairs + " " ) ; document . write ( " " + evenPairs ) ; }
function countSeq ( n ) { let nCr = 1 , res = 1 ; for ( let r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
function Division ( a , n ) { let maxi = Number . MIN_VALUE , mini = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { maxi = Math . max ( a [ i ] , maxi ) ; mini = Math . min ( a [ i ] , mini ) ; } return parseInt ( maxi / mini ) ; }
function sum ( x , n ) { let total = 1.0 ; let multi = x ; for ( let i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
function maxSubmatrixSum ( matrix ) { var r = matrix . length ; var c = matrix [ 0 ] . length ; var maxSubmatrix = 0 ; for ( i = 0 ; i < r ; i ++ ) { for ( j = 0 ; j < c ; j ++ ) { for ( k = i ; k < r ; k ++ ) { for ( l = j ; l < c ; l ++ ) { var sumSubmatrix = 0 ; for ( m = i ; m <= k ; m ++ ) { for ( n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m ] [ n ] ; } } maxSubmatrix = Math . max ( maxSubmatrix , sumSubmatrix ) ; } } } } document . write ( maxSubmatrix ) ; }
function bs ( ar , n , ele ) { let start = 0 ; let end = n - 1 ; let ch = ' ' ; while ( start <= end ) { let mid = start + Math . floor ( ( end - start ) / 2 ) ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
function maxSum ( arr , n ) { if ( n < 2 ) return - 1 ; let ans = arr [ 0 ] + arr [ 1 ] ; for ( let i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
function checkOrigin ( x1 , y1 , x2 , y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
function smallest ( k , d ) { let cnt = 1 ; let m = d % k ; let v = new Array ( k ) . fill ( 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } return - 1 ; }
function Area ( r ) { if ( r < 0 ) return - 1 ; var x = ( 2 * r ) / ( Math . sqrt ( 5 ) ) ; var A = 0.70477 * ( Math . pow ( x , 2 ) ) ; return A ; }
function to_upper ( input ) { var result = new Array ( input . length ) ; for ( var i = 0 ; i < input . length ; i ++ ) if ( " " . charCodeAt ( 0 ) <= input [ i ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) result [ i ] = String . fromCharCode ( input [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) + " " . charCodeAt ( 0 ) ) ; return result . join ( " " ) . toString ( ) ; }
function sum_of_series ( n ) { var result = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - parseInt ( Math . pow ( i , 2 ) ) ; else result = result + parseInt ( Math . pow ( i , 2 ) ) ; } return result ; }
function Regions ( Vertices , Edges ) { var R = Edges + 2 - Vertices ; return R ; }
function getRemainder ( num , divisor ) { let t = ( num - divisor * parseInt ( num / divisor ) ) ; return t ; }
function Perimeter ( a , b ) { var Perimeter ; Perimeter = 2 * 3.14 * Math . sqrt ( ( a * a + b * b ) / ( 2 * 1.0 ) ) ; document . write ( " " + Perimeter ) ; }
function hectagonNum ( n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
function findDirection ( n , m ) { if ( n > m ) { if ( m % 2 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } else { if ( n % 2 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } }
function Cells ( n , x ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && parseInt ( x / i ) <= n ) ans ++ ; return ans ; }
function maximum_inversion ( n , k ) { var answer = 0 ; k = Math . min ( k , parseInt ( n / 2 ) ) ; var left = 1 ; var right = n ; while ( k > 0 ) { k -- ; answer += 2 * ( right - left ) - 1 ; left ++ ; right -- ; } document . write ( answer + " " ) ; }
function maxXOR ( mat , N ) { let r_xor , c_xor ; let max_xor = 0 ; for ( let i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( let j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }
function getLargestSum ( N ) { var max_sum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { for ( j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . max ( max_sum , i + j ) ; } } return max_sum ; }
function MinOp ( N ) { if ( N <= 1 ) return N ; let bit = ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; }
function MinimumOperations ( A , N , K ) { let Count = 0 ; let i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
function sumOfMedians ( arr , N , K ) { let selectMedian = Math . floor ( ( K + 1 ) / 2 ) ; let totalArrays = Math . floor ( N / K ) ; let minSum = 0 ; let i = selectMedian - 1 ; while ( i < N && totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } document . write ( minSum ) ; }
function strScore ( str , s , n ) { var score = 0 , index = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( j = 0 ; j < s . length ; j ++ ) { score += s . charAt ( j ) . charCodeAt ( 0 ) - ( ' ' ) . charCodeAt ( 0 ) + 1 ; } index = i + 1 ; break ; } } score = score * index ; return score ; }
function answer ( n ) { let m = 2 ; let ans = 1 ; let r = 1 ; while ( r < n ) { r = ( Math . pow ( 2 , m ) - 1 ) * ( Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
function stirlingFactorial ( n ) { if ( n == 1 ) return 1 ; let z ; let e = 2.71 ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return Math . floor ( z ) ; }
function querySum ( arr , N , Q , M ) { for ( let i = 0 ; i < M ; i ++ ) { let x = Q [ i ] [ 0 ] ; let y = Q [ i ] [ 1 ] ; let sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } document . write ( sum + " " ) ; } }
function minLength ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; }
function dodecahedral_num ( n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
