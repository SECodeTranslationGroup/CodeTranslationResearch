public ListSpeechSynthesisTasksResult listSpeechSynthesisTasks ( ListSpeechSynthesisTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeListSpeechSynthesisTasks ( request ) ; }
public UpdateJourneyStateResult updateJourneyState ( UpdateJourneyStateRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateJourneyState ( request ) ; }
public void removePresentationFormat ( ) { remove1stProperty ( PropertyIDMap . PID_PRESFORMAT ) ; }
public CellRangeAddressList ( int firstRow , int lastRow , int firstCol , int lastCol ) { this ( ) ; addCellRangeAddress ( firstRow , firstCol , lastRow , lastCol ) ; }
public void delete ( int key ) { int i = binarySearch ( mKeys , 0 , mSize , key ) ; if ( i >= 0 ) { if ( mValues [ i ] != DELETED ) { mValues [ i ] = DELETED ; mGarbage = true ; } } }
public CreateBranchCommand setStartPoint ( RevCommit startPoint ) { checkCallable ( ) ; this . startCommit = startPoint ; this . startPoint = null ; return this ; }
public int centerX ( ) { return x + w / 2 ; }
public ListPresetsResult listPresets ( ) { return listPresets ( new ListPresetsRequest ( ) ) ; }
public DeleteFolderContentsResult deleteFolderContents ( DeleteFolderContentsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFolderContents ( request ) ; }
public GetConsoleOutputResult getConsoleOutput ( GetConsoleOutputRequest request ) { request = beforeClientExecution ( request ) ; return executeGetConsoleOutput ( request ) ; }
public PutMailboxPermissionsResult putMailboxPermissions ( PutMailboxPermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executePutMailboxPermissions ( request ) ; }
public Cluster disableSnapshotCopy ( DisableSnapshotCopyRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableSnapshotCopy ( request ) ; }
public static String stripExtension ( String filename ) { int idx = filename . indexOf ( ' . ' ) ; if ( idx != - 1 ) { filename = filename . substring ( 0 , idx ) ; } return filename ; }
public ByteBuffer putInt ( int value ) { throw new ReadOnlyBufferException ( ) ; }
public int lastIndexOf ( final int o ) { int rval = _limit - 1 ; for ( ; rval >= 0 ; rval -- ) { if ( o == _array [ rval ] ) { break ; } } return rval ; }
public void setCountsByTime ( int [ ] counts , long msecStep ) { countsByTime = counts ; countsByTimeStepMSec = msecStep ; }
public FeatHdrRecord ( RecordInputStream in ) { futureHeader = new FtrHeader ( in ) ; isf_sharedFeatureType = in . readShort ( ) ; reserved = in . readByte ( ) ; cbHdrData = in . readInt ( ) ; rgbHdrData = in . readRemainder ( ) ; }
public CopyOnWriteArrayList ( ) { elements = EmptyArray . OBJECT ; }
public WriteRequest ( DeleteRequest deleteRequest ) { setDeleteRequest ( deleteRequest ) ; }
public void readFully ( byte [ ] buf ) { _in . readFully ( buf ) ; }
public static Cell getCell ( Row row , int columnIndex ) { Cell cell = row . getCell ( columnIndex ) ; if ( cell == null ) { cell = row . createCell ( columnIndex ) ; } return cell ; }
public void setPackConfig ( PackConfig pc ) { this . packConfig = pc ; }
public String getSignerName ( ) { return " HMAC - SHA1 " ; }
public IntervalSet or ( IntSet a ) { IntervalSet o = new IntervalSet ( ) ; o . addAll ( this ) ; o . addAll ( a ) ; return o ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + _value + " ] " ; }
public DescribeVpcEndpointServicePermissionsResult describeVpcEndpointServicePermissions ( DescribeVpcEndpointServicePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcEndpointServicePermissions ( request ) ; }
public static byte [ ] copyOfRange ( byte [ ] original , int start , int end ) { if ( start > end ) { throw new IllegalArgumentException ( ) ; } int originalLength = original . length ; if ( start < 0 || start > originalLength ) { throw new ArrayIndexOutOfBoundsException ( ) ; } int resultLength = end - start ; int copyLength = Math . min ( resultLength , originalLength - start ) ; byte [ ] result = new byte [ resultLength ] ; System . arraycopy ( original , start , result , 0 , copyLength ) ; return result ; }
public ListTopicsRequest ( String nextToken ) { setNextToken ( nextToken ) ; }
public void finish ( FieldInfos fis , int numDocs ) throws IOException { if ( ! pendingDocs . isEmpty ( ) ) { flush ( ) ; numDirtyChunks ++ ; } if ( numDocs != this . numDocs ) { throw new RuntimeException ( " Wrote ▁ " + this . numDocs + " ▁ docs , ▁ finish ▁ called ▁ with ▁ numDocs = " + numDocs ) ; } indexWriter . finish ( numDocs , vectorsStream . getFilePointer ( ) ) ; vectorsStream . writeVLong ( numChunks ) ; vectorsStream . writeVLong ( numDirtyChunks ) ; CodecUtil . writeFooter ( vectorsStream ) ; }
public boolean isIndexTerm ( BytesRef term , TermStats stats ) { if ( count >= interval ) { count = 1 ; return true ; } else { count ++ ; return false ; } }
public AssociateDhcpOptionsResult associateDhcpOptions ( AssociateDhcpOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateDhcpOptions ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 ) { return evaluate ( srcRowIndex , srcColumnIndex , arg0 , arg1 , arg2 , DEFAULT_ARG3 ) ; }
public void disconnect ( ) { if ( sock . isConnected ( ) ) sock . disconnect ( ) ; }
public PredictionContext add ( PredictionContext ctx ) { if ( ctx == PredictionContext . EMPTY ) return PredictionContext . EMPTY ; PredictionContext existing = cache . get ( ctx ) ; if ( existing != null ) { return existing ; } cache . put ( ctx , ctx ) ; return ctx ; }
public UploadLayerPartResult uploadLayerPart ( UploadLayerPartRequest request ) { request = beforeClientExecution ( request ) ; return executeUploadLayerPart ( request ) ; }
public String getScriptText ( ) { return getScriptText ( null , null ) ; }
public DescribeClusterSubnetGroupsResult describeClusterSubnetGroups ( ) { return describeClusterSubnetGroups ( new DescribeClusterSubnetGroupsRequest ( ) ) ; }
public char setIndex ( int position ) { if ( position < getBeginIndex ( ) || position > getEndIndex ( ) ) throw new IllegalArgumentException ( " Illegal ▁ Position : ▁ " + position ) ; index = start + position ; return current ( ) ; }
public GetPhoneNumberOrderResult getPhoneNumberOrder ( GetPhoneNumberOrderRequest request ) { request = beforeClientExecution ( request ) ; return executeGetPhoneNumberOrder ( request ) ; }
public EpsilonTransition ( ATNState target , int outermostPrecedenceReturn ) { super ( target ) ; this . outermostPrecedenceReturn = outermostPrecedenceReturn ; }
public DiffCommand setContextLines ( int contextLines ) { this . contextLines = contextLines ; return this ; }
public RejectVpcPeeringConnectionResult rejectVpcPeeringConnection ( RejectVpcPeeringConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeRejectVpcPeeringConnection ( request ) ; }
public static boolean equals ( int [ ] array1 , int [ ] array2 ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1. length != array2. length ) { return false ; } for ( int i = 0 ; i < array1. length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) { return false ; } } return true ; }
public static void main ( String [ ] args ) throws IOException { if ( args . length < 1 ) { System . err . println ( " Usage : ▁ java ▁ QualityQueriesFinder ▁ < index - dir > " ) ; System . exit ( 1 ) ; } QualityQueriesFinder qqf = new QualityQueriesFinder ( FSDirectory . open ( Paths . get ( args [ 0 ] ) ) ) ; String q [ ] = qqf . bestQueries ( " body " , 20 ) ; for ( int i = 0 ; i < q . length ; i ++ ) { System . out . println ( newline + formatQueryAsTrecTopic ( i , q [ i ] , null , null ) ) ; } }
public CharsRef ( char [ ] chars , int offset , int length ) { this . chars = chars ; this . offset = offset ; this . length = length ; assert isValid ( ) ; }
public UpdateIPSetResult updateIPSet ( UpdateIPSetRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateIPSet ( request ) ; }
public void print ( Object obj ) { print ( String . valueOf ( obj ) ) ; }
public String toString ( ) { return " IndexFileDeleter . CommitPoint ( " + segmentsFileName + " ) " ; }
public synchronized boolean waitForGeneration ( long targetGen , int maxMS ) throws InterruptedException { if ( targetGen > searchingGen ) { reopenLock . lock ( ) ; waitingGen = Math . max ( waitingGen , targetGen ) ; try { reopenCond . signal ( ) ; } finally { reopenLock . unlock ( ) ; } long startMS = System . nanoTime ( ) / 1000000 ; while ( targetGen > searchingGen ) { if ( maxMS < 0 ) { wait ( ) ; } else { long msLeft = ( startMS + maxMS ) - System . nanoTime ( ) / 1000000 ; if ( msLeft <= 0 ) { return false ; } else { wait ( msLeft ) ; } } } } return true ; }
public StringBuffer append ( boolean b ) { return append ( b ? " true " : " false " ) ; }
public ByteBuffer put ( int index , byte b ) { throw new ReadOnlyBufferException ( ) ; }
public int getLineCount ( ) { return lineCount ; }
public boolean equals ( Object o ) { return o instanceof DutchStemmer ; }
public CreateNotificationSubscriptionResult createNotificationSubscription ( CreateNotificationSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNotificationSubscription ( request ) ; }
public boolean isOutdated ( ) { return snapshot . isModified ( getFile ( ) ) ; }
public DescribeVirtualInterfacesResult describeVirtualInterfaces ( ) { return describeVirtualInterfaces ( new DescribeVirtualInterfacesRequest ( ) ) ; }
public void onChanged ( ) { buildMap ( ) ; for ( DataSetObserver o : mObservers ) { o . onChanged ( ) ; } }
public DeleteEventTrackerResult deleteEventTracker ( DeleteEventTrackerRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEventTracker ( request ) ; }
public boolean matches ( ValueEval x ) { if ( x instanceof BlankEval ) { switch ( getCode ( ) ) { case CmpOp . NONE : case CmpOp . EQ : return _value . length ( ) == 0 ; case CmpOp . NE : return _value . length ( ) != 0 ; } return false ; } if ( ! ( x instanceof StringEval ) ) { return false ; } String testedValue = ( ( StringEval ) x ) . getStringValue ( ) ; if ( testedValue . length ( ) < 1 && _value . length ( ) < 1 ) { switch ( getCode ( ) ) { case CmpOp . NONE : return true ; case CmpOp . EQ : return false ; case CmpOp . NE : return true ; } return false ; } if ( _pattern != null ) { return evaluate ( _pattern . matcher ( testedValue ) . matches ( ) ) ; } return evaluate ( testedValue . compareToIgnoreCase ( _value ) ) ; }
public ListWebsiteAuthorizationProvidersResult listWebsiteAuthorizationProviders ( ListWebsiteAuthorizationProvidersRequest request ) { request = beforeClientExecution ( request ) ; return executeListWebsiteAuthorizationProviders ( request ) ; }
public void write ( char [ ] buf , int offset , int count ) { doWrite ( buf , offset , count ) ; }
public String formatAsString ( ) { if ( isWholeColumnReference ( ) ) { returnCellReference . convertNumToColString ( _firstCell . getCol ( ) ) + " : " + CellReference . convertNumToColString ( _lastCell . getCol ( ) ) ; } StringBuilder sb = new StringBuilder ( 32 ) ; sb . append ( _firstCell . formatAsString ( ) ) ; if ( ! _isSingleCell ) { sb . append ( CELL_DELIMITER ) ; if ( _lastCell . getSheetName ( ) == null ) { sb . append ( _lastCell . formatAsString ( ) ) ; } else { _lastCell . appendCellReference ( sb ) ; } } return sb . toString ( ) ; }
public Graphics create ( ) { return new EscherGraphics ( escherGroup , workbook , foreground , font , verticalPointsPerPixel ) ; }
public DoubleDocValues ( ValueSource vs ) { this . vs = vs ; }
public static CharArraySet getDefaultStopSet ( ) { return DefaultSetHolder . DEFAULT_STOP_SET ; }
public DeleteLoadBalancerPolicyResult deleteLoadBalancerPolicy ( DeleteLoadBalancerPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLoadBalancerPolicy ( request ) ; }
public ReplicationGroup decreaseReplicaCount ( DecreaseReplicaCountRequest request ) { request = beforeClientExecution ( request ) ; return executeDecreaseReplicaCount ( request ) ; }
public Result update ( RevWalk walk ) throws IOException { requireCanDoUpdate ( ) ; try { return result = updateImpl ( walk , new Store ( ) { @ OverrideResult execute ( Result status ) throws IOException { if ( status == Result . NO_CHANGE ) return status ; return doUpdate ( status ) ; } } ) ; } catch ( IOException x ) { result = Result . IO_FAILURE ; throw x ; } }
public Set < String > getChanged ( ) { return Collections . unmodifiableSet ( diff . getChanged ( ) ) ; }
public static String toHex ( long value ) { StringBuilder sb = new StringBuilder ( 16 ) ; writeHex ( sb , value , 16 , " " ) ; return sb . toString ( ) ; }
public int createPlaceholder ( ) { return _offset ++ ; }
@ Override public boolean equals ( Object o ) { if ( o instanceof Map . Entry ) { Map . Entry other = ( Map . Entry ) o ; return ( key == null ? other . getKey ( ) == null : key . equals ( other . getKey ( ) ) ) && ( value == null ? other . getValue ( ) == null : value . equals ( other . getValue ( ) ) ) ; } return false ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { double result ; try { double d0 = NumericFunction . singleOperandEvaluate ( arg0 , srcRowIndex , srcColumnIndex ) ; double d1 = NumericFunction . singleOperandEvaluate ( arg1 , srcRowIndex , srcColumnIndex ) ; double logE = Math . log ( d0 ) ; if ( Double . compare ( d1 , Math . E ) == 0 ) { result = logE ; } else { result = logE / Math . log ( d1 ) ; } NumericFunction . checkValue ( result ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public DeleteFilterResult deleteFilter ( DeleteFilterRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFilter ( request ) ; }
public CreateInstanceSnapshotResult createInstanceSnapshot ( CreateInstanceSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateInstanceSnapshot ( request ) ; }
public List < Token > getTokens ( int start , int stop ) { return getTokens ( start , stop , null ) ; }
public static TermGroupFacetCollector createTermGroupFacetCollector ( String groupField , String facetField , boolean facetFieldMultivalued , BytesRef facetPrefix , int initialSize ) { if ( facetFieldMultivalued ) { return new MV ( groupField , facetField , facetPrefix , initialSize ) ; } else { return new SV ( groupField , facetField , facetPrefix , initialSize ) ; } }
public RenameAlbumRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " RenameAlbum " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
@ Override public boolean contains ( Object object ) { synchronized ( mutex ) { return c . contains ( object ) ; } }
public CharBuffer put ( char [ ] src , int srcOffset , int charCount ) { if ( charCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } System . arraycopy ( src , srcOffset , backingArray , offset + position , charCount ) ; position += charCount ; return this ; }
public LegendRecord ( RecordInputStream in ) { field_1_xAxisUpperLeft = in . readInt ( ) ; field_2_yAxisUpperLeft = in . readInt ( ) ; field_3_xSize = in . readInt ( ) ; field_4_ySize = in . readInt ( ) ; field_5_type = in . readByte ( ) ; field_6_spacing = in . readByte ( ) ; field_7_options = in . readShort ( ) ; }
public static byte [ ] encodedTypeString ( int typeCode ) { switch ( typeCode ) { case OBJ_COMMIT : return ENCODED_TYPE_COMMIT ; case OBJ_TREE : return ENCODED_TYPE_TREE ; case OBJ_BLOB : return ENCODED_TYPE_BLOB ; case OBJ_TAG : return ENCODED_TYPE_TAG ; default : throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . badObjectType , Integer . valueOf ( typeCode ) ) ) ; } }
public ObjectId getCalulatedPatchId ( ) { return ObjectId . fromRaw ( digest . digest ( ) ) ; }
public DefaultRowHeightRecord ( ) { field_1_option_flags = 0x0000 ; field_2_row_height = DEFAULT_ROW_HEIGHT ; }
public final ByteBuffer encode ( CharBuffer buffer ) { try { return newEncoder ( ) . onMalformedInput ( CodingErrorAction . REPLACE ) . onUnmappableCharacter ( CodingErrorAction . REPLACE ) . encode ( buffer ) ; } catch ( CharacterCodingException ex ) { throw new Error ( ex . getMessage ( ) , ex ) ; } }
public final FloatBuffer get ( float [ ] dst , int dstOffset , int floatCount ) { if ( floatCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } System . arraycopy ( backingArray , offset + position , dst , dstOffset , floatCount ) ; position += floatCount ; return this ; }
public boolean hasNext ( ) { return nextEntry != null ; }
public DeleteNatGatewayResult deleteNatGateway ( DeleteNatGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNatGateway ( request ) ; }
public String resolveNameXText ( int refIndex , int definedNameIndex ) { return linkTable . resolveNameXText ( refIndex , definedNameIndex , this ) ; }
public void setMultiFields ( CharSequence [ ] fields ) { if ( fields == null ) { fields = new CharSequence [ 0 ] ; } getQueryConfigHandler ( ) . set ( ConfigurationKeys . MULTI_FIELDS , fields ) ; }
public boolean isCancelled ( ) { lock . lock ( ) ; try { return pm . isCancelled ( ) ; } finally { lock . unlock ( ) ; } }
public RemoveTargetsResult removeTargets ( RemoveTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveTargets ( request ) ; }
public FuzzyQuery ( Term term , int maxEdits , int prefixLength , int maxExpansions , boolean transpositions ) { super ( term . field ( ) ) ; if ( maxEdits < 0 || maxEdits > LevenshteinAutomata . MAXIMUM_SUPPORTED_DISTANCE ) { throw new IllegalArgumentException ( " maxEdits ▁ must ▁ be ▁ between ▁ 0 ▁ and ▁ " + LevenshteinAutomata . MAXIMUM_SUPPORTED_DISTANCE ) ; } if ( prefixLength < 0 ) { throw new IllegalArgumentException ( " prefixLength ▁ cannot ▁ be ▁ negative . " ) ; } if ( maxExpansions <= 0 ) { throw new IllegalArgumentException ( " maxExpansions ▁ must ▁ be ▁ positive . " ) ; } this . term = term ; this . maxEdits = maxEdits ; this . prefixLength = prefixLength ; this . transpositions = transpositions ; this . maxExpansions = maxExpansions ; int [ ] codePoints = FuzzyTermsEnum . stringToUTF32 ( term . text ( ) ) ; this . termLength = codePoints . length ; this . automata = FuzzyTermsEnum . buildAutomata ( term . text ( ) , codePoints , prefixLength , transpositions , maxEdits ) ; setRewriteMethod ( new MultiTermQuery . TopTermsBlendedFreqScoringRewrite ( maxExpansions ) ) ; this . ramBytesUsed = calculateRamBytesUsed ( term , this . automata ) ; }
public CheckoutCommand checkout ( ) { return new CheckoutCommand ( repo ) ; }
public ValueEval evaluate ( String sheetName , int rowIndex , int columnIndex ) { EvaluationCell cell = _sewb . getEvaluationCell ( sheetName , rowIndex , columnIndex ) ; switch ( cell . getCellType ( ) ) { case BOOLEAN : return BoolEval . valueOf ( cell . getBooleanCellValue ( ) ) ; case ERROR : return ErrorEval . valueOf ( cell . getErrorCellValue ( ) ) ; case FORMULA : return _evaluator . evaluate ( cell ) ; case NUMERIC : return new NumberEval ( cell . getNumericCellValue ( ) ) ; case STRING : return new StringEval ( cell . getStringCellValue ( ) ) ; case BLANK : return null ; default : throw new IllegalStateException ( " Bad ▁ cell ▁ type ▁ ( " + cell . getCellType ( ) + " ) " ) ; } }
public PutFileSystemPolicyResult putFileSystemPolicy ( PutFileSystemPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executePutFileSystemPolicy ( request ) ; }
public long fileLength ( String name ) throws IOException { ensureOpen ( ) ; FileEntry e = entries . get ( IndexFileNames . stripSegmentName ( name ) ) ; if ( e == null ) throw new FileNotFoundException ( name ) ; return e . length ; }
public DescribeCacheClustersResult describeCacheClusters ( ) { return describeCacheClusters ( new DescribeCacheClustersRequest ( ) ) ; }
public void setObjectId ( RevObject obj ) { setObjectId ( obj , obj . getType ( ) ) ; }
public boolean rowHasCells ( int row ) { if ( row >= records . length ) { return false ; } CellValueRecordInterface [ ] rowCells = records [ row ] ; if ( rowCells == null ) return false ; for ( int col = 0 ; col < rowCells . length ; col ++ ) { if ( rowCells [ col ] != null ) return true ; } return false ; }
public TokenStream create ( TokenStream input ) { return new SpanishLightStemFilter ( input ) ; }
public StoredField ( String name , double value ) { super ( name , TYPE ) ; fieldsData = value ; }
public DescribePublicIpv4PoolsResult describePublicIpv4Pools ( DescribePublicIpv4PoolsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribePublicIpv4Pools ( request ) ; }
public IndexRevision ( IndexWriter writer ) throws IOException { IndexDeletionPolicy delPolicy = writer . getConfig ( ) . getIndexDeletionPolicy ( ) ; if ( ! ( delPolicy instanceof SnapshotDeletionPolicy ) ) { throw new IllegalArgumentException ( " IndexWriter ▁ must ▁ be ▁ created ▁ with ▁ SnapshotDeletionPolicy " ) ; } this . writer = writer ; this . sdp = ( SnapshotDeletionPolicy ) delPolicy ; this . commit = sdp . snapshot ( ) ; this . version = revisionVersion ( commit ) ; this . sourceFiles = revisionFiles ( commit ) ; }
public void setTabIdArray ( short [ ] array ) { _tabids = array . clone ( ) ; }
public UpdateObjectAttributesResult updateObjectAttributes ( UpdateObjectAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateObjectAttributes ( request ) ; }
public GetGameSessionLogUrlResult getGameSessionLogUrl ( GetGameSessionLogUrlRequest request ) { request = beforeClientExecution ( request ) ; return executeGetGameSessionLogUrl ( request ) ; }
public RefCount ( T object ) { this . object = object ; }
public ByteBuffer put ( int index , byte b ) { checkIndex ( index ) ; backingArray [ offset + index ] = b ; return this ; }
public IntervalSet LOOK ( ATNState s , ATNState stopState , RuleContext ctx ) { IntervalSet r = new IntervalSet ( ) ; boolean seeThruPreds = true ; PredictionContext lookContext = ctx != null ? PredictionContext . fromRuleContext ( s . atn , ctx ) : null ; _LOOK ( s , stopState , lookContext , r , new HashSet < ATNConfig > ( ) , new BitSet ( ) , seeThruPreds , true ) ; return r ; }
public int getValidationType ( ) { return _validationType ; }
public DeleteTagCommand tagDelete ( ) { return new DeleteTagCommand ( repo ) ; }
public SortRescorer ( Sort sort ) { this . sort = sort ; }
public void verifyBelongsToWorkbook ( HSSFWorkbook wb ) { if ( wb . getWorkbook ( ) != _workbook ) { throw new IllegalArgumentException ( " This ▁ Style ▁ does ▁ not ▁ belong ▁ to ▁ the ▁ supplied ▁ Workbook . ▁ Are ▁ you ▁ trying ▁ to ▁ assign ▁ a ▁ style ▁ from ▁ one ▁ workbook ▁ to ▁ the ▁ cell ▁ of ▁ a ▁ differnt ▁ workbook ? " ) ; } }
public StringBuffer insert ( int index , Object obj ) { return insert ( index , obj == null ? " null " : obj . toString ( ) ) ; }
public boolean containsKey ( CharSequence cs ) { if ( cs == null ) throw new NullPointerException ( ) ; return false ; }
public int compareTo ( HSSFRichTextString r ) { return _string . compareTo ( r . _string ) ; }
public RequestSpotInstancesRequest ( String spotPrice ) { setSpotPrice ( spotPrice ) ; }
public ObjectId getNewObjectId ( ) { return newObjectId ; }
public void setDeltaBaseAsOffset ( boolean deltaBaseAsOffset ) { this . deltaBaseAsOffset = deltaBaseAsOffset ; }
public LengthFilterFactory ( Map < String , String > args ) { super ( args ) ; min = requireInt ( args , MIN_KEY ) ; max = requireInt ( args , MAX_KEY ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public TruncateTokenFilter ( TokenStream input , int length ) { super ( input ) ; if ( length < 1 ) throw new IllegalArgumentException ( " length ▁ parameter ▁ must ▁ be ▁ a ▁ positive ▁ number : ▁ " + length ) ; this . length = length ; }
public ListDomainsResult listDomains ( ) { return listDomains ( new ListDomainsRequest ( ) ) ; }
public ArabicStemFilter create ( TokenStream input ) { return new ArabicStemFilter ( input ) ; }
public PushCommand setRefSpecs ( RefSpec ... specs ) { checkCallable ( ) ; this . refSpecs . clear ( ) ; Collections . addAll ( refSpecs , specs ) ; return this ; }
public BlameGenerator setDiffAlgorithm ( DiffAlgorithm algorithm ) { diffAlgorithm = algorithm ; return this ; }
public GroupingSearch setIncludeMaxScore ( boolean includeMaxScore ) { this . includeMaxScore = includeMaxScore ; return this ; }
public Field [ ] createIndexableFields ( Shape shape ) { double distErr = SpatialArgs . calcDistanceFromErrPct ( shape , distErrPct , ctx ) ; return createIndexableFields ( shape , distErr ) ; }
public PutMethodResponseResult putMethodResponse ( PutMethodResponseRequest request ) { request = beforeClientExecution ( request ) ; return executePutMethodResponse ( request ) ; }
public LegacyCredentials ( Credential legacyCrendential ) { this . legacyCredential = legacyCrendential ; }
public DescribeFeatureTransformationResult describeFeatureTransformation ( DescribeFeatureTransformationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFeatureTransformation ( request ) ; }
public DeleteRouteResult deleteRoute ( DeleteRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRoute ( request ) ; }
public AssociatePhoneNumbersWithVoiceConnectorResult associatePhoneNumbersWithVoiceConnector ( AssociatePhoneNumbersWithVoiceConnectorRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociatePhoneNumbersWithVoiceConnector ( request ) ; }
public long ramBytesUsed ( ) { long size = BASE_RAM_BYTES_USED + RamUsageEstimator . shallowSizeOf ( blocks ) ; if ( blocks . length > 0 ) { size += ( blocks . length - 1 ) * bytesUsedPerBlock ; size += RamUsageEstimator . sizeOf ( blocks [ blocks . length - 1 ] ) ; } return size ; }
public short readShort ( ) { return _in . readShort ( ) ; }
public UpdatePipelineNotificationsResult updatePipelineNotifications ( UpdatePipelineNotificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdatePipelineNotifications ( request ) ; }
public StringWriter append ( char c ) { write ( c ) ; return this ; }
public Iterator < V > iterator ( ) { return new ValueIterator ( ) ; }
public UnitsRecord ( RecordInputStream in ) { field_1_units = in . readShort ( ) ; }
public boolean isEmpty ( ) { return first ; }
public String toString ( ) { return " ANY □ DIFF " ; }
public UpdateDomainNameResult updateDomainName ( UpdateDomainNameRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDomainName ( request ) ; }
public DeleteSnapshotRequest ( String snapshotId ) { setSnapshotId ( snapshotId ) ; }
public void readFully ( byte [ ] buf ) { readFully ( buf , 0 , buf . length ) ; }
public SliceReader ( IntBlockPool pool ) { this . pool = pool ; }
public void setDeltaSearchMemoryLimit ( long memoryLimit ) { deltaSearchMemoryLimit = memoryLimit ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ BOOKBOOL ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . savelinkvalues ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getSaveLinkValues ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / BOOKBOOL ] \ n " ) ; return buffer . toString ( ) ; }
public DescribeTransitGatewayAttachmentsResult describeTransitGatewayAttachments ( DescribeTransitGatewayAttachmentsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTransitGatewayAttachments ( request ) ; }
public CreateVpcResult createVpc ( CreateVpcRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVpc ( request ) ; }
public DescribeElasticGpusResult describeElasticGpus ( DescribeElasticGpusRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeElasticGpus ( request ) ; }
public IntBuffer put ( int c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } byteBuffer . putInt ( position ++ * SizeOf . INT , c ) ; return this ; }
public UpdateEndpointsBatchResult updateEndpointsBatch ( UpdateEndpointsBatchRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateEndpointsBatch ( request ) ; }
public void fromRaw ( byte [ ] bs , int p ) { w1 = NB . decodeInt32 ( bs , p ) ; w2 = NB . decodeInt32 ( bs , p + 4 ) ; w3 = NB . decodeInt32 ( bs , p + 8 ) ; w4 = NB . decodeInt32 ( bs , p + 12 ) ; w5 = NB . decodeInt32 ( bs , p + 16 ) ; }
public static OpenSshConfig get ( FS fs ) { File home = fs . userHome ( ) ; if ( home == null ) home = new File ( " . " ) . getAbsoluteFile ( ) ; final File config = new File ( new File ( home , SshConstants . SSH_DIR ) , SshConstants . CONFIG ) ; return new OpenSshConfig ( home , config ) ; }
public VCenterRecord ( RecordInputStream in ) { field_1_vcenter = in . readShort ( ) ; }
public synchronized InputStream obtainFile ( String sessionID , String source , String fileName ) throws IOException { ensureOpen ( ) ; ReplicationSession session = sessions . get ( sessionID ) ; if ( session != null && session . isExpired ( expirationThresholdMilllis ) ) { releaseSession ( sessionID ) ; session = null ; } if ( session == null ) { throw new SessionExpiredException ( " session ▁ ( " + sessionID + " ) ▁ expired ▁ while ▁ obtaining ▁ file : ▁ source = " + source + " ▁ file = " + fileName ) ; } sessions . get ( sessionID ) . markAccessed ( ) ; return session . revision . revision . open ( source , fileName ) ; }
public DownloadDefaultKeyPairResult downloadDefaultKeyPair ( DownloadDefaultKeyPairRequest request ) { request = beforeClientExecution ( request ) ; return executeDownloadDefaultKeyPair ( request ) ; }
public DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult describeLocalGatewayRouteTableVirtualInterfaceGroupAssociations ( DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations ( request ) ; }
public ResetEbsDefaultKmsKeyIdResult resetEbsDefaultKmsKeyId ( ResetEbsDefaultKmsKeyIdRequest request ) { request = beforeClientExecution ( request ) ; return executeResetEbsDefaultKmsKeyId ( request ) ; }
public int getPropertiesPerBlock ( ) { return bigBlockSize / POIFSConstants . PROPERTY_SIZE ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval numberVE ) { return this . evaluate ( srcRowIndex , srcColumnIndex , numberVE , null ) ; }
public GetFindingsStatisticsResult getFindingsStatistics ( GetFindingsStatisticsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFindingsStatistics ( request ) ; }
public DBCluster modifyDBCluster ( ModifyDBClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBCluster ( request ) ; }
public LimitTokenCountFilterFactory ( Map < String , String > args ) { super ( args ) ; maxTokenCount = requireInt ( args , MAX_TOKEN_COUNT_KEY ) ; consumeAllTokens = getBoolean ( args , CONSUME_ALL_TOKENS_KEY , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public MatchNoDocsQuery build ( QueryNode queryNode ) throws QueryNodeException { if ( ! ( queryNode instanceof MatchNoDocsQueryNode ) ) { throw new QueryNodeException ( new MessageImpl ( QueryParserMessages . LUCENE_QUERY_CONVERSION_ERROR , queryNode . toQueryString ( new EscapeQuerySyntaxImpl ( ) ) , queryNode . getClass ( ) . getName ( ) ) ) ; } return new MatchNoDocsQuery ( ) ; }
public GetUserPolicyRequest ( String userName , String policyName ) { setUserName ( userName ) ; setPolicyName ( policyName ) ; }
public Cluster rotateEncryptionKey ( RotateEncryptionKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeRotateEncryptionKey ( request ) ; }
public int getLinesAdded ( ) { return nAdded ; }
public List < Token > getHiddenTokensToLeft ( int tokenIndex , int channel ) { lazyInit ( ) ; if ( tokenIndex < 0 || tokenIndex >= tokens . size ( ) ) { throw new IndexOutOfBoundsException ( tokenIndex + " ▁ not ▁ in ▁ 0.. " + ( tokens . size ( ) - 1 ) ) ; } if ( tokenIndex == 0 ) { return null ; } int prevOnChannel = previousTokenOnChannel ( tokenIndex - 1 , Lexer . DEFAULT_TOKEN_CHANNEL ) ; if ( prevOnChannel == tokenIndex - 1 ) return null ; int from = prevOnChannel + 1 ; int to = tokenIndex - 1 ; return filterForChannel ( from , to , channel ) ; }
public ValidDBInstanceModificationsMessage describeValidDBInstanceModifications ( DescribeValidDBInstanceModificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeValidDBInstanceModifications ( request ) ; }
public final void add ( RevFlag flag ) { flags |= flag . mask ; }
public void clear ( ) { Iterator < E > it = iterator ( ) ; while ( it . hasNext ( ) ) { it . next ( ) ; it . remove ( ) ; } }
public RegisterImageResult registerImage ( RegisterImageRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterImage ( request ) ; }
public boolean equals ( Object other ) { return sameClassAs ( other ) && term . equals ( ( ( TermQuery ) other ) . term ) ; }
public URI ( String scheme , String authority , String path , String query , String fragment ) throws URISyntaxException { if ( scheme != null && path != null && ! path . isEmpty ( ) && path . charAt ( 0 ) != ' / ' ) { throw new URISyntaxException ( path , " Relative ▁ path " ) ; } StringBuilder uri = new StringBuilder ( ) ; if ( scheme != null ) { uri . append ( scheme ) ; uri . append ( ' : ' ) ; } if ( authority != null ) { uri . append ( " " ) ; AUTHORITY_ENCODER . appendEncoded ( uri , authority ) ; } if ( path != null ) { PATH_ENCODER . appendEncoded ( uri , path ) ; } if ( query != null ) { uri . append ( ' ? ' ) ; ALL_LEGAL_ENCODER . appendEncoded ( uri , query ) ; } if ( fragment != null ) { uri . append ( ' # ' ) ; ALL_LEGAL_ENCODER . appendEncoded ( uri , fragment ) ; } parseURI ( uri . toString ( ) , false ) ; }
public BlameGenerator ( Repository repository , String path ) { this . repository = repository ; this . resultPath = PathFilter . create ( path ) ; idBuf = new MutableObjectId ( ) ; setFollowFileRenames ( true ) ; initRevPool ( false ) ; remaining = - 1 ; }
public synchronized void writeTo ( OutputStream out ) throws IOException { out . write ( buf , 0 , count ) ; }
public DeletableItem ( String name , java . util . List < Attribute > attributes ) { setName ( name ) ; setAttributes ( attributes ) ; }
public DescribeGroupResult describeGroup ( DescribeGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeGroup ( request ) ; }
public EnableVpcClassicLinkResult enableVpcClassicLink ( EnableVpcClassicLinkRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableVpcClassicLink ( request ) ; }
public DescribeStacksResult describeStacks ( ) { return describeStacks ( new DescribeStacksRequest ( ) ) ; }
public CharBuffer duplicate ( ) { return copy ( this ) ; }
public static double mod ( double n , double d ) { if ( d == 0 ) { return Double . NaN ; } else if ( sign ( n ) == sign ( d ) ) { return n % d ; } else { return ( ( n % d ) + d ) % d ; } }
public static String getLocalizedMessage ( String key , Locale locale ) { Object message = getResourceBundleObject ( key , locale ) ; if ( message == null ) { return " Message ▁ with ▁ key : " + key + " ▁ and ▁ locale : ▁ " + locale + " ▁ not ▁ found . " ; } return message . toString ( ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { if ( getChild ( ) == null ) return " " ; return getChild ( ) . toQueryString ( escapeSyntaxParser ) + " ^ " + getValueString ( ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { if ( getChild ( ) == null ) return " " ; return " ( ▁ " + getChild ( ) . toQueryString ( escapeSyntaxParser ) + " ▁ ) " ; }
public GetInvalidationResult getInvalidation ( GetInvalidationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInvalidation ( request ) ; }
public String formatAsString ( ) { return formatAsString ( null , false ) ; }
public final int prefixCompare ( byte [ ] bs , int p ) { int cmp ; cmp = NB . compareUInt32 ( w1 , mask ( 1 , NB . decodeInt32 ( bs , p ) ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w2 , mask ( 2 , NB . decodeInt32 ( bs , p + 4 ) ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w3 , mask ( 3 , NB . decodeInt32 ( bs , p + 8 ) ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w4 , mask ( 4 , NB . decodeInt32 ( bs , p + 12 ) ) ) ; if ( cmp != 0 ) return cmp ; return NB . compareUInt32 ( w5 , mask ( 5 , NB . decodeInt32 ( bs , p + 16 ) ) ) ; }
public AddApplicationInputProcessingConfigurationResult addApplicationInputProcessingConfiguration ( AddApplicationInputProcessingConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeAddApplicationInputProcessingConfiguration ( request ) ; }
public static TermRangeQuery newStringRange ( String field , String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper ) { BytesRef lower = lowerTerm == null ? null : new BytesRef ( lowerTerm ) ; BytesRef upper = upperTerm == null ? null : new BytesRef ( upperTerm ) ; return new TermRangeQuery ( field , lower , upper , includeLower , includeUpper ) ; }
static public double fv ( double r , int nper , double pmt , double pv , int type ) { return - ( pv * Math . pow ( 1 + r , nper ) + pmt * ( 1 + r * type ) * ( Math . pow ( 1 + r , nper ) - 1 ) / r ) ; }
public int checkExternSheet ( int firstSheetIndex , int lastSheetIndex ) { int thisWbIndex = - 1 ; for ( int i = 0 ; i < _externalBookBlocks . length ; i ++ ) { SupBookRecord ebr = _externalBookBlocks [ i ] . getExternalBookRecord ( ) ; if ( ebr . isInternalReferences ( ) ) { thisWbIndex = i ; break ; } } if ( thisWbIndex < 0 ) { throw new RuntimeException ( " Could ▁ not ▁ find ▁ ' internal references ' ▁ EXTERNALBOOK " ) ; } int i = _externSheetRecord . getRefIxForSheet ( thisWbIndex , firstSheetIndex , lastSheetIndex ) ; if ( i >= 0 ) { return i ; } return _externSheetRecord . addRef ( thisWbIndex , firstSheetIndex , lastSheetIndex ) ; }
public DescribeSentimentDetectionJobResult describeSentimentDetectionJob ( DescribeSentimentDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSentimentDetectionJob ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ UNITS ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . units ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getUnits ( ) ) ) . append ( " ▁ ( " ) . append ( getUnits ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " [ / UNITS ] \ n " ) ; return buffer . toString ( ) ; }
public NavigableMap < K , V > tailMap ( K from , boolean inclusive ) { Bound fromBound = inclusive ? INCLUSIVE : EXCLUSIVE ; return subMap ( from , fromBound , null , NO_BOUND ) ; }
public static int compareTo ( Ref o1 , Ref o2 ) { return o1. getName ( ) . compareTo ( o2. getName ( ) ) ; }
public PutEventsConfigurationResult putEventsConfiguration ( PutEventsConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executePutEventsConfiguration ( request ) ; }
public DetachFromIndexResult detachFromIndex ( DetachFromIndexRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachFromIndex ( request ) ; }
public RebaseCommand rebase ( ) { return new RebaseCommand ( repo ) ; }
public SearchGroup < T > next ( ) { assert iter . hasNext ( ) ; final SearchGroup < T > group = iter . next ( ) ; if ( group . sortValues == null ) { throw new IllegalArgumentException ( " group . sortValues ▁ is ▁ null ; ▁ you ▁ must ▁ pass ▁ fillFields = true ▁ to ▁ the ▁ first ▁ pass ▁ collector " ) ; } return group ; }
public UpdateMLModelResult updateMLModel ( UpdateMLModelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateMLModel ( request ) ; }
public CreateIPSetResult createIPSet ( CreateIPSetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateIPSet ( request ) ; }
public FieldDateResolutionFCListener ( QueryConfigHandler config ) { this . config = config ; }
@ Override public boolean containsValue ( Object value ) { HashMapEntry [ ] tab = table ; int len = tab . length ; if ( value == null ) { for ( int i = 0 ; i < len ; i ++ ) { for ( HashMapEntry e = tab [ i ] ; e != null ; e = e . next ) { if ( e . value == null ) { return true ; } } } return entryForNullKey != null && entryForNullKey . value == null ; } for ( int i = 0 ; i < len ; i ++ ) { for ( HashMapEntry e = tab [ i ] ; e != null ; e = e . next ) { if ( value . equals ( e . value ) ) { return true ; } } } return entryForNullKey != null && value . equals ( entryForNullKey . value ) ; }
public DescribeWorkspaceBundlesResult describeWorkspaceBundles ( DescribeWorkspaceBundlesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWorkspaceBundles ( request ) ; }
public PostingsEnum reset ( int [ ] postings ) { this . postings = postings ; upto = - 1 ; return this ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( sid ) ; out . writeShort ( _reserved0 ) ; out . writeInt ( _engineId ) ; }
public static CharBuffer allocate ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( ) ; } return new ReadWriteCharArrayBuffer ( capacity ) ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " >= " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public DeletePipelineResult deletePipeline ( DeletePipelineRequest request ) { request = beforeClientExecution ( request ) ; return executeDeletePipeline ( request ) ; }
public InterfaceHdrRecord ( int codePage ) { _codepage = codePage ; }
public DescribeScalingParametersResult describeScalingParameters ( DescribeScalingParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeScalingParameters ( request ) ; }
public Entry < K , V > higherEntry ( K key ) { return immutableCopy ( findBounded ( key , HIGHER ) ) ; }
public CreateSpotDatafeedSubscriptionRequest ( String bucket ) { setBucket ( bucket ) ; }
public String getLocalizedMessage ( ) { return getLocalizedMessage ( Locale . getDefault ( ) ) ; }
public UDFFinder getUDFFinder ( ) { return _uBook . getUDFFinder ( ) ; }
public ExternalName getExternalName ( String nameName , String sheetName , int externalWorkbookNumber ) { throw new IllegalStateException ( " XSSF - style ▁ external ▁ names ▁ are ▁ not ▁ supported ▁ for ▁ HSSF " ) ; }
public OldFormulaRecord ( RecordInputStream ris ) { super ( ris , ris . getSid ( ) == biff2_sid ) ; if ( isBiff2 ( ) ) { field_4_value = ris . readDouble ( ) ; } else { long valueLongBits = ris . readLong ( ) ; specialCachedValue = FormulaSpecialCachedValue . create ( valueLongBits ) ; if ( specialCachedValue == null ) { field_4_value = Double . longBitsToDouble ( valueLongBits ) ; } } if ( isBiff2 ( ) ) { field_5_options = ( short ) ris . readUByte ( ) ; } else { field_5_options = ris . readShort ( ) ; } int expression_len = ris . readShort ( ) ; int nBytesAvailable = ris . available ( ) ; field_6_parsed_expr = Formula . read ( expression_len , ris , nBytesAvailable ) ; }
public int stem ( char s [ ] , int len ) { assert s . length >= len + 1 : " this ▁ stemmer ▁ requires ▁ an ▁ oversized ▁ array ▁ of ▁ at ▁ least ▁ 1 " ; len = plural . apply ( s , len ) ; len = unification . apply ( s , len ) ; len = adverb . apply ( s , len ) ; int oldlen ; do { oldlen = len ; len = augmentative . apply ( s , len ) ; } while ( len != oldlen ) ; oldlen = len ; len = noun . apply ( s , len ) ; if ( len == oldlen ) { len = verb . apply ( s , len ) ; } len = vowel . apply ( s , len ) ; for ( int i = 0 ; i < len ; i ++ ) switch ( s [ i ] ) { case ' á ' : s [ i ] = ' a ' ; break ; case ' é ' : case ' ê ' : s [ i ] = ' e ' ; break ; case ' í ' : s [ i ] = ' i ' ; break ; case ' ó ' : s [ i ] = ' o ' ; break ; case ' ú ' : s [ i ] = ' u ' ; break ; } return len ; }
public boolean sameProperties ( FontRecord other ) { returnfield_1_font_height == other . field_1_font_height && field_2_attributes == other . field_2_attributes && field_3_color_palette_index == other . field_3_color_palette_index && field_4_bold_weight == other . field_4_bold_weight && field_5_super_sub_script == other . field_5_super_sub_script && field_6_underline == other . field_6_underline && field_7_family == other . field_7_family && field_8_charset == other . field_8_charset && field_9_zero == other . field_9_zero && Objects . equals ( this . field_11_font_name , other . field_11_font_name ) ; }
public String toFormulaString ( ) { return FormulaError . REF . getString ( ) ; }
public StartTextDetectionResult startTextDetection ( StartTextDetectionRequest request ) { request = beforeClientExecution ( request ) ; return executeStartTextDetection ( request ) ; }
public DeleteMessageBatchRequestEntry ( String id , String receiptHandle ) { setId ( id ) ; setReceiptHandle ( receiptHandle ) ; }
public PatternCaptureGroupTokenFilter create ( TokenStream input ) { return new PatternCaptureGroupTokenFilter ( input , preserveOriginal , pattern ) ; }
public SigningCertificate ( String userName , String certificateId , String certificateBody , StatusType status ) { setUserName ( userName ) ; setCertificateId ( certificateId ) ; setCertificateBody ( certificateBody ) ; setStatus ( status . toString ( ) ) ; }
public DistributionConfig ( String callerReference , Boolean enabled ) { setCallerReference ( callerReference ) ; setEnabled ( enabled ) ; }
public FastCharStream ( Reader r ) { input = r ; }
public int end ( int group ) { ensureMatch ( ) ; return matchOffsets [ ( group * 2 ) + 1 ] ; }
public final Map . Entry < K , V > next ( ) { return nextEntry ( ) ; }
public BlameCommand setTextComparator ( RawTextComparator textComparator ) { this . textComparator = textComparator ; return this ; }
public final T pop ( ) { if ( size > 0 ) { T result = heap [ 1 ] ; heap [ 1 ] = heap [ size ] ; heap [ size ] = null ; size -- ; downHeap ( 1 ) ; return result ; } else { return null ; } }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ( fields = " + fields . size ( ) + " , delegate = " + postingsReader + " ) " ; }
public static String shortenRefName ( String noteRefName ) { if ( noteRefName . startsWith ( Constants . R_NOTES ) ) return noteRefName . substring ( Constants . R_NOTES . length ( ) ) ; return noteRefName ; }
public DescribeDomainsResult describeDomains ( ) { return describeDomains ( new DescribeDomainsRequest ( ) ) ; }
public int available ( ) { return ccis . available ( ) ; }
public GetContentModerationResult getContentModeration ( GetContentModerationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetContentModeration ( request ) ; }
public PrintStream ( OutputStream out ) { super ( out ) ; if ( out == null ) { throw new NullPointerException ( ) ; } }
public long ramBytesUsed ( ) { long ramBytesUsed = postingsReader . ramBytesUsed ( ) ; for ( TermsReader r : fields . values ( ) ) { ramBytesUsed += r . ramBytesUsed ( ) ; } return ramBytesUsed ; }
public GetIntegrationResult getIntegration ( GetIntegrationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIntegration ( request ) ; }
public void setVisibility ( int v ) { if ( getVisibility ( ) != v ) { super . setVisibility ( v ) ; if ( mIndeterminate ) { if ( v == GONE || v == INVISIBLE ) { stopAnimation ( ) ; } else { startAnimation ( ) ; } } } }
public boolean matches ( char s [ ] , int len ) { if ( ! super . matches ( s , len ) ) return false ; for ( int i = 0 ; i < exceptions . length ; i ++ ) if ( endsWith ( s , len , exceptions [ i ] ) ) return false ; return true ; }
public DescribeFleetCapacityResult describeFleetCapacity ( DescribeFleetCapacityRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFleetCapacity ( request ) ; }
public UploadPackInternalServerErrorException ( Throwable why ) { initCause ( why ) ; }
public GetNetworkResult getNetwork ( GetNetworkRequest request ) { request = beforeClientExecution ( request ) ; return executeGetNetwork ( request ) ; }
public AllocatePrivateVirtualInterfaceResult allocatePrivateVirtualInterface ( AllocatePrivateVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeAllocatePrivateVirtualInterface ( request ) ; }
public GetDeploymentResult getDeployment ( GetDeploymentRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDeployment ( request ) ; }
public UpdateRepoAuthorizationRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " UpdateRepoAuthorization " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / authorizations / [ AuthorizeId ] " ) ; setMethod ( MethodType . POST ) ; }
public void foldToASCII ( char [ ] input , int length ) { final int maxSizeNeeded = 4 * length ; if ( output . length < maxSizeNeeded ) { output = new char [ ArrayUtil . oversize ( maxSizeNeeded , Character . BYTES ) ] ; } outputPos = foldToASCII ( input , 0 , output , 0 , length ) ; if ( preserveOriginal && needToPreserve ( input , length ) ) { state = captureState ( ) ; } }
public boolean hasEntry ( String name ) { if ( excludes . contains ( name ) ) { return false ; } return directory . hasEntry ( name ) ; }
public void setLockMessage ( String msg ) { lockMessage = msg ; }
public ReflogCommand reflog ( ) { return new ReflogCommand ( repo ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getFirstRow ( ) ) ; out . writeShort ( getLastRow ( ) ) ; out . writeShort ( getFirstColumn ( ) ) ; out . writeShort ( getLastColumn ( ) ) ; }
public static int response ( java . net . HttpURLConnection c ) throws IOException { try { return c . getResponseCode ( ) ; } catch ( ConnectException ce ) { final URL url = c . getURL ( ) ; final String host = ( url == null ) ? " < null > " : url . getHost ( ) ; if ( " Connection ▁ timed ▁ out : ▁ connect " . equals ( ce . getMessage ( ) ) ) throw new ConnectException ( MessageFormat . format ( JGitText . get ( ) . connectionTimeOut , host ) ) ; throw new ConnectException ( ce . getMessage ( ) + " ▁ " + host ) ; } }
public static void fill ( long [ ] array , long value ) { for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = value ; } }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( getPositionOfBof ( ) ) ; out . writeShort ( field_2_option_flags ) ; String name = field_5_sheetname ; out . writeByte ( name . length ( ) ) ; out . writeByte ( field_4_isMultibyteUnicode ) ; if ( isMultibyte ( ) ) { StringUtil . putUnicodeLE ( name , out ) ; } else { StringUtil . putCompressedUnicode ( name , out ) ; } }
public static String getNonBlankTextOrFail ( Element e ) throws ParserException { String v = getText ( e ) ; if ( null != v ) v = v . trim ( ) ; if ( null == v || 0 == v . length ( ) ) { throw new ParserException ( e . getTagName ( ) + " ▁ has ▁ no ▁ text " ) ; } return v ; }
public void buildFieldConfig ( FieldConfig fieldConfig ) { Map < String , Float > fieldBoostMap = this . config . get ( ConfigurationKeys . FIELD_BOOST_MAP ) ; if ( fieldBoostMap != null ) { Float boost = fieldBoostMap . get ( fieldConfig . getField ( ) ) ; if ( boost != null ) { fieldConfig . set ( ConfigurationKeys . BOOST , boost ) ; } } }
public PutLifecyclePolicyResult putLifecyclePolicy ( PutLifecyclePolicyRequest request ) { request = beforeClientExecution ( request ) ; return executePutLifecyclePolicy ( request ) ; }
public SortedSet < E > subSet ( E start , E end ) { return subSet ( start , true , end , false ) ; }
public void setParams ( String params ) { super . setParams ( params ) ; if ( params != null ) { int multiplier ; if ( params . endsWith ( " s " ) ) { multiplier = 1 ; params = params . substring ( 0 , params . length ( ) - 1 ) ; } else if ( params . endsWith ( " m " ) ) { multiplier = 60 ; params = params . substring ( 0 , params . length ( ) - 1 ) ; } else if ( params . endsWith ( " h " ) ) { multiplier = 3600 ; params = params . substring ( 0 , params . length ( ) - 1 ) ; } else { multiplier = 1 ; } waitTimeSec = Double . parseDouble ( params ) * multiplier ; } else { throw new IllegalArgumentException ( " you ▁ must ▁ specify ▁ the ▁ wait ▁ time , ▁ eg : ▁ 10.0s , ▁ 4.5m , ▁ 2h " ) ; } }
public PutAttributesRequest ( String domainName , String itemName , java . util . List < ReplaceableAttribute > attributes , UpdateCondition expected ) { setDomainName ( domainName ) ; setItemName ( itemName ) ; setAttributes ( attributes ) ; setExpected ( expected ) ; }
public DescribeStreamConsumerResult describeStreamConsumer ( DescribeStreamConsumerRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStreamConsumer ( request ) ; }
public void freeze ( ) { this . frozen = true ; }
public FuzzyLikeThisQueryBuilder ( Analyzer analyzer ) { this . analyzer = analyzer ; }
public DBClusterSnapshot copyDBClusterSnapshot ( CopyDBClusterSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCopyDBClusterSnapshot ( request ) ; }
public OutputStreamDataOutput ( OutputStream os ) { this . os = os ; }
public String findPattern ( String pat ) { int k = super . find ( pat ) ; if ( k >= 0 ) { return unpackValues ( k ) ; } return " " ; }
public static int murmurhash3_x86_32 ( BytesRef bytes , int seed ) { return murmurhash3_x86_32 ( bytes . bytes , bytes . offset , bytes . length , seed ) ; }
public boolean isOverridable ( ) { return overridable ; }
public UpdateMemberResult updateMember ( UpdateMemberRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateMember ( request ) ; }
public CopyFpgaImageResult copyFpgaImage ( CopyFpgaImageRequest request ) { request = beforeClientExecution ( request ) ; return executeCopyFpgaImage ( request ) ; }
public void inform ( ResourceLoader loader ) { try { OpenNLPOpsFactory . getPOSTaggerModel ( posTaggerModelFile , loader ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( e ) ; } }
public CellRangeAddress ( int firstRow , int lastRow , int firstCol , int lastCol ) { super ( firstRow , lastRow , firstCol , lastCol ) ; if ( lastRow < firstRow || lastCol < firstCol ) { throw new IllegalArgumentException ( " Invalid ▁ cell ▁ range , ▁ having ▁ lastRow ▁ < ▁ firstRow ▁ || ▁ lastCol ▁ < ▁ firstCol , ▁ " + " had ▁ rows ▁ " + lastRow + " ▁ >= ▁ " + firstRow + " ▁ or ▁ cells ▁ " + lastCol + " ▁ >= ▁ " + firstCol ) ; } }
public boolean equals ( ATNConfig a , ATNConfig b ) { if ( a == b ) return true ; if ( a == null || b == null ) return false ; return a . state . stateNumber == b . state . stateNumber && a . context . equals ( b . context ) ; }
public PushCommand setPushTags ( ) { refSpecs . add ( Transport . REFSPEC_TAGS ) ; return this ; }
public CreateEvaluationResult createEvaluation ( CreateEvaluationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateEvaluation ( request ) ; }
public DescribeOrderableDBInstanceOptionsResult describeOrderableDBInstanceOptions ( DescribeOrderableDBInstanceOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeOrderableDBInstanceOptions ( request ) ; }
public long getPosition ( ) { return ( long ) currentBlockIndex * blockSize + currentBlockUpto ; }
public TokenStream create ( TokenStream input ) { return new FrenchLightStemFilter ( input ) ; }
public AssignPrivateIpAddressesResult assignPrivateIpAddresses ( AssignPrivateIpAddressesRequest request ) { request = beforeClientExecution ( request ) ; return executeAssignPrivateIpAddresses ( request ) ; }
public boolean setExecute ( File f , boolean canExec ) { return false ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval lookup_value , ValueEval table_array , ValueEval col_index , ValueEval range_lookup ) { try { ValueEval lookupValue = OperandResolver . getSingleValue ( lookup_value , srcRowIndex , srcColumnIndex ) ; TwoDEval tableArray = LookupUtils . resolveTableArrayArg ( table_array ) ; boolean isRangeLookup ; try { isRangeLookup = LookupUtils . resolveRangeLookupArg ( range_lookup , srcRowIndex , srcColumnIndex ) ; } catch ( RuntimeException e ) { isRangeLookup = true ; } int rowIndex = LookupUtils . lookupIndexOfValue ( lookupValue , LookupUtils . createColumnVector ( tableArray , 0 ) , isRangeLookup ) ; int colIndex = LookupUtils . resolveRowOrColIndexArg ( col_index , srcRowIndex , srcColumnIndex ) ; ValueVector resultCol = createResultColumnVector ( tableArray , colIndex ) ; return resultCol . getItem ( rowIndex ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public CreateGameSessionResult createGameSession ( CreateGameSessionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateGameSession ( request ) ; }
public RowRecord getRow ( int rowIndex ) { int maxrow = SpreadsheetVersion . EXCEL97. getLastRowIndex ( ) ; if ( rowIndex < 0 || rowIndex > maxrow ) { throw new IllegalArgumentException ( " The ▁ row ▁ number ▁ must ▁ be ▁ between ▁ 0 ▁ and ▁ " + maxrow + " , ▁ but ▁ had : ▁ " + rowIndex ) ; } return _rowRecords . get ( Integer . valueOf ( rowIndex ) ) ; }
public DescribeClientPropertiesResult describeClientProperties ( DescribeClientPropertiesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClientProperties ( request ) ; }
public Builder ( CompositeReader reader ) { this . reader = reader ; }
public synchronized void mark ( int readlimit ) { in . mark ( readlimit ) ; }
public void print ( int inum ) { print ( String . valueOf ( inum ) ) ; }
public static final ObjectId fromRaw ( int [ ] is ) { return fromRaw ( is , 0 ) ; }
public String toString ( ) { return slice . toString ( ) + " : " + postingsEnum ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getMode ( ) ) ; }
@ Override public int size ( ) { return Impl . this . size ( ) ; }
public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; }
public ByteBuffer putFloat ( int index , float value ) { throw new ReadOnlyBufferException ( ) ; }
public ListJournalS3ExportsForLedgerResult listJournalS3ExportsForLedger ( ListJournalS3ExportsForLedgerRequest request ) { request = beforeClientExecution ( request ) ; return executeListJournalS3ExportsForLedger ( request ) ; }
public DeleteMessageBatchResult deleteMessageBatch ( DeleteMessageBatchRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMessageBatch ( request ) ; }
public final void write ( LittleEndianOutput out ) { out . writeByte ( getSid ( ) + getPtgClass ( ) ) ; writeCoordinates ( out ) ; }
public FSTCompletionBuilder ( int buckets , BytesRefSorter sorter , int shareMaxTailLength ) { if ( buckets < 1 || buckets > 255 ) { throw new IllegalArgumentException ( " Buckets ▁ must ▁ be ▁ >= ▁ 1 ▁ and ▁ <= ▁ 255 : ▁ " + buckets ) ; } if ( sorter == null ) throw new IllegalArgumentException ( " BytesRefSorter ▁ must ▁ not ▁ be ▁ null . " ) ; this . sorter = sorter ; this . buckets = buckets ; this . shareMaxTailLength = shareMaxTailLength ; }
public void incRef ( ) { refCount . incrementAndGet ( ) ; }
public boolean supports ( CredentialItem ... items ) { for ( CredentialItem i : items ) { if ( i instanceof CredentialItem . Username ) continue ; else if ( i instanceof CredentialItem . Password ) continue ; else return false ; } return true ; }
public DeleteVpnConnectionRequest ( String vpnConnectionId ) { setVpnConnectionId ( vpnConnectionId ) ; }
public final ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { if ( args . length != 4 ) { return ErrorEval . VALUE_INVALID ; } return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; }
public void print ( double d ) { print ( String . valueOf ( d ) ) ; }
public UpdateUserProfileResult updateUserProfile ( UpdateUserProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateUserProfile ( request ) ; }
public RevFilter clone ( ) { final RevFilter [ ] s = new RevFilter [ subfilters . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) s [ i ] = subfilters [ i ] . clone ( ) ; return new List ( s ) ; }
public GetFederationTokenRequest ( String name ) { setName ( name ) ; }
public static Cell translateUnicodeValues ( Cell cell ) { String s = cell . getRichStringCellValue ( ) . getString ( ) ; boolean foundUnicode = false ; String lowerCaseStr = s . toLowerCase ( Locale . ROOT ) ; for ( UnicodeMapping entry : unicodeMappings ) { String key = entry . entityName ; if ( lowerCaseStr . contains ( key ) ) { s = s . replaceAll ( key , entry . resolvedValue ) ; foundUnicode = true ; } } if ( foundUnicode ) { cell . setCellValue ( cell . getRow ( ) . getSheet ( ) . getWorkbook ( ) . getCreationHelper ( ) . createRichTextString ( s ) ) ; } return cell ; }
public CreateChangeSetResult createChangeSet ( CreateChangeSetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateChangeSet ( request ) ; }
public SubmoduleStatusCommand ( Repository repo ) { super ( repo ) ; paths = new ArrayList <> ( ) ; }
public int getResultStart ( ) { return outRegion . resultStart ; }
public static BigInteger round ( BigInteger bi , int nBits ) { if ( nBits < 1 ) { return bi ; } return bi . add ( HALF_BITS [ nBits ] ) ; }
public static Date round ( Date date , Resolution resolution ) { return new Date ( round ( date . getTime ( ) , resolution ) ) ; }
public static int compareArrayByPrefix ( char [ ] shortArray , int shortIndex , char [ ] longArray , int longIndex ) { if ( shortArray == null ) return 0 ; else if ( longArray == null ) return ( shortIndex < shortArray . length ) ? 1 : 0 ; int si = shortIndex , li = longIndex ; while ( si < shortArray . length && li < longArray . length && shortArray [ si ] == longArray [ li ] ) { si ++ ; li ++ ; } if ( si == shortArray . length ) { return 0 ; } else { if ( li == longArray . length ) return 1 ; else return ( shortArray [ si ] > longArray [ li ] ) ? 1 : - 1 ; } }
public AttachInternetGatewayResult attachInternetGateway ( AttachInternetGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachInternetGateway ( request ) ; }
public synchronized boolean containsValue ( Object value ) { if ( value == null ) { throw new NullPointerException ( ) ; } HashtableEntry [ ] tab = table ; int len = tab . length ; for ( int i = 0 ; i < len ; i ++ ) { for ( HashtableEntry e = tab [ i ] ; e != null ; e = e . next ) { if ( value . equals ( e . value ) ) { return true ; } } } return false ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " <= " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public void write ( String str ) { write ( str . toCharArray ( ) ) ; }
public Sort ( SortField ... fields ) { setSort ( fields ) ; }
public DescribeEventCategoriesResult describeEventCategories ( DescribeEventCategoriesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEventCategories ( request ) ; }
public UpdateDeviceResult updateDevice ( UpdateDeviceRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDevice ( request ) ; }
public CreateWorkerBlockResult createWorkerBlock ( CreateWorkerBlockRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateWorkerBlock ( request ) ; }
public synchronized void reset ( ) throws IOException { throw new IOException ( ) ; }
public final void setReader ( Reader input ) { if ( input == null ) { throw new NullPointerException ( " input ▁ must ▁ not ▁ be ▁ null " ) ; } else if ( this . input != ILLEGAL_STATE_READER ) { throw new IllegalStateException ( " TokenStream ▁ contract ▁ violation : ▁ close ( ) ▁ call ▁ missing " ) ; } this . inputPending = input ; setReaderTestPoint ( ) ; }
public GetUsagePlanKeysResult getUsagePlanKeys ( GetUsagePlanKeysRequest request ) { request = beforeClientExecution ( request ) ; return executeGetUsagePlanKeys ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " subInfos = ( " ) ; for ( SubInfo si : subInfos ) sb . append ( si . toString ( ) ) ; sb . append ( " ) / " ) . append ( totalBoost ) . append ( ' ( ' ) . append ( startOffset ) . append ( ' , ' ) . append ( endOffset ) . append ( ' ) ' ) ; return sb . toString ( ) ; }
public TokenStream create ( TokenStream input ) { return new LimitTokenPositionFilter ( input , maxTokenPosition , consumeAllTokens ) ; }
public DescribeFleetUtilizationResult describeFleetUtilization ( DescribeFleetUtilizationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFleetUtilization ( request ) ; }
public void inform ( ResourceLoader loader ) throws IOException { InputStream stream = null ; try { if ( dictFile != null ) dictionary = getWordSet ( loader , dictFile , false ) ; stream = loader . openResource ( hypFile ) ; final InputSource is = new InputSource ( stream ) ; is . setEncoding ( encoding ) ; is . setSystemId ( hypFile ) ; hyphenator = HyphenationCompoundWordTokenFilter . getHyphenationTree ( is ) ; } finally { IOUtils . closeWhileHandlingException ( stream ) ; } }
public DeclineInvitationsResult declineInvitations ( DeclineInvitationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeclineInvitations ( request ) ; }
public DescribeAutoScalingGroupsResult describeAutoScalingGroups ( ) { return describeAutoScalingGroups ( new DescribeAutoScalingGroupsRequest ( ) ) ; }
public String toString ( ) { return String . format ( " pushMode ( % d ) " , mode ) ; }
public CreateBranchCommand setStartPoint ( String startPoint ) { checkCallable ( ) ; this . startPoint = startPoint ; this . startCommit = null ; return this ; }
public DBInstance stopDBInstance ( StopDBInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeStopDBInstance ( request ) ; }
public SuggestWordQueue ( int size , Comparator < SuggestWord > comparator ) { super ( size ) ; this . comparator = comparator ; }
public LBCookieStickinessPolicy ( String policyName , Long cookieExpirationPeriod ) { setPolicyName ( policyName ) ; setCookieExpirationPeriod ( cookieExpirationPeriod ) ; }
public SheetRangeEvaluator ( int firstSheetIndex , int lastSheetIndex , SheetRefEvaluator [ ] sheetEvaluators ) { if ( firstSheetIndex < 0 ) { throw new IllegalArgumentException ( " Invalid ▁ firstSheetIndex : ▁ " + firstSheetIndex + " . " ) ; } if ( lastSheetIndex < firstSheetIndex ) { throw new IllegalArgumentException ( " Invalid ▁ lastSheetIndex : ▁ " + lastSheetIndex + " ▁ for ▁ firstSheetIndex : ▁ " + firstSheetIndex + " . " ) ; } _firstSheetIndex = firstSheetIndex ; _lastSheetIndex = lastSheetIndex ; _sheetEvaluators = sheetEvaluators . clone ( ) ; }
public RevokeTokenRequest ( ) { super ( " OnsMqtt " , " 2019 - 12 - 11 " , " RevokeToken " , " onsmqtt " ) ; setMethod ( MethodType . POST ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { try { ValueEval ve = OperandResolver . getSingleValue ( arg0 , srcRowIndex , srcColumnIndex ) ; double result = OperandResolver . coerceValueToDouble ( ve ) ; if ( Double . isNaN ( result ) || Double . isInfinite ( result ) ) { throw new EvaluationException ( ErrorEval . NUM_ERROR ) ; } if ( arg1 instanceof RefListEval ) { return eval ( result , ( ( RefListEval ) arg1 ) , true ) ; } final AreaEval aeRange = convertRangeArg ( arg1 ) ; return eval ( result , aeRange , true ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public String toFormulaString ( ) { return " " ; }
public byte readByte ( ) throws IOException { if ( bufferPos == bufferSize ) { refill ( ) ; } assert bufferPos == buffer . position ( ) : " bufferPos = " + bufferPos + " ▁ vs ▁ buffer . position ( ) = " + buffer . position ( ) ; bufferPos ++ ; return buffer . get ( ) ; }
public ListTargetsByRuleResult listTargetsByRule ( ListTargetsByRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeListTargetsByRule ( request ) ; }
public DisassociateQualificationFromWorkerResult disassociateQualificationFromWorker ( DisassociateQualificationFromWorkerRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateQualificationFromWorker ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; CompiledAutomaton other = ( CompiledAutomaton ) obj ; if ( type != other . type ) return false ; if ( type == AUTOMATON_TYPE . SINGLE ) { if ( ! term . equals ( other . term ) ) return false ; } else if ( type == AUTOMATON_TYPE . NORMAL ) { if ( ! runAutomaton . equals ( other . runAutomaton ) ) return false ; } return true ; }
public static CharFilterFactory forName ( String name , Map < String , String > args ) { return loader . newInstance ( name , args ) ; }
public String toString ( ) { String [ ] units = { " bytes " , " KiB " , " MiB " , " GiB " } ; long sz = getIndexSize ( ) ; int u = 0 ; while ( 1024 <= sz && u < units . length - 1 ) { int rem = ( int ) ( sz % 1024 ) ; sz /= 1024 ; if ( rem != 0 ) sz ++ ; u ++ ; } return " DeltaIndex [ " + sz + " ▁ " + units [ u ] + " ] " ; }
public SimilarityConfig build ( ) { return new SimilarityConfig ( this ) ; }
public void mark ( int readLimit ) throws IOException { throw new IOException ( ) ; }
public void collect ( int doc ) throws IOException { final long time = clock . get ( ) ; if ( time - timeout > 0L ) { if ( greedy ) { in . collect ( doc ) ; } throw new TimeExceededException ( timeout - t0 , time - t0 , docBase + doc ) ; } in . collect ( doc ) ; }
public LocalFile ( File directory , int inCoreLimit ) { super ( inCoreLimit ) ; this . directory = directory ; }
@ Override public E remove ( int index ) { Object [ ] a = array ; int s = size ; if ( index >= s ) { throwIndexOutOfBoundsException ( index , s ) ; } @ SuppressWarnings ( " unchecked " ) E result = ( E ) a [ index ] ; System . arraycopy ( a , index + 1 , a , index , -- s - index ) ; a [ s ] = null ; size = s ; modCount ++ ; return result ; }
public RequestUploadCredentialsResult requestUploadCredentials ( RequestUploadCredentialsRequest request ) { request = beforeClientExecution ( request ) ; return executeRequestUploadCredentials ( request ) ; }
public void copyTo ( OutputStream out ) throws MissingObjectException , IOException { if ( isLarge ( ) ) { try ( ObjectStream in = openStream ( ) ) { final long sz = in . getSize ( ) ; byte [ ] tmp = new byte [ 8192 ] ; long copied = 0 ; while ( copied < sz ) { int n = in . read ( tmp ) ; if ( n < 0 ) throw new EOFException ( ) ; out . write ( tmp , 0 , n ) ; copied += n ; } if ( 0 <= in . read ( ) ) throw new EOFException ( ) ; } } else { out . write ( getCachedBytes ( ) ) ; } }
@ Override public V remove ( Object key ) { if ( key == null ) { return removeNullKey ( ) ; } int hash = secondaryHash ( key . hashCode ( ) ) ; HashMapEntry < K , V > [ ] tab = table ; int index = hash & ( tab . length - 1 ) ; for ( HashMapEntry < K , V > e = tab [ index ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( e . hash == hash && key . equals ( e . key ) ) { if ( prev == null ) { tab [ index ] = e . next ; } else { prev . next = e . next ; } modCount ++ ; size -- ; postRemove ( e ) ; return e . value ; } } return null ; }
public RevFilter negate ( ) { return a ; }
public DescribeVpcsResult describeVpcs ( DescribeVpcsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcs ( request ) ; }
public UpdateGameSessionQueueResult updateGameSessionQueue ( UpdateGameSessionQueueRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateGameSessionQueue ( request ) ; }
public String getTitle ( ) { return title ; }
public final void setNewHeads ( List < Head > newHeads ) { if ( this . newHeads != null ) throw new IllegalStateException ( JGitText . get ( ) . propertyIsAlreadyNonNull ) ; this . newHeads = newHeads ; }
public ObjectId getExpectedOldObjectId ( ) { return expectedOldObjectId ; }
public GetRecordsResult getRecords ( GetRecordsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRecords ( request ) ; }
public Deleted3DPxg ( int externalWorkbookNumber , String sheetName ) { this . externalWorkbookNumber = externalWorkbookNumber ; this . sheetName = sheetName ; }
public void execute ( Lexer lexer ) { lexer . skip ( ) ; }
public DescribeScheduledInstancesResult describeScheduledInstances ( DescribeScheduledInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeScheduledInstances ( request ) ; }
public MultiFields ( Fields [ ] subs , ReaderSlice [ ] subSlices ) { this . subs = subs ; this . subSlices = subSlices ; }
public int peekNextSid ( ) { if ( ! hasNext ( ) ) { return - 1 ; } return _list . get ( _nextIndex ) . getSid ( ) ; }
public ConfigureAgentResult configureAgent ( ConfigureAgentRequest request ) { request = beforeClientExecution ( request ) ; return executeConfigureAgent ( request ) ; }
public GetStreamingDistributionResult getStreamingDistribution ( GetStreamingDistributionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetStreamingDistribution ( request ) ; }
public ListTrialComponentsResult listTrialComponents ( ListTrialComponentsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTrialComponents ( request ) ; }
public ByteBuffer putShort ( int index , short value ) { throw new ReadOnlyBufferException ( ) ; }
public int compareNormalised ( NormalisedDecimal other ) { int cmp = _relativeDecimalExponent - other . _relativeDecimalExponent ; if ( cmp != 0 ) { return cmp ; } if ( _wholePart > other . _wholePart ) { return 1 ; } if ( _wholePart < other . _wholePart ) { return - 1 ; } return _fractionalPart - other . _fractionalPart ; }
public TokenStream create ( TokenStream input ) { return new JapaneseKatakanaStemFilter ( input , minimumLength ) ; }
public EnableAvailabilityZonesForLoadBalancerResult enableAvailabilityZonesForLoadBalancer ( EnableAvailabilityZonesForLoadBalancerRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableAvailabilityZonesForLoadBalancer ( request ) ; }
public UpdateEnvironmentResult updateEnvironment ( UpdateEnvironmentRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateEnvironment ( request ) ; }
public ListTagsForDomainResult listTagsForDomain ( ListTagsForDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeListTagsForDomain ( request ) ; }
public static double log ( double base , double x ) { return Math . log ( x ) / Math . log ( base ) ; }
public final void writeBoolean ( boolean val ) throws IOException { out . write ( val ? 1 : 0 ) ; written ++ ; }
public boolean equals ( Object other ) { if ( ! ( other instanceof ByteBuffer ) ) { return false ; } ByteBuffer otherBuffer = ( ByteBuffer ) other ; if ( remaining ( ) != otherBuffer . remaining ( ) ) { return false ; } int myPosition = position ; int otherPosition = otherBuffer . position ; boolean equalSoFar = true ; while ( equalSoFar && ( myPosition < limit ) ) { equalSoFar = get ( myPosition ++ ) == otherBuffer . get ( otherPosition ++ ) ; } return equalSoFar ; }
public DescribeVirtualGatewaysResult describeVirtualGateways ( ) { return describeVirtualGateways ( new DescribeVirtualGatewaysRequest ( ) ) ; }
public FieldConfig getFieldConfig ( String fieldName ) { FieldConfig fieldConfig = new FieldConfig ( StringUtils . toString ( fieldName ) ) ; for ( FieldConfigListener listener : this . listeners ) { listener . buildFieldConfig ( fieldConfig ) ; } return fieldConfig ; }
public void setProperty ( Row row , int column ) { Cell cell = CellUtil . getCell ( row , column ) ; CellUtil . setCellStyleProperty ( cell , _propertyName , _propertyValue ) ; }
public RebootInstancesResult rebootInstances ( RebootInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeRebootInstances ( request ) ; }
public Predicate ( int ruleIndex , int predIndex , boolean isCtxDependent ) { this . ruleIndex = ruleIndex ; this . predIndex = predIndex ; this . isCtxDependent = isCtxDependent ; }
public void fillPolygon ( int [ ] xPoints , int [ ] yPoints , int nPoints ) { int right = findBiggest ( xPoints ) ; int bottom = findBiggest ( yPoints ) ; int left = findSmallest ( xPoints ) ; int top = findSmallest ( yPoints ) ; HSSFPolygon shape = escherGroup . createPolygon ( new HSSFChildAnchor ( left , top , right , bottom ) ) ; shape . setPolygonDrawArea ( right - left , bottom - top ) ; shape . setPoints ( addToAll ( xPoints , - left ) , addToAll ( yPoints , - top ) ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setFillColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; }
public ListEventsRequest ( ) { super ( " Status " , " 2020 - 01 - 17 " , " ListEvents " , " StatusAPI " ) ; setMethod ( MethodType . POST ) ; }
public ListIAMPolicyAssignmentsResult listIAMPolicyAssignments ( ListIAMPolicyAssignmentsRequest request ) { request = beforeClientExecution ( request ) ; return executeListIAMPolicyAssignments ( request ) ; }
public CountingOutputStream ( OutputStream out ) { this . out = out ; }
public void seekExact ( BytesRef target , TermState otherState ) { if ( ! target . equals ( term ) ) { state . copyFrom ( otherState ) ; term = BytesRef . deepCopyOf ( target ) ; seekPending = true ; } }
public void seek ( long pos ) throws IOException { if ( pos != getFilePointer ( ) ) { final long alignedPos = pos & ALIGN_NOT_MASK ; filePos = alignedPos - bufferSize ; final int delta = ( int ) ( pos - alignedPos ) ; if ( delta != 0 ) { refill ( ) ; buffer . position ( delta ) ; bufferPos = delta ; } else { bufferPos = bufferSize ; } } }
public void clear ( ) { removeAllElements ( ) ; }
public QueryCustomerByPhoneRequest ( ) { super ( " xspace " , " 2017 - 07 - 20 " , " QueryCustomerByPhone " ) ; setUriPattern ( " / customerbyphone " ) ; setMethod ( MethodType . POST ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { return this . evaluate ( srcRowIndex , srcColumnIndex , arg0 , null ) ; }
public ListDashboardVersionsResult listDashboardVersions ( ListDashboardVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDashboardVersions ( request ) ; }
public IntBuffer put ( int c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } backingArray [ offset + position ++ ] = c ; return this ; }
public DeleteHostedZoneResult deleteHostedZone ( DeleteHostedZoneRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteHostedZone ( request ) ; }
public CreateReceiptRuleResult createReceiptRule ( CreateReceiptRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateReceiptRule ( request ) ; }
public Result rename ( ) throws IOException { try { result = doRename ( ) ; return result ; } catch ( IOException err ) { result = Result . IO_FAILURE ; throw err ; } }
public DescribeDBInstancesResult describeDBInstances ( ) { return describeDBInstances ( new DescribeDBInstancesRequest ( ) ) ; }
public String toString ( ) { if ( label != null ) { return label + " : " + tag ; } return tag ; }
public CharSequence toQueryString ( EscapeQuerySyntax escaper ) { return " [ DELETEDCHILD ] " ; }
public CreateAccountResult createAccount ( CreateAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAccount ( request ) ; }
public Map . Entry < K , V > next ( ) { HashEntry < K , V > e = super . nextEntry ( ) ; return new WriteThroughEntry ( e . key , e . value ) ; }
public BaseRef ( RefEval re ) { _refEval = re ; _areaEval = null ; _firstRowIndex = re . getRow ( ) ; _firstColumnIndex = re . getColumn ( ) ; _height = 1 ; _width = 1 ; }
public void decode ( long [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; for ( int shift = 62 ; shift >= 0 ; shift -= 2 ) { values [ valuesOffset ++ ] = ( block >>> shift ) & 3 ; } } }
public void unrollRecursionContexts ( ParserRuleContext _parentctx ) { _precedenceStack . pop ( ) ; _ctx . stop = _input . LT ( - 1 ) ; ParserRuleContext retctx = _ctx ; if ( _parseListeners != null ) { while ( _ctx != _parentctx ) { triggerExitRuleEvent ( ) ; _ctx = ( ParserRuleContext ) _ctx . parent ; } } else { _ctx = _parentctx ; } retctx . parent = _parentctx ; if ( _buildParseTrees && _parentctx != null ) { _parentctx . addChild ( retctx ) ; } }
public CancelBundleTaskRequest ( String bundleId ) { setBundleId ( bundleId ) ; }
public void add ( CharsRef input , CharsRef output , boolean includeOrig ) { add ( input , countWords ( input ) , output , countWords ( output ) , includeOrig ) ; }
public SetIdentityDkimEnabledResult setIdentityDkimEnabled ( SetIdentityDkimEnabledRequest request ) { request = beforeClientExecution ( request ) ; return executeSetIdentityDkimEnabled ( request ) ; }
public GetResolverEndpointResult getResolverEndpoint ( GetResolverEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeGetResolverEndpoint ( request ) ; }
public void setText ( String value ) { string = value ; start = offset = 0 ; end = value . length ( ) ; }
public String toString ( ) { return toString ( 0 ) ; }
public void adjustIndex ( int offset ) { _firstSheetIndex += offset ; _lastSheetIndex += offset ; }
public GalicianStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public ListRepositoryAssociationsResult listRepositoryAssociations ( ListRepositoryAssociationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListRepositoryAssociations ( request ) ; }
public void setParams ( String params ) { super . setParams ( params ) ; maxNumSegments = ( int ) Double . parseDouble ( params ) ; }
public char getChar ( ) { return ( char ) getShort ( ) ; }
public void next ( int delta ) { if ( delta == 1 ) { prevPtr = currPtr ; currPtr = nextPtr ; if ( ! eof ( ) ) parseEntry ( ) ; return ; } final int end = raw . length ; int ptr = nextPtr ; while ( -- delta > 0 && ptr != end ) { prevPtr = ptr ; while ( raw [ ptr ] != 0 ) ptr ++ ; ptr += OBJECT_ID_LENGTH + 1 ; } if ( delta != 0 ) throw new ArrayIndexOutOfBoundsException ( delta ) ; currPtr = ptr ; if ( ! eof ( ) ) parseEntry ( ) ; }
public Type getType ( ) { return type ; }
public CharBuffer duplicate ( ) { return copy ( this , mark ) ; }
public NGramFilterFactory ( Map < String , String > args ) { super ( args ) ; minGramSize = requireInt ( args , " minGramSize " ) ; maxGramSize = requireInt ( args , " maxGramSize " ) ; preserveOriginal = getBoolean ( args , " preserveOriginal " , NGramTokenFilter . DEFAULT_PRESERVE_ORIGINAL ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public AddRoleToDBClusterResult addRoleToDBCluster ( AddRoleToDBClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeAddRoleToDBCluster ( request ) ; }
public BlameGenerator setTextComparator ( RawTextComparator comparator ) { textComparator = comparator ; return this ; }
public PatternCaptureGroupFilterFactory ( Map < String , String > args ) { super ( args ) ; pattern = getPattern ( args , " pattern " ) ; preserveOriginal = args . containsKey ( " preserve □ original " ) ? Boolean . parseBoolean ( args . get ( " preserve □ original " ) ) : true ; }
public CreateObjectResult createObject ( CreateObjectRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateObject ( request ) ; }
@ Override public String getActions ( ) { return null ; }
public void onChanged ( ) { if ( mAdapter != null ) { post ( new Runnable ( ) ) ; } }
public CreateResourceGroupResult createResourceGroup ( CreateResourceGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateResourceGroup ( request ) ; }
public static RevFilter has ( RevFlag a ) { final RevFlagSet s = new RevFlagSet ( ) ; s . add ( a ) ; return new HasAll ( s ) ; }
@ Override public int size ( ) { return totalSize ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeShort ( field_1_index_extern_sheet ) ; out . writeInt ( unused1 ) ; }
public String toString ( ) { return this . getClass ( ) . getSimpleName ( ) + " @ " + directory + " ▁ lockFactory = " + lockFactory ; }
public final ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { switch ( args . length ) { case 3 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; case 4 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; } return ErrorEval . VALUE_INVALID ; }
public CancelDataRepositoryTaskResult cancelDataRepositoryTask ( CancelDataRepositoryTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelDataRepositoryTask ( request ) ; }
public DateFormatTokenizer ( String format ) { this . format = format ; }
public static int getBiasedExponent ( long rawBits ) { return Math . toIntExact ( ( rawBits & EXPONENT_MASK ) >> EXPONENT_SHIFT ) ; }
public String toString ( ) { return " IB ▁ " + distribution . toString ( ) + " - " + lambda . toString ( ) + normalization . toString ( ) ; }
public String getName ( ) { return name ; }
public boolean inContext ( String context ) { return false ; }
public String toString ( ) { String desc ; File directory = getDirectory ( ) ; if ( directory != null ) desc = directory . getPath ( ) ; elsedesc = getClass ( ) . getSimpleName ( ) + " - " + System . identityHashCode ( this ) ; return " Repository [ " + desc + " ] " ; }
public int serialize ( int offset , byte [ ] data ) { LittleEndian . putInt ( data , offset + 0 , field_13_border_styles1 ) ; LittleEndian . putInt ( data , offset + 4 , field_14_border_styles2 ) ; return 8 ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { final byte block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( block >>> 7 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 6 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 5 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 4 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 3 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 2 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 1 ) & 1 ; values [ valuesOffset ++ ] = block & 1 ; } }
public PipedWriter ( PipedReader destination ) throws IOException { super ( destination ) ; connect ( destination ) ; }
public String dequote ( byte [ ] in , int ip , int ie ) { boolean inquote = false ; final byte [ ] r = new byte [ ie - ip ] ; int rPtr = 0 ; while ( ip < ie ) { final byte b = in [ ip ++ ] ; switch ( b ) { case ' \ ' ' : inquote = ! inquote ; continue ; case ' \\ ' : if ▁ ( inquote ▁ || ▁ ip ▁ == ▁ ie ) r [ rPtr ++ ] ▁ = ▁ b ; ▁ elser [ rPtr ++ ] ▁ = ▁ in [ ip ++ ] ; continue ; default : r [ rPtr ++ ] ▁ = ▁ b ; continue ; } } return ▁ RawParseUtils . decode ( UTF □ 8 , ▁ r , ▁ 0 , ▁ rPtr ) ; }
public Status getStatus ( ) { return myStatus ; }
public DeltaRecord ( RecordInputStream in ) { field_1_max_change = in . readDouble ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getCount ( ) ) ; }
public ListPartsRequest ( String vaultName , String uploadId ) { setVaultName ( vaultName ) ; setUploadId ( uploadId ) ; }
public void set ( int index , long value ) { final int o = index >>> 2 ; final int b = index & 3 ; final int shift = b << 4 ; blocks [ o ] = ( blocks [ o ] & ~ ( 65535L << shift ) ) | ( value << shift ) ; }
public void setRunInBackground ( int deltaPri ) { runInBackground = true ; this . deltaPri = deltaPri ; }
public TeeInputStream ( InputStream src , OutputStream dst ) { this . src = src ; this . dst = dst ; }
public void addChild ( final Property property ) throws IOException { String name = property . getName ( ) ; if ( _children_names . contains ( name ) ) { throw new IOException ( " Duplicate ▁ name ▁ \ " " + name + " \ " " ) ; } _children_names . add ( name ) ; _children . add ( property ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { int result ; if ( arg0 instanceof TwoDEval ) { result = ( ( TwoDEval ) arg0 ) . getWidth ( ) ; } else if ( arg0 instanceof RefEval ) { result = 1 ; } else { return ErrorEval . VALUE_INVALID ; } return new NumberEval ( result ) ; }
public ListModelsResult listModels ( ListModelsRequest request ) { request = beforeClientExecution ( request ) ; return executeListModels ( request ) ; }
public ExtensionQuery ( QueryParser topLevelParser , String field , String rawQueryString ) { this . field = field ; this . rawQueryString = rawQueryString ; this . topLevelParser = topLevelParser ; }
public String toString ( ) { return resourceDescription ; }
public GetDeploymentInstanceResult getDeploymentInstance ( GetDeploymentInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDeploymentInstance ( request ) ; }
public MappingCharFilterFactory ( Map < String , String > args ) { super ( args ) ; mapping = get ( args , " mapping " ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public boolean promptPassphrase ( String msg ) { CredentialItem . StringType v = newPrompt ( msg ) ; if ( provider . get ( uri , v ) ) { passphrase = v . getValue ( ) ; return true ; } passphrase = null ; return false ; }
public DescribeReservedDBInstancesResult describeReservedDBInstances ( ) { return describeReservedDBInstances ( new DescribeReservedDBInstancesRequest ( ) ) ; }
public UnsubscribeFromDatasetResult unsubscribeFromDataset ( UnsubscribeFromDatasetRequest request ) { request = beforeClientExecution ( request ) ; return executeUnsubscribeFromDataset ( request ) ; }
public int available ( ) throws IOException { if ( buf == null ) { throw new IOException ( ) ; } return buf . length - pos + in . available ( ) ; }
@ Override public V remove ( Object key ) { return isInBounds ( key ) ? TreeMap . this . remove ( key ) : null ; }
public void insertSST ( ) { LOG . log ( DEBUG , " creating ▁ new ▁ SST ▁ via ▁ insertSST ! " ) ; sst = new SSTRecord ( ) ; records . add ( records . size ( ) - 1 , createExtendedSST ( ) ) ; records . add ( records . size ( ) - 2 , sst ) ; }
public AddApplicationCloudWatchLoggingOptionResult addApplicationCloudWatchLoggingOption ( AddApplicationCloudWatchLoggingOptionRequest request ) { request = beforeClientExecution ( request ) ; return executeAddApplicationCloudWatchLoggingOption ( request ) ; }
public ListCampaignsResult listCampaigns ( ListCampaignsRequest request ) { request = beforeClientExecution ( request ) ; return executeListCampaigns ( request ) ; }
public void execute ( Lexer lexer ) { lexer . more ( ) ; }
public SetFaceCoverRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " SetFaceCover " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public GetInstanceAccessResult getInstanceAccess ( GetInstanceAccessRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInstanceAccess ( request ) ; }
public void clear ( ) { value = null ; }
public GetFederationTokenResult getFederationToken ( GetFederationTokenRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFederationToken ( request ) ; }
public int first ( ) { currentSentence = 0 ; text . setIndex ( text . getBeginIndex ( ) ) ; return current ( ) ; }
public QueryPhraseMap getFieldTermMap ( String fieldName , String term ) { QueryPhraseMap rootMap = getRootMap ( fieldName ) ; return rootMap == null ? null : rootMap . subMap . get ( term ) ; }
@ Override public boolean contains ( Object object ) { if ( object instanceof Multiset . Entry ) { Multiset . Entry <?> entry = ( Multiset . Entry <?> ) object ; Object element = entry . getElement ( ) ; int entryCount = entry . getCount ( ) ; return entryCount > 0 && count ( element ) == entryCount ; } return false ; }
public DeleteLexiconResult deleteLexicon ( DeleteLexiconRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLexicon ( request ) ; }
public DomainMetadataResult domainMetadata ( DomainMetadataRequest request ) { request = beforeClientExecution ( request ) ; return executeDomainMetadata ( request ) ; }
public RevFlag getReinterestingFlag ( ) { return REINTERESTING ; }
public static void advise ( FileDescriptor fd , long offset , long len , int advise ) throws IOException { final int code = posix_fadvise ( fd , offset , len , advise ) ; if ( code != 0 ) { throw new RuntimeException ( " posix □ fadvise ▁ failed ▁ code = " + code ) ; } }
public DeleteSchemaResult deleteSchema ( DeleteSchemaRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSchema ( request ) ; }
public CreateBatchInferenceJobResult createBatchInferenceJob ( CreateBatchInferenceJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateBatchInferenceJob ( request ) ; }
public BitField ( final int mask ) { _mask = mask ; int count = 0 ; int bit_pattern = mask ; if ( bit_pattern != 0 ) { while ( ( bit_pattern & 1 ) == 0 ) { count ++ ; bit_pattern >>= 1 ; } } _shift_count = count ; }
public boolean failed ( ) { return ! failingPaths . isEmpty ( ) ; }
public String toString ( ) { StringBuilder b = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( i > 0 ) { b . append ( ' ▁ ' ) ; } b . append ( Integer . toBinaryString ( bytes [ i ] . value ) ) ; } return b . toString ( ) ; }
public final void remove ( ) { if ( modCount != expectedModCount ) throw new ConcurrentModificationException ( ) ; if ( lastReturned == null ) throw new IllegalStateException ( ) ; LinkedHashMap . this . remove ( lastReturned . key ) ; lastReturned = null ; expectedModCount = modCount ; }
public boolean shouldBeRecursive ( ) { return path . shouldBeRecursive ( ) || ANY_DIFF . shouldBeRecursive ( ) ; }
public DeleteQueueRequest ( String queueUrl ) { setQueueUrl ( queueUrl ) ; }
public ExternalName getExternalName ( int externSheetIndex , int externNameIndex ) { String nameName = linkTable . resolveNameXText ( externSheetIndex , externNameIndex , this ) ; if ( nameName == null ) { return null ; } int ix = linkTable . resolveNameXIx ( externSheetIndex , externNameIndex ) ; return new ExternalName ( nameName , externNameIndex , ix ) ; }
public RegisterUserResult registerUser ( RegisterUserRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterUser ( request ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { values [ valuesOffset ++ ] = blocks [ blocksOffset ++ ] & 0xFF ; } }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { return fixed ( arg0 , new NumberEval ( 2 ) , BoolEval . FALSE , srcRowIndex , srcColumnIndex ) ; }
public final byte [ ] array ( ) { return protectedArray ( ) ; }
public int readUByte ( ) { byte [ ] buf = new byte [ 1 ] ; try { checkEOF ( read ( buf ) , 1 ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return LittleEndian . getUByte ( buf ) ; }
public static AttrPtg createSkip ( int dist ) { return new AttrPtg ( optiSkip . set ( 0 ) , dist , null , - 1 ) ; }
public DescribeUserHierarchyGroupResult describeUserHierarchyGroup ( DescribeUserHierarchyGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeUserHierarchyGroup ( request ) ; }
public User ( String path , String userName , String userId , String arn , java . util . Date createDate ) { setPath ( path ) ; setUserName ( userName ) ; setUserId ( userId ) ; setArn ( arn ) ; setCreateDate ( createDate ) ; }
public OpenNLPLemmatizerFilter create ( TokenStream in ) { try { NLPLemmatizerOp lemmatizerOp = OpenNLPOpsFactory . getLemmatizer ( dictionaryFile , lemmatizerModelFile ) ; return new OpenNLPLemmatizerFilter ( in , lemmatizerOp ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 4 ) | ( byte1 >>> 4 ) ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 15 ) << 8 ) | byte2 ; } }
public RebootInstanceRequest ( ) { super ( " HPC " , " 2016 - 06 - 03 " , " RebootInstance " , " hpc " ) ; setMethod ( MethodType . POST ) ; }
public ListContainerInstancesResult listContainerInstances ( ListContainerInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeListContainerInstances ( request ) ; }
public ListClustersResult listClusters ( ListClustersRequest request ) { request = beforeClientExecution ( request ) ; return executeListClusters ( request ) ; }
public static boolean equals ( boolean [ ] array1 , boolean [ ] array2 ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1. length != array2. length ) { return false ; } for ( int i = 0 ; i < array1. length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) { return false ; } } return true ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final int byte0 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = byte0 >>> 5 ; values [ valuesOffset ++ ] = ( byte0 >>> 2 ) & 7 ; final int byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte0 & 3 ) << 1 ) | ( byte1 >>> 7 ) ; values [ valuesOffset ++ ] = ( byte1 >>> 4 ) & 7 ; values [ valuesOffset ++ ] = ( byte1 >>> 1 ) & 7 ; final int byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 1 ) << 2 ) | ( byte2 >>> 6 ) ; values [ valuesOffset ++ ] = ( byte2 >>> 3 ) & 7 ; values [ valuesOffset ++ ] = byte2 & 7 ; } }
public GetRelationalDatabaseSnapshotResult getRelationalDatabaseSnapshot ( GetRelationalDatabaseSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabaseSnapshot ( request ) ; }
public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; field_1_blipTypeWin32 = data [ pos ] ; field_2_blipTypeMacOS = data [ pos + 1 ] ; System . arraycopy ( data , pos + 2 , field_3_uid , 0 , 16 ) ; field_4_tag = LittleEndian . getShort ( data , pos + 18 ) ; field_5_size = LittleEndian . getInt ( data , pos + 20 ) ; field_6_ref = LittleEndian . getInt ( data , pos + 24 ) ; field_7_offset = LittleEndian . getInt ( data , pos + 28 ) ; field_8_usage = data [ pos + 32 ] ; field_9_name = data [ pos + 33 ] ; field_10_unused2 = data [ pos + 34 ] ; field_11_unused3 = data [ pos + 35 ] ; bytesRemaining -= 36 ; int bytesRead = 0 ; if ( bytesRemaining > 0 ) { field_12_blipRecord = ( EscherBlipRecord ) recordFactory . createRecord ( data , pos + 36 ) ; bytesRead = field_12_blipRecord . fillFields ( data , pos + 36 , recordFactory ) ; } pos += 36 + bytesRead ; bytesRemaining -= bytesRead ; _remainingData = IOUtils . safelyAllocate ( bytesRemaining , MAX_RECORD_LENGTH ) ; System . arraycopy ( data , pos , _remainingData , 0 , bytesRemaining ) ; return bytesRemaining + 8 + 36 + ( field_12_blipRecord == null ? 0 : field_12_blipRecord . getRecordSize ( ) ) ; }
@ Override public int size ( ) { return size ; }
public PhoneNumberValidateResult phoneNumberValidate ( PhoneNumberValidateRequest request ) { request = beforeClientExecution ( request ) ; return executePhoneNumberValidate ( request ) ; }
public CreateTransformJobResult createTransformJob ( CreateTransformJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTransformJob ( request ) ; }
public synchronized int search ( Object o ) { final Object [ ] dumpArray = elementData ; final int size = elementCount ; if ( o != null ) { for ( int i = size - 1 ; i >= 0 ; i -- ) { if ( o . equals ( dumpArray [ i ] ) ) { return size - i ; } } } else { for ( int i = size - 1 ; i >= 0 ; i -- ) { if ( dumpArray [ i ] == null ) { return size - i ; } } } return - 1 ; }
public DescribeCacheParametersRequest ( String cacheParameterGroupName ) { setCacheParameterGroupName ( cacheParameterGroupName ) ; }
public void clear ( ) { synchronized ( mutex ) { delegate ( ) . clear ( ) ; } }
public boolean hasRevSort ( RevSort sort ) { return sorting . contains ( sort ) ; }
public StashListCommand stashList ( ) { return new StashListCommand ( repo ) ; }
public PutGroupPolicyRequest ( String groupName , String policyName , String policyDocument ) { setGroupName ( groupName ) ; setPolicyName ( policyName ) ; setPolicyDocument ( policyDocument ) ; }
public String toString ( ) { return super . get ( ) + " = " + value ; }
public void writeByte ( int v ) { checkPosition ( 1 ) ; _buf [ _writeIndex ++ ] = ( byte ) v ; }
public CountryRecord ( RecordInputStream in ) { field_1_default_country = in . readShort ( ) ; field_2_current_country = in . readShort ( ) ; }
public UpdateContainerAgentResult updateContainerAgent ( UpdateContainerAgentRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateContainerAgent ( request ) ; }
public DescribeNodeConfigurationOptionsResult describeNodeConfigurationOptions ( DescribeNodeConfigurationOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNodeConfigurationOptions ( request ) ; }
public AddImageRequest ( ) { super ( " ImageSearch " , " 2019 - 03 - 25 " , " AddImage " , " imagesearch " ) ; setUriPattern ( " / v2 / image / add " ) ; setMethod ( MethodType . POST ) ; }
public BorderFormatting ( ) { field_13_border_styles1 = 0 ; field_14_border_styles2 = 0 ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " ▁ " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public ListTagsForStreamResult listTagsForStream ( ListTagsForStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeListTagsForStream ( request ) ; }
public HSSFName createName ( ) { NameRecord nameRecord = workbook . createName ( ) ; HSSFName newName = new HSSFName ( this , nameRecord ) ; names . add ( newName ) ; return newName ; }
public CreateLogPatternResult createLogPattern ( CreateLogPatternRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLogPattern ( request ) ; }
public GetTransitGatewayRouteTablePropagationsResult getTransitGatewayRouteTablePropagations ( GetTransitGatewayRouteTablePropagationsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTransitGatewayRouteTablePropagations ( request ) ; }
public void setup ( ) throws Exception { super . setup ( ) ; String inputDirProp = getRunData ( ) . getConfig ( ) . get ( ADDINDEXES_INPUT_DIR , null ) ; if ( inputDirProp == null ) { throw new IllegalArgumentException ( " config ▁ parameter ▁ " + ADDINDEXES_INPUT_DIR + " ▁ not ▁ specified ▁ in ▁ configuration " ) ; } inputDir = FSDirectory . open ( Paths . get ( inputDirProp ) ) ; }
public StashDropCommand setAll ( boolean all ) { this . all = all ; return this ; }
public ListTrainingJobsForHyperParameterTuningJobResult listTrainingJobsForHyperParameterTuningJob ( ListTrainingJobsForHyperParameterTuningJobRequest request ) { request = beforeClientExecution ( request ) ; return executeListTrainingJobsForHyperParameterTuningJob ( request ) ; }
public String toString ( ) { return String . format ( " Match ▁ % s ; ▁ found ▁ % d ▁ labels " , succeeded ( ) ? " succeeded " : " failed " , getLabels ( ) . size ( ) ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { double result ; try { double d = singleOperandEvaluate ( arg0 , srcRowIndex , srcColumnIndex ) ; result = evaluate ( d ) ; checkValue ( result ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public CacheSecurityGroup authorizeCacheSecurityGroupIngress ( AuthorizeCacheSecurityGroupIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeAuthorizeCacheSecurityGroupIngress ( request ) ; }
public String getInflectionType ( ) { return dictionary . getInflectionType ( wordId ) ; }
@ Override public boolean remove ( Object o ) { return contains ( o ) && ( removeValuesForKey ( ( ( Multiset . Entry <?> ) o ) . getElement ( ) ) > 0 ) ; }
public RevCommit next ( ) { RevCommit r = next ; next = nextForIterator ( ) ; return r ; }
public BatchAssociateUserStackResult batchAssociateUserStack ( BatchAssociateUserStackRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchAssociateUserStack ( request ) ; }
public ScenarioProtectRecord clone ( ) { return copy ( ) ; }
public final Class getBundleClass ( ) { return bundleClass ; }
public void nextBuffer ( ) { if ( 1 + bufferUpto == buffers . length ) { int [ ] [ ] newBuffers = new int [ ( int ) ( buffers . length * 1.5 ) ] [ ] ; System . arraycopy ( buffers , 0 , newBuffers , 0 , buffers . length ) ; buffers = newBuffers ; } buffer = buffers [ 1 + bufferUpto ] = allocator . getIntBlock ( ) ; bufferUpto ++ ; intUpto = 0 ; intOffset += INT_BLOCK_SIZE ; }
public DeleteVpnGatewayRequest ( String vpnGatewayId ) { setVpnGatewayId ( vpnGatewayId ) ; }
public static Encoder getEncoder ( Format format , int version , int bitsPerValue ) { checkVersion ( version ) ; return BulkOperation . of ( format , bitsPerValue ) ; }
public ClassificationResult ( T assignedClass , double score ) { this . assignedClass = assignedClass ; this . score = score ; }
public CreateRelationalDatabaseSnapshotResult createRelationalDatabaseSnapshot ( CreateRelationalDatabaseSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRelationalDatabaseSnapshot ( request ) ; }
public NameRecord addName ( NameRecord name ) { getOrCreateLinkTable ( ) . addName ( name ) ; return name ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getFirstRow ( ) ) ; out . writeShort ( getLastRow ( ) ) ; out . writeByte ( getFirstColumn ( ) ) ; out . writeByte ( getLastColumn ( ) ) ; }
public String getKey ( ) { return key ; }
public GetBlockPublicAccessConfigurationResult getBlockPublicAccessConfiguration ( GetBlockPublicAccessConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetBlockPublicAccessConfiguration ( request ) ; }
public static long getResultSize ( byte [ ] delta ) { int p = 0 ; int c ; do { c = delta [ p ++ ] & 0xff ; } while ( ( c & 0x80 ) != 0 ) ; long resLen = 0 ; int shift = 0 ; do { c = delta [ p ++ ] & 0xff ; resLen |= ( ( long ) ( c & 0x7f ) ) << shift ; shift += 7 ; } while ( ( c & 0x80 ) != 0 ) ; return resLen ; }
public long ramBytesUsed ( ) { return RamUsageEstimator . alignObjectSize ( RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + Integer . BYTES ) ; }
public NoteRecord ( ) { field_6_author = " " ; field_3_flags = 0 ; field_7_padding = DEFAULT_PADDING ; }
public CellReference [ ] getAllReferencedCells ( ) { if ( _isSingleCell ) { return new CellReference [ ] { _firstCell , } ; } int minRow = Math . min ( _firstCell . getRow ( ) , _lastCell . getRow ( ) ) ; int maxRow = Math . max ( _firstCell . getRow ( ) , _lastCell . getRow ( ) ) ; int minCol = Math . min ( _firstCell . getCol ( ) , _lastCell . getCol ( ) ) ; int maxCol = Math . max ( _firstCell . getCol ( ) , _lastCell . getCol ( ) ) ; String sheetName = _firstCell . getSheetName ( ) ; List < CellReference > refs = new ArrayList <> ( ) ; for ( int row = minRow ; row <= maxRow ; row ++ ) { for ( int col = minCol ; col <= maxCol ; col ++ ) { CellReference ref = new CellReference ( sheetName , row , col , _firstCell . isRowAbsolute ( ) , _firstCell . isColAbsolute ( ) ) ; refs . add ( ref ) ; } } return refs . toArray ( new CellReference [ 0 ] ) ; }
public String [ ] listAll ( ) { ensureOpen ( ) ; String [ ] res = entries . keySet ( ) . toArray ( new String [ entries . size ( ) ] ) ; for ( int i = 0 ; i < res . length ; i ++ ) { res [ i ] = segmentName + res [ i ] ; } return res ; }
public UpdateDataRetentionResult updateDataRetention ( UpdateDataRetentionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDataRetention ( request ) ; }
public CreateDistributionRequest ( DistributionConfig distributionConfig ) { setDistributionConfig ( distributionConfig ) ; }
public DescribeBatchPredictionsResult describeBatchPredictions ( DescribeBatchPredictionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeBatchPredictions ( request ) ; }
public float getScore ( int index ) { return scores [ index ] ; }
public BatchUpdatePhoneNumberResult batchUpdatePhoneNumber ( BatchUpdatePhoneNumberRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchUpdatePhoneNumber ( request ) ; }
public LMSimilarity ( CollectionModel collectionModel ) { this . collectionModel = collectionModel ; }
public GetGlobalSettingsResult getGlobalSettings ( GetGlobalSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetGlobalSettings ( request ) ; }
public CreateHITTypeResult createHITType ( CreateHITTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateHITType ( request ) ; }
public MLTConfig build ( ) { return new MLTConfig ( this ) ; }
public CharsRef ( String string ) { this . chars = string . toCharArray ( ) ; this . offset = 0 ; this . length = chars . length ; }
public ListFargateProfilesResult listFargateProfiles ( ListFargateProfilesRequest request ) { request = beforeClientExecution ( request ) ; return executeListFargateProfiles ( request ) ; }
public Entry < K , V > floorEntry ( K key ) { return immutableCopy ( findBounded ( key , FLOOR ) ) ; }
public boolean equals ( Object o ) { return o instanceof NorwegianStemmer ; }
public DeleteVaultNotificationsResult deleteVaultNotifications ( DeleteVaultNotificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVaultNotifications ( request ) ; }
public static boolean endsWith ( char s [ ] , int len , String suffix ) { final int suffixLen = suffix . length ( ) ; if ( suffixLen > len ) return false ; for ( int i = suffixLen - 1 ; i >= 0 ; i -- ) if ( s [ len - ( suffixLen - i ) ] != suffix . charAt ( i ) ) return false ; return true ; }
public synchronized void setRequireDimCount ( String dimName , boolean v ) { DimConfig ft = fieldTypes . get ( dimName ) ; if ( ft == null ) { ft = new DimConfig ( ) ; fieldTypes . put ( dimName , ft ) ; } ft . requireDimCount = v ; }
public HSSFName getName ( String name ) { int nameIndex = getNameIndex ( name ) ; if ( nameIndex < 0 ) { return null ; } return names . get ( nameIndex ) ; }
public ScriptBootstrapActionConfig ( String path , java . util . List < String > args ) { setPath ( path ) ; setArgs ( args ) ; }
public RegisterApplicationRevisionResult registerApplicationRevision ( RegisterApplicationRevisionRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterApplicationRevision ( request ) ; }
public SendTestEventNotificationResult sendTestEventNotification ( SendTestEventNotificationRequest request ) { request = beforeClientExecution ( request ) ; return executeSendTestEventNotification ( request ) ; }
public void setRefLogIdent ( PersonIdent pi ) { refLogIdent = pi ; }
public GetDomainDeliverabilityCampaignResult getDomainDeliverabilityCampaign ( GetDomainDeliverabilityCampaignRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDomainDeliverabilityCampaign ( request ) ; }
public String toFormulaString ( ) { StringBuilder b = new StringBuilder ( ) ; b . append ( " { " ) ; for ( int y = 0 ; y < _nRows ; y ++ ) { if ( y > 0 ) { b . append ( " ; " ) ; } for ( int x = 0 ; x < _nColumns ; x ++ ) { if ( x > 0 ) { b . append ( " , " ) ; } Object o = _arrayValues [ getValueIndex ( x , y ) ] ; b . append ( getConstantText ( o ) ) ; } } b . append ( " } " ) ; return b . toString ( ) ; }
public ShingleFilterFactory ( Map < String , String > args ) { super ( args ) ; maxShingleSize = getInt ( args , " maxShingleSize " , ShingleFilter . DEFAULT_MAX_SHINGLE_SIZE ) ; if ( maxShingleSize < 2 ) { throw new IllegalArgumentException ( " Invalid ▁ maxShingleSize ▁ ( " + maxShingleSize + " ) ▁ - ▁ must ▁ be ▁ at ▁ least ▁ 2 " ) ; } minShingleSize = getInt ( args , " minShingleSize " , ShingleFilter . DEFAULT_MIN_SHINGLE_SIZE ) ; if ( minShingleSize < 2 ) { throw new IllegalArgumentException ( " Invalid ▁ minShingleSize ▁ ( " + minShingleSize + " ) ▁ - ▁ must ▁ be ▁ at ▁ least ▁ 2 " ) ; } if ( minShingleSize > maxShingleSize ) { throw new IllegalArgumentException ( " Invalid ▁ minShingleSize ▁ ( " + minShingleSize + " ) ▁ - ▁ must ▁ be ▁ no ▁ greater ▁ than ▁ maxShingleSize ▁ ( " + maxShingleSize + " ) " ) ; } outputUnigrams = getBoolean ( args , " outputUnigrams " , true ) ; outputUnigramsIfNoShingles = getBoolean ( args , " outputUnigramsIfNoShingles " , false ) ; tokenSeparator = get ( args , " tokenSeparator " , ShingleFilter . DEFAULT_TOKEN_SEPARATOR ) ; fillerToken = get ( args , " fillerToken " , ShingleFilter . DEFAULT_FILLER_TOKEN ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public UpdateRelationalDatabaseParametersResult updateRelationalDatabaseParameters ( UpdateRelationalDatabaseParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRelationalDatabaseParameters ( request ) ; }
public static Collection < ParseTree > findAllRuleNodes ( ParseTree t , int ruleIndex ) { return findAllNodes ( t , ruleIndex , false ) ; }
public int getObjectCount ( ) { return entryCount ; }
public ActionTransition ( ATNState target , int ruleIndex , int actionIndex , boolean isCtxDependent ) { super ( target ) ; this . ruleIndex = ruleIndex ; this . actionIndex = actionIndex ; this . isCtxDependent = isCtxDependent ; }
public long get ( int index ) { final int blockOffset = index / valuesPerBlock ; final long skip = ( ( long ) blockOffset ) << 3 ; try { in . seek ( startPointer + skip ) ; long block = in . readLong ( ) ; final int offsetInBlock = index % valuesPerBlock ; return ( block >>> ( offsetInBlock * bitsPerValue ) ) & mask ; } catch ( IOException e ) { throw new IllegalStateException ( " failed " , e ) ; } }
public String getSignerType ( ) { return " BEARERTOKEN " ; }
public PipedOutputStream ( PipedInputStream target ) throws IOException { connect ( target ) ; }
public DeleteLedgerResult deleteLedger ( DeleteLedgerRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLedger ( request ) ; }
public GetCognitoEventsResult getCognitoEvents ( GetCognitoEventsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCognitoEvents ( request ) ; }
public NameXPtg getNameXPtg ( String name , SheetIdentifier sheet ) { int sheetRefIndex = getSheetExtIx ( sheet ) ; return _iBook . getNameXPtg ( name , sheetRefIndex , _uBook . getUDFFinder ( ) ) ; }
public ListResolverEndpointsResult listResolverEndpoints ( ListResolverEndpointsRequest request ) { request = beforeClientExecution ( request ) ; return executeListResolverEndpoints ( request ) ; }
public String readLine ( ) { try { return reader . readLine ( ) ; } catch ( IOException e ) { throw new IOError ( e ) ; } }
public int hash2 ( char carray [ ] ) { int hash = 5381 ; for ( int i = 0 ; i < carray . length ; i ++ ) { char d = carray [ i ] ; hash = ( ( hash << 5 ) + hash ) + d & 0x00FF ; hash = ( ( hash << 5 ) + hash ) + d >> 8 ; } return hash ; }
public static long toBookSheetColumn ( int bookIndex , int sheetIndex , int columnIndex ) { return ( ( bookIndex & 0xFFFFL ) << 48 ) + ( ( sheetIndex & 0xFFFFL ) << 32 ) + ( ( columnIndex & 0xFFFFL ) << 0 ) ; }
public CreateConfigurationProfileResult createConfigurationProfile ( CreateConfigurationProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateConfigurationProfile ( request ) ; }
public ReplicationGroup startMigration ( StartMigrationRequest request ) { request = beforeClientExecution ( request ) ; return executeStartMigration ( request ) ; }
public OffsetLimitTokenFilter ( TokenStream input , int offsetLimit ) { super ( input ) ; this . offsetLimit = offsetLimit ; }
public final void write ( byte [ ] b , int off , int len ) throws IOException { while ( 0 < len ) { final int n = Math . min ( len , BYTES_TO_WRITE_BEFORE_CANCEL_CHECK ) ; count += n ; if ( checkCancelAt <= count ) { if ( writeMonitor . isCancelled ( ) ) { throw new IOException ( JGitText . get ( ) . packingCancelledDuringObjectsWriting ) ; } checkCancelAt = count + BYTES_TO_WRITE_BEFORE_CANCEL_CHECK ; } out . write ( b , off , n ) ; md . update ( b , off , n ) ; off += n ; len -= n ; } }
public Cell merge ( Cell m , Cell e ) { Cell n = new Cell ( ) ; if ( m . skip != e . skip ) { return null ; } if ( m . cmd >= 0 ) { if ( e . cmd >= 0 ) { if ( m . cmd == e . cmd ) { n . cmd = m . cmd ; } else { return null ; } } else { n . cmd = m . cmd ; } } else { n . cmd = e . cmd ; } if ( m . ref >= 0 ) { if ( e . ref >= 0 ) { if ( m . ref == e . ref ) { if ( m . skip == e . skip ) { n . ref = m . ref ; } else { return null ; } } else { return null ; } } else { n . ref = m . ref ; } } else { n . ref = e . ref ; } n . cnt = m . cnt + e . cnt ; n . skip = m . skip ; return n ; }
public GetCampaignActivitiesResult getCampaignActivities ( GetCampaignActivitiesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCampaignActivities ( request ) ; }
public long estimateBytesUsed ( ) { return bytesUsed ; }
public FunctionNameEval ( String functionName ) { _functionName = functionName ; }
public final float averageBytesPerChar ( ) { return averageBytesPerChar ; }
public CreateCacheSecurityGroupRequest ( String cacheSecurityGroupName , String description ) { setCacheSecurityGroupName ( cacheSecurityGroupName ) ; setDescription ( description ) ; }
public void removeAt ( int index ) { System . arraycopy ( mKeys , index + 1 , mKeys , index , mSize - ( index + 1 ) ) ; System . arraycopy ( mValues , index + 1 , mValues , index , mSize - ( index + 1 ) ) ; mSize -- ; }
public DescribeIndexFieldsResult describeIndexFields ( DescribeIndexFieldsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIndexFields ( request ) ; }
public void remove ( int key ) { delete ( key ) ; }
public ShortBuffer duplicate ( ) { ByteBuffer bb = byteBuffer . duplicate ( ) . order ( byteBuffer . order ( ) ) ; ShortToByteBufferAdapter buf = new ShortToByteBufferAdapter ( bb ) ; buf . limit = limit ; buf . position = position ; buf . mark = mark ; return buf ; }
public void addDbcell ( int cell ) { if ( field_5_dbcells == null ) { field_5_dbcells = new IntList ( ) ; } field_5_dbcells . add ( cell ) ; }
public DeleteSubnetResult deleteSubnet ( DeleteSubnetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSubnet ( request ) ; }
public List < HSSFPictureData > getAllPictures ( ) { List < HSSFPictureData > pictures = new ArrayList <> ( ) ; for ( org . apache . poi . hssf . record . Record r : workbook . getRecords ( ) ) { if ( r instanceof AbstractEscherHolderRecord ) { ( ( AbstractEscherHolderRecord ) r ) . decode ( ) ; List < EscherRecord > escherRecords = ( ( AbstractEscherHolderRecord ) r ) . getEscherRecords ( ) ; searchForPictures ( escherRecords , pictures ) ; } } return Collections . unmodifiableList ( pictures ) ; }
public DescribeWorkspacesConnectionStatusResult describeWorkspacesConnectionStatus ( DescribeWorkspacesConnectionStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWorkspacesConnectionStatus ( request ) ; }
public String toString ( ) { return " MultiDocsAndPositionsEnum ( " + Arrays . toString ( getSubs ( ) ) + " ) " ; }
public InvokeServiceAsyncRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " InvokeServiceAsync " ) ; setMethod ( MethodType . POST ) ; }
public AuthorizeSecurityGroupIngressRequest ( String groupName , java . util . List < IpPermission > ipPermissions ) { setGroupName ( groupName ) ; setIpPermissions ( ipPermissions ) ; }
public static byte [ ] readData ( InputStream stream , String section ) throws IOException { try { StringBuilder sectionText = new StringBuilder ( ) ; boolean inSection = false ; int c = stream . read ( ) ; while ( c != - 1 ) { switch ( c ) { case ' [ ' : inSection = true ; break ; case ' \ n ' : case ' \ r ' : inSection = false ; sectionText = new StringBuilder ( ) ; break ; case ' ] ' : inSection = false ; if ( sectionText . toString ( ) . equals ( section ) ) return readData ( stream , ' [ ' ) ; sectionText = new StringBuilder ( ) ; break ; default : if ( inSection ) sectionText . append ( ( char ) c ) ; } c = stream . read ( ) ; } } finally { stream . close ( ) ; } throw new IOException ( " Section ▁ ' " ▁ + ▁ section ▁ + ▁ " ' ▁ not ▁ found " ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval numberVE ) { int number ; try { number = OperandResolver . coerceValueToInt ( numberVE ) ; } catch ( EvaluationException e ) { return ErrorEval . VALUE_INVALID ; } if ( number < 0 ) { return ErrorEval . NUM_ERROR ; } return new NumberEval ( factorial ( number ) . longValue ( ) ) ; }
public final LexerActionExecutor getLexerActionExecutor ( ) { return lexerActionExecutor ; }
public EnableUserResult enableUser ( EnableUserRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableUser ( request ) ; }
public void fillSlice ( BytesRef b , long start , int length ) { assert length >= 0 : " length = " + length ; assert length <= blockSize + 1 : " length = " + length ; b . length = length ; if ( length == 0 ) { return ; } final int index = ( int ) ( start >> blockBits ) ; final int offset = ( int ) ( start & blockMask ) ; if ( blockSize - offset >= length ) { b . bytes = blocks [ index ] ; b . offset = offset ; } else { b . bytes = new byte [ length ] ; b . offset = 0 ; System . arraycopy ( blocks [ index ] , offset , b . bytes , 0 , blockSize - offset ) ; System . arraycopy ( blocks [ 1 + index ] , 0 , b . bytes , blockSize - offset , length - ( blockSize - offset ) ) ; } }
public DescribeJournalS3ExportResult describeJournalS3Export ( DescribeJournalS3ExportRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeJournalS3Export ( request ) ; }
public void setCoordinates ( int x1 , int y1 , int x2 , int y2 ) { _spgrRecord . setRectY1 ( y1 ) ; _spgrRecord . setRectY2 ( y2 ) ; _spgrRecord . setRectX1 ( x1 ) ; _spgrRecord . setRectX2 ( x2 ) ; }
public DescribeTagsResult describeTags ( DescribeTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTags ( request ) ; }
public int doLogic ( ) { return 1 ; }
public DeleteCustomerGatewayResult deleteCustomerGateway ( DeleteCustomerGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCustomerGateway ( request ) ; }
public static Map newContext ( IndexSearcher searcher ) { Map context = new IdentityHashMap ( ) ; context . put ( " searcher " , searcher ) ; return context ; }
public NameRecord getSpecificBuiltinRecord ( byte builtInCode , int sheetNumber ) { Iterator < NameRecord > iterator = _definedNames . iterator ( ) ; while ( iterator . hasNext ( ) ) { NameRecord record = iterator . next ( ) ; if ( record . getBuiltInName ( ) == builtInCode && record . getSheetNumber ( ) == sheetNumber ) { return record ; } } return null ; }
public final double readDouble ( ) throws IOException { return Double . longBitsToDouble ( readLong ( ) ) ; }
public void write ( byte [ ] buffer , int offset , int count ) throws IOException { super . write ( buffer , offset , count ) ; }
public TokenStream create ( TokenStream input ) { return new PersianNormalizationFilter ( input ) ; }
public SpanishLightStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public SmallDocSet ( int size ) { intSet = new SentinelIntSet ( size , - 1 ) ; }
public RawCharSequence ( byte [ ] buf , int start , int end ) { buffer = buf ; startPtr = start ; endPtr = end ; }
public GetCustomVerificationEmailTemplateResult getCustomVerificationEmailTemplate ( GetCustomVerificationEmailTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCustomVerificationEmailTemplate ( request ) ; }
public SendMessageBatchRequest ( String queueUrl , java . util . List < SendMessageBatchRequestEntry > entries ) { setQueueUrl ( queueUrl ) ; setEntries ( entries ) ; }
public void writeInt ( int v ) { writeContinueIfRequired ( 4 ) ; _ulrOutput . writeInt ( v ) ; }
public DescribeDataSourcesResult describeDataSources ( DescribeDataSourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDataSources ( request ) ; }
public ListRoomsResult listRooms ( ListRoomsRequest request ) { request = beforeClientExecution ( request ) ; return executeListRooms ( request ) ; }
public char getConversion ( ) { return c ; }
public boolean equals ( Object _other ) { FieldAndTerm other = ( FieldAndTerm ) _other ; return other . field . equals ( field ) && term . bytesEquals ( other . term ) ; }
public CreateConfigurationSetEventDestinationResult createConfigurationSetEventDestination ( CreateConfigurationSetEventDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateConfigurationSetEventDestination ( request ) ; }
public Ole10Native ( String label , String filename , String command , byte [ ] data ) { setLabel ( label ) ; setFileName ( filename ) ; setCommand ( command ) ; setDataBuffer ( data ) ; mode = EncodingMode . parsed ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( fetchResult != null ) sb . append ( fetchResult . toString ( ) ) ; elsesb . append ( " No ▁ fetch ▁ result " ) ; sb . append ( " \ n " ) ; if ( mergeResult != null ) sb . append ( mergeResult . toString ( ) ) ; else if ( rebaseResult != null ) sb . append ( rebaseResult . toString ( ) ) ; elsesb . append ( " No ▁ update ▁ result " ) ; return sb . toString ( ) ; }
public static Cell createCell ( Row row , int column , String value ) { return createCell ( row , column , value , null ) ; }
public TokenStream create ( TokenStream input ) { return new HindiNormalizationFilter ( input ) ; }
public DescribeAddressesResult describeAddresses ( ) { return describeAddresses ( new DescribeAddressesRequest ( ) ) ; }
public SimpleQQParser ( String qqName , String indexField ) { this ( new String [ ] { qqName } , indexField ) ; }
public void dispatch ( RefsChangedListener listener ) { listener . onRefsChanged ( this ) ; }
public SnowballFilter ( TokenStream in , String name ) { super ( in ) ; try { Class <? extends SnowballStemmer > stemClass = Class . forName ( " org . tartarus . snowball . ext . " + name + " Stemmer " ) . asSubclass ( SnowballStemmer . class ) ; stemmer = stemClass . getConstructor ( ) . newInstance ( ) ; } catch ( Exception e ) { } }
public UpgradeAppliedSchemaResult upgradeAppliedSchema ( UpgradeAppliedSchemaRequest request ) { request = beforeClientExecution ( request ) ; return executeUpgradeAppliedSchema ( request ) ; }
public String getParent ( ) { int length = path . length ( ) , firstInPath = 0 ; if ( separatorChar == ' \\ ' ▁ && ▁ length ▁ > ▁ 2 ▁ && ▁ path . charAt ( 1 ) ▁ == ▁ ' : ' ) ▁ { firstInPath ▁ = ▁ 2 ; } int ▁ index ▁ = ▁ path . lastIndexOf ( separatorChar ) ; if ▁ ( index ▁ == ▁ - 1 ▁ && ▁ firstInPath ▁ > ▁ 0 ) ▁ { index ▁ = ▁ 2 ; } if ▁ ( index ▁ == ▁ - 1 ▁ || ▁ path . charAt ( length ▁ - ▁ 1 ) ▁ == ▁ separatorChar ) ▁ { return ▁ null ; } if ▁ ( path . indexOf ( separatorChar ) ▁ == ▁ index && ▁ path . charAt ( firstInPath ) ▁ == ▁ separatorChar ) ▁ { return ▁ path . substring ( 0 , ▁ index ▁ + ▁ 1 ) ; } return ▁ path . substring ( 0 , ▁ index ) ; }
public BufferedChecksumIndexInput ( IndexInput main ) { super ( " BufferedChecksumIndexInput ( " + main + " ) " ) ; this . main = main ; this . digest = new BufferedChecksum ( new CRC32 ( ) ) ; }
public final void remove ( RevFlagSet set ) { flags &= ~ set . mask ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; return true ; }
public GetFaceSearchResult getFaceSearch ( GetFaceSearchRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFaceSearch ( request ) ; }
public DescribeUserStackAssociationsResult describeUserStackAssociations ( DescribeUserStackAssociationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeUserStackAssociations ( request ) ; }
public void close ( ) throws IOException { in . close ( ) ; in = new ClosedInputStream ( ) ; }
public CreateBranchCommand branchCreate ( ) { return new CreateBranchCommand ( repo ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( rt ) ; out . writeShort ( grbitFrt ) ; out . writeShort ( wOffset ) ; out . writeShort ( at ) ; out . writeShort ( grbit ) ; if ( unused != null ) out . writeShort ( unused ) ; }
public StringBuilder insert ( int offset , Object obj ) { insert0 ( offset , obj == null ? " null " : obj . toString ( ) ) ; return this ; }
public int next ( ) { int res = child ; if ( child != TaxonomyReader . INVALID_ORDINAL ) { child = siblings [ child ] ; } return res ; }
public DeleteStackResult deleteStack ( DeleteStackRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteStack ( request ) ; }
public NorwegianMinimalStemFilterFactory ( Map < String , String > args ) { super ( args ) ; String variant = get ( args , " variant " ) ; if ( variant == null || " nb " . equals ( variant ) ) { flags = BOKMAAL ; } else if ( " nn " . equals ( variant ) ) { flags = NYNORSK ; } else if ( " no " . equals ( variant ) ) { flags = BOKMAAL | NYNORSK ; } else { throw new IllegalArgumentException ( " invalid ▁ variant : ▁ " + variant ) ; } if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public String toString ( ) { return " Z ( " + z + " ) " ; }
public static org . apache . poi . hssf . record . Record create ( RecordInputStream in ) { switch ( in . remaining ( ) ) { case 0 : return instance ; case 2 : return new InterfaceHdrRecord ( in ) ; } throw new RecordFormatException ( " Invalid ▁ record ▁ data ▁ size : ▁ " + in . remaining ( ) ) ; }
public int getCellsPnt ( ) { int size = 0 ; for ( Row row : rows ) size += row . getCellsPnt ( ) ; return size ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof LexerActionExecutor ) ) { return false ; } LexerActionExecutor other = ( LexerActionExecutor ) obj ; return hashCode == other . hashCode && Arrays . equals ( lexerActions , other . lexerActions ) ; }
public static final Analyzer createAnalyzer ( String className ) throws Exception { final Class <? extends Analyzer > clazz = Class . forName ( className ) . asSubclass ( Analyzer . class ) ; try { Constructor <? extends Analyzer > cnstr = clazz . getConstructor ( Version . class ) ; return cnstr . newInstance ( Version . LATEST ) ; } catch ( NoSuchMethodException nsme ) { return clazz . getConstructor ( ) . newInstance ( ) ; } }
public GetSegmentVersionsResult getSegmentVersions ( GetSegmentVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSegmentVersions ( request ) ; }
public int getDeltaBaseCacheLimit ( ) { return deltaBaseCacheLimit ; }
public GroupMerger ( Sort groupSort ) { groupComp = new GroupComparator <> ( groupSort ) ; queue = new TreeSet <> ( groupComp ) ; groupsSeen = new HashMap <> ( ) ; }
public long get ( int index ) { final int o = index >>> 4 ; final int b = index & 15 ; final int shift = b << 2 ; return ( blocks [ o ] >>> shift ) & 15L ; }
public FileIdCluster ( int drawingGroupId , int numShapeIdsUsed ) { this . field_1_drawingGroupId = drawingGroupId ; this . field_2_numShapeIdsUsed = numShapeIdsUsed ; }
public CharArrayIterator clone ( ) { CharArrayIterator clone = new CharArrayIterator ( ) ; clone . setText ( array , start , length ) ; clone . index = index ; return clone ; }
public DescribeReservedNodesResult describeReservedNodes ( DescribeReservedNodesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReservedNodes ( request ) ; }
public ObjectWalk ( Repository repo , int depth ) { super ( repo ) ; this . depth = depth ; this . deepenNots = Collections . emptyList ( ) ; this . UNSHALLOW = newFlag ( " UNSHALLOW " ) ; this . REINTERESTING = newFlag ( " REINTERESTING " ) ; this . DEEPEN_NOT = newFlag ( " DEEPEN □ NOT " ) ; }
public boolean isRefLogDisabled ( ) { return refLogMessage == null ; }
public SetLoadBalancerListenerSSLCertificateResult setLoadBalancerListenerSSLCertificate ( SetLoadBalancerListenerSSLCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeSetLoadBalancerListenerSSLCertificate ( request ) ; }
public DescribeRulesPackagesResult describeRulesPackages ( DescribeRulesPackagesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeRulesPackages ( request ) ; }
public byte readByte ( ) throws IOException { return primitiveTypes . readByte ( ) ; }
public String getConversion ( ) { return s ; }
public StandardSyntaxParserTokenManager ( CharStream stream , int lexState ) { this ( stream ) ; SwitchTo ( lexState ) ; }
public TokenStream create ( TokenStream input ) { return new TurkishLowerCaseFilter ( input ) ; }
public String toString ( ) { return " B " ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { return evaluate ( srcRowIndex , srcColumnIndex , arg0 , DEFAULT_ARG1 ) ; }
public void doubleField ( FieldInfo fieldInfo , double value ) { doc . add ( new StoredField ( fieldInfo . name , value ) ) ; }
public GetDistributionConfigRequest ( String id ) { setId ( id ) ; }
public DescribeCacheSecurityGroupsResult describeCacheSecurityGroups ( ) { return describeCacheSecurityGroups ( new DescribeCacheSecurityGroupsRequest ( ) ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { double d ; try { ValueEval ve = OperandResolver . getSingleValue ( arg0 , srcRowIndex , srcColumnIndex ) ; d = OperandResolver . coerceValueToDouble ( ve ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } if ( d == 0.0 ) { return NumberEval . ZERO ; } return new NumberEval ( d / 100 ) ; }
public boolean containsCell ( int rowIndex , int columnIndex ) { if ( columnIndex < _firstColumnIndex ) { return false ; } if ( columnIndex > _lastColumnIndex ) { return false ; } if ( rowIndex < _firstRowIndex ) { return false ; } if ( rowIndex > _lastRowIndex ) { return false ; } return true ; }
public GetSegmentVersionResult getSegmentVersion ( GetSegmentVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSegmentVersion ( request ) ; }
public final FloatBuffer put ( float [ ] src , int srcOffset , int byteCount ) { throw new ReadOnlyBufferException ( ) ; }
public final IntBuffer put ( int [ ] src ) { return put ( src , 0 , src . length ) ; }
public SearchFaceRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " SearchFace " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public TagStreamResult tagStream ( TagStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeTagStream ( request ) ; }
public String getAccessKeyId ( ) { return this . accessKeyId ; }
public ET previous ( ) { if ( expectedModCount == list . modCount ) { if ( link != list . voidLink ) { lastLink = link ; link = link . previous ; pos -- ; return lastLink . data ; } throw new NoSuchElementException ( ) ; } throw new ConcurrentModificationException ( ) ; }
public CreateLBCookieStickinessPolicyResult createLBCookieStickinessPolicy ( CreateLBCookieStickinessPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLBCookieStickinessPolicy ( request ) ; }
public CreateDataSourceFromRDSResult createDataSourceFromRDS ( CreateDataSourceFromRDSRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDataSourceFromRDS ( request ) ; }
public CreateReceiptFilterResult createReceiptFilter ( CreateReceiptFilterRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateReceiptFilter ( request ) ; }
public final byte get ( int index ) { checkIndex ( index ) ; return backingArray [ offset + index ] ; }
public CherryPickCommand include ( AnyObjectId commit ) { return include ( commit . getName ( ) , commit ) ; }
public ATNDeserializationOptions ( ) { this . verifyATN = true ; this . generateRuleBypassTransitions = false ; }
public ListIdentityPoliciesResult listIdentityPolicies ( ListIdentityPoliciesRequest request ) { request = beforeClientExecution ( request ) ; return executeListIdentityPolicies ( request ) ; }
public static boolean isValidCode ( int errorCode ) { for ( FormulaError error : values ( ) ) { if ( error . getCode ( ) == errorCode ) return true ; if ( error . getLongCode ( ) == errorCode ) return true ; } return false ; }
public RKRecord ( RecordInputStream in ) { super ( in ) ; field_4_rk_number = in . readInt ( ) ; }
public void copyTo ( ByteBuffer b ) { b . put ( toHexByteArray ( ) ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ DAT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . options ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getOptions ( ) ) ) . append ( " ▁ ( " ) . append ( getOptions ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . horizontalBorder ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( isHorizontalBorder ( ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . verticalBorder ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( isVerticalBorder ( ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . border ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( isBorder ( ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . showSeriesKey ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( isShowSeriesKey ( ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / DAT ] \ n " ) ; return buffer . toString ( ) ; }
public UpdateDashboardResult updateDashboard ( UpdateDashboardRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDashboard ( request ) ; }
public RegisterTagRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " RegisterTag " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DiffCommand setPathFilter ( TreeFilter pathFilter ) { this . pathFilter = pathFilter ; return this ; }
public boolean markSupported ( ) { return true ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( getClass ( ) . getSimpleName ( ) + " : ▁ " ) ; sb . append ( " maxThreadCount = " ) . append ( maxThreadCount ) . append ( " , ▁ " ) ; sb . append ( " maxMergeCount = " ) . append ( maxMergeCount ) . append ( " , ▁ " ) ; sb . append ( " ioThrottle = " ) . append ( doAutoIOThrottle ) ; return sb . toString ( ) ; }
public synchronized void println ( String str ) { print ( str ) ; newline ( ) ; }
public UpdateApiResult updateApi ( UpdateApiRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateApi ( request ) ; }
public FlushStageAuthorizersCacheResult flushStageAuthorizersCache ( FlushStageAuthorizersCacheRequest request ) { request = beforeClientExecution ( request ) ; return executeFlushStageAuthorizersCache ( request ) ; }
public BasicQueryFactory ( int maxBasicQueries ) { this . maxBasicQueries = maxBasicQueries ; this . queriesMade = 0 ; }
public TrackingRefUpdate getTrackingRefUpdate ( String localName ) { return updates . get ( localName ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ CATLAB ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rt ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( rt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbitFrt = " ) . append ( HexDump . shortToHex ( grbitFrt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . wOffset ▁ = " ) . append ( HexDump . shortToHex ( wOffset ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . at ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( at ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbit ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( grbit ) ) . append ( ' \ n ' ) ; if ( unused != null ) buffer . append ( " ▁ ▁ ▁ ▁ . unused ▁ ▁ = " ) . append ( HexDump . shortToHex ( unused ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / CATLAB ] \ n " ) ; return buffer . toString ( ) ; }
public EnableDirectoryResult enableDirectory ( EnableDirectoryRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableDirectory ( request ) ; }
public IntBuffer put ( int [ ] src , int srcOffset , int intCount ) { if ( intCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } System . arraycopy ( src , srcOffset , backingArray , offset + position , intCount ) ; position += intCount ; return this ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ PROT4REVPASSWORD ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . password ▁ = ▁ " ) . append ( HexDump . shortToHex ( field_1_password ) ) . append ( " \ n " ) ; buffer . append ( " [ / PROT4REVPASSWORD ] \ n " ) ; return buffer . toString ( ) ; }
public DescribeProjectVersionsResult describeProjectVersions ( DescribeProjectVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeProjectVersions ( request ) ; }
public UpdateHostedZoneCommentResult updateHostedZoneComment ( UpdateHostedZoneCommentRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateHostedZoneComment ( request ) ; }
public Rescorer getRescorer ( Bindings bindings ) { return new ExpressionRescorer ( this , bindings ) ; }
public SortedSet < E > headSet ( E end ) { return headSet ( end , false ) ; }
final public QueryNode DisjQuery ( CharSequence field ) throws ParseException { QueryNode first , c ; Vector < QueryNode > clauses = null ; first = ConjQuery ( field ) ; label_2 : while ( true ) { switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case OR : ; break ; default : jj_la1 [ 3 ] = jj_gen ; break label_2 ; } jj_consume_token ( OR ) ; c = ConjQuery ( field ) ; if ( clauses == null ) { clauses = new Vector < QueryNode > ( ) ; clauses . addElement ( first ) ; } clauses . addElement ( c ) ; } if ( clauses != null ) { { if ( true ) return new OrQueryNode ( clauses ) ; } } else { { if ( true ) return first ; } } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public DataValidationConstraint createExplicitListConstraint ( String [ ] listOfValues ) { return DVConstraint . createExplicitListConstraint ( listOfValues ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { String s0 ; String s1 ; try { s0 = evaluateStringArg ( arg0 , srcRowIndex , srcColumnIndex ) ; s1 = evaluateStringArg ( arg1 , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return BoolEval . valueOf ( s0. equals ( s1 ) ) ; }
public boolean offer ( E o ) { return addLastImpl ( o ) ; }
public ListInvalidationsRequest ( String distributionId ) { setDistributionId ( distributionId ) ; }
public TagPhotoRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " TagPhoto " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public CreateFleetResult createFleet ( CreateFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFleet ( request ) ; }
public GetTransitGatewayAttachmentPropagationsResult getTransitGatewayAttachmentPropagations ( GetTransitGatewayAttachmentPropagationsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTransitGatewayAttachmentPropagations ( request ) ; }
public ListWorkteamsResult listWorkteams ( ListWorkteamsRequest request ) { request = beforeClientExecution ( request ) ; return executeListWorkteams ( request ) ; }
public DetachVpnGatewayResult detachVpnGateway ( DetachVpnGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachVpnGateway ( request ) ; }
public ListGeoLocationsResult listGeoLocations ( ) { return listGeoLocations ( new ListGeoLocationsRequest ( ) ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + getStringValue ( ) + " ] " ; }
public static double decodeNumber ( int number ) { long raw_number = number ; raw_number = raw_number >> 2 ; double rvalue = 0 ; if ( ( number & 0x02 ) == 0x02 ) { rvalue = raw_number ; } else { rvalue = Double . longBitsToDouble ( raw_number << 34 ) ; } if ( ( number & 0x01 ) == 0x01 ) { rvalue /= 100 ; } return rvalue ; }
public long get ( long index ) { assert index >= 0 && index < valueCount ; final int block = ( int ) ( index >>> blockShift ) ; final int idx = ( int ) ( index & blockMask ) ; return ( minValues == null ? 0 : minValues [ block ] ) + subReaders [ block ] . get ( idx ) ; }
public UpdatePublishingDestinationResult updatePublishingDestination ( UpdatePublishingDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdatePublishingDestination ( request ) ; }
public void notifyDeleteCell ( EvaluationCell cell ) { int sheetIndex = getSheetIndex ( cell . getSheet ( ) ) ; _cache . notifyDeleteCell ( _workbookIx , sheetIndex , cell ) ; }
public Request < GetPolicyRequest > marshall ( GetPolicyRequest getPolicyRequest ) { if ( getPolicyRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( ... ) " ) ; } Request < GetPolicyRequest > request = new DefaultRequest < GetPolicyRequest > ( getPolicyRequest , " AmazonIdentityManagement " ) ; request . addParameter ( " Action " , " GetPolicy " ) ; request . addParameter ( " Version " , " 2010 - 05 - 08 " ) ; request . setHttpMethod ( HttpMethodName . POST ) ; if ( getPolicyRequest . getPolicyArn ( ) != null ) { request . addParameter ( " PolicyArn " , StringUtils . fromString ( getPolicyRequest . getPolicyArn ( ) ) ) ; } return request ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval real_num , ValueEval i_num ) { return this . evaluate ( srcRowIndex , srcColumnIndex , real_num , i_num , new StringEval ( DEFAULT_SUFFIX ) ) ; }
public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { readHeader ( data , offset ) ; int pos = offset + 8 ; int size = 0 ; field_1_numShapes = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_2_lastMSOSPID = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; return getRecordSize ( ) ; }
public final CharsetEncoder reset ( ) { status = INIT ; implReset ( ) ; return this ; }
public void emit ( Token token ) { this . _token = token ; }
public AbstractTreeIterator createSubtreeIterator ( ObjectReader reader ) throws IncorrectObjectTypeException , IOException { if ( currentSubtree == null ) throw new IncorrectObjectTypeException ( getEntryObjectId ( ) , Constants . TYPE_TREE ) ; return new DirCacheBuildIterator ( this , currentSubtree ) ; }
public GreekLowerCaseFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public URI relativize ( URI relative ) { if ( relative . opaque || opaque ) { return relative ; } if ( scheme == null ? relative . scheme != null : ! scheme . equals ( relative . scheme ) ) { return relative ; } if ( authority == null ? relative . authority != null : ! authority . equals ( relative . authority ) ) { return relative ; } String thisPath = normalize ( path , false ) ; String relativePath = normalize ( relative . path , false ) ; if ( ! thisPath . equals ( relativePath ) ) { thisPath = thisPath . substring ( 0 , thisPath . lastIndexOf ( ' / ' ) + 1 ) ; if ( ! relativePath . startsWith ( thisPath ) ) { return relative ; } } URI result = new URI ( ) ; result . fragment = relative . fragment ; result . query = relative . query ; result . path = relativePath . substring ( thisPath . length ( ) ) ; result . setSchemeSpecificPart ( ) ; return result ; }
public Reader freeze ( boolean trim ) { if ( frozen ) { throw new IllegalStateException ( " already ▁ frozen " ) ; } if ( didSkipBytes ) { throw new IllegalStateException ( " cannot ▁ freeze ▁ when ▁ copy ( BytesRef , ▁ BytesRef ) ▁ was ▁ used " ) ; } if ( trim && upto < blockSize ) { final byte [ ] newBlock = new byte [ upto ] ; System . arraycopy ( currentBlock , 0 , newBlock , 0 , upto ) ; currentBlock = newBlock ; } if ( currentBlock == null ) { currentBlock = EMPTY_BYTES ; } addBlock ( currentBlock ) ; frozen = true ; currentBlock = null ; return new PagedBytes . Reader ( this ) ; }
public ValueEval evaluate ( ValueEval [ ] args , OperationEvaluationContext ec ) { if ( args . length == 2 ) { return evaluate ( ec . getRowIndex ( ) , ec . getColumnIndex ( ) , args [ 0 ] , args [ 1 ] ) ; } if ( args . length == 3 ) { return evaluate ( ec . getRowIndex ( ) , ec . getColumnIndex ( ) , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; } return ErrorEval . VALUE_INVALID ; }
public Cluster createCluster ( CreateClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCluster ( request ) ; }
public PersistentSnapshotDeletionPolicy ( IndexDeletionPolicy primary , Directory dir , OpenMode mode ) throws IOException { super ( primary ) ; this . dir = dir ; if ( mode == OpenMode . CREATE ) { clearPriorSnapshots ( ) ; } loadPriorSnapshots ( ) ; if ( mode == OpenMode . APPEND && nextWriteGen == 0 ) { throw new IllegalStateException ( " no ▁ snapshots ▁ stored ▁ in ▁ this ▁ directory " ) ; } }
public String getText ( RuleContext ctx ) { return getText ( ctx . getSourceInterval ( ) ) ; }
public final float get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return backingArray [ offset + position ++ ] ; }
public DeleteDataSetResult deleteDataSet ( DeleteDataSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDataSet ( request ) ; }
public boolean contains ( Object o ) { return containsKey ( o ) ; }
public boolean matches ( char s [ ] , int len ) { return super . matches ( s , len ) && ! exceptions . contains ( s , 0 , len ) ; }
public int getDeltaSearchWindowSize ( ) { return deltaSearchWindowSize ; }
public GetDomainNameResult getDomainName ( GetDomainNameRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDomainName ( request ) ; }
public DeleteAccessLogSettingsResult deleteAccessLogSettings ( DeleteAccessLogSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAccessLogSettings ( request ) ; }
public QueryValueSource ( Query q , float defVal ) { this . q = q ; this . defVal = defVal ; }
@ Override public Object [ ] toArray ( ) { return snapshot ( ) . toArray ( ) ; }
public String toLexerString ( ) { if ( s0 == null ) return " " ; DFASerializer serializer = new LexerDFASerializer ( this ) ; return serializer . toString ( ) ; }
public void clear ( ) { fill ( 0 , size ( ) , 0 ) ; }
public GetStreamingDistributionConfigResult getStreamingDistributionConfig ( GetStreamingDistributionConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeGetStreamingDistributionConfig ( request ) ; }
public UpdateDomainContactResult updateDomainContact ( UpdateDomainContactRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDomainContact ( request ) ; }
public ListIterator < E > listIterator ( int location ) { return new LinkIterator < E > ( this , location ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ STARTBLOCK ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rt ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( rt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbitFrt ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( grbitFrt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . iObjectKind ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( iObjectKind ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . iObjectContext ▁ ▁ = " ) . append ( HexDump . shortToHex ( iObjectContext ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . iObjectInstance1 = " ) . append ( HexDump . shortToHex ( iObjectInstance1 ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . iObjectInstance2 = " ) . append ( HexDump . shortToHex ( iObjectInstance2 ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / STARTBLOCK ] \ n " ) ; return buffer . toString ( ) ; }
public long get ( int index ) { final int o = index / 7 ; final int b = index % 7 ; final int shift = b * 9 ; return ( blocks [ o ] >>> shift ) & 511L ; }
public String toString ( String field ) { StringBuilder buffer = new StringBuilder ( ) ; boolean needParens = ( getLowFreqMinimumNumberShouldMatch ( ) > 0 ) ; if ( needParens ) { buffer . append ( " ( " ) ; } for ( int i = 0 ; i < terms . size ( ) ; i ++ ) { Term t = terms . get ( i ) ; buffer . append ( newTermQuery ( t , null ) . toString ( ) ) ; if ( i != terms . size ( ) - 1 ) buffer . append ( " , ▁ " ) ; } if ( needParens ) { buffer . append ( " ) " ) ; } if ( getLowFreqMinimumNumberShouldMatch ( ) > 0 || getHighFreqMinimumNumberShouldMatch ( ) > 0 ) { buffer . append ( ' ~ ' ) ; buffer . append ( " ( " ) ; buffer . append ( getLowFreqMinimumNumberShouldMatch ( ) ) ; buffer . append ( getHighFreqMinimumNumberShouldMatch ( ) ) ; buffer . append ( " ) " ) ; } return buffer . toString ( ) ; }
public String [ ] getStopWords ( String fieldName ) { Set < String > stopWords = stopWordsPerField . get ( fieldName ) ; return stopWords != null ? stopWords . toArray ( new String [ stopWords . size ( ) ] ) : new String [ 0 ] ; }
public void print ( float f ) { print ( String . valueOf ( f ) ) ; }
public MopenCreateGroupRequest ( ) { super ( " MoPen " , " 2018 - 02 - 11 " , " MopenCreateGroup " , " mopen " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public SmallObject ( int type , byte [ ] data ) { this . type = type ; this . data = data ; }
public final boolean matches ( char c ) { return Character . isUpperCase ( c ) ; }
public StartNotebookInstanceResult startNotebookInstance ( StartNotebookInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeStartNotebookInstance ( request ) ; }
public static void putUnicodeLE ( String input , byte [ ] output , int offset ) { byte [ ] bytes = input . getBytes ( UTF16LE ) ; System . arraycopy ( bytes , 0 , output , offset , bytes . length ) ; }
public void deleteDocument ( int docID ) { final int i = readerIndex ( docID ) ; getSequentialSubReaders ( ) . get ( i ) . deleteDocument ( docID - readerBase ( i ) ) ; }
public boolean isRelevant ( String docName , QualityQuery query ) { QRelJudgement qrj = judgements . get ( query . getQueryID ( ) ) ; return qrj != null && qrj . isRelevant ( docName ) ; }
public final int getBeginB ( ) { return beginB ; }
public ModifySpotFleetRequestResult modifySpotFleetRequest ( ModifySpotFleetRequestRequest request ) { request = beforeClientExecution ( request ) ; return executeModifySpotFleetRequest ( request ) ; }
public UncalcedRecord ( ) { _reserved = 0 ; }
public static PageOrder valueOf ( int value ) { return _table [ value ] ; }
public static CellValue valueOf ( boolean booleanValue ) { return booleanValue ? TRUE : FALSE ; }
public void write ( String str ) { buf . append ( str ) ; }
public void addListener ( HSSFListener lsnr , short sid ) { List < HSSFListener > list = _records . computeIfAbsent ( Short . valueOf ( sid ) , k -> new ArrayList <> ( 1 ) ) ; list . add ( lsnr ) ; }
public GetMeetingResult getMeeting ( GetMeetingRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMeeting ( request ) ; }
public void stopTimer ( ) { stop = true ; }
public AttachLoadBalancerTargetGroupsResult attachLoadBalancerTargetGroups ( AttachLoadBalancerTargetGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachLoadBalancerTargetGroups ( request ) ; }
public GetQueryLoggingConfigResult getQueryLoggingConfig ( GetQueryLoggingConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeGetQueryLoggingConfig ( request ) ; }
public ListIterator < E > listIterator ( ) { Object [ ] snapshot = elements ; return new CowIterator < E > ( snapshot , 0 , snapshot . length ) ; }
public CreateSnapshotResult createSnapshot ( CreateSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSnapshot ( request ) ; }
public boolean hasObject ( AnyObjectId objectId ) { try { return getObjectDatabase ( ) . has ( objectId ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public final void sort ( int from , int to ) { checkRange ( from , to ) ; mergeSort ( from , to ) ; }
public < T extends EscherRecord > T getChildById ( short recordId ) { for ( EscherRecord childRecord : this ) { if ( childRecord . getRecordId ( ) == recordId ) { @ SuppressWarnings ( " unchecked " ) final T result = ( T ) childRecord ; return result ; } } return null ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_xBasis ) ; out . writeShort ( field_2_yBasis ) ; out . writeShort ( field_3_heightBasis ) ; out . writeShort ( field_4_scale ) ; out . writeShort ( field_5_indexToFontTable ) ; }
public static String toHex ( int value ) { StringBuilder sb = new StringBuilder ( 8 ) ; writeHex ( sb , value & 0xFFFFFFFFL , 8 , " " ) ; return sb . toString ( ) ; }
public static Collection < Ref > sort ( Collection < Ref > refs ) { final List < Ref > r = new ArrayList <> ( refs ) ; Collections . sort ( r , INSTANCE ) ; return r ; }
public DescribeVpcsResult describeVpcs ( ) { return describeVpcs ( new DescribeVpcsRequest ( ) ) ; }
public ListProposalsResult listProposals ( ListProposalsRequest request ) { request = beforeClientExecution ( request ) ; return executeListProposals ( request ) ; }
public void close ( ) throws IOException { flush ( ) ; output . close ( ) ; }
public final T get ( ) { return object ; }
public BundleInstanceRequest ( String instanceId , Storage storage ) { setInstanceId ( instanceId ) ; setStorage ( storage ) ; }
public void back ( int delta ) { if ( delta == 1 && 0 <= prevPtr ) { currPtr = prevPtr ; prevPtr = - 1 ; if ( ! eof ( ) ) parseEntry ( ) ; return ; } else if ( delta <= 0 ) throw new ArrayIndexOutOfBoundsException ( delta ) ; final int [ ] trace = new int [ delta + 1 ] ; Arrays . fill ( trace , - 1 ) ; int ptr = 0 ; while ( ptr != currPtr ) { System . arraycopy ( trace , 1 , trace , 0 , delta ) ; trace [ delta ] = ptr ; while ( raw [ ptr ] != 0 ) ptr ++ ; ptr += OBJECT_ID_LENGTH + 1 ; } if ( trace [ 1 ] == - 1 ) throw new ArrayIndexOutOfBoundsException ( delta ) ; prevPtr = trace [ 0 ] ; currPtr = trace [ 1 ] ; parseEntry ( ) ; }
public String toString ( ) { return " pred □ " + ruleIndex + " : " + predIndex ; }
public PatternSyntaxException ( String description , String pattern , int index ) { this . desc = description ; this . pattern = pattern ; this . index = index ; }
public AlphaAnimation ( float from , float to ) { mStartAlpha = from ; mEndAlpha = to ; mCurrentAlpha = from ; }
public int doLogic ( ) throws Exception { TaxonomyWriter taxonomyWriter = getRunData ( ) . getTaxonomyWriter ( ) ; if ( taxonomyWriter != null ) { taxonomyWriter . commit ( ) ; } else { throw new IllegalStateException ( " TaxonomyWriter ▁ is ▁ not ▁ currently ▁ open " ) ; } return 1 ; }
public DeltaIndex ( byte [ ] sourceBuffer ) { src = sourceBuffer ; DeltaIndexScanner scan = new DeltaIndexScanner ( src , src . length ) ; table = scan . table ; tableMask = scan . tableMask ; entries = new long [ 1 + countEntries ( scan ) ] ; copyEntries ( scan ) ; }
public int previousIndex ( ) { return pos ; }
public QueryMaker getQueryMaker ( ) { return getRunData ( ) . getQueryMaker ( this ) ; }
public JapaneseTokenizerFactory ( Map < String , String > args ) { super ( args ) ; mode = Mode . valueOf ( get ( args , MODE , JapaneseTokenizer . DEFAULT_MODE . toString ( ) ) . toUpperCase ( Locale . ROOT ) ) ; userDictionaryPath = args . remove ( USER_DICT_PATH ) ; userDictionaryEncoding = args . remove ( USER_DICT_ENCODING ) ; discardPunctuation = getBoolean ( args , DISCARD_PUNCTUATION , true ) ; discardCompoundToken = getBoolean ( args , DISCARD_COMPOUND_TOKEN , true ) ; nbestCost = getInt ( args , NBEST_COST , 0 ) ; nbestExamples = args . remove ( NBEST_EXAMPLES ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public Long longValue ( String key ) { String value = responseMap . get ( key ) ; if ( null == value || 0 == value . length ( ) ) { return null ; } return Long . valueOf ( responseMap . get ( key ) ) ; }
public GetLibraryRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetLibrary " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public short getFontOfFormattingRun ( int index ) { FormatRun r = _string . getFormatRun ( index ) ; return r . getFontIndex ( ) ; }
public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; int size = 0 ; field_1_shapeIdMax = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; size += 4 ; field_3_numShapesSaved = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_4_drawingsSaved = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_5_fileIdClusters . clear ( ) ; int numIdClusters = ( bytesRemaining - size ) / 8 ; for ( int i = 0 ; i < numIdClusters ; i ++ ) { int drawingGroupId = LittleEndian . getInt ( data , pos + size ) ; int numShapeIdsUsed = LittleEndian . getInt ( data , pos + size + 4 ) ; FileIdCluster fic = new FileIdCluster ( drawingGroupId , numShapeIdsUsed ) ; field_5_fileIdClusters . add ( fic ) ; maxDgId = Math . max ( maxDgId , drawingGroupId ) ; size += 8 ; } bytesRemaining -= size ; if ( bytesRemaining != 0 ) { throw new RecordFormatException ( " Expecting ▁ no ▁ remaining ▁ data ▁ but ▁ got ▁ " + bytesRemaining + " ▁ byte ( s ) . " ) ; } return 8 + size ; }
public void encode ( int [ ] values , int valuesOffset , byte [ ] blocks , int blocksOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = encode ( values , valuesOffset ) ; valuesOffset += valueCount ; blocksOffset = writeLong ( block , blocks , blocksOffset ) ; } }
public GetTerminologyResult getTerminology ( GetTerminologyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTerminology ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _character ) ; out . writeShort ( _fontIndex ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_options ) ; }
public SearchFacesResult searchFaces ( SearchFacesRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchFaces ( request ) ; }
public int getPositionIncrementGap ( String fieldName ) { return getWrappedAnalyzer ( fieldName ) . getPositionIncrementGap ( fieldName ) ; }
public DescribeSchemaResult describeSchema ( DescribeSchemaRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSchema ( request ) ; }
@ Override public int size ( ) { return BoundedMap . this . size ( ) ; }
public MutableEntry cloneEntry ( ) { final MutableEntry r = new MutableEntry ( ) ; ensureId ( ) ; r . idBuffer . fromObjectId ( idBuffer ) ; r . offset = offset ; return r ; }
public OperateEquipmentRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " OperateEquipment " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public boolean add ( E e ) { synchronized ( mutex ) { return delegate ( ) . add ( e ) ; } }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof EscherSimpleProperty ) ) { return false ; } final EscherSimpleProperty escherSimpleProperty = ( EscherSimpleProperty ) o ; if ( propertyValue != escherSimpleProperty . propertyValue ) { return false ; } if ( getId ( ) != escherSimpleProperty . getId ( ) ) { return false ; } return true ; }
public final FloatBuffer asFloatBuffer ( ) { return FloatToByteBufferAdapter . asFloatBuffer ( this ) ; }
public void removeThumbnail ( ) { remove1stProperty ( PropertyIDMap . PID_THUMBNAIL ) ; }
public static int compareIgnoreCase ( String a , String b ) { for ( int i = 0 ; i < a . length ( ) && i < b . length ( ) ; i ++ ) { int d = toLowerCase ( a . charAt ( i ) ) - toLowerCase ( b . charAt ( i ) ) ; if ( d != 0 ) return d ; } return a . length ( ) - b . length ( ) ; }
public ViewDefinitionRecord ( RecordInputStream in ) { rwFirst = in . readUShort ( ) ; rwLast = in . readUShort ( ) ; colFirst = in . readUShort ( ) ; colLast = in . readUShort ( ) ; rwFirstHead = in . readUShort ( ) ; rwFirstData = in . readUShort ( ) ; colFirstData = in . readUShort ( ) ; iCache = in . readUShort ( ) ; reserved = in . readUShort ( ) ; sxaxis4Data = in . readUShort ( ) ; ipos4Data = in . readUShort ( ) ; cDim = in . readUShort ( ) ; cDimRw = in . readUShort ( ) ; cDimCol = in . readUShort ( ) ; cDimPg = in . readUShort ( ) ; cDimData = in . readUShort ( ) ; cRw = in . readUShort ( ) ; cCol = in . readUShort ( ) ; grbit = in . readUShort ( ) ; itblAutoFmt = in . readUShort ( ) ; int cchName = in . readUShort ( ) ; int cchData = in . readUShort ( ) ; name = StringUtil . readUnicodeString ( in , cchName ) ; dataField = StringUtil . readUnicodeString ( in , cchData ) ; }
public FormatRecord ( RecordInputStream in ) { field_1_index_code = in . readShort ( ) ; int field_3_unicode_len = in . readUShort ( ) ; field_3_hasMultibyte = ( in . readByte ( ) & 0x01 ) != 0 ; if ( field_3_hasMultibyte ) { field_4_formatstring = readStringCommon ( in , field_3_unicode_len , false ) ; } else { field_4_formatstring = readStringCommon ( in , field_3_unicode_len , true ) ; } }
public DescribeBrokerResult describeBroker ( DescribeBrokerRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeBroker ( request ) ; }
public void reset ( ) { if ( getInputStream ( ) != null ) getInputStream ( ) . seek ( 0 ) ; _errHandler . reset ( this ) ; _ctx = null ; _syntaxErrors = 0 ; matchedEOF = false ; setTrace ( false ) ; _precedenceStack . clear ( ) ; _precedenceStack . push ( 0 ) ; ATNSimulator interpreter = getInterpreter ( ) ; if ( interpreter != null ) { interpreter . reset ( ) ; } }
public boolean remove ( Object o ) { final RevFlag flag = ( RevFlag ) o ; if ( ( mask & flag . mask ) == 0 ) return false ; mask &= ~ flag . mask ; for ( int i = 0 ; i < active . size ( ) ; i ++ ) if ( active . get ( i ) . mask == flag . mask ) active . remove ( i ) ; return true ; }
public String format ( Passage passages [ ] , String content ) { StringBuilder sb = new StringBuilder ( ) ; int pos = 0 ; for ( Passage passage : passages ) { if ( passage . getStartOffset ( ) > pos && pos > 0 ) { sb . append ( ellipsis ) ; } pos = passage . getStartOffset ( ) ; for ( int i = 0 ; i < passage . getNumMatches ( ) ; i ++ ) { int start = passage . getMatchStarts ( ) [ i ] ; assert start >= pos && start < passage . getEndOffset ( ) ; append ( sb , content , pos , start ) ; int end = passage . getMatchEnds ( ) [ i ] ; assert end > start ; while ( i + 1 < passage . getNumMatches ( ) && passage . getMatchStarts ( ) [ i + 1 ] < end ) { end = passage . getMatchEnds ( ) [ ++ i ] ; } end = Math . min ( end , passage . getEndOffset ( ) ) ; sb . append ( preTag ) ; append ( sb , content , start , end ) ; sb . append ( postTag ) ; pos = end ; } append ( sb , content , pos , Math . max ( pos , passage . getEndOffset ( ) ) ) ; pos = passage . getEndOffset ( ) ; } return sb . toString ( ) ; }
public DrillSidewaysResult ( Facets facets , TopDocs hits ) { this . facets = facets ; this . hits = hits ; }
public ListTrafficPolicyInstancesByPolicyResult listTrafficPolicyInstancesByPolicy ( ListTrafficPolicyInstancesByPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeListTrafficPolicyInstancesByPolicy ( request ) ; }
public ComplexPhraseQuery ( String field , String phrasedQueryStringContents , int slopFactor , boolean inOrder ) { this . field = Objects . requireNonNull ( field ) ; this . phrasedQueryStringContents = Objects . requireNonNull ( phrasedQueryStringContents ) ; this . slopFactor = slopFactor ; this . inOrder = inOrder ; }
public String toString ( String field ) { StringBuilder buffer = new StringBuilder ( ) ; if ( ! term . field ( ) . equals ( field ) ) { buffer . append ( term . field ( ) ) ; buffer . append ( " : " ) ; } buffer . append ( getClass ( ) . getSimpleName ( ) ) ; buffer . append ( " ▁ { " ) ; buffer . append ( ' \ n ' ) ; buffer . append ( automaton . toString ( ) ) ; buffer . append ( " } " ) ; return buffer . toString ( ) ; }
public final String toFormulaString ( ) { return getName ( ) ; }
public AreaRecord clone ( ) { return copy ( ) ; }
public long ramBytesUsed ( ) { return TERMS_BASE_RAM_BYTES_USED + ( fst != null ? fst . ramBytesUsed ( ) : 0 ) + RamUsageEstimator . sizeOf ( scratch . bytes ( ) ) + RamUsageEstimator . sizeOf ( scratchUTF16. chars ( ) ) ; }
public DeleteConfigurationTemplateRequest ( String applicationName , String templateName ) { setApplicationName ( applicationName ) ; setTemplateName ( templateName ) ; }
public List < Token > getTokens ( int start , int stop , int ttype ) { HashSet < Integer > s = new HashSet < Integer > ( ttype ) ; s . add ( ttype ) ; return getTokens ( start , stop , s ) ; }
public DescribeIamInstanceProfileAssociationsResult describeIamInstanceProfileAssociations ( DescribeIamInstanceProfileAssociationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIamInstanceProfileAssociations ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval textArg ) { ValueEval veText1 ; try { veText1 = OperandResolver . getSingleValue ( textArg , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } String text = OperandResolver . coerceValueToString ( veText1 ) ; if ( text . length ( ) == 0 ) { return ErrorEval . VALUE_INVALID ; } int code = text . charAt ( 0 ) ; return new StringEval ( String . valueOf ( code ) ) ; }
public AttachVpnGatewayResult attachVpnGateway ( AttachVpnGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachVpnGateway ( request ) ; }
public int compareTo ( FloatBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; float thisFloat , otherFloat ; while ( compareRemaining > 0 ) { thisFloat = get ( thisPos ) ; otherFloat = otherBuffer . get ( otherPos ) ; if ( ( thisFloat != otherFloat ) && ( ( thisFloat == thisFloat ) || ( otherFloat == otherFloat ) ) ) { return thisFloat < otherFloat ? - 1 : 1 ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; }
public Matcher useTransparentBounds ( boolean value ) { transparentBounds = value ; useTransparentBoundsImpl ( address , value ) ; return this ; }
public void remove ( ) { if ( lastEntryReturned == null ) throw new IllegalStateException ( ) ; if ( modCount != expectedModCount ) throw new ConcurrentModificationException ( ) ; Hashtable . this . remove ( lastEntryReturned . key ) ; lastEntryReturned = null ; expectedModCount = modCount ; }
public String toFormulaString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; if ( externalWorkbookNumber >= 0 ) { sb . append ( ' [ ' ) ; sb . append ( externalWorkbookNumber ) ; sb . append ( ' ] ' ) ; } if ( sheetName != null ) { SheetNameFormatter . appendFormat ( sb , sheetName ) ; } sb . append ( ' ! ' ) ; sb . append ( FormulaError . REF . getString ( ) ) ; return sb . toString ( ) ; }
public String toString ( ) { return slice . toString ( ) + " : " + postingsEnum ; }
public CreateVpnConnectionRouteResult createVpnConnectionRoute ( CreateVpnConnectionRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVpnConnectionRoute ( request ) ; }
public boolean hasNext ( ) { return next != null ; }
public DeleteDBSecurityGroupRequest ( String dBSecurityGroupName ) { setDBSecurityGroupName ( dBSecurityGroupName ) ; }
public int compare ( Property o1 , Property o2 ) { String VBA_PROJECT = " □ VBA □ PROJECT " ; String name1 = o1. getName ( ) ; String name2 = o2. getName ( ) ; int result = name1. length ( ) - name2. length ( ) ; if ( result == 0 ) { if ( name1. compareTo ( VBA_PROJECT ) == 0 ) result = 1 ; else if ( name2. compareTo ( VBA_PROJECT ) == 0 ) result = - 1 ; else { if ( name1. startsWith ( " □ □ " ) && name2. startsWith ( " □ □ " ) ) { result = name1. compareToIgnoreCase ( name2 ) ; } else if ( name1. startsWith ( " □ □ " ) ) { result = 1 ; } else if ( name2. startsWith ( " □ □ " ) ) { result = - 1 ; } elseresult = name1. compareToIgnoreCase ( name2 ) ; } } return result ; }
public DoubleBuffer get ( double [ ] dst , int dstOffset , int doubleCount ) { Arrays . checkOffsetAndCount ( dst . length , dstOffset , doubleCount ) ; if ( doubleCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } for ( int i = dstOffset ; i < dstOffset + doubleCount ; ++ i ) { dst [ i ] = get ( ) ; } return this ; }
public CharsRef add ( CharsRef prefix , CharsRef output ) { assert prefix != null ; assert output != null ; if ( prefix == NO_OUTPUT ) { return output ; } else if ( output == NO_OUTPUT ) { return prefix ; } else { assert prefix . length > 0 ; assert output . length > 0 ; CharsRef result = new CharsRef ( prefix . length + output . length ) ; System . arraycopy ( prefix . chars , prefix . offset , result . chars , 0 , prefix . length ) ; System . arraycopy ( output . chars , output . offset , result . chars , prefix . length , output . length ) ; result . length = prefix . length + output . length ; return result ; } }
public UpdateProfileResult updateProfile ( UpdateProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateProfile ( request ) ; }
public LikeThisQueryBuilder ( Analyzer analyzer , String [ ] defaultFieldNames ) { this . analyzer = analyzer ; this . defaultFieldNames = defaultFieldNames ; }
public StringBuffer insert ( int index , long l ) { return insert ( index , Long . toString ( l ) ) ; }
public Field ( String name , BytesRef bytes , IndexableFieldType type ) { if ( name == null ) { throw new IllegalArgumentException ( " name ▁ must ▁ not ▁ be ▁ null " ) ; } if ( bytes == null ) { throw new IllegalArgumentException ( " bytes ▁ must ▁ not ▁ be ▁ null " ) ; } if ( type == null ) { throw new IllegalArgumentException ( " type ▁ must ▁ not ▁ be ▁ null " ) ; } this . name = name ; this . fieldsData = bytes ; this . type = type ; }
public void clear ( ) { mSize = 0 ; }
public SrndQuery parse2 ( String query ) throws ParseException { ReInit ( new FastCharStream ( new StringReader ( query ) ) ) ; try { return TopSrndQuery ( ) ; } catch ( TokenMgrError tme ) { throw new ParseException ( tme . getMessage ( ) ) ; } }
@ Override public int size ( ) { return ( int ) Math . min ( this . size , Integer . MAX_VALUE ) ; }
public DescribeConfigurationResult describeConfiguration ( DescribeConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeConfiguration ( request ) ; }
public String getCharErrorDisplay ( int c ) { String s = getErrorDisplay ( c ) ; return " ' " + s + " ' " ; }
public DescribeHumanTaskUiResult describeHumanTaskUi ( DescribeHumanTaskUiRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeHumanTaskUi ( request ) ; }
public void run ( ) { try { int n = task . runAndMaybeStats ( letChildReport ) ; if ( anyExhaustibleTasks ) { updateExhausted ( task ) ; } count += n ; } catch ( NoMoreDataException e ) { exhausted = true ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
public DescribeImagePermissionsResult describeImagePermissions ( DescribeImagePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeImagePermissions ( request ) ; }
public SrndQuery clone ( ) { try { return ( SrndQuery ) super . clone ( ) ; } catch ( CloneNotSupportedException cns ) { throw new Error ( cns ) ; } }
public void recycleByteBlocks ( byte [ ] [ ] blocks , int start , int end ) { final int numBlocks = Math . min ( maxBufferedBlocks - freeBlocks , end - start ) ; final int size = freeBlocks + numBlocks ; if ( size >= freeByteBlocks . length ) { final byte [ ] [ ] newBlocks = new byte [ ArrayUtil . oversize ( size , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ] [ ] ; System . arraycopy ( freeByteBlocks , 0 , newBlocks , 0 , freeBlocks ) ; freeByteBlocks = newBlocks ; } final int stop = start + numBlocks ; for ( int i = start ; i < stop ; i ++ ) { freeByteBlocks [ freeBlocks ++ ] = blocks [ i ] ; blocks [ i ] = null ; } for ( int i = stop ; i < end ; i ++ ) { blocks [ i ] = null ; } bytesUsed . addAndGet ( - ( end - stop ) * blockSize ) ; assert bytesUsed . get ( ) >= 0 ; }
public GeohashPrefixTree ( SpatialContext ctx , int maxLevels ) { super ( ctx , maxLevels ) ; Rectangle bounds = ctx . getWorldBounds ( ) ; if ( bounds . getMinX ( ) != - 180 ) throw new IllegalArgumentException ( " Geohash ▁ only ▁ supports ▁ lat - lon ▁ world ▁ bounds . ▁ Got ▁ " + bounds ) ; int MAXP = getMaxLevelsPossible ( ) ; if ( maxLevels <= 0 || maxLevels > MAXP ) throw new IllegalArgumentException ( " maxLevels ▁ must ▁ be ▁ [ 1 - " + MAXP + " ] ▁ but ▁ got ▁ " + maxLevels ) ; }
public void removeName ( int namenum ) { _definedNames . remove ( namenum ) ; }
public CancelSpotFleetRequestsResult cancelSpotFleetRequests ( CancelSpotFleetRequestsRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelSpotFleetRequests ( request ) ; }
public GetIndustryInfoLineageListRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " GetIndustryInfoLineageList " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public static double [ ] grow ( double [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Double . BYTES ) ) ; } else return array ; }
public void setResult ( RefUpdate . Result status ) { result = status ; super . setResult ( status ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final int byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final int byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 2 ) | ( byte1 >>> 6 ) ; final int byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 63 ) << 4 ) | ( byte2 >>> 4 ) ; final int byte3 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte2 & 15 ) << 6 ) | ( byte3 >>> 2 ) ; final int byte4 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte3 & 3 ) << 8 ) | byte4 ; } }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 ) { try { ValueEval ve = OperandResolver . getSingleValue ( arg0 , srcRowIndex , srcColumnIndex ) ; final double result = OperandResolver . coerceValueToDouble ( ve ) ; if ( Double . isNaN ( result ) || Double . isInfinite ( result ) ) { throw new EvaluationException ( ErrorEval . NUM_ERROR ) ; } ve = OperandResolver . getSingleValue ( arg2 , srcRowIndex , srcColumnIndex ) ; int order_value = OperandResolver . coerceValueToInt ( ve ) ; final boolean order ; if ( order_value == 0 ) { order = true ; } else if ( order_value == 1 ) { order = false ; } else { throw new EvaluationException ( ErrorEval . NUM_ERROR ) ; } if ( arg1 instanceof RefListEval ) { return eval ( result , ( ( RefListEval ) arg1 ) , order ) ; } final AreaEval aeRange = convertRangeArg ( arg1 ) ; return eval ( result , aeRange , order ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public DeleteEventBusResult deleteEventBus ( DeleteEventBusRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEventBus ( request ) ; }
public static ByteBuffer wrap ( byte [ ] array , int start , int byteCount ) { Arrays . checkOffsetAndCount ( array . length , start , byteCount ) ; ByteBuffer buf = new ReadWriteHeapByteBuffer ( array ) ; buf . position = start ; buf . limit = start + byteCount ; return buf ; }
public String apiVersion ( ) { return this . apiVersion ; }
public SearchResult search ( SearchRequest request ) { request = beforeClientExecution ( request ) ; return executeSearch ( request ) ; }
public PushCommand setRemote ( String remote ) { checkCallable ( ) ; this . remote = remote ; return this ; }
public AcceptReservedInstancesExchangeQuoteResult acceptReservedInstancesExchangeQuote ( AcceptReservedInstancesExchangeQuoteRequest request ) { request = beforeClientExecution ( request ) ; return executeAcceptReservedInstancesExchangeQuote ( request ) ; }
public GetAuthorizationTokenResult getAuthorizationToken ( GetAuthorizationTokenRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAuthorizationToken ( request ) ; }
public static InitCommand init ( ) { return new InitCommand ( ) ; }
public static RevFilter create ( Collection < RevFilter > list ) { if ( list . size ( ) < 2 ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastTwoFiltersNeeded ) ; final RevFilter [ ] subfilters = new RevFilter [ list . size ( ) ] ; list . toArray ( subfilters ) ; if ( subfilters . length == 2 ) return create ( subfilters [ 0 ] , subfilters [ 1 ] ) ; return new List ( subfilters ) ; }
public static PredictionContext mergeRoot ( SingletonPredictionContext a , SingletonPredictionContext b , boolean rootIsWildcard ) { if ( rootIsWildcard ) { if ( a == EMPTY ) return EMPTY ; if ( b == EMPTY ) return EMPTY ; } else { if ( a == EMPTY && b == EMPTY ) return EMPTY ; if ( a == EMPTY ) { int [ ] payloads = { b . returnState , EMPTY_RETURN_STATE } ; PredictionContext [ ] parents = { b . parent , null } ; PredictionContext joined = new ArrayPredictionContext ( parents , payloads ) ; return joined ; } if ( b == EMPTY ) { int [ ] payloads = { a . returnState , EMPTY_RETURN_STATE } ; PredictionContext [ ] parents = { a . parent , null } ; PredictionContext joined = new ArrayPredictionContext ( parents , payloads ) ; return joined ; } } return null ; }
public ListTerminologiesResult listTerminologies ( ListTerminologiesRequest request ) { request = beforeClientExecution ( request ) ; return executeListTerminologies ( request ) ; }
public ModifyInstanceGroupsRequest ( java . util . List < InstanceGroupModifyConfig > instanceGroups ) { setInstanceGroups ( instanceGroups ) ; }
public String toString ( ) { return " AnyObjectId [ " + name ( ) + " ] " ; }
public long ramBytesUsed ( ) { long ramBytesUsed = postingsReader . ramBytesUsed ( ) ; for ( TermsReader r : fields . values ( ) ) { ramBytesUsed += r . ramBytesUsed ( ) ; } return ramBytesUsed ; }
public static final ObjectId fromRaw ( int [ ] is , int p ) { return new ObjectId ( is [ p ] , is [ p + 1 ] , is [ p + 2 ] , is [ p + 3 ] , is [ p + 4 ] ) ; }
public RemoveTagsFromStreamResult removeTagsFromStream ( RemoveTagsFromStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveTagsFromStream ( request ) ; }
public void writeChar ( int value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeChar ( value ) ; }
public void setParams ( String params ) { super . setParams ( params ) ; if ( params != null ) { commitUserData = params ; } }
public OptionGroup modifyOptionGroup ( ModifyOptionGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyOptionGroup ( request ) ; }
public CreateCommentResult createComment ( CreateCommentRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateComment ( request ) ; }
public void setParams ( String params ) { super . setParams ( params ) ; userData = params ; }
public SearchAvailablePhoneNumbersResult searchAvailablePhoneNumbers ( SearchAvailablePhoneNumbersRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchAvailablePhoneNumbers ( request ) ; }
public SpanPositionCheckQuery ( SpanQuery match ) { this . match = Objects . requireNonNull ( match ) ; }
public boolean removeChildRecord ( EscherRecord toBeRemoved ) { return _childRecords . remove ( toBeRemoved ) ; }
public BytesRef clone ( ) { return new BytesRef ( bytes , offset , length ) ; }
public ByteBuffer putLong ( long value ) { throw new ReadOnlyBufferException ( ) ; }
@ Override public boolean add ( E object ) { synchronized ( CopyOnWriteArrayList . this ) { add ( slice . to - slice . from , object ) ; return true ; } }
public RevTree lookupTree ( AnyObjectId id ) { RevTree c = ( RevTree ) objects . get ( id ) ; if ( c == null ) { c = new RevTree ( id ) ; objects . add ( c ) ; } return c ; }
public boolean equals ( Object other ) { return sameClassAs ( other ) && func . equals ( ( ( FunctionQuery ) other ) . func ) ; }
public boolean changeExternalReference ( String oldUrl , String newUrl ) { for ( ExternalBookBlock ex : _externalBookBlocks ) { SupBookRecord externalRecord = ex . getExternalBookRecord ( ) ; if ( externalRecord . isExternalReferences ( ) && externalRecord . getURL ( ) . equals ( oldUrl ) ) { externalRecord . setURL ( newUrl ) ; return true ; } } return false ; }
public void removeLastPrinted ( ) { remove1stProperty ( PropertyIDMap . PID_LASTPRINTED ) ; }
public MergeCommand merge ( ) { return new MergeCommand ( repo ) ; }
public String toString ( ) { final Type t = getType ( ) ; return t + " ( " + beginA + " - " + endA + " , " + beginB + " - " + endB + " ) " ; }
public void serialize ( LittleEndianOutput out ) { int nItems = _list . size ( ) ; out . writeShort ( nItems ) ; for ( int k = 0 ; k < nItems ; k ++ ) { CellRangeAddress region = _list . get ( k ) ; region . serialize ( out ) ; } }
public void remove ( ) { throw new UnsupportedOperationException ( " Remove ▁ not ▁ supported " ) ; }
public TagCommand setSigned ( boolean signed ) { this . signed = signed ; return this ; }
public DescribeReservedInstancesListingsResult describeReservedInstancesListings ( DescribeReservedInstancesListingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReservedInstancesListings ( request ) ; }
public String getName ( ) { return getRef ( ) . getName ( ) ; }
public boolean isAllSet ( final int holder ) { return ( holder & _mask ) == _mask ; }
public static int getEncodedSize ( String value ) { int result = 2 + 1 ; result += value . length ( ) * ( StringUtil . hasMultibyte ( value ) ? 2 : 1 ) ; return result ; }
public List < CharsRef > stem ( char word [ ] , int length ) { if ( dictionary . needsInputCleaning ) { scratchSegment . setLength ( 0 ) ; scratchSegment . append ( word , 0 , length ) ; CharSequence cleaned = dictionary . cleanInput ( scratchSegment , segment ) ; scratchBuffer = ArrayUtil . grow ( scratchBuffer , cleaned . length ( ) ) ; length = segment . length ( ) ; segment . getChars ( 0 , length , scratchBuffer , 0 ) ; word = scratchBuffer ; } int caseType = caseOf ( word , length ) ; if ( caseType == UPPER_CASE ) { caseFoldTitle ( word , length ) ; caseFoldLower ( titleBuffer , length ) ; List < CharsRef > list = doStem ( word , length , false ) ; list . addAll ( doStem ( titleBuffer , length , true ) ) ; list . addAll ( doStem ( lowerBuffer , length , true ) ) ; return list ; } else if ( caseType == TITLE_CASE ) { caseFoldLower ( word , length ) ; List < CharsRef > list = doStem ( word , length , false ) ; list . addAll ( doStem ( lowerBuffer , length , true ) ) ; return list ; } else { return doStem ( word , length , false ) ; } }
public HSSFConditionalFormattingRule createConditionalFormattingRule ( String formula ) { CFRuleRecord rr = CFRuleRecord . create ( _sheet , formula ) ; return new HSSFConditionalFormattingRule ( _sheet , rr ) ; }
public Record create ( RecordInputStream in ) { Object [ ] args = { in , } ; try { return ( org . apache . poi . hssf . record . Record ) _m . invoke ( null , args ) ; } catch ( IllegalArgumentException | IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new org . apache . poi . util . RecordFormatException ( " Unable ▁ to ▁ construct ▁ record ▁ instance " , e . getTargetException ( ) ) ; } }
public int set ( int index , long [ ] arr , int off , int len ) { assert len > 0 : " len ▁ must ▁ be ▁ > ▁ 0 ▁ ( got ▁ " + len + " ) " ; assert index >= 0 && index < size ( ) ; len = Math . min ( len , size ( ) - index ) ; assert off + len <= arr . length ; for ( int i = index , o = off , end = index + len ; i < end ; ++ i , ++ o ) { set ( i , arr [ o ] ) ; } return len ; }
public synchronized long ramBytesUsed ( ) { long bytes = 0 ; for ( CachedOrds ords : ordsCache . values ( ) ) { bytes += ords . ramBytesUsed ( ) ; } return bytes ; }
public void writeDouble ( double v ) { writeLong ( Double . doubleToLongBits ( v ) ) ; }
public String toString ( ) { return " DocumentsWriterFlushControl ▁ [ activeBytes = " + activeBytes + " , ▁ flushBytes = " + flushBytes + " ] " ; }
public ListSecurityConfigurationsResult listSecurityConfigurations ( ListSecurityConfigurationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListSecurityConfigurations ( request ) ; }
public ListQualificationRequestsResult listQualificationRequests ( ListQualificationRequestsRequest request ) { request = beforeClientExecution ( request ) ; return executeListQualificationRequests ( request ) ; }
public void println ( char [ ] chars ) { println ( new String ( chars , 0 , chars . length ) ) ; }
public ReleaseAddressResult releaseAddress ( ReleaseAddressRequest request ) { request = beforeClientExecution ( request ) ; return executeReleaseAddress ( request ) ; }
public static boolean [ ] copyOfRange ( boolean [ ] original , int start , int end ) { if ( start > end ) { throw new IllegalArgumentException ( ) ; } int originalLength = original . length ; if ( start < 0 || start > originalLength ) { throw new ArrayIndexOutOfBoundsException ( ) ; } int resultLength = end - start ; int copyLength = Math . min ( resultLength , originalLength - start ) ; boolean [ ] result = new boolean [ resultLength ] ; System . arraycopy ( original , start , result , 0 , copyLength ) ; return result ; }
public void fillOval ( int x , int y , int width , int height ) { HSSFSimpleShape shape = escherGroup . createShape ( new HSSFChildAnchor ( x , y , x + width , y + height ) ) ; shape . setShapeType ( HSSFSimpleShape . OBJECT_TYPE_OVAL ) ; shape . setLineStyle ( HSSFShape . LINESTYLE_NONE ) ; shape . setFillColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setNoFill ( false ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 ) { try { String needle = TextFunction . evaluateStringArg ( arg0 , srcRowIndex , srcColumnIndex ) ; String haystack = TextFunction . evaluateStringArg ( arg1 , srcRowIndex , srcColumnIndex ) ; int startpos = TextFunction . evaluateIntArg ( arg2 , srcRowIndex , srcColumnIndex ) - 1 ; if ( startpos < 0 ) { return ErrorEval . VALUE_INVALID ; } return eval ( haystack , needle , startpos ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public CreateInvalidationRequest ( String distributionId , InvalidationBatch invalidationBatch ) { setDistributionId ( distributionId ) ; setInvalidationBatch ( invalidationBatch ) ; }
public CreateUsageReportSubscriptionResult createUsageReportSubscription ( CreateUsageReportSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateUsageReportSubscription ( request ) ; }
public static String fromString ( String value ) { return value ; }
public GetDetectorsResult getDetectors ( GetDetectorsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDetectors ( request ) ; }
public static String fromDouble ( Double d ) { return Double . toString ( d ) ; }
public void writeProtectWorkbook ( String password , String username ) { FileSharingRecord frec = getFileSharing ( ) ; WriteAccessRecord waccess = getWriteAccess ( ) ; getWriteProtect ( ) ; frec . setReadOnly ( ( short ) 1 ) ; frec . setPassword ( ( short ) CryptoFunctions . createXorVerifier1 ( password ) ) ; frec . setUsername ( username ) ; waccess . setUsername ( username ) ; }
public Process exec ( String command , int timeout ) throws TransportException { String ssh = SystemReader . getInstance ( ) . getenv ( " GIT □ SSH " ) ; boolean putty = ssh . toLowerCase ( Locale . ROOT ) . contains ( " plink " ) ; List < String > args = new ArrayList <> ( ) ; args . add ( ssh ) ; if ( putty && ! ssh . toLowerCase ( Locale . ROOT ) . contains ( " tortoiseplink " ) ) args . add ( " - batch " ) ; if ( 0 < getURI ( ) . getPort ( ) ) { args . add ( putty ? " - P " : " - p " ) ; args . add ( String . valueOf ( getURI ( ) . getPort ( ) ) ) ; } if ( getURI ( ) . getUser ( ) != null ) args . add ( getURI ( ) . getUser ( ) + " @ " + getURI ( ) . getHost ( ) ) ; elseargs . add ( getURI ( ) . getHost ( ) ) ; args . add ( command ) ; ProcessBuilder pb = createProcess ( args ) ; try { return pb . start ( ) ; } catch ( IOException err ) { throw new TransportException ( err . getMessage ( ) , err ) ; } }
public void serialize ( LittleEndianOutput out ) { out . write ( recordData ) ; }
public UpdateFleetCapacityResult updateFleetCapacity ( UpdateFleetCapacityRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFleetCapacity ( request ) ; }
public CreateDirectConnectGatewayAssociationResult createDirectConnectGatewayAssociation ( CreateDirectConnectGatewayAssociationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDirectConnectGatewayAssociation ( request ) ; }
public TokenStream create ( TokenStream input ) { if ( words == null ) { return input ; } else { final TokenStream filter = new KeepWordFilter ( input , words ) ; return filter ; } }
public final int getEndA ( ) { return endA ; }
public String getStrictHostKeyChecking ( ) { return strictHostKeyChecking ; }
public Lift ( boolean changeSkip ) { this . changeSkip = changeSkip ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_precision ) ; }
public GetAuthorizerResult getAuthorizer ( GetAuthorizerRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAuthorizer ( request ) ; }
public StringCharacterIterator ( String value , int start , int end , int location ) { string = value ; if ( start < 0 || end > string . length ( ) || start > end || location < start || location > end ) { throw new IllegalArgumentException ( ) ; } this . start = start ; this . end = end ; offset = location ; }
public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( " ObjectToPack [ " ) ; buf . append ( Constants . typeString ( getType ( ) ) ) ; buf . append ( " ▁ " ) ; buf . append ( name ( ) ) ; if ( wantWrite ( ) ) buf . append ( " ▁ wantWrite " ) ; if ( isReuseAsIs ( ) ) buf . append ( " ▁ reuseAsIs " ) ; if ( isDoNotDelta ( ) ) buf . append ( " ▁ doNotDelta " ) ; if ( isEdge ( ) ) buf . append ( " ▁ edge " ) ; if ( getDeltaDepth ( ) > 0 ) buf . append ( " ▁ depth = " ) . append ( getDeltaDepth ( ) ) ; if ( isDeltaRepresentation ( ) ) { if ( getDeltaBase ( ) != null ) buf . append ( " ▁ base = inpack : " ) . append ( getDeltaBase ( ) . name ( ) ) ; elsebuf . append ( " ▁ base = edge : " ) . append ( getDeltaBaseId ( ) . name ( ) ) ; } if ( isWritten ( ) ) buf . append ( " ▁ offset = " ) . append ( getOffset ( ) ) ; buf . append ( " ] " ) ; return buf . toString ( ) ; }
public String toString ( ) { return " 1 " ; }
public final void readFully ( byte [ ] dst , int offset , int byteCount ) throws IOException { Streams . readFully ( in , dst , offset , byteCount ) ; }
public GetMailboxDetailsResult getMailboxDetails ( GetMailboxDetailsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMailboxDetails ( request ) ; }
public CharBuffer append ( CharSequence csq ) { if ( csq != null ) { return put ( csq . toString ( ) ) ; } return put ( " null " ) ; }
public RegisterFaceRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " RegisterFace " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public static void checkValue ( double result ) throws EvaluationException { if ( Double . isNaN ( result ) || Double . isInfinite ( result ) ) { throw new EvaluationException ( ErrorEval . NUM_ERROR ) ; } }
public PutInvitationConfigurationResult putInvitationConfiguration ( PutInvitationConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executePutInvitationConfiguration ( request ) ; }
public QueryNode process ( QueryNode queryTree ) throws QueryNodeException { Operator op = getQueryConfigHandler ( ) . get ( ConfigurationKeys . DEFAULT_OPERATOR ) ; if ( op == null ) { throw new IllegalArgumentException ( " StandardQueryConfigHandler . ConfigurationKeys . DEFAULT □ OPERATOR ▁ should ▁ be ▁ set ▁ on ▁ the ▁ QueryConfigHandler " ) ; } this . usingAnd = StandardQueryConfigHandler . Operator . AND == op ; return super . process ( queryTree ) ; }
public void add ( BytesRef utf8 , int bucket ) throws IOException { if ( bucket < 0 || bucket >= buckets ) { throw new IllegalArgumentException ( " Bucket ▁ outside ▁ of ▁ the ▁ allowed ▁ range ▁ [ 0 , ▁ " + buckets + " ) : ▁ " + bucket ) ; } scratch . grow ( utf8. length + 10 ) ; scratch . clear ( ) ; scratch . append ( ( byte ) bucket ) ; scratch . append ( utf8 ) ; sorter . add ( scratch . get ( ) ) ; }
public DescribeWorkspaceBundlesResult describeWorkspaceBundles ( ) { return describeWorkspaceBundles ( new DescribeWorkspaceBundlesRequest ( ) ) ; }
public static String decode ( String s ) { return decode ( s , false , Charsets . UTF_8 ) ; }
public void setExpire ( Date expire ) { this . expire = expire ; expireAgeMillis = - 1 ; }
public int DecRef ( ) { assert count > 0 : Thread . currentThread ( ) . getName ( ) + " : ▁ RefCount ▁ is ▁ 0 ▁ pre - decrement ▁ for ▁ file ▁ \ " " + fileName + " \ " " ; return -- count ; }
public List < WeightedFragInfo > getWeightedFragInfoList ( List < WeightedFragInfo > src ) { return src ; }
public CreateInstancesFromSnapshotResult createInstancesFromSnapshot ( CreateInstancesFromSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateInstancesFromSnapshot ( request ) ; }
public Comparator <? super E > comparator ( ) { return backingMap . comparator ( ) ; }
public boolean isValueSecure ( ) { return valueSecure ; }
public static short [ ] grow ( short [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Short . BYTES ) ) ; } else return array ; }
public ObjectId idFor ( int type , byte [ ] data ) { return idFor ( type , data , 0 , data . length ) ; }
public CreateDomainNameResult createDomainName ( CreateDomainNameRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDomainName ( request ) ; }
public DeleteAddressBookResult deleteAddressBook ( DeleteAddressBookRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAddressBook ( request ) ; }
public void addToolPack ( UDFFinder toopack ) { AggregatingUDFFinder udfs = ( AggregatingUDFFinder ) _udfFinder ; udfs . add ( toopack ) ; }
public SearchUsersResult searchUsers ( SearchUsersRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchUsers ( request ) ; }
public String getAccessKeySecret ( ) { return privateKeySecret ; }
public void setValueAt ( int index , E value ) { if ( mGarbage ) { gc ( ) ; } mValues [ index ] = value ; }
public RefErrorPtg ( ) { field_1_reserved = 0 ; }
public boolean getFlagByBit ( int bitmask ) { return ( ( flags & bitmask ) != 0 ) ; }
public UpdateAccountSendingEnabledResult updateAccountSendingEnabled ( UpdateAccountSendingEnabledRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateAccountSendingEnabled ( request ) ; }
public AppCookieStickinessPolicy ( String policyName , String cookieName ) { setPolicyName ( policyName ) ; setCookieName ( cookieName ) ; }
public GetAccountBalanceResult getAccountBalance ( GetAccountBalanceRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAccountBalance ( request ) ; }
public DescribeConversionTasksResult describeConversionTasks ( DescribeConversionTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeConversionTasks ( request ) ; }
public DescribeImagesResult describeImages ( ) { return describeImages ( new DescribeImagesRequest ( ) ) ; }
public void close ( ) { _closed = true ; }
public ListSignalingChannelsResult listSignalingChannels ( ListSignalingChannelsRequest request ) { request = beforeClientExecution ( request ) ; return executeListSignalingChannels ( request ) ; }
public MergeFacesRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " MergeFaces " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DetectTextResult detectText ( DetectTextRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectText ( request ) ; }
public DoubleBuffer get ( double [ ] dst ) { return get ( dst , 0 , dst . length ) ; }
public long getCreationTime ( ) { return decodeTS ( P_CTIME ) ; }
public TreeFilter clone ( ) { return new Binary ( a . clone ( ) , b . clone ( ) ) ; }
public ByteBuffer putChar ( char value ) { int newPosition = position + SizeOf . CHAR ; if ( newPosition > limit ) { throw new BufferOverflowException ( ) ; } Memory . pokeShort ( backingArray , offset + position , ( short ) value , order ) ; position = newPosition ; return this ; }
public String toString ( ) { return String . format ( " Rect ▁ [ ( % d , % d ) - ( % d , % d ) : ▁ % dx % d ] " , x , y , x + w , y + h , w , h ) ; }
public static LongBuffer wrap ( long [ ] array ) { return wrap ( array , 0 , array . length ) ; }
public CharsRef clone ( ) { return new CharsRef ( chars , offset , length ) ; }
public SpanNearClauseFactory ( IndexReader reader , String fieldName , BasicQueryFactory qf ) { this . reader = reader ; this . fieldName = fieldName ; this . weightBySpanQuery = new HashMap <> ( ) ; this . qf = qf ; }
public BeginRecord clone ( ) { return copy ( ) ; }
public int start ( ) { return start ( 0 ) ; }
public DescribeGameSessionQueuesResult describeGameSessionQueues ( DescribeGameSessionQueuesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeGameSessionQueues ( request ) ; }
public SubmitAttachmentStateChangesResult submitAttachmentStateChanges ( SubmitAttachmentStateChangesRequest request ) { request = beforeClientExecution ( request ) ; return executeSubmitAttachmentStateChanges ( request ) ; }
public UnicodeString getString ( int id ) { return field_3_strings . get ( id ) ; }
public BigInteger getSignificand ( ) { return _significand ; }
public void join ( AbstractEscherHolderRecord record ) { rawDataContainer . concatenate ( record . getRawData ( ) ) ; }
public static byte [ ] grow ( byte [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Byte . BYTES ) ) ; } else return array ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; FlushInfo other = ( FlushInfo ) obj ; if ( estimatedSegmentSize != other . estimatedSegmentSize ) return false ; if ( numDocs != other . numDocs ) return false ; return true ; }
public void copyRawTo ( int [ ] b , int o ) { b [ o ] = w1 ; b [ o + 1 ] = w2 ; b [ o + 2 ] = w3 ; b [ o + 3 ] = w4 ; b [ o + 4 ] = w5 ; }
public ReadPipelineResult readPipeline ( ReadPipelineRequest request ) { request = beforeClientExecution ( request ) ; return executeReadPipeline ( request ) ; }
public BoostQueryNode ( QueryNode query , float value ) { if ( query == null ) { throw new QueryNodeError ( new MessageImpl ( QueryParserMessages . NODE_ACTION_NOT_SUPPORTED , " query " , " null " ) ) ; } this . value = value ; setLeaf ( false ) ; allocate ( ) ; add ( query ) ; }
public void setFallbackAlgorithm ( DiffAlgorithm alg ) { fallback = alg ; }
public void add ( Transition t ) { find ( t . min ) . starts . add ( t ) ; find ( 1 + t . max ) . ends . add ( t ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " ▁ [ FEATURE ▁ FORMULA ▁ ERRORS ] \ n " ) ; buffer . append ( " ▁ ▁ checkCalculationErrors ▁ ▁ ▁ ▁ = ▁ " ) ; buffer . append ( " ▁ ▁ checkEmptyCellRef ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) ; buffer . append ( " ▁ ▁ checkNumbersAsText ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) ; buffer . append ( " ▁ ▁ checkInconsistentRanges ▁ ▁ ▁ = ▁ " ) ; buffer . append ( " ▁ ▁ checkInconsistentFormulas ▁ = ▁ " ) ; buffer . append ( " ▁ ▁ checkDateTimeFormats ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) ; buffer . append ( " ▁ ▁ checkUnprotectedFormulas ▁ ▁ = ▁ " ) ; buffer . append ( " ▁ ▁ performDataValidation ▁ ▁ ▁ ▁ ▁ = ▁ " ) ; buffer . append ( " ▁ [ / FEATURE ▁ FORMULA ▁ ERRORS ] \ n " ) ; return buffer . toString ( ) ; }
public void execute ( Lexer lexer ) { lexer . setType ( type ) ; }
public UpgradePublishedSchemaResult upgradePublishedSchema ( UpgradePublishedSchemaRequest request ) { request = beforeClientExecution ( request ) ; return executeUpgradePublishedSchema ( request ) ; }
public int readRecordSID ( ) { readPlain ( buffer , 0 , LittleEndianConsts . SHORT_SIZE ) ; int sid = LittleEndian . getUShort ( buffer , 0 ) ; shouldSkipEncryptionOnCurrentRecord = isNeverEncryptedRecord ( sid ) ; return sid ; }
public CreateImageBuilderStreamingURLResult createImageBuilderStreamingURL ( CreateImageBuilderStreamingURLRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateImageBuilderStreamingURL ( request ) ; }
public SheetIdentifier ( String bookName , NameIdentifier sheetIdentifier ) { _bookName = bookName ; _sheetIdentifier = sheetIdentifier ; }
public boolean equals ( Object o ) { return o instanceof PortugueseStemmer ; }
public PasswordRecord clone ( ) { return copy ( ) ; }
public DescribeTableRequest ( String tableName ) { setTableName ( tableName ) ; }
public ModifyCacheParameterGroupResult modifyCacheParameterGroup ( ModifyCacheParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyCacheParameterGroup ( request ) ; }
public E set ( int location , E object ) { ListIterator < E > it = listIterator ( location ) ; if ( ! it . hasNext ( ) ) { throw new IndexOutOfBoundsException ( ) ; } E result = it . next ( ) ; it . set ( object ) ; return result ; }
public String toFormulaString ( ) { return NumberToTextConverter . toText ( field_1_value ) ; }
public ListBootstrapActionsResult listBootstrapActions ( ListBootstrapActionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListBootstrapActions ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _wStyle ) ; out . writeShort ( _cLine ) ; out . writeShort ( _dxMin ) ; StringUtil . writeUnicodeString ( out , _str ) ; if ( _unused != null ) { out . writeByte ( _unused ) ; } }
public SynonymFilter ( TokenStream input , SynonymMap synonyms , boolean ignoreCase ) { super ( input ) ; this . synonyms = synonyms ; this . ignoreCase = ignoreCase ; this . fst = synonyms . fst ; if ( fst == null ) { throw new IllegalArgumentException ( " fst ▁ must ▁ be ▁ non - null " ) ; } this . fstReader = fst . getBytesReader ( ) ; rollBufferSize = 1 + synonyms . maxHorizontalContext ; futureInputs = new PendingInput [ rollBufferSize ] ; futureOutputs = new PendingOutputs [ rollBufferSize ] ; for ( int pos = 0 ; pos < rollBufferSize ; pos ++ ) { futureInputs [ pos ] = new PendingInput ( ) ; futureOutputs [ pos ] = new PendingOutputs ( ) ; } scratchArc = new FST . Arc <> ( ) ; }
public CreateApiResult createApi ( CreateApiRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateApi ( request ) ; }
public IndexOutput createOutput ( String name , IOContext context ) throws IOException { ensureOpen ( ) ; if ( context . context != Context . MERGE || context . mergeInfo . estimatedMergeBytes < minBytesDirect ) { return delegate . createOutput ( name , context ) ; } else { return new NativeUnixIndexOutput ( getDirectory ( ) . resolve ( name ) , name , mergeBufferSize ) ; } }
public void drawArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , " drawArc ▁ not ▁ supported " ) ; }
public UpdateUserSettingsResult updateUserSettings ( UpdateUserSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateUserSettings ( request ) ; }
public DeleteDiskSnapshotResult deleteDiskSnapshot ( DeleteDiskSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDiskSnapshot ( request ) ; }
public ColumnInfoRecord ( ) { setColumnWidth ( 2275 ) ; _options = 2 ; _xfIndex = 0x0f ; field_6_reserved = 2 ; }
public final long getLong ( int index ) { checkIndex ( index , SizeOf . LONG ) ; return Memory . peekLong ( backingArray , offset + index , order ) ; }
public DeleteKnownHostKeysResult deleteKnownHostKeys ( DeleteKnownHostKeysRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteKnownHostKeys ( request ) ; }
public DeleteSigningCertificateRequest ( String certificateId ) { setCertificateId ( certificateId ) ; }
public StopProcessingJobResult stopProcessingJob ( StopProcessingJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopProcessingJob ( request ) ; }
public TermsEnum getTermsEnum ( Terms terms ) throws IOException { switch ( type ) { case NONE : return TermsEnum . EMPTY ; case ALL : return terms . iterator ( ) ; case SINGLE : return new SingleTermsEnum ( terms . iterator ( ) , term ) ; case NORMAL : return terms . intersect ( this , null ) ; default : throw new RuntimeException ( " unhandled ▁ case " ) ; } }
public void grow ( ) { costs = ArrayUtil . grow ( costs , 1 + count ) ; lastRightID = ArrayUtil . grow ( lastRightID , 1 + count ) ; backPos = ArrayUtil . grow ( backPos , 1 + count ) ; backWordPos = ArrayUtil . grow ( backWordPos , 1 + count ) ; backIndex = ArrayUtil . grow ( backIndex , 1 + count ) ; backID = ArrayUtil . grow ( backID , 1 + count ) ; final Type [ ] newBackType = new Type [ backID . length ] ; System . arraycopy ( backType , 0 , newBackType , 0 , backType . length ) ; backType = newBackType ; }
public int get ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( index + " ▁ not ▁ accessible ▁ in ▁ a ▁ list ▁ of ▁ length ▁ " + _limit ) ; } return _array [ index ] ; }
public LongBuffer slice ( ) { return new ReadWriteLongArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public ListProblemsResult listProblems ( ListProblemsRequest request ) { request = beforeClientExecution ( request ) ; return executeListProblems ( request ) ; }
public static double pmt ( double r , double n , double p , double f , boolean t ) { double retval = 0 ; if ( r == 0 ) { retval = - 1 * ( f + p ) / n ; } else { double r1 = r + 1 ; retval = ( f + p * Math . pow ( r1 , n ) ) * r / ( ( t ? r1 : 1 ) * ( 1 - Math . pow ( r1 , n ) ) ) ; } return retval ; }
public PrintGridlinesRecord clone ( ) { return copy ( ) ; }
public HSSFCellStyle getColumnStyle ( int column ) { short styleIndex = _sheet . getXFIndexForColAt ( ( short ) column ) ; if ( styleIndex == 0xf ) { return null ; } ExtendedFormatRecord xf = _book . getExFormatAt ( styleIndex ) ; return new HSSFCellStyle ( styleIndex , xf , _book ) ; }
public Query makeLuceneQueryField ( String fieldName , BasicQueryFactory qf ) { Query q = makeLuceneQueryFieldNoBoost ( fieldName , qf ) ; if ( isWeighted ( ) ) { q = new BoostQuery ( q , getWeight ( ) ) ; } return q ; }
public double getPrecisionAt ( int n ) { if ( n < 1 || n > MAX_POINTS ) { throw new IllegalArgumentException ( " n = " + n + " ▁ - ▁ but ▁ it ▁ must ▁ be ▁ in ▁ [ 1 , " + MAX_POINTS + " ] ▁ range ! " ) ; } if ( n > numPoints ) { return ( numPoints * pAt [ ( int ) numPoints ] ) / n ; } return pAt [ n ] ; }
public DescribeEngineDefaultParametersRequest ( String dBParameterGroupFamily ) { setDBParameterGroupFamily ( dBParameterGroupFamily ) ; }
public DeleteClientCertificateResult deleteClientCertificate ( DeleteClientCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteClientCertificate ( request ) ; }
public int compareTo ( CharBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; char thisByte , otherByte ; while ( compareRemaining > 0 ) { thisByte = get ( thisPos ) ; otherByte = otherBuffer . get ( otherPos ) ; if ( thisByte != otherByte ) { return thisByte < otherByte ? - 1 : 1 ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; }
public byte readByte ( ) { return _in . readByte ( ) ; }
public SendBounceResult sendBounce ( SendBounceRequest request ) { request = beforeClientExecution ( request ) ; return executeSendBounce ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { double dn ; try { ValueEval ve1 = OperandResolver . getSingleValue ( arg1 , srcRowIndex , srcColumnIndex ) ; dn = OperandResolver . coerceValueToDouble ( ve1 ) ; } catch ( EvaluationException e1 ) { return ErrorEval . VALUE_INVALID ; } if ( dn < 0 || dn > 1 ) { return ErrorEval . NUM_ERROR ; } double result ; try { double [ ] ds = ValueCollector . collectValues ( arg0 ) ; int N = ds . length ; if ( N == 0 || N > 8191 ) { return ErrorEval . NUM_ERROR ; } double n = ( N - 1 ) * dn + 1 ; if ( n == 1d ) { result = StatsLib . kthSmallest ( ds , 1 ) ; } else if ( Double . compare ( n , N ) == 0 ) { result = StatsLib . kthLargest ( ds , 1 ) ; } else { int k = ( int ) n ; double d = n - k ; result = StatsLib . kthSmallest ( ds , k ) + d * ( StatsLib . kthSmallest ( ds , k + 1 ) - StatsLib . kthSmallest ( ds , k ) ) ; } NumericFunction . checkValue ( result ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public int getIndexOfFormattingRun ( int index ) { FormatRun r = _string . getFormatRun ( index ) ; return r . getCharacterPos ( ) ; }
public void getEntryObjectId ( MutableObjectId out ) { out . fromRaw ( idBuffer ( ) , idOffset ( ) ) ; }
public static byte [ ] grow ( byte [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Byte . BYTES ) ) ; } else return array ; }
public boolean get ( String name , boolean dflt ) { boolean vals [ ] = ( boolean [ ] ) valByRound . get ( name ) ; if ( vals != null ) { return vals [ roundNumber % vals . length ] ; } String sval = props . getProperty ( name , " " + dflt ) ; if ( sval . indexOf ( " : " ) < 0 ) { return Boolean . valueOf ( sval ) . booleanValue ( ) ; } int k = sval . indexOf ( " : " ) ; String colName = sval . substring ( 0 , k ) ; sval = sval . substring ( k + 1 ) ; colForValByRound . put ( name , colName ) ; vals = propToBooleanArray ( sval ) ; valByRound . put ( name , vals ) ; return vals [ roundNumber % vals . length ] ; }
public GroupingSearch setCaching ( int maxDocsToCache , boolean cacheScores ) { this . maxDocsToCache = maxDocsToCache ; this . maxCacheRAMMB = null ; this . cacheScores = cacheScores ; return this ; }
public boolean isValidTermOrPhrase ( final List < TermInfo > phraseCandidate ) { if ( ! terminal ) return false ; if ( phraseCandidate . size ( ) == 1 ) return true ; int pos = phraseCandidate . get ( 0 ) . getPosition ( ) ; for ( int i = 1 ; i < phraseCandidate . size ( ) ; i ++ ) { int nextPos = phraseCandidate . get ( i ) . getPosition ( ) ; if ( Math . abs ( nextPos - pos - 1 ) > slop ) return false ; pos = nextPos ; } return true ; }
public Run startWorkflowExecution ( StartWorkflowExecutionRequest request ) { request = beforeClientExecution ( request ) ; return executeStartWorkflowExecution ( request ) ; }
public char [ ] nextKey ( ) { goNext ( ) ; return keys [ lastPos ] ; }
public ContainsResult contains ( BytesRef value ) { int hash = hashFunction . hash ( value ) ; if ( hash < 0 ) { hash = hash * - 1 ; } return mayContainValue ( hash ) ; }
public GetMethodResponseResult getMethodResponse ( GetMethodResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMethodResponse ( request ) ; }
public void setValue ( boolean value ) { _value = value ? 1 : 0 ; _isError = false ; }
public synchronized E elementAt ( int location ) { if ( location < elementCount ) { return ( E ) elementData [ location ] ; } throw arrayIndexOutOfBoundsException ( location , elementCount ) ; }
public void set ( int index , long value ) { final int o = index >>> 3 ; final int b = index & 7 ; final int shift = b << 3 ; blocks [ o ] = ( blocks [ o ] & ~ ( 255L << shift ) ) | ( value << shift ) ; }
public IterationRecord clone ( ) { return copy ( ) ; }
public boolean requiresCommitBody ( ) { return a . requiresCommitBody ( ) ; }
public UpdateTrafficPolicyCommentResult updateTrafficPolicyComment ( UpdateTrafficPolicyCommentRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTrafficPolicyComment ( request ) ; }
public UpdatePrimaryEmailAddressResult updatePrimaryEmailAddress ( UpdatePrimaryEmailAddressRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdatePrimaryEmailAddress ( request ) ; }
public static Pattern compile ( String pattern ) { return new Pattern ( pattern , 0 ) ; }
public static int update ( int hash , int value ) { final int c1 = 0xCC9E2D51 ; final int c2 = 0x1B873593 ; final int r1 = 15 ; final int r2 = 13 ; final int m = 5 ; final int n = 0xE6546B64 ; int k = value ; k = k * c1 ; k = ( k << r1 ) | ( k >>> ( 32 - r1 ) ) ; k = k * c2 ; hash = hash ^ k ; hash = ( hash << r2 ) | ( hash >>> ( 32 - r2 ) ) ; hash = hash * m + n ; return hash ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getHorizontalHold ( ) ) ; out . writeShort ( getVerticalHold ( ) ) ; out . writeShort ( getWidth ( ) ) ; out . writeShort ( getHeight ( ) ) ; out . writeShort ( getOptions ( ) ) ; out . writeShort ( getActiveSheetIndex ( ) ) ; out . writeShort ( getFirstVisibleTab ( ) ) ; out . writeShort ( getNumSelectedTabs ( ) ) ; out . writeShort ( getTabWidthRatio ( ) ) ; }
public boolean lessThan ( ShardRef first , ShardRef second ) { assert first != second ; final FieldDoc firstFD = ( FieldDoc ) shardHits [ first . shardIndex ] [ first . hitIndex ] ; final FieldDoc secondFD = ( FieldDoc ) shardHits [ second . shardIndex ] [ second . hitIndex ] ; for ( int compIDX = 0 ; compIDX < comparators . length ; compIDX ++ ) { final FieldComparator comp = comparators [ compIDX ] ; final int cmp = reverseMul [ compIDX ] * comp . compareValues ( firstFD . fields [ compIDX ] , secondFD . fields [ compIDX ] ) ; if ( cmp != 0 ) { return cmp < 0 ; } } return tieBreakLessThan ( first , firstFD , second , secondFD , tieBreaker ) ; }
public static int UTF8toUTF16 ( BytesRef bytesRef , char [ ] chars ) { return UTF8toUTF16 ( bytesRef . bytes , bytesRef . offset , bytesRef . length , chars ) ; }
public Trie optimize ( Trie orig ) { List < CharSequence > cmds = orig . cmds ; List < Row > rows = new ArrayList <> ( ) ; List < Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; Arrays . fill ( remap , 1 ) ; for ( int j = orows . size ( ) - 1 ; j >= 0 ; j -- ) { if ( eat ( orows . get ( j ) , remap ) ) { remap [ j ] = 0 ; } } Arrays . fill ( remap , - 1 ) ; rows = removeGaps ( orig . root , orows , new ArrayList < Row > ( ) , remap ) ; return new Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
public DataValidationConstraint createCustomConstraint ( String formula ) { return DVConstraint . createCustomFormulaConstraint ( formula ) ; }
public ByteBuffer putInt ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; }
public DescribeLoadBalancerPolicyTypesResult describeLoadBalancerPolicyTypes ( ) { return describeLoadBalancerPolicyTypes ( new DescribeLoadBalancerPolicyTypesRequest ( ) ) ; }
public NIOFSIndexInput clone ( ) { NIOFSIndexInput clone = ( NIOFSIndexInput ) super . clone ( ) ; clone . isClone = true ; return clone ; }
public long getTotalSLLATNLookaheadOps ( ) { DecisionInfo [ ] decisions = atnSimulator . getDecisionInfo ( ) ; long k = 0 ; for ( int i = 0 ; i < decisions . length ; i ++ ) { k += decisions [ i ] . SLL_ATNTransitions ; } return k ; }
public UpdateEndpointResult updateEndpoint ( UpdateEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateEndpoint ( request ) ; }
public GetEmailChannelResult getEmailChannel ( GetEmailChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetEmailChannel ( request ) ; }
public ListPhoneNumberOrdersResult listPhoneNumberOrders ( ListPhoneNumberOrdersRequest request ) { request = beforeClientExecution ( request ) ; return executeListPhoneNumberOrders ( request ) ; }
public UpdateBuildResult updateBuild ( UpdateBuildRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateBuild ( request ) ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = 16 ; LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; LittleEndian . putInt ( data , offset + 8 , field_1_rectX1 ) ; LittleEndian . putInt ( data , offset + 12 , field_2_rectY1 ) ; LittleEndian . putInt ( data , offset + 16 , field_3_rectX2 ) ; LittleEndian . putInt ( data , offset + 20 , field_4_rectY2 ) ; listener . afterRecordSerialize ( offset + getRecordSize ( ) , getRecordId ( ) , offset + getRecordSize ( ) , this ) ; return 8 + 16 ; }
public CleanCommand setDryRun ( boolean dryRun ) { this . dryRun = dryRun ; return this ; }
public DescribeClusterVersionsResult describeClusterVersions ( DescribeClusterVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClusterVersions ( request ) ; }
public DescribeWorkspacesResult describeWorkspaces ( DescribeWorkspacesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWorkspaces ( request ) ; }
public void copyRawTo ( int [ ] b , int o ) { b [ o ] = w1 ; b [ o + 1 ] = w2 ; b [ o + 2 ] = w3 ; b [ o + 3 ] = w4 ; b [ o + 4 ] = w5 ; }
public SetStackPolicyResult setStackPolicy ( SetStackPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeSetStackPolicy ( request ) ; }
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; append ( s , oldRef , " CREATE " ) ; s . append ( ' ▁ ' ) ; append ( s , newRef , " DELETE " ) ; s . append ( ' ▁ ' ) . append ( getRefName ( ) ) ; s . append ( ' ▁ ' ) . append ( getResult ( ) ) ; if ( getMessage ( ) != null ) { s . append ( ' ▁ ' ) . append ( getMessage ( ) ) ; } return s . toString ( ) ; }
public short getXFAt ( int coffset ) { return field_3_rks [ coffset ] . xf ; }
public ByteBuffer put ( byte [ ] src , int srcOffset , int byteCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , byteCount ) ; if ( byteCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + byteCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public ReceiveMessageResult receiveMessage ( String queueUrl ) { return receiveMessage ( new ReceiveMessageRequest ( ) . withQueueUrl ( queueUrl ) ) ; }
public NativeUnixIndexInput ( NativeUnixIndexInput other ) throws IOException { super ( other . toString ( ) ) ; this . fis = null ; channel = other . channel ; this . bufferSize = other . bufferSize ; buffer = ByteBuffer . allocateDirect ( bufferSize ) ; filePos = - bufferSize ; bufferPos = bufferSize ; isOpen = true ; isClone = true ; seek ( other . getFilePointer ( ) ) ; }
public Merger newMerger ( Repository db , boolean inCore ) { return new OneSide ( db , treeIndex ) ; }
public void flush ( ) { synchronized ( lock ) { if ( out != null ) { try { out . flush ( ) ; } catch ( IOException e ) { setError ( ) ; } } else { setError ( ) ; } } }
public DisassociateIamInstanceProfileResult disassociateIamInstanceProfile ( DisassociateIamInstanceProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateIamInstanceProfile ( request ) ; }
public void beginTask ( String title , int totalWork ) { if ( ! isMainThread ( ) ) throw new IllegalStateException ( ) ; pm . beginTask ( title , totalWork ) ; }
public void run ( ) { try { count = task . runAndMaybeStats ( letChildReport ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
public TokenFilter create ( TokenStream input ) { return new EdgeNGramTokenFilter ( input , minGramSize , maxGramSize , preserveOriginal ) ; }
public String toString ( ) { return " RemoteRefUpdate [ remoteName = " + remoteName + " , ▁ " + status + " , ▁ " + ( expectedOldObjectId != null ? expectedOldObjectId . name ( ) : " ( null ) " ) + " ... " + ( newObjectId != null ? newObjectId . name ( ) : " ( null ) " ) + ( fastForward ? " , ▁ fastForward " : " " ) + " , ▁ srcRef = " + srcRef + ( forceUpdate ? " , ▁ forceUpdate " : " " ) + " , ▁ message = " + ( message != null ? " \ " " + message + " \ " " : " null " ) + " ] " ; }
public ListJournalS3ExportsResult listJournalS3Exports ( ListJournalS3ExportsRequest request ) { request = beforeClientExecution ( request ) ; return executeListJournalS3Exports ( request ) ; }
public boolean lookingAt ( ) { matchFound = lookingAtImpl ( address , input , matchOffsets ) ; if ( matchFound ) { findPos = matchOffsets [ 1 ] ; } return matchFound ; }
public DescribeIdentityUsageResult describeIdentityUsage ( DescribeIdentityUsageRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIdentityUsage ( request ) ; }
public void carry ( RevFlag flag ) { final int carry = flags & flag . mask ; if ( carry != 0 ) carryFlags ( this , carry ) ; }
public Count ( ) { _predicate = defaultPredicate ; }
public ShowNoteCommand notesShow ( ) { return new ShowNoteCommand ( repo ) ; }
public ResolveRoomResult resolveRoom ( ResolveRoomRequest request ) { request = beforeClientExecution ( request ) ; return executeResolveRoom ( request ) ; }
public ValueEval getArea3DEval ( Area3DPxg aptg ) { SheetRangeEvaluator sre = createExternSheetRefEvaluator ( aptg . getSheetName ( ) , aptg . getLastSheetName ( ) , aptg . getExternalWorkbookNumber ( ) ) ; return new LazyAreaEval ( aptg . getFirstRow ( ) , aptg . getFirstColumn ( ) , aptg . getLastRow ( ) , aptg . getLastColumn ( ) , sre ) ; }
public DoubleMetaphoneFilterFactory ( Map < String , String > args ) { super ( args ) ; inject = getBoolean ( args , INJECT , true ) ; maxCodeLength = getInt ( args , MAX_CODE_LENGTH , DEFAULT_MAX_CODE_LENGTH ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ PALETTE ] \ n " ) ; buffer . append ( " ▁ ▁ numcolors ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( _colors . size ( ) ) . append ( ' \ n ' ) ; for ( int i = 0 ; i < _colors . size ( ) ; i ++ ) { PColor c = _colors . get ( i ) ; buffer . append ( " * ▁ colornum ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( i ) . append ( ' \ n ' ) ; buffer . append ( c ) ; buffer . append ( " " ) ; } }
public DocOffsetSorter ( int maxDoc ) { super ( maxDoc / 64 ) ; this . tmpDocs = new int [ maxDoc / 64 ] ; this . tmpOffsets = new long [ maxDoc / 64 ] ; }
public EnableInsightRulesResult enableInsightRules ( EnableInsightRulesRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableInsightRules ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! ( obj instanceof AND ) ) return false ; AND other = ( AND ) obj ; return Arrays . equals ( this . opnds , other . opnds ) ; }
public static int getEncodedSize ( Ptg [ ] ptgs ) { int result = 0 ; for ( Ptg ptg : ptgs ) { result += ptg . getSize ( ) ; } return result ; }
public IterationRecord ( boolean iterateOn ) { _flags = iterationOn . setBoolean ( 0 , iterateOn ) ; }
public UnlinkIdentityResult unlinkIdentity ( UnlinkIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeUnlinkIdentity ( request ) ; }
public CreateThreatIntelSetResult createThreatIntelSet ( CreateThreatIntelSetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateThreatIntelSet ( request ) ; }
public TokenizedPhraseQueryNode ( ) { setLeaf ( false ) ; allocate ( ) ; }
public DataItemRecord ( RecordInputStream in ) { isxvdData = in . readUShort ( ) ; iiftab = in . readUShort ( ) ; df = in . readUShort ( ) ; isxvd = in . readUShort ( ) ; isxvi = in . readUShort ( ) ; ifmt = in . readUShort ( ) ; name = in . readString ( ) ; }
public DeleteDBParameterGroupResult deleteDBParameterGroup ( DeleteDBParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDBParameterGroup ( request ) ; }
public GetReservedNodeExchangeOfferingsResult getReservedNodeExchangeOfferings ( GetReservedNodeExchangeOfferingsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetReservedNodeExchangeOfferings ( request ) ; }
public static long nextHighestPowerOfTwo ( long v ) { v -- ; v |= v >> 1 ; v |= v >> 2 ; v |= v >> 4 ; v |= v >> 8 ; v |= v >> 16 ; v |= v >> 32 ; v ++ ; return v ; }
public RunInstancesResult runInstances ( RunInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeRunInstances ( request ) ; }
public ChangeMessageVisibilityBatchResult changeMessageVisibilityBatch ( String queueUrl , java . util . List < ChangeMessageVisibilityBatchRequestEntry > entries ) { return changeMessageVisibilityBatch ( new ChangeMessageVisibilityBatchRequest ( ) . withQueueUrl ( queueUrl ) . withEntries ( entries ) ) ; }
public DeleteRealtimeEndpointResult deleteRealtimeEndpoint ( DeleteRealtimeEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRealtimeEndpoint ( request ) ; }
public CreateDiskSnapshotResult createDiskSnapshot ( CreateDiskSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDiskSnapshot ( request ) ; }
public void mark ( int readLimit ) throws IOException { if ( readLimit < 0 ) { throw new IllegalArgumentException ( ) ; } synchronized ( lock ) { checkNotClosed ( ) ; markpos = pos ; } }
public TokenStream create ( TokenStream input ) { return new ICUNormalizer2Filter ( input , normalizer ) ; }
public ModifyImageAttributeResult modifyImageAttribute ( ModifyImageAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyImageAttribute ( request ) ; }
public DescribeClusterSubnetGroupsResult describeClusterSubnetGroups ( DescribeClusterSubnetGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClusterSubnetGroups ( request ) ; }
public StopQueryExecutionResult stopQueryExecution ( StopQueryExecutionRequest request ) { request = beforeClientExecution ( request ) ; return executeStopQueryExecution ( request ) ; }
public UpdateUserInfoRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " UpdateUserInfo " , " cr " ) ; setUriPattern ( " / users " ) ; setMethod ( MethodType . POST ) ; }
public DiscoverInputSchemaResult discoverInputSchema ( DiscoverInputSchemaRequest request ) { request = beforeClientExecution ( request ) ; return executeDiscoverInputSchema ( request ) ; }
public GetEnvironmentResult getEnvironment ( GetEnvironmentRequest request ) { request = beforeClientExecution ( request ) ; return executeGetEnvironment ( request ) ; }
public UpdateCondition ( String name , String value , Boolean exists ) { setName ( name ) ; setValue ( value ) ; setExists ( exists ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getCalcMode ( ) ) ; }
public AmazonS3EncryptionClient ( EncryptionMaterials encryptionMaterials ) { this ( new StaticEncryptionMaterialsProvider ( encryptionMaterials ) ) ; }
public void addRule ( ConditionalFormattingRule cfRule ) { addRule ( ( HSSFConditionalFormattingRule ) cfRule ) ; }
public Iterator < E > descendingIterator ( ) { return descendingSet ( ) . iterator ( ) ; }
public DescribeSubnetGroupsResult describeSubnetGroups ( DescribeSubnetGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSubnetGroups ( request ) ; }
public void append ( String name , RevBlob blob ) { append ( name , REGULAR_FILE , blob ) ; }
public NavigableMap < K , V > subMap ( K from , boolean fromInclusive , K to , boolean toInclusive ) { Bound fromBound = fromInclusive ? INCLUSIVE : EXCLUSIVE ; Bound toBound = toInclusive ? INCLUSIVE : EXCLUSIVE ; return subMap ( from , fromBound , to , toBound ) ; }
public E next ( ) { if ( expectedModCount == modCount ) { try { E result = get ( pos + 1 ) ; lastPosition = ++ pos ; return result ; } catch ( IndexOutOfBoundsException e ) { throw new NoSuchElementException ( ) ; } } throw new ConcurrentModificationException ( ) ; }
static public double ipmt ( double r , int per , int nper , double pv ) { return ipmt ( r , per , nper , pv , 0 ) ; }
public TokenStream create ( TokenStream input ) { if ( dictionary == null ) { return input ; } return new DictionaryCompoundWordTokenFilter ( input , dictionary , minWordSize , minSubwordSize , maxSubwordSize , onlyLongestMatch ) ; }
public String toString ( ) { StringBuilder r = new StringBuilder ( ) ; r . append ( " ( " ) ; fieldNamesToString ( r ) ; r . append ( q . toString ( ) ) ; r . append ( " ) " ) ; return r . toString ( ) ; }
public AssociateDeviceWithRoomResult associateDeviceWithRoom ( AssociateDeviceWithRoomRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateDeviceWithRoom ( request ) ; }
public DeleteRetentionPolicyRequest ( String logGroupName ) { setLogGroupName ( logGroupName ) ; }
public TypeTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; stopTypesFiles = require ( args , " types " ) ; useWhitelist = getBoolean ( args , " useWhitelist " , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public ServerCertificate ( ServerCertificateMetadata serverCertificateMetadata , String certificateBody ) { setServerCertificateMetadata ( serverCertificateMetadata ) ; setCertificateBody ( certificateBody ) ; }
public final void add ( RevCommit c , RevFlag queueControl ) { if ( ! c . has ( queueControl ) ) { c . add ( queueControl ) ; add ( c ) ; } }
public BlameCommand setFilePath ( String filePath ) { this . path = filePath ; return this ; }
public boolean isTraverseEmptyCells ( ) { return traverseEmptyCells ; }
public QueryCustomerByIdRequest ( ) { super ( " xspace " , " 2017 - 07 - 20 " , " QueryCustomerById " ) ; setUriPattern ( " / customer " ) ; setMethod ( MethodType . PUT ) ; }
public OpenNLPPOSFilterFactory ( Map < String , String > args ) { super ( args ) ; posTaggerModelFile = require ( args , POS_TAGGER_MODEL ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public GetLinkAttributesResult getLinkAttributes ( GetLinkAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLinkAttributes ( request ) ; }
public byte [ ] getByteBlock ( ) { bytesUsed . addAndGet ( blockSize ) ; return new byte [ blockSize ] ; }
public CanonicalTreeParser ( ) { reset ( EMPTY ) ; }
public OldLabelRecord ( RecordInputStream in ) { super ( in , in . getSid ( ) == biff2_sid ) ; if ( isBiff2 ( ) ) { field_4_string_len = ( short ) in . readUByte ( ) ; } else { field_4_string_len = in . readShort ( ) ; } field_5_bytes = IOUtils . safelyAllocate ( field_4_string_len , MAX_RECORD_LENGTH ) ; in . read ( field_5_bytes , 0 , field_4_string_len ) ; if ( in . remaining ( ) > 0 ) { logger . log ( POILogger . INFO , " LabelRecord ▁ data ▁ remains : ▁ " + in . remaining ( ) + " ▁ : ▁ " + HexDump . toHex ( in . readRemainder ( ) ) ) ; } }
public DBCellRecord clone ( ) { return copy ( ) ; }
public GetCampaignResult getCampaign ( GetCampaignRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCampaign ( request ) ; }
public boolean isEmpty ( ) { return backingMap . isEmpty ( ) ; }
public Object subtract ( Object object , Object inc ) { return outputs . subtract ( ( T ) object , ( T ) inc ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ COLINFO ] \ n " ) ; sb . append ( " ▁ ▁ colfirst ▁ = ▁ " ) . append ( getFirstColumn ( ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ collast ▁ ▁ = ▁ " ) . append ( getLastColumn ( ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ colwidth ▁ = ▁ " ) . append ( getColumnWidth ( ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ xfindex ▁ ▁ = ▁ " ) . append ( getXFIndex ( ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ options ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( _options ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ hidden ▁ ▁ ▁ = ▁ " ) . append ( getHidden ( ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ olevel ▁ ▁ ▁ = ▁ " ) . append ( getOutlineLevel ( ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ collapsed = ▁ " ) . append ( getCollapsed ( ) ) . append ( " \ n " ) ; sb . append ( " [ / COLINFO ] \ n " ) ; return sb . toString ( ) ; }
public EditList toEditList ( ) { final EditList r = new EditList ( ) ; for ( HunkHeader hunk : hunks ) r . addAll ( hunk . toEditList ( ) ) ; return r ; }
public void setParams ( String params ) { super . setParams ( params ) ; if ( params != null ) { String [ ] split = params . split ( " , " ) ; if ( split . length > 0 ) { commitUserData = split [ 0 ] ; } } }
public HSSFCell createCell ( int columnIndex , CellType type ) { short shortCellNum = ( short ) columnIndex ; if ( columnIndex > 0x7FFF ) { shortCellNum = ( short ) ( 0xffff - columnIndex ) ; } HSSFCell cell = new HSSFCell ( book , sheet , getRowNum ( ) , shortCellNum , type ) ; addCell ( cell ) ; sheet . getSheet ( ) . addValueRecord ( getRowNum ( ) , cell . getCellValueRecord ( ) ) ; return cell ; }
public PhraseQuery build ( ) { Term [ ] terms = this . terms . toArray ( new Term [ this . terms . size ( ) ] ) ; int [ ] positions = new int [ this . positions . size ( ) ] ; for ( int i = 0 ; i < positions . length ; ++ i ) { positions [ i ] = this . positions . get ( i ) ; } return new PhraseQuery ( slop , terms , positions ) ; }
public ModifyInstanceEventStartTimeResult modifyInstanceEventStartTime ( ModifyInstanceEventStartTimeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyInstanceEventStartTime ( request ) ; }
public boolean checkShowJsonItemName ( ) { return false ; }
public Analyzer create ( ) { return new Analyzer ( ) { private final Integer positionIncrementGap = AnalyzerFactory . this . positionIncrementGap ; private final Integer offsetGap = AnalyzerFactory . this . offsetGap ; } ; }
public static RevFilter create ( RevFilter [ ] list ) { if ( list . length == 2 ) return create ( list [ 0 ] , list [ 1 ] ) ; if ( list . length < 2 ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastTwoFiltersNeeded ) ; final RevFilter [ ] subfilters = new RevFilter [ list . length ] ; System . arraycopy ( list , 0 , subfilters , 0 , list . length ) ; return new List ( subfilters ) ; }
public DescribePrefixListsResult describePrefixLists ( DescribePrefixListsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribePrefixLists ( request ) ; }
public CharVector clone ( ) { CharVector cv = new CharVector ( array . clone ( ) , blockSize ) ; cv . n = this . n ; return cv ; }
public CreateDatasetImportJobResult createDatasetImportJob ( CreateDatasetImportJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDatasetImportJob ( request ) ; }
public GetRecommenderConfigurationsResult getRecommenderConfigurations ( GetRecommenderConfigurationsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRecommenderConfigurations ( request ) ; }
public void setOldPrefix ( String prefix ) { oldPrefix = prefix ; }
public DescribeAvailabilityZonesResult describeAvailabilityZones ( ) { return describeAvailabilityZones ( new DescribeAvailabilityZonesRequest ( ) ) ; }
public final boolean matches ( char c ) { return this . expectedCharacter == c ; }
public static void putCompressedUnicode ( String input , byte [ ] output , int offset ) { byte [ ] bytes = input . getBytes ( ISO_8859_1 ) ; System . arraycopy ( bytes , 0 , output , offset , bytes . length ) ; }
public void put ( int key , int value ) { int i = binarySearch ( mKeys , 0 , mSize , key ) ; if ( i >= 0 ) { mValues [ i ] = value ; } else { i = ~ i ; if ( mSize >= mKeys . length ) { int n = ArrayUtils . idealIntArraySize ( mSize + 1 ) ; int [ ] nkeys = new int [ n ] ; int [ ] nvalues = new int [ n ] ; System . arraycopy ( mKeys , 0 , nkeys , 0 , mKeys . length ) ; System . arraycopy ( mValues , 0 , nvalues , 0 , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } if ( mSize - i != 0 ) { System . arraycopy ( mKeys , i , mKeys , i + 1 , mSize - i ) ; System . arraycopy ( mValues , i , mValues , i + 1 , mSize - i ) ; } mKeys [ i ] = key ; mValues [ i ] = value ; mSize ++ ; } }
public void clearEscherRecords ( ) { escherRecords . clear ( ) ; }
public String getSchemeSpecificPart ( ) { return decode ( schemeSpecificPart ) ; }
public DeleteSkillAuthorizationResult deleteSkillAuthorization ( DeleteSkillAuthorizationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSkillAuthorization ( request ) ; }
public QuerySyncPicScheduleRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " QuerySyncPicSchedule " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public SheetRecordCollectingListener ( HSSFListener childListener ) { this . childListener = childListener ; }
public boolean equals ( Object o ) { return o instanceof RussianStemmer ; }
public void clear ( ) { ArrayList < HSSFShape > copy = new ArrayList <> ( _shapes ) ; for ( HSSFShape shape : copy ) { removeShape ( shape ) ; } }
public AddTagsToVaultResult addTagsToVault ( AddTagsToVaultRequest request ) { request = beforeClientExecution ( request ) ; return executeAddTagsToVault ( request ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + ' @ ' + Integer . toHexString ( hashCode ( ) ) ; }
public final boolean equals ( Object obj ) { if ( obj instanceof Charset ) { Charset that = ( Charset ) obj ; return this . canonicalName . equals ( that . canonicalName ) ; } return false ; }
public String toString ( ) { return source + " ▁ --> ▁ " + dest + " ▁ " + ( char ) min + " - " + ( char ) max ; }
public DeleteDirectoryConfigResult deleteDirectoryConfig ( DeleteDirectoryConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDirectoryConfig ( request ) ; }
public static DVConstraint createTimeConstraint ( int comparisonOperator , String expr1 , String expr2 ) { if ( expr1 == null ) { throw new IllegalArgumentException ( " expr1 ▁ must ▁ be ▁ supplied " ) ; } OperatorType . validateSecondArg ( comparisonOperator , expr1 ) ; String formula1 = getFormulaFromTextExpression ( expr1 ) ; Double value1 = formula1 == null ? convertTime ( expr1 ) : null ; String formula2 = getFormulaFromTextExpression ( expr2 ) ; Double value2 = formula2 == null ? convertTime ( expr2 ) : null ; return new DVConstraint ( ValidationType . TIME , comparisonOperator , formula1 , formula2 , value1 , value2 , null ) ; }
public String toString ( ) { return " . " ; }
public RestoreDBInstanceFromDBSnapshotRequest ( String dBInstanceIdentifier , String dBSnapshotIdentifier ) { setDBInstanceIdentifier ( dBInstanceIdentifier ) ; setDBSnapshotIdentifier ( dBSnapshotIdentifier ) ; }
public String getName ( ) { return seqName ; }
public void readFully ( byte [ ] buf ) { readFully ( buf , 0 , buf . length ) ; }
public boolean containsKey ( Object o ) { if ( o == null ) throw new NullPointerException ( ) ; return false ; }
public String toFormulaString ( ) { return FormulaError . REF . getString ( ) ; }
public History getWorkflowExecutionHistory ( GetWorkflowExecutionHistoryRequest request ) { request = beforeClientExecution ( request ) ; return executeGetWorkflowExecutionHistory ( request ) ; }
public DeleteFileSystemPolicyResult deleteFileSystemPolicy ( DeleteFileSystemPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFileSystemPolicy ( request ) ; }
public ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { switch ( args . length ) { case 1 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] ) ; case 0 : return new NumberEval ( srcColumnIndex + 1 ) ; } return ErrorEval . VALUE_INVALID ; }
public String getFormat ( short index ) { if ( _movedBuiltins ) { return _formats . get ( index ) ; } if ( index == - 1 ) { return null ; } String fmt = _formats . size ( ) > index ? _formats . get ( index ) : null ; if ( _builtinFormats . length > index && _builtinFormats [ index ] != null ) { if ( fmt != null ) { return fmt ; } else { return _builtinFormats [ index ] ; } } return fmt ; }
public boolean include ( RevWalk walker , RevCommit cmit ) throws StopWalkException , MissingObjectException , IncorrectObjectTypeException , IOException { count ++ ; if ( count > maxCount ) throw StopWalkException . INSTANCE ; return true ; }
public final Buffer mark ( ) { mark = position ; return this ; }
public ModifyClientPropertiesResult modifyClientProperties ( ModifyClientPropertiesRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyClientProperties ( request ) ; }
public void stopWalk ( ) { if ( parent != null ) parent . stopWalk ( ) ; }
public ObjectId toObjectId ( ) { return isComplete ( ) ? new ObjectId ( w1 , w2 , w3 , w4 , w5 ) : null ; }
public UpdateIntegrationResult updateIntegration ( UpdateIntegrationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateIntegration ( request ) ; }
public PutDetectorResult putDetector ( PutDetectorRequest request ) { request = beforeClientExecution ( request ) ; return executePutDetector ( request ) ; }
public long getLong ( String section , String name , long defaultValue ) { return typedGetter . getLong ( this , section , null , name , defaultValue ) ; }
public void resetBackgroundImage ( ) { EscherSimpleProperty property = getOptRecord ( ) . lookup ( EscherPropertyTypes . FILL__PATTERNTEXTURE ) ; if ( null != property ) { EscherBSERecord bse = getPatriarch ( ) . getSheet ( ) . getWorkbook ( ) . getWorkbook ( ) . getBSERecord ( property . getPropertyValue ( ) ) ; bse . setRef ( bse . getRef ( ) - 1 ) ; getOptRecord ( ) . removeEscherProperty ( EscherPropertyTypes . FILL__PATTERNTEXTURE ) ; } setPropertyValue ( new EscherSimpleProperty ( EscherPropertyTypes . FILL__FILLTYPE , false , false , FILL_TYPE_SOLID ) ) ; }
public void reset ( DataInput in , long valueCount ) { this . in = in ; assert valueCount >= 0 ; this . valueCount = valueCount ; off = blockSize ; ord = 0 ; }
public ResetSnapshotAttributeResult resetSnapshotAttribute ( ResetSnapshotAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeResetSnapshotAttribute ( request ) ; }
public MutableValue duplicate ( ) { MutableValueStr v = new MutableValueStr ( ) ; v . value . copyBytes ( value ) ; v . exists = this . exists ; return v ; }
public int getColumnNumber ( ) { return column ; }
public TokenStream create ( TokenStream input ) { if ( pattern != null ) { input = new PatternKeywordMarkerFilter ( input , pattern ) ; } if ( protectedWords != null ) { input = new SetKeywordMarkerFilter ( input , protectedWords ) ; } return input ; }
public ElisionFilter ( TokenStream input , CharArraySet articles ) { super ( input ) ; this . articles = articles ; }
public static int strcmp ( String str , char [ ] a , int start ) { int i , d , len = str . length ( ) ; for ( i = 0 ; i < len ; i ++ ) { d = ( int ) str . charAt ( i ) - a [ start + i ] ; if ( d != 0 ) { return d ; } if ( a [ start + i ] == 0 ) { return d ; } } if ( a [ start + i ] != 0 ) { return - a [ start + i ] ; } return 0 ; }
public NavigableSet < E > descendingSet ( ) { return ( descendingSet != null ) ? descendingSet : ( descendingSet = new TreeSet < E > ( backingMap . descendingMap ( ) ) ) ; }
public DecisionInfo [ ] getDecisionInfo ( ) { return decisions ; }
public PushConnection openPush ( ) throws NotSupportedException { throw new NotSupportedException ( JGitText . get ( ) . pushIsNotSupportedForBundleTransport ) ; }
public PutRecordResult putRecord ( PutRecordRequest request ) { request = beforeClientExecution ( request ) ; return executePutRecord ( request ) ; }
public List <? extends Token > getAllTokens ( ) { List < Token > tokens = new ArrayList < Token > ( ) ; Token t = nextToken ( ) ; while ( t . getType ( ) != Token . EOF ) { tokens . add ( t ) ; t = nextToken ( ) ; } return tokens ; }
public ModifyInstanceCapacityReservationAttributesResult modifyInstanceCapacityReservationAttributes ( ModifyInstanceCapacityReservationAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyInstanceCapacityReservationAttributes ( request ) ; }
public MoveFacePhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " MoveFacePhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public RequestSpotFleetResult requestSpotFleet ( RequestSpotFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeRequestSpotFleet ( request ) ; }
public ListApplicationSnapshotsResult listApplicationSnapshots ( ListApplicationSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeListApplicationSnapshots ( request ) ; }
public DefaultAcsClient ( IClientProfile profile , AlibabaCloudCredentials credentials ) { this ( profile , new StaticCredentialsProvider ( credentials ) ) ; }
public ConcurrentRefUpdateException ( String message , Ref ref , RefUpdate . Result rc ) { super ( ( rc == null ) ? message : message + " . ▁ " + MessageFormat . format ( JGitText . get ( ) . refUpdateReturnCodeWas , rc ) ) ; this . rc = rc ; this . ref = ref ; }
public DeleteNetworkAclResult deleteNetworkAcl ( DeleteNetworkAclRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNetworkAcl ( request ) ; }
public ShortBuffer get ( short [ ] dst , int dstOffset , int shortCount ) { Arrays . checkOffsetAndCount ( dst . length , dstOffset , shortCount ) ; if ( shortCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } for ( int i = dstOffset ; i < dstOffset + shortCount ; ++ i ) { dst [ i ] = get ( ) ; } return this ; }
public static SharedValueManager createEmpty ( ) { return new SharedValueManager ( new SharedFormulaRecord [ 0 ] , new CellReference [ 0 ] , new ArrayRecord [ 0 ] , new TableRecord [ 0 ] ) ; }
public DeleteCacheSecurityGroupResult deleteCacheSecurityGroup ( DeleteCacheSecurityGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCacheSecurityGroup ( request ) ; }
public CreateGroupRequest ( String groupName ) { setGroupName ( groupName ) ; }
public void setParentId ( AnyObjectId newParent ) { parentIds = new ObjectId [ ] { newParent . copy ( ) } ; }
public static boolean hasConflictingAltSet ( Collection < BitSet > altsets ) { for ( BitSet alts : altsets ) { if ( alts . cardinality ( ) > 1 ) { return true ; } } return false ; }
public CommonRpcRequest ( String product ) { super ( product ) ; setAcceptFormat ( FormatType . JSON ) ; }
public K next ( ) { return super . nextEntry ( ) . key ; }
public DeleteTransitGatewayMulticastDomainResult deleteTransitGatewayMulticastDomain ( DeleteTransitGatewayMulticastDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTransitGatewayMulticastDomain ( request ) ; }
public DescribeEventsResult describeEvents ( DescribeEventsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEvents ( request ) ; }
public DescribeFleetsResult describeFleets ( DescribeFleetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFleets ( request ) ; }
public DescribeDataRepositoryTasksResult describeDataRepositoryTasks ( DescribeDataRepositoryTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDataRepositoryTasks ( request ) ; }
public StartLabelDetectionResult startLabelDetection ( StartLabelDetectionRequest request ) { request = beforeClientExecution ( request ) ; return executeStartLabelDetection ( request ) ; }
public static long getLastCommitGeneration ( String [ ] files ) { long max = - 1 ; for ( String file : files ) { if ( file . startsWith ( IndexFileNames . SEGMENTS ) && file . startsWith ( OLD_SEGMENTS_GEN ) == false ) { long gen = generationFromSegmentsFileName ( file ) ; if ( gen > max ) { max = gen ; } } } return max ; }
public EnableFastSnapshotRestoresResult enableFastSnapshotRestores ( EnableFastSnapshotRestoresRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableFastSnapshotRestores ( request ) ; }
public ListVPCAssociationAuthorizationsResult listVPCAssociationAuthorizations ( ListVPCAssociationAuthorizationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListVPCAssociationAuthorizations ( request ) ; }
public Thumbnail ( final byte [ ] thumbnailData ) { this . _thumbnailData = thumbnailData ; }
public final Explanation explain ( BasicStats stats , double tfn ) { return Explanation . match ( ( float ) ( scoreTimes1pTfn ( stats ) / ( 1 + tfn ) ) , getClass ( ) . getSimpleName ( ) + " , ▁ computed ▁ as ▁ 1 ▁ / ▁ ( tfn ▁ + ▁ 1 ) ▁ from : " , Explanation . match ( ( float ) tfn , " tfn , ▁ normalized ▁ term ▁ frequency " ) ) ; }
public static String [ ] parse ( String line ) { boolean insideQuote = false ; ArrayList < String > result = new ArrayList <> ( ) ; int quoteCount = 0 ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { char c = line . charAt ( i ) ; if ( c == QUOTE ) { insideQuote = ! insideQuote ; quoteCount ++ ; } if ( c == COMMA && ! insideQuote ) { String value = sb . toString ( ) ; value = unQuoteUnEscape ( value ) ; result . add ( value ) ; sb . setLength ( 0 ) ; continue ; } sb . append ( c ) ; } result . add ( sb . toString ( ) ) ; if ( quoteCount % 2 != 0 ) { return new String [ 0 ] ; } return result . toArray ( new String [ result . size ( ) ] ) ; }
public String toString ( String field ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " mask ( " ) ; buffer . append ( maskedQuery . toString ( field ) ) ; buffer . append ( " ) " ) ; buffer . append ( " ▁ as ▁ " ) ; buffer . append ( this . field ) ; return buffer . toString ( ) ; }
public static RevFilter create ( String pattern ) { if ( pattern . length ( ) == 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . cannotMatchOnEmptyString ) ; if ( SubStringRevFilter . safe ( pattern ) ) return new SubStringSearch ( pattern ) ; return new PatternSearch ( pattern ) ; }
public NotImplementedFunctionException ( String functionName ) { super ( functionName ) ; this . functionName = functionName ; }
public DeleteResourceResult deleteResource ( DeleteResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteResource ( request ) ; }
public PaletteRecord ( ) { PColor [ ] defaultPalette = createDefaultPalette ( ) ; _colors . ensureCapacity ( defaultPalette . length ) ; Collections . addAll ( _colors , defaultPalette ) ; }
public GetRepoBuildLogsRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoBuildLogs " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / build / [ BuildId ] / logs " ) ; setMethod ( MethodType . GET ) ; }
public String toString ( ) { return " SortedSetDocValuesFacetField ( dim = " + dim + " ▁ label = " + label + " ) " ; }
public Break ( int main , int subFrom , int subTo ) { this . main = main ; this . subFrom = subFrom ; this . subTo = subTo ; }
public void setParams ( String params ) { super . setParams ( params ) ; docSize = ( int ) Float . parseFloat ( params ) ; }
public static double pv ( double r , double n , double y , double f , boolean t ) { double retval = 0 ; if ( r == 0 ) { retval = - 1 * ( ( n * y ) + f ) ; } else { double r1 = r + 1 ; retval = ( ( ( 1 - Math . pow ( r1 , n ) ) / r ) * ( t ? r1 : 1 ) * y - f ) / Math . pow ( r1 , n ) ; } return retval ; }
public int compareTo ( File another ) { return this . getPath ( ) . compareTo ( another . getPath ( ) ) ; }
public void writeByte ( int value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeByte ( value ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( " [ Data ▁ Table ▁ - ▁ Parent ▁ cell ▁ is ▁ an ▁ interior ▁ cell ▁ in ▁ a ▁ data ▁ table ] \ n " ) ; buffer . append ( " top ▁ left ▁ row ▁ = ▁ " ) . append ( getRow ( ) ) . append ( " \ n " ) ; buffer . append ( " top ▁ left ▁ col ▁ = ▁ " ) . append ( getColumn ( ) ) . append ( " \ n " ) ; return buffer . toString ( ) ; }
public Credential ( ) { this . refreshDate = new Date ( ) ; }
public NavigableMap < K , V > subMap ( K fromInclusive , K toExclusive ) { return subMap ( fromInclusive , INCLUSIVE , toExclusive , EXCLUSIVE ) ; }
public DescribeLedgerResult describeLedger ( DescribeLedgerRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLedger ( request ) ; }
public boolean isNoPrefix ( ) { return noPrefix ; }
public static Policy fromJson ( String jsonString ) { return fromJson ( jsonString , new PolicyReaderOptions ( ) ) ; }
public GetPhoneNumberResult getPhoneNumber ( GetPhoneNumberRequest request ) { request = beforeClientExecution ( request ) ; return executeGetPhoneNumber ( request ) ; }
public static void writeUnicodeString ( LittleEndianOutput out , String value ) { int nChars = value . length ( ) ; out . writeShort ( nChars ) ; boolean is16Bit = hasMultibyte ( value ) ; out . writeByte ( is16Bit ? 0x01 : 0x00 ) ; if ( is16Bit ) { putUnicodeLE ( value , out ) ; } else { putCompressedUnicode ( value , out ) ; } }
public DescribeCoipPoolsResult describeCoipPools ( DescribeCoipPoolsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCoipPools ( request ) ; }
public void removeRow ( Row row ) { HSSFRow hrow = ( HSSFRow ) row ; if ( row . getSheet ( ) != this ) { throw new IllegalArgumentException ( " Specified ▁ row ▁ does ▁ not ▁ belong ▁ to ▁ this ▁ sheet " ) ; } for ( Cell cell : row ) { HSSFCell xcell = ( HSSFCell ) cell ; if ( xcell . isPartOfArrayFormulaGroup ( ) ) { String msg = " Row [ rownum = " + row . getRowNum ( ) + " ] ▁ contains ▁ cell ( s ) ▁ included ▁ in ▁ a ▁ multi - cell ▁ array ▁ formula . ▁ You ▁ cannot ▁ change ▁ part ▁ of ▁ an ▁ array . " ; xcell . tryToDeleteArrayFormula ( msg ) ; } } if ( _rows . size ( ) > 0 ) { Integer key = Integer . valueOf ( row . getRowNum ( ) ) ; HSSFRow removedRow = _rows . remove ( key ) ; if ( removedRow != row ) { throw new IllegalArgumentException ( " Specified ▁ row ▁ does ▁ not ▁ belong ▁ to ▁ this ▁ sheet " ) ; } if ( hrow . getRowNum ( ) == getLastRowNum ( ) ) { _lastrow = findLastRow ( _lastrow ) ; } if ( hrow . getRowNum ( ) == getFirstRowNum ( ) ) { _firstrow = findFirstRow ( _firstrow ) ; } _sheet . removeRow ( hrow . getRowRecord ( ) ) ; if ( _rows . size ( ) == 0 ) { _firstrow = - 1 ; _lastrow = - 1 ; } } }
public static TreeFilter create ( Collection < TreeFilter > list ) { if ( list . size ( ) < 2 ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastTwoFiltersNeeded ) ; final TreeFilter [ ] subfilters = new TreeFilter [ list . size ( ) ] ; list . toArray ( subfilters ) ; if ( subfilters . length == 2 ) return create ( subfilters [ 0 ] , subfilters [ 1 ] ) ; return new List ( subfilters ) ; }
public SpanOrTermsBuilder ( Analyzer analyzer ) { this . analyzer = analyzer ; }
public boolean isReadOnly ( ) { return byteBuffer . isReadOnly ( ) ; }
public void setValuesCellRange ( CellRangeAddressBase range ) { Integer count = setVerticalCellRange ( dataValues , range ) ; if ( count == null ) { return ; } series . setNumValues ( ( short ) ( int ) count ) ; }
public GlobalReplicationGroup modifyGlobalReplicationGroup ( ModifyGlobalReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyGlobalReplicationGroup ( request ) ; }
public CreateTrialResult createTrial ( CreateTrialRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTrial ( request ) ; }
public void preWrite ( ) { List < Property > pList = new ArrayList <> ( ) ; int i = 0 ; for ( Property p : _properties ) { if ( p == null ) continue ; p . setIndex ( i ++ ) ; pList . add ( p ) ; } for ( Property p : pList ) p . preWrite ( ) ; }
public E first ( ) { return backingMap . firstKey ( ) ; }
public int available ( ) { return data . length - ptr ; }
public GetHostedZoneCountResult getHostedZoneCount ( GetHostedZoneCountRequest request ) { request = beforeClientExecution ( request ) ; return executeGetHostedZoneCount ( request ) ; }
public LookupResult [ ] getResults ( ) { int size = size ( ) ; LookupResult [ ] res = new LookupResult [ size ] ; for ( int i = size - 1 ; i >= 0 ; i -- ) { res [ i ] = pop ( ) ; } return res ; }
public void add ( Transition t ) { if ( transitions . length < next + 3 ) { transitions = ArrayUtil . grow ( transitions , next + 3 ) ; } transitions [ next ] = t . dest ; transitions [ next + 1 ] = t . min ; transitions [ next + 2 ] = t . max ; next += 3 ; }
public String getFormatString ( int formatIndex ) { String format = null ; if ( formatIndex >= HSSFDataFormat . getNumberOfBuiltinBuiltinFormats ( ) ) { FormatRecord tfr = _customFormatRecords . get ( Integer . valueOf ( formatIndex ) ) ; if ( tfr == null ) { logger . log ( POILogger . ERROR , " Requested ▁ format ▁ at ▁ index ▁ " + formatIndex + " , ▁ but ▁ it ▁ wasn ' t found " ) ; } ▁ else ▁ { format ▁ = ▁ tfr . getFormatString ( ) ; } } ▁ else ▁ { format ▁ = ▁ HSSFDataFormat . getBuiltinFormat ( ( short ) ▁ formatIndex ) ; } return ▁ format ; }
public DisassociateDelegateFromResourceResult disassociateDelegateFromResource ( DisassociateDelegateFromResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateDelegateFromResource ( request ) ; }
public void readFully ( byte [ ] dst , int offset , int byteCount ) throws IOException { primitiveTypes . readFully ( dst , offset , byteCount ) ; }
public StartDocumentClassificationJobResult startDocumentClassificationJob ( StartDocumentClassificationJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStartDocumentClassificationJob ( request ) ; }
public final float [ ] array ( ) { return protectedArray ( ) ; }
public void prunePacked ( ) throws IOException { ObjectDirectory objdb = repo . getObjectDatabase ( ) ; Collection < PackFile > packs = objdb . getPacks ( ) ; File objects = repo . getObjectsDirectory ( ) ; String [ ] fanout = objects . list ( ) ; if ( fanout != null && fanout . length > 0 ) { pm . beginTask ( JGitText . get ( ) . pruneLoosePackedObjects , fanout . length ) ; try { for ( String d : fanout ) { checkCancelled ( ) ; pm . update ( 1 ) ; if ( d . length ( ) != 2 ) continue ; String [ ] entries = new File ( objects , d ) . list ( ) ; if ( entries == null ) continue ; for ( String e : entries ) { checkCancelled ( ) ; if ( e . length ( ) != Constants . OBJECT_ID_STRING_LENGTH - 2 ) continue ; ObjectId id ; try { id = ObjectId . fromString ( d + e ) ; } catch ( IllegalArgumentException notAnObject ) { continue ; } boolean found = false ; for ( PackFile p : packs ) { checkCancelled ( ) ; if ( p . hasObject ( id ) ) { found = true ; break ; } } if ( found ) FileUtils . delete ( objdb . fileFor ( id ) , FileUtils . RETRY | FileUtils . SKIP_MISSING | FileUtils . IGNORE_ERRORS ) ; } } } finally { pm . endTask ( ) ; } } }
public ListJobsByPipelineResult listJobsByPipeline ( ListJobsByPipelineRequest request ) { request = beforeClientExecution ( request ) ; return executeListJobsByPipeline ( request ) ; }
public SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialRequest ( ) { super ( " Domain " , " 2018 - 01 - 29 " , " SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredential " ) ; setMethod ( MethodType . POST ) ; }
public DeleteDhcpOptionsResult deleteDhcpOptions ( DeleteDhcpOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDhcpOptions ( request ) ; }
public String getSheetLastNameByExternSheet ( int externSheetIndex ) { return _iBook . findSheetLastNameFromExternSheet ( externSheetIndex ) ; }
public InMemorySorter ( Comparator < BytesRef > comparator ) { this . comparator = comparator ; }
public boolean isSymbolic ( ) { return true ; }
public static ValueEval chooseSingleElementFromArea ( AreaEval ae , int srcCellRow , int srcCellCol ) throws EvaluationException { ValueEval result = chooseSingleElementFromAreaInternal ( ae , srcCellRow , srcCellCol ) ; if ( result instanceof ErrorEval ) { throw new EvaluationException ( ( ErrorEval ) result ) ; } return result ; }
public int freeBlocks ( int num ) { assert num >= 0 : " free ▁ blocks ▁ must ▁ be ▁ >= ▁ 0 ▁ but ▁ was : ▁ " + num ; final int stop ; final int count ; if ( num > freeBlocks ) { stop = 0 ; count = freeBlocks ; } else { stop = freeBlocks - num ; count = num ; } while ( freeBlocks > stop ) { freeByteBlocks [ -- freeBlocks ] = null ; } bytesUsed . addAndGet ( - count * blockSize ) ; assert bytesUsed . get ( ) >= 0 ; return count ; }
public final static String htmlEncode ( String plainText ) { if ( plainText == null || plainText . length ( ) == 0 ) { return " " ; } StringBuilder result = new StringBuilder ( plainText . length ( ) ) ; for ( int index = 0 ; index < plainText . length ( ) ; index ++ ) { char ch = plainText . charAt ( index ) ; switch ( ch ) { case ' " ' : result . append ( " & quot ; " ) ; break ; case ▁ ' & ' : result . append ( " & amp ; " ) ; break ; case ▁ ' < ' : result . append ( " & lt ; " ) ; break ; case ▁ ' > ' : result . append ( " & gt ; " ) ; break ; case ▁ ' \ ' ' : result . append ( " &# x27 ; " ) ; break ; case ▁ ' / ' : result . append ( " &# x2F ; " ) ; break ; default : result . append ( ch ) ; } } return ▁ result . toString ( ) ; }
public boolean isReuseDeltas ( ) { return reuseDeltas ; }
public static int headerLength ( String codec ) { return 9 + codec . length ( ) ; }
public StartCelebrityRecognitionResult startCelebrityRecognition ( StartCelebrityRecognitionRequest request ) { request = beforeClientExecution ( request ) ; return executeStartCelebrityRecognition ( request ) ; }
public synchronized void write ( byte [ ] buffer , int offset , int length ) throws IOException { checkNotClosed ( ) ; if ( buffer == null ) { throw new NullPointerException ( " buffer ▁ == ▁ null " ) ; } byte [ ] internalBuffer = buf ; if ( length >= internalBuffer . length ) { flushInternal ( ) ; out . write ( buffer , offset , length ) ; return ; } Arrays . checkOffsetAndCount ( buffer . length , offset , length ) ; if ( length > ( internalBuffer . length - count ) ) { flushInternal ( ) ; } System . arraycopy ( buffer , offset , internalBuffer , count , length ) ; count += length ; }
public int readRecordSID ( ) { return _lei . readUShort ( ) ; }
public ListProfileTimesResult listProfileTimes ( ListProfileTimesRequest request ) { request = beforeClientExecution ( request ) ; return executeListProfileTimes ( request ) ; }
public RevFilter clone ( ) { final RevFilter [ ] s = new RevFilter [ subfilters . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) s [ i ] = subfilters [ i ] . clone ( ) ; return new List ( s ) ; }
public Cluster modifyCluster ( ModifyClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyCluster ( request ) ; }
public GetRouteResponsesResult getRouteResponses ( GetRouteResponsesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRouteResponses ( request ) ; }
synchronized public QueryMaker getQueryMaker ( ReadTask readTask ) { Class <? extends ReadTask > readTaskClass = readTask . getClass ( ) ; QueryMaker qm = readTaskQueryMaker . get ( readTaskClass ) ; if ( qm == null ) { try { qm = qmkrClass . getConstructor ( ) . newInstance ( ) ; qm . setConfig ( config ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } readTaskQueryMaker . put ( readTaskClass , qm ) ; } return qm ; }
public boolean promptYesNo ( String msg ) { CredentialItem . YesNoType v = new CredentialItem . YesNoType ( msg ) ; return provider . get ( uri , v ) && v . getValue ( ) ; }
public String utf8ToString ( ) { final char [ ] ref = new char [ length ] ; final int len = UnicodeUtil . UTF8toUTF16 ( bytes , offset , length , ref ) ; return new String ( ref , 0 , len ) ; }
public ListCandidatesForAutoMLJobResult listCandidatesForAutoMLJob ( ListCandidatesForAutoMLJobRequest request ) { request = beforeClientExecution ( request ) ; return executeListCandidatesForAutoMLJob ( request ) ; }
public String toFormulaString ( FormulaRenderingWorkbook book ) { return book . resolveNameXText ( this ) ; }
public UpdateSkillGroupResult updateSkillGroup ( UpdateSkillGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateSkillGroup ( request ) ; }
public String getValue ( ) { return RawParseUtils . decode ( enc , buffer , valStart , valEnd ) ; }
public ListAssociatedFleetsResult listAssociatedFleets ( ListAssociatedFleetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAssociatedFleets ( request ) ; }
public void removeLastChild ( ) { if ( children != null ) { children . remove ( children . size ( ) - 1 ) ; } }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 6 ) | ( byte1 >>> 2 ) ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte3 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 3 ) << 12 ) | ( byte2 << 4 ) | ( byte3 >>> 4 ) ; final long byte4 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte5 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte3 & 15 ) << 10 ) | ( byte4 << 2 ) | ( byte5 >>> 6 ) ; final long byte6 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte5 & 63 ) << 8 ) | byte6 ; } }
public String describeParams ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " \ t " ) . append ( " maxQueryTerms ▁ ▁ : ▁ " ) . append ( maxQueryTerms ) . append ( " \ n " ) ; sb . append ( " \ t " ) . append ( " minWordLen ▁ ▁ ▁ ▁ ▁ : ▁ " ) . append ( minWordLen ) . append ( " \ n " ) ; sb . append ( " \ t " ) . append ( " maxWordLen ▁ ▁ ▁ ▁ ▁ : ▁ " ) . append ( maxWordLen ) . append ( " \ n " ) ; sb . append ( " \ t " ) . append ( " fieldNames ▁ ▁ ▁ ▁ ▁ : ▁ " ) ; String delim = " " ; for ( String fieldName : fieldNames ) { sb . append ( delim ) . append ( fieldName ) ; delim = " , ▁ " ; } sb . append ( " \ n " ) ; sb . append ( " \ t " ) . append ( " boost ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ : ▁ " ) . append ( boost ) . append ( " \ n " ) ; sb . append ( " \ t " ) . append ( " minTermFreq ▁ ▁ ▁ ▁ : ▁ " ) . append ( minTermFreq ) . append ( " \ n " ) ; sb . append ( " \ t " ) . append ( " minDocFreq ▁ ▁ ▁ ▁ ▁ : ▁ " ) . append ( minDocFreq ) . append ( " \ n " ) ; return sb . toString ( ) ; }
public RunScheduledInstancesResult runScheduledInstances ( RunScheduledInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeRunScheduledInstances ( request ) ; }
public static boolean isValidExcelDate ( double value ) { return ( value > - Double . MIN_VALUE ) ; }
public CreateBranchCommand setForce ( boolean force ) { checkCallable ( ) ; this . force = force ; return this ; }
public AbstractEscherHolderRecord ( RecordInputStream in ) { if ( ! DESERIALISE ) { rawDataContainer . concatenate ( in . readRemainder ( ) ) ; } else { byte [ ] data = in . readAllContinuedRemainder ( ) ; convertToEscherRecords ( 0 , data . length , data ) ; } }
public int next ( int n ) { currentSentence += n ; if ( n < 0 ) { if ( text . getIndex ( ) == text . getEndIndex ( ) ) { ++ currentSentence ; } if ( currentSentence < 0 ) { currentSentence = 0 ; text . setIndex ( text . getBeginIndex ( ) ) ; return DONE ; } else { text . setIndex ( sentenceStarts [ currentSentence ] ) ; } } else if ( n > 0 ) { if ( currentSentence >= sentenceStarts . length ) { currentSentence = sentenceStarts . length - 1 ; text . setIndex ( text . getEndIndex ( ) ) ; return DONE ; } else { text . setIndex ( sentenceStarts [ currentSentence ] ) ; } } return current ( ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; RunAutomaton other = ( RunAutomaton ) obj ; if ( alphabetSize != other . alphabetSize ) return false ; if ( size != other . size ) return false ; if ( ! Arrays . equals ( points , other . points ) ) return false ; if ( ! accept . equals ( other . accept ) ) return false ; if ( ! Arrays . equals ( transitions , other . transitions ) ) return false ; return true ; }
public void setOffset ( long offset ) { this . offset = offset ; }
public DescribeKeyPairsResult describeKeyPairs ( ) { return describeKeyPairs ( new DescribeKeyPairsRequest ( ) ) ; }
public ParseTree get ( String label ) { List < ParseTree > parseTrees = labels . get ( label ) ; if ( parseTrees == null || parseTrees . size ( ) == 0 ) { return null ; } return parseTrees . get ( parseTrees . size ( ) - 1 ) ; }
public ListRecordsResult listRecords ( ListRecordsRequest request ) { request = beforeClientExecution ( request ) ; return executeListRecords ( request ) ; }
public DetectStackResourceDriftResult detectStackResourceDrift ( DetectStackResourceDriftRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectStackResourceDrift ( request ) ; }
public String encodeText ( String originalText ) { return htmlEncode ( originalText ) ; }
public Collection < ParseTree > evaluate ( ParseTree t ) { if ( invert ) return new ArrayList < ParseTree > ( ) ; return Trees . getDescendants ( t ) ; }
public DeleteUsagePlanKeyResult deleteUsagePlanKey ( DeleteUsagePlanKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteUsagePlanKey ( request ) ; }
public String getLocalName ( ) { return localName ; }
public DeleteDocumentResult deleteDocument ( DeleteDocumentRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDocument ( request ) ; }
public int getExternalSheetIndex ( String sheetName ) { int sheetIndex = _uBook . getSheetIndex ( sheetName ) ; return _iBook . checkExternSheet ( sheetIndex ) ; }
public IdentityEncoder ( Charset charset ) { this . charset = charset ; }
public static SupBookRecord createInternalReferences ( short numberOfSheets ) { return new SupBookRecord ( false , numberOfSheets ) ; }
public DBInstance createDBInstanceReadReplica ( CreateDBInstanceReadReplicaRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBInstanceReadReplica ( request ) ; }
public DescribePartnerEventSourceResult describePartnerEventSource ( DescribePartnerEventSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribePartnerEventSource ( request ) ; }
public EnterStandbyResult enterStandby ( EnterStandbyRequest request ) { request = beforeClientExecution ( request ) ; return executeEnterStandby ( request ) ; }
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 24 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } } } } for ( int i = 0 ; i < 24 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; }
public CreateCloudFrontOriginAccessIdentityRequest ( CloudFrontOriginAccessIdentityConfig cloudFrontOriginAccessIdentityConfig ) { setCloudFrontOriginAccessIdentityConfig ( cloudFrontOriginAccessIdentityConfig ) ; }
public ResetFpgaImageAttributeResult resetFpgaImageAttribute ( ResetFpgaImageAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeResetFpgaImageAttribute ( request ) ; }
public void serialize ( ContinuableRecordOutput out ) { out . writeInt ( _numStrings ) ; out . writeInt ( _numUniqueStrings ) ; for ( int k = 0 ; k < strings . size ( ) ; k ++ ) { if ( k % ExtSSTRecord . DEFAULT_BUCKET_SIZE == 0 ) { int rOff = out . getTotalSize ( ) ; int index = k / ExtSSTRecord . DEFAULT_BUCKET_SIZE ; if ( index < ExtSSTRecord . MAX_BUCKETS ) { bucketAbsoluteOffsets [ index ] = rOff ; bucketRelativeOffsets [ index ] = rOff ; } } UnicodeString s = getUnicodeString ( k ) ; s . serialize ( out ) ; } }
public DeleteGroupMembershipResult deleteGroupMembership ( DeleteGroupMembershipRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteGroupMembership ( request ) ; }
public GetHostedZoneCountResult getHostedZoneCount ( ) { return getHostedZoneCount ( new GetHostedZoneCountRequest ( ) ) ; }
public NameXPtg getNameXPtg ( String name , int sheetRefIndex ) { for ( int i = 0 ; i < _externalBookBlocks . length ; i ++ ) { int definedNameIndex = _externalBookBlocks [ i ] . getIndexOfName ( name ) ; if ( definedNameIndex < 0 ) { continue ; } int thisSheetRefIndex = findRefIndexFromExtBookIndex ( i ) ; if ( thisSheetRefIndex >= 0 ) { if ( sheetRefIndex == - 1 || thisSheetRefIndex == sheetRefIndex ) { return new NameXPtg ( thisSheetRefIndex , definedNameIndex ) ; } } } return null ; }
public E pop ( ) { return removeFirstImpl ( ) ; }
public void set ( ET object ) { if ( expectedModCount == list . modCount ) { if ( lastLink != null ) { lastLink . data = object ; } else { throw new IllegalStateException ( ) ; } } else { throw new ConcurrentModificationException ( ) ; } }
public ElisionFilterFactory ( Map < String , String > args ) { super ( args ) ; articlesFile = get ( args , " articles " ) ; ignoreCase = getBoolean ( args , " ignoreCase " , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public int [ ] grow ( ) { final int [ ] ord = super . grow ( ) ; if ( start . length < ord . length ) { start = ArrayUtil . grow ( start , ord . length ) ; end = ArrayUtil . grow ( end , ord . length ) ; freq = ArrayUtil . grow ( freq , ord . length ) ; } assert start . length >= ord . length ; assert end . length >= ord . length ; assert freq . length >= ord . length ; return ord ; }
public GetPersonalizedRankingResult getPersonalizedRanking ( GetPersonalizedRankingRequest request ) { request = beforeClientExecution ( request ) ; return executeGetPersonalizedRanking ( request ) ; }
public ObjectId getObjectId ( ) { return ObjectId . fromRaw ( idBuffer ( ) , idOffset ( ) ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( getFirstRow ( ) ) ; out . writeInt ( getLastRow ( ) ) ; out . writeShort ( getFirstCol ( ) ) ; out . writeShort ( getLastCol ( ) ) ; out . writeShort ( ( short ) 0 ) ; }
public RmCommand ( Repository repo ) { super ( repo ) ; filepatterns = new LinkedList <> ( ) ; }
public void recover ( Parser recognizer , RecognitionException e ) { for ( ParserRuleContext context = recognizer . getContext ( ) ; context != null ; context = context . getParent ( ) ) { context . exception = e ; } throw new ParseCancellationException ( e ) ; }
public static BATBlock createBATBlock ( final POIFSBigBlockSize bigBlockSize , ByteBuffer data ) { BATBlock block = new BATBlock ( bigBlockSize ) ; byte [ ] buffer = new byte [ LittleEndian . INT_SIZE ] ; for ( int i = 0 ; i < block . _values . length ; i ++ ) { data . get ( buffer ) ; block . _values [ i ] = LittleEndian . getInt ( buffer ) ; } block . recomputeFree ( ) ; return block ; }
public byte [ ] toByteArray ( ) throws IOException { final long len = length ( ) ; if ( Integer . MAX_VALUE < len ) throw new OutOfMemoryError ( JGitText . get ( ) . lengthExceedsMaximumArraySize ) ; final byte [ ] out = new byte [ ( int ) len ] ; int outPtr = 0 ; for ( Block b : blocks ) { System . arraycopy ( b . buffer , 0 , out , outPtr , b . count ) ; outPtr += b . count ; } return out ; }
public short clearShort ( final short holder ) { return ( short ) clear ( holder ) ; }
public final String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; String recordName = getRecordName ( ) ; sb . append ( " [ " ) . append ( recordName ) . append ( " ] \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . row ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( getRow ( ) ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . col ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( getColumn ( ) ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . xfindex = ▁ " ) . append ( HexDump . shortToHex ( getXFIndex ( ) ) ) . append ( " \ n " ) ; appendValueText ( sb ) ; sb . append ( " \ n " ) ; sb . append ( " [ / " ) . append ( recordName ) . append ( " ] \ n " ) ; return sb . toString ( ) ; }
public IllegalFormatCodePointException ( int c ) { this . c = c ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { return " @ " + this . schema + " : ' " ▁ + ▁ this . value ▁ + ▁ " ' " ; }
public ValueEval evaluate ( ValueEval [ ] args , OperationEvaluationContext ec ) { if ( args . length != 2 ) { return ErrorEval . VALUE_INVALID ; } try { double startDateAsNumber = NumericFunction . singleOperandEvaluate ( args [ 0 ] , ec . getRowIndex ( ) , ec . getColumnIndex ( ) ) ; int months = ( int ) NumericFunction . singleOperandEvaluate ( args [ 1 ] , ec . getRowIndex ( ) , ec . getColumnIndex ( ) ) ; if ( startDateAsNumber >= 0.0 && startDateAsNumber < 1.0 ) { startDateAsNumber = 1.0 ; } Date startDate = DateUtil . getJavaDate ( startDateAsNumber , false ) ; Calendar cal = LocaleUtil . getLocaleCalendar ( ) ; cal . setTime ( startDate ) ; cal . clear ( Calendar . HOUR ) ; cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . clear ( Calendar . MINUTE ) ; cal . clear ( Calendar . SECOND ) ; cal . clear ( Calendar . MILLISECOND ) ; cal . add ( Calendar . MONTH , months + 1 ) ; cal . set ( Calendar . DAY_OF_MONTH , 1 ) ; cal . add ( Calendar . DAY_OF_MONTH , - 1 ) ; return new NumberEval ( DateUtil . getExcelDate ( cal . getTime ( ) ) ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public UnicodeString getSSTString ( int str ) { if ( sst == null ) { insertSST ( ) ; } UnicodeString retval = sst . getString ( str ) ; LOG . log ( DEBUG , " Returning ▁ SST ▁ for ▁ index = " , str , " ▁ String = ▁ " , retval ) ; return retval ; }
public String quote ( String in ) { final StringBuilder r = new StringBuilder ( ) ; r . append ( ' \ ' ' ) ; int start = 0 , i = 0 ; for ( ; i < in . length ( ) ; i ++ ) { switch ( in . charAt ( i ) ) { case ' \ ' ' : case ' ! ' : r . append ( in , start , i ) ; r . append ( ' \ ' ' ) ; r . append ( ' \\ ' ) ; r . append ( in . charAt ( i ) ) ; r . append ( ' \ ' ' ) ; start ▁ = ▁ i ▁ + ▁ 1 ; break ; } } r . append ( in , ▁ start , ▁ i ) ; r . append ( ' \ ' ' ) ; return ▁ r . toString ( ) ; }
public void clear ( ) { lastElement = 0 ; currentOffset = 0 ; Arrays . fill ( offsets , 0 ) ; pool . reset ( false , true ) ; }
public ReplaceableItem ( String name , java . util . List < ReplaceableAttribute > attributes ) { setName ( name ) ; setAttributes ( attributes ) ; }
public int getScore ( ) { return score ; }
public IrishLowerCaseFilter ( TokenStream in ) { super ( in ) ; }
public synchronized void setSecondaryProgress ( int secondaryProgress ) { if ( mIndeterminate ) { return ; } if ( secondaryProgress < 0 ) { secondaryProgress = 0 ; } if ( secondaryProgress > mMax ) { secondaryProgress = mMax ; } if ( secondaryProgress != mSecondaryProgress ) { mSecondaryProgress = secondaryProgress ; refreshProgress ( R . id . secondaryProgress , mSecondaryProgress , false ) ; } }
public static byte [ ] grow ( byte [ ] array ) { return grow ( array , 1 + array . length ) ; }
public List < Token > getHiddenTokensToRight ( int tokenIndex ) { return getHiddenTokensToRight ( tokenIndex , - 1 ) ; }
public DataValidityTable ( ) { _headerRec = new DVALRecord ( ) ; _validationList = new ArrayList <> ( ) ; }
public EvaluationException ( ErrorEval errorEval ) { _errorEval = errorEval ; }
public UpdateConfigurationTemplateRequest ( String applicationName , String templateName ) { setApplicationName ( applicationName ) ; setTemplateName ( templateName ) ; }
public DescribeAvailabilityZonesResult describeAvailabilityZones ( DescribeAvailabilityZonesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAvailabilityZones ( request ) ; }
public static int idealShortArraySize ( int need ) { return idealByteArraySize ( need * 2 ) / 2 ; }
public NumericPayloadTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; payload = requireFloat ( args , " payload " ) ; typeMatch = require ( args , " typeMatch " ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { values [ valuesOffset ++ ] = blocks [ blocksOffset ++ ] & 0xFF ; } }
public DescribeResourcePermissionsResult describeResourcePermissions ( DescribeResourcePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeResourcePermissions ( request ) ; }
public TokenStream create ( TokenStream input ) { return map . fst == null ? input : new SynonymFilter ( input , map , ignoreCase ) ; }
public List < String > getRuleInvocationStack ( ) { return getRuleInvocationStack ( _ctx ) ; }
public void write ( String s ) { reserve ( s . length ( ) ) ; s . getChars ( 0 , s . length ( ) , buf , len ) ; len += s . length ( ) ; }
public void clear ( ) { map . clear ( ) ; }
public DeleteWorkteamResult deleteWorkteam ( DeleteWorkteamRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteWorkteam ( request ) ; }
public String toString ( ) { return " ( " + a . toString ( ) + " ▁ OR ▁ " + b . toString ( ) + " ) " ; }
public TreeFilter clone ( ) { final TreeFilter [ ] s = new TreeFilter [ subfilters . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) s [ i ] = subfilters [ i ] . clone ( ) ; return new List ( s ) ; }
public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( " DiffEntry [ " ) ; buf . append ( changeType ) ; buf . append ( " ▁ " ) ; switch ( changeType ) { case ADD : buf . append ( newPath ) ; break ; case COPY : buf . append ( oldPath + " -> " + newPath ) ; break ; case DELETE : buf . append ( oldPath ) ; break ; case MODIFY : buf . append ( oldPath ) ; break ; case RENAME : buf . append ( oldPath + " -> " + newPath ) ; break ; } buf . append ( " ] " ) ; return buf . toString ( ) ; }
public CreateRepositoryResult createRepository ( CreateRepositoryRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRepository ( request ) ; }
public static String toHex ( String value ) { return ( value == null || value . length ( ) == 0 ) ? " [ ] " : toHex ( value . getBytes ( LocaleUtil . CHARSET_1252 ) ) ; }
public LineFormatRecord ( RecordInputStream in ) { field_1_lineColor = in . readInt ( ) ; field_2_linePattern = in . readShort ( ) ; field_3_weight = in . readShort ( ) ; field_4_format = in . readShort ( ) ; field_5_colourPaletteIndex = in . readShort ( ) ; }
public DescribeClusterResult describeCluster ( DescribeClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCluster ( request ) ; }
public UserAgentConfig getUserAgentConfig ( ) { return userAgentConfig ; }
public float getTokenScore ( ) { String termText = termAtt . toString ( ) ; WeightedTerm queryTerm = termsToFind . get ( termText ) ; if ( queryTerm == null ) { return 0 ; } if ( ! uniqueTermsInFragment . contains ( termText ) ) { totalScore += queryTerm . getWeight ( ) ; uniqueTermsInFragment . add ( termText ) ; } return queryTerm . getWeight ( ) ; }
public void clear ( ) { arrays . clear ( ) ; }
public DescribeEndpointsResult describeEndpoints ( DescribeEndpointsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEndpoints ( request ) ; }
public String toString ( ) { return " PATH ( \ " " + pathStr + " \ " ) " ; }
public DictionaryCompoundWordTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; dictFile = require ( args , " dictionary " ) ; minWordSize = getInt ( args , " minWordSize " , CompoundWordTokenFilterBase . DEFAULT_MIN_WORD_SIZE ) ; minSubwordSize = getInt ( args , " minSubwordSize " , CompoundWordTokenFilterBase . DEFAULT_MIN_SUBWORD_SIZE ) ; maxSubwordSize = getInt ( args , " maxSubwordSize " , CompoundWordTokenFilterBase . DEFAULT_MAX_SUBWORD_SIZE ) ; onlyLongestMatch = getBoolean ( args , " onlyLongestMatch " , true ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public final void writeFloat ( float val ) throws IOException { writeInt ( Float . floatToIntBits ( val ) ) ; }
public char [ ] toCharArray ( ) { char newbuf [ ] = new char [ size ( ) ] ; System . arraycopy ( buf , 0 , newbuf , 0 , size ( ) ) ; return newbuf ; }
public IntervalSet getExpectedTokens ( ) { if ( recognizer != null ) { return recognizer . getATN ( ) . getExpectedTokens ( offendingState , ctx ) ; } return null ; }
public HindiNormalizationFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public UpdateUserIdentityInfoResult updateUserIdentityInfo ( UpdateUserIdentityInfoRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateUserIdentityInfo ( request ) ; }
public Allocator ( int blockSize ) { this . blockSize = blockSize ; }
public NoteMapMerger ( Repository db , NoteMerger noteMerger , MergeStrategy nonNotesMergeStrategy ) { this . db = db ; this . reader = db . newObjectReader ( ) ; this . inserter = db . newObjectInserter ( ) ; this . noteMerger = noteMerger ; this . nonNotesMergeStrategy = nonNotesMergeStrategy ; this . objectIdPrefix = new MutableObjectId ( ) ; }
public ListAliasesResult listAliases ( ListAliasesRequest request ) { request = beforeClientExecution ( request ) ; return executeListAliases ( request ) ; }
public STSAssumeRoleSessionCredentialsProvider withRoleSessionName ( String roleSessionName ) { this . roleSessionName = roleSessionName ; return this ; }
public IntList ( int capacity ) { entries = new int [ capacity ] ; }
public Result getResult ( ) { return result ; }
public int size ( ) { return count ; }
public DescribeAccountAttributesResult describeAccountAttributes ( ) { return describeAccountAttributes ( new DescribeAccountAttributesRequest ( ) ) ; }
public String toString ( ) { return " G " ; }
public StoredField ( String name , double value ) { super ( name , TYPE ) ; fieldsData = value ; }
public GroupedFacetResult ( int size , int minCount , boolean orderByCount , int totalCount , int totalMissingCount ) { this . facetEntries = new TreeSet <> ( orderByCount ? orderByCountAndValue : orderByValue ) ; this . totalMissingCount = totalMissingCount ; this . totalCount = totalCount ; maxSize = size ; currentMin = minCount ; }
public FieldInfo fieldInfo ( String fieldName ) { return byName . get ( fieldName ) ; }
public int regionStart ( ) { return regionStart ; }
public int getPort ( ) { return Host . this . getPort ( ) ; }
public InterruptTimer ( String threadName ) { state = new AlarmState ( ) ; autoKiller = new AutoKiller ( state ) ; thread = new AlarmThread ( threadName , state ) ; thread . start ( ) ; }
public HighFrequencyDictionary ( IndexReader reader , String field , float thresh ) { this . reader = reader ; this . field = field ; this . thresh = thresh ; }
public ModifyDBProxyTargetGroupResult modifyDBProxyTargetGroup ( ModifyDBProxyTargetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBProxyTargetGroup ( request ) ; }
public void close ( ) throws IOException { input . close ( ) ; }
public void reset ( ) { arriving = - 1 ; leaving = - 1 ; }
public SetLoadBalancerListenerSSLCertificateRequest ( String loadBalancerName , Integer loadBalancerPort , String sSLCertificateId ) { setLoadBalancerName ( loadBalancerName ) ; setLoadBalancerPort ( loadBalancerPort ) ; setSSLCertificateId ( sSLCertificateId ) ; }
public SpanTermQuery ( Term term ) { this . term = Objects . requireNonNull ( term ) ; this . termStates = null ; }
public long ramBytesUsed ( ) { long ramBytesUsed = postingsReader . ramBytesUsed ( ) ; for ( TermsReader r : fields . values ( ) ) { ramBytesUsed += r . ramBytesUsed ( ) ; } return ramBytesUsed ; }
public boolean equals ( Object o ) { if ( this . getClass ( ) != o . getClass ( ) ) return false ; DocFreqValueSource other = ( DocFreqValueSource ) o ; return this . indexedField . equals ( other . indexedField ) && this . indexedBytes . equals ( other . indexedBytes ) ; }
public Term getLucenePrefixTerm ( String fieldName ) { return new Term ( fieldName , getPrefix ( ) ) ; }
public Collection < ParseTree > evaluate ( ParseTree t ) { return Trees . findAllTokenNodes ( t , tokenType ) ; }
public static Signer getSigner ( AlibabaCloudCredentials credentials ) { if ( credentials instanceof KeyPairCredentials ) { return SHA256_WITH_RSA_SIGNER ; } else if ( credentials instanceof BearerTokenCredentials ) { return BEARER_TOKEN_SIGNER ; } else { return HMACSHA1_SIGNER ; } }
public PutAccountSendingAttributesResult putAccountSendingAttributes ( PutAccountSendingAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executePutAccountSendingAttributes ( request ) ; }
public static String getExtension ( String filename ) { final int idx = filename . indexOf ( ' . ' ) ; if ( idx == - 1 ) { return null ; } else { return filename . substring ( idx + 1 , filename . length ( ) ) ; } }
public RunJobFlowResult runJobFlow ( RunJobFlowRequest request ) { request = beforeClientExecution ( request ) ; return executeRunJobFlow ( request ) ; }
public int lastLength ( ) { return lastLength ; }
public ListStreamConsumersResult listStreamConsumers ( ListStreamConsumersRequest request ) { request = beforeClientExecution ( request ) ; return executeListStreamConsumers ( request ) ; }
public static SimpleFraction buildFractionMaxDenominator ( double value , int maxDenominator ) { return buildFractionMaxDenominator ( value , 0 , maxDenominator , 100 ) ; }
public void seekExact ( BytesRef term , TermState state ) { throw new IllegalStateException ( " this ▁ method ▁ should ▁ never ▁ be ▁ called " ) ; }
public LsRemoteCommand setUploadPack ( String uploadPack ) { this . uploadPack = uploadPack ; return this ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval numberVE ) { final String hex ; if ( numberVE instanceof RefEval ) { RefEval re = ( RefEval ) numberVE ; hex = OperandResolver . coerceValueToString ( re . getInnerValueEval ( re . getFirstSheetIndex ( ) ) ) ; } else { hex = OperandResolver . coerceValueToString ( numberVE ) ; } try { return new NumberEval ( BaseNumberUtils . convertToDecimal ( hex , HEXADECIMAL_BASE , MAX_NUMBER_OF_PLACES ) ) ; } catch ( IllegalArgumentException e ) { return ErrorEval . NUM_ERROR ; } }
public DescribeInstancesResult describeInstances ( ) { return describeInstances ( new DescribeInstancesRequest ( ) ) ; }
public Collection < RevCommit > call ( ) throws GitAPIException , InvalidRefNameException { checkCallable ( ) ; try { if ( repo . exactRef ( Constants . R_STASH ) == null ) return Collections . emptyList ( ) ; } catch ( IOException e ) { throw new InvalidRefNameException ( MessageFormat . format ( JGitText . get ( ) . cannotRead , Constants . R_STASH ) , e ) ; } final ReflogCommand refLog = new ReflogCommand ( repo ) ; refLog . setRef ( Constants . R_STASH ) ; final Collection < ReflogEntry > stashEntries = refLog . call ( ) ; if ( stashEntries . isEmpty ( ) ) return Collections . emptyList ( ) ; final List < RevCommit > stashCommits = new ArrayList <> ( stashEntries . size ( ) ) ; try ( RevWalk walk = new RevWalk ( repo ) ) { for ( ReflogEntry entry : stashEntries ) { try { stashCommits . add ( walk . parseCommit ( entry . getNewId ( ) ) ) ; } catch ( IOException e ) { throw new JGitInternalException ( MessageFormat . format ( JGitText . get ( ) . cannotReadCommit , entry . getNewId ( ) ) , e ) ; } } } return stashCommits ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeByte ( field_1_error_code ) ; }
public PutAccountSettingResult putAccountSetting ( PutAccountSettingRequest request ) { request = beforeClientExecution ( request ) ; return executePutAccountSetting ( request ) ; }
public static CharacterBuffer newCharacterBuffer ( final int bufferSize ) { if ( bufferSize < 2 ) { throw new IllegalArgumentException ( " buffersize ▁ must ▁ be ▁ >= ▁ 2 " ) ; } return new CharacterBuffer ( new char [ bufferSize ] , 0 , 0 ) ; }
public int getLevelForDistance ( double dist ) { if ( dist == 0 ) return maxLevels ; for ( int i = 0 ; i < maxLevels - 1 ; i ++ ) { if ( dist > levelW [ i ] && dist > levelH [ i ] ) { return i + 1 ; } } return maxLevels ; }
public Query makeLuceneQueryFieldNoBoost ( String fieldName , BasicQueryFactory qf ) { return makeLuceneQueryNoBoost ( qf ) ; }
public ListDedicatedIpPoolsResult listDedicatedIpPools ( ListDedicatedIpPoolsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDedicatedIpPools ( request ) ; }
public static ValueVector createVector ( RefEval re ) { return new SheetVector ( re ) ; }
public RemoveNoteCommand setObjectId ( RevObject id ) { checkCallable ( ) ; this . id = id ; return this ; }
public int getSheetIndex ( String sheetName ) { return _uBook . getSheetIndex ( sheetName ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_chartGroupIndex ) ; }
public FontFormatting ( ) { setFontHeight ( - 1 ) ; setItalic ( false ) ; setFontWieghtModified ( false ) ; setOutline ( false ) ; setShadow ( false ) ; setStrikeout ( false ) ; setEscapementType ( ( short ) 0 ) ; setUnderlineType ( ( byte ) 0 ) ; setFontColorIndex ( ( short ) - 1 ) ; setFontStyleModified ( false ) ; setFontOutlineModified ( false ) ; setFontShadowModified ( false ) ; setFontCancellationModified ( false ) ; setEscapementTypeModified ( false ) ; setUnderlineTypeModified ( false ) ; setShort ( OFFSET_FONT_NAME , 0 ) ; setInt ( OFFSET_NOT_USED1 , 0x00000001 ) ; setInt ( OFFSET_NOT_USED2 , 0x00000000 ) ; setInt ( OFFSET_NOT_USED3 , 0x7FFFFFFF ) ; setShort ( OFFSET_FONT_FORMATING_END , 0x0001 ) ; }
public GetFacetResult getFacet ( GetFacetRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFacet ( request ) ; }
public IndexInput clone ( ) { return ( IndexInput ) super . clone ( ) ; }
public String toFormulaString ( ) { throw new RuntimeException ( " Table ▁ and ▁ Arrays ▁ are ▁ not ▁ yet ▁ supported " ) ; }
public StartFleetResult startFleet ( StartFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeStartFleet ( request ) ; }
public static FontFamily valueOf ( int nativeId ) { for ( FontFamily ff : values ( ) ) { if ( ff . nativeId == nativeId ) { return ff ; } } return null ; }
public synchronized boolean isEmpty ( ) { return size == 0 ; }
public static String encodeBytes ( byte [ ] source ) { return encodeBytes ( source , 0 , source . length ) ; }
public DescribeBackupsResult describeBackups ( DescribeBackupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeBackups ( request ) ; }
public ReflectionMethodRecordCreator ( Method m ) { _m = m ; }
public static int resolvesToJustOneViableAlt ( Collection < BitSet > altsets ) { return getSingleViableAlt ( altsets ) ; }
public GetGatewayResult getGateway ( GetGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeGetGateway ( request ) ; }
public void onFilterComplete ( int count ) { updateDropDownForFilter ( count ) ; }
public boolean isReadOnly ( ) { return true ; }
public FreeRefFunction findUserDefinedFunction ( String functionName ) { return _bookEvaluator . findUserDefinedFunction ( functionName ) ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof PrecedencePredicate ) ) { return false ; } if ( this == obj ) { return true ; } PrecedencePredicate other = ( PrecedencePredicate ) obj ; return this . precedence == other . precedence ; }
public int getStringWidth ( String str ) { int width = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { width += getCharWidth ( str . charAt ( i ) ) ; } return width ; }
public ByteVector ( byte [ ] a ) { blockSize = DEFAULT_BLOCK_SIZE ; array = a ; n = 0 ; }
public DeleteVerifiedEmailAddressResult deleteVerifiedEmailAddress ( DeleteVerifiedEmailAddressRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVerifiedEmailAddress ( request ) ; }
public DescribeScalingActivitiesResult describeScalingActivities ( DescribeScalingActivitiesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeScalingActivities ( request ) ; }
public SimpleQueryParser ( Analyzer analyzer , String field ) { this ( analyzer , Collections . singletonMap ( field , 1.0F ) ) ; }
final public SrndQuery AndQuery ( ) throws ParseException { SrndQuery q ; ArrayList < SrndQuery > queries = null ; Token oprt = null ; q = NotQuery ( ) ; label_3 : while ( true ) { switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case AND : ; break ; default : jj_la1 [ 1 ] = jj_gen ; break label_3 ; } oprt = jj_consume_token ( AND ) ; if ( queries == null ) { queries = new ArrayList < SrndQuery > ( ) ; queries . add ( q ) ; } q = NotQuery ( ) ; queries . add ( q ) ; } { if ( true ) return ( queries == null ) ? q : getAndQuery ( queries , true , oprt ) ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public final int get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return backingArray [ offset + position ++ ] ; }
public AddJobFlowStepsRequest ( String jobFlowId , java . util . List < StepConfig > steps ) { setJobFlowId ( jobFlowId ) ; setSteps ( steps ) ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " <> " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public static String toHex ( short value ) { StringBuilder sb = new StringBuilder ( 4 ) ; writeHex ( sb , value & 0xFFFF , 4 , " " ) ; return sb . toString ( ) ; }
public static String stripSegmentName ( String filename ) { int idx = indexOfSegmentName ( filename ) ; if ( idx != - 1 ) { filename = filename . substring ( idx ) ; } return filename ; }
public InvalidMarkException ( String detailMessage ) { super ( detailMessage ) ; }
public V nextElement ( ) { return nextEntryNotFailFast ( ) . value ; }
public boolean equals ( Object o ) { if ( o instanceof PersonIdent ) { final PersonIdent p = ( PersonIdent ) o ; return getName ( ) . equals ( p . getName ( ) ) && getEmailAddress ( ) . equals ( p . getEmailAddress ( ) ) && when / 1000L == p . when / 1000L ; } return false ; }
public DetectKeyPhrasesResult detectKeyPhrases ( DetectKeyPhrasesRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectKeyPhrases ( request ) ; }
public long skip ( long byteCount ) throws IOException { return Streams . skipByReading ( this , byteCount ) ; }
public ByteBuffer get ( byte [ ] dst ) { return get ( dst , 0 , dst . length ) ; }
public void setHideObj ( short hide ) { field_1_hide_obj = hide ; }
public final void setLastColumnRaw ( short column ) { field_4_last_column = column ; }
public static PrintCellComments valueOf ( int value ) { return _table [ value ] ; }
public DBInstance deleteDBInstance ( DeleteDBInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDBInstance ( request ) ; }
public String require ( Map < String , String > args , String name ) { String s = args . remove ( name ) ; if ( s == null ) { throw new IllegalArgumentException ( " Configuration ▁ Error : ▁ missing ▁ parameter ▁ ' " ▁ + ▁ name ▁ + ▁ " ' " ) ; } return s ; }
public CompositeReaderContext build ( ) { return ( CompositeReaderContext ) build ( null , reader , 0 , 0 ) ; }
public GetImageLayerRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetImageLayer " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / tags / [ Tag ] / layers " ) ; setMethod ( MethodType . GET ) ; }
public ParameterNameValue ( String parameterName ) { setParameterName ( parameterName ) ; }
public CreateDirectConnectGatewayAssociationProposalResult createDirectConnectGatewayAssociationProposal ( CreateDirectConnectGatewayAssociationProposalRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDirectConnectGatewayAssociationProposal ( request ) ; }
public ListResourceDelegatesResult listResourceDelegates ( ListResourceDelegatesRequest request ) { request = beforeClientExecution ( request ) ; return executeListResourceDelegates ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval numberVE , ValueEval placesVE ) { ValueEval veText1 ; try { veText1 = OperandResolver . getSingleValue ( numberVE , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } String strText1 = OperandResolver . coerceValueToString ( veText1 ) ; Double number = OperandResolver . parseDouble ( strText1 ) ; if ( number == null ) { return ErrorEval . VALUE_INVALID ; } if ( number . longValue ( ) < MIN_VALUE || number . longValue ( ) > MAX_VALUE ) { return ErrorEval . NUM_ERROR ; } int placesNumber ; if ( number < 0 || placesVE == null ) { placesNumber = DEFAULT_PLACES_VALUE ; } else { ValueEval placesValueEval ; try { placesValueEval = OperandResolver . getSingleValue ( placesVE , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } String placesStr = OperandResolver . coerceValueToString ( placesValueEval ) ; Double placesNumberDouble = OperandResolver . parseDouble ( placesStr ) ; if ( placesNumberDouble == null ) { return ErrorEval . VALUE_INVALID ; } placesNumber = placesNumberDouble . intValue ( ) ; if ( placesNumber < 0 || placesNumber == 0 ) { return ErrorEval . NUM_ERROR ; } } String binary = Integer . toBinaryString ( number . intValue ( ) ) ; if ( binary . length ( ) > DEFAULT_PLACES_VALUE ) { binary = binary . substring ( binary . length ( ) - DEFAULT_PLACES_VALUE ) ; } if ( binary . length ( ) > placesNumber ) { return ErrorEval . NUM_ERROR ; } return new StringEval ( binary ) ; }
public static int checkHeaderNoMagic ( DataInput in , String codec , int minVersion , int maxVersion ) throws IOException { final String actualCodec = in . readString ( ) ; if ( ! actualCodec . equals ( codec ) ) { throw new CorruptIndexException ( " codec ▁ mismatch : ▁ actual ▁ codec = " + actualCodec + " ▁ vs ▁ expected ▁ codec = " + codec , in ) ; } final int actualVersion = in . readInt ( ) ; if ( actualVersion < minVersion ) { throw new IndexFormatTooOldException ( in , actualVersion , minVersion , maxVersion ) ; } if ( actualVersion > maxVersion ) { throw new IndexFormatTooNewException ( in , actualVersion , minVersion , maxVersion ) ; } return actualVersion ; }
public DescribeDefaultParametersResult describeDefaultParameters ( DescribeDefaultParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDefaultParameters ( request ) ; }
public SimpleSpanFragmenter ( QueryScorer queryScorer , int fragmentSize ) { this . fragmentSize = fragmentSize ; this . queryScorer = queryScorer ; }
public CreateApplicationResult createApplication ( CreateApplicationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateApplication ( request ) ; }
public URIish getURI ( ) { return uri ; }
public DeleteConferenceProviderResult deleteConferenceProvider ( DeleteConferenceProviderRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteConferenceProvider ( request ) ; }
public byte setByte ( final byte holder ) { return ( byte ) set ( holder ) ; }
public PipedInputStream ( PipedOutputStream out ) throws IOException { connect ( out ) ; }
public IntBuffer slice ( ) { byteBuffer . limit ( limit * SizeOf . INT ) ; byteBuffer . position ( position * SizeOf . INT ) ; ByteBuffer bb = byteBuffer . slice ( ) . order ( byteBuffer . order ( ) ) ; IntBuffer result = new IntToByteBufferAdapter ( bb ) ; byteBuffer . clear ( ) ; return result ; }
public CreateDeploymentConfigResult createDeploymentConfig ( CreateDeploymentConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDeploymentConfig ( request ) ; }
public HSSFColor findColor ( byte red , byte green , byte blue ) { byte [ ] b = _palette . getColor ( PaletteRecord . FIRST_COLOR_INDEX ) ; for ( short i = PaletteRecord . FIRST_COLOR_INDEX ; b != null ; b = _palette . getColor ( ++ i ) ) { if ( b [ 0 ] == red && b [ 1 ] == green && b [ 2 ] == blue ) { return new CustomColor ( i , b ) ; } } return null ; }
public boolean canEncode ( char c ) { return implCanEncode ( CharBuffer . wrap ( new char [ ] { c } ) ) ; }
public NetworkInterface ( String macAddress ) { mac = macAddress ; path = " / network / interfaces / macs / " + mac + " / " ; }
public final boolean isAccept ( int state ) { return accept . get ( state ) ; }
public String toStringTree ( ) { return toStringTree ( ( List < String > ) null ) ; }
public TermRangeQuery ( String field , BytesRef lowerTerm , BytesRef upperTerm , boolean includeLower , boolean includeUpper ) { super ( new Term ( field , lowerTerm ) , toAutomaton ( lowerTerm , upperTerm , includeLower , includeUpper ) , Integer . MAX_VALUE , true ) ; this . lowerTerm = lowerTerm ; this . upperTerm = upperTerm ; this . includeLower = includeLower ; this . includeUpper = includeUpper ; }
public ScanResult scan ( String tableName , java . util . List < String > attributesToGet ) { return scan ( new ScanRequest ( ) . withTableName ( tableName ) . withAttributesToGet ( attributesToGet ) ) ; }
public StopLabelingJobResult stopLabelingJob ( StopLabelingJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopLabelingJob ( request ) ; }
public PublishSchemaResult publishSchema ( PublishSchemaRequest request ) { request = beforeClientExecution ( request ) ; return executePublishSchema ( request ) ; }
public DeleteAttributesRequest ( String domainName , String itemName , java . util . List < Attribute > attributes ) { setDomainName ( domainName ) ; setItemName ( itemName ) ; setAttributes ( attributes ) ; }
public ObjectId toObjectId ( ) { return this ; }
@ Override public ListIterator < E > listIterator ( ) { return listIterator ( 0 ) ; }
public ExternalBookBlock ( ) { _externalBookRecord = SupBookRecord . createAddInFunctions ( ) ; _externalNameRecords = new ExternalNameRecord [ 0 ] ; _crnBlocks = new CRNBlock [ 0 ] ; }
public String getFragment ( ) { return decode ( fragment ) ; }
public String toString ( ) { return slice . toString ( ) + " : " + postingsEnum ; }
public ByteBuffer putDouble ( double value ) { throw new ReadOnlyBufferException ( ) ; }
public static InternalWorkbook createStubWorkbook ( ExternSheetRecord [ ] externs , BoundSheetRecord [ ] bounds ) { return createStubWorkbook ( externs , bounds , null ) ; }
public IndexDocumentsResult indexDocuments ( IndexDocumentsRequest request ) { request = beforeClientExecution ( request ) ; return executeIndexDocuments ( request ) ; }
public String toStringTree ( Parser recog ) { return Trees . toStringTree ( this , recog ) ; }
public FieldsConsumer fieldsConsumer ( SegmentWriteState state ) throws IOException { if ( delegatePostingsFormat == null ) { throw new UnsupportedOperationException ( " Error ▁ - ▁ " + getClass ( ) . getName ( ) + " ▁ has ▁ been ▁ constructed ▁ without ▁ a ▁ choice ▁ of ▁ PostingsFormat " ) ; } FieldsConsumer fieldsConsumer = delegatePostingsFormat . fieldsConsumer ( state ) ; return new BloomFilteredFieldsConsumer ( fieldsConsumer , state ) ; }
public String toString ( ) { return super . toString ( ) + " ( \ " " + pattern . pattern ( ) + " \ " ) " ; }
public static String stripTags ( String buf , int start ) { if ( start > 0 ) { buf = buf . substring ( start ) ; } return buf . replaceAll ( " < [ ^> ] *> " , " ▁ " ) ; }
public Reader create ( Reader input ) { return new JapaneseIterationMarkCharFilter ( input , normalizeKanji , normalizeKana ) ; }
public int getKeyProgressIncrement ( ) { return mKeyProgressIncrement ; }
public void ReInit ( StandardSyntaxParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 25 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public long copyUsingLengthPrefix ( BytesRef bytes ) { if ( bytes . length >= 32768 ) { throw new IllegalArgumentException ( " max ▁ length ▁ is ▁ 32767 ▁ ( got ▁ " + bytes . length + " ) " ) ; } if ( upto + bytes . length + 2 > blockSize ) { if ( bytes . length + 2 > blockSize ) { throw new IllegalArgumentException ( " block ▁ size ▁ " + blockSize + " ▁ is ▁ too ▁ small ▁ to ▁ store ▁ length ▁ " + bytes . length + " ▁ bytes " ) ; } if ( currentBlock != null ) { addBlock ( currentBlock ) ; } currentBlock = new byte [ blockSize ] ; upto = 0 ; } final long pointer = getPointer ( ) ; if ( bytes . length < 128 ) { currentBlock [ upto ++ ] = ( byte ) bytes . length ; } else { currentBlock [ upto ++ ] = ( byte ) ( 0x80 | ( bytes . length >> 8 ) ) ; currentBlock [ upto ++ ] = ( byte ) ( bytes . length & 0xff ) ; } System . arraycopy ( bytes . bytes , bytes . offset , currentBlock , upto , bytes . length ) ; upto += bytes . length ; return pointer ; }
public HighFreqTerm ( int [ ] docIDs , int [ ] freqs , int [ ] [ ] positions , byte [ ] [ ] [ ] payloads , long totalTermFreq ) { this . docIDs = docIDs ; this . freqs = freqs ; this . positions = positions ; this . payloads = payloads ; this . totalTermFreq = totalTermFreq ; }
public TermQuery newTermQuery ( Term term ) throws TooManyBasicQueries { checkMax ( ) ; return new TermQuery ( term ) ; }
public HindiStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public DecisionInfo [ ] getDecisionInfo ( ) { return atnSimulator . getDecisionInfo ( ) ; }
public String toString ( ) { return " < regexp ▁ field = ' " ▁ + ▁ this . field ▁ + ▁ " ' ▁ term = ' " ▁ + ▁ this . text ▁ + ▁ " ' /> " ; }
public CreateStackSetResult createStackSet ( CreateStackSetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateStackSet ( request ) ; }
public SendMessagesResult sendMessages ( SendMessagesRequest request ) { request = beforeClientExecution ( request ) ; return executeSendMessages ( request ) ; }
public synchronized void setCharAt ( int index , char ch ) { super . setCharAt ( index , ch ) ; }
public CreateIntegrationResult createIntegration ( CreateIntegrationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateIntegration ( request ) ; }
public void execute ( Lexer lexer ) { lexer . mode ( mode ) ; }
public void readFully ( byte [ ] dst ) throws IOException { primitiveTypes . readFully ( dst ) ; }
public final void decRef ( ) throws IOException { ensureOpen ( ) ; final int rc = refCount . decrementAndGet ( ) ; if ( rc == 0 ) { boolean success = false ; try { doClose ( ) ; closed = true ; success = true ; } finally { if ( ! success ) { refCount . incrementAndGet ( ) ; } } } else if ( rc < 0 ) { throw new IllegalStateException ( " too ▁ many ▁ decRef ▁ calls : ▁ refCount ▁ is ▁ " + rc + " ▁ after ▁ decrement " ) ; } }
public String toString ( ) { if ( dfa . s0 == null ) return null ; StringBuilder buf = new StringBuilder ( ) ; List < DFAState > states = dfa . getStates ( ) ; for ( DFAState s : states ) { int n = 0 ; if ( s . edges != null ) n = s . edges . length ; for ( int i = 0 ; i < n ; i ++ ) { DFAState t = s . edges [ i ] ; if ( t != null && t . stateNumber != Integer . MAX_VALUE ) { buf . append ( getStateString ( s ) ) ; String label = getEdgeLabel ( i ) ; buf . append ( " - " ) . append ( label ) . append ( " -> " ) . append ( getStateString ( t ) ) . append ( ' \ n ' ) ; } } } String output = buf . toString ( ) ; if ( output . length ( ) == 0 ) return null ; return output ; }
public static void register ( Repository db ) { if ( db . getDirectory ( ) != null ) { FileKey key = FileKey . exact ( db . getDirectory ( ) , db . getFS ( ) ) ; cache . registerRepository ( key , db ) ; } }
public GetConfigurationSetEventDestinationsResult getConfigurationSetEventDestinations ( GetConfigurationSetEventDestinationsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetConfigurationSetEventDestinations ( request ) ; }
public ByteBuffer put ( byte value ) { throw new ReadOnlyBufferException ( ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 ) { AreaEval aeRange ; AreaEval aeSum ; try { aeRange = convertRangeArg ( arg0 ) ; aeSum = createSumRange ( arg2 , aeRange ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return eval ( srcRowIndex , srcColumnIndex , arg1 , aeRange , aeSum ) ; }
public MoPenAddGroupMemberRequest ( ) { super ( " MoPen " , " 2018 - 02 - 11 " , " MoPenAddGroupMember " , " mopen " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public DeleteAssessmentTargetResult deleteAssessmentTarget ( DeleteAssessmentTargetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAssessmentTarget ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SXDI ] \ n " ) ; buffer . append ( " ▁ ▁ . isxvdData ▁ = ▁ " ) . append ( HexDump . shortToHex ( isxvdData ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ . iiftab ▁ = ▁ " ) . append ( HexDump . shortToHex ( iiftab ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ . df ▁ = ▁ " ) . append ( HexDump . shortToHex ( df ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ . isxvd ▁ = ▁ " ) . append ( HexDump . shortToHex ( isxvd ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ . isxvi ▁ = ▁ " ) . append ( HexDump . shortToHex ( isxvi ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ . ifmt ▁ = ▁ " ) . append ( HexDump . shortToHex ( ifmt ) ) . append ( " \ n " ) ; buffer . append ( " [ / SXDI ] \ n " ) ; return buffer . toString ( ) ; }
public String toString ( ) { return " LL " ; }
public DescribeReservedInstancesOfferingsResult describeReservedInstancesOfferings ( DescribeReservedInstancesOfferingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReservedInstancesOfferings ( request ) ; }
public void setNextEnum ( TermsEnum termsEnum ) { this . termsEnum = termsEnum ; this . boostAtt = termsEnum . attributes ( ) . addAttribute ( BoostAttribute . class ) ; }
public RevFilter clone ( ) { return new PatternSearch ( pattern ( ) ) ; }
public GetRouteResponseResult getRouteResponse ( GetRouteResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRouteResponse ( request ) ; }
public UpdateLagResult updateLag ( UpdateLagRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateLag ( request ) ; }
public DescribeEndpointResult describeEndpoint ( DescribeEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEndpoint ( request ) ; }
public void addPositionSpans ( List < PositionSpan > positionSpans ) { this . positionSpans . addAll ( positionSpans ) ; }
public boolean remove ( Object object ) { return backingMap . remove ( object ) != null ; }
public ListPartsResult listParts ( ListPartsRequest request ) { request = beforeClientExecution ( request ) ; return executeListParts ( request ) ; }
public void setForceUpdate ( boolean b ) { force = b ; }
public void removeCustomProperties ( ) { if ( getSectionCount ( ) < 2 ) { } }
public int available ( ) { return remaining ( ) ; }
public GetInstanceResult getInstance ( GetInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInstance ( request ) ; }
public UpdateSmsChannelResult updateSmsChannel ( UpdateSmsChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateSmsChannel ( request ) ; }
public CreateEgressOnlyInternetGatewayResult createEgressOnlyInternetGateway ( CreateEgressOnlyInternetGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateEgressOnlyInternetGateway ( request ) ; }
public GetResourcesResult getResources ( GetResourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetResources ( request ) ; }
public ByteBlockPool ( Allocator allocator ) { this . allocator = allocator ; }
public ListStepsResult listSteps ( ListStepsRequest request ) { request = beforeClientExecution ( request ) ; return executeListSteps ( request ) ; }
public boolean readBoolean ( ) throws IOException { return primitiveTypes . readBoolean ( ) ; }
public PutLogEventsRequest ( String logGroupName , String logStreamName , java . util . List < InputLogEvent > logEvents ) { setLogGroupName ( logGroupName ) ; setLogStreamName ( logStreamName ) ; setLogEvents ( logEvents ) ; }
public void reset ( int sliceOffset ) { this . offset = sliceOffset ; }
public GetAttendeeResult getAttendee ( GetAttendeeRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAttendee ( request ) ; }
public long getFilePointer ( ) { return pointer + pos ; }
public int serializeSimplePart ( byte [ ] data , int pos ) { LittleEndian . putShort ( data , pos , getId ( ) ) ; int recordSize = getComplexData ( ) . length ; if ( ! sizeIncludesHeaderSize ) { recordSize -= 6 ; } LittleEndian . putInt ( data , pos + 2 , recordSize ) ; return 6 ; }
public CherryPickCommand include ( AnyObjectId commit ) { return include ( commit . getName ( ) , commit ) ; }
public int readDataSize ( ) { readPlain ( buffer , 0 , LittleEndianConsts . SHORT_SIZE ) ; int dataSize = LittleEndian . getUShort ( buffer , 0 ) ; ccis . setNextRecordSize ( dataSize ) ; return dataSize ; }
public RemoveUserFromGroupRequest ( String groupName , String userName ) { setGroupName ( groupName ) ; setUserName ( userName ) ; }
public PutImageResult putImage ( PutImageRequest request ) { request = beforeClientExecution ( request ) ; return executePutImage ( request ) ; }
public boolean stem ( ) { limit_backward = cursor ; cursor = limit ; int v_1 = limit - cursor ; r_endings ( ) ; cursor = limit - v_1 ; int v_2 = limit - cursor ; r_undouble ( ) ; cursor = limit - v_2 ; int v_3 = limit - cursor ; r_respell ( ) ; cursor = limit - v_3 ; cursor = limit_backward ; return true ; }
public IntervalSet [ ] getDecisionLookahead ( ATNState s ) { if ( s == null ) { return null ; } IntervalSet [ ] look = new IntervalSet [ s . getNumberOfTransitions ( ) ] ; for ( int alt = 0 ; alt < s . getNumberOfTransitions ( ) ; alt ++ ) { look [ alt ] = new IntervalSet ( ) ; Set < ATNConfig > lookBusy = new HashSet < ATNConfig > ( ) ; boolean seeThruPreds = false ; _LOOK ( s . transition ( alt ) . target , null , PredictionContext . EMPTY , look [ alt ] , lookBusy , new BitSet ( ) , seeThruPreds , false ) ; if ( look [ alt ] . size ( ) == 0 || look [ alt ] . contains ( HIT_PRED ) ) { look [ alt ] = null ; } } return look ; }
public static Ptg createPtg ( LittleEndianInput in ) { byte id = in . readByte ( ) ; if ( id < 0x20 ) { return createBasePtg ( id , in ) ; } Ptg retval = createClassifiedPtg ( id , in ) ; if ( id >= 0x60 ) { retval . setClass ( CLASS_ARRAY ) ; } else if ( id >= 0x40 ) { retval . setClass ( CLASS_VALUE ) ; } else { retval . setClass ( CLASS_REF ) ; } return retval ; }
public ListEntitiesDetectionJobsResult listEntitiesDetectionJobs ( ListEntitiesDetectionJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListEntitiesDetectionJobs ( request ) ; }
public ListReviewableHITsResult listReviewableHITs ( ListReviewableHITsRequest request ) { request = beforeClientExecution ( request ) ; return executeListReviewableHITs ( request ) ; }
public OperationEvaluationContext ( WorkbookEvaluator bookEvaluator , EvaluationWorkbook workbook , int sheetIndex , int srcRowNum , int srcColNum , EvaluationTracker tracker ) { this ( bookEvaluator , workbook , sheetIndex , srcRowNum , srcColNum , tracker , true ) ; }
public void setMaxDocFreqPct ( int maxPercentage ) { setMaxDocFreq ( Math . toIntExact ( ( long ) maxPercentage * ir . maxDoc ( ) / 100 ) ) ; }
public final void lazySet ( V newValue ) { unsafe . putOrderedObject ( this , valueOffset , newValue ) ; }
public UpdateVpcLinkResult updateVpcLink ( UpdateVpcLinkRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateVpcLink ( request ) ; }
public void removeNoteCount ( ) { remove1stProperty ( PropertyIDMap . PID_NOTECOUNT ) ; }
public Ref setValue ( Ref value ) { Ref prior = put ( getKey ( ) , value ) ; ref = value ; return prior ; }
public RevCommit getSourceCommit ( int idx ) { return sourceCommits [ idx ] ; }
public ClassicTokenizerFactory ( Map < String , String > args ) { super ( args ) ; maxTokenLength = getInt ( args , " maxTokenLength " , StandardAnalyzer . DEFAULT_MAX_TOKEN_LENGTH ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public GetDistributionResult getDistribution ( GetDistributionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDistribution ( request ) ; }
public long seek ( long ord ) { long idx = ord / indexInterval ; assert idx < fieldIndex . numIndexTerms ; final long offset = fieldIndex . termOffsets . get ( idx ) ; final int length = ( int ) ( fieldIndex . termOffsets . get ( 1 + idx ) - offset ) ; termBytesReader . fillSlice ( term , fieldIndex . termBytesStart + offset , length ) ; this . ord = idx * indexInterval ; return fieldIndex . termsStart + fieldIndex . termsDictOffsets . get ( idx ) ; }
public DescribeInterconnectsResult describeInterconnects ( DescribeInterconnectsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInterconnects ( request ) ; }
public static EvaluationException invalidValue ( ) { return new EvaluationException ( ErrorEval . VALUE_INVALID ) ; }
public static String escapeWhitespace ( String s , boolean escapeSpaces ) { StringBuilder buf = new StringBuilder ( ) ; for ( char c : s . toCharArray ( ) ) { if ( c == ' ▁ ' && escapeSpaces ) buf . append ( ' \ u00B7 ' ) ; else if ( c == ' \ t ' ) buf . append ( " \\ t " ) ; else if ( c == ' \ n ' ) buf . append ( " \\ n " ) ; else if ( c == ' \ r ' ) buf . append ( " \\ r " ) ; else buf . append ( c ) ; } return buf . toString ( ) ; }
public DescribeOrderableClusterOptionsResult describeOrderableClusterOptions ( DescribeOrderableClusterOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeOrderableClusterOptions ( request ) ; }
public DeleteArchiveRequest ( String vaultName , String archiveId ) { setVaultName ( vaultName ) ; setArchiveId ( archiveId ) ; }
public DescribeSnapshotsResult describeSnapshots ( DescribeSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSnapshots ( request ) ; }
public BatchDeleteClusterSnapshotsResult batchDeleteClusterSnapshots ( BatchDeleteClusterSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDeleteClusterSnapshots ( request ) ; }
public DescribeClientVpnRoutesResult describeClientVpnRoutes ( DescribeClientVpnRoutesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClientVpnRoutes ( request ) ; }
public String toString ( ) { String padd = getPadding ( ) ; StringBuilder sb = new StringBuilder ( super . toString ( ) ) ; sb . append ( parallel ? " ▁ [ " : " ▁ { " ) ; sb . append ( NEW_LINE ) ; for ( final PerfTask task : tasks ) { sb . append ( task . toString ( ) ) ; sb . append ( NEW_LINE ) ; } sb . append ( padd ) ; sb . append ( ! letChildReport ? " > " : ( parallel ? " ] " : " } " ) ) ; if ( fixedTime ) { sb . append ( ' ▁ ' ) . append ( NumberFormat . getNumberInstance ( Locale . ROOT ) . format ( runTimeSec ) ) . append ( ' s ' ) ; } else if ( repetitions > 1 ) { sb . append ( " ▁ * ▁ " ) . append ( repetitions ) ; } else if ( repetitions == REPEAT_EXHAUST ) { sb . append ( " ▁ * ▁ EXHAUST " ) ; } if ( rate > 0 ) { sb . append ( " , ▁ ▁ rate : ▁ " ) . append ( rate ) . append ( ' / ' ) . append ( perMin ? " min " : " sec " ) ; } if ( getRunInBackground ( ) ) { sb . append ( " ▁ & " ) ; int x = getBackgroundDeltaPriority ( ) ; if ( x != 0 ) { sb . append ( x ) ; } } return sb . toString ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeDouble ( field_1_minimumAxisValue ) ; out . writeDouble ( field_2_maximumAxisValue ) ; out . writeDouble ( field_3_majorIncrement ) ; out . writeDouble ( field_4_minorIncrement ) ; out . writeDouble ( field_5_categoryAxisCross ) ; out . writeShort ( field_6_options ) ; }
public final void makeReadOnly ( ) { readOnly = true ; }
public DescribeDirectConnectGatewaysResult describeDirectConnectGateways ( DescribeDirectConnectGatewaysRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDirectConnectGateways ( request ) ; }
public GetUsagePlanKeyResult getUsagePlanKey ( GetUsagePlanKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetUsagePlanKey ( request ) ; }
public DescribeVpcEndpointConnectionNotificationsResult describeVpcEndpointConnectionNotifications ( DescribeVpcEndpointConnectionNotificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcEndpointConnectionNotifications ( request ) ; }
public UpdateGatewayGroupResult updateGatewayGroup ( UpdateGatewayGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateGatewayGroup ( request ) ; }
public DetachClassicLinkVpcResult detachClassicLinkVpc ( DetachClassicLinkVpcRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachClassicLinkVpc ( request ) ; }
public ListOperationsResult listOperations ( ) { return listOperations ( new ListOperationsRequest ( ) ) ; }
public BatchDeletePhoneNumberResult batchDeletePhoneNumber ( BatchDeletePhoneNumberRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDeletePhoneNumber ( request ) ; }
public void setExpireAgeMillis ( long expireAgeMillis ) { this . expireAgeMillis = expireAgeMillis ; expire = null ; }
public DeactivateEventSourceResult deactivateEventSource ( DeactivateEventSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeactivateEventSource ( request ) ; }
public void readBytes ( byte [ ] b , int offset , int len ) { System . arraycopy ( bytes , pos , b , offset , len ) ; pos += len ; }
public IntBuffer put ( int index , int c ) { throw new ReadOnlyBufferException ( ) ; }
public SendUsersMessagesResult sendUsersMessages ( SendUsersMessagesRequest request ) { request = beforeClientExecution ( request ) ; return executeSendUsersMessages ( request ) ; }
public MissingFormatWidthException ( String s ) { if ( s == null ) { throw new NullPointerException ( ) ; } this . s = s ; }
public DescribeVolumesRequest ( java . util . List < String > volumeIds ) { setVolumeIds ( volumeIds ) ; }
public SubmitCutoutTaskRequest ( ) { super ( " lubancloud " , " 2018 - 05 - 09 " , " SubmitCutoutTask " , " luban " ) ; setMethod ( MethodType . POST ) ; }
public DoubleBuffer asReadOnlyBuffer ( ) { return duplicate ( ) ; }
@ Override public int size ( ) { return subMap . size ( ) ; }
public CreateLabelsResult createLabels ( CreateLabelsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLabels ( request ) ; }
public boolean isEmpty ( ) { return size == 0 ; }
public int getRenameScore ( ) { return outCandidate . renameScore ; }
public SeriesTextRecord ( ) { field_4_text = " " ; is16bit = false ; }
public char get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return sequence . charAt ( position ++ ) ; }
public static double irr ( double [ ] values , double guess ) { double x0 = guess ; for ( int i = 0 ; i < MAX_ITERATION_COUNT ; i ++ ) { final double factor = 1.0 + x0 ; double denominator = factor ; if ( denominator == 0 ) { return Double . NaN ; } double fValue = values [ 0 ] ; double fDerivative = 0 ; for ( int k = 1 ; k < values . length ; k ++ ) { final double value = values [ k ] ; fValue += value / denominator ; denominator *= factor ; fDerivative -= k * value / denominator ; } if ( fDerivative == 0 ) { return Double . NaN ; } double x1 = x0 - fValue / fDerivative ; if ( Math . abs ( x1 - x0 ) <= ABSOLUTE_ACCURACY ) { return x1 ; } x0 = x1 ; } return Double . NaN ; }
public static String toHex ( long value ) { StringBuilder sb = new StringBuilder ( 16 ) ; writeHex ( sb , value , 16 , " " ) ; return sb . toString ( ) ; }
public void skip ( ) { _type = SKIP ; }
public HSSFClientAnchor getPreferredSize ( ) { return getPreferredSize ( 1.0 ) ; }
public void fromRaw ( int [ ] ints ) { fromRaw ( ints , 0 ) ; }
public ModifyClusterParameterGroupResult modifyClusterParameterGroup ( ModifyClusterParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyClusterParameterGroup ( request ) ; }
public boolean get ( URIish uri , List < CredentialItem > items ) throws UnsupportedCredentialItem { return get ( uri , items . toArray ( new CredentialItem [ 0 ] ) ) ; }
public synchronized FormatType getFormat ( ) { return acceptFormat ; }
public ListTypesResult listTypes ( ListTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeListTypes ( request ) ; }
public K next ( ) { return nextEntry ( ) . key ; }
public StartAssessmentRunResult startAssessmentRun ( StartAssessmentRunRequest request ) { request = beforeClientExecution ( request ) ; return executeStartAssessmentRun ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! ( obj instanceof OR ) ) return false ; OR other = ( OR ) obj ; return Arrays . equals ( this . opnds , other . opnds ) ; }
public boolean equals ( Object other ) { return ( ( PointTransitions ) other ) . point == point ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 , ValueEval arg3 ) { throw new RuntimeException ( " Incomplete ▁ code " + " ▁ - ▁ don ' t know how to support the ' area □ num ' parameter yet ) " ) ; }
public DescribeClusterParametersResult describeClusterParameters ( DescribeClusterParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClusterParameters ( request ) ; }
public String typeName ( ) { return typeName ; }
public CreateModelPackageResult createModelPackage ( CreateModelPackageRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateModelPackage ( request ) ; }
public long ramBytesUsed ( ) { long mem = RamUsageEstimator . shallowSizeOf ( this ) + RamUsageEstimator . sizeOf ( offsets ) ; if ( offsets != ordinals ) { mem += RamUsageEstimator . sizeOf ( ordinals ) ; } return mem ; }
public final int get ( int index ) { checkIndex ( index ) ; return backingArray [ offset + index ] ; }
public final State captureState ( ) { final State state = this . getCurrentState ( ) ; return ( state == null ) ? null : state . clone ( ) ; }
public String toString ( ) { CellReference cr = new CellReference ( getRow ( ) , getColumn ( ) ) ; return getClass ( ) . getName ( ) + " [ " + _evaluator . getSheetNameRange ( ) + ' ! ' + cr . formatAsString ( ) + " ] " ; }
public CharBuffer compact ( ) { throw new ReadOnlyBufferException ( ) ; }
public DetectCustomLabelsResult detectCustomLabels ( DetectCustomLabelsRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectCustomLabels ( request ) ; }
public int indexOf ( final int o ) { int rval = 0 ; for ( ; rval < _limit ; rval ++ ) { if ( o == _array [ rval ] ) { break ; } } if ( rval == _limit ) { rval = - 1 ; } return rval ; }
public boolean matches ( int symbol , int minVocabSymbol , int maxVocabSymbol ) { return symbol >= minVocabSymbol && symbol <= maxVocabSymbol ; }
@ Override public int indexOf ( Object object ) { Object [ ] a = array ; int s = size ; if ( object != null ) { for ( int i = 0 ; i < s ; i ++ ) { if ( object . equals ( a [ i ] ) ) { return i ; } } } else { for ( int i = 0 ; i < s ; i ++ ) { if ( a [ i ] == null ) { return i ; } } } return - 1 ; }
public void setObjectChecking ( boolean on ) { setObjectChecker ( on ? new ObjectChecker ( ) : null ) ; }
public ModifyVpcEndpointResult modifyVpcEndpoint ( ModifyVpcEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVpcEndpoint ( request ) ; }
public DeleteMethodResponseResult deleteMethodResponse ( DeleteMethodResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMethodResponse ( request ) ; }
public StringRecord ( RecordInputStream in ) { int field_1_string_length = in . readUShort ( ) ; _is16bitUnicode = in . readByte ( ) != 0x00 ; if ( _is16bitUnicode ) { _text = in . readUnicodeLEString ( field_1_string_length ) ; } else { _text = in . readCompressedUnicode ( field_1_string_length ) ; } }
public DrawingRecord ( RecordInputStream in ) { recordData = in . readRemainder ( ) ; }
public GetProfileResult getProfile ( GetProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeGetProfile ( request ) ; }
public DescribeTableResult describeTable ( String tableName ) { return describeTable ( new DescribeTableRequest ( ) . withTableName ( tableName ) ) ; }
public GetSegmentResult getSegment ( GetSegmentRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSegment ( request ) ; }
public IntBuffer duplicate ( ) { return copy ( this , mark ) ; }
public PutAlarmResult putAlarm ( PutAlarmRequest request ) { request = beforeClientExecution ( request ) ; return executePutAlarm ( request ) ; }
public boolean matches ( ValueEval x ) { int testValue ; if ( x instanceof StringEval ) { return false ; } else if ( ( x instanceof BoolEval ) ) { BoolEval be = ( BoolEval ) x ; testValue = boolToInt ( be . getBooleanValue ( ) ) ; } else if ( ( x instanceof BlankEval ) ) { switch ( getCode ( ) ) { case CmpOp . NE : return true ; default : return false ; } } else if ( ( x instanceof NumberEval ) ) { switch ( getCode ( ) ) { case CmpOp . NE : return true ; default : return false ; } } else { return false ; } return evaluate ( testValue - _value ) ; }
public DeleteTrialResult deleteTrial ( DeleteTrialRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTrial ( request ) ; }
public String toString ( ) { return set . toString ( ) ; }
public String toString ( String field ) { StringBuilder buffer = new StringBuilder ( ) ; if ( ! getField ( ) . equals ( field ) ) { buffer . append ( getField ( ) ) ; buffer . append ( " : " ) ; } buffer . append ( includeLower ? ' [ ' : ' { ' ) ; buffer . append ( lowerTerm != null ? ( " * " . equals ( Term . toString ( lowerTerm ) ) ? " \\* " : Term . toString ( lowerTerm ) ) : " * " ) ; buffer . append ( " ▁ TO ▁ " ) ; buffer . append ( upperTerm != null ? ( " * " . equals ( Term . toString ( upperTerm ) ) ? " \\* " : Term . toString ( upperTerm ) ) : " * " ) ; buffer . append ( includeUpper ? ' ] ' : ' } ' ) ; return buffer . toString ( ) ; }
public void reset ( ) { count = 0 ; }
public int [ ] init ( ) { return bytesStart = new int [ ArrayUtil . oversize ( initSize , Integer . BYTES ) ] ; }
public int codePointBefore ( int index ) { if ( index < 1 || index > count ) { throw indexAndLength ( index ) ; } return Character . codePointBefore ( value , index ) ; }
public String toString ( ) { return " SkipWorkTree ( " + treeIdx + " ) " ; }
public GetLifecyclePoliciesResult getLifecyclePolicies ( GetLifecyclePoliciesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLifecyclePolicies ( request ) ; }
public NRTCachingDirectory ( Directory delegate , double maxMergeSizeMB , double maxCachedMB ) { super ( delegate ) ; maxMergeSizeBytes = ( long ) ( maxMergeSizeMB * 1024 * 1024 ) ; maxCachedBytes = ( long ) ( maxCachedMB * 1024 * 1024 ) ; }
public void visitContainedRecords ( RecordVisitor rv ) { visitIfPresent ( _protectRecord , rv ) ; visitIfPresent ( _objectProtectRecord , rv ) ; visitIfPresent ( _scenarioProtectRecord , rv ) ; visitIfPresent ( _passwordRecord , rv ) ; }
public RefSubRecord ( int extBookIndex , int firstSheetIndex , int lastSheetIndex ) { _extBookIndex = extBookIndex ; _firstSheetIndex = firstSheetIndex ; _lastSheetIndex = lastSheetIndex ; }
public long getEntryLength ( ) { return current ( ) . getLength ( ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ( maxLevels : " + maxLevels + " , ctx : " + ctx + " ) " ; }
public BooleanQueryBuilder ( QueryBuilder factory ) { this . factory = factory ; }
public HSSFShape ( EscherContainerRecord spContainer , ObjRecord objRecord ) { this . _escherContainer = spContainer ; this . _objRecord = objRecord ; this . _optRecord = spContainer . getChildById ( EscherOptRecord . RECORD_ID ) ; this . anchor = HSSFAnchor . createAnchorFromEscher ( spContainer ) ; }
public ListUpdatesResult listUpdates ( ListUpdatesRequest request ) { request = beforeClientExecution ( request ) ; return executeListUpdates ( request ) ; }
public IncreaseStreamRetentionPeriodResult increaseStreamRetentionPeriod ( IncreaseStreamRetentionPeriodRequest request ) { request = beforeClientExecution ( request ) ; return executeIncreaseStreamRetentionPeriod ( request ) ; }
public void writeFloat ( float value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeFloat ( value ) ; }
public Collection < Cell > getSubCells ( ) { String [ ] hashes = GeohashUtils . getSubGeohashes ( getGeohash ( ) ) ; List < Cell > cells = new ArrayList <> ( hashes . length ) ; for ( String hash : hashes ) { cells . add ( new GhCell ( hash ) ) ; } return cells ; }
public StringBuilder insert ( int offset , CharSequence s ) { insert0 ( offset , s == null ? " null " : s . toString ( ) ) ; return this ; }
public static Collection < ParseTree > findAllTokenNodes ( ParseTree t , int ttype ) { return findAllNodes ( t , ttype , true ) ; }
public NameIdentifier ( String name , boolean isQuoted ) { _name = name ; _isQuoted = isQuoted ; }
public ObjectLoader open ( DiffEntry . Side side , DiffEntry ent ) throws IOException { switch ( side ) { case OLD : return oldSource . open ( ent . oldPath , ent . oldId . toObjectId ( ) ) ; case NEW : return newSource . open ( ent . newPath , ent . newId . toObjectId ( ) ) ; default : throw new IllegalArgumentException ( ) ; } }
public DBClusterSnapshot createDBClusterSnapshot ( CreateDBClusterSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBClusterSnapshot ( request ) ; }
public ExternalBookBlock ( String url , String [ ] sheetNames ) { _externalBookRecord = SupBookRecord . createExternalReferences ( url , sheetNames ) ; _crnBlocks = new CRNBlock [ 0 ] ; }
public static int compareWithCase ( String a , String b ) { for ( int i = 0 ; i < a . length ( ) && i < b . length ( ) ; i ++ ) { int d = a . charAt ( i ) - b . charAt ( i ) ; if ( d != 0 ) return d ; } return a . length ( ) - b . length ( ) ; }
public RecallPoint [ ] getRecallPoints ( ) { return recallPoints . toArray ( new RecallPoint [ 0 ] ) ; }
public RemoveFacePhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " RemoveFacePhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public static IntsRef toUTF32 ( char [ ] s , int offset , int length , IntsRefBuilder scratch ) { int charIdx = offset ; int intIdx = 0 ; final int charLimit = offset + length ; while ( charIdx < charLimit ) { scratch . grow ( intIdx + 1 ) ; final int utf32 = Character . codePointAt ( s , charIdx , charLimit ) ; scratch . setIntAt ( intIdx , utf32 ) ; charIdx += Character . charCount ( utf32 ) ; intIdx ++ ; } scratch . setLength ( intIdx ) ; return scratch . get ( ) ; }
public void skipBytes ( long count ) { pos -= count ; }
public void addDataValidation ( DVRecord dvRecord ) { _validationList . add ( dvRecord ) ; _headerRec . setDVRecNo ( _validationList . size ( ) ) ; }
public void setDoubleValue ( double value ) { if ( ! ( fieldsData instanceof Double ) ) { throw new IllegalArgumentException ( " cannot ▁ change ▁ value ▁ type ▁ from ▁ " + fieldsData . getClass ( ) . getSimpleName ( ) + " ▁ to ▁ Double " ) ; } fieldsData = Double . valueOf ( value ) ; }
public DeleteRepoAuthorizationRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " DeleteRepoAuthorization " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / authorizations / [ AuthorizeId ] " ) ; setMethod ( MethodType . DELETE ) ; }
public final void writeObject ( Object object ) throws IOException { writeObject ( object , false ) ; }
public String toString ( ) { byte [ ] raw = toByteArray ( ) ; CanonicalTreeParser p = new CanonicalTreeParser ( ) ; p . reset ( raw ) ; StringBuilder r = new StringBuilder ( ) ; r . append ( " Tree = { " ) ; if ( ! p . eof ( ) ) { r . append ( ' \ n ' ) ; try { new ObjectChecker ( ) . checkTree ( raw ) ; } catch ( CorruptObjectException error ) { r . append ( " *** ▁ ERROR : ▁ " ) . append ( error . getMessage ( ) ) . append ( " \ n " ) ; r . append ( ' \ n ' ) ; } } while ( ! p . eof ( ) ) { final FileMode mode = p . getEntryFileMode ( ) ; r . append ( mode ) ; r . append ( ' ▁ ' ) ; r . append ( Constants . typeString ( mode . getObjectType ( ) ) ) ; r . append ( ' ▁ ' ) ; r . append ( p . getEntryObjectId ( ) . name ( ) ) ; r . append ( ' ▁ ' ) ; r . append ( p . getEntryPathString ( ) ) ; r . append ( ' \ n ' ) ; p . next ( ) ; } r . append ( " } " ) ; return r . toString ( ) ; }
public char getChar ( int index ) { return ( char ) getShort ( index ) ; }
public String toString ( ) { return " I ( ne ) " ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ GUTS ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . leftgutter ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getLeftRowGutter ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . topgutter ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getTopColGutter ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rowlevelmax ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getRowLevelMax ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . collevelmax ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getColLevelMax ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / GUTS ] \ n " ) ; return buffer . toString ( ) ; }
public ParseTree getChild ( int i ) { return null ; }
public ListInvalidationsResult listInvalidations ( ListInvalidationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListInvalidations ( request ) ; }
public TokenStream newSinkTokenStream ( ) { return new SinkTokenStream ( this . cloneAttributes ( ) , cachedStates ) ; }
public PrecedencePredicate ( int precedence ) { this . precedence = precedence ; }
public ReadPresetResult readPreset ( ReadPresetRequest request ) { request = beforeClientExecution ( request ) ; return executeReadPreset ( request ) ; }
public File getIndexFile ( ) throws NoWorkTreeException { if ( isBare ( ) ) throw new NoWorkTreeException ( ) ; return indexFile ; }
public ListApplicationsResult listApplications ( ListApplicationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListApplications ( request ) ; }
public DataValidationConstraint createNumericConstraint ( int validationType , int operatorType , String formula1 , String formula2 ) { return DVConstraint . createNumericConstraint ( validationType , operatorType , formula1 , formula2 ) ; }
public int read ( byte [ ] buffer ) throws IOException { return read ( buffer , 0 , buffer . length ) ; }
public String toFormulaString ( ) { return _value ? " TRUE " : " FALSE " ; }
public void write ( char [ ] chars , int offset , int count ) { Arrays . checkOffsetAndCount ( chars . length , offset , count ) ; if ( count == 0 ) { return ; } buf . append ( chars , offset , count ) ; }
public void ReInit ( CharStream stream ) { token_source . ReInit ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public RevokeDBSecurityGroupIngressRequest ( String dBSecurityGroupName ) { setDBSecurityGroupName ( dBSecurityGroupName ) ; }
public InitiateDocumentVersionUploadResult initiateDocumentVersionUpload ( InitiateDocumentVersionUploadRequest request ) { request = beforeClientExecution ( request ) ; return executeInitiateDocumentVersionUpload ( request ) ; }
public MemAreaPtg ( int subexLen ) { field_1_reserved = 0 ; field_2_subex_len = subexLen ; }
public FtrHeader ( ) { associatedRange = new CellRangeAddress ( 0 , 0 , 0 , 0 ) ; }
public IntBuffer compact ( ) { if ( byteBuffer . isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } byteBuffer . limit ( limit * SizeOf . INT ) ; byteBuffer . position ( position * SizeOf . INT ) ; byteBuffer . compact ( ) ; byteBuffer . clear ( ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public String getRawAuthority ( ) { return authority ; }
public void write ( byte [ ] b , int off , int len ) throws IOException { if ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == 0 ) { return ; } do { createBlockIfNeeded ( ) ; int writeBytes = Math . min ( buffer . remaining ( ) , len ) ; buffer . put ( b , off , writeBytes ) ; off += writeBytes ; len -= writeBytes ; } while ( len > 0 ) ; }
public static void validateSimple ( String s , String legal ) throws URISyntaxException { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( ! ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) || ( ch >= ' 0 ' && ch <= ' 9 ' ) || legal . indexOf ( ch ) > - 1 ) ) { throw new URISyntaxException ( s , " Illegal ▁ character " , i ) ; } } }
public static String readUnicodeString ( LittleEndianInput in ) { int nChars = in . readUShort ( ) ; byte flag = in . readByte ( ) ; if ( ( flag & 0x01 ) == 0 ) { return readCompressedUnicode ( in , nChars ) ; } return readUnicodeLE ( in , nChars ) ; }
public DocValuesOrdinalsReader ( String field ) { this . field = field ; }
public AdvertiseByoipCidrResult advertiseByoipCidr ( AdvertiseByoipCidrRequest request ) { request = beforeClientExecution ( request ) ; return executeAdvertiseByoipCidr ( request ) ; }
public DescribeAlarmsResult describeAlarms ( ) { return describeAlarms ( new DescribeAlarmsRequest ( ) ) ; }
public DescribeCrossAccountAccessRoleResult describeCrossAccountAccessRole ( DescribeCrossAccountAccessRoleRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCrossAccountAccessRole ( request ) ; }
public StringBuilder reverse ( ) { reverse0 ( ) ; return this ; }
public DescribeImagesResult describeImages ( DescribeImagesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeImages ( request ) ; }
public CreateDhcpOptionsRequest ( java . util . List < DhcpConfiguration > dhcpConfigurations ) { setDhcpConfigurations ( dhcpConfigurations ) ; }
public StartChatContactResult startChatContact ( StartChatContactRequest request ) { request = beforeClientExecution ( request ) ; return executeStartChatContact ( request ) ; }
public GetCampaignsResult getCampaigns ( GetCampaignsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCampaigns ( request ) ; }
public GetAssessmentReportResult getAssessmentReport ( GetAssessmentReportRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAssessmentReport ( request ) ; }
public void reportAmbiguity ( Parser recognizer , DFA dfa , int startIndex , int stopIndex , boolean exact , BitSet ambigAlts , ATNConfigSet configs ) { if ( exactOnly && ! exact ) { return ; } String format = " reportAmbiguity ▁ d =% s : ▁ ambigAlts =% s , ▁ input = ' % s ' " ; String decision = getDecisionDescription ( recognizer , dfa ) ; BitSet conflictingAlts = getConflictingAlts ( ambigAlts , configs ) ; String text = recognizer . getTokenStream ( ) . getText ( Interval . of ( startIndex , stopIndex ) ) ; String message = String . format ( format , decision , conflictingAlts , text ) ; recognizer . notifyErrorListeners ( message ) ; }
public Object [ ] toArray ( ) { synchronized ( Hashtable . this ) { return super . toArray ( ) ; } }
public boolean contains ( Object o ) { if ( o instanceof RevFlag ) return ( mask & ( ( RevFlag ) o ) . mask ) != 0 ; return false ; }
public DisableAlarmActionsResult disableAlarmActions ( DisableAlarmActionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableAlarmActions ( request ) ; }
public RegisterDBProxyTargetsResult registerDBProxyTargets ( RegisterDBProxyTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterDBProxyTargets ( request ) ; }
public static void fill ( byte [ ] array , int start , int end , byte value ) { Arrays . checkStartAndEnd ( array . length , start , end ) ; for ( int i = start ; i < end ; i ++ ) { array [ i ] = value ; } }
public boolean containsColumn ( int columnIndex ) { return _firstCol <= columnIndex && columnIndex <= _lastCol ; }
public Hashtable ( ) { table = ( HashtableEntry < K , V > [ ] ) EMPTY_TABLE ; threshold = - 1 ; }
public final AttributeFactory getAttributeFactory ( ) { return this . factory ; }
public void onChange ( boolean selfChange ) { refreshData ( ) ; }
public ListObjectAttributesResult listObjectAttributes ( ListObjectAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeListObjectAttributes ( request ) ; }
public GetDeploymentsResult getDeployments ( GetDeploymentsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDeployments ( request ) ; }
public ListWorkGroupsResult listWorkGroups ( ListWorkGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListWorkGroups ( request ) ; }
public CreatePhotoStoreRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " CreatePhotoStore " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public PutMethodResult putMethod ( PutMethodRequest request ) { request = beforeClientExecution ( request ) ; return executePutMethod ( request ) ; }
public DescribeServiceAccessPoliciesResult describeServiceAccessPolicies ( DescribeServiceAccessPoliciesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeServiceAccessPolicies ( request ) ; }
public DescribeCacheParameterGroupsResult describeCacheParameterGroups ( ) { return describeCacheParameterGroups ( new DescribeCacheParameterGroupsRequest ( ) ) ; }
public Float getAndIncrement ( String key ) { String key2 = key . trim ( ) . toLowerCase ( locale ) ; TSTNode node = getNode ( key2 ) ; if ( node == null ) { return null ; } Float aux = ( Float ) ( node . data ) ; if ( aux == null ) { aux = 1f ; } else { aux = ( float ) ( aux . intValue ( ) + 1 ) ; } put ( key2 , aux ) ; return aux ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ WINDOWPROTECT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . options ▁ = ▁ " ) . append ( HexDump . shortToHex ( _options ) ) . append ( " \ n " ) ; buffer . append ( " [ / WINDOWPROTECT ] \ n " ) ; return buffer . toString ( ) ; }
public RetrieveDomainAuthCodeResult retrieveDomainAuthCode ( RetrieveDomainAuthCodeRequest request ) { request = beforeClientExecution ( request ) ; return executeRetrieveDomainAuthCode ( request ) ; }
public GetRelationalDatabaseMetricDataResult getRelationalDatabaseMetricData ( GetRelationalDatabaseMetricDataRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabaseMetricData ( request ) ; }
public Entry < K , V > pollFirstEntry ( ) { Node < K , V > result = endpoint ( true ) ; if ( result != null ) { removeInternal ( result ) ; } return immutableCopy ( result ) ; }
public LimitTokenPositionFilter ( TokenStream in , int maxTokenPosition , boolean consumeAllTokens ) { super ( in ) ; if ( maxTokenPosition < 1 ) { throw new IllegalArgumentException ( " maxTokenPosition ▁ must ▁ be ▁ greater ▁ than ▁ zero " ) ; } this . maxTokenPosition = maxTokenPosition ; this . consumeAllTokens = consumeAllTokens ; }
public ViewFieldsRecord ( RecordInputStream in ) { _sxaxis = in . readShort ( ) ; _cSub = in . readShort ( ) ; _grbitSub = in . readShort ( ) ; _cItm = in . readShort ( ) ; int cchName = in . readUShort ( ) ; if ( cchName != STRING_NOT_PRESENT_LEN ) { int flag = in . readByte ( ) ; if ( ( flag & 0x01 ) != 0 ) { _name = in . readUnicodeLEString ( cchName ) ; } else { _name = in . readCompressedUnicode ( cchName ) ; } } }
public synchronized static DefaultProfile getProfile ( String regionId , String accessKeyId , String secret ) { Credential creden = new Credential ( accessKeyId , secret ) ; profile = new DefaultProfile ( regionId , creden ) ; return profile ; }
public int indexOf ( String string ) { return indexOf ( string , 0 ) ; }
public ListAppsResult listApps ( ListAppsRequest request ) { request = beforeClientExecution ( request ) ; return executeListApps ( request ) ; }
public ListAttachedIndicesResult listAttachedIndices ( ListAttachedIndicesRequest request ) { request = beforeClientExecution ( request ) ; return executeListAttachedIndices ( request ) ; }
public void addShape ( HSSFShape shape ) { shape . setPatriarch ( this ) ; _shapes . add ( shape ) ; }
public CreateNatGatewayResult createNatGateway ( CreateNatGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNatGateway ( request ) ; }
public GetApnsVoipChannelResult getApnsVoipChannel ( GetApnsVoipChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApnsVoipChannel ( request ) ; }
public ReplaceTransitGatewayRouteResult replaceTransitGatewayRoute ( ReplaceTransitGatewayRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeReplaceTransitGatewayRoute ( request ) ; }
public long ramBytesUsed ( ) { return super . ramBytesUsed ( ) + offsets . ramBytesUsed ( ) + lengths . ramBytesUsed ( ) + RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + 2 * Integer . BYTES + 3 * RamUsageEstimator . NUM_BYTES_OBJECT_REF + values . bytes ( ) . length ; }
public ParseTreePattern compile ( String pattern , int patternRuleIndex ) { List <? extends Token > tokenList = tokenize ( pattern ) ; ListTokenSource tokenSrc = new ListTokenSource ( tokenList ) ; CommonTokenStream tokens = new CommonTokenStream ( tokenSrc ) ; ParserInterpreter parserInterp = new ParserInterpreter ( parser . getGrammarFileName ( ) , parser . getVocabulary ( ) , Arrays . asList ( parser . getRuleNames ( ) ) , parser . getATNWithBypassAlts ( ) , tokens ) ; ParseTree tree = null ; try { parserInterp . setErrorHandler ( new BailErrorStrategy ( ) ) ; tree = parserInterp . parse ( patternRuleIndex ) ; } catch ( ParseCancellationException e ) { throw ( RecognitionException ) e . getCause ( ) ; } catch ( RecognitionException re ) { throw re ; } catch ( Exception e ) { throw new CannotInvokeStartRule ( e ) ; } if ( tokens . LA ( 1 ) != Token . EOF ) { throw new StartRuleDoesNotConsumeFullPattern ( ) ; } return new ParseTreePattern ( this , pattern , patternRuleIndex , tree ) ; }
public GetRelationalDatabaseLogEventsResult getRelationalDatabaseLogEvents ( GetRelationalDatabaseLogEventsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabaseLogEvents ( request ) ; }
public TokenStream create ( TokenStream input ) { return new BeiderMorseFilter ( input , engine , languageSet ) ; }
public FloatBuffer duplicate ( ) { return copy ( this , mark ) ; }
public ClasspathResourceLoader ( Class <?> clazz ) { this ( clazz , clazz . getClassLoader ( ) ) ; }
public DescribeRouteTablesResult describeRouteTables ( DescribeRouteTablesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeRouteTables ( request ) ; }
public void setRenameCallback ( RenameCallback callback ) { renameCallback = callback ; }
public DimensionsRecord createDimensions ( ) { DimensionsRecord result = new DimensionsRecord ( ) ; result . setFirstRow ( _firstrow ) ; result . setLastRow ( _lastrow ) ; result . setFirstCol ( ( short ) _valuesAgg . getFirstCellNum ( ) ) ; result . setLastCol ( ( short ) _valuesAgg . getLastCellNum ( ) ) ; return result ; }
public StopTransformJobResult stopTransformJob ( StopTransformJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopTransformJob ( request ) ; }
public final String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + getStringValue ( ) + " ] " ; }
public QueryAuthenticationRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " QueryAuthentication " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public PrintStream append ( char c ) { print ( c ) ; return this ; }
public StartKeyPhrasesDetectionJobResult startKeyPhrasesDetectionJob ( StartKeyPhrasesDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStartKeyPhrasesDetectionJob ( request ) ; }
public QueryPhraseMap searchPhrase ( final List < TermInfo > phraseCandidate ) { QueryPhraseMap currMap = this ; for ( TermInfo ti : phraseCandidate ) { currMap = currMap . subMap . get ( ti . getText ( ) ) ; if ( currMap == null ) return null ; } return currMap . isValidTermOrPhrase ( phraseCandidate ) ? currMap : null ; }
public void add ( Term term ) { if ( term == null ) { throw new IllegalArgumentException ( " Term ▁ must ▁ not ▁ be ▁ null " ) ; } this . terms . add ( term ) ; }
public ListEmailIdentitiesResult listEmailIdentities ( ListEmailIdentitiesRequest request ) { request = beforeClientExecution ( request ) ; return executeListEmailIdentities ( request ) ; }
public MutableFPNumber ( BigInteger frac , int binaryExponent ) { _significand = frac ; _binaryExponent = binaryExponent ; }
public CreateNetworkProfileResult createNetworkProfile ( CreateNetworkProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNetworkProfile ( request ) ; }
public Transition removeTransition ( int index ) { return transitions . remove ( index ) ; }
public int doLogic ( ) throws Exception { final PerfRunData runData = getRunData ( ) ; IndexWriter w = runData . getIndexWriter ( ) ; if ( w == null ) { throw new RuntimeException ( " please ▁ open ▁ the ▁ writer ▁ before ▁ invoking ▁ NearRealtimeReader " ) ; } if ( runData . getIndexReader ( ) != null ) { throw new RuntimeException ( " please ▁ close ▁ the ▁ existing ▁ reader ▁ before ▁ invoking ▁ NearRealtimeReader " ) ; } long t = System . currentTimeMillis ( ) ; DirectoryReader r = DirectoryReader . open ( w ) ; runData . setIndexReader ( r ) ; r . decRef ( ) ; reopenCount = 0 ; while ( ! stopNow ) { long waitForMsec = ( pauseMSec - ( System . currentTimeMillis ( ) - t ) ) ; if ( waitForMsec > 0 ) { Thread . sleep ( waitForMsec ) ; } t = System . currentTimeMillis ( ) ; final DirectoryReader newReader = DirectoryReader . openIfChanged ( r ) ; if ( newReader != null ) { final int delay = ( int ) ( System . currentTimeMillis ( ) - t ) ; if ( reopenTimes . length == reopenCount ) { reopenTimes = ArrayUtil . grow ( reopenTimes , 1 + reopenCount ) ; } reopenTimes [ reopenCount ++ ] = delay ; runData . setIndexReader ( newReader ) ; newReader . decRef ( ) ; r = newReader ; } } stopNow = false ; return reopenCount ; }
public PutAttributesResult putAttributes ( PutAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executePutAttributes ( request ) ; }
public DeleteLocalGatewayRouteTableVpcAssociationResult deleteLocalGatewayRouteTableVpcAssociation ( DeleteLocalGatewayRouteTableVpcAssociationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLocalGatewayRouteTableVpcAssociation ( request ) ; }
public TreeFilter clone ( ) { return this ; }
public static TreeFilter create ( TreeFilter [ ] list ) { if ( list . length == 2 ) return create ( list [ 0 ] , list [ 1 ] ) ; if ( list . length < 2 ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastTwoFiltersNeeded ) ; final TreeFilter [ ] subfilters = new TreeFilter [ list . length ] ; System . arraycopy ( list , 0 , subfilters , 0 , list . length ) ; return new List ( subfilters ) ; }
public void back ( int delta ) { while ( -- delta >= 0 ) { if ( currentSubtree != null ) nextSubtreePos -- ; ptr -- ; parseEntry ( false ) ; if ( currentSubtree != null ) ptr -= currentSubtree . getEntrySpan ( ) - 1 ; } }
public Map < String , SubmoduleStatus > call ( ) throws GitAPIException { checkCallable ( ) ; try ( SubmoduleWalk generator = SubmoduleWalk . forIndex ( repo ) ) { if ( ! paths . isEmpty ( ) ) generator . setFilter ( PathFilterGroup . createFromStrings ( paths ) ) ; Map < String , SubmoduleStatus > statuses = new HashMap <> ( ) ; while ( generator . next ( ) ) { SubmoduleStatus status = getStatus ( generator ) ; statuses . put ( status . getPath ( ) , status ) ; } return statuses ; } catch ( IOException | ConfigInvalidException e ) { throw new JGitInternalException ( e . getMessage ( ) , e ) ; } }
public synchronized int available ( ) { return count - pos ; }
public SmallStream ( int type , byte [ ] data ) { this . type = type ; this . data = data ; }
public String escapeExtensionField ( String extfield ) { return QueryParserBase . escape ( extfield ) ; }
public QueryScorer ( Query query ) { init ( query , null , null , true ) ; }
public int getHighIx ( ) { return _highIx ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ VCENTER ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . vcenter ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getVCenter ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / VCENTER ] \ n " ) ; return buffer . toString ( ) ; }
public int size ( ) { return _limit ; }
public PredictCategoryRequest ( ) { super ( " visionai - poc " , " 2020 - 04 - 08 " , " PredictCategory " ) ; setMethod ( MethodType . POST ) ; }
public DeleteLagResult deleteLag ( DeleteLagRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLag ( request ) ; }
public boolean equals ( Object other ) { if ( ! ( other instanceof LongBuffer ) ) { return false ; } LongBuffer otherBuffer = ( LongBuffer ) other ; if ( remaining ( ) != otherBuffer . remaining ( ) ) { return false ; } int myPosition = position ; int otherPosition = otherBuffer . position ; boolean equalSoFar = true ; while ( equalSoFar && ( myPosition < limit ) ) { equalSoFar = get ( myPosition ++ ) == otherBuffer . get ( otherPosition ++ ) ; } return equalSoFar ; }
public void end ( ) { state . end ( ) ; }
public BooleanMatcher ( boolean value , CmpOp operator ) { super ( operator ) ; _value = boolToInt ( value ) ; }
public SheetVector ( RefEval re ) { _size = re . getNumberOfSheets ( ) ; _re = re ; }
public UpdateGameSessionResult updateGameSession ( UpdateGameSessionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateGameSession ( request ) ; }
public String getName ( ) { return String . format ( Locale . ROOT , " Dirichlet ( % f ) " , getMu ( ) ) ; }
public void decompress ( DataInput in , int originalLength , int offset , int length , BytesRef bytes ) throws IOException { assert offset + length <= originalLength ; if ( length == 0 ) { bytes . length = 0 ; return ; } final int compressedLength = in . readVInt ( ) ; final int paddedLength = compressedLength + 1 ; compressed = ArrayUtil . grow ( compressed , paddedLength ) ; in . readBytes ( compressed , 0 , compressedLength ) ; compressed [ compressedLength ] = 0 ; final Inflater decompressor = new Inflater ( true ) ; try { decompressor . setInput ( compressed , 0 , paddedLength ) ; bytes . offset = bytes . length = 0 ; bytes . bytes = ArrayUtil . grow ( bytes . bytes , originalLength ) ; try { bytes . length = decompressor . inflate ( bytes . bytes , bytes . length , originalLength ) ; } catch ( DataFormatException e ) { throw new IOException ( e ) ; } if ( ! decompressor . finished ( ) ) { throw new CorruptIndexException ( " Invalid ▁ decoder ▁ state : ▁ needsInput = " + decompressor . needsInput ( ) + " , ▁ needsDict = " + decompressor . needsDictionary ( ) , in ) ; } } finally { decompressor . end ( ) ; } if ( bytes . length != originalLength ) { throw new CorruptIndexException ( " Lengths ▁ mismatch : ▁ " + bytes . length + " ▁ != ▁ " + originalLength , in ) ; } bytes . offset = offset ; bytes . length = length ; }
public Pair < String , String > splitExtensionField ( String defaultField , String field ) { int indexOf = field . indexOf ( this . extensionFieldDelimiter ) ; if ( indexOf < 0 ) return new Pair <> ( field , null ) ; final String indexField = indexOf == 0 ? defaultField : field . substring ( 0 , indexOf ) ; final String extensionKey = field . substring ( indexOf + 1 ) ; return new Pair <> ( indexField , extensionKey ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ FRAME ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . borderType ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getBorderType ( ) ) ) . append ( " ▁ ( " ) . append ( getBorderType ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " ▁ ▁ ▁ ▁ . options ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getOptions ( ) ) ) . append ( " ▁ ( " ) . append ( getOptions ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . autoSize ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( isAutoSize ( ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . autoPosition ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( isAutoPosition ( ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / FRAME ] \ n " ) ; return buffer . toString ( ) ; }
public Cluster pauseCluster ( PauseClusterRequest request ) { request = beforeClientExecution ( request ) ; return executePauseCluster ( request ) ; }
public void setValue ( String newValue ) { value = newValue ; }
public AllocateAddressResult allocateAddress ( AllocateAddressRequest request ) { request = beforeClientExecution ( request ) ; return executeAllocateAddress ( request ) ; }
public GetNetworkProfileResult getNetworkProfile ( GetNetworkProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeGetNetworkProfile ( request ) ; }
public static void reThrow ( Throwable th ) throws IOException { if ( th != null ) { throw rethrowAlways ( th ) ; } }
public void removeCell ( CellValueRecordInterface cvRec ) { if ( cvRec instanceof FormulaRecordAggregate ) { ( ( FormulaRecordAggregate ) cvRec ) . notifyFormulaChanging ( ) ; } _valuesAgg . removeCell ( cvRec ) ; }
public Snapshot createSnapshot ( CreateSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSnapshot ( request ) ; }
public Token get ( int i ) { if ( i < 0 || i >= tokens . size ( ) ) { throw new IndexOutOfBoundsException ( " token ▁ index ▁ " + i + " ▁ out ▁ of ▁ range ▁ 0.. " + ( tokens . size ( ) - 1 ) ) ; } return tokens . get ( i ) ; }
public DescribeAlarmsResult describeAlarms ( DescribeAlarmsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAlarms ( request ) ; }
public static long [ ] grow ( long [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Long . BYTES ) ) ; } else return array ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = 8 ; LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; LittleEndian . putInt ( data , offset + 8 , field_1_shapeId ) ; LittleEndian . putInt ( data , offset + 12 , field_2_flags ) ; listener . afterRecordSerialize ( offset + getRecordSize ( ) , getRecordId ( ) , getRecordSize ( ) , this ) ; return 8 + 8 ; }
public LsRemoteCommand setTags ( boolean tags ) { this . tags = tags ; return this ; }
public ASCIIFoldingFilterFactory ( Map < String , String > args ) { super ( args ) ; preserveOriginal = getBoolean ( args , PRESERVE_ORIGINAL , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public String toString ( ) { return " input = " + input . get ( ) + " ▁ output = " + output + " ▁ context = " + context + " ▁ boost = " + boost + " ▁ payload = " + payload ; }
public ListNotesCommand setNotesRef ( String notesRef ) { checkCallable ( ) ; this . notesRef = notesRef ; return this ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SXVD ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . sxaxis ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( _sxaxis ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . cSub ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( _cSub ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbitSub ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( _grbitSub ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . cItm ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( _cItm ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . name ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( _name ) . append ( ' \ n ' ) ; buffer . append ( " [ / SXVD ] \ n " ) ; return buffer . toString ( ) ; }
public V get ( Object o ) { if ( o == null ) throw new NullPointerException ( ) ; return null ; }
public String toString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ NAMECMT ] \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . record ▁ type ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( field_1_record_type ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . frt ▁ cell ▁ ref ▁ flag ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . byteToHex ( field_2_frt_cell_ref_flag ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . reserved ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( field_3_reserved ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . name ▁ length ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( field_6_name_text . length ( ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . comment ▁ length ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( field_7_comment_text . length ( ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . name ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( field_6_name_text ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . comment ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( field_7_comment_text ) . append ( " \ n " ) ; sb . append ( " [ / NAMECMT ] \ n " ) ; return sb . toString ( ) ; }
public CodepointCountFilterFactory ( Map < String , String > args ) { super ( args ) ; min = requireInt ( args , MIN_KEY ) ; max = requireInt ( args , MAX_KEY ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public Entry < K , V > ceilingEntry ( K key ) { return immutableCopy ( findBounded ( key , CEILING ) ) ; }
public long setStartTimeMillis ( ) { startTimeMillis = System . currentTimeMillis ( ) ; return startTimeMillis ; }
public ListProfilingGroupsResult listProfilingGroups ( ListProfilingGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListProfilingGroups ( request ) ; }
public static PersonIdent parsePersonIdent ( String in ) { return parsePersonIdent ( Constants . encode ( in ) , 0 ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_numerator ) ; out . writeShort ( field_2_denominator ) ; }
public AddCommand setUpdate ( boolean update ) { this . update = update ; return this ; }
public static < T > T [ ] copyOf ( T [ ] original , int newLength ) { if ( original == null ) { throw new NullPointerException ( ) ; } if ( newLength < 0 ) { throw new NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; }
public void writeByte ( int v ) { writeContinueIfRequired ( 1 ) ; _ulrOutput . writeByte ( v ) ; }
public DeleteDBInstanceRequest ( String dBInstanceIdentifier ) { setDBInstanceIdentifier ( dBInstanceIdentifier ) ; }
public void reset ( ) { previousValue = value = minValue ; }
public void setLength ( long sz ) { setLength ( ( int ) sz ) ; }
public static String revisionVersion ( IndexCommit indexCommit , IndexCommit taxoCommit ) { return Long . toString ( indexCommit . getGeneration ( ) , RADIX ) + " : " + Long . toString ( taxoCommit . getGeneration ( ) , RADIX ) ; }
public String pattern ( ) { return needleString ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SST ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . numstrings ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getNumStrings ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . uniquestrings ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getNumUniqueStrings ( ) ) ) . append ( " \ n " ) ; for ( int k = 0 ; k < field_3_strings . size ( ) ; k ++ ) { UnicodeString s = field_3_strings . get ( k ) ; buffer . append ( " ▁ ▁ ▁ ▁ . string □ " ) . append ( k ) . append ( " ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( s . getDebugInfo ( ) ) . append ( " \ n " ) ; } buffer . append ( " [ / SST ] \ n " ) ; return buffer . toString ( ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " " ; StringBuilder sb = new StringBuilder ( ) ; String filler = " " ; for ( Iterator < QueryNode > it = getChildren ( ) . iterator ( ) ; it . hasNext ( ) ; ) { sb . append ( filler ) . append ( it . next ( ) . toQueryString ( escapeSyntaxParser ) ) ; filler = " ▁ OR ▁ " ; } if ( ( getParent ( ) != null && getParent ( ) instanceof GroupQueryNode ) || isRoot ( ) ) return sb . toString ( ) ; else return " ( ▁ " + sb . toString ( ) + " ▁ ) " ; }
public PushCommand setReceivePack ( String receivePack ) { checkCallable ( ) ; this . receivePack = receivePack ; return this ; }
public DeleteImagePermissionsResult deleteImagePermissions ( DeleteImagePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteImagePermissions ( request ) ; }
public static Ptg [ ] getTokens ( Formula formula ) { if ( formula == null ) { return null ; } return formula . getTokens ( ) ; }
public void skipToNextByte ( ) { remainingBits = 0 ; }
public GetJourneyExecutionActivityMetricsResult getJourneyExecutionActivityMetrics ( GetJourneyExecutionActivityMetricsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetJourneyExecutionActivityMetrics ( request ) ; }
public DeregisterContainerInstanceResult deregisterContainerInstance ( DeregisterContainerInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterContainerInstance ( request ) ; }
public DeleteEntityRecognizerResult deleteEntityRecognizer ( DeleteEntityRecognizerRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEntityRecognizer ( request ) ; }
public DescribeGameSessionsResult describeGameSessions ( DescribeGameSessionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeGameSessions ( request ) ; }
public SegToken ( char [ ] idArray , int start , int end , int wordType , int weight ) { this . charArray = idArray ; this . startOffset = start ; this . endOffset = end ; this . wordType = wordType ; this . weight = weight ; }
public int compareTo ( TermInfo o ) { return ( this . position - o . position ) ; }
public TagMeetingResult tagMeeting ( TagMeetingRequest request ) { request = beforeClientExecution ( request ) ; return executeTagMeeting ( request ) ; }
public final Buffer limit ( int newLimit ) { limitImpl ( newLimit ) ; return this ; }
public final DoubleValuesSource makeRecipDistanceValueSource ( Shape queryShape ) { Rectangle bbox = queryShape . getBoundingBox ( ) ; double diagonalDist = ctx . getDistCalc ( ) . distance ( ctx . makePoint ( bbox . getMinX ( ) , bbox . getMinY ( ) ) , bbox . getMaxX ( ) , bbox . getMaxY ( ) ) ; double distToEdge = diagonalDist * 0.5 ; float c = ( float ) distToEdge * 0.1f ; DoubleValuesSource distance = makeDistanceValueSource ( queryShape . getCenter ( ) , 1.0 ) ; return new ReciprocalDoubleValuesSource ( c , distance ) ; }
public GetLoginProfileRequest ( String userName ) { setUserName ( userName ) ; }
public int serializeComplexPart ( byte [ ] data , int pos ) { return 0 ; }
public DBCellRecord ( int rowOffset , short [ ] cellOffsets ) { field_1_row_offset = rowOffset ; field_2_cell_offsets = cellOffsets ; }
public StoredField ( String name , long value ) { super ( name , TYPE ) ; fieldsData = value ; }
public final Locale getLocale ( ) { return locale ; }
public SpanNotBuilder ( SpanQueryBuilder factory ) { this . factory = factory ; }
public String toString ( ) { return toString ( 0 ) ; }
public int compareTo ( ExtRst o ) { int result ; result = reserved - o . reserved ; if ( result != 0 ) { return result ; } result = formattingFontIndex - o . formattingFontIndex ; if ( result != 0 ) { return result ; } result = formattingOptions - o . formattingOptions ; if ( result != 0 ) { return result ; } result = numberOfRuns - o . numberOfRuns ; if ( result != 0 ) { return result ; } result = phoneticText . compareTo ( o . phoneticText ) ; if ( result != 0 ) { return result ; } result = phRuns . length - o . phRuns . length ; if ( result != 0 ) { return result ; } for ( int i = 0 ; i < phRuns . length ; i ++ ) { result = phRuns [ i ] . phoneticTextFirstCharacterOffset - o . phRuns [ i ] . phoneticTextFirstCharacterOffset ; if ( result != 0 ) { return result ; } result = phRuns [ i ] . realTextFirstCharacterOffset - o . phRuns [ i ] . realTextFirstCharacterOffset ; if ( result != 0 ) { return result ; } result = phRuns [ i ] . realTextLength - o . phRuns [ i ] . realTextLength ; if ( result != 0 ) { return result ; } } result = Arrays . hashCode ( extraData ) - Arrays . hashCode ( o . extraData ) ; return result ; }
public GetInstanceSnapshotsResult getInstanceSnapshots ( GetInstanceSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInstanceSnapshots ( request ) ; }
public static long [ ] grow ( long [ ] array ) { return grow ( array , 1 + array . length ) ; }
public TranslateTextResult translateText ( TranslateTextRequest request ) { request = beforeClientExecution ( request ) ; return executeTranslateText ( request ) ; }
public DimensionsRecord ( RecordInputStream in ) { field_1_first_row = in . readInt ( ) ; field_2_last_row = in . readInt ( ) ; field_3_first_col = in . readShort ( ) ; field_4_last_col = in . readShort ( ) ; field_5_zero = in . readShort ( ) ; if ( in . available ( ) == 2 ) { logger . log ( POILogger . INFO , " DimensionsRecord ▁ has ▁ extra ▁ 2 ▁ bytes . " ) ; in . readShort ( ) ; } }
public int flags ( ) { return flags ; }
public Vector ( int capacity , int capacityIncrement ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( ) ; } elementData = newElementArray ( capacity ) ; elementCount = 0 ; this . capacityIncrement = capacityIncrement ; }
public DeleteLogGroupRequest ( String logGroupName ) { setLogGroupName ( logGroupName ) ; }
public RemoveManagedScalingPolicyResult removeManagedScalingPolicy ( RemoveManagedScalingPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveManagedScalingPolicy ( request ) ; }
public GetDataRetrievalPolicyResult getDataRetrievalPolicy ( GetDataRetrievalPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDataRetrievalPolicy ( request ) ; }
public DescribeExportImageTasksResult describeExportImageTasks ( DescribeExportImageTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeExportImageTasks ( request ) ; }
public DefaultICUTokenizerConfig ( boolean cjkAsWords , boolean myanmarAsWords ) { this . cjkAsWords = cjkAsWords ; this . myanmarAsWords = myanmarAsWords ; }
public DisableAvailabilityZonesForLoadBalancerResult disableAvailabilityZonesForLoadBalancer ( DisableAvailabilityZonesForLoadBalancerRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableAvailabilityZonesForLoadBalancer ( request ) ; }
public synchronized void setIndexFieldName ( String dimName , String indexFieldName ) { DimConfig ft = fieldTypes . get ( dimName ) ; if ( ft == null ) { ft = new DimConfig ( ) ; fieldTypes . put ( dimName , ft ) ; } ft . indexFieldName = indexFieldName ; }
public BytesRef encode ( char [ ] buffer , int offset , int length ) { int payload = ArrayUtil . parseInt ( buffer , offset , length ) ; byte [ ] bytes = PayloadHelper . encodeInt ( payload ) ; BytesRef result = new BytesRef ( bytes ) ; return result ; }
public HideObjRecord ( RecordInputStream in ) { field_1_hide_obj = in . readShort ( ) ; }
public String toString ( ) { if ( isEmpty ( ) ) return " [ ] " ; StringBuilder buf = new StringBuilder ( ) ; buf . append ( " [ " ) ; for ( int i = 0 ; i < returnStates . length ; i ++ ) { if ( i > 0 ) buf . append ( " , ▁ " ) ; if ( returnStates [ i ] == EMPTY_RETURN_STATE ) { buf . append ( " $ " ) ; continue ; } buf . append ( returnStates [ i ] ) ; if ( parents [ i ] != null ) { buf . append ( ' ▁ ' ) ; buf . append ( parents [ i ] . toString ( ) ) ; } else { buf . append ( " null " ) ; } } buf . append ( " ] " ) ; return buf . toString ( ) ; }
public synchronized int getSecondaryProgress ( ) { return mIndeterminate ? 0 : mSecondaryProgress ; }
public DeleteContactMethodResult deleteContactMethod ( DeleteContactMethodRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteContactMethod ( request ) ; }
@ Override public List < E > subList ( int start , int end ) { synchronized ( mutex ) { return new SynchronizedList < E > ( list . subList ( start , end ) , mutex ) ; } }
@ Override public boolean equals ( Object object ) { return m . equals ( object ) ; }
public static String getSchemePrefix ( String spec ) { int colon = spec . indexOf ( ' : ' ) ; if ( colon < 1 ) { return null ; } for ( int i = 0 ; i < colon ; i ++ ) { char c = spec . charAt ( i ) ; if ( ! isValidSchemeChar ( i , c ) ) { return null ; } } return spec . substring ( 0 , colon ) . toLowerCase ( Locale . US ) ; }
public ByteBuffer put ( byte [ ] src , int srcOffset , int byteCount ) { throw new ReadOnlyBufferException ( ) ; }
public CreateServiceResult createService ( CreateServiceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateService ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _numberOfRegions ) ; for ( int i = 0 ; i < _numberOfRegions ; i ++ ) { _regions [ _startIndex + i ] . serialize ( out ) ; } }
public StringBuilder insert ( int offset , char c ) { insert0 ( offset , c ) ; return this ; }
public LabelSSTRecord ( RecordInputStream in ) { super ( in ) ; field_4_sst_index = in . readInt ( ) ; }
public void setObjectId ( AnyObjectId id ) { if ( objectId == null ) objectId = id . copy ( ) ; }
public int add ( CFRecordsAggregate cfAggregate ) { cfAggregate . getHeader ( ) . setID ( _cfHeaders . size ( ) ) ; _cfHeaders . add ( cfAggregate ) ; return _cfHeaders . size ( ) - 1 ; }
public TermVectorsPostingsArray ( int size ) { super ( size ) ; freqs = new int [ size ] ; lastOffsets = new int [ size ] ; lastPositions = new int [ size ] ; }
public FieldsQuery ( SrndQuery q , List < String > fieldNames , char fieldOp ) { this . q = q ; this . fieldNames = fieldNames ; this . fieldOp = fieldOp ; }
public TokenStream create ( TokenStream in ) { return new GreekLowerCaseFilter ( in ) ; }
public ECSMetadataServiceCredentialsFetcher ( ) { this . connectionTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MILLISECONDS ; }
public static Decoder getDecoder ( Format format , int version , int bitsPerValue ) { checkVersion ( version ) ; return BulkOperation . of ( format , bitsPerValue ) ; }
public synchronized void reset ( ) { nameFinder . clearAdaptiveData ( ) ; }
public String nextKeyString ( ) { return new String ( nextKey ( ) ) ; }
public DescribeEventsResult describeEvents ( ) { return describeEvents ( new DescribeEventsRequest ( ) ) ; }
public UpdateNodeResult updateNode ( UpdateNodeRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateNode ( request ) ; }
public GetJobOutputRequest ( String vaultName , String jobId , String range ) { setVaultName ( vaultName ) ; setJobId ( jobId ) ; setRange ( range ) ; }
public static String stripTags ( String buf , int start ) { if ( start > 0 ) { buf = buf . substring ( start ) ; } return buf . replaceAll ( " < [ ^> ] *> " , " ▁ " ) ; }
public DescribeLaunchTemplatesResult describeLaunchTemplates ( DescribeLaunchTemplatesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLaunchTemplates ( request ) ; }
public SynonymFilterFactory ( Map < String , String > args ) { super ( args ) ; ignoreCase = getBoolean ( args , " ignoreCase " , false ) ; synonyms = require ( args , " synonyms " ) ; format = get ( args , " format " ) ; expand = getBoolean ( args , " expand " , true ) ; analyzerName = get ( args , " analyzer " ) ; tokenizerFactory = get ( args , " tokenizerFactory " ) ; if ( analyzerName != null && tokenizerFactory != null ) { throw new IllegalArgumentException ( " Analyzer ▁ and ▁ TokenizerFactory ▁ can ' t be specified both : " ▁ + analyzerName ▁ + ▁ " and " ▁ + ▁ tokenizerFactory ) ; } if ▁ ( tokenizerFactory ▁ != ▁ null ) ▁ { tokArgs . put ( " luceneMatchVersion " , ▁ getLuceneMatchVersion ( ) . toString ( ) ) ; for ▁ ( Iterator < String > ▁ itr ▁ = ▁ args . keySet ( ) . iterator ( ) ; ▁ itr . hasNext ( ) ; ) ▁ { String ▁ key ▁ = ▁ itr . next ( ) ; tokArgs . put ( key . replaceAll ( " ^ tokenizerFactory \\ . " , " " ) , ▁ args . get ( key ) ) ; itr . remove ( ) ; } } if ▁ ( ! args . isEmpty ( ) ) ▁ { throw ▁ new ▁ IllegalArgumentException ( " Unknown parameters : " ▁ + ▁ args ) ; } }
public void removePrintArea ( int sheetIndex ) { getWorkbook ( ) . removeBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; }
public ModifyTrafficMirrorFilterNetworkServicesResult modifyTrafficMirrorFilterNetworkServices ( ModifyTrafficMirrorFilterNetworkServicesRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyTrafficMirrorFilterNetworkServices ( request ) ; }
public ValueEval evaluate ( ValueEval [ ] args , OperationEvaluationContext ec ) { if ( args . length == 2 ) { return evaluate ( ec . getRowIndex ( ) , ec . getColumnIndex ( ) , args [ 0 ] , args [ 1 ] ) ; } return ErrorEval . VALUE_INVALID ; }
public DeltaRecord ( double maxChange ) { field_1_max_change = maxChange ; }
public UpdateDomainEntryResult updateDomainEntry ( UpdateDomainEntryRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDomainEntry ( request ) ; }
public SegmentCommitInfo clone ( ) { SegmentCommitInfo other = new SegmentCommitInfo ( info , delCount , softDelCount , delGen , fieldInfosGen , docValuesGen ) ; other . nextWriteDelGen = nextWriteDelGen ; other . nextWriteFieldInfosGen = nextWriteFieldInfosGen ; other . nextWriteDocValuesGen = nextWriteDocValuesGen ; for ( Entry < Integer , Set < String >> e : dvUpdatesFiles . entrySet ( ) ) { other . dvUpdatesFiles . put ( e . getKey ( ) , new HashSet <> ( e . getValue ( ) ) ) ; } other . fieldInfosFiles . addAll ( fieldInfosFiles ) ; return other ; }
public String putAttribute ( String key , String value ) { HashMap < String , String > newMap = new HashMap <> ( attributes ) ; String oldValue = newMap . put ( key , value ) ; attributes = Collections . unmodifiableMap ( newMap ) ; return oldValue ; }
public void write ( int oneChar ) { buf . append ( ( char ) oneChar ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ WRITEPROTECT ] \ n " ) ; buffer . append ( " [ / WRITEPROTECT ] \ n " ) ; return buffer . toString ( ) ; }
public EvaluationSheet getSheet ( int sheetIndex ) { return new HSSFEvaluationSheet ( _uBook . getSheetAt ( sheetIndex ) ) ; }
public void removeSlideCount ( ) { remove1stProperty ( PropertyIDMap . PID_SLIDECOUNT ) ; }
public DescribeFlowDefinitionResult describeFlowDefinition ( DescribeFlowDefinitionRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFlowDefinition ( request ) ; }
public void set ( int index ) { intSet . put ( index ) ; if ( index > maxInt ) maxInt = index ; }
public boolean equals ( Object other ) { if ( other == null ) { return false ; } if ( other instanceof CharsRef ) { return this . charsEquals ( ( CharsRef ) other ) ; } return false ; }
public StopFilterFactory ( Map < String , String > args ) { super ( args ) ; stopWordFiles = get ( args , " words " ) ; format = get ( args , " format " , ( null == stopWordFiles ? null : FORMAT_WORDSET ) ) ; ignoreCase = getBoolean ( args , " ignoreCase " , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void addState ( ATNState state ) { if ( state != null ) { state . atn = this ; state . stateNumber = states . size ( ) ; } states . add ( state ) ; }
public String batchUrl ( ) { return this . batchUrl ; }
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 33 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 25 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } } } } for ( int i = 0 ; i < 33 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; }
@ Override public Iterator < K > iterator ( ) { return new KeyIterator ( ) ; }
public DoubleList ( ) { _array = new double [ 8 ] ; _count = 0 ; }
public AddNoteCommand setMessage ( String message ) { checkCallable ( ) ; this . message = message ; return this ; }
public SerializationHandleMap ( ) { this . size = 0 ; this . threshold = 21 ; int arraySize = ( int ) ( ( ( long ) threshold * 10000 ) / LOAD_FACTOR ) ; resizeArrays ( arraySize ) ; }
public PagedBytes ( int blockBits ) { assert blockBits > 0 && blockBits <= 31 : blockBits ; this . blockSize = 1 << blockBits ; this . blockBits = blockBits ; blockMask = blockSize - 1 ; upto = blockSize ; bytesUsedPerBlock = RamUsageEstimator . alignObjectSize ( blockSize + RamUsageEstimator . NUM_BYTES_ARRAY_HEADER ) ; numBlocks = 0 ; }
public IncreaseReplicationFactorResult increaseReplicationFactor ( IncreaseReplicationFactorRequest request ) { request = beforeClientExecution ( request ) ; return executeIncreaseReplicationFactor ( request ) ; }
public UpdateRuntimeConfigurationResult updateRuntimeConfiguration ( UpdateRuntimeConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRuntimeConfiguration ( request ) ; }
public char getChar ( Map < String , String > args , String name , char defaultValue ) { String s = args . remove ( name ) ; if ( s == null ) { return defaultValue ; } else { if ( s . length ( ) != 1 ) { throw new IllegalArgumentException ( name + " ▁ should ▁ be ▁ a ▁ char . ▁ \ " " + s + " \ " ▁ is ▁ invalid " ) ; } else { return s . charAt ( 0 ) ; } } }
public void notifyListeners ( LexerNoViableAltException e ) { String text = _input . getText ( Interval . of ( _tokenStartCharIndex , _input . index ( ) ) ) ; String msg = " token ▁ recognition ▁ error ▁ at : ▁ ' " + ▁ getErrorDisplay ( text ) ▁ + ▁ " ' " ; ANTLRErrorListener listener = getErrorListenerDispatch ( ) ; listener . syntaxError ( this , null , _tokenStartLine , _tokenStartCharPositionInLine , msg , e ) ; }
public void writeLong ( long v ) { writeContinueIfRequired ( 8 ) ; _ulrOutput . writeLong ( v ) ; }
public ChangeMessageVisibilityBatchRequest ( String queueUrl , java . util . List < ChangeMessageVisibilityBatchRequestEntry > entries ) { setQueueUrl ( queueUrl ) ; setEntries ( entries ) ; }
public GetExportJobResult getExportJob ( GetExportJobRequest request ) { request = beforeClientExecution ( request ) ; return executeGetExportJob ( request ) ; }
public AddRoleToDBInstanceResult addRoleToDBInstance ( AddRoleToDBInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeAddRoleToDBInstance ( request ) ; }
public DeregisterInstancesFromLoadBalancerResult deregisterInstancesFromLoadBalancer ( DeregisterInstancesFromLoadBalancerRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterInstancesFromLoadBalancer ( request ) ; }
public synchronized StringBuffer insert ( int index , char ch ) { insert0 ( index , ch ) ; return this ; }
public DownloadDBLogFilePortionResult downloadDBLogFilePortion ( DownloadDBLogFilePortionRequest request ) { request = beforeClientExecution ( request ) ; return executeDownloadDBLogFilePortion ( request ) ; }
public GetStaticIpResult getStaticIp ( GetStaticIpRequest request ) { request = beforeClientExecution ( request ) ; return executeGetStaticIp ( request ) ; }
public CreateUsagePlanResult createUsagePlan ( CreateUsagePlanRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateUsagePlan ( request ) ; }
public BlameResult call ( ) throws GitAPIException { checkCallable ( ) ; try ( BlameGenerator gen = new BlameGenerator ( repo , path ) ) { if ( diffAlgorithm != null ) gen . setDiffAlgorithm ( diffAlgorithm ) ; if ( textComparator != null ) gen . setTextComparator ( textComparator ) ; if ( followFileRenames != null ) gen . setFollowFileRenames ( followFileRenames . booleanValue ( ) ) ; if ( reverseEndCommits != null ) gen . reverse ( startCommit , reverseEndCommits ) ; else if ( startCommit != null ) gen . push ( null , startCommit ) ; else { gen . prepareHead ( ) ; } return gen . computeBlameResult ( ) ; } catch ( IOException e ) { throw new JGitInternalException ( e . getMessage ( ) , e ) ; } }
public SearchTransitGatewayMulticastGroupsResult searchTransitGatewayMulticastGroups ( SearchTransitGatewayMulticastGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchTransitGatewayMulticastGroups ( request ) ; }
public LinearOffsetRange normaliseAndTranslate ( int translationAmount ) { if ( _length > 0 ) { if ( translationAmount == 0 ) { return this ; } return new LinearOffsetRange ( translationAmount + _offset , _length ) ; } return new LinearOffsetRange ( translationAmount + _offset + _length + 1 , - _length ) ; }
public boolean isInvoke ( char c ) { return invokeMap [ characterCategoryMap [ c ] ] ; }
public int getSize ( ) { return size ; }
public int read ( ) throws IOException { if ( buf == null ) { throw new IOException ( ) ; } if ( pos < buf . length ) { return ( buf [ pos ++ ] & 0xFF ) ; } return in . read ( ) ; }
public int mark ( ) { return 0 ; }
public SearchPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " SearchPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public void copyFrom ( TermState other ) { assert other instanceof OrdTermState : " can ▁ not ▁ copy ▁ from ▁ " + other . getClass ( ) . getName ( ) ; this . ord = ( ( OrdTermState ) other ) . ord ; }
public AnalyzeDocumentResult analyzeDocument ( AnalyzeDocumentRequest request ) { request = beforeClientExecution ( request ) ; return executeAnalyzeDocument ( request ) ; }
public int calcExtSSTRecordSize ( ) { return ExtSSTRecord . getRecordSizeForStrings ( field_3_strings . size ( ) ) ; }
public static FormulaShifter createForSheetShift ( int srcSheetIndex , int dstSheetIndex ) { return new FormulaShifter ( srcSheetIndex , dstSheetIndex ) ; }
public void setRule ( int idx , ConditionalFormattingRule cfRule ) { setRule ( idx , ( HSSFConditionalFormattingRule ) cfRule ) ; }
public SelectionRecord ( RecordInputStream in ) { field_1_pane = in . readByte ( ) ; field_2_row_active_cell = in . readUShort ( ) ; field_3_col_active_cell = in . readShort ( ) ; field_4_active_cell_ref_index = in . readShort ( ) ; int field_5_num_refs = in . readUShort ( ) ; field_6_refs = new CellRangeAddress8Bit [ field_5_num_refs ] ; for ( int i = 0 ; i < field_6_refs . length ; i ++ ) { field_6_refs [ i ] = new CellRangeAddress8Bit ( in ) ; } }
public void setNeedNewObjectIds ( boolean b ) { if ( b ) newObjectIds = new ObjectIdSubclassMap <> ( ) ; elsenewObjectIds = null ; }
public GetResolverRulePolicyResult getResolverRulePolicy ( GetResolverRulePolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetResolverRulePolicy ( request ) ; }
public static DoubleBuffer wrap ( double [ ] array ) { return wrap ( array , 0 , array . length ) ; }
public UnitsRecord clone ( ) { return copy ( ) ; }
public void readFully ( byte [ ] buf , int off , int len ) { try { checkEOF ( _read ( buf , off , len ) , len ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public DescribeInterconnectLoaResult describeInterconnectLoa ( DescribeInterconnectLoaRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInterconnectLoa ( request ) ; }
public static ByteOrder nativeOrder ( ) { return NATIVE_ORDER ; }
public CalcModeRecord ( RecordInputStream in ) { field_1_calcmode = in . readShort ( ) ; }
public void addParentId ( AnyObjectId additionalParent ) { if ( parentIds . length == 0 ) { setParentId ( additionalParent ) ; } else { ObjectId [ ] newParents = new ObjectId [ parentIds . length + 1 ] ; System . arraycopy ( parentIds , 0 , newParents , 0 , parentIds . length ) ; newParents [ parentIds . length ] = additionalParent . copy ( ) ; parentIds = newParents ; } }
public CreateAccessPointResult createAccessPoint ( CreateAccessPointRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAccessPoint ( request ) ; }
public DeleteLoadBalancerListenersResult deleteLoadBalancerListeners ( DeleteLoadBalancerListenersRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLoadBalancerListeners ( request ) ; }
public DescribeOrderableClusterOptionsResult describeOrderableClusterOptions ( ) { return describeOrderableClusterOptions ( new DescribeOrderableClusterOptionsRequest ( ) ) ; }
public void setDerefTags ( boolean deref ) { derefTags = deref ; }
public DeactivateMFADeviceRequest ( String userName , String serialNumber ) { setUserName ( userName ) ; setSerialNumber ( serialNumber ) ; }
public boolean markSupported ( ) { synchronized ( lock ) { return in . markSupported ( ) ; } }
public static void createNewFile ( File f ) throws IOException { if ( ! f . createNewFile ( ) ) throw new IOException ( MessageFormat . format ( JGitText . get ( ) . createNewFileFailed , f ) ) ; }
public String getFieldAsString ( ) { if ( this . field == null ) return null ; else return this . field . toString ( ) ; }
public void inform ( ResourceLoader loader ) throws IOException { String dicts [ ] = dictionaryFiles . split ( " , " ) ; InputStream affix = null ; List < InputStream > dictionaries = new ArrayList <> ( ) ; try { dictionaries = new ArrayList <> ( ) ; for ( String file : dicts ) { dictionaries . add ( loader . openResource ( file ) ) ; } affix = loader . openResource ( affixFile ) ; Path tempPath = Files . createTempDirectory ( Dictionary . getDefaultTempDir ( ) , " Hunspell " ) ; try ( Directory tempDir = FSDirectory . open ( tempPath ) ) { this . dictionary = new Dictionary ( tempDir , " hunspell " , affix , dictionaries , ignoreCase ) ; } finally { IOUtils . rm ( tempPath ) ; } } catch ( ParseException e ) { throw new IOException ( " Unable ▁ to ▁ load ▁ hunspell ▁ data ! ▁ [ dictionary = " + dictionaries + " , affix = " + affixFile + " ] " , e ) ; } finally { IOUtils . closeWhileHandlingException ( affix ) ; IOUtils . closeWhileHandlingException ( dictionaries ) ; } }
public DetectDocumentTextResult detectDocumentText ( DetectDocumentTextRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectDocumentText ( request ) ; }
public DescribeCertificatesResult describeCertificates ( DescribeCertificatesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCertificates ( request ) ; }
public int getFormatCount ( ) { return _formats . length ; }
public GetOutcomesResult getOutcomes ( GetOutcomesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetOutcomes ( request ) ; }
public Set < URIishField > getOptionalFields ( ) { return Collections . emptySet ( ) ; }
public BasicStats ( String field , double boost ) { this . field = field ; this . boost = boost ; }
public UpdateSecurityGroupRuleDescriptionsIngressResult updateSecurityGroupRuleDescriptionsIngress ( UpdateSecurityGroupRuleDescriptionsIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateSecurityGroupRuleDescriptionsIngress ( request ) ; }
public long getOffset ( ) { return position ; }
public Collection < Ref > getAdvertisedRefs ( ) { return Collections . unmodifiableCollection ( advertisedRefs . values ( ) ) ; }
public QueryParser ( QueryParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public void setText ( CharacterIterator newText ) { start = newText . getBeginIndex ( ) ; end = newText . getEndIndex ( ) ; text = newText ; current = start ; }
public PutOutcomeResult putOutcome ( PutOutcomeRequest request ) { request = beforeClientExecution ( request ) ; return executePutOutcome ( request ) ; }
public UnescapedCharSequence ( CharSequence text ) { this . chars = new char [ text . length ( ) ] ; this . wasEscaped = new boolean [ text . length ( ) ] ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { this . chars [ i ] = text . charAt ( i ) ; this . wasEscaped [ i ] = false ; } }
public DoubleBuffer put ( double [ ] src , int srcOffset , int doubleCount ) { byteBuffer . limit ( limit * SizeOf . DOUBLE ) ; byteBuffer . position ( position * SizeOf . DOUBLE ) ; if ( byteBuffer instanceof ReadWriteDirectByteBuffer ) { ( ( ReadWriteDirectByteBuffer ) byteBuffer ) . put ( src , srcOffset , doubleCount ) ; } else { ( ( ReadWriteHeapByteBuffer ) byteBuffer ) . put ( src , srcOffset , doubleCount ) ; } this . position += doubleCount ; return this ; }
public void remove ( ) { throw new UnsupportedOperationException ( ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ CHARTTITLEFORMAT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . format □ runs ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( _formats . length ) . append ( " \ n " ) ; for ( int i = 0 ; i < _formats . length ; i ++ ) { CTFormat ctf = _formats [ i ] ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ . char □ offset = ▁ " ) . append ( ctf . getOffset ( ) ) ; buffer . append ( " , . fontidx = ▁ " ) . append ( ctf . getFontIndex ( ) ) ; buffer . append ( " \ n " ) ; } buffer . append ( " [ / CHARTTITLEFORMAT ] \ n " ) ; return buffer . toString ( ) ; }
public StartDominantLanguageDetectionJobResult startDominantLanguageDetectionJob ( StartDominantLanguageDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStartDominantLanguageDetectionJob ( request ) ; }
public static boolean hasNonConflictingAltSet ( Collection < BitSet > altsets ) { for ( BitSet alts : altsets ) { if ( alts . cardinality ( ) == 1 ) { return true ; } } return false ; }
public ByteBuffer putChar ( int index , char value ) { return putShort ( index , ( short ) value ) ; }
public DataValidationConstraint createTextLengthConstraint ( int operatorType , String formula1 , String formula2 ) { return DVConstraint . createNumericConstraint ( ValidationType . TEXT_LENGTH , operatorType , formula1 , formula2 ) ; }
public void writeShort ( int v ) { writeContinueIfRequired ( 2 ) ; _ulrOutput . writeShort ( v ) ; }
public final short getShort ( int index ) { checkIndex ( index , SizeOf . SHORT ) ; return Memory . peekShort ( backingArray , offset + index , order ) ; }
public static FuncPtg create ( int functionIndex ) { FunctionMetadata fm = FunctionMetadataRegistry . getFunctionByIndex ( functionIndex ) ; if ( fm == null ) { throw new RuntimeException ( " Invalid ▁ built - in ▁ function ▁ index ▁ ( " + functionIndex + " ) " ) ; } return new FuncPtg ( functionIndex , fm ) ; }
public String toString ( ) { return " { " + ruleIndex + " : " + predIndex + " } ? " ; }
public ListDashboardsResult listDashboards ( ListDashboardsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDashboards ( request ) ; }
public DeleteVoiceTemplateResult deleteVoiceTemplate ( DeleteVoiceTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVoiceTemplate ( request ) ; }
public void addListenerForAllRecords ( HSSFListener lsnr ) { short [ ] rectypes = RecordFactory . getAllKnownRecordSIDs ( ) ; for ( short rectype : rectypes ) { addListener ( lsnr , rectype ) ; } }
public DescribeLocalGatewayRouteTablesResult describeLocalGatewayRouteTables ( DescribeLocalGatewayRouteTablesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLocalGatewayRouteTables ( request ) ; }
public EnableDomainAutoRenewResult enableDomainAutoRenew ( EnableDomainAutoRenewRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableDomainAutoRenew ( request ) ; }
public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( type . toString ( ) ) ; result . append ( ' < ' ) ; result . append ( name ) ; result . append ( ' : ' ) ; if ( fieldsData != null ) { result . append ( fieldsData ) ; } result . append ( ' > ' ) ; return result . toString ( ) ; }
public DescribeConversionTasksResult describeConversionTasks ( ) { return describeConversionTasks ( new DescribeConversionTasksRequest ( ) ) ; }
public GetFieldLevelEncryptionProfileConfigResult getFieldLevelEncryptionProfileConfig ( GetFieldLevelEncryptionProfileConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFieldLevelEncryptionProfileConfig ( request ) ; }
public ListInstancesResult listInstances ( ListInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeListInstances ( request ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { final byte block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( block >>> 6 ) & 3 ; values [ valuesOffset ++ ] = ( block >>> 4 ) & 3 ; values [ valuesOffset ++ ] = ( block >>> 2 ) & 3 ; values [ valuesOffset ++ ] = block & 3 ; } }
public int read ( byte [ ] dst , int pos , int cnt ) throws IOException { try { int n = 0 ; while ( n < cnt ) { int r = inf . inflate ( dst , pos + n , cnt - n ) ; n += r ; if ( inf . finished ( ) ) break ; if ( inf . needsInput ( ) ) { onObjectData ( src , buf , p , bAvail ) ; use ( bAvail ) ; p = fill ( src , 1 ) ; inf . setInput ( buf , p , bAvail ) ; } else if ( r == 0 ) { throw new CorruptObjectException ( MessageFormat . format ( JGitText . get ( ) . packfileCorruptionDetected , JGitText . get ( ) . unknownZlibError ) ) ; } } actualSize += n ; return 0 < n ? n : - 1 ; } catch ( DataFormatException dfe ) { throw new CorruptObjectException ( MessageFormat . format ( JGitText . get ( ) . packfileCorruptionDetected , dfe . getMessage ( ) ) ) ; } }
public WorkflowExecutionCount countClosedWorkflowExecutions ( CountClosedWorkflowExecutionsRequest request ) { request = beforeClientExecution ( request ) ; return executeCountClosedWorkflowExecutions ( request ) ; }
public E remove ( ) { return removeFirstImpl ( ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval numberVE ) { final String number ; if ( numberVE instanceof RefEval ) { RefEval re = ( RefEval ) numberVE ; number = OperandResolver . coerceValueToString ( re . getInnerValueEval ( re . getFirstSheetIndex ( ) ) ) ; } else { number = OperandResolver . coerceValueToString ( numberVE ) ; } if ( number . length ( ) > 10 ) { return ErrorEval . NUM_ERROR ; } String unsigned ; boolean isPositive ; if ( number . length ( ) < 10 ) { unsigned = number ; isPositive = true ; } else { unsigned = number . substring ( 1 ) ; isPositive = number . startsWith ( " 0 " ) ; } String value ; try { if ( isPositive ) { int sum = getDecimalValue ( unsigned ) ; value = String . valueOf ( sum ) ; } else { String inverted = toggleBits ( unsigned ) ; int sum = getDecimalValue ( inverted ) ; sum ++ ; value = " - " + sum ; } } catch ( NumberFormatException e ) { return ErrorEval . NUM_ERROR ; } return new NumberEval ( Long . parseLong ( value ) ) ; }
public ObjectId getOldId ( ) { return oldId ; }
public FeatProtection ( RecordInputStream in ) { fSD = in . readInt ( ) ; passwordVerifier = in . readInt ( ) ; title = StringUtil . readUnicodeString ( in ) ; securityDescriptor = in . readRemainder ( ) ; }
public UpdateContactAttributesResult updateContactAttributes ( UpdateContactAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateContactAttributes ( request ) ; }
public DescribeClientVpnEndpointsResult describeClientVpnEndpoints ( DescribeClientVpnEndpointsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClientVpnEndpoints ( request ) ; }
public DescribeCacheSecurityGroupsResult describeCacheSecurityGroups ( DescribeCacheSecurityGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCacheSecurityGroups ( request ) ; }
public boolean equals ( Object object ) { synchronized ( Hashtable . this ) { return super . equals ( object ) ; } }
public static List < TransportProtocol > getTransportProtocols ( ) { int cnt = protocols . size ( ) ; List < TransportProtocol > res = new ArrayList <> ( cnt ) ; for ( WeakReference < TransportProtocol > ref : protocols ) { TransportProtocol proto = ref . get ( ) ; if ( proto != null ) res . add ( proto ) ; elseprotocols . remove ( ref ) ; } return Collections . unmodifiableList ( res ) ; }
public SrndTermQuery ( String termText , boolean quoted ) { super ( quoted ) ; this . termText = termText ; }
public CreateEmailTemplateResult createEmailTemplate ( CreateEmailTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateEmailTemplate ( request ) ; }
public ByteBuffer putChar ( char value ) { return putShort ( ( short ) value ) ; }
public static String getLocalizedMessage ( String key ) { return getLocalizedMessage ( key , Locale . getDefault ( ) ) ; }
public Snapshot deleteSnapshot ( DeleteSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSnapshot ( request ) ; }
public ListMemberAccountsResult listMemberAccounts ( ListMemberAccountsRequest request ) { request = beforeClientExecution ( request ) ; return executeListMemberAccounts ( request ) ; }
public boolean shouldRefresh ( ) { long now = System . currentTimeMillis ( ) ; return now - lastFailedRefreshTime > refreshIntervalInMillSeconds ; }
public void setRefLogMessage ( String msg , boolean appendStatus ) { if ( msg == null && ! appendStatus ) disableRefLog ( ) ; else if ( msg == null && appendStatus ) { refLogMessage = " " ; refLogIncludeResult = true ; } else { refLogMessage = msg ; refLogIncludeResult = appendStatus ; } }
public Status getStatus ( ) { return myStatus ; }
public GetDeploymentStrategyResult getDeploymentStrategy ( GetDeploymentStrategyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDeploymentStrategy ( request ) ; }
public DeleteEventResult deleteEvent ( DeleteEventRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEvent ( request ) ; }
public ListQueryLoggingConfigsResult listQueryLoggingConfigs ( ListQueryLoggingConfigsRequest request ) { request = beforeClientExecution ( request ) ; return executeListQueryLoggingConfigs ( request ) ; }
public BatchGetDeploymentTargetsResult batchGetDeploymentTargets ( BatchGetDeploymentTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetDeploymentTargets ( request ) ; }
public GetRulesResult getRules ( GetRulesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRules ( request ) ; }
public void setMessage ( String newMessage ) { message = newMessage ; }
public String toString ( String field ) { return null ; }
public ReplicationGroup completeMigration ( CompleteMigrationRequest request ) { request = beforeClientExecution ( request ) ; return executeCompleteMigration ( request ) ; }
public SupBookRecord ( RecordInputStream in ) { int recLen = in . remaining ( ) ; field_1_number_of_sheets = in . readShort ( ) ; if ( recLen > SMALL_RECORD_SIZE ) { _isAddInFunctions = false ; field_2_encoded_url = in . readString ( ) ; String [ ] sheetNames = new String [ field_1_number_of_sheets ] ; for ( int i = 0 ; i < sheetNames . length ; i ++ ) { sheetNames [ i ] = in . readString ( ) ; } field_3_sheet_names = sheetNames ; return ; } field_2_encoded_url = null ; field_3_sheet_names = null ; short nextShort = in . readShort ( ) ; if ( nextShort == TAG_INTERNAL_REFERENCES ) { _isAddInFunctions = false ; } else if ( nextShort == TAG_ADD_IN_FUNCTIONS ) { _isAddInFunctions = true ; if ( field_1_number_of_sheets != 1 ) { throw new RuntimeException ( " Expected ▁ 0x0001 ▁ for ▁ number ▁ of ▁ sheets ▁ field ▁ in ▁ ' Add - In Functions ' ▁ but ▁ got ▁ ( " + field_1_number_of_sheets + " ) " ) ; } } else { throw new RuntimeException ( " invalid ▁ EXTERNALBOOK ▁ code ▁ ( " + Integer . toHexString ( nextShort ) + " ) " ) ; } }
public GetEmailTemplateResult getEmailTemplate ( GetEmailTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeGetEmailTemplate ( request ) ; }
public void setByte ( int index , int value ) { switch ( index >> 2 ) { case 0 : w1 = set ( w1 , index & 3 , value ) ; break ; case 1 : w2 = set ( w2 , index & 3 , value ) ; break ; case 2 : w3 = set ( w3 , index & 3 , value ) ; break ; case 3 : w4 = set ( w4 , index & 3 , value ) ; break ; case 4 : w5 = set ( w5 , index & 3 , value ) ; break ; default : throw new ArrayIndexOutOfBoundsException ( index ) ; } }
public LongBuffer put ( int index , long c ) { throw new ReadOnlyBufferException ( ) ; }
public SumTotalTermFreqValueSource ( String indexedField ) { this . indexedField = indexedField ; }
public NavigableSet < E > tailSet ( E start , boolean startInclusive ) { Comparator <? super E > c = backingMap . comparator ( ) ; if ( c == null ) { ( ( Comparable < E > ) start ) . compareTo ( start ) ; } else { c . compare ( start , start ) ; } return new TreeSet < E > ( backingMap . tailMap ( start , startInclusive ) ) ; }
public ReadJobResult readJob ( ReadJobRequest request ) { request = beforeClientExecution ( request ) ; return executeReadJob ( request ) ; }
public GetSignalingChannelEndpointResult getSignalingChannelEndpoint ( GetSignalingChannelEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSignalingChannelEndpoint ( request ) ; }
public VariableGapTermsIndexWriter ( SegmentWriteState state , IndexTermSelector policy ) throws IOException { final String indexFileName = IndexFileNames . segmentFileName ( state . segmentInfo . name , state . segmentSuffix , TERMS_INDEX_EXTENSION ) ; out = state . directory . createOutput ( indexFileName , state . context ) ; boolean success = false ; try { fieldInfos = state . fieldInfos ; this . policy = policy ; CodecUtil . writeIndexHeader ( out , CODEC_NAME , VERSION_CURRENT , state . segmentInfo . getId ( ) , state . segmentSuffix ) ; success = true ; } finally { if ( ! success ) { IOUtils . closeWhileHandlingException ( out ) ; } } }
@ Override public boolean add ( E object ) { Object [ ] a = array ; int s = size ; if ( s == a . length ) { Object [ ] newArray = new Object [ s + ( s < ( MIN_CAPACITY_INCREMENT / 2 ) ? MIN_CAPACITY_INCREMENT : s >> 1 ) ] ; System . arraycopy ( a , 0 , newArray , 0 , s ) ; array = a = newArray ; } a [ s ] = object ; size = s + 1 ; modCount ++ ; return true ; }
public Set < Integer > toSet ( ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( Interval I : intervals ) { int a = I . a ; int b = I . b ; for ( int v = a ; v <= b ; v ++ ) { s . add ( v ) ; } } return s ; }
public final void writeBoolean ( boolean val ) throws IOException { write ( val ? 1 : 0 ) ; }
public void serialize ( LittleEndianOutput out ) { throw new RecordFormatException ( " Sorry , ▁ you ▁ can ' t serialize MulRK in this release " ) ; }
public T get ( int index ) { if ( index < 0 || size <= index ) throw new IndexOutOfBoundsException ( String . valueOf ( index ) ) ; return directory [ toDirectoryIndex ( index ) ] [ toBlockIndex ( index ) ] ; }
public DeleteSnapshotCopyGrantResult deleteSnapshotCopyGrant ( DeleteSnapshotCopyGrantRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSnapshotCopyGrant ( request ) ; }
public void resetFontStyle ( ) { setFontStyle ( false , false ) ; }
public static int getEncodedSize ( int numberOfRanges ) { return 2 + CellRangeAddress . getEncodedSize ( numberOfRanges ) ; }
public ListJobsRequest ( String vaultName ) { setVaultName ( vaultName ) ; }
public DeletePlacementGroupRequest ( String groupName ) { setGroupName ( groupName ) ; }
public void fill ( ) { lazyInit ( ) ; final int blockSize = 1000 ; while ( true ) { int fetched = fetch ( blockSize ) ; if ( fetched < blockSize ) { return ; } } }
public DescribeGlobalClustersResult describeGlobalClusters ( DescribeGlobalClustersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeGlobalClusters ( request ) ; }
public PutVoiceConnectorTerminationResult putVoiceConnectorTermination ( PutVoiceConnectorTerminationRequest request ) { request = beforeClientExecution ( request ) ; return executePutVoiceConnectorTermination ( request ) ; }
public static int strcmp ( char [ ] a , int startA , char [ ] b , int startB ) { for ( ; a [ startA ] == b [ startB ] ; startA ++ , startB ++ ) { if ( a [ startA ] == 0 ) { return 0 ; } } return a [ startA ] - b [ startB ] ; }
public StartSentimentDetectionJobResult startSentimentDetectionJob ( StartSentimentDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStartSentimentDetectionJob ( request ) ; }
public HSSFCell createCell ( int column ) { return this . createCell ( column , CellType . BLANK ) ; }
public RecalcIdRecord ( RecordInputStream in ) { in . readUShort ( ) ; _reserved0 = in . readUShort ( ) ; _engineId = in . readInt ( ) ; }
public static int getEncodedSizeWithoutArrayData ( Ptg [ ] ptgs ) { int result = 0 ; for ( Ptg ptg : ptgs ) { if ( ptg instanceof ArrayPtg ) { result += ArrayPtg . PLAIN_TOKEN_SIZE ; } else { result += ptg . getSize ( ) ; } } return result ; }
public static double ceiling ( double n , double s ) { if ( n > 0 && s < 0 ) { return Double . NaN ; } else { return ( n == 0 || s == 0 ) ? 0 : Math . ceil ( n / s ) * s ; } }
public ListResolverRulesResult listResolverRules ( ListResolverRulesRequest request ) { request = beforeClientExecution ( request ) ; return executeListResolverRules ( request ) ; }
public ListBusinessReportSchedulesResult listBusinessReportSchedules ( ListBusinessReportSchedulesRequest request ) { request = beforeClientExecution ( request ) ; return executeListBusinessReportSchedules ( request ) ; }
public EscherDgRecord createDgRecord ( ) { EscherDgRecord dg = new EscherDgRecord ( ) ; dg . setRecordId ( EscherDgRecord . RECORD_ID ) ; short dgId = findNewDrawingGroupId ( ) ; dg . setOptions ( ( short ) ( dgId << 4 ) ) ; dg . setNumShapes ( 0 ) ; dg . setLastMSOSPID ( - 1 ) ; drawingGroups . add ( dg ) ; dgg . addCluster ( dgId , 0 ) ; dgg . setDrawingsSaved ( dgg . getDrawingsSaved ( ) + 1 ) ; return dg ; }
public Transport open ( URIish uri ) throws NotSupportedException , TransportException { throw new NotSupportedException ( JGitText . get ( ) . transportNeedsRepository ) ; }
public int compare ( Ref o1 , Ref o2 ) { return compareTo ( o1 , o2 ) ; }
public OrdRange ( int start , int end ) { this . start = start ; this . end = end ; }
public boolean add ( E object ) { return backingMap . put ( object , this ) == null ; }
public void write ( String s ) { reserve ( s . length ( ) ) ; s . getChars ( 0 , s . length ( ) , buf , len ) ; len += s . length ( ) ; }
public long skip ( long cnt ) throws IOException { try { beginRead ( ) ; return super . skip ( cnt ) ; } catch ( InterruptedIOException e ) { throw readTimedOut ( e ) ; } finally { endRead ( ) ; } }
public StepDetail ( StepConfig stepConfig , StepExecutionStatusDetail executionStatusDetail ) { setStepConfig ( stepConfig ) ; setExecutionStatusDetail ( executionStatusDetail ) ; }
final public Token getToken ( int index ) { Token t = token ; for ( int i = 0 ; i < index ; i ++ ) { if ( t . next != null ) t = t . next ; else t = t . next = token_source . getNextToken ( ) ; } return t ; }
public Object [ ] toArray ( ) { synchronized ( mutex ) { return delegate ( ) . toArray ( ) ; } }
public DBParameterGroup createDBParameterGroup ( CreateDBParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBParameterGroup ( request ) ; }
public StringBuilder append ( boolean b ) { append0 ( b ? " true " : " false " ) ; return this ; }
public void execute ( Lexer lexer , CharStream input , int startIndex ) { boolean requiresSeek = false ; int stopIndex = input . index ( ) ; try { for ( LexerAction lexerAction : lexerActions ) { if ( lexerAction instanceof LexerIndexedCustomAction ) { int offset = ( ( LexerIndexedCustomAction ) lexerAction ) . getOffset ( ) ; input . seek ( startIndex + offset ) ; lexerAction = ( ( LexerIndexedCustomAction ) lexerAction ) . getAction ( ) ; requiresSeek = ( startIndex + offset ) != stopIndex ; } else if ( lexerAction . isPositionDependent ( ) ) { input . seek ( stopIndex ) ; requiresSeek = false ; } lexerAction . execute ( lexer ) ; } } finally { if ( requiresSeek ) { input . seek ( stopIndex ) ; } } }
public ListMailboxPermissionsResult listMailboxPermissions ( ListMailboxPermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListMailboxPermissions ( request ) ; }
public ConditionalFormattingTable ( RecordStream rs ) { while ( rs . peekNextRecord ( ) instanceof CFHeaderBase ) { _cfHeaders . add ( CFRecordsAggregate . createCFAggregate ( rs ) ) ; } }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final int byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final int byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 4 ) | ( byte1 >>> 4 ) ; final int byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 15 ) << 8 ) | byte2 ; } }
public Map < String , Ref > getTags ( ) { try { return getRefDatabase ( ) . getRefs ( Constants . R_TAGS ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public ComposedQuery ( List < SrndQuery > qs , boolean operatorInfix , String opName ) { recompose ( qs ) ; this . operatorInfix = operatorInfix ; this . opName = opName ; }
public TestRoleResult testRole ( TestRoleRequest request ) { request = beforeClientExecution ( request ) ; return executeTestRole ( request ) ; }
public String toString ( ) { final StringBuilder r = new StringBuilder ( ) ; r . append ( " ( " ) ; for ( int i = 0 ; i < subfilters . length ; i ++ ) { if ( i > 0 ) r . append ( " ▁ AND ▁ " ) ; r . append ( subfilters [ i ] . toString ( ) ) ; } r . append ( " ) " ) ; return r . toString ( ) ; }
public ModifyVpcAttributeResult modifyVpcAttribute ( ModifyVpcAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVpcAttribute ( request ) ; }
public void seekExact ( long ord ) throws IOException { throw new UnsupportedOperationException ( ) ; }
public ArabicNormalizationFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof BookSheetKey ) ) { return false ; } BookSheetKey other = ( BookSheetKey ) obj ; return _bookIndex == other . _bookIndex && _sheetIndex == other . _sheetIndex ; }
public TermQuery ( Term t , TermStates states ) { assert states != null ; term = Objects . requireNonNull ( t ) ; perReaderTermState = Objects . requireNonNull ( states ) ; }
public GetClusterCredentialsResult getClusterCredentials ( GetClusterCredentialsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetClusterCredentials ( request ) ; }
public boolean equals ( Object other ) { return ( getClass ( ) == other . getClass ( ) ) && this . equalsSameType ( other ) ; }
public Item clone ( ) { return new Item ( parent , child ) ; }
public UpdateClusterResult updateCluster ( UpdateClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateCluster ( request ) ; }
public E get ( int index ) { synchronized ( mutex ) { return delegate ( ) . get ( index ) ; } }
public LogCommand setMaxCount ( int maxCount ) { checkCallable ( ) ; this . maxCount = maxCount ; return this ; }
public GetInsightRuleReportResult getInsightRuleReport ( GetInsightRuleReportRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInsightRuleReport ( request ) ; }
public CommonToken ( Token oldToken ) { type = oldToken . getType ( ) ; line = oldToken . getLine ( ) ; index = oldToken . getTokenIndex ( ) ; charPositionInLine = oldToken . getCharPositionInLine ( ) ; channel = oldToken . getChannel ( ) ; start = oldToken . getStartIndex ( ) ; stop = oldToken . getStopIndex ( ) ; if ( oldToken instanceof CommonToken ) { text = ( ( CommonToken ) oldToken ) . text ; source = ( ( CommonToken ) oldToken ) . source ; } else { text = oldToken . getText ( ) ; source = new Pair < TokenSource , CharStream > ( oldToken . getTokenSource ( ) , oldToken . getInputStream ( ) ) ; } }
public ListSolutionsResult listSolutions ( ListSolutionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListSolutions ( request ) ; }
public boolean hasPrevious ( ) { return index > from ; }
public final void end ( ) { if ( finalState != null ) { restoreState ( finalState ) ; } }
public DoubleBuffer put ( int index , double c ) { checkIndex ( index ) ; backingArray [ offset + index ] = c ; return this ; }
public ThreeWayMerger newMerger ( Repository db ) { return new ResolveMerger ( db , false ) ; }
public static long pop_union ( long [ ] arr1 , long [ ] arr2 , int wordOffset , int numWords ) { long popCount = 0 ; for ( int i = wordOffset , end = wordOffset + numWords ; i < end ; ++ i ) { popCount += Long . bitCount ( arr1 [ i ] | arr2 [ i ] ) ; } return popCount ; }
public LongBuffer put ( long c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } backingArray [ offset + position ++ ] = c ; return this ; }
public ConstValueSource ( float constant ) { this . constant = constant ; this . dv = constant ; }
public boolean matches ( char c ) { return punctCharacters . indexOf ( c ) != - 1 ; }
public FlushInfo ( int numDocs , long estimatedSegmentSize ) { this . numDocs = numDocs ; this . estimatedSegmentSize = estimatedSegmentSize ; }
public void print ( char [ ] chars ) { print ( new String ( chars , 0 , chars . length ) ) ; }
public E element ( ) { return getFirstImpl ( ) ; }
public ListNodegroupsResult listNodegroups ( ListNodegroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListNodegroups ( request ) ; }
public PutSkillAuthorizationResult putSkillAuthorization ( PutSkillAuthorizationRequest request ) { request = beforeClientExecution ( request ) ; return executePutSkillAuthorization ( request ) ; }
public DescribeSourceRegionsResult describeSourceRegions ( DescribeSourceRegionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSourceRegions ( request ) ; }
public SplitShardResult splitShard ( SplitShardRequest request ) { request = beforeClientExecution ( request ) ; return executeSplitShard ( request ) ; }
public CreateTableRequest ( String tableName , java . util . List < KeySchemaElement > keySchema ) { setTableName ( tableName ) ; setKeySchema ( keySchema ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_id ) ; out . writeByte ( field_4_text . length ( ) ) ; if ( is16bit ) { out . writeByte ( 0x01 ) ; StringUtil . putUnicodeLE ( field_4_text , out ) ; } else { out . writeByte ( 0x00 ) ; StringUtil . putCompressedUnicode ( field_4_text , out ) ; } }
public UpdateVoiceTemplateResult updateVoiceTemplate ( UpdateVoiceTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateVoiceTemplate ( request ) ; }
public BookBoolRecord ( RecordInputStream in ) { field_1_save_link_values = in . readShort ( ) ; }
public final Buffer flip ( ) { limit = position ; position = 0 ; mark = UNSET_MARK ; return this ; }
public IntBuffer get ( int [ ] dst , int dstOffset , int intCount ) { Arrays . checkOffsetAndCount ( dst . length , dstOffset , intCount ) ; if ( intCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } for ( int i = dstOffset ; i < dstOffset + intCount ; ++ i ) { dst [ i ] = get ( ) ; } return this ; }
public GroupingSearch setGroupDocsOffset ( int groupDocsOffset ) { this . groupDocsOffset = groupDocsOffset ; return this ; }
public Builder ( ) { this ( 16 , 16 ) ; }
public String getCommandName ( ) { return command ; }
public int getFirstInternalSheetIndexForExtIndex ( int extRefIndex ) { if ( extRefIndex >= _externSheetRecord . getNumOfRefs ( ) || extRefIndex < 0 ) { return - 1 ; } return _externSheetRecord . getFirstSheetIndexFromRefIndex ( extRefIndex ) ; }
public boolean isExpired ( ) { return this . expiredDate == null || this . expiredDate . after ( new Date ( ) ) ; }
public ListPolicyAttachmentsResult listPolicyAttachments ( ListPolicyAttachmentsRequest request ) { request = beforeClientExecution ( request ) ; return executeListPolicyAttachments ( request ) ; }
public double readDouble ( ) { return Double . longBitsToDouble ( readLong ( ) ) ; }
public UpdateLoginProfileRequest ( String userName ) { setUserName ( userName ) ; }
public String getResultPath ( ) { return resultPath ; }
public DescribeInstanceAttributeRequest ( String instanceId , InstanceAttributeName attribute ) { setInstanceId ( instanceId ) ; setAttribute ( attribute . toString ( ) ) ; }
public int previousIndex ( ) { return index - 1 ; }
public static RevFilter create ( RevFilter [ ] list ) { if ( list . length == 2 ) return create ( list [ 0 ] , list [ 1 ] ) ; if ( list . length < 2 ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastTwoFiltersNeeded ) ; final RevFilter [ ] subfilters = new RevFilter [ list . length ] ; System . arraycopy ( list , 0 , subfilters , 0 , list . length ) ; return new List ( subfilters ) ; }
public void reset ( ) { seek ( 0 ) ; }
public ListResourceRecordSetsRequest ( String hostedZoneId ) { setHostedZoneId ( hostedZoneId ) ; }
public EventBasedExcelExtractor ( POIFSFileSystem fs ) { this ( fs . getRoot ( ) ) ; super . setFilesystem ( fs ) ; }
public ListClustersResult listClusters ( ) { return listClusters ( new ListClustersRequest ( ) ) ; }
public CreateAddressResult createAddress ( CreateAddressRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAddress ( request ) ; }
public ListFacePhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListFacePhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public String toPrivateASCIIString ( ) { return format ( true , true ) ; }
public BatchGetNamedQueryResult batchGetNamedQuery ( BatchGetNamedQueryRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetNamedQuery ( request ) ; }
public CreateProfilingGroupResult createProfilingGroup ( CreateProfilingGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateProfilingGroup ( request ) ; }
@ Override public String toString ( ) { return Arrays . toString ( elements ) ; }
public String toString ( ) { String padd = getPadding ( ) ; StringBuilder sb = new StringBuilder ( padd ) ; if ( disableCounting ) { sb . append ( ' - ' ) ; } sb . append ( getName ( ) ) ; if ( getRunInBackground ( ) ) { sb . append ( " ▁ & " ) ; int x = getBackgroundDeltaPriority ( ) ; if ( x != 0 ) { sb . append ( x ) ; } } return sb . toString ( ) ; }
public Counter bytesUsed ( ) { return bytesUsed ; }
public ListStreamingDistributionsResult listStreamingDistributions ( ListStreamingDistributionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListStreamingDistributions ( request ) ; }
public final void writeInt ( int val ) throws IOException { Memory . pokeInt ( scratch , 0 , val , ByteOrder . BIG_ENDIAN ) ; write ( scratch , 0 , SizeOf . INT ) ; }
public static ExpandedDouble fromRawBitsAndExponent ( long rawBits , int exp ) { return new ExpandedDouble ( getFrac ( rawBits ) , exp ) ; }
public boolean offerFirst ( E e ) { return addFirstImpl ( e ) ; }
public BlockTermsWriter ( TermsIndexWriterBase termsIndexWriter , SegmentWriteState state , PostingsWriterBase postingsWriter ) throws IOException { final String termsFileName = IndexFileNames . segmentFileName ( state . segmentInfo . name , state . segmentSuffix , TERMS_EXTENSION ) ; this . termsIndexWriter = termsIndexWriter ; maxDoc = state . segmentInfo . maxDoc ( ) ; out = state . directory . createOutput ( termsFileName , state . context ) ; boolean success = false ; try { fieldInfos = state . fieldInfos ; CodecUtil . writeIndexHeader ( out , CODEC_NAME , VERSION_CURRENT , state . segmentInfo . getId ( ) , state . segmentSuffix ) ; currentField = null ; this . postingsWriter = postingsWriter ; postingsWriter . init ( out , state ) ; success = true ; } finally { if ( ! success ) { IOUtils . closeWhileHandlingException ( out ) ; } } }
public InstanceGroupModifyConfig ( String instanceGroupId , Integer instanceCount ) { setInstanceGroupId ( instanceGroupId ) ; setInstanceCount ( instanceCount ) ; }
public void collect ( int doc ) { totalHits ++ ; }
public void writeByte ( int v ) { try { out . write ( v ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public int serializeComplexPart ( byte [ ] data , int pos ) { System . arraycopy ( complexData , 0 , data , pos , complexData . length ) ; return complexData . length ; }
public String toString ( ) { return " < notokenfound /> " ; }
public DecisionInfo ( int decision ) { this . decision = decision ; }
public CFRuleRecord ( RecordInputStream in ) { setConditionType ( in . readByte ( ) ) ; setComparisonOperation ( in . readByte ( ) ) ; int field_3_formula1_len = in . readUShort ( ) ; int field_4_formula2_len = in . readUShort ( ) ; readFormatOptions ( in ) ; setFormula1 ( Formula . read ( field_3_formula1_len , in ) ) ; setFormula2 ( Formula . read ( field_4_formula2_len , in ) ) ; }
public GroupMarkerSubRecord ( ) { reserved = EMPTY_BYTE_ARRAY ; }
public SegToken filter ( SegToken token ) { switch ( token . wordType ) { case WordType . FULLWIDTH_NUMBER : case WordType . FULLWIDTH_STRING : for ( int i = 0 ; i < token . charArray . length ; i ++ ) { if ( token . charArray [ i ] >= 0xFF10 ) token . charArray [ i ] -= 0xFEE0 ; if ( token . charArray [ i ] >= 0x0041 && token . charArray [ i ] <= 0x005A ) token . charArray [ i ] += 0x0020 ; } break ; case WordType . STRING : for ( int i = 0 ; i < token . charArray . length ; i ++ ) { if ( token . charArray [ i ] >= 0x0041 && token . charArray [ i ] <= 0x005A ) token . charArray [ i ] += 0x0020 ; } break ; case WordType . DELIMITER : token . charArray = Utility . COMMON_DELIMITER ; break ; default : break ; } return token ; }
public BarRecord ( RecordInputStream in ) { field_1_barSpace = in . readShort ( ) ; field_2_categorySpace = in . readShort ( ) ; field_3_formatFlags = in . readShort ( ) ; }
public final boolean tryIncRef ( ) { int count ; while ( ( count = refCount . get ( ) ) > 0 ) { if ( refCount . compareAndSet ( count , count + 1 ) ) { return true ; } } return false ; }
public GetStackPolicyResult getStackPolicy ( GetStackPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetStackPolicy ( request ) ; }
public void removeKeywords ( ) { remove1stProperty ( PropertyIDMap . PID_KEYWORDS ) ; }
public boolean follows ( TextFragment fragment ) { return textStartPos == fragment . textEndPos ; }
public DescribeHyperParameterTuningJobResult describeHyperParameterTuningJob ( DescribeHyperParameterTuningJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeHyperParameterTuningJob ( request ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " " ; StringBuilder sb = new StringBuilder ( ) ; String filler = " " ; for ( QueryNode child : getChildren ( ) ) { sb . append ( filler ) . append ( child . toQueryString ( escapeSyntaxParser ) ) ; filler = " ▁ AND ▁ " ; } if ( ( getParent ( ) != null && getParent ( ) instanceof GroupQueryNode ) || isRoot ( ) ) return sb . toString ( ) ; else return " ( ▁ " + sb . toString ( ) + " ▁ ) " ; }
public String toString ( ) { return " State ▁ [ entries = " + entries + " , ▁ hosts = " + hosts + " ] " ; }
public DataFormatRecord ( RecordInputStream in ) { field_1_pointNumber = in . readShort ( ) ; field_2_seriesIndex = in . readShort ( ) ; field_3_seriesNumber = in . readShort ( ) ; field_4_formatFlags = in . readShort ( ) ; }
public ModifyVpcEndpointServiceConfigurationResult modifyVpcEndpointServiceConfiguration ( ModifyVpcEndpointServiceConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVpcEndpointServiceConfiguration ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _encodedTokenLen ) ; out . write ( _byteEncoding ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { AreaEval aeRange ; try { aeRange = convertRangeArg ( arg0 ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return eval ( srcRowIndex , srcColumnIndex , arg1 , aeRange , aeRange ) ; }
public RecognizeLabelRequest ( ) { super ( " visionai - poc " , " 2020 - 04 - 08 " , " RecognizeLabel " ) ; setMethod ( MethodType . POST ) ; }
public ListStackSetsResult listStackSets ( ListStackSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListStackSets ( request ) ; }
public ModifyNetworkInterfaceAttributeResult modifyNetworkInterfaceAttribute ( ModifyNetworkInterfaceAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyNetworkInterfaceAttribute ( request ) ; }
public static RevFilter create ( RevFilter a ) { return new NotRevFilter ( a ) ; }
public String toString ( ) { String up = parent != null ? parent . toString ( ) : " " ; if ( up . length ( ) == 0 ) { if ( returnState == EMPTY_RETURN_STATE ) { return " $ " ; } return String . valueOf ( returnState ) ; } return String . valueOf ( returnState ) + " ▁ " + up ; }
public ToParentBlockJoinQuery ( Query childQuery , BitSetProducer parentsFilter , ScoreMode scoreMode ) { super ( ) ; this . childQuery = childQuery ; this . parentsFilter = parentsFilter ; this . scoreMode = scoreMode ; }
public int previousIndex ( ) { int previous = iterator . previousIndex ( ) ; if ( previous >= start ) { return previous - start ; } return - 1 ; }
public String getSourcePath ( int idx ) { return sourcePaths [ idx ] ; }
public DoubleBuffer slice ( ) { return new ReadWriteDoubleArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public DescribeEvaluationsResult describeEvaluations ( DescribeEvaluationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEvaluations ( request ) ; }
public int getBigBlockSize ( ) { return bigBlockSize ; }
public static ValueVector createRowVector ( TwoDEval tableArray , int relativeRowIndex ) { return new RowVector ( tableArray , relativeRowIndex ) ; }
public void setDbcell ( int cell , int value ) { field_5_dbcells . set ( cell , value ) ; }
public int compareTo ( MutableValue other ) { Class <? extends MutableValue > c1 = this . getClass ( ) ; Class <? extends MutableValue > c2 = other . getClass ( ) ; if ( c1 != c2 ) { int c = c1. hashCode ( ) - c2. hashCode ( ) ; if ( c == 0 ) { c = c1. getCanonicalName ( ) . compareTo ( c2. getCanonicalName ( ) ) ; } return c ; } return compareSameType ( other ) ; }
public StartSpeechSynthesisTaskResult startSpeechSynthesisTask ( StartSpeechSynthesisTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeStartSpeechSynthesisTask ( request ) ; }
public void removeParseListeners ( ) { _parseListeners = null ; }
public ListIdentityPoolsResult listIdentityPools ( ListIdentityPoolsRequest request ) { request = beforeClientExecution ( request ) ; return executeListIdentityPools ( request ) ; }
public String toString ( ) { return text + ' ( ' + startOffset + ' , ' + endOffset + ' , ' + position + ' ) ' ; }
public void setWrapIfNotCachingTokenFilter ( boolean wrap ) { this . wrapToCaching = wrap ; }
public void onChange ( boolean selfChange ) { mCursor . requery ( ) ; }
public DeleteRuleResult deleteRule ( DeleteRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRule ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeByte ( getAddMenuCount ( ) ) ; out . writeByte ( getDelMenuCount ( ) ) ; }
public String getPattern ( ) { return pattern ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ BottomMargin ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . margin ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " ▁ ( " ) . append ( getMargin ( ) ) . append ( " ▁ ) \ n " ) ; buffer . append ( " [ / BottomMargin ] \ n " ) ; return buffer . toString ( ) ; }
public final void getText ( CharTermAttribute t ) { t . copyBuffer ( zzBuffer , zzStartRead , zzMarkedPos - zzStartRead ) ; }
public LinkedList ( ) { voidLink = new Link < E > ( null , null , null ) ; voidLink . previous = voidLink ; voidLink . next = voidLink ; }
public SnapshotCopyGrant createSnapshotCopyGrant ( CreateSnapshotCopyGrantRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSnapshotCopyGrant ( request ) ; }
public static int getSingleViableAlt ( Collection < BitSet > altsets ) { BitSet viableAlts = new BitSet ( ) ; for ( BitSet alts : altsets ) { int minAlt = alts . nextSetBit ( 0 ) ; viableAlts . set ( minAlt ) ; if ( viableAlts . cardinality ( ) > 1 ) { return ATN . INVALID_ALT_NUMBER ; } } return viableAlts . nextSetBit ( 0 ) ; }
public Builder ( ) { this . similarity = new BM25Similarity ( ) ; }
public List < Ref > getRevertedRefs ( ) { return revertedRefs ; }
public DetachPolicyResult detachPolicy ( DetachPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachPolicy ( request ) ; }
public final void writeUTF ( String str ) throws IOException { write ( ModifiedUtf8. encode ( str ) ) ; }
public DeleteBusinessReportScheduleResult deleteBusinessReportSchedule ( DeleteBusinessReportScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteBusinessReportSchedule ( request ) ; }
public JapanesePartOfSpeechStopFilterFactory ( Map < String , String > args ) { super ( args ) ; stopTagFiles = get ( args , " tags " ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public SetVaultNotificationsResult setVaultNotifications ( SetVaultNotificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeSetVaultNotifications ( request ) ; }
public void writeBytes ( byte [ ] b , int offset , int length ) { assert pos + length <= limit ; System . arraycopy ( b , offset , bytes , pos , length ) ; pos += length ; }
public UpdateLedgerResult updateLedger ( UpdateLedgerRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateLedger ( request ) ; }
public BatchDetectDominantLanguageResult batchDetectDominantLanguage ( BatchDetectDominantLanguageRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDetectDominantLanguage ( request ) ; }
public void pollForUpdates ( ) { assert isMainThread ( ) ; doUpdates ( ) ; }
public int getAltNumber ( ) { return ATN . INVALID_ALT_NUMBER ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . append ( getClass ( ) . getName ( ) ) . append ( " ▁ [ " ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public int getTimeout ( ) { return timeout ; }
public boolean canReuse ( IndexInput in ) { return in == inStart ; }
public DescribeMetricFiltersRequest ( String logGroupName ) { setLogGroupName ( logGroupName ) ; }
public final void write ( char [ ] b ) { write ( b , 0 , b . length ) ; }
public void trimToSize ( ) { if ( count < value . length ) { char [ ] newValue = new char [ count ] ; System . arraycopy ( value , 0 , newValue , 0 , count ) ; value = newValue ; shared = false ; } }
public ListTransformJobsResult listTransformJobs ( ListTransformJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTransformJobs ( request ) ; }
public EvaluationName getName ( NamePtg namePtg ) { int ix = namePtg . getIndex ( ) ; return new Name ( _iBook . getNameRecord ( ix ) , ix ) ; }
public StashCreateCommand setIndexMessage ( String message ) { indexMessage = message ; return this ; }
public HSSFPalette getCustomPalette ( ) { return new HSSFPalette ( workbook . getCustomPalette ( ) ) ; }
public DeregisterTaskDefinitionResult deregisterTaskDefinition ( DeregisterTaskDefinitionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterTaskDefinition ( request ) ; }
public String pattern ( ) { return pattern ; }
public void setThreads ( int threads ) { this . threads = threads ; }
public void execute ( ReceivePack rp ) { try { String expTarget = getOldSymref ( ) ; boolean detach = getNewSymref ( ) != null || ( type == Type . DELETE && expTarget != null ) ; RefUpdate ru = rp . getRepository ( ) . updateRef ( getRefName ( ) , detach ) ; if ( expTarget != null ) { if ( ! ru . getRef ( ) . isSymbolic ( ) || ! ru . getRef ( ) . getTarget ( ) . getName ( ) . equals ( expTarget ) ) { setResult ( Result . LOCK_FAILURE ) ; return ; } } ru . setRefLogIdent ( rp . getRefLogIdent ( ) ) ; ru . setRefLogMessage ( refLogMessage , refLogIncludeResult ) ; switch ( getType ( ) ) { case DELETE : if ( ! ObjectId . zeroId ( ) . equals ( getOldId ( ) ) ) { ru . setExpectedOldObjectId ( getOldId ( ) ) ; } ru . setForceUpdate ( true ) ; setResult ( ru . delete ( rp . getRevWalk ( ) ) ) ; break ; case CREATE : case UPDATE : case UPDATE_NONFASTFORWARD : ru . setForceUpdate ( rp . isAllowNonFastForwards ( ) ) ; ru . setExpectedOldObjectId ( getOldId ( ) ) ; ru . setRefLogMessage ( " push " , true ) ; if ( getNewSymref ( ) != null ) { setResult ( ru . link ( getNewSymref ( ) ) ) ; } else { ru . setNewObjectId ( getNewId ( ) ) ; setResult ( ru . update ( rp . getRevWalk ( ) ) ) ; } break ; } } catch ( IOException err ) { reject ( err ) ; } }
public GetEbsDefaultKmsKeyIdResult getEbsDefaultKmsKeyId ( GetEbsDefaultKmsKeyIdRequest request ) { request = beforeClientExecution ( request ) ; return executeGetEbsDefaultKmsKeyId ( request ) ; }
public String toString ( ) { return " MultiDocsAndPositionsEnum ( " + Arrays . toString ( getSubs ( ) ) + " ) " ; }
public DeleteCacheParameterGroupRequest ( String cacheParameterGroupName ) { setCacheParameterGroupName ( cacheParameterGroupName ) ; }
public NavigableMap < K , V > headMap ( K to , boolean inclusive ) { Bound toBound = inclusive ? INCLUSIVE : EXCLUSIVE ; return subMap ( null , NO_BOUND , to , toBound ) ; }
public OutputStream getOutputStream ( ) { return rawOut ; }
public Boolean booleanValue ( String key ) { String value = responseMap . get ( key ) ; if ( null == value || 0 == value . length ( ) ) { return null ; } return Boolean . valueOf ( responseMap . get ( key ) ) ; }
public ATN getATNWithBypassAlts ( ) { String serializedAtn = getSerializedATN ( ) ; if ( serializedAtn == null ) { throw new UnsupportedOperationException ( " The ▁ current ▁ parser ▁ does ▁ not ▁ support ▁ an ▁ ATN ▁ with ▁ bypass ▁ alternatives . " ) ; } synchronized ( bypassAltsAtnCache ) { ATN result = bypassAltsAtnCache . get ( serializedAtn ) ; if ( result == null ) { ATNDeserializationOptions deserializationOptions = new ATNDeserializationOptions ( ) ; deserializationOptions . setGenerateRuleBypassTransitions ( true ) ; result = new ATNDeserializer ( deserializationOptions ) . deserialize ( serializedAtn . toCharArray ( ) ) ; bypassAltsAtnCache . put ( serializedAtn , result ) ; } return result ; } }
public GetDownloadUrlRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetDownloadUrl " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public int getCRC ( ) { return crc ; }
public boolean addEscherRecord ( EscherRecord element ) { return escherRecords . add ( element ) ; }
public CharBuffer put ( String src , int start , int end ) { throw new ReadOnlyBufferException ( ) ; }
public ModifyWorkspaceStateResult modifyWorkspaceState ( ModifyWorkspaceStateRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyWorkspaceState ( request ) ; }
public ICUTransformFilter ( TokenStream input , Transliterator transform ) { super ( input ) ; this . transform = transform ; if ( transform . getFilter ( ) == null && transform instanceof com . ibm . icu . text . RuleBasedTransliterator ) { final UnicodeSet sourceSet = transform . getSourceSet ( ) ; if ( sourceSet != null && ! sourceSet . isEmpty ( ) ) transform . setFilter ( sourceSet ) ; } }
public StopGameSessionPlacementResult stopGameSessionPlacement ( StopGameSessionPlacementRequest request ) { request = beforeClientExecution ( request ) ; return executeStopGameSessionPlacement ( request ) ; }
public ObjectId getDeltaBase ( ) { return null ; }
public RefModeRecord clone ( ) { return copy ( ) ; }
public boolean addURI ( URIish toAdd ) { if ( uris . contains ( toAdd ) ) return false ; return uris . add ( toAdd ) ; }
public FileMode getOldMode ( ) { return getOldMode ( 0 ) ; }
public Collection < RemoteRefUpdate > getRemoteUpdates ( ) { return Collections . unmodifiableCollection ( remoteUpdates . values ( ) ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( " ▁ [ " ) ; String ws = String . valueOf ( _wholePart ) ; sb . append ( ws . charAt ( 0 ) ) ; sb . append ( ' . ' ) ; sb . append ( ws . substring ( 1 ) ) ; sb . append ( ' ▁ ' ) ; sb . append ( getFractionalDigits ( ) ) ; sb . append ( " E " ) ; sb . append ( getDecimalExponent ( ) ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public CreateCollectionResult createCollection ( CreateCollectionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCollection ( request ) ; }
public ChangeMessageVisibilityBatchResult changeMessageVisibilityBatch ( ChangeMessageVisibilityBatchRequest request ) { request = beforeClientExecution ( request ) ; return executeChangeMessageVisibilityBatch ( request ) ; }
public static int [ ] copyOfRange ( int [ ] original , int start , int end ) { if ( start > end ) { throw new IllegalArgumentException ( ) ; } int originalLength = original . length ; if ( start < 0 || start > originalLength ) { throw new ArrayIndexOutOfBoundsException ( ) ; } int resultLength = end - start ; int copyLength = Math . min ( resultLength , originalLength - start ) ; int [ ] result = new int [ resultLength ] ; System . arraycopy ( original , start , result , 0 , copyLength ) ; return result ; }
public static void setInstance ( SshSessionFactory newFactory ) { if ( newFactory != null ) { INSTANCE = newFactory ; } else { INSTANCE = loadSshSessionFactory ( ) ; } }
public GetRepoSyncTaskListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoSyncTaskList " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / syncTasks " ) ; setMethod ( MethodType . GET ) ; }
public RunInstancesRequest ( String imageId , Integer minCount , Integer maxCount ) { setImageId ( imageId ) ; setMinCount ( minCount ) ; setMaxCount ( maxCount ) ; }
public DeleteCodeRepositoryResult deleteCodeRepository ( DeleteCodeRepositoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCodeRepository ( request ) ; }
public void fill ( int fromIndex , int toIndex , long val ) { assert fromIndex >= 0 ; assert fromIndex <= toIndex ; assert PackedInts . unsignedBitsRequired ( val ) <= bitsPerValue ; final int valuesPerBlock = 64 / bitsPerValue ; if ( toIndex - fromIndex <= valuesPerBlock << 1 ) { super . fill ( fromIndex , toIndex , val ) ; return ; } int fromOffsetInBlock = fromIndex % valuesPerBlock ; if ( fromOffsetInBlock != 0 ) { for ( int i = fromOffsetInBlock ; i < valuesPerBlock ; ++ i ) { set ( fromIndex ++ , val ) ; } assert fromIndex % valuesPerBlock == 0 ; } final int fromBlock = fromIndex / valuesPerBlock ; final int toBlock = toIndex / valuesPerBlock ; assert fromBlock * valuesPerBlock == fromIndex ; long blockValue = 0L ; for ( int i = 0 ; i < valuesPerBlock ; ++ i ) { blockValue = blockValue | ( val << ( i * bitsPerValue ) ) ; } Arrays . fill ( blocks , fromBlock , toBlock , blockValue ) ; for ( int i = valuesPerBlock * toBlock ; i < toIndex ; ++ i ) { set ( i , val ) ; } }
public void close ( ) { str = null ; }
public ListDomainNamesResult listDomainNames ( ) { return listDomainNames ( new ListDomainNamesRequest ( ) ) ; }
public AbortMultipartUploadRequest ( String accountId , String vaultName , String uploadId ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; setUploadId ( uploadId ) ; }
public RevCommit getNewHead ( ) { return newHead ; }
public long get ( int index ) { final int o = index >>> 5 ; final int b = index & 31 ; final int shift = b << 1 ; return ( blocks [ o ] >>> shift ) & 3L ; }
public UpdateContainerInstancesStateResult updateContainerInstancesState ( UpdateContainerInstancesStateRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateContainerInstancesState ( request ) ; }
public GetExternalModelsResult getExternalModels ( GetExternalModelsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetExternalModels ( request ) ; }
public GetFaceDetectionResult getFaceDetection ( GetFaceDetectionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFaceDetection ( request ) ; }
public void delete ( ) { synchronized ( SnapshotDeletionPolicy . this ) { if ( ! refCounts . containsKey ( cp . getGeneration ( ) ) ) { cp . delete ( ) ; } } }
public void decode ( long [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; for ( int shift = 56 ; shift >= 0 ; shift -= 8 ) { values [ valuesOffset ++ ] = ( int ) ( ( block >>> shift ) & 255 ) ; } } }
public Iterator < E > descendingIterator ( ) { return new ReverseLinkIterator < E > ( this ) ; }
public CredentialsBackupCompatibilityAdaptor ( AlibabaCloudCredentialsProvider provider ) { this . provider = provider ; }
public DescribeDBClusterSnapshotsResult describeDBClusterSnapshots ( DescribeDBClusterSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBClusterSnapshots ( request ) ; }
public FontRecord getFontRecordAt ( int idx ) { int index = idx ; if ( index > 4 ) { index -= 1 ; } if ( index > ( numfonts - 1 ) ) { throw new ArrayIndexOutOfBoundsException ( " There ▁ are ▁ only ▁ " + numfonts + " ▁ font ▁ records , ▁ but ▁ you ▁ asked ▁ for ▁ index ▁ " + idx ) ; } return ( FontRecord ) records . get ( ( records . getFontpos ( ) - ( numfonts - 1 ) ) + index ) ; }
public final ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { if ( args . length != 2 ) { return ErrorEval . VALUE_INVALID ; } return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] ) ; }
public DescribeCustomerGatewaysResult describeCustomerGateways ( ) { return describeCustomerGateways ( new DescribeCustomerGatewaysRequest ( ) ) ; }
public CreateSubnetRequest ( String vpcId , String cidrBlock ) { setVpcId ( vpcId ) ; setCidrBlock ( cidrBlock ) ; }
public StempelStemmer ( Trie stemmer ) { this . stemmer = stemmer ; }
public NLPNERTaggerOp ( TokenNameFinderModel model ) { this . nameFinder = new NameFinderME ( model ) ; }
public TreeFilter clone ( ) { return new FollowFilter ( path . clone ( ) , cfg ) ; }
public QueryAddUserInfoRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " QueryAddUserInfo " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public boolean include ( TreeWalk walker ) { DirCacheIterator i = walker . getTree ( treeIdx , DirCacheIterator . class ) ; if ( i == null ) return true ; DirCacheEntry e = i . getDirCacheEntry ( ) ; return e == null || ! e . isSkipWorkTree ( ) ; }
public final CompareResult compareTo ( ValueEval other ) { if ( other == null ) { throw new RuntimeException ( " compare ▁ to ▁ value ▁ cannot ▁ be ▁ null " ) ; } if ( _targetClass != other . getClass ( ) ) { return CompareResult . TYPE_MISMATCH ; } return compareSameType ( other ) ; }
public SegmentReadState ( SegmentReadState other , String newSegmentSuffix ) { this . directory = other . directory ; this . segmentInfo = other . segmentInfo ; this . fieldInfos = other . fieldInfos ; this . context = other . context ; this . segmentSuffix = newSegmentSuffix ; }
public void println ( Object obj ) { println ( String . valueOf ( obj ) ) ; }
public DeleteModelResult deleteModel ( DeleteModelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteModel ( request ) ; }
public void setFiles ( Collection < String > files ) { setFiles = new HashSet <> ( ) ; addFiles ( files ) ; }
public void release ( ) { lItr . release ( ) ; }
public FloatBuffer asReadOnlyBuffer ( ) { return duplicate ( ) ; }
public int get ( int key , int valueIfKeyNotFound ) { int i = binarySearch ( mKeys , 0 , mSize , key ) ; if ( i < 0 ) { return valueIfKeyNotFound ; } else { return mValues [ i ] ; } }
public CharBuffer get ( char [ ] dst ) { return get ( dst , 0 , dst . length ) ; }
public static String toHex ( String value ) { return ( value == null || value . length ( ) == 0 ) ? " [ ] " : toHex ( value . getBytes ( LocaleUtil . CHARSET_1252 ) ) ; }
public String resolveNameXText ( NameXPtg n ) { return _iBook . resolveNameXText ( n . getSheetRefIndex ( ) , n . getNameIndex ( ) ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( " ▁ [ " ) . append ( _representation ) . append ( " ] " ) ; return sb . toString ( ) ; }
public PutEmailIdentityMailFromAttributesResult putEmailIdentityMailFromAttributes ( PutEmailIdentityMailFromAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executePutEmailIdentityMailFromAttributes ( request ) ; }
public RemoveAlbumPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " RemoveAlbumPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DeleteAttributesResult deleteAttributes ( DeleteAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAttributes ( request ) ; }
public void disableRefLog ( ) { destination . setRefLogMessage ( " " , false ) ; }
public TokenStream create ( TokenStream input ) { return new GermanLightStemFilter ( input ) ; }
public E removeLast ( ) { return removeLastImpl ( ) ; }
public UpdateDomainMetadataResult updateDomainMetadata ( UpdateDomainMetadataRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDomainMetadata ( request ) ; }
public short findNewDrawingGroupId ( ) { return dgg . findNewDrawingGroupId ( ) ; }
public String toString ( ) { return " FacetEntry { " + " value = " + value . utf8ToString ( ) + " , ▁ count = " + count + ' } ' ; }
public SharedFormulaRecord linkSharedFormulaRecord ( CellReference firstCell , FormulaRecordAggregate agg ) { SharedFormulaGroup result = findFormulaGroupForCell ( firstCell ) ; if ( null == result ) { throw new RuntimeException ( " Failed ▁ to ▁ find ▁ a ▁ matching ▁ shared ▁ formula ▁ record " ) ; } result . add ( agg ) ; return result . getSFR ( ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeShort ( field_1_label_index ) ; out . writeShort ( field_2_zero ) ; }
public Appendable append ( char c ) { write ( c ) ; return this ; }
public static BigInteger factorial ( int n ) { if ( n == 0 || n < 0 ) { return BigInteger . ONE ; } if ( cache . containsKey ( n ) ) { return cache . get ( n ) ; } BigInteger result = BigInteger . valueOf ( n ) . multiply ( factorial ( n - 2 ) ) ; cache . put ( n , result ) ; return result ; }
public DelimitedPayloadTokenFilter create ( TokenStream input ) { return new DelimitedPayloadTokenFilter ( input , delimiter , encoder ) ; }
public String toString ( ) { return " NONE " ; }
public GetAlarmsResult getAlarms ( GetAlarmsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAlarms ( request ) ; }
public DeleteDetectorVersionResult deleteDetectorVersion ( DeleteDetectorVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDetectorVersion ( request ) ; }
public ExpandedDouble createExpandedDouble ( ) { return new ExpandedDouble ( _significand , _binaryExponent ) ; }
public CharBuffer duplicate ( ) { ByteBuffer bb = byteBuffer . duplicate ( ) . order ( byteBuffer . order ( ) ) ; CharToByteBufferAdapter buf = new CharToByteBufferAdapter ( bb ) ; buf . limit = limit ; buf . position = position ; buf . mark = mark ; return buf ; }
public int size ( ) { return Hashtable . this . size ( ) ; }
public ResetInstanceAttributeRequest ( String instanceId , InstanceAttributeName attribute ) { setInstanceId ( instanceId ) ; setAttribute ( attribute . toString ( ) ) ; }
public final List < FooterLine > getFooterLines ( ) { final byte [ ] raw = buffer ; int ptr = raw . length - 1 ; while ( raw [ ptr ] == ' \ n ' ) ptr -- ; final int msgB = RawParseUtils . commitMessage ( raw , 0 ) ; final ArrayList < FooterLine > r = new ArrayList <> ( 4 ) ; final Charset enc = guessEncoding ( ) ; for ( ; ; ) { ptr = RawParseUtils . prevLF ( raw , ptr ) ; if ( ptr <= msgB ) break ; final int keyStart = ptr + 2 ; if ( raw [ keyStart ] == ' \ n ' ) break ; final int keyEnd = RawParseUtils . endOfFooterLineKey ( raw , keyStart ) ; if ( keyEnd < 0 ) continue ; int valStart = keyEnd + 1 ; while ( valStart < raw . length && raw [ valStart ] == ' ▁ ' ) valStart ++ ; int valEnd = RawParseUtils . nextLF ( raw , valStart ) ; if ( raw [ valEnd - 1 ] == ' \ n ' ) valEnd -- ; r . add ( new FooterLine ( raw , enc , keyStart , keyEnd , valStart , valEnd ) ) ; } Collections . reverse ( r ) ; return r ; }
public SupBookRecord getExternalBookRecord ( ) { return _externalBookRecord ; }
public Builder ( ) { this ( false ) ; }
public ApplySecurityGroupsToLoadBalancerResult applySecurityGroupsToLoadBalancer ( ApplySecurityGroupsToLoadBalancerRequest request ) { request = beforeClientExecution ( request ) ; return executeApplySecurityGroupsToLoadBalancer ( request ) ; }
public DeleteDedicatedIpPoolResult deleteDedicatedIpPool ( DeleteDedicatedIpPoolRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDedicatedIpPool ( request ) ; }
public DescribeStackInstanceResult describeStackInstance ( DescribeStackInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStackInstance ( request ) ; }
public HSSFChildAnchor ( EscherChildAnchorRecord escherChildAnchorRecord ) { this . _escherChildAnchor = escherChildAnchorRecord ; }
public SynonymQuery build ( ) { Collections . sort ( terms , Comparator . comparing ( a -> a . term ) ) ; return new SynonymQuery ( terms . toArray ( new TermAndBoost [ 0 ] ) , field ) ; }
public void addCell ( int rowIndex , int columnIndex ) { if ( rowIndex > _lastDefinedRow ) return ; if ( _currentRowIndex == - 1 ) { _currentRowIndex = rowIndex ; _firstColumnIndex = columnIndex ; _lastColumnIndex = columnIndex ; } else { if ( _currentRowIndex == rowIndex && _lastColumnIndex + 1 == columnIndex ) { _lastColumnIndex = columnIndex ; } else { if ( _currentRectangleGroup == null ) { _currentRectangleGroup = new BlankCellRectangleGroup ( _currentRowIndex , _firstColumnIndex , _lastColumnIndex ) ; } else { if ( ! _currentRectangleGroup . acceptRow ( _currentRowIndex , _firstColumnIndex , _lastColumnIndex ) ) { _rectangleGroups . add ( _currentRectangleGroup ) ; _currentRectangleGroup = new BlankCellRectangleGroup ( _currentRowIndex , _firstColumnIndex , _lastColumnIndex ) ; } } _currentRowIndex = rowIndex ; _firstColumnIndex = columnIndex ; _lastColumnIndex = columnIndex ; } } }
public String toString ( ) { return " BLOCK : ▁ prefix = " + brToString ( prefix ) ; }
public void set ( int index , long value ) { final int o = index / 21 ; final int b = index % 21 ; final int shift = b * 3 ; blocks [ o ] = ( blocks [ o ] & ~ ( 7L << shift ) ) | ( value << shift ) ; }
@ Override public boolean contains ( Object o ) { if ( ! ( o instanceof Entry ) ) { return false ; } Entry <? , ?> e = ( Entry <? , ?> ) o ; Object key = e . getKey ( ) ; if ( key == null ) { return false ; } V v = Impl . this . get ( key ) ; return v != null && strategy . equalValues ( v , e . getValue ( ) ) ; }
public void clear ( ) { if ( value != null ) { Arrays . fill ( value , ( char ) 0 ) ; value = null ; } }
public DescribeDirectConnectGatewayAssociationsResult describeDirectConnectGatewayAssociations ( DescribeDirectConnectGatewayAssociationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDirectConnectGatewayAssociations ( request ) ; }
public GetRestApiResult getRestApi ( GetRestApiRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRestApi ( request ) ; }
public CreateLaunchTemplateVersionResult createLaunchTemplateVersion ( CreateLaunchTemplateVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLaunchTemplateVersion ( request ) ; }
public SetLoadBalancerPoliciesOfListenerResult setLoadBalancerPoliciesOfListener ( SetLoadBalancerPoliciesOfListenerRequest request ) { request = beforeClientExecution ( request ) ; return executeSetLoadBalancerPoliciesOfListener ( request ) ; }
public SoraniNormalizationFilter ( TokenStream input ) { super ( input ) ; }
public UpdateTerminationProtectionResult updateTerminationProtection ( UpdateTerminationProtectionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTerminationProtection ( request ) ; }
public void addChildRecord ( EscherRecord record ) { _childRecords . add ( record ) ; }
public SetIdentityMailFromDomainResult setIdentityMailFromDomain ( SetIdentityMailFromDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeSetIdentityMailFromDomain ( request ) ; }
public E remove ( int location ) { if ( location >= 0 && location < size ) { Link < E > link = voidLink ; if ( location < ( size / 2 ) ) { for ( int i = 0 ; i <= location ; i ++ ) { link = link . next ; } } else { for ( int i = size ; i > location ; i -- ) { link = link . previous ; } } Link < E > previous = link . previous ; Link < E > next = link . next ; previous . next = next ; next . previous = previous ; size -- ; modCount ++ ; return link . data ; } throw new IndexOutOfBoundsException ( ) ; }
public UpdateJobResult updateJob ( UpdateJobRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateJob ( request ) ; }
public AddNoteCommand setNotesRef ( String notesRef ) { checkCallable ( ) ; this . notesRef = notesRef ; return this ; }
public ListInvitationsResult listInvitations ( ListInvitationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListInvitations ( request ) ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof ExtRst ) ) { return false ; } ExtRst other = ( ExtRst ) obj ; return ( compareTo ( other ) == 0 ) ; }
public synchronized void close ( ) throws IOException { buffer = null ; isClosed = true ; notifyAll ( ) ; }
public ListTrialsResult listTrials ( ListTrialsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTrials ( request ) ; }
public CreateDocumentClassifierResult createDocumentClassifier ( CreateDocumentClassifierRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDocumentClassifier ( request ) ; }
public GetPasswordDataResult getPasswordData ( GetPasswordDataRequest request ) { request = beforeClientExecution ( request ) ; return executeGetPasswordData ( request ) ; }
public final String text ( ) { return toString ( bytes ) ; }
public HSSFPicture ( HSSFShape parent , HSSFAnchor anchor ) { super ( parent , anchor ) ; super . setShapeType ( OBJECT_TYPE_PICTURE ) ; CommonObjectDataSubRecord cod = ( CommonObjectDataSubRecord ) getObjRecord ( ) . getSubRecords ( ) . get ( 0 ) ; cod . setObjectType ( CommonObjectDataSubRecord . OBJECT_TYPE_PICTURE ) ; }
public CharSequence subSequence ( int start , int end ) { return new RawCharSequence ( buffer , startPtr + start , startPtr + end ) ; }
public DeleteAccessPointResult deleteAccessPoint ( DeleteAccessPointRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAccessPoint ( request ) ; }
public DescribeSubnetsResult describeSubnets ( ) { return describeSubnets ( new DescribeSubnetsRequest ( ) ) ; }
public AddTagsToOnPremisesInstancesResult addTagsToOnPremisesInstances ( AddTagsToOnPremisesInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeAddTagsToOnPremisesInstances ( request ) ; }
public static String coerceValueToString ( ValueEval ve ) { if ( ve instanceof StringValueEval ) { StringValueEval sve = ( StringValueEval ) ve ; return sve . getStringValue ( ) ; } if ( ve == BlankEval . instance ) { return " " ; } }
public CreateVpcLinkResult createVpcLink ( CreateVpcLinkRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVpcLink ( request ) ; }
public DescribeTrafficMirrorTargetsResult describeTrafficMirrorTargets ( DescribeTrafficMirrorTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTrafficMirrorTargets ( request ) ; }
public SetRepositoryPolicyResult setRepositoryPolicy ( SetRepositoryPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeSetRepositoryPolicy ( request ) ; }
public String toFormulaString ( ) { return " UNKNOWN " ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { try { double d0 = NumericFunction . singleOperandEvaluate ( arg0 , srcRowIndex , srcColumnIndex ) ; double d1 = NumericFunction . singleOperandEvaluate ( arg1 , srcRowIndex , srcColumnIndex ) ; return new NumberEval ( evaluate ( d0 , d1 , false ) ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public void set ( int index , long value ) { final int o = index / 5 ; final int b = index % 5 ; final int shift = b * 12 ; blocks [ o ] = ( blocks [ o ] & ~ ( 4095L << shift ) ) | ( value << shift ) ; }
public ProtectionRev4Record ( boolean protect ) { this ( 0 ) ; setProtect ( protect ) ; }
public UpdateAuditStreamConfigurationResult updateAuditStreamConfiguration ( UpdateAuditStreamConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateAuditStreamConfiguration ( request ) ; }
public Sheet build ( ) { Sheet sheet = ( sheetName == null ) ? workbook . createSheet ( ) : workbook . createSheet ( sheetName ) ; Row currentRow ; Cell currentCell ; for ( int rowIndex = 0 ; rowIndex < cells . length ; ++ rowIndex ) { Object [ ] rowArray = cells [ rowIndex ] ; currentRow = sheet . createRow ( rowIndex ) ; for ( int cellIndex = 0 ; cellIndex < rowArray . length ; ++ cellIndex ) { Object cellValue = rowArray [ cellIndex ] ; if ( cellValue != null || shouldCreateEmptyCells ) { currentCell = currentRow . createCell ( cellIndex ) ; setCellValue ( currentCell , cellValue ) ; } } } return sheet ; }
public CharArrayWriter ( int initialSize ) { if ( initialSize < 0 ) { throw new IllegalArgumentException ( " size ▁ < ▁ 0 " ) ; } buf = new char [ initialSize ] ; lock = buf ; }
public AtomicReference ( V initialValue ) { value = initialValue ; }
public static ISignatureComposer getComposer ( ) { if ( null == composer ) { composer = new RpcSignatureComposer ( ) ; } return composer ; }
public ListHITsForQualificationTypeResult listHITsForQualificationType ( ListHITsForQualificationTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeListHITsForQualificationType ( request ) ; }
public AddTagsToStreamResult addTagsToStream ( AddTagsToStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeAddTagsToStream ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; final String nl = System . getProperty ( " line . separator " ) ; buffer . append ( ' [ ' + getRecordName ( ) + ' ] ' + nl ) ; if ( escherRecords . size ( ) == 0 ) buffer . append ( " No ▁ Escher ▁ Records ▁ Decoded " + nl ) ; for ( EscherRecord r : escherRecords ) { buffer . append ( r ) ; } buffer . append ( " [ / " + getRecordName ( ) + ' ] ' + nl ) ; return buffer . toString ( ) ; }
public WSBoolRecord ( RecordInputStream in ) { byte [ ] data = in . readRemainder ( ) ; field_1_wsbool = data [ 1 ] ; field_2_wsbool = data [ 0 ] ; }
public BrazilianStemFilter create ( TokenStream in ) { return new BrazilianStemFilter ( in ) ; }
public ResetCommand setRef ( String ref ) { this . ref = ref ; return this ; }
public EnableOrganizationAdminAccountResult enableOrganizationAdminAccount ( EnableOrganizationAdminAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableOrganizationAdminAccount ( request ) ; }
public ValueEval getInnerValueEval ( int sheetIndex ) { return _evaluator . getEvalForCell ( sheetIndex , getRow ( ) , getColumn ( ) ) ; }
public DeleteRecommenderConfigurationResult deleteRecommenderConfiguration ( DeleteRecommenderConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRecommenderConfiguration ( request ) ; }
public UpdateIntegrationResponseResult updateIntegrationResponse ( UpdateIntegrationResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateIntegrationResponse ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ INTERFACEHDR ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . codepage ▁ = ▁ " ) . append ( HexDump . shortToHex ( _codepage ) ) . append ( " \ n " ) ; buffer . append ( " [ / INTERFACEHDR ] \ n " ) ; return buffer . toString ( ) ; }
public String outputToString ( BytesRef output ) { return output . toString ( ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " dim = " ) ; sb . append ( dim ) ; sb . append ( " ▁ path = " ) ; sb . append ( Arrays . toString ( path ) ) ; sb . append ( " ▁ value = " ) ; sb . append ( value ) ; sb . append ( " ▁ childCount = " ) ; sb . append ( childCount ) ; sb . append ( ' \ n ' ) ; for ( LabelAndValue labelValue : labelValues ) { sb . append ( " ▁ ▁ " ) . append ( labelValue ) . append ( " \ n " ) ; } return sb . toString ( ) ; }
public AcceptVpcEndpointConnectionsResult acceptVpcEndpointConnections ( AcceptVpcEndpointConnectionsRequest request ) { request = beforeClientExecution ( request ) ; return executeAcceptVpcEndpointConnections ( request ) ; }
public DescribeIdentityProviderConfigurationResult describeIdentityProviderConfiguration ( DescribeIdentityProviderConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIdentityProviderConfiguration ( request ) ; }
public void clear ( ) { head = null ; free . clear ( ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " [ " + getFile ( ) . getPath ( ) + " ] " ; }
public GetRelationalDatabaseBlueprintsResult getRelationalDatabaseBlueprints ( GetRelationalDatabaseBlueprintsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabaseBlueprints ( request ) ; }
public void concatenate ( byte [ ] array ) { if ( array == null ) { throw new IllegalArgumentException ( " array ▁ cannot ▁ be ▁ null " ) ; } arrays . add ( array ) ; }
public final ByteBuffer get ( byte [ ] dst , int dstOffset , int byteCount ) { checkGetBounds ( 1 , dst . length , dstOffset , byteCount ) ; System . arraycopy ( backingArray , offset + position , dst , dstOffset , byteCount ) ; position += byteCount ; return this ; }
public DescribeAutoScalingNotificationTypesResult describeAutoScalingNotificationTypes ( ) { return describeAutoScalingNotificationTypes ( new DescribeAutoScalingNotificationTypesRequest ( ) ) ; }
public int compareTo ( LookupResult o ) { return CHARSEQUENCE_COMPARATOR . compare ( key , o . key ) ; }
public UpdateVariableResult updateVariable ( UpdateVariableRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateVariable ( request ) ; }
public TranslateTextRequest ( ) { super ( " hiknoengine " , " 2019 - 06 - 25 " , " TranslateText " , " hiknoengine " ) ; setMethod ( MethodType . POST ) ; }
public E set ( int location , E object ) { E result = a [ location ] ; a [ location ] = object ; return result ; }
public static Document loadXML ( Reader is ) { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = null ; try { db = dbf . newDocumentBuilder ( ) ; } catch ( Exception se ) { throw new RuntimeException ( " Parser ▁ configuration ▁ error " , se ) ; } org . w3c . dom . Document doc = null ; try { doc = db . parse ( new InputSource ( is ) ) ; } catch ( Exception se ) { throw new RuntimeException ( " Error ▁ parsing ▁ file : " + se , se ) ; } return doc ; }
public void setTokenStream ( TokenStream tokenStream ) { if ( type . indexOptions ( ) == IndexOptions . NONE || ! type . tokenized ( ) ) { throw new IllegalArgumentException ( " TokenStream ▁ fields ▁ must ▁ be ▁ indexed ▁ and ▁ tokenized " ) ; } this . tokenStream = tokenStream ; }
public ValueEval getArea3DEval ( Area3DPtg aptg ) { SheetRangeEvaluator sre = createExternSheetRefEvaluator ( aptg . getExternSheetIndex ( ) ) ; return new LazyAreaEval ( aptg . getFirstRow ( ) , aptg . getFirstColumn ( ) , aptg . getLastRow ( ) , aptg . getLastColumn ( ) , sre ) ; }
public MulBlankRecord ( int row , int firstCol , short [ ] xfs ) { _row = row ; _firstCol = firstCol ; _xfs = xfs ; _lastCol = firstCol + xfs . length - 1 ; }
public EngineDefaults describeEngineDefaultParameters ( DescribeEngineDefaultParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEngineDefaultParameters ( request ) ; }
public AttachVolumeResult attachVolume ( AttachVolumeRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachVolume ( request ) ; }
public long ramBytesUsed ( ) { return ( ( termOffsets != null ) ? termOffsets . ramBytesUsed ( ) : 0 ) + ( ( termsDictOffsets != null ) ? termsDictOffsets . ramBytesUsed ( ) : 0 ) ; }
public DeleteWorkerBlockResult deleteWorkerBlock ( DeleteWorkerBlockRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteWorkerBlock ( request ) ; }
public static void unregister ( TransportProtocol proto ) { for ( WeakReference < TransportProtocol > ref : protocols ) { TransportProtocol refProto = ref . get ( ) ; if ( refProto == null || refProto == proto ) protocols . remove ( ref ) ; } }
public CreateNetworkInterfacePermissionResult createNetworkInterfacePermission ( CreateNetworkInterfacePermissionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNetworkInterfacePermission ( request ) ; }
public void parseLine ( DocData docData , String line ) { String [ ] parts = line . split ( " \\ t " , 7 ) ; docData . setID ( Integer . parseInt ( parts [ 0 ] ) ) ; docData . setName ( parts [ 1 ] ) ; String latitude = parts [ 4 ] ; String longitude = parts [ 5 ] ; docData . setBody ( " POINT ( " + longitude + " ▁ " + latitude + " ) " ) ; }
public DeleteArchiveRequest ( String accountId , String vaultName , String archiveId ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; setArchiveId ( archiveId ) ; }
public static void close ( @ NonNull Repository db ) { if ( db . getDirectory ( ) != null ) { FileKey key = FileKey . exact ( db . getDirectory ( ) , db . getFS ( ) ) ; cache . unregisterAndCloseRepository ( key ) ; } }
public OrQueryNode ( List < QueryNode > clauses ) { super ( clauses ) ; if ( ( clauses == null ) || ( clauses . size ( ) == 0 ) ) { throw new IllegalArgumentException ( " OR ▁ query ▁ must ▁ have ▁ at ▁ least ▁ one ▁ clause " ) ; } }
public ReplicationGroup createReplicationGroup ( CreateReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateReplicationGroup ( request ) ; }
public ListCollectionsResult listCollections ( ListCollectionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListCollections ( request ) ; }
public void setParentIds ( AnyObjectId parent1 , AnyObjectId parent2 ) { parentIds = new ObjectId [ ] { parent1. copy ( ) , parent2. copy ( ) } ; }
public TokenOffsetPayloadTokenFilter create ( TokenStream input ) { return new TokenOffsetPayloadTokenFilter ( input ) ; }
public CreateDataSourceResult createDataSource ( CreateDataSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDataSource ( request ) ; }
public DeleteBranchCommand setBranchNames ( String ... branchnames ) { checkCallable ( ) ; this . branchNames . clear ( ) ; this . branchNames . addAll ( Arrays . asList ( branchnames ) ) ; return this ; }
public void setCoordinates ( int x1 , int y1 , int x2 , int y2 ) { _spgrRecord . setRectX1 ( x1 ) ; _spgrRecord . setRectX2 ( x2 ) ; _spgrRecord . setRectY1 ( y1 ) ; _spgrRecord . setRectY2 ( y2 ) ; }
public DescribeNotificationConfigurationsResult describeNotificationConfigurations ( ) { return describeNotificationConfigurations ( new DescribeNotificationConfigurationsRequest ( ) ) ; }
public GetStatusResult getStatus ( GetStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeGetStatus ( request ) ; }
public final ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { switch ( args . length ) { case 1 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] ) ; case 2 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] ) ; } return ErrorEval . VALUE_INVALID ; }
public ExternalSheet getExternalSheet ( int externSheetIndex ) { String [ ] extNames = linkTable . getExternalBookAndSheetName ( externSheetIndex ) ; if ( extNames == null ) { return null ; } if ( extNames . length == 2 ) { return new ExternalSheet ( extNames [ 0 ] , extNames [ 1 ] ) ; } else { return new ExternalSheetRange ( extNames [ 0 ] , extNames [ 1 ] , extNames [ 2 ] ) ; } }
public static int delete ( char s [ ] , int pos , int len ) { assert pos < len ; if ( pos < len - 1 ) { System . arraycopy ( s , pos + 1 , s , pos , len - pos - 1 ) ; } return len - 1 ; }
public HSSFConditionalFormatting getConditionalFormattingAt ( int index ) { CFRecordsAggregate cf = _conditionalFormattingTable . get ( index ) ; if ( cf == null ) { return null ; } return new HSSFConditionalFormatting ( _sheet , cf ) ; }
public static Cell createCell ( Row row , int column , String value , CellStyle style ) { Cell cell = getCell ( row , column ) ; cell . setCellValue ( cell . getRow ( ) . getSheet ( ) . getWorkbook ( ) . getCreationHelper ( ) . createRichTextString ( value ) ) ; if ( style != null ) { cell . setCellStyle ( style ) ; } return cell ; }
public void setFillColor ( int red , int green , int blue ) { int fillColor = ( ( blue ) << 16 ) | ( ( green ) << 8 ) | red ; setPropertyValue ( new EscherRGBProperty ( EscherPropertyTypes . FILL__FILLCOLOR , fillColor ) ) ; }
public ErrorResponseBody error ( ) { return this . error ; }
public void write ( int b ) throws IOException { try { beginWrite ( ) ; dst . write ( b ) ; } catch ( InterruptedIOException e ) { throw writeTimedOut ( e ) ; } finally { endWrite ( ) ; } }
public void add ( String key , ParserExtension extension ) { this . extensions . put ( key , extension ) ; }
public SignOutUserResult signOutUser ( SignOutUserRequest request ) { request = beforeClientExecution ( request ) ; return executeSignOutUser ( request ) ; }
public PutImageTagMutabilityResult putImageTagMutability ( PutImageTagMutabilityRequest request ) { request = beforeClientExecution ( request ) ; return executePutImageTagMutability ( request ) ; }
public CreateIAMPolicyAssignmentResult createIAMPolicyAssignment ( CreateIAMPolicyAssignmentRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateIAMPolicyAssignment ( request ) ; }
public GetRoomResult getRoom ( GetRoomRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRoom ( request ) ; }
public DescribeLaunchConfigurationsResult describeLaunchConfigurations ( ) { return describeLaunchConfigurations ( new DescribeLaunchConfigurationsRequest ( ) ) ; }
public UpdateTaskSetResult updateTaskSet ( UpdateTaskSetRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTaskSet ( request ) ; }
public boolean equals ( Object other_ ) { if ( other_ == this ) { return true ; } else if ( ! ( other_ instanceof FSTTermOutputs . TermData ) ) { return false ; } TermData other = ( TermData ) other_ ; return statsEqual ( this , other ) && bytesEqual ( this , other ) ; }
public int getSequenceIndex ( ) { return sequenceIndex ; }
public DeleteAutoScalingGroupResult deleteAutoScalingGroup ( DeleteAutoScalingGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAutoScalingGroup ( request ) ; }
public int nextDoc ( ) { while ( true ) { if ( queue . size ( ) == 0 ) { doc = NO_MORE_DOCS ; break ; } int newDoc = queue . top ( ) . docID ( ) ; if ( newDoc != doc ) { assert newDoc > doc : " doc = " + doc + " ▁ newDoc = " + newDoc ; doc = newDoc ; break ; } if ( queue . top ( ) . nextDoc ( ) == NO_MORE_DOCS ) { queue . pop ( ) ; } else { queue . updateTop ( ) ; } } return doc ; }
public Collection < ChildScorable > getChildren ( ) { return Collections . singleton ( new ChildScorable ( parentScorer , " BLOCK □ JOIN " ) ) ; }
public void endTask ( ) { if ( ! isMainThread ( ) ) throw new IllegalStateException ( ) ; pm . endTask ( ) ; }
public UpdateConfigurationSetEventDestinationResult updateConfigurationSetEventDestination ( UpdateConfigurationSetEventDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateConfigurationSetEventDestination ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getBackup ( ) ) ; }
public DescribeBundleTasksResult describeBundleTasks ( DescribeBundleTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeBundleTasks ( request ) ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats ) { final long df = termStats . docFreq ( ) ; final long docCount = collectionStats . docCount ( ) ; final float idf = idf ( df , docCount ) ; return Explanation . match ( idf , " idf , ▁ computed ▁ as ▁ log ( 1 ▁ + ▁ ( N ▁ - ▁ n ▁ + ▁ 0.5 ) ▁ / ▁ ( n ▁ + ▁ 0.5 ) ) ▁ from : " , Explanation . match ( df , " n , ▁ number ▁ of ▁ documents ▁ containing ▁ term " ) , Explanation . match ( docCount , " N , ▁ total ▁ number ▁ of ▁ documents ▁ with ▁ field " ) ) ; }
public DescribeFleetEventsResult describeFleetEvents ( DescribeFleetEventsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFleetEvents ( request ) ; }
public BasicCredentials ( String accessKeyId , String accessKeySecret ) { if ( accessKeyId == null ) { throw new IllegalArgumentException ( " Access ▁ key ▁ ID ▁ cannot ▁ be ▁ null . " ) ; } if ( accessKeySecret == null ) { throw new IllegalArgumentException ( " Access ▁ key ▁ secret ▁ cannot ▁ be ▁ null . " ) ; } this . accessKeyId = accessKeyId ; this . accessKeySecret = accessKeySecret ; }
public String getOldPath ( ) { return oldPath ; }
public int nextIndex ( ) { return iterator . nextIndex ( ) - start ; }
public Snapshot deleteClusterSnapshot ( DeleteClusterSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteClusterSnapshot ( request ) ; }
public String getColsNamesForValsByRound ( ) { if ( colForValByRound . size ( ) == 0 ) { return " " ; } StringBuilder sb = new StringBuilder ( ) ; for ( final String colName : colForValByRound . values ( ) ) { sb . append ( ' ▁ ' ) . append ( colName ) ; } return sb . toString ( ) ; }
public void deprecateActivityType ( DeprecateActivityTypeRequest request ) { request = beforeClientExecution ( request ) ; executeDeprecateActivityType ( request ) ; }
public PartETag ( int partNumber , String eTag ) { this . partNumber = partNumber ; this . eTag = eTag ; }
@ Override public boolean remove ( Object object ) { if ( object instanceof Multiset . Entry ) { Multiset . Entry <?> entry = ( Multiset . Entry <?> ) object ; Object element = entry . getElement ( ) ; int entryCount = entry . getCount ( ) ; return countMap . remove ( element , entryCount ) ; } return false ; }
public ListAccessControlRulesResult listAccessControlRules ( ListAccessControlRulesRequest request ) { request = beforeClientExecution ( request ) ; return executeListAccessControlRules ( request ) ; }
public final CharBuffer get ( char [ ] dst , int srcOffset , int charCount ) { if ( charCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } System . arraycopy ( backingArray , offset + position , dst , srcOffset , charCount ) ; position += charCount ; return this ; }
public DescribeDBClusterBacktracksResult describeDBClusterBacktracks ( DescribeDBClusterBacktracksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBClusterBacktracks ( request ) ; }
public boolean equals ( ATNConfig other ) { if ( this == other ) { return true ; } else if ( other == null ) { return false ; } return this . state . stateNumber == other . state . stateNumber && this . alt == other . alt && ( this . context == other . context || ( this . context != null && this . context . equals ( other . context ) ) ) && this . semanticContext . equals ( other . semanticContext ) && this . isPrecedenceFilterSuppressed ( ) == other . isPrecedenceFilterSuppressed ( ) ; }
public AbbreviatedObjectId getId ( Side side ) { return side == Side . OLD ? getOldId ( ) : getNewId ( ) ; }
public CatLabRecord ( RecordInputStream in ) { rt = in . readShort ( ) ; grbitFrt = in . readShort ( ) ; wOffset = in . readShort ( ) ; at = in . readShort ( ) ; grbit = in . readShort ( ) ; if ( in . available ( ) == 0 ) { unused = null ; } else { unused = in . readShort ( ) ; } }
public String substring ( int start , int end ) { if ( start >= 0 && start <= end && end <= count ) { if ( start == end ) { return " " ; } return new String ( value , start , end - start ) ; } throw startEndAndLength ( start , end ) ; }
public int remove ( final int index ) { if ( index >= _limit ) { throw new IndexOutOfBoundsException ( ) ; } int rval = _array [ index ] ; System . arraycopy ( _array , index + 1 , _array , index , _limit - index ) ; _limit -- ; return rval ; }
public K getKey ( ) { return super . get ( ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeInt ( unused1 ) ; out . writeInt ( unused2 ) ; }
public void setDeltaCacheLimit ( int size ) { deltaCacheLimit = size ; }
public String toString ( ) { return " L " ; }
public Map < String , String > read ( String response , String endpoint ) { return read ( new StringCharacterIterator ( response ) , endpoint , FIRST_POSITION ) ; }
public DeleteMessageResult deleteMessage ( DeleteMessageRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMessage ( request ) ; }
public SearchFind ( boolean isCaseSensitive ) { _isCaseSensitive = isCaseSensitive ; }
public void setRoleName ( String roleName ) { if ( null == roleName ) { throw new NullPointerException ( " You ▁ must ▁ specifiy ▁ a ▁ valid ▁ role ▁ name . " ) ; } this . roleName = roleName ; setCredentialUrl ( ) ; }
public AllocatePublicVirtualInterfaceResult allocatePublicVirtualInterface ( AllocatePublicVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeAllocatePublicVirtualInterface ( request ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 2 ) | ( byte1 >>> 6 ) ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 63 ) << 4 ) | ( byte2 >>> 4 ) ; final long byte3 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte2 & 15 ) << 6 ) | ( byte3 >>> 2 ) ; final long byte4 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte3 & 3 ) << 8 ) | byte4 ; } }
public DeleteLoadBalancerRequest ( String loadBalancerName ) { setLoadBalancerName ( loadBalancerName ) ; }
public PutDeliverabilityDashboardOptionResult putDeliverabilityDashboardOption ( PutDeliverabilityDashboardOptionRequest request ) { request = beforeClientExecution ( request ) ; return executePutDeliverabilityDashboardOption ( request ) ; }
public XPathRuleElement ( String ruleName , int ruleIndex ) { super ( ruleName ) ; this . ruleIndex = ruleIndex ; }
public PullCommand setProgressMonitor ( ProgressMonitor monitor ) { if ( monitor == null ) { monitor = NullProgressMonitor . INSTANCE ; } this . monitor = monitor ; return this ; }
public static final RevFilter after ( long ts ) { return new After ( ts ) ; }
public final String toString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . append ( getClass ( ) . getName ( ) ) . append ( " ▁ [ len = " ) ; sb . append ( field_2_subex_len ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public DeleteRoomResult deleteRoom ( DeleteRoomRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRoom ( request ) ; }
public ScandinavianNormalizationFilter create ( TokenStream input ) { return new ScandinavianNormalizationFilter ( input ) ; }
public ValidateTemplateResult validateTemplate ( ValidateTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeValidateTemplate ( request ) ; }
public ListBranchCommand branchList ( ) { return new ListBranchCommand ( repo ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " [ " + getEntryPathString ( ) + " ] " ; }
public final Edit before ( Edit cut ) { return new Edit ( beginA , cut . beginA , beginB , cut . beginB ) ; }
public String toString ( ) { if ( symbol . getType ( ) == Token . EOF ) return " < EOF > " ; return symbol . getText ( ) ; }
public DeleteDeploymentStrategyResult deleteDeploymentStrategy ( DeleteDeploymentStrategyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDeploymentStrategy ( request ) ; }
public GetModelResult getModel ( GetModelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetModel ( request ) ; }
public DescribeUserResult describeUser ( DescribeUserRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeUser ( request ) ; }
public ListSnapshotBlocksResult listSnapshotBlocks ( ListSnapshotBlocksRequest request ) { request = beforeClientExecution ( request ) ; return executeListSnapshotBlocks ( request ) ; }
public ByteBuffer putShort ( int index , short value ) { checkIndex ( index , SizeOf . SHORT ) ; Memory . pokeShort ( backingArray , offset + index , value , order ) ; return this ; }
public ResetCommand reset ( ) { return new ResetCommand ( repo ) ; }
public Snapshot createClusterSnapshot ( CreateClusterSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateClusterSnapshot ( request ) ; }
public void setCachedResultTypeEmptyString ( ) { specialCachedValue = FormulaSpecialCachedValue . createCachedEmptyValue ( ) ; }
public DeleteIdentityPolicyResult deleteIdentityPolicy ( DeleteIdentityPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteIdentityPolicy ( request ) ; }
public int IncRef ( ) { if ( ! initDone ) { initDone = true ; } else { assert count > 0 : Thread . currentThread ( ) . getName ( ) + " : ▁ RefCount ▁ is ▁ 0 ▁ pre - increment ▁ for ▁ file ▁ \ " " + fileName + " \ " " ; } return ++ count ; }
public void fromRaw ( byte [ ] bs ) { fromRaw ( bs , 0 ) ; }
public LeftMarginRecord clone ( ) { return copy ( ) ; }
public FailedPredicateException ( Parser recognizer , String predicate , String message ) { super ( formatMessage ( predicate , message ) , recognizer , recognizer . getInputStream ( ) , recognizer . _ctx ) ; ATNState s = recognizer . getInterpreter ( ) . atn . states . get ( recognizer . getState ( ) ) ; AbstractPredicateTransition trans = ( AbstractPredicateTransition ) s . transition ( 0 ) ; if ( trans instanceof PredicateTransition ) { this . ruleIndex = ( ( PredicateTransition ) trans ) . ruleIndex ; this . predicateIndex = ( ( PredicateTransition ) trans ) . predIndex ; } else { this . ruleIndex = 0 ; this . predicateIndex = 0 ; } this . predicate = predicate ; this . setOffendingToken ( recognizer . getCurrentToken ( ) ) ; }
public int normalize ( char s [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { switch ( s [ i ] ) { case ALEF_MADDA : case ALEF_HAMZA_ABOVE : case ALEF_HAMZA_BELOW : s [ i ] = ALEF ; break ; case DOTLESS_YEH : s [ i ] = YEH ; break ; case TEH_MARBUTA : s [ i ] = HEH ; break ; case TATWEEL : case KASRATAN : case DAMMATAN : case FATHATAN : case FATHA : case DAMMA : case KASRA : case SHADDA : case SUKUN : len = delete ( s , i , len ) ; i -- ; break ; default : break ; } } return len ; }
public static int idealCharArraySize ( int need ) { return idealByteArraySize ( need * 2 ) / 2 ; }
public void setObjectId ( AnyObjectId obj , int objType ) { object = obj . copy ( ) ; type = objType ; }
public ValueEval getItem ( int index ) { if ( index != 0 ) { throw new RuntimeException ( " Invalid ▁ index ▁ ( " + index + " ) ▁ only ▁ zero ▁ is ▁ allowed " ) ; } return _value ; }
public AND ( SemanticContext a , SemanticContext b ) { Set < SemanticContext > operands = new HashSet < SemanticContext > ( ) ; if ( a instanceof AND ) operands . addAll ( Arrays . asList ( ( ( AND ) a ) . opnds ) ) ; else operands . add ( a ) ; if ( b instanceof AND ) operands . addAll ( Arrays . asList ( ( ( AND ) b ) . opnds ) ) ; else operands . add ( b ) ; List < PrecedencePredicate > precedencePredicates = filterPrecedencePredicates ( operands ) ; if ( ! precedencePredicates . isEmpty ( ) ) { PrecedencePredicate reduced = Collections . min ( precedencePredicates ) ; operands . add ( reduced ) ; } opnds = operands . toArray ( new SemanticContext [ operands . size ( ) ] ) ; }
public GetCampaignVersionResult getCampaignVersion ( GetCampaignVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCampaignVersion ( request ) ; }
public SeriesTextRecord ( RecordInputStream in ) { field_1_id = in . readUShort ( ) ; int field_2_textLength = in . readUByte ( ) ; is16bit = ( in . readUByte ( ) & 0x01 ) != 0 ; if ( is16bit ) { field_4_text = in . readUnicodeLEString ( field_2_textLength ) ; } else { field_4_text = in . readCompressedUnicode ( field_2_textLength ) ; } }
public void writeUTF ( String value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeUTF ( value ) ; }
public DeleteCacheSubnetGroupResult deleteCacheSubnetGroup ( DeleteCacheSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCacheSubnetGroup ( request ) ; }
public Tab getItem ( int position ) { return mTabs . get ( position ) ; }
public int createFormat ( String formatString ) { maxformatid = maxformatid >= 0xa4 ? maxformatid + 1 : 0xa4 ; FormatRecord rec = new FormatRecord ( maxformatid , formatString ) ; int pos = 0 ; while ( pos < records . size ( ) && records . get ( pos ) . getSid ( ) != FormatRecord . sid ) { pos ++ ; } pos += formats . size ( ) ; formats . add ( rec ) ; records . add ( pos , rec ) ; return maxformatid ; }
public ListDeploymentStrategiesResult listDeploymentStrategies ( ListDeploymentStrategiesRequest request ) { request = beforeClientExecution ( request ) ; return executeListDeploymentStrategies ( request ) ; }
public CreateLoginProfileRequest ( String userName , String password ) { setUserName ( userName ) ; setPassword ( password ) ; }
public String getMetadata ( ) throws ClientException { HttpRequest request = new HttpRequest ( credentialUrl . toString ( ) ) ; request . setSysMethod ( MethodType . GET ) ; request . setSysConnectTimeout ( connectionTimeoutInMilliseconds ) ; request . setSysReadTimeout ( connectionTimeoutInMilliseconds ) ; HttpResponse response ; try { response = CompatibleUrlConnClient . compatibleGetResponse ( request ) ; } catch ( Exception e ) { throw new ClientException ( " Failed ▁ to ▁ connect ▁ ECS ▁ Metadata ▁ Service : ▁ " + e . toString ( ) ) ; } if ( response . getStatus ( ) != HttpURLConnection . HTTP_OK ) { throw new ClientException ( ECS_METADAT_FETCH_ERROR_MSG + " ▁ HttpCode = " + response . getStatus ( ) ) ; } return new String ( response . getHttpContent ( ) ) ; }
public void setAbbreviationLength ( int count ) { if ( count < 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . abbreviationLengthMustBeNonNegative ) ; abbreviationLength = count ; }
public SearchFacesByImageResult searchFacesByImage ( SearchFacesByImageRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchFacesByImage ( request ) ; }
public ListMonitoringSchedulesResult listMonitoringSchedules ( ListMonitoringSchedulesRequest request ) { request = beforeClientExecution ( request ) ; return executeListMonitoringSchedules ( request ) ; }
public static double [ ] grow ( double [ ] array ) { return grow ( array , 1 + array . length ) ; }
public E next ( ) { if ( index < to ) { return ( E ) snapshot [ index ++ ] ; } else { throw new NoSuchElementException ( ) ; } }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval inumberVE ) { ValueEval veText1 ; try { veText1 = OperandResolver . getSingleValue ( inumberVE , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } String iNumber = OperandResolver . coerceValueToString ( veText1 ) ; Matcher m = Imaginary . COMPLEX_NUMBER_PATTERN . matcher ( iNumber ) ; boolean result = m . matches ( ) ; String real = " " ; if ( result ) { String realGroup = m . group ( 2 ) ; boolean hasRealPart = realGroup . length ( ) != 0 ; if ( realGroup . length ( ) == 0 ) { return new StringEval ( String . valueOf ( 0 ) ) ; } if ( hasRealPart ) { String sign = " " ; String realSign = m . group ( Imaginary . GROUP1_REAL_SIGN ) ; if ( realSign . length ( ) != 0 && ! ( realSign . equals ( " + " ) ) ) { sign = realSign ; } String groupRealNumber = m . group ( Imaginary . GROUP2_IMAGINARY_INTEGER_OR_DOUBLE ) ; if ( groupRealNumber . length ( ) != 0 ) { real = sign + groupRealNumber ; } else { real = sign + " 1 " ; } } } else { return ErrorEval . NUM_ERROR ; } return new StringEval ( real ) ; }
public PlacementType ( String availabilityZone ) { setAvailabilityZone ( availabilityZone ) ; }
public UpdateDomainResult updateDomain ( UpdateDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDomain ( request ) ; }
public byte [ ] serialize ( ) { byte [ ] retval = new byte [ getRecordSize ( ) ] ; serialize ( 0 , retval ) ; return retval ; }
public GetLoadBalancerResult getLoadBalancer ( GetLoadBalancerRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLoadBalancer ( request ) ; }
public ModifyTrafficMirrorFilterRuleResult modifyTrafficMirrorFilterRule ( ModifyTrafficMirrorFilterRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyTrafficMirrorFilterRule ( request ) ; }
public void resize ( double scaleX , double scaleY ) { HSSFClientAnchor anchor = getClientAnchor ( ) ; anchor . setAnchorType ( AnchorType . MOVE_DONT_RESIZE ) ; HSSFClientAnchor pref = getPreferredSize ( scaleX , scaleY ) ; int row2 = anchor . getRow1 ( ) + ( pref . getRow2 ( ) - pref . getRow1 ( ) ) ; int col2 = anchor . getCol1 ( ) + ( pref . getCol2 ( ) - pref . getCol1 ( ) ) ; anchor . setCol2 ( ( short ) col2 ) ; anchor . setDx2 ( pref . getDx2 ( ) ) ; anchor . setRow2 ( row2 ) ; anchor . setDy2 ( pref . getDy2 ( ) ) ; }
public void reset ( ) throws IOException { throw new IOException ( " mark / reset ▁ not ▁ supported " ) ; }
public Body ( Content text ) { setText ( text ) ; }
public StaticCredentialsProvider ( IClientProfile clientProfile ) { IClientProfile clientProfile1 = clientProfile ; Credential legacyCredential = clientProfile1. getCredential ( ) ; if ( null != legacyCredential . getSecurityToken ( ) ) { this . credentials = new BasicSessionCredentials ( legacyCredential . getAccessKeyId ( ) , legacyCredential . getAccessSecret ( ) , legacyCredential . getSecurityToken ( ) ) ; } else { this . credentials = new LegacyCredentials ( legacyCredential ) ; } }
public synchronized V get ( Object key ) { int hash = key . hashCode ( ) ; hash ^= ( hash >>> 20 ) ^ ( hash >>> 12 ) ; hash ^= ( hash >>> 7 ) ^ ( hash >>> 4 ) ; HashtableEntry < K , V > [ ] tab = table ; for ( HashtableEntry < K , V > e = tab [ hash & ( tab . length - 1 ) ] ; e != null ; e = e . next ) { K eKey = e . key ; if ( eKey == key || ( e . hash == hash && key . equals ( eKey ) ) ) { return e . value ; } } return null ; }
public void keep ( int pos , int cnt ) { beforeAdd ( cache . getEntry ( pos ) ) ; fastKeep ( pos , cnt ) ; }
public TableStylesRecord ( RecordInputStream in ) { rt = in . readUShort ( ) ; grbitFrt = in . readUShort ( ) ; in . readFully ( unused ) ; cts = in . readInt ( ) ; int cchDefListStyle = in . readUShort ( ) ; int cchDefPivotStyle = in . readUShort ( ) ; rgchDefListStyle = in . readUnicodeLEString ( cchDefListStyle ) ; rgchDefPivotStyle = in . readUnicodeLEString ( cchDefPivotStyle ) ; }
public AddAttributesToFindingsResult addAttributesToFindings ( AddAttributesToFindingsRequest request ) { request = beforeClientExecution ( request ) ; return executeAddAttributesToFindings ( request ) ; }
public CellElapsedFormatter ( String pattern ) { super ( pattern ) ; specs = new ArrayList <> ( ) ; StringBuffer desc = CellFormatPart . parseFormat ( pattern , CellFormatType . ELAPSED , new ElapsedPartHandler ( ) ) ; ListIterator < TimeSpec > it = specs . listIterator ( specs . size ( ) ) ; while ( it . hasPrevious ( ) ) { TimeSpec spec = it . previous ( ) ; desc . replace ( spec . pos , spec . pos + spec . len , " % 0 " + spec . len + " d " ) ; if ( spec . type != topmost . type ) { spec . modBy = modFor ( spec . type , spec . len ) ; } } printfFmt = desc . toString ( ) ; }
public final int capacity ( ) { return capacity ; }
public final boolean matches ( char c ) { return Character . isWhitespace ( c ) ; }
public BytesRef get ( int bytesID , BytesRef ref ) { assert bytesStart != null : " bytesStart ▁ is ▁ null ▁ - ▁ not ▁ initialized " ; assert bytesID < bytesStart . length : " bytesID ▁ exceeds ▁ byteStart ▁ len : ▁ " + bytesStart . length ; pool . setBytesRef ( ref , bytesStart [ bytesID ] ) ; return ref ; }
public void run ( ) { display = true ; }
public UpdateMatchmakingConfigurationResult updateMatchmakingConfiguration ( UpdateMatchmakingConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateMatchmakingConfiguration ( request ) ; }
public boolean isGroup ( char c ) { return groupMap [ characterCategoryMap [ c ] ] ; }
public void setTraverseEmptyCells ( boolean traverseEmptyCells ) { this . traverseEmptyCells = traverseEmptyCells ; }
public ListPresetsResult listPresets ( ListPresetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListPresets ( request ) ; }
@ Override public Set < K > keySet ( ) { Set < K > ks = keySet ; return ( ks != null ) ? ks : ( keySet = new KeySet ( ) ) ; }
public void include ( Ref r ) { include ( r . getName ( ) , r . getObjectId ( ) ) ; if ( r . getPeeledObjectId ( ) != null ) tagTargets . add ( r . getPeeledObjectId ( ) ) ; else if ( r . getObjectId ( ) != null && r . getName ( ) . startsWith ( Constants . R_HEADS ) ) tagTargets . add ( r . getObjectId ( ) ) ; }
public CharBuffer get ( char [ ] dst , int dstOffset , int charCount ) { byteBuffer . limit ( limit * SizeOf . CHAR ) ; byteBuffer . position ( position * SizeOf . CHAR ) ; if ( byteBuffer instanceof DirectByteBuffer ) { ( ( DirectByteBuffer ) byteBuffer ) . get ( dst , dstOffset , charCount ) ; } else { ( ( HeapByteBuffer ) byteBuffer ) . get ( dst , dstOffset , charCount ) ; } this . position += charCount ; return this ; }
public BytesRef subtract ( BytesRef output , BytesRef inc ) { assert output != null ; assert inc != null ; if ( inc == NO_OUTPUT ) { return output ; } else { assert StringHelper . startsWith ( output , inc ) ; if ( inc . length == output . length ) { return NO_OUTPUT ; } else { assert inc . length < output . length : " inc . length = " + inc . length + " ▁ vs ▁ output . length = " + output . length ; assert inc . length > 0 ; return new BytesRef ( output . bytes , output . offset + inc . length , output . length - inc . length ) ; } } }
public boolean isKanji ( char c ) { final byte characterClass = characterCategoryMap [ c ] ; return characterClass == KANJI || characterClass == KANJINUMERIC ; }
public int getType ( ) { return type ; }
public ValueEval getItem ( int index ) { if ( index > _size ) { throw new ArrayIndexOutOfBoundsException ( " Specified ▁ index ▁ ( " + index + " ) ▁ is ▁ outside ▁ the ▁ allowed ▁ range ▁ ( 0.. " + ( _size - 1 ) + " ) " ) ; } return _tableArray . getValue ( index , _columnIndex ) ; }
public void writeDouble ( double v ) { writeContinueIfRequired ( 8 ) ; _ulrOutput . writeDouble ( v ) ; }
final public QueryNode ConjQuery ( CharSequence field ) throws ParseException { QueryNode first , c ; Vector < QueryNode > clauses = null ; first = ModClause ( field ) ; label_3 : while ( true ) { switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case AND : ; break ; default : jj_la1 [ 4 ] = jj_gen ; break label_3 ; } jj_consume_token ( AND ) ; c = ModClause ( field ) ; if ( clauses == null ) { clauses = new Vector < QueryNode > ( ) ; clauses . addElement ( first ) ; } clauses . addElement ( c ) ; } if ( clauses != null ) { { if ( true ) return new AndQueryNode ( clauses ) ; } } else { { if ( true ) return first ; } } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public void setRevFilter ( RevFilter newFilter ) { assertNotStarted ( ) ; filter = newFilter != null ? newFilter : RevFilter . ALL ; }
public void setText ( final char array [ ] , int start , int length ) { this . array = array ; this . start = start ; this . index = start ; this . length = length ; this . limit = start + length ; }
public GetVoiceChannelResult getVoiceChannel ( GetVoiceChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVoiceChannel ( request ) ; }
public RevokeSecurityGroupIngressResult revokeSecurityGroupIngress ( RevokeSecurityGroupIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeRevokeSecurityGroupIngress ( request ) ; }
public DoubleBuffer slice ( ) { byteBuffer . limit ( limit * SizeOf . DOUBLE ) ; byteBuffer . position ( position * SizeOf . DOUBLE ) ; ByteBuffer bb = byteBuffer . slice ( ) . order ( byteBuffer . order ( ) ) ; DoubleBuffer result = new DoubleToByteBufferAdapter ( bb ) ; byteBuffer . clear ( ) ; return result ; }
public DoubleValuesSource makeDistanceValueSource ( Point queryPoint , double multiplier ) { return new DistanceValueSource ( this , queryPoint , multiplier ) ; }
public String toString ( ) { final StringBuilder r = new StringBuilder ( ) ; final SimpleDateFormat dtfmt ; dtfmt = new SimpleDateFormat ( " EEE ▁ MMM ▁ d ▁ HH : mm : ss ▁ yyyy ▁ Z " , Locale . US ) ; dtfmt . setTimeZone ( getTimeZone ( ) ) ; r . append ( " PersonIdent [ " ) ; r . append ( getName ( ) ) ; r . append ( " , ▁ " ) ; r . append ( getEmailAddress ( ) ) ; r . append ( " , ▁ " ) ; r . append ( dtfmt . format ( Long . valueOf ( when ) ) ) ; r . append ( " ] " ) ; return r . toString ( ) ; }
public ArabicStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public int getIndex ( ) { return offset ; }
public ListVoiceConnectorsResult listVoiceConnectors ( ListVoiceConnectorsRequest request ) { request = beforeClientExecution ( request ) ; return executeListVoiceConnectors ( request ) ; }
public GetOperationResult getOperation ( GetOperationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetOperation ( request ) ; }
public Item ( String name , java . util . List < Attribute > attributes ) { setName ( name ) ; setAttributes ( attributes ) ; }
public SetIdentityHeadersInNotificationsEnabledResult setIdentityHeadersInNotificationsEnabled ( SetIdentityHeadersInNotificationsEnabledRequest request ) { request = beforeClientExecution ( request ) ; return executeSetIdentityHeadersInNotificationsEnabled ( request ) ; }
public void setSensitiveInputCells ( CellCacheEntry [ ] sensitiveInputCells ) { if ( sensitiveInputCells == null ) { _sensitiveInputCells = null ; changeConsumingCells ( CellCacheEntry . EMPTY_ARRAY ) ; } else { _sensitiveInputCells = sensitiveInputCells . clone ( ) ; changeConsumingCells ( _sensitiveInputCells ) ; } }
public synchronized boolean add ( E e ) { Object [ ] newElements = new Object [ elements . length + 1 ] ; System . arraycopy ( elements , 0 , newElements , 0 , elements . length ) ; newElements [ elements . length ] = e ; elements = newElements ; return true ; }
public StringBuilder append ( long l ) { IntegralToString . appendLong ( this , l ) ; return this ; }
public DeleteHsmClientCertificateResult deleteHsmClientCertificate ( DeleteHsmClientCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteHsmClientCertificate ( request ) ; }
public CreateAssessmentTargetResult createAssessmentTarget ( CreateAssessmentTargetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAssessmentTarget ( request ) ; }
public DescribeGlobalReplicationGroupsResult describeGlobalReplicationGroups ( DescribeGlobalReplicationGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeGlobalReplicationGroups ( request ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeShort ( _sheetRefIndex ) ; out . writeShort ( _nameNumber ) ; out . writeShort ( _reserved ) ; }
public static String parseSegmentName ( String filename ) { int idx = indexOfSegmentName ( filename ) ; if ( idx != - 1 ) { filename = filename . substring ( 0 , idx ) ; } return filename ; }
public String getRefLogMessage ( ) { return refLogMessage ; }
public ObjectId getObjectId ( ) { return missing ; }
public void setPackedGitLimit ( long newLimit ) { packedGitLimit = newLimit ; }
public String toString ( ) { return " " ; }
public void clear ( ) { if ( size > 0 ) { size = 0 ; voidLink . next = voidLink ; voidLink . previous = voidLink ; modCount ++ ; } }
public List < Note > call ( ) throws GitAPIException { checkCallable ( ) ; List < Note > notes = new ArrayList <> ( ) ; NoteMap map = NoteMap . newEmptyMap ( ) ; try ( RevWalk walk = new RevWalk ( repo ) ) { Ref ref = repo . findRef ( notesRef ) ; if ( ref != null ) { RevCommit notesCommit = walk . parseCommit ( ref . getObjectId ( ) ) ; map = NoteMap . read ( walk . getObjectReader ( ) , notesCommit ) ; } Iterator < Note > i = map . iterator ( ) ; while ( i . hasNext ( ) ) notes . add ( i . next ( ) ) ; } catch ( IOException e ) { throw new JGitInternalException ( e . getMessage ( ) , e ) ; } return notes ; }
public ListOrganizationsResult listOrganizations ( ListOrganizationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListOrganizations ( request ) ; }
public ParseTreeMatch match ( ParseTree tree , String pattern , int patternRuleIndex ) { ParseTreePattern p = compile ( pattern , patternRuleIndex ) ; return match ( tree , p ) ; }
public GridsetRecord ( RecordInputStream in ) { field_1_gridset_flag = in . readShort ( ) ; }
public PagedBytesDataInput clone ( ) { PagedBytesDataInput clone = getDataInput ( ) ; clone . setPosition ( getPosition ( ) ) ; return clone ; }
public MissingObjectException ( AbbreviatedObjectId id , int type ) { super ( MessageFormat . format ( JGitText . get ( ) . missingObject , Constants . typeString ( type ) , id . name ( ) ) ) ; missing = null ; }
public void getName ( byte [ ] buffer , int offset ) { System . arraycopy ( path , pathOffset , buffer , offset , pathLen - pathOffset ) ; }
public List <? extends CombinedHunkHeader > getHunks ( ) { return ( List < CombinedHunkHeader > ) super . getHunks ( ) ; }
public long getPointer ( ) { if ( currentBlock == null ) { return 0 ; } else { return ( numBlocks * ( ( long ) blockSize ) ) + upto ; } }
public PendingTaskCount countPendingDecisionTasks ( CountPendingDecisionTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeCountPendingDecisionTasks ( request ) ; }
public ListStackResourcesResult listStackResources ( ListStackResourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeListStackResources ( request ) ; }
public Credential ( String keyId , String secret , String securityToken , int expiredHours ) { this . accessKeyId = keyId ; this . accessSecret = secret ; this . securityToken = securityToken ; this . refreshDate = new Date ( ) ; setExpiredDate ( expiredHours ) ; }
public void writeFields ( ) throws IOException { if ( currentPutField == null ) { throw new NotActiveException ( ) ; } writeFieldValues ( currentPutField ) ; }
public Result getResult ( ) { return status ; }
public AssignIpv6AddressesResult assignIpv6Addresses ( AssignIpv6AddressesRequest request ) { request = beforeClientExecution ( request ) ; return executeAssignIpv6Addresses ( request ) ; }
public DBInstance modifyDBInstance ( ModifyDBInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBInstance ( request ) ; }
public RemoveAttributesFromFindingsResult removeAttributesFromFindings ( RemoveAttributesFromFindingsRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveAttributesFromFindings ( request ) ; }
public JoinDocFreqValueSource ( String field , String qfield ) { super ( field ) ; this . qfield = qfield ; }
public double readDouble ( ) { return Double . longBitsToDouble ( readLong ( ) ) ; }
public DescribeDirectoryConfigsResult describeDirectoryConfigs ( DescribeDirectoryConfigsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDirectoryConfigs ( request ) ; }
public GetAccountResult getAccount ( GetAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAccount ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ BOUNDSHEET ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . bof ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . intToHex ( getPositionOfBof ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . visibility ▁ = ▁ " ) . append ( HexDump . shortToHex ( field_2_visibility ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . type ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . byteToHex ( field_3_type ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . sheetname ▁ ▁ = ▁ " ) . append ( getSheetname ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / BOUNDSHEET ] \ n " ) ; return buffer . toString ( ) ; }
public short getShortRawValue ( final short holder ) { return ( short ) getRawValue ( holder ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 ) { double result ; try { double d0 = NumericFunction . singleOperandEvaluate ( arg0 , srcRowIndex , srcColumnIndex ) ; double d1 = NumericFunction . singleOperandEvaluate ( arg1 , srcRowIndex , srcColumnIndex ) ; double d2 = NumericFunction . singleOperandEvaluate ( arg2 , srcRowIndex , srcColumnIndex ) ; result = evaluate ( getYear ( d0 ) , ( int ) ( d1 - 1 ) , ( int ) d2 ) ; NumericFunction . checkValue ( result ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public GetPublicKeyConfigResult getPublicKeyConfig ( GetPublicKeyConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeGetPublicKeyConfig ( request ) ; }
public URIish setUser ( String n ) { final URIish r = new URIish ( this ) ; r . user = n ; return r ; }
public EscherArrayProperty ( short id , int complexSize ) { super ( id , complexSize ) ; emptyComplexPart = ( complexSize == 0 ) ; }
public String toASCIIString ( ) { return format ( false , true ) ; }
public void decode ( long [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; for ( int shift = 56 ; shift >= 0 ; shift -= 8 ) { values [ valuesOffset ++ ] = ( block >>> shift ) & 255 ; } } }
public GetContactResult getContact ( GetContactRequest request ) { request = beforeClientExecution ( request ) ; return executeGetContact ( request ) ; }
public void removeHiddenCount ( ) { remove1stProperty ( PropertyIDMap . PID_HIDDENCOUNT ) ; }
public GetRestApisResult getRestApis ( GetRestApisRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRestApis ( request ) ; }
public ArrayPredictionContext ( PredictionContext [ ] parents , int [ ] returnStates ) { super ( calculateHashCode ( parents , returnStates ) ) ; assert parents != null && parents . length > 0 ; assert returnStates != null && returnStates . length > 0 ; this . parents = parents ; this . returnStates = returnStates ; }
public CharBuffer compact ( ) { System . arraycopy ( backingArray , position + offset , backingArray , offset , remaining ( ) ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public DeleteStageResult deleteStage ( DeleteStageRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteStage ( request ) ; }
public Object [ ] toArray ( ) { return elements . clone ( ) ; }
public synchronized void mark ( int ignoredReadlimit ) { _marked_offset = _current_offset ; _marked_offset_count = Math . max ( 0 , _current_block_count - 1 ) ; }
public String toString ( ) { return " NOT ▁ " + a . toString ( ) ; }
public void setExpectDataAfterPackFooter ( boolean e ) { expectDataAfterPackFooter = e ; }
public Request < DeletePublicAccessBlockRequest > marshall ( DeletePublicAccessBlockRequest deletePublicAccessBlockRequest ) { if ( deletePublicAccessBlockRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( ... ) " ) ; } Request < DeletePublicAccessBlockRequest > request = new DefaultRequest < DeletePublicAccessBlockRequest > ( deletePublicAccessBlockRequest , " AWSS3Control " ) ; request . setHttpMethod ( HttpMethodName . DELETE ) ; if ( deletePublicAccessBlockRequest . getAccountId ( ) != null ) { request . addHeader ( " x - amz - account - id " , StringUtils . fromString ( deletePublicAccessBlockRequest . getAccountId ( ) ) ) ; } String uriResourcePath = " / v20180820 / configuration / publicAccessBlock " ; request . setResourcePath ( uriResourcePath ) ; return request ; }
public FetchResult getFetchResult ( ) { return this . fetchResult ; }
public GetJourneyExecutionMetricsResult getJourneyExecutionMetrics ( GetJourneyExecutionMetricsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetJourneyExecutionMetrics ( request ) ; }
public static long [ ] grow ( long [ ] array ) { return grow ( array , 1 + array . length ) ; }
@ Override public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( getClass ( ) . getName ( ) ) ; buf . append ( " , ▁ status : ▁ capacity = " ) ; buf . append ( capacity ) ; buf . append ( " ▁ position = " ) ; buf . append ( position ) ; buf . append ( " ▁ limit = " ) ; buf . append ( limit ) ; return buf . toString ( ) ; }
public UpdateStreamingDistributionResult updateStreamingDistribution ( UpdateStreamingDistributionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateStreamingDistribution ( request ) ; }
public DeleteVaultNotificationsRequest ( String vaultName ) { setVaultName ( vaultName ) ; }
public AttachNetworkInterfaceResult attachNetworkInterface ( AttachNetworkInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachNetworkInterface ( request ) ; }
public boolean equals ( Object o ) { return o instanceof HungarianStemmer ; }
public DescribeDatasetResult describeDataset ( DescribeDatasetRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDataset ( request ) ; }
public UpdateShardCountResult updateShardCount ( UpdateShardCountRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateShardCount ( request ) ; }
public String getText ( ) { return getText ( Interval . of ( 0 , size ( ) - 1 ) ) ; }
public BoundSheetRecord [ ] getBoundSheetRecords ( ) { return boundSheetRecords . toArray ( new BoundSheetRecord [ 0 ] ) ; }
public boolean matches ( FooterKey key ) { final byte [ ] kRaw = key . raw ; final int len = kRaw . length ; int bPtr = keyStart ; if ( keyEnd - bPtr != len ) return false ; for ( int kPtr = 0 ; kPtr < len ; ) { byte b = buffer [ bPtr ++ ] ; if ( ' A ' <= b && b <= ' Z ' ) b += ( byte ) ( ' a ' - ' A ' ) ; if ( b != kRaw [ kPtr ++ ] ) return false ; } return true ; }
public CreateUserResult createUser ( CreateUserRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateUser ( request ) ; }
public S3Origin ( String domainName , String originAccessIdentity ) { setDomainName ( domainName ) ; setOriginAccessIdentity ( originAccessIdentity ) ; }
public StartTopicsDetectionJobResult startTopicsDetectionJob ( StartTopicsDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStartTopicsDetectionJob ( request ) ; }
public ClusterSecurityGroup revokeClusterSecurityGroupIngress ( RevokeClusterSecurityGroupIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeRevokeClusterSecurityGroupIngress ( request ) ; }
public void enterRule ( ParserRuleContext localctx , int state , int ruleIndex ) { setState ( state ) ; _ctx = localctx ; _ctx . start = _input . LT ( 1 ) ; if ( _buildParseTrees ) addContextToParseTree ( ) ; if ( _parseListeners != null ) triggerEnterRuleEvent ( ) ; }
public ObjectReader newReader ( ) { return new WindowCursor ( db ) ; }
@ Override public int size ( ) { return backingMap . size ( ) ; }
public static String pathToString ( String [ ] path , int length ) { if ( length == 0 ) { return " " ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { String s = path [ i ] ; if ( s . length ( ) == 0 ) { throw new IllegalArgumentException ( " each ▁ path ▁ component ▁ must ▁ have ▁ length ▁ > ▁ 0 ▁ ( got : ▁ \ " \ " ) " ) ; } int numChars = s . length ( ) ; for ( int j = 0 ; j < numChars ; j ++ ) { char ch = s . charAt ( j ) ; if ( ch == DELIM_CHAR || ch == ESCAPE_CHAR ) { sb . append ( ESCAPE_CHAR ) ; } sb . append ( ch ) ; } sb . append ( DELIM_CHAR ) ; } sb . setLength ( sb . length ( ) - 1 ) ; return sb . toString ( ) ; }
public CancelSpotInstanceRequestsRequest ( java . util . List < String > spotInstanceRequestIds ) { setSpotInstanceRequestIds ( spotInstanceRequestIds ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ' [ ' ) ; for ( byte [ ] b : table ) { if ( b == null ) continue ; if ( sb . length ( ) > 1 ) sb . append ( " ▁ , ▁ " ) ; sb . append ( ' " ' ) ; sb . append ( RawParseUtils . decode ( b ) ) ; sb . append ( ' " ' ) ; sb . append ( ' ( ' ) ; sb . append ( chainlength ( b ) ) ; sb . append ( ' ) ' ) ; } sb . append ( ' ] ' ) ; return sb . toString ( ) ; }
public GetConnectionResult getConnection ( GetConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetConnection ( request ) ; }
public String toString ( ) { return a + " .. " + b ; }
public AddNoteCommand notesAdd ( ) { return new AddNoteCommand ( repo ) ; }
public static void fill ( short [ ] array , int start , int end , short value ) { Arrays . checkStartAndEnd ( array . length , start , end ) ; for ( int i = start ; i < end ; i ++ ) { array [ i ] = value ; } }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof LexerIndexedCustomAction ) ) { return false ; } LexerIndexedCustomAction other = ( LexerIndexedCustomAction ) obj ; return offset == other . offset && action . equals ( other . action ) ; }
public DeleteNamespaceAuthorizationRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " DeleteNamespaceAuthorization " , " cr " ) ; setUriPattern ( " / namespace / [ Namespace ] / authorizations / [ AuthorizeId ] " ) ; setMethod ( MethodType . DELETE ) ; }
public static final int author ( byte [ ] b , int ptr ) { final int sz = b . length ; if ( ptr == 0 ) ptr += 46 ; while ( ptr < sz && b [ ptr ] == ' p ' ) ptr += 48 ; return match ( b , ptr , author ) ; }
public DescribeHostsResult describeHosts ( DescribeHostsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeHosts ( request ) ; }
public void reset ( byte [ ] bytes ) { reset ( bytes , 0 , bytes . length ) ; }
public OpenNLPChunkerFilterFactory ( Map < String , String > args ) { super ( args ) ; chunkerModelFile = get ( args , CHUNKER_MODEL ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public String toString ( ) { StringBuilder r = new StringBuilder ( ) ; r . append ( " Ref [ " ) ; r . append ( getName ( ) ) ; r . append ( ' = ' ) ; r . append ( ObjectId . toString ( getObjectId ( ) ) ) ; r . append ( ' ( ' ) ; r . append ( updateIndex ) ; r . append ( " ) ] " ) ; return r . toString ( ) ; }
public StartStreamEncryptionResult startStreamEncryption ( StartStreamEncryptionRequest request ) { request = beforeClientExecution ( request ) ; return executeStartStreamEncryption ( request ) ; }
public DeleteCloudFrontOriginAccessIdentityRequest ( String id , String ifMatch ) { setId ( id ) ; setIfMatch ( ifMatch ) ; }
public int getWidth ( ) { return mImage . getWidth ( ) ; }
public List < String > getUntrackedFolders ( ) { LinkedList < String > ret = new LinkedList <> ( untrackedFolders ) ; if ( ! untrackedParentFolders . isEmpty ( ) ) { String toBeAdded = untrackedParentFolders . getLast ( ) ; while ( ! ret . isEmpty ( ) && ret . getLast ( ) . startsWith ( toBeAdded ) ) ret . removeLast ( ) ; ret . addLast ( toBeAdded ) ; } return ret ; }
public CredentialsProviderUserInfo ( Session session , CredentialsProvider credentialsProvider ) { this . uri = createURI ( session ) ; this . provider = credentialsProvider ; }
public String toString ( ) { return " [ SELECTION ] \ n " + " ▁ ▁ ▁ ▁ . pane ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + HexDump . byteToHex ( getPane ( ) ) + " \ n " + " ▁ ▁ ▁ ▁ . activecellrow ▁ ▁ ▁ = ▁ " + HexDump . shortToHex ( getActiveCellRow ( ) ) + " \ n " + " ▁ ▁ ▁ ▁ . activecellcol ▁ ▁ ▁ = ▁ " + HexDump . shortToHex ( getActiveCellCol ( ) ) + " \ n " + " ▁ ▁ ▁ ▁ . activecellref ▁ ▁ ▁ = ▁ " + HexDump . shortToHex ( getActiveCellRef ( ) ) + " \ n " + " ▁ ▁ ▁ ▁ . numrefs ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + HexDump . shortToHex ( field_6_refs . length ) + " \ n " + " [ / SELECTION ] \ n " ; }
public static boolean isCellInternalDateFormatted ( Cell cell ) { if ( cell == null ) { return false ; } boolean bDate = false ; double d = cell . getNumericCellValue ( ) ; if ( DateUtil . isValidExcelDate ( d ) ) { CellStyle style = cell . getCellStyle ( ) ; int i = style . getDataFormat ( ) ; bDate = isInternalDateFormat ( i ) ; } return bDate ; }
public static String getSegmentsFile ( List < String > files , boolean allowEmpty ) { if ( files . isEmpty ( ) ) { if ( allowEmpty ) { return null ; } else { throw new IllegalStateException ( " empty ▁ list ▁ of ▁ files ▁ not ▁ allowed " ) ; } } String segmentsFile = files . remove ( files . size ( ) - 1 ) ; if ( ! segmentsFile . startsWith ( IndexFileNames . SEGMENTS ) ) { throw new IllegalStateException ( " last ▁ file ▁ to ▁ copy + sync ▁ must ▁ be ▁ segments □ N ▁ but ▁ got ▁ " + segmentsFile + " ; ▁ check ▁ your ▁ Revision ▁ implementation ! " ) ; } return segmentsFile ; }
public static boolean hasMultibyte ( String value ) { if ( value == null ) { return false ; } for ( char c : value . toCharArray ( ) ) { if ( c > 0xFF ) { return true ; } } return false ; }
public static ObjectId fromString ( String str ) { if ( str . length ( ) != Constants . OBJECT_ID_STRING_LENGTH ) { throw new InvalidObjectIdException ( str ) ; } return fromHexString ( Constants . encodeASCII ( str ) , 0 ) ; }
public void reset ( ) throws IOException { throw new IOException ( ) ; }
public GetReservedInstancesExchangeQuoteResult getReservedInstancesExchangeQuote ( GetReservedInstancesExchangeQuoteRequest request ) { request = beforeClientExecution ( request ) ; return executeGetReservedInstancesExchangeQuote ( request ) ; }
public IntBuffer put ( int c ) { throw new ReadOnlyBufferException ( ) ; }
public GetFolderPathResult getFolderPath ( GetFolderPathRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFolderPath ( request ) ; }
public DeleteDirectConnectGatewayAssociationResult deleteDirectConnectGatewayAssociation ( DeleteDirectConnectGatewayAssociationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDirectConnectGatewayAssociation ( request ) ; }
public ByteBuffer putDouble ( double value ) { return putLong ( Double . doubleToRawLongBits ( value ) ) ; }
public SearchContactsResult searchContacts ( SearchContactsRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchContacts ( request ) ; }
@ Override public boolean isEmpty ( ) { return size == 0 ; }
public CreatePartnerEventSourceResult createPartnerEventSource ( CreatePartnerEventSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePartnerEventSource ( request ) ; }
public CreateNamespaceAuthorizationRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " CreateNamespaceAuthorization " , " cr " ) ; setUriPattern ( " / namespace / [ Namespace ] / authorizations " ) ; setMethod ( MethodType . PUT ) ; }
public URIish setPass ( String n ) { final URIish r = new URIish ( this ) ; r . pass = n ; return r ; }
public void execute ( Lexer lexer ) { lexer . pushMode ( mode ) ; }
public CreateModelVersionResult createModelVersion ( CreateModelVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateModelVersion ( request ) ; }
public UpdateServicePrimaryTaskSetResult updateServicePrimaryTaskSet ( UpdateServicePrimaryTaskSetRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateServicePrimaryTaskSet ( request ) ; }
public LinearRegressionFunction ( FUNCTION function ) { this . function = function ; }
public ATNConfig ( ATNConfig old ) { this . state = old . state ; this . alt = old . alt ; this . context = old . context ; this . semanticContext = old . semanticContext ; this . reachesIntoOuterContext = old . reachesIntoOuterContext ; }
public DescribeEntitiesDetectionJobResult describeEntitiesDetectionJob ( DescribeEntitiesDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEntitiesDetectionJob ( request ) ; }
public AssociateDhcpOptionsRequest ( String vpcId ) { setVpcId ( vpcId ) ; }
public ListChangedBlocksResult listChangedBlocks ( ListChangedBlocksRequest request ) { request = beforeClientExecution ( request ) ; return executeListChangedBlocks ( request ) ; }
public boolean removeFirstOccurrence ( Object o ) { return removeFirstOccurrenceImpl ( o ) ; }
public ArrayList < PerfTask > extractTasks ( ) { ArrayList < PerfTask > res = new ArrayList <> ( ) ; extractTasks ( res , sequence ) ; return res ; }
public FacetsCollector ( boolean keepScores ) { this . keepScores = keepScores ; }
public UpdateNodegroupVersionResult updateNodegroupVersion ( UpdateNodegroupVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateNodegroupVersion ( request ) ; }
public DeleteAttributesRequest ( String domainName , String itemName ) { setDomainName ( domainName ) ; setItemName ( itemName ) ; }
public void clearDFA ( ) { throw new UnsupportedOperationException ( " This ▁ ATN ▁ simulator ▁ does ▁ not ▁ support ▁ clearing ▁ the ▁ DFA . " ) ; }
public Field [ ] createIndexableFields ( Shape shape ) { if ( shape instanceof Point ) return createIndexableFields ( ( Point ) shape ) ; throw new UnsupportedOperationException ( " Can ▁ only ▁ index ▁ Point , ▁ not ▁ " + shape ) ; }
public void untagResource ( UntagResourceRequest request ) { request = beforeClientExecution ( request ) ; executeUntagResource ( request ) ; }
public DBSecurityGroup createDBSecurityGroup ( CreateDBSecurityGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBSecurityGroup ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } ExpressionValueSource other = ( ExpressionValueSource ) obj ; if ( expression == null ) { if ( other . expression != null ) { return false ; } } else if ( ! expression . sourceText . equals ( other . expression . sourceText ) ) { return false ; } if ( needsScores != other . needsScores ) { return false ; } if ( ! Arrays . equals ( variables , other . variables ) ) { return false ; } return true ; }
public static String getPreferredEncoding ( ) { return ISO_8859_1. name ( ) ; }
public synchronized IndexSearcher getIndexSearcher ( ) { if ( indexReader != null ) { indexReader . incRef ( ) ; } return indexSearcher ; }
public boolean equals ( Object o ) { return o instanceof German2Stemmer ; }
public FacetLabel ( final String ... components ) { this . components = components ; length = components . length ; checkComponents ( ) ; }
public void visitContainedRecords ( RecordVisitor rv ) { if ( _recs . isEmpty ( ) ) { return ; } rv . visitRecord ( _begin ) ; for ( int i = 0 ; i < _recs . size ( ) ; i ++ ) { RecordBase rb = _recs . get ( i ) ; if ( rb instanceof RecordAggregate ) { ( ( RecordAggregate ) rb ) . visitContainedRecords ( rv ) ; } else { rv . visitRecord ( ( org . apache . poi . hssf . record . Record ) rb ) ; } } rv . visitRecord ( _end ) ; }
public void setDirCache ( DirCache dc ) { this . dircache = dc ; implicitDirCache = false ; }
public long seek ( BytesRef target ) { long lo = 0 ; long hi = fieldIndex . numIndexTerms - 1 ; while ( hi >= lo ) { long mid = ( lo + hi ) >>> 1 ; final long offset = fieldIndex . termOffsets . get ( mid ) ; final int length = ( int ) ( fieldIndex . termOffsets . get ( 1 + mid ) - offset ) ; termBytesReader . fillSlice ( term , fieldIndex . termBytesStart + offset , length ) ; int delta = target . compareTo ( term ) ; if ( delta < 0 ) { hi = mid - 1 ; } else if ( delta > 0 ) { lo = mid + 1 ; } else { assert mid >= 0 ; ord = mid * indexInterval ; return fieldIndex . termsStart + fieldIndex . termsDictOffsets . get ( mid ) ; } } if ( hi < 0 ) { assert hi == - 1 ; hi = 0 ; } final long offset = fieldIndex . termOffsets . get ( hi ) ; final int length = ( int ) ( fieldIndex . termOffsets . get ( 1 + hi ) - offset ) ; termBytesReader . fillSlice ( term , fieldIndex . termBytesStart + offset , length ) ; ord = hi * indexInterval ; return fieldIndex . termsStart + fieldIndex . termsDictOffsets . get ( hi ) ; }
public void write ( byte [ ] b , int offset , int len ) { int i = 0 ; while ( true ) { int nWritableChars = Math . min ( len - i , _ulrOutput . getAvailableSpace ( ) / 1 ) ; for ( ; nWritableChars > 0 ; nWritableChars -- ) { _ulrOutput . writeByte ( b [ offset + i ++ ] ) ; } if ( i >= len ) { break ; } writeContinue ( ) ; } }
public FormatFlagsConversionMismatchException ( String f , char c ) { if ( f == null ) { throw new NullPointerException ( ) ; } this . f = f ; this . c = c ; }
public List < Head > getNextHeads ( char c ) { return FileNameMatcher . EMPTY_HEAD_LIST ; }
public void addQueryBuilder ( String nodeName , QueryBuilder builder ) { queryFactory . addBuilder ( nodeName , builder ) ; }
public int defineDecisionState ( DecisionState s ) { decisionToState . add ( s ) ; s . decision = decisionToState . size ( ) - 1 ; return s . decision ; }
public void afterRefresh ( boolean didRefresh ) { refreshDone ( ) ; }
public static final int prevLF ( byte [ ] b , int ptr , char chrA ) { if ( ptr == b . length ) -- ptr ; while ( ptr >= 0 ) { final byte c = b [ ptr -- ] ; if ( c == chrA || c == ' \ n ' ) return ptr ; } return ptr ; }
public ConsumeContentSourceTask ( PerfRunData runData ) { super ( runData ) ; source = runData . getContentSource ( ) ; }
public DescribeInstanceTypeOfferingsResult describeInstanceTypeOfferings ( DescribeInstanceTypeOfferingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInstanceTypeOfferings ( request ) ; }
public void clearDrawingGroups ( ) { drawingGroups . clear ( ) ; }
public String formatDate ( PersonIdent ident ) { switch ( format ) { case RAW : int offset = ident . getTimeZoneOffset ( ) ; String sign = offset < 0 ? " - " : " + " ; int offset2 ; if ( offset < 0 ) offset2 = - offset ; elseoffset2 = offset ; int hours = offset2 / 60 ; int minutes = offset2 % 60 ; return String . format ( " % d ▁ % s % 02d % 02d " , ident . getWhen ( ) . getTime ( ) / 1000 , sign , hours , minutes ) ; case RELATIVE : return RelativeDateFormatter . format ( ident . getWhen ( ) ) ; case LOCALELOCAL : case LOCAL : dateTimeInstance . setTimeZone ( SystemReader . getInstance ( ) . getTimeZone ( ) ) ; return dateTimeInstance . format ( ident . getWhen ( ) ) ; case LOCALE : TimeZone tz = ident . getTimeZone ( ) ; if ( tz == null ) tz = SystemReader . getInstance ( ) . getTimeZone ( ) ; dateTimeInstance . setTimeZone ( tz ) ; dateTimeInstance2. setTimeZone ( tz ) ; return dateTimeInstance . format ( ident . getWhen ( ) ) + " ▁ " + dateTimeInstance2. format ( ident . getWhen ( ) ) ; default : tz = ident . getTimeZone ( ) ; if ( tz == null ) tz = SystemReader . getInstance ( ) . getTimeZone ( ) ; dateTimeInstance . setTimeZone ( ident . getTimeZone ( ) ) ; return dateTimeInstance . format ( ident . getWhen ( ) ) ; } }
public DeregisterStreamConsumerResult deregisterStreamConsumer ( DeregisterStreamConsumerRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterStreamConsumer ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; return true ; }
public ByteBuffer asReadOnlyBuffer ( ) { return ReadOnlyHeapByteBuffer . copy ( this , mark ) ; }
public long ramBytesUsed ( ) { long sizeInBytes = 0 ; for ( FieldIndexData entry : fields . values ( ) ) { sizeInBytes += entry . ramBytesUsed ( ) ; } return sizeInBytes ; }
public CreateTransitGatewayRouteTableResult createTransitGatewayRouteTable ( CreateTransitGatewayRouteTableRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTransitGatewayRouteTable ( request ) ; }
public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; int size = 0 ; field_1_color1 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_2_color2 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_3_color3 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_4_color4 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; bytesRemaining -= size ; if ( bytesRemaining != 0 ) { throw new RecordFormatException ( " Expecting ▁ no ▁ remaining ▁ data ▁ but ▁ got ▁ " + bytesRemaining + " ▁ byte ( s ) . " ) ; } return 8 + size + bytesRemaining ; }
public CharSequence [ ] getMultiFields ( ) { return getQueryConfigHandler ( ) . get ( ConfigurationKeys . MULTI_FIELDS ) ; }
public boolean hasNext ( ) { return returnedNumber < getObjectCount ( ) ; }
public String toString ( ) { return SpatialArgsParser . writeSpatialArgs ( this ) ; }
public static RowRecord createRow ( int rowNumber ) { return new RowRecord ( rowNumber ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeByte ( field_1_last_column_index ) ; out . writeByte ( field_2_first_column_index ) ; out . writeShort ( field_3_row_index ) ; ConstantValueParser . encode ( out , field_4_constant_values ) ; }
public DescribeHostReservationOfferingsResult describeHostReservationOfferings ( DescribeHostReservationOfferingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeHostReservationOfferings ( request ) ; }
public void setEmpty ( ) { field_2_first_col = 0 ; field_3_last_col = 0 ; }
public CancelBundleTaskResult cancelBundleTask ( CancelBundleTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelBundleTask ( request ) ; }
public ShingleFilter ( TokenStream input , String tokenType ) { this ( input , DEFAULT_MIN_SHINGLE_SIZE , DEFAULT_MAX_SHINGLE_SIZE ) ; setTokenType ( tokenType ) ; }
public MergeException ( String message , Directory dir ) { super ( message ) ; this . dir = dir ; }
public TestDNSAnswerResult testDNSAnswer ( TestDNSAnswerRequest request ) { request = beforeClientExecution ( request ) ; return executeTestDNSAnswer ( request ) ; }
public String getFieldAsString ( ) { return field . toString ( ) ; }
public GetMasterAccountResult getMasterAccount ( GetMasterAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMasterAccount ( request ) ; }
public int getIndexVersion ( ) { return indexVersion ; }
public GetAdmChannelResult getAdmChannel ( GetAdmChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAdmChannel ( request ) ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof BasicQueryFactory ) ) return false ; BasicQueryFactory other = ( BasicQueryFactory ) obj ; return atMax ( ) == other . atMax ( ) ; }
public byte readByte ( ) { return ( byte ) readUByte ( ) ; }
public DeletePolicyResult deletePolicy ( DeletePolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeletePolicy ( request ) ; }
public String get ( Object key ) { return idMap . get ( key ) ; }
public void setNonLocalizedMessage ( Message message ) { this . message = message ; }
public DescribeClusterVersionsResult describeClusterVersions ( ) { return describeClusterVersions ( new DescribeClusterVersionsRequest ( ) ) ; }
public void onPostReceive ( ReceivePack rp , Collection < ReceiveCommand > commands ) { for ( int i = 0 ; i < count ; i ++ ) hooks [ i ] . onPostReceive ( rp , commands ) ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " ^ " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public int stem ( char s [ ] , int len ) { if ( len < 6 ) return len ; if ( s [ len - 1 ] == ' x ' ) { if ( s [ len - 3 ] == ' a ' && s [ len - 2 ] == ' u ' ) s [ len - 2 ] = ' l ' ; return len - 1 ; } if ( s [ len - 1 ] == ' s ' ) len -- ; if ( s [ len - 1 ] == ' r ' ) len -- ; if ( s [ len - 1 ] == ' e ' ) len -- ; if ( s [ len - 1 ] == ' é ' ) len -- ; if ( s [ len - 1 ] == s [ len - 2 ] && Character . isLetter ( s [ len - 1 ] ) ) len -- ; return len ; }
public static RkRec [ ] parseRKs ( RecordInputStream in ) { int nItems = ( in . remaining ( ) - 2 ) / ENCODED_SIZE ; RkRec [ ] retval = new RkRec [ nItems ] ; for ( int i = 0 ; i < nItems ; i ++ ) { retval [ i ] = new RkRec ( in ) ; } return retval ; }
public boolean deliverSelfNotifications ( ) { return true ; }
public CreateWorkteamResult createWorkteam ( CreateWorkteamRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateWorkteam ( request ) ; }
public ProfilingATNSimulator ( Parser parser ) { super ( parser , parser . getInterpreter ( ) . atn , parser . getInterpreter ( ) . decisionToDFA , parser . getInterpreter ( ) . sharedContextCache ) ; numDecisions = atn . decisionToState . size ( ) ; decisions = new DecisionInfo [ numDecisions ] ; for ( int i = 0 ; i < numDecisions ; i ++ ) { decisions [ i ] = new DecisionInfo ( i ) ; } }
public DescribeDeliveryStreamResult describeDeliveryStream ( DescribeDeliveryStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDeliveryStream ( request ) ; }
public boolean hasNext ( ) { return link . next != list . voidLink ; }
public static double product ( double [ ] values ) { double product = 0 ; if ( values != null && values . length > 0 ) { product = 1 ; for ( double value : values ) { product *= value ; } } return product ; }
public RebaseCommand setUpstream ( String upstream ) throws RefNotFoundException { try { ObjectId upstreamId = repo . resolve ( upstream ) ; if ( upstreamId == null ) throw new RefNotFoundException ( MessageFormat . format ( JGitText . get ( ) . refNotResolved , upstream ) ) ; upstreamCommit = walk . parseCommit ( repo . resolve ( upstream ) ) ; upstreamCommitName = upstream ; return this ; } catch ( IOException ioe ) { throw new JGitInternalException ( ioe . getMessage ( ) , ioe ) ; } }
public ATN ( ATNType grammarType , int maxTokenType ) { this . grammarType = grammarType ; this . maxTokenType = maxTokenType ; }
public HyphenatedWordsFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public GetBlueprintsResult getBlueprints ( GetBlueprintsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetBlueprints ( request ) ; }
public synchronized StringBuffer append ( StringBuffer sb ) { if ( sb == null ) { appendNull ( ) ; } else { synchronized ( sb ) { append0 ( sb . getValue ( ) , 0 , sb . length ( ) ) ; } } return this ; }
public EngineDefaults describeEngineDefaultClusterParameters ( DescribeEngineDefaultClusterParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEngineDefaultClusterParameters ( request ) ; }
public DeleteLaunchTemplateResult deleteLaunchTemplate ( DeleteLaunchTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLaunchTemplate ( request ) ; }
public Object toObject ( ) { assert exists || ( false == value ) ; return exists ? value : null ; }
public ObjectReader newObjectReader ( ) { return getObjectDatabase ( ) . newReader ( ) ; }
public String toString ( ) { String nl = System . getProperty ( " line . separtor " ) ; StringBuilder result = new StringBuilder ( ) ; result . append ( ' [ ' ) . append ( getRecordName ( ) ) . append ( ' ] ' ) . append ( nl ) ; for ( EscherRecord escherRecord : getEscherRecords ( ) ) { result . append ( escherRecord ) ; } result . append ( " [ / " ) . append ( getRecordName ( ) ) . append ( ' ] ' ) . append ( nl ) ; return result . toString ( ) ; }
public GetSnapshotBlockResult getSnapshotBlock ( GetSnapshotBlockRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSnapshotBlock ( request ) ; }
public HSSFComment createComment ( HSSFAnchor anchor ) { HSSFComment shape = new HSSFComment ( null , anchor ) ; addShape ( shape ) ; onCreate ( shape ) ; return shape ; }
public CopySnapshotResult copySnapshot ( CopySnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCopySnapshot ( request ) ; }
public String toString ( ) { return " < quotedfield ▁ start = ' " ▁ + ▁ this . begin ▁ + ▁ " ' ▁ end = ' " ▁ + ▁ this . end + ▁ " ' ▁ field = ' " ▁ + ▁ this . field ▁ + ▁ " ' ▁ term = ' " ▁ + ▁ this . text ▁ + ▁ " ' /> " ; }
public void write ( int b ) throws IOException { throw new IllegalStateException ( JGitText . get ( ) . writingNotPermitted ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { try { String needle = TextFunction . evaluateStringArg ( arg0 , srcRowIndex , srcColumnIndex ) ; String haystack = TextFunction . evaluateStringArg ( arg1 , srcRowIndex , srcColumnIndex ) ; return eval ( haystack , needle , 0 ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public NumberMatcher ( double value , CmpOp operator ) { super ( operator ) ; _value = value ; }
public GroupingSearch setCachingInMB ( double maxCacheRAMMB , boolean cacheScores ) { this . maxCacheRAMMB = maxCacheRAMMB ; this . maxDocsToCache = null ; this . cacheScores = cacheScores ; return this ; }
public DescribeRegionsResult describeRegions ( DescribeRegionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeRegions ( request ) ; }
public ListApplicationRevisionsResult listApplicationRevisions ( ListApplicationRevisionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListApplicationRevisions ( request ) ; }
public int set ( int index , long [ ] arr , int off , int len ) { long max = 0 ; for ( int i = off , end = off + len ; i < end ; ++ i ) { max |= arr [ i ] ; } ensureCapacity ( max ) ; return current . set ( index , arr , off , len ) ; }
public MutableValue duplicate ( ) { MutableValueDate v = new MutableValueDate ( ) ; v . value = this . value ; v . exists = this . exists ; return v ; }
public DeleteUserResult deleteUser ( DeleteUserRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteUser ( request ) ; }
public String getPath ( ) { return path ; }
public ListVerifiedEmailAddressesResult listVerifiedEmailAddresses ( ) { return listVerifiedEmailAddresses ( new ListVerifiedEmailAddressesRequest ( ) ) ; }
public DescribeStackResourceResult describeStackResource ( DescribeStackResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStackResource ( request ) ; }
public MetricsTagPredicate ( Tag tag ) { this . tag = tag ; }
public void remove ( ) { if ( last == null ) { throw new IllegalStateException ( ) ; } removeInternal ( last ) ; expectedModCount = modCount ; last = null ; }
public void setExecutor ( Executor executor ) { this . executor = executor ; }
public boolean hasDirectoryEntry ( ) { EmbeddedObjectRefSubRecord subRecord = findObjectRecord ( ) ; Integer streamId = subRecord . getStreamId ( ) ; return streamId != null && streamId . intValue ( ) != 0 ; }
public K higherKey ( K key ) { Entry < K , V > entry = findBounded ( key , HIGHER ) ; return entry != null ? entry . getKey ( ) : null ; }
public void exitRule ( ) { if ( matchedEOF ) { _ctx . stop = _input . LT ( 1 ) ; } else { _ctx . stop = _input . LT ( - 1 ) ; } if ( _parseListeners != null ) triggerExitRuleEvent ( ) ; setState ( _ctx . invokingState ) ; _ctx = ( ParserRuleContext ) _ctx . parent ; }
public DeleteTrafficPolicyInstanceResult deleteTrafficPolicyInstance ( DeleteTrafficPolicyInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTrafficPolicyInstance ( request ) ; }
public boolean check ( final int level ) { int currentLevel ; try { currentLevel = Integer . parseInt ( System . getProperty ( " poi . log . level " , WARN + " " ) ) ; } catch ( SecurityException e ) { currentLevel = POILogger . DEBUG ; } return level >= currentLevel ; }
public ShortBuffer put ( short c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } backingArray [ offset + position ++ ] = c ; return this ; }
public DeletePublicKeyResult deletePublicKey ( DeletePublicKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeletePublicKey ( request ) ; }
public ObjectId idFor ( int type , byte [ ] data ) { return delegate ( ) . idFor ( type , data ) ; }
public DeleteDBProxyResult deleteDBProxy ( DeleteDBProxyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDBProxy ( request ) ; }
public void add ( int n ) { if ( count == entries . length ) grow ( ) ; entries [ count ++ ] = n ; }
public PortugueseStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public DisconnectParticipantResult disconnectParticipant ( DisconnectParticipantRequest request ) { request = beforeClientExecution ( request ) ; return executeDisconnectParticipant ( request ) ; }
public ObjectId getPeeledObjectId ( ) { return null ; }
public DeleteParameterGroupResult deleteParameterGroup ( DeleteParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteParameterGroup ( request ) ; }
public TextRecord ( RecordInputStream in ) { field_1_horizontalAlignment = in . readByte ( ) ; field_2_verticalAlignment = in . readByte ( ) ; field_3_displayMode = in . readShort ( ) ; field_4_rgbColor = in . readInt ( ) ; field_5_x = in . readInt ( ) ; field_6_y = in . readInt ( ) ; field_7_width = in . readInt ( ) ; field_8_height = in . readInt ( ) ; field_9_options1 = in . readShort ( ) ; field_10_indexOfColorValue = in . readShort ( ) ; field_11_options2 = in . readShort ( ) ; field_12_textRotation = in . readShort ( ) ; }
public ReflogCommand setRef ( String ref ) { checkCallable ( ) ; this . ref = ref ; return this ; }
@ Override public boolean contains ( Object object ) { Object [ ] a = array ; int s = size ; if ( object != null ) { for ( int i = 0 ; i < s ; i ++ ) { if ( object . equals ( a [ i ] ) ) { return true ; } } } else { for ( int i = 0 ; i < s ; i ++ ) { if ( a [ i ] == null ) { return true ; } } } return false ; }
public CreateFpgaImageResult createFpgaImage ( CreateFpgaImageRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFpgaImage ( request ) ; }
public DescribeAggregateIdFormatResult describeAggregateIdFormat ( DescribeAggregateIdFormatRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAggregateIdFormat ( request ) ; }
public ListMultipartUploadsRequest ( String vaultName ) { setVaultName ( vaultName ) ; }
public DeleteRepoRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " DeleteRepo " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] " ) ; setMethod ( MethodType . DELETE ) ; }
public static BOFRecord createSheetBOF ( ) { return new BOFRecord ( TYPE_WORKSHEET ) ; }
public FloatBuffer put ( float [ ] src , int srcOffset , int floatCount ) { byteBuffer . limit ( limit * SizeOf . FLOAT ) ; byteBuffer . position ( position * SizeOf . FLOAT ) ; if ( byteBuffer instanceof ReadWriteDirectByteBuffer ) { ( ( ReadWriteDirectByteBuffer ) byteBuffer ) . put ( src , srcOffset , floatCount ) ; } else { ( ( ReadWriteHeapByteBuffer ) byteBuffer ) . put ( src , srcOffset , floatCount ) ; } this . position += floatCount ; return this ; }
public void execute ( Lexer lexer ) { lexer . popMode ( ) ; }
public DeleteImageRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " DeleteImage " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / tags / [ Tag ] " ) ; setMethod ( MethodType . DELETE ) ; }
public CreateImageBuilderResult createImageBuilder ( CreateImageBuilderRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateImageBuilder ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getRow ( ) ) ; out . writeShort ( getColumn ( ) ) ; out . writeShort ( getXFIndex ( ) ) ; }
public UpdateSegmentResult updateSegment ( UpdateSegmentRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateSegment ( request ) ; }
public DescribeSnapshotsResult describeSnapshots ( ) { return describeSnapshots ( new DescribeSnapshotsRequest ( ) ) ; }
public AddNoteCommand setObjectId ( RevObject id ) { checkCallable ( ) ; this . id = id ; return this ; }
public String toString ( ) { return path ; }
public GetMetricStatisticsResult getMetricStatistics ( GetMetricStatisticsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMetricStatistics ( request ) ; }
public DescribeAutoScalingInstancesResult describeAutoScalingInstances ( DescribeAutoScalingInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAutoScalingInstances ( request ) ; }
public TokenFilter create ( TokenStream input ) { return new KStemFilter ( input ) ; }
public CreateEnvironmentRequest ( String applicationName , String environmentName ) { setApplicationName ( applicationName ) ; setEnvironmentName ( environmentName ) ; }
public static LongBuffer allocate ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( ) ; } return new ReadWriteLongArrayBuffer ( capacity ) ; }
public GetIdentityMailFromDomainAttributesResult getIdentityMailFromDomainAttributes ( GetIdentityMailFromDomainAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIdentityMailFromDomainAttributes ( request ) ; }
public boolean isForce ( ) { return force ; }
public DescribeImageScanFindingsResult describeImageScanFindings ( DescribeImageScanFindingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeImageScanFindings ( request ) ; }
public SendContactMethodVerificationResult sendContactMethodVerification ( SendContactMethodVerificationRequest request ) { request = beforeClientExecution ( request ) ; return executeSendContactMethodVerification ( request ) ; }
public DeleteReceiptFilterResult deleteReceiptFilter ( DeleteReceiptFilterRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteReceiptFilter ( request ) ; }
public void updateFormulaResult ( ValueEval result , CellCacheEntry [ ] sensitiveInputCells , FormulaUsedBlankCellSet usedBlankAreas ) { updateValue ( result ) ; setSensitiveInputCells ( sensitiveInputCells ) ; _usedBlankCellGroup = usedBlankAreas ; }
public String toString ( ) { final StringBuilder r = new StringBuilder ( ) ; r . append ( " ( " ) ; for ( int i = 0 ; i < subfilters . length ; i ++ ) { if ( i > 0 ) r . append ( " ▁ OR ▁ " ) ; r . append ( subfilters [ i ] . toString ( ) ) ; } r . append ( " ) " ) ; return r . toString ( ) ; }
public boolean equals ( Object o ) { return o instanceof FrenchStemmer ; }
public MergedCellsTable ( ) { _mergedRegions = new ArrayList <> ( ) ; }
public PrecedencePredicateTransition ( ATNState target , int precedence ) { super ( target ) ; this . precedence = precedence ; }
public String toFormulaString ( ) { throw new RuntimeException ( " Coding ▁ Error : ▁ Expected ▁ ExpPtg ▁ to ▁ be ▁ converted ▁ from ▁ Shared ▁ to ▁ Non - Shared ▁ Formula ▁ by ▁ ValueRecordsAggregate , ▁ but ▁ it ▁ wasn ' t " ) ; }
public ParseTree getChild ( int i ) { return children != null && i >= 0 && i < children . size ( ) ? children . get ( i ) : null ; }
public ListIterator < E > listIterator ( int index ) { return delegate ( ) . listIterator ( index ) ; }
public StringBuffer getBuffer ( ) { return buf ; }
public BytesRefHash ( ByteBlockPool pool , int capacity , BytesStartArray bytesStartArray ) { hashSize = capacity ; hashHalfSize = hashSize >> 1 ; hashMask = hashSize - 1 ; this . pool = pool ; ids = new int [ hashSize ] ; Arrays . fill ( ids , - 1 ) ; this . bytesStartArray = bytesStartArray ; bytesStart = bytesStartArray . init ( ) ; bytesUsed = bytesStartArray . bytesUsed ( ) == null ? Counter . newCounter ( ) : bytesStartArray . bytesUsed ( ) ; bytesUsed . addAndGet ( hashSize * Integer . BYTES ) ; }
public GetIdentityDkimAttributesResult getIdentityDkimAttributes ( GetIdentityDkimAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIdentityDkimAttributes ( request ) ; }
public DescribeSubnetsResult describeSubnets ( DescribeSubnetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSubnets ( request ) ; }
public final void serialize ( LittleEndianOutput out ) { if ( getTextLength ( ) > 0 ) { out . writeShort ( getTextLength ( ) ) ; out . writeByte ( field_2_hasMultibyte ? 0x01 : 0x00 ) ; if ( field_2_hasMultibyte ) { StringUtil . putUnicodeLE ( field_3_text , out ) ; } else { StringUtil . putCompressedUnicode ( field_3_text , out ) ; } } }
public DeleteMessageRequest ( String queueUrl , String receiptHandle ) { setQueueUrl ( queueUrl ) ; setReceiptHandle ( receiptHandle ) ; }
public int find ( char [ ] key , int start ) { int d ; char p = root ; int i = start ; char c ; while ( p != 0 ) { if ( sc [ p ] == 0xFFFF ) { if ( strcmp ( key , i , kv . getArray ( ) , lo [ p ] ) == 0 ) { return eq [ p ] ; } else { return - 1 ; } } c = key [ i ] ; d = c - sc [ p ] ; if ( d == 0 ) { if ( c == 0 ) { return eq [ p ] ; } i ++ ; p = eq [ p ] ; } else if ( d < 0 ) { p = lo [ p ] ; } else { p = hi [ p ] ; } } return - 1 ; }
public DescribeIdFormatResult describeIdFormat ( DescribeIdFormatRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIdFormat ( request ) ; }
public void setCharAt ( int index , char ch ) { if ( index < 0 || index >= count ) { throw indexAndLength ( index ) ; } if ( shared ) { value = value . clone ( ) ; shared = false ; } value [ index ] = ch ; }
public FieldFragList createFieldFragList ( FieldPhraseList fieldPhraseList , int fragCharSize ) { FieldFragList ffl = new SimpleFieldFragList ( fragCharSize ) ; List < WeightedPhraseInfo > wpil = new ArrayList <> ( ) ; Iterator < WeightedPhraseInfo > ite = fieldPhraseList . phraseList . iterator ( ) ; WeightedPhraseInfo phraseInfo = null ; while ( true ) { if ( ! ite . hasNext ( ) ) break ; phraseInfo = ite . next ( ) ; if ( phraseInfo == null ) break ; wpil . add ( phraseInfo ) ; } if ( wpil . size ( ) > 0 ) ffl . add ( 0 , Integer . MAX_VALUE , wpil ) ; return ffl ; }
public List < String > getModifiedList ( ) { return modifiedList ; }
public synchronized int capacity ( ) { return elementData . length ; }
public GermanLightStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void setAnchor ( short col1 , int row1 , int x1 , int y1 , short col2 , int row2 , int x2 , int y2 ) { checkRange ( getDx1 ( ) , 0 , 1023 , " dx1 " ) ; checkRange ( getDx2 ( ) , 0 , 1023 , " dx2 " ) ; checkRange ( getDy1 ( ) , 0 , 255 , " dy1 " ) ; checkRange ( getDy2 ( ) , 0 , 255 , " dy2 " ) ; checkRange ( getCol1 ( ) , 0 , MAX_COL , " col1 " ) ; checkRange ( getCol2 ( ) , 0 , MAX_COL , " col2 " ) ; checkRange ( getRow1 ( ) , 0 , MAX_ROW , " row1 " ) ; checkRange ( getRow2 ( ) , 0 , MAX_ROW , " row2 " ) ; setCol1 ( col1 ) ; setRow1 ( row1 ) ; setDx1 ( x1 ) ; setDy1 ( y1 ) ; setCol2 ( col2 ) ; setRow2 ( row2 ) ; setDx2 ( x2 ) ; setDy2 ( y2 ) ; }
public static ErrorEval valueOf ( int errorCode ) { FormulaError error = FormulaError . forInt ( errorCode ) ; ErrorEval eval = evals . get ( error ) ; if ( eval != null ) { return eval ; } else { throw new RuntimeException ( " Unhandled ▁ error ▁ type ▁ for ▁ code ▁ " + errorCode ) ; } }
public static long calculateChecksum ( byte [ ] data ) { Checksum sum = new CRC32 ( ) ; sum . update ( data , 0 , data . length ) ; return sum . getValue ( ) ; }
public RevCommit lookupCommit ( AnyObjectId id ) { RevCommit c = ( RevCommit ) objects . get ( id ) ; if ( c == null ) { c = createCommit ( id ) ; objects . add ( c ) ; } return c ; }
public String toString ( ) { QueryText text = this . values . get ( 0 ) ; return " < path ▁ start = ' " ▁ + ▁ text . begin ▁ + ▁ " ' ▁ end = ' " ▁ + ▁ text . end ▁ + ▁ " ' ▁ path = ' " + ▁ getPathString ( ) ▁ + ▁ " ' /> " ; }
public TokenStream create ( TokenStream input ) { StopFilter stopFilter = new StopFilter ( input , stopWords ) ; return stopFilter ; }
public DeleteStreamProcessorResult deleteStreamProcessor ( DeleteStreamProcessorRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteStreamProcessor ( request ) ; }
public RuleWithSetExceptions ( String suffix , int min , String replacement , String [ ] exceptions ) { super ( suffix , min , replacement ) ; for ( int i = 0 ; i < exceptions . length ; i ++ ) { if ( ! exceptions [ i ] . endsWith ( suffix ) ) throw new RuntimeException ( " useless ▁ exception ▁ ' " ▁ + ▁ exceptions [ i ] ▁ + ▁ " ' ▁ does ▁ not ▁ end ▁ with ▁ ' " ▁ + ▁ suffix ▁ + ▁ " ' " ) ; } this . exceptions = new CharArraySet ( Arrays . asList ( exceptions ) , false ) ; }
public CreateClientVpnRouteResult createClientVpnRoute ( CreateClientVpnRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateClientVpnRoute ( request ) ; }
public RangeTransition ( ATNState target , int from , int to ) { super ( target ) ; this . from = from ; this . to = to ; }
public TypeAsPayloadTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void fromRaw ( int [ ] ints , int p ) { w1 = ints [ p ] ; w2 = ints [ p + 1 ] ; w3 = ints [ p + 2 ] ; w4 = ints [ p + 3 ] ; w5 = ints [ p + 4 ] ; }
public ICUNormalizer2Filter ( TokenStream input , Normalizer2 normalizer ) { super ( input ) ; this . normalizer = normalizer ; }
public static TreeFilter create ( TreeFilter a ) { return new NotTreeFilter ( a ) ; }
public boolean isMalformed ( ) { return this . type == TYPE_MALFORMED_INPUT ; }
public void enterRecursionRule ( ParserRuleContext localctx , int state , int ruleIndex , int precedence ) { Pair < ParserRuleContext , Integer > pair = new Pair < ParserRuleContext , Integer > ( _ctx , localctx . invokingState ) ; _parentContextStack . push ( pair ) ; super . enterRecursionRule ( localctx , state , ruleIndex , precedence ) ; }
public DescribeAddressesResult describeAddresses ( DescribeAddressesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAddresses ( request ) ; }
public int getEstimatedUniqueValues ( ) { return getEstimatedNumberUniqueValuesAllowingForCollisions ( bloomSize , filter . cardinality ( ) ) ; }
public DescribeTransformJobResult describeTransformJob ( DescribeTransformJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTransformJob ( request ) ; }
public HeaderFooterRecord clone ( ) { return copy ( ) ; }
public void decode ( long [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block0 = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = block0 >>> 40 ; values [ valuesOffset ++ ] = ( block0 >>> 16 ) & 16777215L ; final long block1 = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( ( block0 & 65535L ) << 8 ) | ( block1 >>> 56 ) ; values [ valuesOffset ++ ] = ( block1 >>> 32 ) & 16777215L ; values [ valuesOffset ++ ] = ( block1 >>> 8 ) & 16777215L ; final long block2 = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( ( block1 & 255L ) << 16 ) | ( block2 >>> 48 ) ; values [ valuesOffset ++ ] = ( block2 >>> 24 ) & 16777215L ; values [ valuesOffset ++ ] = block2 & 16777215L ; } }
public FieldInfo fieldInfo ( int fieldNumber ) { if ( fieldNumber < 0 ) { throw new IllegalArgumentException ( " Illegal ▁ field ▁ number : ▁ " + fieldNumber ) ; } if ( fieldNumber >= byNumber . length ) { return null ; } return byNumber [ fieldNumber ] ; }
public DescribeIdentityPoolResult describeIdentityPool ( DescribeIdentityPoolRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIdentityPool ( request ) ; }
public static String getText ( Node e ) { StringBuilder sb = new StringBuilder ( ) ; getTextBuffer ( e , sb ) ; return sb . toString ( ) ; }
public void delete ( int key ) { int i = binarySearch ( mKeys , 0 , mSize , key ) ; if ( i >= 0 ) { removeAt ( i ) ; } }
public GetCurrentMetricDataResult getCurrentMetricData ( GetCurrentMetricDataRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCurrentMetricData ( request ) ; }
public void append ( String name , FileMode mode , AnyObjectId id ) { append ( encode ( name ) , mode , id ) ; }
public final String replacement ( ) { return replacementChars ; }
public WindowProtectRecord ( boolean protect ) { this ( 0 ) ; setProtect ( protect ) ; }
public static boolean equals ( long [ ] array1 , long [ ] array2 ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1. length != array2. length ) { return false ; } for ( int i = 0 ; i < array1. length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) { return false ; } } return true ; }
public PredictionContext getParent ( int index ) { assert index == 0 ; return parent ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { return " *:* " ; }
public SeekStatus seekCeil ( BytesRef term ) throws IOException { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) + " ▁ does ▁ not ▁ support ▁ seeking " ) ; }
public BindInstance2VpcRequest ( ) { super ( " Ots " , " 2016 - 06 - 20 " , " BindInstance2Vpc " , " ots " ) ; setMethod ( MethodType . POST ) ; }
public UpdateTableResult updateTable ( String tableName , ProvisionedThroughput provisionedThroughput ) { return updateTable ( new UpdateTableRequest ( ) . withTableName ( tableName ) . withProvisionedThroughput ( provisionedThroughput ) ) ; }
public boolean get ( int index ) { return in . get ( docMap . newToOld ( index ) ) ; }
public GetQueueAttributesResult getQueueAttributes ( GetQueueAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetQueueAttributes ( request ) ; }
public UpdateUserRoutingProfileResult updateUserRoutingProfile ( UpdateUserRoutingProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateUserRoutingProfile ( request ) ; }
public int getMidIx ( ) { int ixDiff = _highIx - _lowIx ; if ( ixDiff < 2 ) { return - 1 ; } return _lowIx + ( ixDiff / 2 ) ; }
public MergeResult getMergeResult ( ) { return this . mergeResult ; }
public void setAsActiveCell ( ) { int row = _record . getRow ( ) ; short col = _record . getColumn ( ) ; _sheet . getSheet ( ) . setActiveCellRow ( row ) ; _sheet . getSheet ( ) . setActiveCellCol ( col ) ; }
public InviteMembersResult inviteMembers ( InviteMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeInviteMembers ( request ) ; }
public FormatTrackingHSSFListener ( HSSFListener childListener ) { this ( childListener , LocaleUtil . getUserLocale ( ) ) ; }
public UpdateDistributionRequest ( DistributionConfig distributionConfig , String id , String ifMatch ) { setDistributionConfig ( distributionConfig ) ; setId ( id ) ; setIfMatch ( ifMatch ) ; }
public GetLogEventsRequest ( String logGroupName , String logStreamName ) { setLogGroupName ( logGroupName ) ; setLogStreamName ( logStreamName ) ; }
public String toString ( ) { return " FlushInfo ▁ [ numDocs = " + numDocs + " , ▁ estimatedSegmentSize = " + estimatedSegmentSize + " ] " ; }
public GrowableWriter resize ( int newSize ) { GrowableWriter next = new GrowableWriter ( getBitsPerValue ( ) , newSize , acceptableOverheadRatio ) ; final int limit = Math . min ( size ( ) , newSize ) ; PackedInts . copy ( current , 0 , next , 0 , limit , PackedInts . DEFAULT_BUFFER_SIZE ) ; return next ; }
public Analyzer ( ReuseStrategy reuseStrategy ) { this . reuseStrategy = reuseStrategy ; }
public void reset ( ) { prevAccept . reset ( ) ; startIndex = - 1 ; line = 1 ; charPositionInLine = 0 ; mode = Lexer . DEFAULT_MODE ; }
public EmbeddedObjectRefSubRecord ( ) { field_2_unknownFormulaData = new byte [ ] { 0x02 , 0x6C , 0x6A , 0x16 , 0x01 , } ; field_6_unknown = EMPTY_BYTE_ARRAY ; field_4_ole_classname = null ; }
public String toString ( ) { return " doc = " + doc + " ▁ score = " + score + " ▁ shardIndex = " + shardIndex ; }
public static double kthLargest ( double [ ] v , int k ) { double r = Double . NaN ; int index = k - 1 ; if ( v != null && v . length > index && index >= 0 ) { Arrays . sort ( v ) ; r = v [ v . length - index - 1 ] ; } return r ; }
public int get ( int forwardId , int backwardId ) { int offset = ( backwardId * forwardSize + forwardId ) * 2 ; return buffer . getShort ( offset ) ; }
public void sort ( ) { Arrays . sort ( entries , 0 , count ) ; }
public BM25FQuery build ( ) { int size = fieldAndWeights . size ( ) * termsSet . size ( ) ; if ( size > IndexSearcher . getMaxClauseCount ( ) ) { throw new IndexSearcher . TooManyClauses ( ) ; } BytesRef [ ] terms = termsSet . toArray ( new BytesRef [ 0 ] ) ; return new BM25FQuery ( similarity , new TreeMap <> ( fieldAndWeights ) , terms ) ; }
public LexerCustomAction ( int ruleIndex , int actionIndex ) { this . ruleIndex = ruleIndex ; this . actionIndex = actionIndex ; }
public DescribeDevicePolicyConfigurationResult describeDevicePolicyConfiguration ( DescribeDevicePolicyConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDevicePolicyConfiguration ( request ) ; }
public CreateLBCookieStickinessPolicyRequest ( String loadBalancerName , String policyName ) { setLoadBalancerName ( loadBalancerName ) ; setPolicyName ( policyName ) ; }
public static short [ ] grow ( short [ ] array ) { return grow ( array , 1 + array . length ) ; }
public static AttrPtg createSpace ( int type , int count ) { int data = type & 0x00FF | ( count << 8 ) & 0x00FFFF ; return new AttrPtg ( space . set ( 0 ) , data , null , - 1 ) ; }
public boolean equals ( Object o ) { return ( o instanceof FontRecord ) && sameProperties ( ( FontRecord ) o ) ; }
public void setDSTSavings ( int milliseconds ) { if ( milliseconds > 0 ) { dstSavings = milliseconds ; } else { throw new IllegalArgumentException ( ) ; } }
public DescribeAccountResult describeAccount ( DescribeAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAccount ( request ) ; }
public int getCellsVal ( ) { int size = 0 ; for ( Row row : rows ) size += row . getCellsVal ( ) ; return size ; }
public boolean equalsSameType ( Object other ) { assert exists || ( false == value ) ; MutableValueBool b = ( MutableValueBool ) other ; return value == b . value && exists == b . exists ; }
public K next ( ) { Node < K , V > n = next ; advance ( ) ; return n . key ; }
public DBCluster createDBCluster ( CreateDBClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBCluster ( request ) ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof FormatRun ) ) { return false ; } FormatRun other = ( FormatRun ) o ; return _character == other . _character && _fontIndex == other . _fontIndex ; }
public static ValueEval getSingleValue ( ValueEval arg , int srcCellRow , int srcCellCol ) throws EvaluationException { final ValueEval result ; if ( arg instanceof RefEval ) { result = chooseSingleElementFromRef ( ( RefEval ) arg ) ; } else if ( arg instanceof AreaEval ) { result = chooseSingleElementFromArea ( ( AreaEval ) arg , srcCellRow , srcCellCol ) ; } else { result = arg ; } if ( result instanceof ErrorEval ) { throw new EvaluationException ( ( ErrorEval ) result ) ; } return result ; }
public GermanStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public ClusterSubnetGroup modifyClusterSubnetGroup ( ModifyClusterSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyClusterSubnetGroup ( request ) ; }
public FacetLabel subpath ( final int length ) { if ( length >= this . length || length < 0 ) { return this ; } else { return new FacetLabel ( this , length ) ; } }
public DataValidationConstraint createDecimalConstraint ( int operatorType , String formula1 , String formula2 ) { return DVConstraint . createNumericConstraint ( ValidationType . DECIMAL , operatorType , formula1 , formula2 ) ; }
public ByteBuffer put ( byte b ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } backingArray [ offset + position ++ ] = b ; return this ; }
public DescribeUserProfileResult describeUserProfile ( DescribeUserProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeUserProfile ( request ) ; }
public K firstKey ( ) { Entry < K , V > entry = endpoint ( true ) ; if ( entry == null ) { throw new NoSuchElementException ( ) ; } return entry . getKey ( ) ; }
public DescribeAutoScalingGroupsResult describeAutoScalingGroups ( DescribeAutoScalingGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAutoScalingGroups ( request ) ; }
public Class < RefsChangedListener > getListenerType ( ) { return RefsChangedListener . class ; }
public int getWordCost ( int wordId ) { return WORD_COST ; }
public void serialize ( LittleEndianOutput out ) { out . writeByte ( field_1_horizontalAlignment ) ; out . writeByte ( field_2_verticalAlignment ) ; out . writeShort ( field_3_displayMode ) ; out . writeInt ( field_4_rgbColor ) ; out . writeInt ( field_5_x ) ; out . writeInt ( field_6_y ) ; out . writeInt ( field_7_width ) ; out . writeInt ( field_8_height ) ; out . writeShort ( field_9_options1 ) ; out . writeShort ( field_10_indexOfColorValue ) ; out . writeShort ( field_11_options2 ) ; out . writeShort ( field_12_textRotation ) ; }
public LinkedDataRecord getDataCategoryLabels ( ) { return dataCategoryLabels ; }
public void setStringValue ( String value ) { collator . getRawCollationKey ( value , key ) ; bytes . bytes = key . bytes ; bytes . offset = 0 ; bytes . length = key . size ; }
public String toString ( ) { return " FacetField ( dim = " + dim + " ▁ path = " + Arrays . toString ( path ) + " ) " ; }
public static long gcd ( long a , long b ) { a = Math . abs ( a ) ; b = Math . abs ( b ) ; if ( a == 0 ) { return b ; } else if ( b == 0 ) { return a ; } final int commonTrailingZeros = Long . numberOfTrailingZeros ( a | b ) ; a >>>= Long . numberOfTrailingZeros ( a ) ; while ( true ) { b >>>= Long . numberOfTrailingZeros ( b ) ; if ( a == b ) { break ; } else if ( a > b || a == Long . MIN_VALUE ) { final long tmp = a ; a = b ; b = tmp ; } if ( a == 1 ) { break ; } b -= a ; } return a << commonTrailingZeros ; }
public BatchRefUpdate disableRefLog ( ) { refLogMessage = null ; refLogIncludeResult = false ; return this ; }
public static int compareTo ( Ref o1 , String o2 ) { return o1. getName ( ) . compareTo ( o2 ) ; }
public CreateLoadBalancerTlsCertificateResult createLoadBalancerTlsCertificate ( CreateLoadBalancerTlsCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLoadBalancerTlsCertificate ( request ) ; }
public GetDocumentationPartsResult getDocumentationParts ( GetDocumentationPartsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDocumentationParts ( request ) ; }
public Iterator < RevFlag > iterator ( ) { final Iterator < RevFlag > i = active . iterator ( ) ; return new Iterator < RevFlag > ( ) ; }
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Sort ) ) return false ; final Sort other = ( Sort ) o ; return Arrays . equals ( this . fields , other . fields ) ; }
public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { POIFSDocumentPath path = ( POIFSDocumentPath ) o ; if ( path . components . length == this . components . length ) { rval = true ; for ( int j = 0 ; j < this . components . length ; j ++ ) { if ( ! path . components [ j ] . equals ( this . components [ j ] ) ) { rval = false ; break ; } } } } } return rval ; }
public SearchImageRequest ( ) { super ( " ImageSearch " , " 2019 - 03 - 25 " , " SearchImage " , " imagesearch " ) ; setUriPattern ( " / v2 / image / search " ) ; setMethod ( MethodType . POST ) ; }
public RevFlagSet ( ) { active = new ArrayList <> ( ) ; }
public BatchDisassociateUserStackResult batchDisassociateUserStack ( BatchDisassociateUserStackRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDisassociateUserStack ( request ) ; }
public FloatBuffer get ( float [ ] dst ) { return get ( dst , 0 , dst . length ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ ftEnd ] \ n " ) ; buffer . append ( " [ / ftEnd ] \ n " ) ; return buffer . toString ( ) ; }
public InputStreamDataInput ( InputStream is ) { this . is = is ; }
public static char [ ] grow ( char [ ] array ) { return grow ( array , 1 + array . length ) ; }
public void showMessage ( String msg ) { provider . get ( uri , new CredentialItem . InformationalMessage ( msg ) ) ; }
public DeregisterTypeResult deregisterType ( DeregisterTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterType ( request ) ; }
public final void add ( RevFlagSet set ) { flags |= set . mask ; }
public IntList ( final IntList list ) { this ( list . _array . length ) ; System . arraycopy ( list . _array , 0 , _array , 0 , _array . length ) ; _limit = list . _limit ; }
public int convertFromExternSheetIndex ( int externSheetIndex ) { return _iBook . getFirstSheetIndexFromExternSheetIndex ( externSheetIndex ) ; }
public ExternalSheet getExternalSheet ( String firstSheetName , String lastSheetName , int externalWorkbookNumber ) { throw new IllegalStateException ( " XSSF - style ▁ external ▁ references ▁ are ▁ not ▁ supported ▁ for ▁ HSSF " ) ; }
public CellRangeAddress8Bit copy ( ) { return new CellRangeAddress8Bit ( getFirstRow ( ) , getLastRow ( ) , getFirstColumn ( ) , getLastColumn ( ) ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof Document == false ) return false ; Document other = ( Document ) obj ; if ( other . getBytes ( ) == null ^ this . getBytes ( ) == null ) return false ; if ( other . getBytes ( ) != null && other . getBytes ( ) . equals ( this . getBytes ( ) ) == false ) return false ; if ( other . getS3Object ( ) == null ^ this . getS3Object ( ) == null ) return false ; if ( other . getS3Object ( ) != null && other . getS3Object ( ) . equals ( this . getS3Object ( ) ) == false ) return false ; return true ; }
public ListMembersResult listMembers ( ListMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeListMembers ( request ) ; }
public String toString ( ) { final StringBuilder s = new StringBuilder ( ) ; for ( Block q = head ; q != null ; q = q . next ) { for ( int i = q . headIndex ; i < q . tailIndex ; i ++ ) describe ( s , q . commits [ i ] ) ; } return s . toString ( ) ; }
public void delete ( ) { if ( ! deleted ) { deleted = true ; commitsToDelete . add ( this ) ; } }
public final boolean isWritten ( ) { return 1 < getOffset ( ) ; }
public static Cell translateUnicodeValues ( Cell cell ) { String s = cell . getRichStringCellValue ( ) . getString ( ) ; boolean foundUnicode = false ; String lowerCaseStr = s . toLowerCase ( Locale . ROOT ) ; for ( UnicodeMapping entry : unicodeMappings ) { String key = entry . entityName ; if ( lowerCaseStr . contains ( key ) ) { s = s . replaceAll ( key , entry . resolvedValue ) ; foundUnicode = true ; } } if ( foundUnicode ) { cell . setCellValue ( cell . getRow ( ) . getSheet ( ) . getWorkbook ( ) . getCreationHelper ( ) . createRichTextString ( s ) ) ; } return cell ; }
public DeleteCampaignResult deleteCampaign ( DeleteCampaignRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCampaign ( request ) ; }
public String toFormulaString ( ) { return formatReferenceAsString ( ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 ) { TwoDEval reference = convertFirstArg ( arg0 ) ; try { int columnIx = resolveIndexArg ( arg2 , srcRowIndex , srcColumnIndex ) ; int rowIx = resolveIndexArg ( arg1 , srcRowIndex , srcColumnIndex ) ; return getValueFromArea ( reference , rowIx , columnIx ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public URISyntaxException ( String input , String reason ) { super ( reason ) ; if ( input == null || reason == null ) { throw new NullPointerException ( ) ; } this . input = input ; index = - 1 ; }
public int append ( BytesRef bytes ) { if ( lastElement >= offsets . length ) { int oldLen = offsets . length ; offsets = ArrayUtil . grow ( offsets , offsets . length + 1 ) ; bytesUsed . addAndGet ( ( offsets . length - oldLen ) * Integer . BYTES ) ; } pool . append ( bytes ) ; offsets [ lastElement ++ ] = currentOffset ; currentOffset += bytes . length ; return lastElement - 1 ; }
public EscherAggregate ( boolean createDefaultTree ) { if ( createDefaultTree ) { buildBaseTree ( ) ; } }
public NumericDocValuesField ( String name , Long value ) { super ( name , TYPE ) ; fieldsData = value ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_index ) ; }
public AssociateDeviceWithNetworkProfileResult associateDeviceWithNetworkProfile ( AssociateDeviceWithNetworkProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateDeviceWithNetworkProfile ( request ) ; }
public void add ( DirCacheEntry newEntry ) { if ( newEntry . getRawMode ( ) == 0 ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . fileModeNotSetForPath , newEntry . getPathString ( ) ) ) ; beforeAdd ( newEntry ) ; fastAdd ( newEntry ) ; }
public ValueEval getEvalForCell ( int rowIndex , int columnIndex ) { return _bookEvaluator . evaluateReference ( getSheet ( ) , _sheetIndex , rowIndex , columnIndex , _tracker ) ; }
public static RevFilter create ( String pattern ) { if ( pattern . length ( ) == 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . cannotMatchOnEmptyString ) ; if ( SubStringRevFilter . safe ( pattern ) ) return new SubStringSearch ( pattern ) ; return new PatternSearch ( pattern ) ; }
public ObjectId getResultTreeId ( ) { return sourceTrees [ treeIndex ] ; }
public MoPenQueryCanvasRequest ( ) { super ( " MoPen " , " 2018 - 02 - 11 " , " MoPenQueryCanvas " , " mopen " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public DescribeTrialResult describeTrial ( DescribeTrialRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTrial ( request ) ; }
public DeleteCommentResult deleteComment ( DeleteCommentRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteComment ( request ) ; }
public DeleteCacheSecurityGroupRequest ( String cacheSecurityGroupName ) { setCacheSecurityGroupName ( cacheSecurityGroupName ) ; }
public ParseTreePattern ( ParseTreePatternMatcher matcher , String pattern , int patternRuleIndex , ParseTree patternTree ) { this . matcher = matcher ; this . patternRuleIndex = patternRuleIndex ; this . pattern = pattern ; this . patternTree = patternTree ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( PERCENT ) ; return buffer . toString ( ) ; }
public GetVaultLockResult getVaultLock ( GetVaultLockRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVaultLock ( request ) ; }
public DecreaseStreamRetentionPeriodResult decreaseStreamRetentionPeriod ( DecreaseStreamRetentionPeriodRequest request ) { request = beforeClientExecution ( request ) ; return executeDecreaseStreamRetentionPeriod ( request ) ; }
public void append ( String name , RevTree tree ) { append ( name , TREE , tree ) ; }
public String getSessionToken ( ) { return sessionToken ; }
public ListIterator < E > listIterator ( int index ) { Object [ ] snapshot = elements ; if ( index < 0 || index > snapshot . length ) { throw new IndexOutOfBoundsException ( " index = " + index + " , ▁ length = " + snapshot . length ) ; } CowIterator < E > result = new CowIterator < E > ( snapshot , 0 , snapshot . length ) ; result . index = index ; return result ; }
public synchronized Span [ ] getTerms ( String sentence ) { if ( tokenizer == null ) { Span [ ] span1 = new Span [ 1 ] ; span1 [ 0 ] = new Span ( 0 , sentence . length ( ) ) ; return span1 ; } return tokenizer . tokenizePos ( sentence ) ; }
public DeleteRelationalDatabaseSnapshotResult deleteRelationalDatabaseSnapshot ( DeleteRelationalDatabaseSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRelationalDatabaseSnapshot ( request ) ; }
public CheckDomainAvailabilityResult checkDomainAvailability ( CheckDomainAvailabilityRequest request ) { request = beforeClientExecution ( request ) ; return executeCheckDomainAvailability ( request ) ; }
public DeleteVaultRequest ( String vaultName ) { setVaultName ( vaultName ) ; }
public InputStream getInputStream ( ) { return rawIn ; }
public final byte [ ] getBytes ( int sizeLimit ) throws LargeObjectException , MissingObjectException , IOException { byte [ ] cached = getCachedBytes ( sizeLimit ) ; try { return cloneArray ( cached ) ; } catch ( OutOfMemoryError tooBig ) { throw new LargeObjectException . OutOfMemory ( tooBig ) ; } }
public HSSFSimpleShape createSimpleShape ( HSSFClientAnchor anchor ) { HSSFSimpleShape shape = new HSSFSimpleShape ( null , anchor ) ; addShape ( shape ) ; onCreate ( shape ) ; return shape ; }
public synchronized V remove ( Object key ) { int hash = secondaryHash ( key . hashCode ( ) ) ; HashtableEntry < K , V > [ ] tab = table ; int index = hash & ( tab . length - 1 ) ; for ( HashtableEntry < K , V > e = tab [ index ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( e . hash == hash && key . equals ( e . key ) ) { if ( prev == null ) { tab [ index ] = e . next ; } else { prev . next = e . next ; } modCount ++ ; size -- ; return e . value ; } } return null ; }
public final ValueEval getValue ( int sheetIndex , int row , int col ) { return getRelativeValue ( sheetIndex , row , col ) ; }
public SetIdentityNotificationTopicResult setIdentityNotificationTopic ( SetIdentityNotificationTopicRequest request ) { request = beforeClientExecution ( request ) ; return executeSetIdentityNotificationTopic ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . write ( _rawData ) ; }
public BlockJoinWeight ( Query joinQuery , Weight childWeight , BitSetProducer parentsFilter , ScoreMode scoreMode ) { super ( joinQuery , childWeight ) ; this . parentsFilter = parentsFilter ; this . scoreMode = scoreMode ; }
public Builder ( ) { this . field = null ; this . termArrays = new ArrayList <> ( ) ; this . positions = new ArrayList <> ( ) ; this . slop = 0 ; }
public CreateGameSessionQueueResult createGameSessionQueue ( CreateGameSessionQueueRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateGameSessionQueue ( request ) ; }
public DescribeMetricCollectionTypesResult describeMetricCollectionTypes ( ) { return describeMetricCollectionTypes ( new DescribeMetricCollectionTypesRequest ( ) ) ; }
@ Override public boolean contains ( Object o ) { if ( o instanceof Entry ) { Entry <?> entry = ( Entry <?> ) o ; int count = count ( entry . getElement ( ) ) ; return ( count == entry . getCount ( ) ) && ( count > 0 ) ; } return false ; }
public synchronized int get ( FacetLabel categoryPath ) { Integer res = cache . get ( categoryPath ) ; if ( res == null ) { return - 1 ; } return res . intValue ( ) ; }
@ Override public boolean containsKey ( Object key ) { if ( key == null ) { return entryForNullKey != null ; } int hash = key . hashCode ( ) ; hash ^= ( hash >>> 20 ) ^ ( hash >>> 12 ) ; hash ^= ( hash >>> 7 ) ^ ( hash >>> 4 ) ; HashMapEntry < K , V > [ ] tab = table ; for ( HashMapEntry < K , V > e = tab [ hash & ( tab . length - 1 ) ] ; e != null ; e = e . next ) { K eKey = e . key ; if ( eKey == key || ( e . hash == hash && key . equals ( eKey ) ) ) { return true ; } } return false ; }
public boolean equals ( Object obj ) { if ( obj instanceof Point ) { Point that = ( Point ) obj ; return this . x == that . x && this . y == that . y ; } return false ; }
public void message ( String component , String message ) { assert false : " message ( ) ▁ should ▁ not ▁ be ▁ called ▁ when ▁ isEnabled ▁ returns ▁ false " ; }
public ListWorkerBlocksResult listWorkerBlocks ( ListWorkerBlocksRequest request ) { request = beforeClientExecution ( request ) ; return executeListWorkerBlocks ( request ) ; }
public ListProvisionedCapacityResult listProvisionedCapacity ( ListProvisionedCapacityRequest request ) { request = beforeClientExecution ( request ) ; return executeListProvisionedCapacity ( request ) ; }
@ Override public boolean contains ( Object value ) { return containsValue ( value ) ; }
public void exitEveryRule ( ParserRuleContext ctx ) { if ( ctx . children instanceof ArrayList ) { ( ( ArrayList <?> ) ctx . children ) . trimToSize ( ) ; } }
public int lookup ( char [ ] text , int offset , int len ) { if ( ! characterDefinition . isGroup ( text [ offset ] ) ) { return 1 ; } byte characterIdOfFirstCharacter = characterDefinition . getCharacterClass ( text [ offset ] ) ; int length = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( characterIdOfFirstCharacter == characterDefinition . getCharacterClass ( text [ offset + i ] ) ) { length ++ ; } else { break ; } } return length ; }
public GetJobOutputResult getJobOutput ( GetJobOutputRequest request ) { request = beforeClientExecution ( request ) ; return executeGetJobOutput ( request ) ; }
public void write ( char b [ ] , int off , int len ) { reserve ( len ) ; unsafeWrite ( b , off , len ) ; }
public String toString ( ) { return " weight ( " + TermQuery . this + " ) " ; }
public int [ ] grow ( ) { ParallelPostingsArray postingsArray = perField . postingsArray ; final int oldSize = perField . postingsArray . size ; postingsArray = perField . postingsArray = postingsArray . grow ( ) ; perField . newPostingsArray ( ) ; bytesUsed . addAndGet ( ( postingsArray . bytesPerPosting ( ) * ( postingsArray . size - oldSize ) ) ) ; return postingsArray . textStarts ; }
public String toString ( ) { return " ' " + text + " ' " ; }
public boolean isMatch ( ) { if ( heads . isEmpty ( ) ) return false ; final ListIterator < Head > headIterator = heads . listIterator ( heads . size ( ) ) ; while ( headIterator . hasPrevious ( ) ) { final Head head = headIterator . previous ( ) ; if ( head == LastHead . INSTANCE ) { return true ; } } return false ; }
public CRNRecord [ ] getCrns ( ) { return _crns . clone ( ) ; }
public String toString ( ) { return " slot : " + slot + " ▁ " + super . toString ( ) ; }
public int apply ( char s [ ] , int len ) { if ( len < min ) return len ; if ( suffixes != null ) { boolean found = false ; for ( int i = 0 ; i < suffixes . length ; i ++ ) if ( endsWith ( s , len , suffixes [ i ] ) ) { found = true ; break ; } if ( ! found ) return len ; } for ( int i = 0 ; i < rules . length ; i ++ ) { if ( rules [ i ] . matches ( s , len ) ) return rules [ i ] . replace ( s , len ) ; } return len ; }
public ModifyInstanceAttributeRequest ( String instanceId , InstanceAttributeName attribute ) { setInstanceId ( instanceId ) ; setAttribute ( attribute . toString ( ) ) ; }
public ListEventTrackersResult listEventTrackers ( ListEventTrackersRequest request ) { request = beforeClientExecution ( request ) ; return executeListEventTrackers ( request ) ; }
public boolean isNewFragment ( ) { boolean isNewFrag = offsetAtt . endOffset ( ) >= ( fragmentSize * currentNumFrags ) ; if ( isNewFrag ) { currentNumFrags ++ ; } return isNewFrag ; }
public BatchGetQueryExecutionResult batchGetQueryExecution ( BatchGetQueryExecutionRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetQueryExecution ( request ) ; }
public static double cos ( double a ) { if ( a < 0.0 ) { a = - a ; } if ( a > SIN_COS_MAX_VALUE_FOR_INT_MODULO ) { return Math . cos ( a ) ; } int index = ( int ) ( a * SIN_COS_INDEXER + 0.5 ) ; double delta = ( a - index * SIN_COS_DELTA_HI ) - index * SIN_COS_DELTA_LO ; index &= ( SIN_COS_TABS_SIZE - 2 ) ; double indexCos = cosTab [ index ] ; double indexSin = sinTab [ index ] ; return indexCos + delta * ( - indexSin + delta * ( - indexCos * ONE_DIV_F2 + delta * ( indexSin * ONE_DIV_F3 + delta * indexCos * ONE_DIV_F4 ) ) ) ; }
public ByteBuffer putLong ( long value ) { throw new ReadOnlyBufferException ( ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( " ▁ [ " ) ; sb . append ( " sheetIx = " ) . append ( getExternSheetIndex ( ) ) ; sb . append ( " ▁ ! ▁ " ) ; sb . append ( formatReferenceAsString ( ) ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public STSAssumeRoleSessionCredentialsProvider ( AlibabaCloudCredentials longLivedCredentials , String roleArn , IClientProfile clientProfile ) { this ( new StaticCredentialsProvider ( longLivedCredentials ) , roleArn , clientProfile ) ; }
public SessionToken ( String id , Revision revision ) { this . id = id ; this . version = revision . getVersion ( ) ; this . sourceFiles = revision . getSourceFiles ( ) ; }
public Collection < String > call ( ) throws GitAPIException { checkCallable ( ) ; try ( SubmoduleWalk generator = SubmoduleWalk . forIndex ( repo ) ) { if ( ! paths . isEmpty ( ) ) generator . setFilter ( PathFilterGroup . createFromStrings ( paths ) ) ; StoredConfig config = repo . getConfig ( ) ; List < String > initialized = new ArrayList <> ( ) ; while ( generator . next ( ) ) { if ( generator . getConfigUrl ( ) != null ) continue ; String path = generator . getPath ( ) ; String name = generator . getModuleName ( ) ; String url = generator . getRemoteUrl ( ) ; String update = generator . getModulesUpdate ( ) ; if ( url != null ) config . setString ( ConfigConstants . CONFIG_SUBMODULE_SECTION , name , ConfigConstants . CONFIG_KEY_URL , url ) ; if ( update != null ) config . setString ( ConfigConstants . CONFIG_SUBMODULE_SECTION , name , ConfigConstants . CONFIG_KEY_UPDATE , update ) ; if ( url != null || update != null ) initialized . add ( path ) ; } if ( ! initialized . isEmpty ( ) ) config . save ( ) ; return initialized ; } catch ( IOException | ConfigInvalidException e ) { throw new JGitInternalException ( e . getMessage ( ) , e ) ; } }
public CreateVaultRequest ( String accountId , String vaultName ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; }
public BooleanQueryNode ( List < QueryNode > clauses ) { setLeaf ( false ) ; allocate ( ) ; set ( clauses ) ; }
public DVALRecord ( ) { field_cbo_id = 0xFFFFFFFF ; field_5_dv_no = 0x00000000 ; }
public ListConfigurationsResult listConfigurations ( ListConfigurationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListConfigurations ( request ) ; }
public String toFormulaString ( ) { throw new RuntimeException ( " 3D ▁ references ▁ need ▁ a ▁ workbook ▁ to ▁ determine ▁ formula ▁ text " ) ; }
public int LA ( int i ) { return LT ( i ) . getType ( ) ; }
public void setCellValue ( boolean value ) { int row = _record . getRow ( ) ; short col = _record . getColumn ( ) ; short styleIndex = _record . getXFIndex ( ) ; switch ( _cellType ) { default : setCellType ( CellType . BOOLEAN , false , row , col , styleIndex ) ; case BOOLEAN : ( ( BoolErrRecord ) _record ) . setValue ( value ) ; break ; case FORMULA : ( ( FormulaRecordAggregate ) _record ) . setCachedBooleanResult ( value ) ; break ; } }
public UntagDeliveryStreamResult untagDeliveryStream ( UntagDeliveryStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeUntagDeliveryStream ( request ) ; }
public CJKBigramFilterFactory ( Map < String , String > args ) { super ( args ) ; int flags = 0 ; if ( getBoolean ( args , " han " , true ) ) { flags |= CJKBigramFilter . HAN ; } if ( getBoolean ( args , " hiragana " , true ) ) { flags |= CJKBigramFilter . HIRAGANA ; } if ( getBoolean ( args , " katakana " , true ) ) { flags |= CJKBigramFilter . KATAKANA ; } if ( getBoolean ( args , " hangul " , true ) ) { flags |= CJKBigramFilter . HANGUL ; } this . flags = flags ; this . outputUnigrams = getBoolean ( args , " outputUnigrams " , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static int toChars ( int [ ] src , int srcOff , int srcLen , char [ ] dest , int destOff ) { if ( srcLen < 0 ) { throw new IllegalArgumentException ( " srcLen ▁ must ▁ be ▁ >= ▁ 0 " ) ; } int written = 0 ; for ( int i = 0 ; i < srcLen ; ++ i ) { written += Character . toChars ( src [ srcOff + i ] , dest , destOff + written ) ; } return written ; }
public StoredField ( String name , long value ) { super ( name , TYPE ) ; fieldsData = value ; }
public static CFRuleRecord create ( HSSFSheet sheet , byte comparisonOperation , String formulaText1 , String formulaText2 ) { Ptg [ ] formula1 = parseFormula ( formulaText1 , sheet ) ; Ptg [ ] formula2 = parseFormula ( formulaText2 , sheet ) ; return new CFRuleRecord ( CONDITION_TYPE_CELL_VALUE_IS , comparisonOperation , formula1 , formula2 ) ; }
public int newSlice ( final int size ) { if ( byteUpto > BYTE_BLOCK_SIZE - size ) nextBuffer ( ) ; final int upto = byteUpto ; byteUpto += size ; buffer [ byteUpto - 1 ] = 16 ; return upto ; }
public DescribeWorkspaceDirectoriesResult describeWorkspaceDirectories ( ) { return describeWorkspaceDirectories ( new DescribeWorkspaceDirectoriesRequest ( ) ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + _functionName + " ] " ; }
public void writeBytes ( int stream , byte [ ] b , int offset , int len ) { final int end = offset + len ; for ( int i = offset ; i < end ; i ++ ) writeByte ( stream , b [ i ] ) ; }
public GetExportSnapshotRecordsResult getExportSnapshotRecords ( GetExportSnapshotRecordsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetExportSnapshotRecords ( request ) ; }
public DeleteMessageResult deleteMessage ( String queueUrl , String receiptHandle ) { return deleteMessage ( new DeleteMessageRequest ( ) . withQueueUrl ( queueUrl ) . withReceiptHandle ( receiptHandle ) ) ; }
public ModifyInstanceAttributeResult modifyInstanceAttribute ( ModifyInstanceAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyInstanceAttribute ( request ) ; }
public static float [ ] copyOfRange ( float [ ] original , int start , int end ) { if ( start > end ) { throw new IllegalArgumentException ( ) ; } int originalLength = original . length ; if ( start < 0 || start > originalLength ) { throw new ArrayIndexOutOfBoundsException ( ) ; } int resultLength = end - start ; int copyLength = Math . min ( resultLength , originalLength - start ) ; float [ ] result = new float [ resultLength ] ; System . arraycopy ( original , start , result , 0 , copyLength ) ; return result ; }
public TokenFilter create ( TokenStream input ) { SnowballStemmer program ; try { program = stemClass . getConstructor ( ) . newInstance ( ) ; } catch ( Exception e ) { } }
public GetPhotosByMd5sRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetPhotosByMd5s " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public StartOutboundVoiceContactResult startOutboundVoiceContact ( StartOutboundVoiceContactRequest request ) { request = beforeClientExecution ( request ) ; return executeStartOutboundVoiceContact ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( field_1_x ) ; out . writeInt ( field_2_y ) ; out . writeInt ( field_3_width ) ; out . writeInt ( field_4_height ) ; }
public String getEmailAddress ( ) { return emailAddress ; }
public ValueEval getRelativeValue ( int sheetIndex , int relativeRowIndex , int relativeColumnIndex ) { int rowIx = ( relativeRowIndex + getFirstRow ( ) ) ; int colIx = ( relativeColumnIndex + getFirstColumn ( ) ) ; return _evaluator . getEvalForCell ( sheetIndex , rowIx , colIx ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ' [ ' ) ; for ( byte [ ] b : table ) { if ( b == null ) continue ; if ( sb . length ( ) > 1 ) sb . append ( " ▁ , ▁ " ) ; sb . append ( ' " ' ) ; sb . append ( RawParseUtils . decode ( b ) ) ; sb . append ( ' " ' ) ; sb . append ( ' ( ' ) ; sb . append ( chainlength ( b ) ) ; sb . append ( ' ) ' ) ; } sb . append ( ' ] ' ) ; return sb . toString ( ) ; }
public void stopNow ( ) { super . stopNow ( ) ; if ( runningParallelTasks != null ) { for ( ParallelTask t : runningParallelTasks ) { if ( t != null ) { t . task . stopNow ( ) ; } } } }
public UpdateLogPatternResult updateLogPattern ( UpdateLogPatternRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateLogPattern ( request ) ; }
public FileMode getMode ( ) { return mode ; }
public ValueEval getEvalForCell ( int sheetIndex , int rowIndex , int columnIndex ) { return getSheetEvaluator ( sheetIndex ) . getEvalForCell ( rowIndex , columnIndex ) ; }
public String toString ( ) { final StringBuilder buffer = new StringBuilder ( ) ; for ( Class <?> clazz = getClass ( ) ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { if ( ! clazz . isAnonymousClass ( ) ) { buffer . append ( clazz . getSimpleName ( ) ) ; break ; } } buffer . append ( ' ( ' ) ; final List <? extends IndexReader > subReaders = getSequentialSubReaders ( ) ; assert subReaders != null ; if ( ! subReaders . isEmpty ( ) ) { buffer . append ( subReaders . get ( 0 ) ) ; for ( int i = 1 , c = subReaders . size ( ) ; i < c ; ++ i ) { buffer . append ( " ▁ " ) . append ( subReaders . get ( i ) ) ; } } buffer . append ( ' ) ' ) ; return buffer . toString ( ) ; }
public CreateTypedLinkFacetResult createTypedLinkFacet ( CreateTypedLinkFacetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTypedLinkFacet ( request ) ; }
public PutResolverRulePolicyResult putResolverRulePolicy ( PutResolverRulePolicyRequest request ) { request = beforeClientExecution ( request ) ; return executePutResolverRulePolicy ( request ) ; }
public ConfirmPublicVirtualInterfaceResult confirmPublicVirtualInterface ( ConfirmPublicVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeConfirmPublicVirtualInterface ( request ) ; }
public FieldInfo add ( FieldInfo fi ) { return add ( fi , - 1 ) ; }
public AssociateFleetResult associateFleet ( AssociateFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateFleet ( request ) ; }
public void close ( ) { ctx . close ( ) ; }
public InclusiveRange ( long start , long end ) { assert end >= start ; this . start = start ; this . end = end ; }
public UpdateProfilingGroupResult updateProfilingGroup ( UpdateProfilingGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateProfilingGroup ( request ) ; }
public void seekExact ( long ord ) throws IOException { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) + " ▁ does ▁ not ▁ support ▁ seeking " ) ; }
public DetectStackSetDriftResult detectStackSetDrift ( DetectStackSetDriftRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectStackSetDrift ( request ) ; }
public ListConfigurationProfilesResult listConfigurationProfiles ( ListConfigurationProfilesRequest request ) { request = beforeClientExecution ( request ) ; return executeListConfigurationProfiles ( request ) ; }
public int getFormat ( ) { return FORMAT_OTHER ; }
public K lastKey ( ) { Entry < K , V > entry = endpoint ( false ) ; if ( entry == null ) { throw new NoSuchElementException ( ) ; } return entry . getKey ( ) ; }
public final void writeChars ( String str ) throws IOException { write ( str . getBytes ( " UTF - 16BE " ) ) ; }
public UpdateFleetPortSettingsResult updateFleetPortSettings ( UpdateFleetPortSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFleetPortSettings ( request ) ; }
public RuleTransition ( RuleStartState ruleStart , int ruleIndex , int precedence , ATNState followState ) { super ( ruleStart ) ; this . ruleIndex = ruleIndex ; this . precedence = precedence ; this . followState = followState ; }
public GetConferenceProviderResult getConferenceProvider ( GetConferenceProviderRequest request ) { request = beforeClientExecution ( request ) ; return executeGetConferenceProvider ( request ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = readLong ( blocks , blocksOffset ) ; blocksOffset += 8 ; valuesOffset = decode ( block , values , valuesOffset ) ; } }
public void serialize ( LittleEndianOutput out ) { out . write ( _data ) ; }
public void upgrade ( ) throws IOException { if ( ! DirectoryReader . indexExists ( dir ) ) { throw new IndexNotFoundException ( dir . toString ( ) ) ; } if ( ! deletePriorCommits ) { final Collection < IndexCommit > commits = DirectoryReader . listCommits ( dir ) ; if ( commits . size ( ) > 1 ) { throw new IllegalArgumentException ( " This ▁ tool ▁ was ▁ invoked ▁ to ▁ not ▁ delete ▁ prior ▁ commit ▁ points , ▁ but ▁ the ▁ following ▁ commits ▁ were ▁ found : ▁ " + commits ) ; } } iwc . setMergePolicy ( new UpgradeIndexMergePolicy ( iwc . getMergePolicy ( ) ) ) ; iwc . setIndexDeletionPolicy ( new KeepOnlyLastCommitDeletionPolicy ( ) ) ; try ( final IndexWriter w = new IndexWriter ( dir , iwc ) ) { InfoStream infoStream = iwc . getInfoStream ( ) ; if ( infoStream . isEnabled ( LOG_PREFIX ) ) { infoStream . message ( LOG_PREFIX , " Upgrading ▁ all ▁ pre - " + Version . LATEST + " ▁ segments ▁ of ▁ index ▁ directory ▁ ' " ▁ + ▁ dir ▁ + ▁ " ' ▁ to ▁ version ▁ " + Version . LATEST + " ... " ) ; } w . forceMerge ( 1 ) ; if ( infoStream . isEnabled ( LOG_PREFIX ) ) { infoStream . message ( LOG_PREFIX , " All ▁ segments ▁ upgraded ▁ to ▁ version ▁ " + Version . LATEST ) ; infoStream . message ( LOG_PREFIX , " Enforcing ▁ commit ▁ to ▁ rewrite ▁ all ▁ index ▁ metadata ... " ) ; } w . setLiveCommitData ( w . getLiveCommitData ( ) ) ; assert w . hasUncommittedChanges ( ) ; w . commit ( ) ; if ( infoStream . isEnabled ( LOG_PREFIX ) ) { infoStream . message ( LOG_PREFIX , " Committed ▁ upgraded ▁ metadata ▁ to ▁ index . " ) ; } } }
public byte [ ] getThumbnailAsWMF ( ) throws HPSFException { if ( ! ( getClipboardFormatTag ( ) == CFTAG_WINDOWS ) ) throw new HPSFException ( " Clipboard ▁ Format ▁ Tag ▁ of ▁ Thumbnail ▁ must ▁ " + " be ▁ CFTAG □ WINDOWS . " ) ; if ( ! ( getClipboardFormat ( ) == CF_METAFILEPICT ) ) { throw new HPSFException ( " Clipboard ▁ Format ▁ of ▁ Thumbnail ▁ must ▁ " + " be ▁ CF □ METAFILEPICT . " ) ; } byte [ ] thumbnail = getThumbnail ( ) ; int wmfImageLength = thumbnail . length - OFFSET_WMFDATA ; byte [ ] wmfImage = new byte [ wmfImageLength ] ; System . arraycopy ( thumbnail , OFFSET_WMFDATA , wmfImage , 0 , wmfImageLength ) ; return wmfImage ; }
public DescribeKeyPhrasesDetectionJobResult describeKeyPhrasesDetectionJob ( DescribeKeyPhrasesDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeKeyPhrasesDetectionJob ( request ) ; }
public LabelAndValue ( String label , Number value ) { this . label = label ; this . value = value ; }
public RebaseCommand setUpstreamName ( String upstreamName ) { if ( upstreamCommit == null ) { throw new IllegalStateException ( " setUpstreamName ▁ must ▁ be ▁ called ▁ after ▁ setUpstream . " ) ; } this . upstreamCommitName = upstreamName ; return this ; }
public SearchDashboardsResult searchDashboards ( SearchDashboardsRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchDashboards ( request ) ; }
public ClusterSubnetGroup createClusterSubnetGroup ( CreateClusterSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateClusterSubnetGroup ( request ) ; }
public static int endOfFooterLineKey ( byte [ ] raw , int ptr ) { try { for ( ; ; ) { final byte c = raw [ ptr ] ; if ( footerLineKeyChars [ c ] == 0 ) { if ( c == ' : ' ) return ptr ; return - 1 ; } ptr ++ ; } } catch ( ArrayIndexOutOfBoundsException e ) { return - 1 ; } }
public final char [ ] GetSuffix ( int len ) { char [ ] value = new char [ len ] ; System . arraycopy ( buffer , bufferPosition - len , value , 0 , len ) ; return value ; }
public boolean containsValue ( Object value ) { if ( value instanceof CustomProperty ) { return props . containsValue ( value ) ; } for ( CustomProperty cp : props . values ( ) ) { if ( cp . getValue ( ) == value ) { return true ; } } return false ; }
public RecordInputStream createDecryptingStream ( InputStream original ) { String userPassword = Biff8EncryptionKey . getCurrentUserPassword ( ) ; if ( userPassword == null ) { userPassword = Decryptor . DEFAULT_PASSWORD ; } EncryptionInfo info = _filePassRec . getEncryptionInfo ( ) ; try { if ( ! info . getDecryptor ( ) . verifyPassword ( userPassword ) ) { throw new EncryptedDocumentException ( ( Decryptor . DEFAULT_PASSWORD . equals ( userPassword ) ? " Default " : " Supplied " ) + " ▁ password ▁ is ▁ invalid ▁ for ▁ salt / verifier / verifierHash " ) ; } } catch ( GeneralSecurityException e ) { throw new EncryptedDocumentException ( e ) ; } return new RecordInputStream ( original , info , _initialRecordsSize ) ; }
public UpdateComponentConfigurationResult updateComponentConfiguration ( UpdateComponentConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateComponentConfiguration ( request ) ; }
public String toString ( ) { CellReference crA = new CellReference ( getFirstRow ( ) , getFirstColumn ( ) ) ; CellReference crB = new CellReference ( getLastRow ( ) , getLastColumn ( ) ) ; return getClass ( ) . getName ( ) + " [ " + _evaluator . getSheetNameRange ( ) + ' ! ' + crA . formatAsString ( ) + ' : ' + crB . formatAsString ( ) + " ] " ; }
public SetDesiredCapacityResult setDesiredCapacity ( SetDesiredCapacityRequest request ) { request = beforeClientExecution ( request ) ; return executeSetDesiredCapacity ( request ) ; }
public long getTotalLLATNLookaheadOps ( ) { DecisionInfo [ ] decisions = atnSimulator . getDecisionInfo ( ) ; long k = 0 ; for ( int i = 0 ; i < decisions . length ; i ++ ) { k += decisions [ i ] . LL_ATNTransitions ; } return k ; }
public ListQueuesResult listQueues ( ListQueuesRequest request ) { request = beforeClientExecution ( request ) ; return executeListQueues ( request ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 12 ) | ( byte1 << 4 ) | ( byte2 >>> 4 ) ; final long byte3 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte4 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte2 & 15 ) << 16 ) | ( byte3 << 8 ) | byte4 ; } }
public EnableVolumeIOResult enableVolumeIO ( EnableVolumeIORequest request ) { request = beforeClientExecution ( request ) ; return executeEnableVolumeIO ( request ) ; }
public long seek ( BytesRef target ) throws IOException { current = fstEnum . seekFloor ( target ) ; return current . output ; }
public GetStreamingDistributionConfigRequest ( String id ) { setId ( id ) ; }
public WordnetSynonymParser ( boolean dedup , boolean expand , Analyzer analyzer ) { super ( dedup , analyzer ) ; this . expand = expand ; }
public DescribeProblemResult describeProblem ( DescribeProblemRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeProblem ( request ) ; }
public E floor ( E e ) { return backingMap . floorKey ( e ) ; }
public IrishLowerCaseFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public EnableAvailabilityZonesForLoadBalancerRequest ( String loadBalancerName , java . util . List < String > availabilityZones ) { setLoadBalancerName ( loadBalancerName ) ; setAvailabilityZones ( availabilityZones ) ; }
public DescribeLoadBalancerTargetGroupsResult describeLoadBalancerTargetGroups ( DescribeLoadBalancerTargetGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLoadBalancerTargetGroups ( request ) ; }
public Snapshot copySnapshot ( CopySnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCopySnapshot ( request ) ; }
public Map < String , String > readForHideArrayItem ( String response , String endpoint ) { return readForHideItem ( new StringCharacterIterator ( response ) , endpoint , FIRST_POSITION ) ; }
public LbsDropData ( LittleEndianInput in ) { _wStyle = in . readUShort ( ) ; _cLine = in . readUShort ( ) ; _dxMin = in . readUShort ( ) ; _str = StringUtil . readUnicodeString ( in ) ; if ( StringUtil . getEncodedSize ( _str ) % 2 != 0 ) { _unused = in . readByte ( ) ; } }
public void decode ( long [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; for ( int shift = 60 ; shift >= 0 ; shift -= 4 ) { values [ valuesOffset ++ ] = ( block >>> shift ) & 15 ; } } }
public int doLogic ( ) throws Exception { final String docID = doc . get ( DocMaker . ID_FIELD ) ; if ( docID == null ) { throw new IllegalStateException ( " document ▁ must ▁ define ▁ the ▁ docid ▁ field " ) ; } final IndexWriter iw = getRunData ( ) . getIndexWriter ( ) ; iw . updateDocument ( new Term ( DocMaker . ID_FIELD , docID ) , doc ) ; return 1 ; }
public ListInstanceFleetsResult listInstanceFleets ( ListInstanceFleetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListInstanceFleets ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { return func . evaluate ( srcRowIndex , srcColumnIndex , arg0 , arg1 ) ; }
public DescribeDBParametersResult describeDBParameters ( DescribeDBParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBParameters ( request ) ; }
public CreateFargateProfileResult createFargateProfile ( CreateFargateProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFargateProfile ( request ) ; }
public char previous ( ) { if ( offset == start ) { return DONE ; } return string . charAt ( -- offset ) ; }
public List < String > call ( ) throws GitAPIException { checkCallable ( ) ; List < String > result = new ArrayList <> ( ) ; if ( tags . isEmpty ( ) ) return result ; try { setCallable ( false ) ; for ( String tagName : tags ) { if ( tagName == null ) continue ; Ref currentRef = repo . findRef ( tagName ) ; if ( currentRef == null ) continue ; String fullName = currentRef . getName ( ) ; RefUpdate update = repo . updateRef ( fullName ) ; update . setForceUpdate ( true ) ; Result deleteResult = update . delete ( ) ; boolean ok = true ; switch ( deleteResult ) { case IO_FAILURE : case LOCK_FAILURE : case REJECTED : ok = false ; break ; default : break ; } if ( ok ) { result . add ( fullName ) ; } else throw new JGitInternalException ( MessageFormat . format ( JGitText . get ( ) . deleteTagUnexpectedResult , deleteResult . name ( ) ) ) ; } return result ; } catch ( IOException ioe ) { throw new JGitInternalException ( ioe . getMessage ( ) , ioe ) ; } }
public static void fill ( byte [ ] array , byte value ) { for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = value ; } }
public CreateSampleFindingsResult createSampleFindings ( CreateSampleFindingsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSampleFindings ( request ) ; }
public Builder ( ) { slop = 0 ; terms = new ArrayList <> ( ) ; positions = new ArrayList <> ( ) ; }
public boolean run ( char [ ] s , int offset , int length ) { int p = 0 ; int l = offset + length ; for ( int i = offset , cp = 0 ; i < l ; i += Character . charCount ( cp ) ) { p = step ( p , cp = Character . codePointAt ( s , i , l ) ) ; if ( p == - 1 ) return false ; } return accept . get ( p ) ; }
public String toFormulaString ( ) { return " ERR # " ; }
public void close ( ) { synchronized ( lock ) { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { setError ( ) ; } out = null ; } } }
public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; short propertiesCount = readInstance ( data , offset ) ; int pos = offset + 8 ; EscherPropertyFactory f = new EscherPropertyFactory ( ) ; properties . clear ( ) ; properties . addAll ( f . createProperties ( data , pos , propertiesCount ) ) ; return bytesRemaining + 8 ; }
public EveryNOrDocFreqTermSelector ( int docFreqThresh , int interval ) { this . interval = interval ; this . docFreqThresh = docFreqThresh ; count = interval ; }
public UpdateAvailabilityOptionsResult updateAvailabilityOptions ( UpdateAvailabilityOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateAvailabilityOptions ( request ) ; }
public AddInstanceFleetResult addInstanceFleet ( AddInstanceFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeAddInstanceFleet ( request ) ; }
public synchronized void setMax ( int max ) { super . setMax ( max ) ; if ( ( mKeyProgressIncrement == 0 ) || ( getMax ( ) / mKeyProgressIncrement > 20 ) ) { setKeyProgressIncrement ( Math . max ( 1 , Math . round ( ( float ) getMax ( ) / 20 ) ) ) ; } }
public LazyAreaEval getRow ( int rowIndex ) { if ( rowIndex >= getHeight ( ) ) { throw new IllegalArgumentException ( " Invalid ▁ rowIndex ▁ " + rowIndex + " . ▁ ▁ Allowable ▁ range ▁ is ▁ ( 0.. " + getHeight ( ) + " ) . " ) ; } int absRowIx = getFirstRow ( ) + rowIndex ; return new LazyAreaEval ( absRowIx , getFirstColumn ( ) , absRowIx , getLastColumn ( ) , _evaluator ) ; }
public IntervalSet getExpectedTokens ( int stateNumber , RuleContext context ) { if ( stateNumber < 0 || stateNumber >= states . size ( ) ) { throw new IllegalArgumentException ( " Invalid ▁ state ▁ number . " ) ; } RuleContext ctx = context ; ATNState s = states . get ( stateNumber ) ; IntervalSet following = nextTokens ( s ) ; if ( ! following . contains ( Token . EPSILON ) ) { return following ; } IntervalSet expected = new IntervalSet ( ) ; expected . addAll ( following ) ; expected . remove ( Token . EPSILON ) ; while ( ctx != null && ctx . invokingState >= 0 && following . contains ( Token . EPSILON ) ) { ATNState invokingState = states . get ( ctx . invokingState ) ; RuleTransition rt = ( RuleTransition ) invokingState . transition ( 0 ) ; following = nextTokens ( rt . followState ) ; expected . addAll ( following ) ; expected . remove ( Token . EPSILON ) ; ctx = ctx . parent ; } if ( following . contains ( Token . EPSILON ) ) { expected . add ( Token . EOF ) ; } return expected ; }
public UntagResourceResult untagResource ( UntagResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeUntagResource ( request ) ; }
public String getInflectionForm ( int wordId ) { return null ; }
public Ref3DPxg ( int externalWorkbookNumber , SheetIdentifier sheetName , CellReference c ) { super ( c ) ; this . externalWorkbookNumber = externalWorkbookNumber ; this . firstSheetName = sheetName . getSheetIdentifier ( ) . getName ( ) ; if ( sheetName instanceof SheetRangeIdentifier ) { this . lastSheetName = ( ( SheetRangeIdentifier ) sheetName ) . getLastSheetIdentifier ( ) . getName ( ) ; } else { this . lastSheetName = null ; } }
public ModifyJumpserverPasswordRequest ( ) { super ( " HPC " , " 2016 - 06 - 03 " , " ModifyJumpserverPassword " , " hpc " ) ; setMethod ( MethodType . POST ) ; }
public SearchLocalGatewayRoutesResult searchLocalGatewayRoutes ( SearchLocalGatewayRoutesRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchLocalGatewayRoutes ( request ) ; }
public void write ( byte [ ] buffer ) throws IOException { write ( buffer , 0 , buffer . length ) ; }
public ExtendedPivotTableViewFieldsRecord ( RecordInputStream in ) { _grbit1 = in . readInt ( ) ; _grbit2 = in . readUByte ( ) ; _citmShow = in . readUByte ( ) ; _isxdiSort = in . readUShort ( ) ; _isxdiShow = in . readUShort ( ) ; switch ( in . remaining ( ) ) { case 0 : _reserved1 = 0 ; _reserved2 = 0 ; _subtotalName = null ; return ; case 10 : break ; default : throw new RecordFormatException ( " Unexpected ▁ remaining ▁ size ▁ ( " + in . remaining ( ) + " ) " ) ; } int cchSubName = in . readUShort ( ) ; _reserved1 = in . readInt ( ) ; _reserved2 = in . readInt ( ) ; if ( cchSubName != STRING_NOT_PRESENT_LEN ) { _subtotalName = in . readUnicodeLEString ( cchSubName ) ; } }
public static double cosh ( double d ) { double ePowX = Math . pow ( Math . E , d ) ; double ePowNegX = Math . pow ( Math . E , - d ) ; return ( ePowX + ePowNegX ) / 2 ; }
public List < String > getDFAStrings ( ) { synchronized ( _interp . decisionToDFA ) { List < String > s = new ArrayList < String > ( ) ; for ( int d = 0 ; d < _interp . decisionToDFA . length ; d ++ ) { DFA dfa = _interp . decisionToDFA [ d ] ; s . add ( dfa . toString ( getVocabulary ( ) ) ) ; } return s ; } }
public LexerChannelAction ( int channel ) { this . channel = channel ; }
public MappingCharFilter ( NormalizeCharMap normMap , Reader in ) { super ( in ) ; buffer . reset ( in ) ; map = normMap . map ; cachedRootArcs = normMap . cachedRootArcs ; if ( map != null ) { fstReader = map . getBytesReader ( ) ; } else { fstReader = null ; } }
public String toString ( ) { String newline = System . getProperty ( " line . separator " ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( sequence . toString ( ) ) ; sb . append ( newline ) ; return sb . toString ( ) ; }
public void visitContainedRecords ( RecordVisitor rv ) { for ( CFRecordsAggregate subAgg : _cfHeaders ) { subAgg . visitContainedRecords ( rv ) ; } }
public static boolean equals ( short [ ] array1 , short [ ] array2 ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1. length != array2. length ) { return false ; } for ( int i = 0 ; i < array1. length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) { return false ; } } return true ; }
public String getString ( ) { return getString ( field_2_bytes , codepage ) ; }
public SimpleDate ( Calendar cal ) { year = cal . get ( Calendar . YEAR ) ; month = cal . get ( Calendar . MONTH ) + 1 ; day = cal . get ( Calendar . DAY_OF_MONTH ) ; tsMilliseconds = cal . getTimeInMillis ( ) ; }
public TreeFilter clone ( ) { throw new IllegalStateException ( " Do ▁ not ▁ clone ▁ this ▁ kind ▁ of ▁ filter : ▁ " + getClass ( ) . getName ( ) ) ; }
public String getText ( Interval interval ) { int start = interval . a ; int stop = interval . b ; if ( start < 0 || stop < 0 ) return " " ; fill ( ) ; if ( stop >= tokens . size ( ) ) stop = tokens . size ( ) - 1 ; StringBuilder buf = new StringBuilder ( ) ; for ( int i = start ; i <= stop ; i ++ ) { Token t = tokens . get ( i ) ; if ( t . getType ( ) == Token . EOF ) break ; buf . append ( t . getText ( ) ) ; } return buf . toString ( ) ; }
public CancelStepsResult cancelSteps ( CancelStepsRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelSteps ( request ) ; }
public long ramBytesUsed ( ) { return 0 ; }
public boolean contains ( Object o ) { return containsValue ( o ) ; }
public synchronized int codePointBefore ( int index ) { return super . codePointBefore ( index ) ; }
public DeleteApplicationRequest ( String applicationName ) { setApplicationName ( applicationName ) ; }
public LazyDocument ( IndexReader reader , int docID ) { this . reader = reader ; this . docID = docID ; }
public static int trimLeadingWhitespace ( byte [ ] raw , int start , int end ) { while ( start < end && isWhitespace ( raw [ start ] ) ) start ++ ; return start ; }
public int [ ] getMap ( ) { return map ; }
public void set ( E object ) { iterator . set ( object ) ; }
public ModifyCurrentDBClusterCapacityResult modifyCurrentDBClusterCapacity ( ModifyCurrentDBClusterCapacityRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyCurrentDBClusterCapacity ( request ) ; }
public CancelRepoBuildRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " CancelRepoBuild " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / build / [ BuildId ] / cancel " ) ; setMethod ( MethodType . POST ) ; }
public LongBuffer get ( long [ ] dst , int dstOffset , int longCount ) { Arrays . checkOffsetAndCount ( dst . length , dstOffset , longCount ) ; if ( longCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } for ( int i = dstOffset ; i < dstOffset + longCount ; ++ i ) { dst [ i ] = get ( ) ; } return this ; }
public SpreadsheetVersion getSpreadsheetVersion ( ) { return SpreadsheetVersion . EXCEL97 ; }
public boolean equals ( Object obj ) { if ( obj instanceof Point ) { Point rhs = ( Point ) obj ; return this . x == rhs . x && this . y == rhs . y ; } return false ; }
public int numNodes ( ) { return numNodes ( rootNode ) ; }
public String toString ( ) { return super . toString ( ) + flags ; }
public EnglishPossessiveFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static double atanh ( double d ) { return Math . log ( ( 1 + d ) / ( 1 - d ) ) / 2 ; }
public WindowsIndexInput clone ( ) { WindowsIndexInput clone = ( WindowsIndexInput ) super . clone ( ) ; clone . isClone = true ; return clone ; }
public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( initialise ( currentTokenVal , expectedTokenSequencesVal , tokenImageVal ) ) ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; }
public long getTotalATNLookaheadOps ( ) { DecisionInfo [ ] decisions = atnSimulator . getDecisionInfo ( ) ; long k = 0 ; for ( int i = 0 ; i < decisions . length ; i ++ ) { k += decisions [ i ] . SLL_ATNTransitions ; k += decisions [ i ] . LL_ATNTransitions ; } return k ; }
public synchronized StringBuffer reverse ( ) { reverse0 ( ) ; return this ; }
public DescribeLoadBalancersRequest ( java . util . List < String > loadBalancerNames ) { setLoadBalancerNames ( loadBalancerNames ) ; }
public String toString ( ) { return ' ~ ' + super . toString ( ) ; }
public static ISignatureComposer getComposer ( ) { if ( null == composer ) { composer = new RoaSignatureComposer ( ) ; } return composer ; }
public boolean ready ( ) throws IOException { synchronized ( lock ) { if ( buf == null ) { throw new IOException ( " Reader ▁ is ▁ closed " ) ; } return ( buf . length - pos > 0 || in . ready ( ) ) ; } }
public GetClientCertificatesResult getClientCertificates ( GetClientCertificatesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetClientCertificates ( request ) ; }
public static final int tagger ( byte [ ] b , int ptr ) { final int sz = b . length ; if ( ptr == 0 ) ptr += 48 ; while ( ptr < sz ) { if ( b [ ptr ] == ' \ n ' ) return - 1 ; final int m = match ( b , ptr , tagger ) ; if ( m >= 0 ) return m ; ptr = nextLF ( b , ptr ) ; } return - 1 ; }
public GetInstanceStateResult getInstanceState ( GetInstanceStateRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInstanceState ( request ) ; }
public boolean isEmpty ( ) { synchronized ( mutex ) { return delegate ( ) . isEmpty ( ) ; } }
public long getCount ( ) { return cnt ; }
public DeleteConfigurationSetEventDestinationResult deleteConfigurationSetEventDestination ( DeleteConfigurationSetEventDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteConfigurationSetEventDestination ( request ) ; }
public DeleteNetworkInterfacePermissionResult deleteNetworkInterfacePermission ( DeleteNetworkInterfacePermissionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNetworkInterfacePermission ( request ) ; }
public Tag ( String key , String value ) { this . key = key ; this . value = value ; }
public CreateTrafficMirrorTargetResult createTrafficMirrorTarget ( CreateTrafficMirrorTargetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTrafficMirrorTarget ( request ) ; }
public GetGroupPolicyRequest ( String groupName , String policyName ) { setGroupName ( groupName ) ; setPolicyName ( policyName ) ; }
public DeleteVoiceChannelResult deleteVoiceChannel ( DeleteVoiceChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVoiceChannel ( request ) ; }
public DBClusterSnapshotAttributesResult modifyDBClusterSnapshotAttribute ( ModifyDBClusterSnapshotAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBClusterSnapshotAttribute ( request ) ; }
public RegisterAVSDeviceResult registerAVSDevice ( RegisterAVSDeviceRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterAVSDevice ( request ) ; }
public void setValue ( char [ ] newValue ) { clear ( ) ; if ( newValue != null ) { value = new char [ newValue . length ] ; System . arraycopy ( newValue , 0 , value , 0 , newValue . length ) ; } }
public int compareSameType ( Object other ) { assert exists || 0.0D == value ; MutableValueDouble b = ( MutableValueDouble ) other ; int c = Double . compare ( value , b . value ) ; if ( c != 0 ) return c ; if ( exists == b . exists ) return 0 ; return exists ? 1 : - 1 ; }
public UpdateCodeRepositoryResult updateCodeRepository ( UpdateCodeRepositoryRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateCodeRepository ( request ) ; }
public static FormulaError forString ( String code ) throws IllegalArgumentException { FormulaError err = smap . get ( code ) ; if ( err == null ) throw new IllegalArgumentException ( " Unknown ▁ error ▁ code : ▁ " + code ) ; return err ; }
public UnmonitorInstancesResult unmonitorInstances ( UnmonitorInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeUnmonitorInstances ( request ) ; }
public boolean isInteractive ( ) { return false ; }
public void setColor ( short byteIndex , byte red , byte green , byte blue ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= STANDARD_PALETTE_SIZE ) { return ; } while ( _colors . size ( ) <= i ) { _colors . add ( new PColor ( 0 , 0 , 0 ) ) ; } PColor custColor = new PColor ( red , green , blue ) ; _colors . set ( i , custColor ) ; }
public boolean isUser ( ) { return type == Type . USER ; }
public DeleteMeetingResult deleteMeeting ( DeleteMeetingRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMeeting ( request ) ; }
public void serializeTokens ( LittleEndianOutput out ) { out . write ( _byteEncoding , 0 , _encodedTokenLen ) ; }
final public QueryNode Query ( CharSequence field ) throws ParseException { Vector < QueryNode > clauses = null ; QueryNode c , first = null ; first = DisjQuery ( field ) ; label_1 : while ( true ) { switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case NOT : case PLUS : case MINUS : case LPAREN : case QUOTED : case TERM : case REGEXPTERM : case RANGEIN_START : case RANGEEX_START : case NUMBER : ; break ; default : jj_la1 [ 2 ] = jj_gen ; break label_1 ; } c = DisjQuery ( field ) ; if ( clauses == null ) { clauses = new Vector < QueryNode > ( ) ; clauses . addElement ( first ) ; } clauses . addElement ( c ) ; } if ( clauses != null ) { { if ( true ) return new BooleanQueryNode ( clauses ) ; } } else { if ( first instanceof ModifierQueryNode ) { ModifierQueryNode m = ( ModifierQueryNode ) first ; if ( m . getModifier ( ) == ModifierQueryNode . Modifier . MOD_NOT ) { { if ( true ) return new BooleanQueryNode ( Arrays . < QueryNode > asList ( m ) ) ; } } } { if ( true ) return first ; } } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public DBInstance rebootDBInstance ( RebootDBInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeRebootDBInstance ( request ) ; }
public SortedSet < E > tailSet ( E start ) { return tailSet ( start , true ) ; }
public static boolean equals ( byte [ ] array1 , byte [ ] array2 , int length ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1. length < length || array2. length < length ) { return false ; } for ( int i = 0 ; i < length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) { return false ; } } return true ; }
public boolean contains ( Object o ) { synchronized ( mutex ) { return delegate ( ) . contains ( o ) ; } }
public RestoreDomainAccessResult restoreDomainAccess ( RestoreDomainAccessRequest request ) { request = beforeClientExecution ( request ) ; return executeRestoreDomainAccess ( request ) ; }
static final public boolean wasEscaped ( CharSequence text , int index ) { if ( text instanceof UnescapedCharSequence ) return ( ( UnescapedCharSequence ) text ) . wasEscaped [ index ] ; else return false ; }
public void setCmd ( Character way , int cmd ) { Cell c = at ( way ) ; if ( c == null ) { c = new Cell ( ) ; c . cmd = cmd ; cells . put ( way , c ) ; } else { c . cmd = cmd ; } c . cnt = ( cmd >= 0 ) ? 1 : 0 ; }
public ValueRangeRecord ( RecordInputStream in ) { field_1_minimumAxisValue = in . readDouble ( ) ; field_2_maximumAxisValue = in . readDouble ( ) ; field_3_majorIncrement = in . readDouble ( ) ; field_4_minorIncrement = in . readDouble ( ) ; field_5_categoryAxisCross = in . readDouble ( ) ; field_6_options = in . readShort ( ) ; }
public void addFiles ( Collection < String > files ) { checkFileNames ( files ) ; for ( String f : files ) { setFiles . add ( namedForThisSegment ( f ) ) ; } }
public CreateClientVpnEndpointResult createClientVpnEndpoint ( CreateClientVpnEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateClientVpnEndpoint ( request ) ; }
public static IntBuffer allocate ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( ) ; } return new ReadWriteIntArrayBuffer ( capacity ) ; }
public File getFile ( ) { return attributes . getFile ( ) ; }
public static CFRecordsAggregate createCFAggregate ( RecordStream rs ) { Record rec = rs . getNext ( ) ; if ( rec . getSid ( ) != CFHeaderRecord . sid && rec . getSid ( ) != CFHeader12Record . sid ) { throw new IllegalStateException ( " next ▁ record ▁ sid ▁ was ▁ " + rec . getSid ( ) + " ▁ instead ▁ of ▁ " + CFHeaderRecord . sid + " ▁ or ▁ " + CFHeader12Record . sid + " ▁ as ▁ expected " ) ; } CFHeaderBase header = ( CFHeaderBase ) rec ; int nRules = header . getNumberOfConditionalFormats ( ) ; CFRuleBase [ ] rules = new CFRuleBase [ nRules ] ; for ( int i = 0 ; i < rules . length ; i ++ ) { rules [ i ] = ( CFRuleBase ) rs . getNext ( ) ; } return new CFRecordsAggregate ( header , rules ) ; }
public void save ( ) throws IOException { final byte [ ] out ; final String text = toText ( ) ; if ( utf8Bom ) { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; bos . write ( 0xEF ) ; bos . write ( 0xBB ) ; bos . write ( 0xBF ) ; bos . write ( text . getBytes ( UTF_8 ) ) ; out = bos . toByteArray ( ) ; } else { out = Constants . encode ( text ) ; } final LockFile lf = new LockFile ( getFile ( ) ) ; if ( ! lf . lock ( ) ) throw new LockFailedException ( getFile ( ) ) ; try { lf . setNeedSnapshot ( true ) ; lf . write ( out ) ; if ( ! lf . commit ( ) ) throw new IOException ( MessageFormat . format ( JGitText . get ( ) . cannotCommitWriteTo , getFile ( ) ) ) ; } finally { lf . unlock ( ) ; } snapshot = lf . getCommitSnapshot ( ) ; hash = hash ( out ) ; fireConfigChangedEvent ( ) ; }
public DeleteTopicRequest ( String topicArn ) { setTopicArn ( topicArn ) ; }
public static boolean contains ( CellRangeAddress crA , CellRangeAddress crB ) { return le ( crA . getFirstRow ( ) , crB . getFirstRow ( ) ) && ge ( crA . getLastRow ( ) , crB . getLastRow ( ) ) && le ( crA . getFirstColumn ( ) , crB . getFirstColumn ( ) ) && ge ( crA . getLastColumn ( ) , crB . getLastColumn ( ) ) ; }
@ Override public void clear ( ) { if ( size != 0 ) { Arrays . fill ( array , 0 , size , null ) ; size = 0 ; modCount ++ ; } }
public String toString ( ) { return this . getClass ( ) . toString ( ) ; }
public CherryPickCommand include ( Ref commit ) { checkCallable ( ) ; commits . add ( commit ) ; return this ; }
public String toString ( ) { return " NO □ MERGES " ; }
public FileMode getOldMode ( int nthParent ) { return oldModes [ nthParent ] ; }
public void reset ( Reader reader ) { this . reader = reader ; nextPos = 0 ; nextWrite = 0 ; count = 0 ; end = false ; }
public void serialize ( LittleEndianOutput out ) { String formatString = getFormatString ( ) ; out . writeShort ( getIndexCode ( ) ) ; out . writeShort ( formatString . length ( ) ) ; out . writeByte ( field_3_hasMultibyte ? 0x01 : 0x00 ) ; if ( field_3_hasMultibyte ) { StringUtil . putUnicodeLE ( formatString , out ) ; } else { StringUtil . putCompressedUnicode ( formatString , out ) ; } }
public DescribePendingMaintenanceActionsResult describePendingMaintenanceActions ( DescribePendingMaintenanceActionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribePendingMaintenanceActions ( request ) ; }
public DescribeServicesResult describeServices ( DescribeServicesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeServices ( request ) ; }
public int getCachedResultType ( ) { if ( specialCachedValue == null ) { return CellType . NUMERIC . getCode ( ) ; } return specialCachedValue . getValueType ( ) ; }
public boolean stem ( ) { int v_1 = cursor ; r_mark_regions ( ) ; cursor = v_1 ; limit_backward = cursor ; cursor = limit ; int v_2 = limit - cursor ; r_main_suffix ( ) ; cursor = limit - v_2 ; int v_3 = limit - cursor ; r_consonant_pair ( ) ; cursor = limit - v_3 ; int v_4 = limit - cursor ; r_other_suffix ( ) ; cursor = limit - v_4 ; int v_5 = limit - cursor ; r_undouble ( ) ; cursor = limit - v_5 ; cursor = limit_backward ; return true ; }
public void setCachedResultErrorCode ( int errorCode ) { specialCachedValue = FormulaSpecialCachedValue . createCachedErrorCode ( errorCode ) ; }
public void setMinShingleSize ( int minShingleSize ) { if ( minShingleSize < 2 ) { throw new IllegalArgumentException ( " Min ▁ shingle ▁ size ▁ must ▁ be ▁ >= ▁ 2 " ) ; } if ( minShingleSize > maxShingleSize ) { throw new IllegalArgumentException ( " Min ▁ shingle ▁ size ▁ must ▁ be ▁ <= ▁ max ▁ shingle ▁ size " ) ; } this . minShingleSize = minShingleSize ; gramSize = new CircularSequence ( ) ; }
public void write ( int value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . write ( value ) ; }
public int serializeSimplePart ( byte [ ] data , int pos ) { LittleEndian . putShort ( data , pos , getId ( ) ) ; LittleEndian . putInt ( data , pos + 2 , complexData . length ) ; return 6 ; }
public InputMismatchException ( Parser recognizer ) { super ( recognizer , recognizer . getInputStream ( ) , recognizer . _ctx ) ; this . setOffendingToken ( recognizer . getCurrentToken ( ) ) ; }
public long ramBytesUsed ( ) { long mem = RamUsageEstimator . shallowSizeOf ( this ) + RamUsageEstimator . sizeOf ( offsets ) ; if ( offsets != ordinals ) { mem += RamUsageEstimator . sizeOf ( ordinals ) ; } return mem ; }
public Trec1MQReader ( String name ) { super ( ) ; this . name = name ; }
public String toString ( ) { return " MergeInfo ▁ [ totalMaxDoc = " + totalMaxDoc + " , ▁ estimatedMergeBytes = " + estimatedMergeBytes + " , ▁ isExternal = " + isExternal + " , ▁ mergeMaxNumSegments = " + mergeMaxNumSegments + " ] " ; }
public GetVaultNotificationsRequest ( String vaultName ) { setVaultName ( vaultName ) ; }
public DisassociatePhoneNumbersFromVoiceConnectorGroupResult disassociatePhoneNumbersFromVoiceConnectorGroup ( DisassociatePhoneNumbersFromVoiceConnectorGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociatePhoneNumbersFromVoiceConnectorGroup ( request ) ; }
public int size ( ) { return ConcurrentHashMap . this . size ( ) ; }
public void addPattern ( String pattern , String ivalue ) { int k = ivalues . find ( ivalue ) ; if ( k <= 0 ) { k = packValues ( ivalue ) ; ivalues . insert ( ivalue , ( char ) k ) ; } insert ( pattern , ( char ) k ) ; }
public boolean isSheetHidden ( int sheetnum ) { return getBoundSheetRec ( sheetnum ) . isHidden ( ) ; }
public AddUserToGroupRequest ( String groupName , String userName ) { setGroupName ( groupName ) ; setUserName ( userName ) ; }
public static double sumsq ( double [ ] values ) { double sumsq = 0 ; for ( double value : values ) { sumsq += value * value ; } return sumsq ; }
public DeleteHostedZoneRequest ( String id ) { setId ( id ) ; }
public UserSViewEnd ( RecordInputStream in ) { _rawData = in . readRemainder ( ) ; }
public BatchPutScheduledUpdateGroupActionResult batchPutScheduledUpdateGroupAction ( BatchPutScheduledUpdateGroupActionRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchPutScheduledUpdateGroupAction ( request ) ; }
public static EvaluationException numberError ( ) { return new EvaluationException ( ErrorEval . NUM_ERROR ) ; }
public String displayName ( ) { return this . displayName ; }
public final boolean equals ( Object o ) { if ( o instanceof AnyObjectId ) { return equals ( ( AnyObjectId ) o ) ; } return false ; }
public DescribeSpotFleetRequestHistoryResult describeSpotFleetRequestHistory ( DescribeSpotFleetRequestHistoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSpotFleetRequestHistory ( request ) ; }
public InventoryPrefixPredicate ( String prefix ) { this . prefix = prefix ; }
public static synchronized MergeStrategy [ ] get ( ) { final MergeStrategy [ ] r = new MergeStrategy [ STRATEGIES . size ( ) ] ; STRATEGIES . values ( ) . toArray ( r ) ; return r ; }
public DeleteVoiceConnectorTerminationCredentialsResult deleteVoiceConnectorTerminationCredentials ( DeleteVoiceConnectorTerminationCredentialsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVoiceConnectorTerminationCredentials ( request ) ; }
public int mark ( ) { if ( numMarkers == 0 ) { lastCharBufferStart = lastChar ; } int mark = - numMarkers - 1 ; numMarkers ++ ; return mark ; }
public ScoreCachingWrappingScorer ( Scorable scorer ) { this . in = scorer ; }
public void skip ( long count ) throws IOException { assert count >= 0 ; if ( ord + count > valueCount || ord + count < 0 ) { throw new EOFException ( ) ; } final int skipBuffer = ( int ) Math . min ( count , blockSize - off ) ; off += skipBuffer ; ord += skipBuffer ; count -= skipBuffer ; if ( count == 0L ) { return ; } assert off == blockSize ; while ( count >= blockSize ) { final int token = in . readByte ( ) & 0xFF ; final int bitsPerValue = token >>> BPV_SHIFT ; if ( bitsPerValue > 64 ) { throw new IOException ( " Corrupted " ) ; } if ( ( token & MIN_VALUE_EQUALS_0 ) == 0 ) { readVLong ( in ) ; } final long blockBytes = PackedInts . Format . PACKED . byteCount ( packedIntsVersion , blockSize , bitsPerValue ) ; skipBytes ( blockBytes ) ; ord += blockSize ; count -= blockSize ; } if ( count == 0L ) { return ; } assert count < blockSize ; refill ( ) ; ord += count ; off += count ; }
public GetDownloadUrlsRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetDownloadUrls " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public ListSecurityProfilesResult listSecurityProfiles ( ListSecurityProfilesRequest request ) { request = beforeClientExecution ( request ) ; return executeListSecurityProfiles ( request ) ; }
@ Override public boolean contains ( Object o ) { return containsKey ( o ) ; }
public TerminalNode getToken ( int ttype , int i ) { if ( children == null || i < 0 || i >= children . size ( ) ) { return null ; } int j = - 1 ; for ( ParseTree o : children ) { if ( o instanceof TerminalNode ) { TerminalNode tnode = ( TerminalNode ) o ; Token symbol = tnode . getSymbol ( ) ; if ( symbol . getType ( ) == ttype ) { j ++ ; if ( j == i ) { return tnode ; } } } } return null ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _offset ) ; out . writeShort ( _fontIndex ) ; }
public void incrementOpen ( ) { useCnt . incrementAndGet ( ) ; }
public OneMerge ( List < SegmentCommitInfo > segments ) { if ( 0 == segments . size ( ) ) { throw new RuntimeException ( " segments ▁ must ▁ include ▁ at ▁ least ▁ one ▁ segment " ) ; } this . segments = new ArrayList <> ( segments ) ; int count = 0 ; for ( SegmentCommitInfo info : segments ) { count += info . info . maxDoc ( ) ; } totalMaxDoc = count ; mergeProgress = new OneMergeProgress ( ) ; }
public final byte get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return backingArray [ offset + position ++ ] ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( " ▁ [ " ) ; if ( _isQuoted ) { sb . append ( " ' " ) . append ( □ name ) . append ( " ' " ) ; } else { sb . append ( _name ) ; } sb . append ( " ] " ) ; return sb . toString ( ) ; }
public AssociateWebsiteCertificateAuthorityResult associateWebsiteCertificateAuthority ( AssociateWebsiteCertificateAuthorityRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateWebsiteCertificateAuthority ( request ) ; }
public RevFilter clone ( ) { return new PatternSearch ( pattern ( ) ) ; }
public PredictionContext getParent ( int index ) { return null ; }
public AttachVpnGatewayRequest ( String vpnGatewayId , String vpcId ) { setVpnGatewayId ( vpnGatewayId ) ; setVpcId ( vpcId ) ; }
public void onUpdate ( DocumentsWriterFlushControl control , ThreadState state ) { onInsert ( control , state ) ; onDelete ( control , state ) ; }
public UpdateComponentResult updateComponent ( UpdateComponentRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateComponent ( request ) ; }
public DeleteDashboardResult deleteDashboard ( DeleteDashboardRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDashboard ( request ) ; }
public byte [ ] getByteBlock ( ) { if ( freeBlocks == 0 ) { bytesUsed . addAndGet ( blockSize ) ; return new byte [ blockSize ] ; } final byte [ ] b = freeByteBlocks [ -- freeBlocks ] ; freeByteBlocks [ freeBlocks ] = null ; return b ; }
public DisableLoggingResult disableLogging ( DisableLoggingRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableLogging ( request ) ; }
public TokenStream create ( TokenStream input ) { return new CJKWidthFilter ( input ) ; }
public void reset ( int startOffset , int endOffset ) { bufferUpto = startOffset / INT_BLOCK_SIZE ; bufferOffset = bufferUpto * INT_BLOCK_SIZE ; this . end = endOffset ; upto = startOffset ; level = 1 ; buffer = pool . buffers [ bufferUpto ] ; upto = startOffset & INT_BLOCK_MASK ; final int firstSize = IntBlockPool . LEVEL_SIZE_ARRAY [ 0 ] ; if ( startOffset + firstSize >= endOffset ) { limit = endOffset & INT_BLOCK_MASK ; } else { limit = upto + firstSize - 1 ; } }
public long ramBytesUsed ( ) { return values . ramBytesUsed ( ) + super . ramBytesUsed ( ) + Long . BYTES + RamUsageEstimator . NUM_BYTES_OBJECT_REF ; }
public PutItemOutcome putItem ( Item item ) { return putItemDelegate . putItem ( item ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = byte0 >>> 2 ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte0 & 3 ) << 4 ) | ( byte1 >>> 4 ) ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 15 ) << 2 ) | ( byte2 >>> 6 ) ; values [ valuesOffset ++ ] = byte2 & 63 ; } }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ DELTA ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . maxchange ▁ = ▁ " ) . append ( getMaxChange ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / DELTA ] \ n " ) ; return buffer . toString ( ) ; }
public StartFaceDetectionResult startFaceDetection ( StartFaceDetectionRequest request ) { request = beforeClientExecution ( request ) ; return executeStartFaceDetection ( request ) ; }
public DataValidation createValidation ( DataValidationConstraint constraint , CellRangeAddressList cellRangeAddressList ) { return new HSSFDataValidation ( cellRangeAddressList , constraint ) ; }
public DocumentStoredFieldVisitor ( Set < String > fieldsToAdd ) { this . fieldsToAdd = fieldsToAdd ; }
public TokenStream create ( TokenStream tokenStream ) { return new HunspellStemFilter ( tokenStream , dictionary , true , longestOnly ) ; }
public Repository getRepository ( ) { return repository ; }
public DeleteMLModelResult deleteMLModel ( DeleteMLModelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMLModel ( request ) ; }
public GetAccountLimitResult getAccountLimit ( GetAccountLimitRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAccountLimit ( request ) ; }
public final char [ ] GetSuffix ( int len ) { char [ ] value = new char [ len ] ; System . arraycopy ( buffer , bufferPosition - len , value , 0 , len ) ; return value ; }
public ModifyClientVpnEndpointResult modifyClientVpnEndpoint ( ModifyClientVpnEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyClientVpnEndpoint ( request ) ; }
public final boolean containsRow ( int row ) { return _firstRow <= row && _lastRow >= row ; }
public int available ( ) { return remainingBytes ( ) ; }
public RequestEnvironmentInfoRequest ( EnvironmentInfoType infoType ) { setInfoType ( infoType . toString ( ) ) ; }
public void write ( byte [ ] buf ) throws IOException { write ( buf , 0 , buf . length ) ; }
public ResetDBClusterParameterGroupResult resetDBClusterParameterGroup ( ResetDBClusterParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeResetDBClusterParameterGroup ( request ) ; }
public void unwriteProtectWorkbook ( ) { this . workbook . unwriteProtectWorkbook ( ) ; }
public ANTLRInputStream ( String input ) { this . data = input . toCharArray ( ) ; this . n = input . length ( ) ; }
public ByteBuffer putShort ( short value ) { throw new ReadOnlyBufferException ( ) ; }
public ReplaceIamInstanceProfileAssociationResult replaceIamInstanceProfileAssociation ( ReplaceIamInstanceProfileAssociationRequest request ) { request = beforeClientExecution ( request ) ; return executeReplaceIamInstanceProfileAssociation ( request ) ; }
public void add ( String name , Expression expression ) { map . put ( name , expression ) ; }
public Ref3DPtg ( CellReference c , int externIdx ) { super ( c ) ; setExternSheetIndex ( externIdx ) ; }
public int readUShort ( ) { byte [ ] buf = new byte [ LittleEndianConsts . SHORT_SIZE ] ; try { checkEOF ( read ( buf ) , LittleEndianConsts . SHORT_SIZE ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return LittleEndian . getUShort ( buf ) ; }
public int stem ( char s [ ] , int len ) { len = removeCase ( s , len ) ; len = removePossessives ( s , len ) ; if ( len > 0 ) { len = normalize ( s , len ) ; } return len ; }
public static int getNearestSetSize ( int maxNumberOfBits ) { int result = usableBitSetSizes [ 0 ] ; for ( int i = 0 ; i < usableBitSetSizes . length ; i ++ ) { if ( usableBitSetSizes [ i ] <= maxNumberOfBits ) { result = usableBitSetSizes [ i ] ; } } return result ; }
public String toString ( ) { return " AbbreviatedObjectId [ " + name ( ) + " ] " ; }
public ListFacesRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListFaces " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public BytesRef ( int capacity ) { this . bytes = new byte [ capacity ] ; }
public DescribeFargateProfileResult describeFargateProfile ( DescribeFargateProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFargateProfile ( request ) ; }
public GetOpenIdTokenForDeveloperIdentityResult getOpenIdTokenForDeveloperIdentity ( GetOpenIdTokenForDeveloperIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeGetOpenIdTokenForDeveloperIdentity ( request ) ; }
public int countBytesWritten ( ) { return _countBytesWritten ; }
public boolean containsAll ( final IntList c ) { boolean rval = true ; if ( this != c ) { for ( int j = 0 ; rval && ( j < c . _limit ) ; j ++ ) { if ( ! contains ( c . _array [ j ] ) ) { rval = false ; } } } return rval ; }
public void setTreeFilter ( TreeFilter newFilter ) { assertNotStarted ( ) ; treeFilter = newFilter != null ? newFilter : TreeFilter . ALL ; }
public DBInstance promoteReadReplica ( PromoteReadReplicaRequest request ) { request = beforeClientExecution ( request ) ; return executePromoteReadReplica ( request ) ; }
public final short getShort ( ) { int newPosition = position + SizeOf . SHORT ; if ( newPosition > limit ) { throw new BufferUnderflowException ( ) ; } short result = Memory . peekShort ( backingArray , offset + position , order ) ; position = newPosition ; return result ; }
public AttachClassicLinkVpcResult attachClassicLinkVpc ( AttachClassicLinkVpcRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachClassicLinkVpc ( request ) ; }
public static < T > T [ ] grow ( T [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { final int newLength = oversize ( minSize , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ; return growExact ( array , newLength ) ; } else return array ; }
public ByteArrayDataOutput ( ) { reset ( BytesRef . EMPTY_BYTES ) ; }
public void balance ( ) { int i = 0 , n = length ; String [ ] k = new String [ n ] ; char [ ] v = new char [ n ] ; Iterator iter = new Iterator ( ) ; while ( iter . hasMoreElements ( ) ) { v [ i ] = iter . getValue ( ) ; k [ i ++ ] = iter . nextElement ( ) ; } init ( ) ; insertBalanced ( k , v , 0 , n ) ; }
public MultiPhraseQueryNode ( ) { setLeaf ( false ) ; allocate ( ) ; }
public PublishRequest ( String topicArn , String message , String subject ) { setTopicArn ( topicArn ) ; setMessage ( message ) ; setSubject ( subject ) ; }
public SendCommandResult sendCommand ( SendCommandRequest request ) { request = beforeClientExecution ( request ) ; return executeSendCommand ( request ) ; }
public ListDeploymentInstancesResult listDeploymentInstances ( ListDeploymentInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeListDeploymentInstances ( request ) ; }
public Iterator < E > iterator ( ) { return delegate ( ) . iterator ( ) ; }
public ProvisionedThroughput ( Long readCapacityUnits , Long writeCapacityUnits ) { setReadCapacityUnits ( readCapacityUnits ) ; setWriteCapacityUnits ( writeCapacityUnits ) ; }
public DescribeTagsResult describeTags ( ) { return describeTags ( new DescribeTagsRequest ( ) ) ; }
public DeprovisionByoipCidrResult deprovisionByoipCidr ( DeprovisionByoipCidrRequest request ) { request = beforeClientExecution ( request ) ; return executeDeprovisionByoipCidr ( request ) ; }
public boolean isDone ( TreeWalk walker ) { return pathRaw . length == walker . getPathLength ( ) ; }
public String buildExtensionField ( String extensionKey , String field ) { StringBuilder builder = new StringBuilder ( field ) ; builder . append ( this . extensionFieldDelimiter ) ; builder . append ( extensionKey ) ; return escapeExtensionField ( builder . toString ( ) ) ; }
public void reset ( byte [ ] bytes , int offset , int len ) { this . bytes = bytes ; pos = offset ; limit = offset + len ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof Loc ) ) { return false ; } Loc other = ( Loc ) obj ; return _bookSheetColumn == other . _bookSheetColumn && _rowIndex == other . _rowIndex ; }
public DeleteDeploymentConfigResult deleteDeploymentConfig ( DeleteDeploymentConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDeploymentConfig ( request ) ; }
public StartQueryExecutionResult startQueryExecution ( StartQueryExecutionRequest request ) { request = beforeClientExecution ( request ) ; return executeStartQueryExecution ( request ) ; }
public GetRepoListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoList " , " cr " ) ; setUriPattern ( " / repos " ) ; setMethod ( MethodType . GET ) ; }
public CreateDistributionResult createDistribution ( CreateDistributionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDistribution ( request ) ; }
public LongField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( " Illegal ▁ offset : ▁ " + offset ) ; } _offset = offset ; }
public String toString ( ) { StringBuilder b = new StringBuilder ( ) ; b . append ( " ▁ target = " ) . append ( target ( ) ) ; b . append ( " ▁ label = 0x " ) . append ( Integer . toHexString ( label ( ) ) ) ; if ( flag ( BIT_FINAL_ARC ) ) { b . append ( " ▁ final " ) ; } if ( flag ( BIT_LAST_ARC ) ) { b . append ( " ▁ last " ) ; } if ( flag ( BIT_TARGET_NEXT ) ) { b . append ( " ▁ targetNext " ) ; } if ( flag ( BIT_STOP_NODE ) ) { b . append ( " ▁ stop " ) ; } if ( flag ( BIT_ARC_HAS_OUTPUT ) ) { b . append ( " ▁ output = " ) . append ( output ( ) ) ; } if ( flag ( BIT_ARC_HAS_FINAL_OUTPUT ) ) { b . append ( " ▁ nextFinalOutput = " ) . append ( nextFinalOutput ( ) ) ; } if ( bytesPerArc ( ) != 0 ) { b . append ( " ▁ arcArray ( idx = " ) . append ( arcIdx ( ) ) . append ( " ▁ of ▁ " ) . append ( numArcs ( ) ) . append ( " ) " ) ; } return b . toString ( ) ; }
public final int getRefCount ( ) { return refCount . get ( ) ; }
public int readInt ( ) { byte [ ] buf = new byte [ LittleEndianConsts . INT_SIZE ] ; try { checkEOF ( read ( buf ) , buf . length ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return LittleEndian . getInt ( buf ) ; }
public BatchCreateAttendeeResult batchCreateAttendee ( BatchCreateAttendeeRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchCreateAttendee ( request ) ; }
public DetachInstancesFromLoadBalancerResult detachInstancesFromLoadBalancer ( DetachInstancesFromLoadBalancerRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachInstancesFromLoadBalancer ( request ) ; }
public int getSourceStart ( ) { return outRegion . sourceStart ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ FORMAT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . indexcode ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( getIndexCode ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . isUnicode ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( field_3_hasMultibyte ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . formatstring ▁ ▁ ▁ ▁ = ▁ " ) . append ( getFormatString ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / FORMAT ] \ n " ) ; return buffer . toString ( ) ; }
public void remove ( ) { if ( lastReturned == null ) { throw new IllegalStateException ( ) ; } Impl . this . remove ( lastReturned . getKey ( ) ) ; lastReturned = null ; }
public String toString ( ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " < boolean ▁ operation = ' or ' /> " ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " < boolean ▁ operation = ' or ' > " ) ; for ( QueryNode child : getChildren ( ) ) { sb . append ( " \ n " ) ; sb . append ( child . toString ( ) ) ; } sb . append ( " \ n </ boolean > " ) ; return sb . toString ( ) ; }
public String getPartOfSpeech ( int wordId ) { return getFeature ( wordId , 1 ) ; }
public BatchWriteResult batchWrite ( BatchWriteRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchWrite ( request ) ; }
public ObjectId idFor ( int type , byte [ ] data ) { return delegate ( ) . idFor ( type , data ) ; }
public ConfirmTransitVirtualInterfaceResult confirmTransitVirtualInterface ( ConfirmTransitVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeConfirmTransitVirtualInterface ( request ) ; }
public GetFileUploadURLResult getFileUploadURL ( GetFileUploadURLRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFileUploadURL ( request ) ; }
public TokenStream create ( TokenStream input ) { return new KeywordRepeatFilter ( input ) ; }
public StartWorkspacesResult startWorkspaces ( StartWorkspacesRequest request ) { request = beforeClientExecution ( request ) ; return executeStartWorkspaces ( request ) ; }
public int getDeltaCacheLimit ( ) { return deltaCacheLimit ; }
public RebootJumpserverRequest ( ) { super ( " HPC " , " 2016 - 06 - 03 " , " RebootJumpserver " , " hpc " ) ; setMethod ( MethodType . POST ) ; }
public int getResultEnd ( ) { Region r = outRegion ; return r . resultStart + r . length ; }
public CreateLagResult createLag ( CreateLagRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLag ( request ) ; }
public ConflictState getConflictState ( ) { return conflictState ; }
public final void writeByte ( int val ) throws IOException { write ( val & 0xFF ) ; }
public UpdateRelationalDatabaseResult updateRelationalDatabase ( UpdateRelationalDatabaseRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRelationalDatabase ( request ) ; }
public Entry < K , V > lowerEntry ( K key ) { return immutableCopy ( findBounded ( key , LOWER ) ) ; }
public ExternalNameRecord ( ) { field_2_ixals = 0 ; }
public int stem ( char s [ ] , int len ) { len = stemPrefix ( s , len ) ; len = stemSuffix ( s , len ) ; return len ; }
public final void remove ( RevFlagSet set ) { flags &= ~ set . mask ; }
public IllegalFormatFlagsException ( String flags ) { if ( flags == null ) { throw new NullPointerException ( ) ; } this . flags = flags ; }
public boolean shouldBeRecursive ( ) { return false ; }
public CapitalizationFilter create ( TokenStream input ) { return new CapitalizationFilter ( input , onlyFirstWord , keep , forceFirstLetter , okPrefix , minWordLength , maxWordCount , maxTokenLength ) ; }
public GetAppliedSchemaVersionResult getAppliedSchemaVersion ( GetAppliedSchemaVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAppliedSchemaVersion ( request ) ; }
public DescribeLabelingJobResult describeLabelingJob ( DescribeLabelingJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLabelingJob ( request ) ; }
public DeleteAttendeeResult deleteAttendee ( DeleteAttendeeRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAttendee ( request ) ; }
public final String toString ( List < String > ruleNames ) { return toString ( ruleNames , null ) ; }
public RejectAssignmentResult rejectAssignment ( RejectAssignmentRequest request ) { request = beforeClientExecution ( request ) ; return executeRejectAssignment ( request ) ; }
public CharVector ( char [ ] a , int capacity ) { if ( capacity > 0 ) { blockSize = capacity ; } else { blockSize = DEFAULT_BLOCK_SIZE ; } array = a ; n = a . length ; }
public UnsubscribeFromEventResult unsubscribeFromEvent ( UnsubscribeFromEventRequest request ) { request = beforeClientExecution ( request ) ; return executeUnsubscribeFromEvent ( request ) ; }
public String getNextToken ( ) { if ( pos >= format . length ( ) ) { return null ; } int subStart = pos ; final char curChar = format . charAt ( pos ) ; ++ pos ; if ( curChar == ' \ ' ' ) { while ( ( pos < format . length ( ) ) && ( format . charAt ( pos ) != ' \ ' ' ) ) { ++ pos ; } if ( pos < format . length ( ) ) { ++ pos ; } } else { while ( ( pos < format . length ( ) ) && ( format . charAt ( pos ) == curChar ) ) { ++ pos ; } } return format . substring ( subStart , pos ) ; }
public Policy withId ( String id ) { setId ( id ) ; return this ; }
public void setStringValue ( String value ) { if ( ! ( fieldsData instanceof String ) ) { throw new IllegalArgumentException ( " cannot ▁ change ▁ value ▁ type ▁ from ▁ " + fieldsData . getClass ( ) . getSimpleName ( ) + " ▁ to ▁ String " ) ; } if ( value == null ) { throw new IllegalArgumentException ( " value ▁ must ▁ not ▁ be ▁ null " ) ; } fieldsData = value ; }
public Area3DPtg ( String arearef , int externIdx ) { super ( new AreaReference ( arearef , SpreadsheetVersion . EXCEL97 ) ) ; setExternSheetIndex ( externIdx ) ; }
public boolean empty ( ) { return isEmpty ( ) ; }
public DeleteMemberResult deleteMember ( DeleteMemberRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMember ( request ) ; }
public DeleteRepositoryResult deleteRepository ( DeleteRepositoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRepository ( request ) ; }
public GetChangeResult getChange ( GetChangeRequest request ) { request = beforeClientExecution ( request ) ; return executeGetChange ( request ) ; }
public PrefixCodedTerms finish ( ) { return new PrefixCodedTerms ( output . toBufferList ( ) , size ) ; }
@ Override public synchronized void clear ( ) { elements = EmptyArray . OBJECT ; }
public LongBuffer duplicate ( ) { ByteBuffer bb = byteBuffer . duplicate ( ) . order ( byteBuffer . order ( ) ) ; LongToByteBufferAdapter buf = new LongToByteBufferAdapter ( bb ) ; buf . limit = limit ; buf . position = position ; buf . mark = mark ; return buf ; }
public StyleRecord ( ) { field_1_xf_index = isBuiltinFlag . set ( 0 ) ; }
public boolean equals ( Object o ) { if ( o instanceof AbbreviatedObjectId ) { final AbbreviatedObjectId b = ( AbbreviatedObjectId ) o ; return nibbles == b . nibbles && w1 == b . w1 && w2 == b . w2 && w3 == b . w3 && w4 == b . w4 && w5 == b . w5 ; } return false ; }
public void ReInit ( QueryParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public ExtendedFormatRecord getExFormatAt ( int index ) { int xfptr = records . getXfpos ( ) - ( numxfs - 1 ) ; xfptr += index ; return ( ExtendedFormatRecord ) records . get ( xfptr ) ; }
public Resource ( String resource ) { this . resource = resource ; }
public NorwegianLightStemFilterFactory ( Map < String , String > args ) { super ( args ) ; String variant = get ( args , " variant " ) ; if ( variant == null || " nb " . equals ( variant ) ) { flags = BOKMAAL ; } else if ( " nn " . equals ( variant ) ) { flags = NYNORSK ; } else if ( " no " . equals ( variant ) ) { flags = BOKMAAL | NYNORSK ; } else { throw new IllegalArgumentException ( " invalid ▁ variant : ▁ " + variant ) ; } if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public UpdateTypedLinkFacetResult updateTypedLinkFacet ( UpdateTypedLinkFacetRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTypedLinkFacet ( request ) ; }
public E higher ( E e ) { return backingMap . higherKey ( e ) ; }
public ListReceiptFiltersResult listReceiptFilters ( ListReceiptFiltersRequest request ) { request = beforeClientExecution ( request ) ; return executeListReceiptFilters ( request ) ; }
public int size ( ) { synchronized ( lock ) { return count ; } }
public CreateVaultRequest ( String vaultName ) { setVaultName ( vaultName ) ; }
public PendingOutputs ( ) { outputs = new CharsRefBuilder [ 1 ] ; endOffsets = new int [ 1 ] ; posLengths = new int [ 1 ] ; }
public static double getExcelDate ( Date date , boolean use1904windowing ) { Calendar calStart = LocaleUtil . getLocaleCalendar ( ) ; calStart . setTime ( date ) ; int year = calStart . get ( Calendar . YEAR ) ; int dayOfYear = calStart . get ( Calendar . DAY_OF_YEAR ) ; int hour = calStart . get ( Calendar . HOUR_OF_DAY ) ; int minute = calStart . get ( Calendar . MINUTE ) ; int second = calStart . get ( Calendar . SECOND ) ; int milliSecond = calStart . get ( Calendar . MILLISECOND ) ; return internalGetExcelDate ( year , dayOfYear , hour , minute , second , milliSecond , use1904windowing ) ; }
public ValueEval evaluate ( ValueEval [ ] args , OperationEvaluationContext ec ) { int nIncomingArgs = args . length ; if ( nIncomingArgs < 1 ) { throw new RuntimeException ( " function ▁ name ▁ argument ▁ missing " ) ; } ValueEval nameArg = args [ 0 ] ; String functionName ; if ( nameArg instanceof FunctionNameEval ) { functionName = ( ( FunctionNameEval ) nameArg ) . getFunctionName ( ) ; } else { throw new RuntimeException ( " First ▁ argument ▁ should ▁ be ▁ a ▁ NameEval , ▁ but ▁ got ▁ ( " + nameArg . getClass ( ) . getName ( ) + " ) " ) ; } FreeRefFunction targetFunc = ec . findUserDefinedFunction ( functionName ) ; if ( targetFunc == null ) { throw new NotImplementedFunctionException ( functionName ) ; } int nOutGoingArgs = nIncomingArgs - 1 ; ValueEval [ ] outGoingArgs = new ValueEval [ nOutGoingArgs ] ; System . arraycopy ( args , 1 , outGoingArgs , 0 , nOutGoingArgs ) ; return targetFunc . evaluate ( outGoingArgs , ec ) ; }
public int indexOf ( Object object ) { int pos = 0 ; Link < E > link = voidLink . next ; if ( object != null ) { while ( link != voidLink ) { if ( object . equals ( link . data ) ) { return pos ; } link = link . next ; pos ++ ; } } else { while ( link != voidLink ) { if ( link . data == null ) { return pos ; } link = link . next ; pos ++ ; } } return - 1 ; }
public DescribeVpcClassicLinkResult describeVpcClassicLink ( DescribeVpcClassicLinkRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcClassicLink ( request ) ; }
public void sort ( RevSort s , boolean use ) { if ( s == RevSort . TOPO && ! use ) throw new IllegalArgumentException ( JGitText . get ( ) . topologicalSortRequired ) ; super . sort ( s , use ) ; }
public synchronized StringBuffer delete ( int start , int end ) { delete0 ( start , end ) ; return this ; }
public void write ( int b ) throws IOException { throw new UnsupportedOperationException ( ) ; }
public boolean isModeDifferent ( int rawMode ) { int modeDiff = getEntryRawMode ( ) ^ rawMode ; if ( modeDiff == 0 ) return false ; if ( getOptions ( ) . getSymLinks ( ) == SymLinks . FALSE ) if ( FileMode . SYMLINK . equals ( rawMode ) ) return false ; if ( ! state . options . isFileMode ( ) ) modeDiff &= ~ FileMode . EXECUTABLE_FILE . getBits ( ) ; return modeDiff != 0 ; }
public DescribeReservedInstancesModificationsResult describeReservedInstancesModifications ( DescribeReservedInstancesModificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReservedInstancesModifications ( request ) ; }
public EventSubscription addSourceIdentifierToSubscription ( AddSourceIdentifierToSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeAddSourceIdentifierToSubscription ( request ) ; }
@ Override public boolean equals ( Object o ) { if ( o == this ) { return true ; } synchronized ( mutex ) { return delegate ( ) . equals ( o ) ; } }
public PagedBytesDataOutput getDataOutput ( ) { if ( frozen ) { throw new IllegalStateException ( " cannot ▁ get ▁ DataOutput ▁ after ▁ freeze ( ) " ) ; } return new PagedBytesDataOutput ( ) ; }
public static short [ ] copyOfRange ( short [ ] original , int start , int end ) { if ( start > end ) { throw new IllegalArgumentException ( ) ; } int originalLength = original . length ; if ( start < 0 || start > originalLength ) { throw new ArrayIndexOutOfBoundsException ( ) ; } int resultLength = end - start ; int copyLength = Math . min ( resultLength , originalLength - start ) ; short [ ] result = new short [ resultLength ] ; System . arraycopy ( original , start , result , 0 , copyLength ) ; return result ; }
public boolean removeURI ( URIish toRemove ) { return uris . remove ( toRemove ) ; }
public DescribeGameServerResult describeGameServer ( DescribeGameServerRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeGameServer ( request ) ; }
public boolean hasNext ( ) { return pos < keys . length ; }
public IntervalSet subtract ( IntSet a ) { if ( a == null || a . isNil ( ) ) { return new IntervalSet ( this ) ; } if ( a instanceof IntervalSet ) { return subtract ( this , ( IntervalSet ) a ) ; } IntervalSet other = new IntervalSet ( ) ; other . addAll ( a ) ; return subtract ( this , other ) ; }
public String displayName ( ) { return this . canonicalName ; }
public final ValueEval getValue ( int row , int col ) { return getRelativeValue ( row , col ) ; }
public AttrPtg ( LittleEndianInput in ) { _options = in . readByte ( ) ; _data = in . readShort ( ) ; if ( isOptimizedChoose ( ) ) { int [ ] jumpTable = new int [ ( int ) _data ] ; for ( int i = 0 ; i < jumpTable . length ; i ++ ) { jumpTable [ i ] = in . readUShort ( ) ; } _jumpTable = jumpTable ; _chooseFuncOffset = in . readUShort ( ) ; } else { _jumpTable = null ; _chooseFuncOffset = - 1 ; } }
public DescribeTrafficMirrorFiltersResult describeTrafficMirrorFilters ( DescribeTrafficMirrorFiltersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTrafficMirrorFilters ( request ) ; }
public final ShortBuffer put ( short [ ] src ) { return put ( src , 0 , src . length ) ; }
public DescribeReservedNodeOfferingsResult describeReservedNodeOfferings ( ) { return describeReservedNodeOfferings ( new DescribeReservedNodeOfferingsRequest ( ) ) ; }
public CreateLogStreamRequest ( String logGroupName , String logStreamName ) { setLogGroupName ( logGroupName ) ; setLogStreamName ( logStreamName ) ; }
public DetachStaticIpResult detachStaticIp ( DetachStaticIpRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachStaticIp ( request ) ; }
public static CharArraySet unmodifiableSet ( CharArraySet set ) { if ( set == null ) throw new NullPointerException ( " Given ▁ set ▁ is ▁ null " ) ; if ( set == EMPTY_SET ) return EMPTY_SET ; if ( set . map instanceof CharArrayMap . UnmodifiableCharArrayMap ) return set ; return new CharArraySet ( CharArrayMap . unmodifiableMap ( set . map ) ) ; }
public BatchDetectKeyPhrasesResult batchDetectKeyPhrases ( BatchDetectKeyPhrasesRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDetectKeyPhrases ( request ) ; }
public final ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { if ( args . length != 1 ) { return ErrorEval . VALUE_INVALID ; } return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] ) ; }
public void removeWordCount ( ) { remove1stProperty ( PropertyIDMap . PID_WORDCOUNT ) ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } else if ( ! ( o instanceof SingletonPredictionContext ) ) { return false ; } if ( this . hashCode ( ) != o . hashCode ( ) ) { return false ; } SingletonPredictionContext s = ( SingletonPredictionContext ) o ; return returnState == s . returnState && ( parent != null && parent . equals ( s . parent ) ) ; }
public ResourceBundle resourceBundle ( ) { return resourceBundle ; }
public TokenStream create ( TokenStream stream ) { if ( stopTags != null ) { final TokenStream filter = new JapanesePartOfSpeechStopFilter ( stream , stopTags ) ; return filter ; } else { return stream ; } }
public final int [ ] getBreaks ( ) { int count = getNumBreaks ( ) ; if ( count < 1 ) { return EMPTY_INT_ARRAY ; } int [ ] result = new int [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { Break breakItem = _breaks . get ( i ) ; result [ i ] = breakItem . main ; } return result ; }
public EventSubscription createEventSubscription ( CreateEventSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateEventSubscription ( request ) ; }
@ Override public V get ( Object key ) { return isInBounds ( key ) ? TreeMap . this . get ( key ) : null ; }
public void setAnchor ( int dx1 , int dy1 , int dx2 , int dy2 ) { setDx1 ( Math . min ( dx1 , dx2 ) ) ; setDy1 ( Math . min ( dy1 , dy2 ) ) ; setDx2 ( Math . max ( dx1 , dx2 ) ) ; setDy2 ( Math . max ( dy1 , dy2 ) ) ; }
public int next ( ) { if ( current == end ) { return DONE ; } else { return last ( ) ; } }
public UpdateGcmChannelResult updateGcmChannel ( UpdateGcmChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateGcmChannel ( request ) ; }
public void write ( LittleEndianOutput out ) { throw new IllegalStateException ( " XSSF - only ▁ Ptg , ▁ should ▁ not ▁ be ▁ serialised " ) ; }
public PlacementGroup ( String groupName ) { setGroupName ( groupName ) ; }
public SendCustomVerificationEmailResult sendCustomVerificationEmail ( SendCustomVerificationEmailRequest request ) { request = beforeClientExecution ( request ) ; return executeSendCustomVerificationEmail ( request ) ; }
public CreateCollectionRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " CreateCollection " , " cr " ) ; setUriPattern ( " / collections " ) ; setMethod ( MethodType . PUT ) ; }
public synchronized boolean remove ( Object o ) { int index = indexOf ( o ) ; if ( index == - 1 ) { return false ; } remove ( index ) ; return true ; }
public final boolean matches ( char c ) { return Character . isDigit ( c ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeByte ( getWSBool2 ( ) ) ; out . writeByte ( getWSBool1 ( ) ) ; }
public SubmitGenerateTaskRequest ( ) { super ( " lubancloud " , " 2018 - 05 - 09 " , " SubmitGenerateTask " , " luban " ) ; setMethod ( MethodType . POST ) ; }
public E ceiling ( E e ) { return backingMap . ceilingKey ( e ) ; }
public BatchApplyUpdateActionResult batchApplyUpdateAction ( BatchApplyUpdateActionRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchApplyUpdateAction ( request ) ; }
public Break ( RecordInputStream in ) { main = in . readUShort ( ) - 1 ; subFrom = in . readUShort ( ) ; subTo = in . readUShort ( ) ; }
public FileNameMatcher createMatcherForSuffix ( ) { final List < Head > copyOfHeads = new ArrayList <> ( heads . size ( ) ) ; copyOfHeads . addAll ( heads ) ; return new FileNameMatcher ( copyOfHeads ) ; }
public static boolean isEmptyOrNull ( String stringValue ) { return stringValue == null || stringValue . length ( ) == 0 ; }
public static char [ ] grow ( char [ ] array ) { return grow ( array , 1 + array . length ) ; }
public ModifySubnetAttributeResult modifySubnetAttribute ( ModifySubnetAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifySubnetAttribute ( request ) ; }
public GetProxySessionResult getProxySession ( GetProxySessionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetProxySession ( request ) ; }
public String toString ( ) { return " TermStats { " + " decodedTermText = ' " ▁ + ▁ decodedTermText ▁ + ▁ ' \ ' ' ▁ + " , field = ' " + field + ' \ ' ' + " , ▁ docFreq = " + docFreq + ' } ' ; }
public String getSignificantDecimalDigitsLastDigitRounded ( ) { long wp = _wholePart + 5 ; StringBuilder sb = new StringBuilder ( 24 ) ; sb . append ( wp ) ; sb . setCharAt ( sb . length ( ) - 1 , ' 0 ' ) ; return sb . toString ( ) ; }
public boolean canReuse ( IndexInput docIn , FieldInfo fieldInfo ) { return docIn == startDocIn && indexHasFreq == ( fieldInfo . getIndexOptions ( ) . compareTo ( IndexOptions . DOCS_AND_FREQS ) >= 0 ) && indexHasPos == ( fieldInfo . getIndexOptions ( ) . compareTo ( IndexOptions . DOCS_AND_FREQS_AND_POSITIONS ) >= 0 ) && indexHasPayloads == fieldInfo . hasPayloads ( ) ; }
public Sort ( SortField field ) { setSort ( field ) ; }
public static byte [ ] encodeASCII ( String s ) { final byte [ ] r = new byte [ s . length ( ) ] ; for ( int k = r . length - 1 ; k >= 0 ; k -- ) { final char c = s . charAt ( k ) ; if ( c > 127 ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . notASCIIString , s ) ) ; r [ k ] = ( byte ) c ; } return r ; }
public PurgeQueueResult purgeQueue ( PurgeQueueRequest request ) { request = beforeClientExecution ( request ) ; return executePurgeQueue ( request ) ; }
public boolean sempred ( RuleContext _localctx , int ruleIndex , int actionIndex ) { return true ; }
public ListStreamsResult listStreams ( ) { return listStreams ( new ListStreamsRequest ( ) ) ; }
public String getSurfaceFormString ( ) { return new String ( surfaceForm , offset , length ) ; }
public GetVaultNotificationsResult getVaultNotifications ( GetVaultNotificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVaultNotifications ( request ) ; }
public DeleteTypedLinkFacetResult deleteTypedLinkFacet ( DeleteTypedLinkFacetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTypedLinkFacet ( request ) ; }
public int previousIndex ( ) { return pos ; }
public long ramBytesUsed ( ) { return super . ramBytesUsed ( ) + offsets . ramBytesUsed ( ) + lengths . ramBytesUsed ( ) + RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + 2 * Integer . BYTES + 3 * RamUsageEstimator . NUM_BYTES_OBJECT_REF + values . bytes ( ) . length ; }
public PushCommand push ( ) { return new PushCommand ( repo ) ; }
public SelectResult select ( SelectRequest request ) { request = beforeClientExecution ( request ) ; return executeSelect ( request ) ; }
public ByteArrayDataOutput ( byte [ ] bytes ) { reset ( bytes ) ; }
public boolean renameTo ( String newName ) { return directory . renameTo ( newName ) ; }
public boolean canReuse ( IndexInput docIn , FieldInfo fieldInfo ) { return docIn == startDocIn && indexHasOffsets == ( fieldInfo . getIndexOptions ( ) . compareTo ( IndexOptions . DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS ) >= 0 ) && indexHasPayloads == fieldInfo . hasPayloads ( ) ; }
public boolean equals ( Object o ) { return o instanceof DanishStemmer ; }
public BooleanQuery build ( QueryNode queryNode ) throws QueryNodeException { BooleanQueryNode booleanNode = ( BooleanQueryNode ) queryNode ; BooleanQuery . Builder bQuery = new BooleanQuery . Builder ( ) ; List < QueryNode > children = booleanNode . getChildren ( ) ; if ( children != null ) { for ( QueryNode child : children ) { Object obj = child . getTag ( QueryTreeBuilder . QUERY_TREE_BUILDER_TAGID ) ; if ( obj != null ) { Query query = ( Query ) obj ; try { bQuery . add ( query , getModifierValue ( child ) ) ; } catch ( TooManyClauses ex ) { throw new QueryNodeException ( new MessageImpl ( QueryParserMessages . TOO_MANY_BOOLEAN_CLAUSES , IndexSearcher . getMaxClauseCount ( ) , queryNode . toQueryString ( new EscapeQuerySyntaxImpl ( ) ) ) , ex ) ; } } } } return bQuery . build ( ) ; }
public String getName ( ) { return name ; }
public List < TerminalNode > getTokens ( int ttype ) { if ( children == null ) { return Collections . emptyList ( ) ; } List < TerminalNode > tokens = null ; for ( ParseTree o : children ) { if ( o instanceof TerminalNode ) { TerminalNode tnode = ( TerminalNode ) o ; Token symbol = tnode . getSymbol ( ) ; if ( symbol . getType ( ) == ttype ) { if ( tokens == null ) { tokens = new ArrayList < TerminalNode > ( ) ; } tokens . add ( tnode ) ; } } } if ( tokens == null ) { return Collections . emptyList ( ) ; } return tokens ; }
public UpdateApnsChannelResult updateApnsChannel ( UpdateApnsChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateApnsChannel ( request ) ; }
public String getInput ( ) { return input ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; LittleEndian . putInt ( data , offset + 4 , getRecordSize ( ) - HEADER_SIZE ) ; int pos = offset + HEADER_SIZE ; System . arraycopy ( field_1_UID , 0 , data , pos , 16 ) ; data [ pos + 16 ] = field_2_marker ; byte [ ] pd = getPicturedata ( ) ; System . arraycopy ( pd , 0 , data , pos + 17 , pd . length ) ; listener . afterRecordSerialize ( offset + getRecordSize ( ) , getRecordId ( ) , getRecordSize ( ) , this ) ; return HEADER_SIZE + 16 + 1 + pd . length ; }
public DescribeFolderContentsResult describeFolderContents ( DescribeFolderContentsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFolderContents ( request ) ; }
public CreateDBInstanceReadReplicaRequest ( String dBInstanceIdentifier , String sourceDBInstanceIdentifier ) { setDBInstanceIdentifier ( dBInstanceIdentifier ) ; setSourceDBInstanceIdentifier ( sourceDBInstanceIdentifier ) ; }
public DVRecord clone ( ) { return copy ( ) ; }
public CreateDefaultSubnetResult createDefaultSubnet ( CreateDefaultSubnetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDefaultSubnet ( request ) ; }
public AbbreviatedObjectId getNewId ( ) { return newId ; }
public final V setValue ( V value ) { V oldValue = this . value ; this . value = value ; return oldValue ; }
public int get ( String name , int dflt ) { int vals [ ] = ( int [ ] ) valByRound . get ( name ) ; if ( vals != null ) { return vals [ roundNumber % vals . length ] ; } String sval = props . getProperty ( name , " " + dflt ) ; if ( sval . indexOf ( " : " ) < 0 ) { return Integer . parseInt ( sval ) ; } int k = sval . indexOf ( " : " ) ; String colName = sval . substring ( 0 , k ) ; sval = sval . substring ( k + 1 ) ; colForValByRound . put ( name , colName ) ; vals = propToIntArray ( sval ) ; valByRound . put ( name , vals ) ; return vals [ roundNumber % vals . length ] ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " extBook = " ) . append ( _extBookIndex ) ; buffer . append ( " ▁ firstSheet = " ) . append ( _firstSheetIndex ) ; buffer . append ( " ▁ lastSheet = " ) . append ( _lastSheetIndex ) ; return buffer . toString ( ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeInt ( field_1_reserved ) ; out . writeShort ( field_2_subex_len ) ; }
public final Buffer rewind ( ) { position = 0 ; mark = UNSET_MARK ; return this ; }
public short getHideObj ( ) { return field_1_hide_obj ; }
public PrintGridlinesRecord ( RecordInputStream in ) { field_1_print_gridlines = in . readShort ( ) ; }
public CreateEventTrackerResult createEventTracker ( CreateEventTrackerRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateEventTracker ( request ) ; }
public boolean hasNext ( ) { return index < to ; }
public void removeExFormatRecord ( ExtendedFormatRecord rec ) { records . remove ( rec ) ; numxfs -- ; }
public synchronized void publish ( Revision revision ) throws IOException { ensureOpen ( ) ; if ( currentRevision != null ) { int compare = revision . compareTo ( currentRevision . revision ) ; if ( compare == 0 ) { revision . release ( ) ; return ; } if ( compare < 0 ) { revision . release ( ) ; throw new IllegalArgumentException ( " Cannot ▁ publish ▁ an ▁ older ▁ revision : ▁ rev = " + revision + " ▁ current = " + currentRevision ) ; } } final RefCountedRevision oldRevision = currentRevision ; currentRevision = new RefCountedRevision ( revision ) ; if ( oldRevision != null ) { oldRevision . decRef ( ) ; } checkExpiredSessions ( ) ; }
public final boolean equals ( AnyObjectId other ) { return other != null ? isEqual ( this , other ) : false ; }
public DeleteBGPPeerResult deleteBGPPeer ( DeleteBGPPeerRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteBGPPeer ( request ) ; }
public String toString ( ) { return " I ( n ) " ; }
public DeleteVpcPeeringConnectionResult deleteVpcPeeringConnection ( DeleteVpcPeeringConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVpcPeeringConnection ( request ) ; }
public UpdateIdentityPoolResult updateIdentityPool ( UpdateIdentityPoolRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateIdentityPool ( request ) ; }
public String signString ( String stringToSign , AlibabaCloudCredentials credentials ) { return signString ( stringToSign , credentials . getAccessKeySecret ( ) ) ; }
public GetDeviceResult getDevice ( GetDeviceRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDevice ( request ) ; }
public void writeInt ( int v ) { writeContinueIfRequired ( 4 ) ; _ulrOutput . writeInt ( v ) ; }
public boolean isSuccess ( ) { return 200 <= this . status && this . status < 300 ; }
public static CredentialsProvider getDefault ( ) { return defaultProvider ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof LexerPushModeAction ) ) { return false ; } return mode == ( ( LexerPushModeAction ) obj ) . mode ; }
public void dumpDFA ( ) { synchronized ( _interp . decisionToDFA ) { boolean seenOne = false ; for ( int d = 0 ; d < _interp . decisionToDFA . length ; d ++ ) { DFA dfa = _interp . decisionToDFA [ d ] ; if ( ! dfa . states . isEmpty ( ) ) { if ( seenOne ) System . out . println ( ) ; System . out . println ( " Decision ▁ " + dfa . decision + " : " ) ; System . out . print ( dfa . toString ( getVocabulary ( ) ) ) ; seenOne = true ; } } } }
public FloatBuffer put ( int index , float c ) { throw new ReadOnlyBufferException ( ) ; }
public CancelClusterResult cancelCluster ( CancelClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelCluster ( request ) ; }
public DeleteSnapshotResult deleteSnapshot ( DeleteSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSnapshot ( request ) ; }
public DeletePhoneNumberResult deletePhoneNumber ( DeletePhoneNumberRequest request ) { request = beforeClientExecution ( request ) ; return executeDeletePhoneNumber ( request ) ; }
public boolean addPushURI ( URIish toAdd ) { if ( pushURIs . contains ( toAdd ) ) return false ; return pushURIs . add ( toAdd ) ; }
public BytesRef next ( ) throws IOException { boolean success = false ; try { scratch = reader . next ( ) ; if ( scratch == null ) { reader . close ( ) ; } success = true ; return scratch ; } finally { if ( ! success ) { IOUtils . closeWhileHandlingException ( reader ) ; } } }
public void removeCreateDateTime ( ) { remove1stProperty ( PropertyIDMap . PID_CREATE_DTM ) ; }
public CreateHealthCheckResult createHealthCheck ( CreateHealthCheckRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateHealthCheck ( request ) ; }
public EnableVgwRoutePropagationResult enableVgwRoutePropagation ( EnableVgwRoutePropagationRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableVgwRoutePropagation ( request ) ; }
public void removeByteCount ( ) { remove1stProperty ( PropertyIDMap . PID_BYTECOUNT ) ; }
public UpdateAutoScalingGroupResult updateAutoScalingGroup ( UpdateAutoScalingGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateAutoScalingGroup ( request ) ; }
public CreateNotebookInstanceResult createNotebookInstance ( CreateNotebookInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNotebookInstance ( request ) ; }
public AllocateAddressResult allocateAddress ( ) { return allocateAddress ( new AllocateAddressRequest ( ) ) ; }
public CreateMLModelResult createMLModel ( CreateMLModelRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateMLModel ( request ) ; }
public ContinueRecord ( byte [ ] data ) { _data = data . clone ( ) ; }
public Parser getParser ( ) { return parser ; }
public DeleteSolutionResult deleteSolution ( DeleteSolutionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSolution ( request ) ; }
public boolean isDelete ( ) { return ObjectId . zeroId ( ) . equals ( newObjectId ) ; }
public int getNextPos ( ) { return nextPos ; }
public DescribeSpotFleetInstancesResult describeSpotFleetInstances ( DescribeSpotFleetInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSpotFleetInstances ( request ) ; }
public ResetPasswordResult resetPassword ( ResetPasswordRequest request ) { request = beforeClientExecution ( request ) ; return executeResetPassword ( request ) ; }
public String toString ( ) { return " DrawingRecord [ " + recordData . length + " ] " ; }
public Status call ( ) throws GitAPIException , NoWorkTreeException { if ( workingTreeIt == null ) workingTreeIt = new FileTreeIterator ( repo ) ; try { IndexDiff diff = new IndexDiff ( repo , Constants . HEAD , workingTreeIt ) ; if ( ignoreSubmoduleMode != null ) diff . setIgnoreSubmoduleMode ( ignoreSubmoduleMode ) ; if ( paths != null ) diff . setFilter ( PathFilterGroup . createFromStrings ( paths ) ) ; if ( progressMonitor == null ) diff . diff ( ) ; elsediff . diff ( progressMonitor , ProgressMonitor . UNKNOWN , ProgressMonitor . UNKNOWN , " " ) ; return new Status ( diff ) ; } catch ( IOException e ) { throw new JGitInternalException ( e . getMessage ( ) , e ) ; } }
public PathHierarchyTokenizerFactory ( Map < String , String > args ) { super ( args ) ; delimiter = getChar ( args , " delimiter " , PathHierarchyTokenizer . DEFAULT_DELIMITER ) ; replacement = getChar ( args , " replace " , delimiter ) ; reverse = getBoolean ( args , " reverse " , false ) ; skip = getInt ( args , " skip " , PathHierarchyTokenizer . DEFAULT_SKIP ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public String toString ( ) { return super . toString ( ) + " : ▁ " + lockName ; }
public CreateFieldLevelEncryptionConfigResult createFieldLevelEncryptionConfig ( CreateFieldLevelEncryptionConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFieldLevelEncryptionConfig ( request ) ; }
public Reader reader ( ) { return reader ; }
public DeleteHealthCheckResult deleteHealthCheck ( DeleteHealthCheckRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteHealthCheck ( request ) ; }
public long get ( ) { return count ; }
public int setArrayData ( byte [ ] data , int offset ) { if ( emptyComplexPart ) { resizeComplexData ( 0 ) ; } else { short numElements = LittleEndian . getShort ( data , offset ) ; short sizeOfElements = LittleEndian . getShort ( data , offset + 4 ) ; int cdLen = getComplexData ( ) . length ; int arraySize = getActualSizeOfElements ( sizeOfElements ) * numElements ; if ( arraySize == cdLen ) { resizeComplexData ( arraySize + 6 , 0 ) ; sizeIncludesHeaderSize = false ; } setComplexData ( data , offset ) ; } return getComplexData ( ) . length ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { TwoDEval reference = convertFirstArg ( arg0 ) ; int columnIx = 0 ; try { int rowIx = resolveIndexArg ( arg1 , srcRowIndex , srcColumnIndex ) ; if ( ! reference . isColumn ( ) ) { if ( ! reference . isRow ( ) ) { return ErrorEval . REF_INVALID ; } columnIx = rowIx ; rowIx = 0 ; } return getValueFromArea ( reference , rowIx , columnIx ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public boolean seekExact ( BytesRef term ) throws IOException { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) + " ▁ does ▁ not ▁ support ▁ seeking " ) ; }
public GetSmsTemplateResult getSmsTemplate ( GetSmsTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSmsTemplate ( request ) ; }
public String getFieldAsString ( ) { if ( this . field == null ) return null ; else return this . field . toString ( ) ; }
@ Override public int read ( byte [ ] buffer , int byteOffset , int byteCount ) throws IOException { return IoBridge . read ( fd , buffer , byteOffset , byteCount ) ; }
public HSSFHyperlink createHyperlink ( HyperlinkType type ) { return new HSSFHyperlink ( type ) ; }
public UpdateGlobalSettingsResult updateGlobalSettings ( UpdateGlobalSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateGlobalSettings ( request ) ; }
public static String segmentFileName ( String segmentName , String segmentSuffix , String ext ) { if ( ext . length ( ) > 0 || segmentSuffix . length ( ) > 0 ) { assert ! ext . startsWith ( " . " ) ; StringBuilder sb = new StringBuilder ( segmentName . length ( ) + 2 + segmentSuffix . length ( ) + ext . length ( ) ) ; sb . append ( segmentName ) ; if ( segmentSuffix . length ( ) > 0 ) { sb . append ( ' □ ' ) . append ( segmentSuffix ) ; } if ( ext . length ( ) > 0 ) { sb . append ( ' . ' ) . append ( ext ) ; } return sb . toString ( ) ; } else { return segmentName ; } }
public static JGitText get ( ) { return NLS . getBundleFor ( JGitText . class ) ; }
public void insert ( String key , char val ) { int len = key . length ( ) + 1 ; if ( freenode + len > eq . length ) { redimNodeArrays ( eq . length + BLOCK_SIZE ) ; } char strkey [ ] = new char [ len -- ] ; key . getChars ( 0 , len , strkey , 0 ) ; strkey [ len ] = 0 ; root = insert ( root , strkey , 0 , val ) ; }
public NameRecord createBuiltInName ( byte builtInName , int sheetNumber ) { if ( sheetNumber < 0 || sheetNumber + 1 > Short . MAX_VALUE ) { throw new IllegalArgumentException ( " Sheet ▁ number ▁ [ " + sheetNumber + " ] is ▁ not ▁ valid ▁ " ) ; } NameRecord name = new NameRecord ( builtInName , sheetNumber ) ; if ( linkTable . nameAlreadyExists ( name ) ) { throw new RuntimeException ( " Builtin ▁ ( " + builtInName + " ) ▁ already ▁ exists ▁ for ▁ sheet ▁ ( " + sheetNumber + " ) " ) ; } addName ( name ) ; return name ; }
public static int compareArray ( char [ ] larray , int lstartIndex , char [ ] rarray , int rstartIndex ) { if ( larray == null ) { if ( rarray == null || rstartIndex >= rarray . length ) return 0 ; else return - 1 ; } else { if ( rarray == null ) { if ( lstartIndex >= larray . length ) return 0 ; else return 1 ; } } int li = lstartIndex , ri = rstartIndex ; while ( li < larray . length && ri < rarray . length && larray [ li ] == rarray [ ri ] ) { li ++ ; ri ++ ; } if ( li == larray . length ) { if ( ri == rarray . length ) { return 0 ; } else { return - 1 ; } } else { if ( ri == rarray . length ) { return 1 ; } else { if ( larray [ li ] > rarray [ ri ] ) return 1 ; else return - 1 ; } } }
public GetVoiceConnectorResult getVoiceConnector ( GetVoiceConnectorRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVoiceConnector ( request ) ; }
public void setValueAt ( int relativeOffset , int value ) { int oldValue = _values [ relativeOffset ] ; _values [ relativeOffset ] = value ; if ( value == POIFSConstants . UNUSED_BLOCK ) { _has_free_sectors = true ; return ; } if ( oldValue == POIFSConstants . UNUSED_BLOCK ) { recomputeFree ( ) ; } }
public static boolean isBinary ( byte [ ] raw ) { return isBinary ( raw , raw . length ) ; }
public void build ( InputIterator iterator ) throws IOException { if ( iterator . hasPayloads ( ) ) { throw new IllegalArgumentException ( " this ▁ suggester ▁ doesn ' t support payloads " ) ; } if ▁ ( iterator . hasContexts ( ) ) ▁ { throw ▁ new ▁ IllegalArgumentException ( " this suggester doesn ' t ▁ support ▁ contexts " ) ; } count = 0 ; trie = new JaspellTernarySearchTrie ( ) ; trie . setMatchAlmostDiff ( editDistance ) ; BytesRef spare ; final CharsRefBuilder charsSpare = new CharsRefBuilder ( ) ; while ( ( spare = iterator . next ( ) ) != null ) { final long weight = iterator . weight ( ) ; if ( spare . length == 0 ) { continue ; } charsSpare . copyUTF8Bytes ( spare ) ; trie . put ( charsSpare . toString ( ) , Long . valueOf ( weight ) ) ; count ++ ; } }
public boolean isVerticalBorder ( ) { return verticalBorder . isSet ( field_1_options ) ; }
public CreateDBInstanceRequest ( String dBInstanceIdentifier , Integer allocatedStorage , String dBInstanceClass , String engine , String masterUsername , String masterUserPassword ) { setDBInstanceIdentifier ( dBInstanceIdentifier ) ; setAllocatedStorage ( allocatedStorage ) ; setDBInstanceClass ( dBInstanceClass ) ; setEngine ( engine ) ; setMasterUsername ( masterUsername ) ; setMasterUserPassword ( masterUserPassword ) ; }
public DescribeCapacityProvidersResult describeCapacityProviders ( DescribeCapacityProvidersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCapacityProviders ( request ) ; }
public CreateQualificationTypeResult createQualificationType ( CreateQualificationTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateQualificationType ( request ) ; }
public void addLast ( E object ) { addLastImpl ( object ) ; }
public Patch ( ) { files = new ArrayList <> ( ) ; errors = new ArrayList <> ( 0 ) ; }
public GetSdkTypesResult getSdkTypes ( GetSdkTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSdkTypes ( request ) ; }
public String toFormulaString ( ) { throw new RuntimeException ( " 3D ▁ references ▁ need ▁ a ▁ workbook ▁ to ▁ determine ▁ formula ▁ text " ) ; }
public ListPhotoFacesRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListPhotoFaces " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public boolean isBatchMode ( ) { return batchMode != null && batchMode . booleanValue ( ) ; }
@ Override public boolean isEmpty ( ) { return endpoint ( true ) == null ; }
@ Override public Set < Entry < K , V >> entrySet ( ) { BoundedEntrySet result = entrySet ; return result != null ? result : ( entrySet = new BoundedEntrySet ( ) ) ; }
public static CFRuleRecord create ( HSSFSheet sheet , String formulaText ) { Ptg [ ] formula1 = parseFormula ( formulaText , sheet ) ; return new CFRuleRecord ( CONDITION_TYPE_FORMULA , ComparisonOperator . NO_COMPARISON , formula1 , null ) ; }
public DeleteAlbumsRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " DeleteAlbums " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public MissingFormatArgumentException ( String s ) { if ( s == null ) { throw new NullPointerException ( ) ; } this . s = s ; }
public DeleteApplicationOutputResult deleteApplicationOutput ( DeleteApplicationOutputRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApplicationOutput ( request ) ; }
public PredictionContextCache getSharedContextCache ( ) { return sharedContextCache ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . append ( getClass ( ) . getName ( ) ) . append ( " ▁ [ " ) ; sb . append ( getText ( ) ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public DecisionState getDecisionState ( int decision ) { if ( ! decisionToState . isEmpty ( ) ) { return decisionToState . get ( decision ) ; } return null ; }
public void removeSheet ( int sheetIdx ) { _externSheetRecord . removeSheet ( sheetIdx ) ; }
public HSSFRequest ( ) { _records = new HashMap <> ( 50 ) ; }
final public QueryNode TopLevelQuery ( CharSequence field ) throws ParseException { QueryNode q ; q = Query ( field ) ; jj_consume_token ( 0 ) ; { if ( true ) return q ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public DescribeUpdateResult describeUpdate ( DescribeUpdateRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeUpdate ( request ) ; }
public boolean getValue ( ) { return value ; }
public final int getType ( ) { return ( flags >> TYPE_SHIFT ) & 0x7 ; }
public DoubleBuffer put ( double c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } byteBuffer . putDouble ( position ++ * SizeOf . DOUBLE , c ) ; return this ; }
public void endEvaluate ( CellCacheEntry cce ) { int nFrames = _evaluationFrames . size ( ) ; if ( nFrames < 1 ) { throw new IllegalStateException ( " Call ▁ to ▁ endEvaluate ▁ without ▁ matching ▁ call ▁ to ▁ startEvaluate " ) ; } nFrames -- ; CellEvaluationFrame frame = _evaluationFrames . get ( nFrames ) ; if ( cce != frame . getCCE ( ) ) { throw new IllegalStateException ( " Wrong ▁ cell ▁ specified . ▁ " ) ; } _evaluationFrames . remove ( nFrames ) ; _currentlyEvaluatingCells . remove ( cce ) ; }
public NumberPtg ( double value ) { field_1_value = value ; }
public GroupingSearch setGroupSort ( Sort groupSort ) { this . groupSort = groupSort ; return this ; }
public HSSFBorderFormatting createBorderFormatting ( ) { return getBorderFormatting ( true ) ; }
public HSSFSimpleShape createShape ( HSSFChildAnchor anchor ) { HSSFSimpleShape shape = new HSSFSimpleShape ( this , anchor ) ; shape . setParent ( this ) ; shape . setAnchor ( anchor ) ; shapes . add ( shape ) ; onCreate ( shape ) ; EscherSpRecord sp = shape . getEscherContainer ( ) . getChildById ( EscherSpRecord . RECORD_ID ) ; if ( shape . getAnchor ( ) . isHorizontallyFlipped ( ) ) { sp . setFlags ( sp . getFlags ( ) | EscherSpRecord . FLAG_FLIPHORIZ ) ; } if ( shape . getAnchor ( ) . isVerticallyFlipped ( ) ) { sp . setFlags ( sp . getFlags ( ) | EscherSpRecord . FLAG_FLIPVERT ) ; } return shape ; }
public GetLifecyclePolicyResult getLifecyclePolicy ( GetLifecyclePolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLifecyclePolicy ( request ) ; }
public Integer integerValue ( String key ) { String value = responseMap . get ( key ) ; if ( null == value || 0 == value . length ( ) ) { return null ; } return Integer . valueOf ( value ) ; }
public int size ( ) { return backingMap . size ( ) ; }
public Map . Entry < K , V > next ( ) { if ( ! valueIterator . hasNext ( ) ) { findValueIteratorAndKey ( ) ; } return Maps . immutableEntry ( key , valueIterator . next ( ) ) ; }
public boolean shouldBeRecursive ( ) { return a . shouldBeRecursive ( ) ; }
public GetRepoAuthorizationListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoAuthorizationList " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / authorizations " ) ; setMethod ( MethodType . GET ) ; }
public int checkExternSheet ( int sheetIndex ) { return checkExternSheet ( sheetIndex , sheetIndex ) ; }
public LexerATNConfig ( LexerATNConfig c , ATNState state ) { super ( c , state , c . context , c . semanticContext ) ; this . lexerActionExecutor = c . lexerActionExecutor ; this . passedThroughNonGreedyDecision = checkNonGreedyDecision ( c , state ) ; }
public QueryNodeProcessor set ( int index , QueryNodeProcessor processor ) { QueryNodeProcessor oldProcessor = this . processors . set ( index , processor ) ; if ( oldProcessor != processor ) { processor . setQueryConfigHandler ( this . queryConfig ) ; } return oldProcessor ; }
public String getRuleName ( int index ) { if ( parser != null && index >= 0 ) return parser . getRuleNames ( ) [ index ] ; return " < rule ▁ " + index + " > " ; }
public ByteBuffer compact ( ) { System . arraycopy ( backingArray , position + offset , backingArray , offset , remaining ( ) ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public DirCache call ( ) throws GitAPIException , NoFilepatternException { if ( filepatterns . isEmpty ( ) ) throw new NoFilepatternException ( JGitText . get ( ) . atLeastOnePatternIsRequired ) ; checkCallable ( ) ; DirCache dc = null ; List < String > actuallyDeletedFiles = new ArrayList <> ( ) ; try ( TreeWalk tw = new TreeWalk ( repo ) ) { dc = repo . lockDirCache ( ) ; DirCacheBuilder builder = dc . builder ( ) ; tw . reset ( ) ; tw . setRecursive ( true ) ; tw . setFilter ( PathFilterGroup . createFromStrings ( filepatterns ) ) ; tw . addTree ( new DirCacheBuildIterator ( builder ) ) ; while ( tw . next ( ) ) { if ( ! cached ) { final FileMode mode = tw . getFileMode ( 0 ) ; if ( mode . getObjectType ( ) == Constants . OBJ_BLOB ) { String relativePath = tw . getPathString ( ) ; final File path = new File ( repo . getWorkTree ( ) , relativePath ) ; if ( delete ( path ) ) { actuallyDeletedFiles . add ( relativePath ) ; } } } } builder . commit ( ) ; setCallable ( false ) ; } catch ( IOException e ) { throw new JGitInternalException ( JGitText . get ( ) . exceptionCaughtDuringExecutionOfRmCommand , e ) ; } finally { try { if ( dc != null ) { dc . unlock ( ) ; } } finally { if ( ! actuallyDeletedFiles . isEmpty ( ) ) { repo . fireEvent ( new WorkingTreeModifiedEvent ( null , actuallyDeletedFiles ) ) ; } } } return dc ; }
public DeleteGatewayResponseResult deleteGatewayResponse ( DeleteGatewayResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteGatewayResponse ( request ) ; }
public TokenStream create ( TokenStream input ) { return new NorwegianLightStemFilter ( input , flags ) ; }
public GetUserSourceRepoListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetUserSourceRepoList " , " cr " ) ; setUriPattern ( " / users / sourceAccount / [ SourceAccountId ] / repos " ) ; setMethod ( MethodType . GET ) ; }
public DescribeEventBusResult describeEventBus ( DescribeEventBusRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEventBus ( request ) ; }
public DefaultAcsClient ( IClientProfile profile , AlibabaCloudCredentialsProvider credentialsProvider ) { this . clientProfile = profile ; this . credentialsProvider = credentialsProvider ; this . clientProfile . setCredentialsProvider ( this . credentialsProvider ) ; this . httpClient = HttpClientFactory . buildClient ( this . clientProfile ) ; this . endpointResolver = new DefaultEndpointResolver ( this , profile ) ; this . appendUserAgent ( " HTTPClient " , this . httpClient . getClass ( ) . getSimpleName ( ) ) ; }
public String toString ( ) { StringBuilder result = new StringBuilder ( limit - position ) ; for ( int i = position ; i < limit ; i ++ ) { result . append ( get ( i ) ) ; } return result . toString ( ) ; }
public final byte [ ] replacement ( ) { return replacementBytes ; }
public SeriesToChartGroupRecord clone ( ) { return copy ( ) ; }
public AttributeValue ( java . util . List < String > sS ) { setSS ( sS ) ; }
public HSSFComment ( EscherContainerRecord spContainer , ObjRecord objRecord , TextObjectRecord textObjectRecord , NoteRecord note ) { super ( spContainer , objRecord , textObjectRecord ) ; _note = note ; }
public FilteredDocIdSetIterator ( DocIdSetIterator innerIter ) { if ( innerIter == null ) { throw new IllegalArgumentException ( " null ▁ iterator " ) ; } _innerIter = innerIter ; doc = - 1 ; }
public DeleteDBClusterParameterGroupResult deleteDBClusterParameterGroup ( DeleteDBClusterParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDBClusterParameterGroup ( request ) ; }
public LongsRef next ( int count ) throws IOException { assert nextValues . length >= 0 ; assert count > 0 ; assert nextValues . offset + nextValues . length <= nextValues . longs . length ; nextValues . offset += nextValues . length ; final int remaining = valueCount - position - 1 ; if ( remaining <= 0 ) { throw new EOFException ( ) ; } count = Math . min ( remaining , count ) ; if ( nextValues . offset == nextValues . longs . length ) { final long remainingBlocks = format . byteCount ( packedIntsVersion , remaining , bitsPerValue ) ; final int blocksToRead = ( int ) Math . min ( remainingBlocks , nextBlocks . length ) ; in . readBytes ( nextBlocks , 0 , blocksToRead ) ; if ( blocksToRead < nextBlocks . length ) { Arrays . fill ( nextBlocks , blocksToRead , nextBlocks . length , ( byte ) 0 ) ; } bulkOperation . decode ( nextBlocks , 0 , nextValues . longs , 0 , iterations ) ; nextValues . offset = 0 ; } nextValues . length = Math . min ( nextValues . longs . length - nextValues . offset , count ) ; position += nextValues . length ; return nextValues ; }
public UpdateServiceAccessPoliciesResult updateServiceAccessPolicies ( UpdateServiceAccessPoliciesRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateServiceAccessPolicies ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( sid ) ; out . writeShort ( ENCODED_SIZE ) ; }
public GetApplicationSettingsResult getApplicationSettings ( GetApplicationSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApplicationSettings ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getCodepage ( ) ) ; }
public SharedFormulaRecord ( RecordInputStream in ) { super ( in ) ; field_5_reserved = in . readShort ( ) ; int field_6_expression_len = in . readShort ( ) ; int nAvailableBytes = in . available ( ) ; field_7_parsed_expr = Formula . read ( field_6_expression_len , in , nAvailableBytes ) ; }
public void remove ( ) { if ( this . lastPosition == - 1 ) { throw new IllegalStateException ( ) ; } if ( expectedModCount != modCount ) { throw new ConcurrentModificationException ( ) ; } try { AbstractList . this . remove ( lastPosition ) ; } catch ( IndexOutOfBoundsException e ) { throw new ConcurrentModificationException ( ) ; } expectedModCount = modCount ; if ( pos == lastPosition ) { pos -- ; } lastPosition = - 1 ; }
public int getRef ( Character way ) { Cell c = at ( way ) ; return ( c == null ) ? - 1 : c . ref ; }
public K ceilingKey ( K key ) { Entry < K , V > entry = findBounded ( key , CEILING ) ; return entry != null ? entry . getKey ( ) : null ; }
public CreateApplicationRequest ( String applicationName ) { setApplicationName ( applicationName ) ; }
public int pathCompare ( byte [ ] buf , int pos , int end , int pathMode ) { return pathCompare ( buf , pos , end , pathMode , 0 ) ; }
public DescribeContainerInstancesResult describeContainerInstances ( DescribeContainerInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeContainerInstances ( request ) ; }
public void serialize ( LittleEndianOutput out ) { for ( short tabid : _tabids ) { out . writeShort ( tabid ) ; } }
public ListIAMPolicyAssignmentsForUserResult listIAMPolicyAssignmentsForUser ( ListIAMPolicyAssignmentsForUserRequest request ) { request = beforeClientExecution ( request ) ; return executeListIAMPolicyAssignmentsForUser ( request ) ; }
public boolean equals ( Object obj ) { if ( obj instanceof Map . Entry ) { final Object key = ( ( Map . Entry ) obj ) . getKey ( ) ; final Object val = ( ( Map . Entry ) obj ) . getValue ( ) ; if ( key instanceof String && val instanceof Ref ) { final Ref r = ( Ref ) val ; if ( r . getName ( ) . equals ( ref . getName ( ) ) ) { final ObjectId a = r . getObjectId ( ) ; final ObjectId b = ref . getObjectId ( ) ; if ( a != null && b != null && AnyObjectId . isEqual ( a , b ) ) { return true ; } } } } return false ; }
public RemoveFacetFromObjectResult removeFacetFromObject ( RemoveFacetFromObjectRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveFacetFromObject ( request ) ; }
public static boolean equals ( char [ ] array1 , char [ ] array2 ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1. length != array2. length ) { return false ; } for ( int i = 0 ; i < array1. length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) { return false ; } } return true ; }
public AssociateRouteTableResult associateRouteTable ( AssociateRouteTableRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateRouteTable ( request ) ; }
public void createInformationProperties ( ) { if ( ! initialized ) { readProperties ( ) ; } if ( sInf == null ) { sInf = PropertySetFactory . newSummaryInformation ( ) ; } if ( dsInf == null ) { dsInf = newDocumentSummaryInformation ( ) ; } }
public DescribeCommentsResult describeComments ( DescribeCommentsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeComments ( request ) ; }
public MoPenCreateDeviceRequest ( ) { super ( " MoPen " , " 2018 - 02 - 11 " , " MoPenCreateDevice " , " mopen " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public ApplySchemaResult applySchema ( ApplySchemaRequest request ) { request = beforeClientExecution ( request ) ; return executeApplySchema ( request ) ; }
public MMSRecord ( RecordInputStream in ) { if ( in . remaining ( ) == 0 ) { return ; } field_1_addMenuCount = in . readByte ( ) ; field_2_delMenuCount = in . readByte ( ) ; }
public UserInputQueryBuilder ( QueryParser parser ) { this . unSafeParser = parser ; }
public Object get ( CharSequence key ) { TSTNode node = getNode ( key ) ; if ( node == null ) { return null ; } return node . data ; }
public MergedGroup ( T groupValue ) { this . groupValue = groupValue ; }
public StoredField ( String name , int value ) { super ( name , TYPE ) ; fieldsData = value ; }
public RebaseCommand setProgressMonitor ( ProgressMonitor monitor ) { if ( monitor == null ) { monitor = NullProgressMonitor . INSTANCE ; } this . monitor = monitor ; return this ; }
public UnknownSubRecord clone ( ) { return copy ( ) ; }
public Query getQuery ( Element e ) throws ParserException { String fieldName = DOMUtils . getAttributeWithInheritanceOrFail ( e , " fieldName " ) ; String text = DOMUtils . getNonBlankTextOrFail ( e ) ; BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . setMinimumNumberShouldMatch ( DOMUtils . getAttribute ( e , " minimumNumberShouldMatch " , 0 ) ) ; try ( TokenStream ts = analyzer . tokenStream ( fieldName , text ) ) { TermToBytesRefAttribute termAtt = ts . addAttribute ( TermToBytesRefAttribute . class ) ; Term term = null ; ts . reset ( ) ; while ( ts . incrementToken ( ) ) { term = new Term ( fieldName , BytesRef . deepCopyOf ( termAtt . getBytesRef ( ) ) ) ; bq . add ( new BooleanClause ( new TermQuery ( term ) , BooleanClause . Occur . SHOULD ) ) ; } ts . end ( ) ; } catch ( IOException ioe ) { throw new RuntimeException ( " Error ▁ constructing ▁ terms ▁ from ▁ index : " + ioe ) ; } Query q = bq . build ( ) ; float boost = DOMUtils . getAttribute ( e , " boost " , 1.0f ) ; return new BoostQuery ( q , boost ) ; }
public UpdateMailboxQuotaResult updateMailboxQuota ( UpdateMailboxQuotaRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateMailboxQuota ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( 40 * ( path . length ( ) + 1 ) ) ; for ( int j = 0 ; j < path . length ( ) ; j ++ ) { buffer . append ( path . getComponent ( j ) ) . append ( " / " ) ; } buffer . append ( name ) ; return buffer . toString ( ) ; }
public void removeApplicationName ( ) { remove1stProperty ( PropertyIDMap . PID_APPNAME ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( " ▁ [ " ) ; if ( externalWorkbookNumber >= 0 ) { sb . append ( " ▁ [ " ) ; sb . append ( " workbook = " ) . append ( getExternalWorkbookNumber ( ) ) ; sb . append ( " ] ▁ " ) ; } sb . append ( " sheet = " ) . append ( getSheetName ( ) ) ; sb . append ( " ▁ ! ▁ " ) ; sb . append ( " name = " ) ; sb . append ( nameName ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public GetRecommenderConfigurationResult getRecommenderConfiguration ( GetRecommenderConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRecommenderConfiguration ( request ) ; }
public int previous ( ) { if ( text . getIndex ( ) == text . getBeginIndex ( ) ) { return DONE ; } else { if ( 0 == sentenceStarts . length ) { text . setIndex ( text . getBeginIndex ( ) ) ; return DONE ; } if ( text . getIndex ( ) == text . getEndIndex ( ) ) { text . setIndex ( sentenceStarts [ currentSentence ] ) ; } else { text . setIndex ( sentenceStarts [ -- currentSentence ] ) ; } return current ( ) ; } }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ STARTOBJECT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rt ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( rt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbitFrt ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( grbitFrt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . iObjectKind ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( iObjectKind ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . iObjectContext ▁ ▁ = " ) . append ( HexDump . shortToHex ( iObjectContext ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . iObjectInstance1 = " ) . append ( HexDump . shortToHex ( iObjectInstance1 ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . iObjectInstance2 = " ) . append ( HexDump . shortToHex ( iObjectInstance2 ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / STARTOBJECT ] \ n " ) ; return buffer . toString ( ) ; }
public static double average ( double [ ] values ) { double ave = 0 ; double sum = 0 ; for ( double value : values ) { sum += value ; } ave = sum / values . length ; return ave ; }
public GetCheckerIpRangesResult getCheckerIpRanges ( GetCheckerIpRangesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCheckerIpRanges ( request ) ; }
public int getRegionLength ( ) { return outRegion . length ; }
@ Override public Iterator < Multiset . Entry < E >> iterator ( ) { final Iterator < Map . Entry < E , Integer >> backingIterator = countMap . entrySet ( ) . iterator ( ) ; return new Iterator < Multiset . Entry < E >> ( ) ; }
public WeightedSpanTerm ( float weight , String term , boolean positionSensitive ) { super ( weight , term ) ; this . positionSensitive = positionSensitive ; }
public synchronized StringBuffer append ( char [ ] chars ) { append0 ( chars ) ; return this ; }
public UploadServerCertificateRequest ( String serverCertificateName , String certificateBody , String privateKey ) { setServerCertificateName ( serverCertificateName ) ; setCertificateBody ( certificateBody ) ; setPrivateKey ( privateKey ) ; }
public List < String > getRuleInvocationStack ( RuleContext p ) { String [ ] ruleNames = getRuleNames ( ) ; List < String > stack = new ArrayList < String > ( ) ; while ( p != null ) { int ruleIndex = p . getRuleIndex ( ) ; if ( ruleIndex < 0 ) stack . add ( " n / a " ) ; else stack . add ( ruleNames [ ruleIndex ] ) ; p = p . parent ; } return stack ; }
static public double ipmt ( double r , int per , int nper , double pv , double fv ) { return ipmt ( r , per , nper , pv , fv , 0 ) ; }
public int countRanges ( ) { return _list . size ( ) ; }
public int compareTo ( FormatRun r ) { if ( _character == r . _character && _fontIndex == r . _fontIndex ) { return 0 ; } if ( _character == r . _character ) { return _fontIndex - r . _fontIndex ; } return _character - r . _character ; }
public final void readFully ( byte [ ] dst ) throws IOException { readFully ( dst , 0 , dst . length ) ; }
public synchronized int size ( ) { return size ; }
public String group ( ) { return group ( 0 ) ; }
public int getExternalSheetIndex ( String workbookName , String firstSheetName , String lastSheetName ) { return getOrCreateLinkTable ( ) . getExternalSheetIndex ( workbookName , firstSheetName , lastSheetName ) ; }
public GetDeliverabilityTestReportResult getDeliverabilityTestReport ( GetDeliverabilityTestReportRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDeliverabilityTestReport ( request ) ; }
public boolean isPeeled ( ) { return getLeaf ( ) . isPeeled ( ) ; }
public RenameCallback getRenameCallback ( ) { return renameCallback ; }
public String toString ( ) { return " EditList " + super . toString ( ) ; }
public PutVoiceConnectorTerminationCredentialsResult putVoiceConnectorTerminationCredentials ( PutVoiceConnectorTerminationCredentialsRequest request ) { request = beforeClientExecution ( request ) ; return executePutVoiceConnectorTerminationCredentials ( request ) ; }
public CreateGroupResult createGroup ( CreateGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateGroup ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_units ) ; }
public ObjectLoader open ( AnyObjectId objectId , int typeHint ) throws MissingObjectException , IncorrectObjectTypeException , IOException { final ObjectLoader ldr = db . openObject ( this , objectId ) ; if ( ldr == null ) { if ( typeHint == OBJ_ANY ) throw new MissingObjectException ( objectId . copy ( ) , JGitText . get ( ) . unknownObjectType2 ) ; throw new MissingObjectException ( objectId . copy ( ) , typeHint ) ; } if ( typeHint != OBJ_ANY && ldr . getType ( ) != typeHint ) throw new IncorrectObjectTypeException ( objectId . copy ( ) , typeHint ) ; return ldr ; }
public ParameterNameValue ( String parameterName , String parameterValue ) { setParameterName ( parameterName ) ; setParameterValue ( parameterValue ) ; }
public AssociateIamInstanceProfileResult associateIamInstanceProfile ( AssociateIamInstanceProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateIamInstanceProfile ( request ) ; }
public CreateHostedZoneRequest ( String name , String callerReference ) { setName ( name ) ; setCallerReference ( callerReference ) ; }
public String getPronunciation ( ) { return dictionary . getPronunciation ( wordId , surfaceForm , offset , length ) ; }
public boolean knows ( String key ) { return ( find ( key ) >= 0 ) ; }
public ServerException ( String errorCode , String errorMessage ) { super ( errorCode , errorMessage ) ; this . setErrorType ( ErrorType . Server ) ; }
public String toString ( ) { return " 3 ( " + mu + " ) " ; }
public CreateDiskResult createDisk ( CreateDiskRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDisk ( request ) ; }
public boolean add ( char [ ] text ) { return map . put ( text , PLACEHOLDER ) == null ; }
public QueryLicensesRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " QueryLicenses " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public ExpectedAttributeValue ( AttributeValue value ) { setValue ( value ) ; }
public long getSize ( ) { return getCachedBytes ( ) . length ; }
public DescribeImageAttributeRequest ( String imageId , ImageAttributeName attribute ) { setImageId ( imageId ) ; setAttribute ( attribute . toString ( ) ) ; }
public HSSFAnchor ( ) { createEscherAnchor ( ) ; }
public V setValue ( V object ) { V result = value ; value = object ; return result ; }
public void readFully ( byte [ ] buffer , int off , int len ) { checkPosition ( len ) ; read ( buffer , off , len ) ; }
public CancelDomainTransferToAnotherAwsAccountResult cancelDomainTransferToAnotherAwsAccount ( CancelDomainTransferToAnotherAwsAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelDomainTransferToAnotherAwsAccount ( request ) ; }
public RecognizeCelebritiesResult recognizeCelebrities ( RecognizeCelebritiesRequest request ) { request = beforeClientExecution ( request ) ; return executeRecognizeCelebrities ( request ) ; }
public SideBandOutputStream ( int chan , int sz , OutputStream os ) { if ( chan <= 0 || chan > 255 ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . channelMustBeInRange1_255 , Integer . valueOf ( chan ) ) ) ; if ( sz <= HDR_SIZE ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . packetSizeMustBeAtLeast , Integer . valueOf ( sz ) , Integer . valueOf ( HDR_SIZE ) ) ) ; else if ( MAX_BUF < sz ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . packetSizeMustBeAtMost , Integer . valueOf ( sz ) , Integer . valueOf ( MAX_BUF ) ) ) ; out = os ; buffer = new byte [ sz ] ; buffer [ 4 ] = ( byte ) chan ; cnt = HDR_SIZE ; }
public LexerATNConfig ( ATNState state , int alt , PredictionContext context , LexerActionExecutor lexerActionExecutor ) { super ( state , alt , context , SemanticContext . NONE ) ; this . lexerActionExecutor = lexerActionExecutor ; this . passedThroughNonGreedyDecision = false ; }
public String format ( List < RevCommit > squashedCommits , Ref target ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " Squashed ▁ commit ▁ of ▁ the ▁ following :\ n " ) ; for ( RevCommit c : squashedCommits ) { sb . append ( " \ ncommit ▁ " ) ; sb . append ( c . getName ( ) ) ; sb . append ( " \ n " ) ; sb . append ( toString ( c . getAuthorIdent ( ) ) ) ; sb . append ( " \ n \ t " ) ; sb . append ( c . getShortMessage ( ) ) ; sb . append ( " \ n " ) ; } return sb . toString ( ) ; }
public int stem ( char s [ ] , int len ) { if ( len < 3 || s [ len - 1 ] != ' s ' ) return len ; switch ( s [ len - 2 ] ) { case ' u ' : case ' s ' : return len ; case ' e ' : if ( len > 3 && s [ len - 3 ] == ' i ' && s [ len - 4 ] != ' a ' && s [ len - 4 ] != ' e ' ) { s [ len - 3 ] = ' y ' ; return len - 2 ; } if ( s [ len - 3 ] == ' i ' || s [ len - 3 ] == ' a ' || s [ len - 3 ] == ' o ' || s [ len - 3 ] == ' e ' ) return len ; default : return len - 1 ; } }
public TermsQueryBuilder ( Analyzer analyzer ) { this . analyzer = analyzer ; }
public CreateDomainRequest ( String domainName ) { setDomainName ( domainName ) ; }
public Trie optimize ( Trie orig ) { List < CharSequence > cmds = orig . cmds ; List < Row > rows = new ArrayList <> ( ) ; List < Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; for ( int j = orows . size ( ) - 1 ; j >= 0 ; j -- ) { Row now = new Remap ( orows . get ( j ) , remap ) ; boolean merged = false ; for ( int i = 0 ; i < rows . size ( ) ; i ++ ) { Row q = merge ( now , rows . get ( i ) ) ; if ( q != null ) { rows . set ( i , q ) ; merged = true ; remap [ j ] = i ; break ; } } if ( merged == false ) { remap [ j ] = rows . size ( ) ; rows . add ( now ) ; } } int root = remap [ orig . root ] ; Arrays . fill ( remap , - 1 ) ; rows = removeGaps ( root , rows , new ArrayList < Row > ( ) , remap ) ; return new Trie ( orig . forward , remap [ root ] , cmds , rows ) ; }
public final boolean isFirstCell ( int rowIx , int colIx ) { CellRangeAddress8Bit r = getRange ( ) ; return r . getFirstRow ( ) == rowIx && r . getFirstColumn ( ) == colIx ; }
public CompleteLayerUploadResult completeLayerUpload ( CompleteLayerUploadRequest request ) { request = beforeClientExecution ( request ) ; return executeCompleteLayerUpload ( request ) ; }
public StopHumanLoopResult stopHumanLoop ( StopHumanLoopRequest request ) { request = beforeClientExecution ( request ) ; return executeStopHumanLoop ( request ) ; }
public RevCommit getSourceCommit ( ) { return outCandidate . sourceCommit ; }
public synchronized Object getPerfObject ( String key ) { return perfObjects . get ( key ) ; }
public TokenStream create ( TokenStream input ) { return new HindiStemFilter ( input ) ; }
public static BreakIterator getWordInstance ( ) { return getWordInstance ( Locale . getDefault ( ) ) ; }
public UpdatePublicKeyResult updatePublicKey ( UpdatePublicKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdatePublicKey ( request ) ; }
public boolean include ( RevWalk walker , RevCommit c ) { return c . getParentCount ( ) < 2 ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ COUNTRY ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . defaultcountry ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getDefaultCountry ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . currentcountry ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getCurrentCountry ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / COUNTRY ] \ n " ) ; return buffer . toString ( ) ; }
public DefaultColWidthRecord clone ( ) { return copy ( ) ; }
public Matcher useAnchoringBounds ( boolean value ) { anchoringBounds = value ; useAnchoringBoundsImpl ( address , value ) ; return this ; }
public PostingsEnum reset ( int [ ] postings ) { this . postings = postings ; upto = - 2 ; return this ; }
public void SwitchTo ( int lexState ) { if ( lexState >= 2 || lexState < 0 ) throw new TokenMgrError ( " Error : ▁ Ignoring ▁ invalid ▁ lexical ▁ state ▁ : ▁ " + lexState + " . ▁ State ▁ unchanged . " , TokenMgrError . INVALID_LEXICAL_STATE ) ; elsecurLexState = lexState ; }
public boolean add ( final int value ) { if ( _limit == _array . length ) { growArray ( _limit * 2 ) ; } _array [ _limit ++ ] = value ; return true ; }
public final int computeIterations ( int valueCount , int ramBudget ) { final int iterations = ramBudget / ( byteBlockCount ( ) + 8 * byteValueCount ( ) ) ; if ( iterations == 0 ) { return 1 ; } else if ( ( iterations - 1 ) * byteValueCount ( ) >= valueCount ) { return ( int ) Math . ceil ( ( double ) valueCount / byteValueCount ( ) ) ; } else { return iterations ; } }
public NameRecord getNameRecord ( int nameIndex ) { return getWorkbook ( ) . getNameRecord ( nameIndex ) ; }
public DescribeJobResult describeJob ( DescribeJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeJob ( request ) ; }
public EscherPropertyMetaData ( String description , byte type ) { this . description = description ; this . type = type ; }
public HSSFColor findSimilarColor ( int red , int green , int blue ) { HSSFColor result = null ; int minColorDistance = Integer . MAX_VALUE ; byte [ ] b = _palette . getColor ( PaletteRecord . FIRST_COLOR_INDEX ) ; for ( short i = PaletteRecord . FIRST_COLOR_INDEX ; b != null ; b = _palette . getColor ( ++ i ) ) { int colorDistance = Math . abs ( red - unsignedInt ( b [ 0 ] ) ) + Math . abs ( green - unsignedInt ( b [ 1 ] ) ) + Math . abs ( blue - unsignedInt ( b [ 2 ] ) ) ; if ( colorDistance < minColorDistance ) { minColorDistance = colorDistance ; result = getColor ( i ) ; } } return result ; }
public synchronized StringBuffer deleteCharAt ( int location ) { deleteCharAt0 ( location ) ; return this ; }
public PathFilter clone ( ) { return this ; }
public String toString ( ) { if ( isEmpty ( ) ) { return " [ ] " ; } StringBuilder buffer = new StringBuilder ( size ( ) * 16 ) ; buffer . append ( ' [ ' ) ; Iterator <?> it = iterator ( ) ; while ( it . hasNext ( ) ) { Object next = it . next ( ) ; if ( next != this ) { buffer . append ( next ) ; } else { buffer . append ( " ( this ▁ Collection ) " ) ; } if ( it . hasNext ( ) ) { buffer . append ( " , ▁ " ) ; } } buffer . append ( ' ] ' ) ; return buffer . toString ( ) ; }
public synchronized void close ( ) throws IOException { buffer = null ; notifyAll ( ) ; }
public String toString ( ) { return " ShardIter ( shard = " + shardIndex + " ) " ; }
public JobParameters ( String format , String type , String archiveId , String description ) { setFormat ( format ) ; setType ( type ) ; setArchiveId ( archiveId ) ; setDescription ( description ) ; }
public IntBuffer get ( int [ ] dst ) { return get ( dst , 0 , dst . length ) ; }
public SupBookRecord ( String url , String [ ] sheetNames ) { field_1_number_of_sheets = ( short ) sheetNames . length ; field_2_encoded_url = url ; field_3_sheet_names = sheetNames ; _isAddInFunctions = false ; }
public SeriesLabelsRecord ( RecordInputStream in ) { field_1_formatFlags = in . readShort ( ) ; }
public DescribeAssessmentRunsResult describeAssessmentRuns ( DescribeAssessmentRunsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAssessmentRuns ( request ) ; }
public DescribeClassicLinkInstancesResult describeClassicLinkInstances ( DescribeClassicLinkInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClassicLinkInstances ( request ) ; }
public byte [ ] getByteBlock ( ) { return new byte [ blockSize ] ; }
public SeriesIndexRecord clone ( ) { return copy ( ) ; }
public RegisterToWorkMailResult registerToWorkMail ( RegisterToWorkMailRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterToWorkMail ( request ) ; }
public DeleteCollectionRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " DeleteCollection " , " cr " ) ; setUriPattern ( " / collections / [ CollectionId ] " ) ; setMethod ( MethodType . DELETE ) ; }
public Cluster deleteCluster ( DeleteClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCluster ( request ) ; }
public static double tanh ( double d ) { double ePowX = Math . pow ( Math . E , d ) ; double ePowNegX = Math . pow ( Math . E , - d ) ; return ( ePowX - ePowNegX ) / ( ePowX + ePowNegX ) ; }
public CharsRef common ( CharsRef output1 , CharsRef output2 ) { assert output1 != null ; assert output2 != null ; int pos1 = output1. offset ; int pos2 = output2. offset ; int stopAt1 = pos1 + Math . min ( output1. length , output2. length ) ; while ( pos1 < stopAt1 ) { if ( output1. chars [ pos1 ] != output2. chars [ pos2 ] ) { break ; } pos1 ++ ; pos2 ++ ; } if ( pos1 == output1. offset ) { return NO_OUTPUT ; } else if ( pos1 == output1. offset + output1. length ) { return output1 ; } else if ( pos2 == output2. offset + output2. length ) { return output2 ; } else { return new CharsRef ( output1. chars , output1. offset , pos1 - output1. offset ) ; } }
public GetExclusionsPreviewResult getExclusionsPreview ( GetExclusionsPreviewRequest request ) { request = beforeClientExecution ( request ) ; return executeGetExclusionsPreview ( request ) ; }
public KeepWordFilterFactory ( Map < String , String > args ) { super ( args ) ; wordFiles = get ( args , " words " ) ; ignoreCase = getBoolean ( args , " ignoreCase " , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public int uniformCmd ( boolean eqSkip ) { Iterator < Cell > i = cells . values ( ) . iterator ( ) ; int ret = - 1 ; uniformCnt = 1 ; uniformSkip = 0 ; for ( ; i . hasNext ( ) ; ) { Cell c = i . next ( ) ; if ( c . ref >= 0 ) { return - 1 ; } if ( c . cmd >= 0 ) { if ( ret < 0 ) { ret = c . cmd ; uniformSkip = c . skip ; } else if ( ret == c . cmd ) { if ( eqSkip ) { if ( uniformSkip == c . skip ) { uniformCnt ++ ; } else { return - 1 ; } } else { uniformCnt ++ ; } } else { return - 1 ; } } } return ret ; }
public ListTypedLinkFacetNamesResult listTypedLinkFacetNames ( ListTypedLinkFacetNamesRequest request ) { request = beforeClientExecution ( request ) ; return executeListTypedLinkFacetNames ( request ) ; }
public T remove ( int index ) { if ( index == size - 1 ) { T [ ] blockRef = directory [ toDirectoryIndex ( index ) ] ; int blockIdx = toBlockIndex ( index ) ; T old = blockRef [ blockIdx ] ; blockRef [ blockIdx ] = null ; size -- ; if ( 0 < tailBlkIdx ) tailBlkIdx -- ; elseresetTailBlock ( ) ; return old ; } else if ( index < 0 || size <= index ) { throw new IndexOutOfBoundsException ( String . valueOf ( index ) ) ; } else { T old = get ( index ) ; for ( ; index < size - 1 ; index ++ ) set ( index , get ( index + 1 ) ) ; set ( size - 1 , null ) ; size -- ; resetTailBlock ( ) ; return old ; } }
public boolean willSoonExpire ( ) { long now = System . currentTimeMillis ( ) ; return this . roleSessionDurationSeconds * ( 1 - expireFact ) > ( expiration - now ) / 1000 ; }
public GroupingSearch setSortWithinGroup ( Sort sortWithinGroup ) { this . sortWithinGroup = sortWithinGroup ; return this ; }
public long ramBytesUsed ( ) { return BASE_RAM_BYTES_USED + ( ( postings != null ) ? RamUsageEstimator . sizeOf ( postings ) : 0 ) + ( ( payloads != null ) ? RamUsageEstimator . sizeOf ( payloads ) : 0 ) ; }
public void seek ( long pos ) throws IOException { final long curFP = getFilePointer ( ) ; final long skip = pos - curFP ; if ( skip < 0 ) { throw new IllegalStateException ( getClass ( ) + " ▁ cannot ▁ seek ▁ backwards ▁ ( pos = " + pos + " ▁ getFilePointer ( ) = " + curFP + " ) " ) ; } skipBytes ( skip ) ; }
public ExternalName getExternalName ( int externSheetIndex , int externNameIndex ) { return _iBook . getExternalName ( externSheetIndex , externNameIndex ) ; }
public StrDocValues ( ValueSource vs ) { this . vs = vs ; }
public int getFunctionIndex ( String name ) { return name . hashCode ( ) ; }
public int hash2 ( char c ) { int hash = 5381 ; hash = ( ( hash << 5 ) + hash ) + c & 0x00FF ; hash = ( ( hash << 5 ) + hash ) + c >> 8 ; return hash ; }
public void create ( String id , String title , String time , String body ) throws IOException { Path d = directory ( count ++ , null ) ; Files . createDirectories ( d ) ; Path f = d . resolve ( id + " . txt " ) ; StringBuilder contents = new StringBuilder ( ) ; contents . append ( time ) ; contents . append ( " \ n \ n " ) ; contents . append ( title ) ; contents . append ( " \ n \ n " ) ; contents . append ( body ) ; contents . append ( " \ n " ) ; try ( Writer writer = Files . newBufferedWriter ( f , StandardCharsets . UTF_8 ) ) { writer . write ( contents . toString ( ) ) ; } }
public CharArrayWriter append ( CharSequence csq ) { if ( csq == null ) { csq = " null " ; } append ( csq , 0 , csq . length ( ) ) ; return this ; }
public PutAccountDedicatedIpWarmupAttributesResult putAccountDedicatedIpWarmupAttributes ( PutAccountDedicatedIpWarmupAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executePutAccountDedicatedIpWarmupAttributes ( request ) ; }
public static boolean equal ( Object a , Object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }
public RevFlag getUnshallowFlag ( ) { return UNSHALLOW ; }
public DescribeSolutionVersionResult describeSolutionVersion ( DescribeSolutionVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSolutionVersion ( request ) ; }
public byte [ ] getBuffer ( ) { return file . buf ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ WRITEACCESS ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . name ▁ = ▁ " ) . append ( field_1_username ) . append ( " \ n " ) ; buffer . append ( " [ / WRITEACCESS ] \ n " ) ; return buffer . toString ( ) ; }
public ModifyFpgaImageAttributeResult modifyFpgaImageAttribute ( ModifyFpgaImageAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyFpgaImageAttribute ( request ) ; }
public SubmoduleUpdateCommand ( Repository repo ) { super ( repo ) ; paths = new ArrayList <> ( ) ; }
public boolean isKnown ( ) { return type == Type . KNOWN ; }
public long get ( int index ) { final int o = index / 10 ; final int b = index % 10 ; final int shift = b * 6 ; return ( blocks [ o ] >>> shift ) & 63L ; }
public void setValue ( byte value ) { setValue ( FormulaError . forInt ( value ) ) ; }
public int getCodePoint ( ) { return c ; }
public GetDocumentationVersionsResult getDocumentationVersions ( GetDocumentationVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDocumentationVersions ( request ) ; }
public int indexOfKey ( int key ) { if ( mGarbage ) { gc ( ) ; } return binarySearch ( mKeys , 0 , mSize , key ) ; }
public void reportError ( Parser recognizer , RecognitionException e ) { if ( inErrorRecoveryMode ( recognizer ) ) { return ; } beginErrorCondition ( recognizer ) ; if ( e instanceof NoViableAltException ) { reportNoViableAlternative ( recognizer , ( NoViableAltException ) e ) ; } else if ( e instanceof InputMismatchException ) { reportInputMismatch ( recognizer , ( InputMismatchException ) e ) ; } else if ( e instanceof FailedPredicateException ) { reportFailedPredicate ( recognizer , ( FailedPredicateException ) e ) ; } else { System . err . println ( " unknown ▁ recognition ▁ error ▁ type : ▁ " + e . getClass ( ) . getName ( ) ) ; recognizer . notifyErrorListeners ( e . getOffendingToken ( ) , e . getMessage ( ) , e ) ; } }
public ConstantStringFormat ( String s ) { str = s ; }
public DoubleBuffer asReadOnlyBuffer ( ) { return ReadOnlyDoubleArrayBuffer . copy ( this , mark ) ; }
public CacheCluster deleteCacheCluster ( DeleteCacheClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCacheCluster ( request ) ; }
public ModifyClusterSnapshotScheduleResult modifyClusterSnapshotSchedule ( ModifyClusterSnapshotScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyClusterSnapshotSchedule ( request ) ; }
public InitCommand setBare ( boolean bare ) { validateDirs ( directory , gitDir , bare ) ; this . bare = bare ; return this ; }
public TermsEnumWithSlice ( int index , ReaderSlice subSlice ) { this . subSlice = subSlice ; this . index = index ; assert subSlice . length >= 0 : " length = " + subSlice . length ; }
public UserSViewEnd ( byte [ ] data ) { _rawData = data ; }
public SetIdentityPoolRolesResult setIdentityPoolRoles ( SetIdentityPoolRolesRequest request ) { request = beforeClientExecution ( request ) ; return executeSetIdentityPoolRoles ( request ) ; }
public Vector ( short type ) { this . _type = type ; }
public GetEndpointResult getEndpoint ( GetEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeGetEndpoint ( request ) ; }
public Builder add ( int docId ) { if ( docId <= lastDocId ) { throw new IllegalArgumentException ( " Doc ▁ ids ▁ must ▁ be ▁ added ▁ in - order , ▁ got ▁ " + docId + " ▁ which ▁ is ▁ <= ▁ lastDocID = " + lastDocId ) ; } final int block = docId >>> 16 ; if ( block != currentBlock ) { flush ( ) ; currentBlock = block ; } if ( currentBlockCardinality < MAX_ARRAY_LENGTH ) { buffer [ currentBlockCardinality ] = ( short ) docId ; } else { if ( denseBuffer == null ) { final int numBits = Math . min ( 1 << 16 , maxDoc - ( block << 16 ) ) ; denseBuffer = new FixedBitSet ( numBits ) ; for ( short doc : buffer ) { denseBuffer . set ( doc & 0xFFFF ) ; } } denseBuffer . set ( docId & 0xFFFF ) ; } lastDocId = docId ; currentBlockCardinality += 1 ; return this ; }
public boolean matches ( int symbol , int minVocabSymbol , int maxVocabSymbol ) { return false ; }
public DescribeClustersResult describeClusters ( DescribeClustersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClusters ( request ) ; }
public Trie reduce ( Reduce by ) { List < Trie > h = new ArrayList <> ( ) ; for ( Trie trie : tries ) h . add ( trie . reduce ( by ) ) ; MultiTrie2 m = new MultiTrie2 ( forward ) ; m . tries = h ; return m ; }
public CellRangeAddressBase getCategoryLabelsCellRange ( ) { return getCellRange ( dataCategoryLabels ) ; }
public String getPass ( ) { return pass ; }
public synchronized Set < Entry < K , V >> entrySet ( ) { Set < Entry < K , V >> es = entrySet ; return ( es != null ) ? es : ( entrySet = new EntrySet ( ) ) ; }
public static String toFormulaString ( HSSFWorkbook book , Ptg [ ] ptgs ) { return FormulaRenderer . toFormulaString ( HSSFEvaluationWorkbook . create ( book ) , ptgs ) ; }
public CharBuffer slice ( ) { return new CharSequenceAdapter ( sequence . subSequence ( position , limit ) ) ; }
public UpdateBusinessReportScheduleResult updateBusinessReportSchedule ( UpdateBusinessReportScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateBusinessReportSchedule ( request ) ; }
public void append ( byte [ ] nameBuf , int namePos , int nameLen , FileMode mode , byte [ ] idBuf , int idPos ) { if ( fmtBuf ( nameBuf , namePos , nameLen , mode ) ) { System . arraycopy ( idBuf , idPos , buf , ptr , OBJECT_ID_LENGTH ) ; ptr += OBJECT_ID_LENGTH ; } else { try { fmtOverflowBuffer ( nameBuf , namePos , nameLen , mode ) ; overflowBuffer . write ( idBuf , idPos , OBJECT_ID_LENGTH ) ; } catch ( IOException badBuffer ) { throw new RuntimeException ( badBuffer ) ; } } }
public CreateSpotDatafeedSubscriptionResult createSpotDatafeedSubscription ( CreateSpotDatafeedSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSpotDatafeedSubscription ( request ) ; }
public final long length ( ) { return count ; }
public CreateSkillGroupResult createSkillGroup ( CreateSkillGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSkillGroup ( request ) ; }
public int getRightId ( int wordId ) { return RIGHT_ID ; }
public void setRetainBody ( boolean retain ) { retainBody = retain ; }
public final void reset ( ) { len = 0 ; }
public StringBuilder insert ( int offset , boolean b ) { insert0 ( offset , b ? " true " : " false " ) ; return this ; }
public static boolean isWhitespace ( byte c ) { return WHITESPACE [ c & 0xff ] ; }
public DescribeSessionsResult describeSessions ( DescribeSessionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSessions ( request ) ; }
public DescribeLocalGatewayVirtualInterfaceGroupsResult describeLocalGatewayVirtualInterfaceGroups ( DescribeLocalGatewayVirtualInterfaceGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLocalGatewayVirtualInterfaceGroups ( request ) ; }
public static String pathToString ( String dim , String [ ] path ) { String [ ] fullPath = new String [ 1 + path . length ] ; fullPath [ 0 ] = dim ; System . arraycopy ( path , 0 , fullPath , 1 , path . length ) ; return pathToString ( fullPath , fullPath . length ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { final byte block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( block >>> 6 ) & 3 ; values [ valuesOffset ++ ] = ( block >>> 4 ) & 3 ; values [ valuesOffset ++ ] = ( block >>> 2 ) & 3 ; values [ valuesOffset ++ ] = block & 3 ; } }
public SignalResourceResult signalResource ( SignalResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeSignalResource ( request ) ; }
public int getPasswordVerifier ( ) { return passwordVerifier ; }
public void copy ( MutableValue source ) { MutableValueDouble s = ( MutableValueDouble ) source ; value = s . value ; exists = s . exists ; }
public int read ( byte [ ] buffer , int offset , int length ) throws IOException { Arrays . checkOffsetAndCount ( buffer . length , offset , length ) ; for ( int i = 0 ; i < length ; i ++ ) { int c ; try { if ( ( c = read ( ) ) == - 1 ) { return i == 0 ? - 1 : i ; } } catch ( IOException e ) { if ( i != 0 ) { return i ; } throw e ; } buffer [ offset + i ] = ( byte ) c ; } return length ; }
public TreeFilter getPathFilter ( ) { return pathFilter ; }
public CalcCountRecord ( RecordInputStream in ) { field_1_iterations = in . readShort ( ) ; }
public DescribeVaultRequest ( String vaultName ) { setVaultName ( vaultName ) ; }
public final double get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return backingArray [ offset + position ++ ] ; }
public final void write ( char [ ] b ) { write ( b , 0 , b . length ) ; }
public DeleteTagsForDomainResult deleteTagsForDomain ( DeleteTagsForDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTagsForDomain ( request ) ; }
public SetMeRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " SetMe " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public LongBuffer put ( long c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } byteBuffer . putLong ( position ++ * SizeOf . LONG , c ) ; return this ; }
public DisassociateFleetResult disassociateFleet ( DisassociateFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateFleet ( request ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ( " + in . toString ( ) + " ) " ; }
public static String fromLong ( Long value ) { return Long . toString ( value ) ; }
public BytesRefArray ( Counter bytesUsed ) { this . pool = new ByteBlockPool ( new ByteBlockPool . DirectTrackingAllocator ( bytesUsed ) ) ; pool . nextBuffer ( ) ; bytesUsed . addAndGet ( RamUsageEstimator . NUM_BYTES_ARRAY_HEADER * Integer . BYTES ) ; this . bytesUsed = bytesUsed ; }
public FloatBuffer put ( float [ ] src , int srcOffset , int floatCount ) { if ( floatCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } System . arraycopy ( src , srcOffset , backingArray , offset + position , floatCount ) ; position += floatCount ; return this ; }
public void skipBytes ( final long numBytes ) throws IOException { if ( numBytes < 0 ) { throw new IllegalArgumentException ( " numBytes ▁ must ▁ be ▁ >= ▁ 0 , ▁ got ▁ " + numBytes ) ; } if ( skipBuffer == null ) { skipBuffer = new byte [ SKIP_BUFFER_SIZE ] ; } assert skipBuffer . length == SKIP_BUFFER_SIZE ; for ( long skipped = 0 ; skipped < numBytes ; ) { final int step = ( int ) Math . min ( SKIP_BUFFER_SIZE , numBytes - skipped ) ; readBytes ( skipBuffer , 0 , step , false ) ; skipped += step ; } }
public final char get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return backingArray [ offset + position ++ ] ; }
@ Override public E remove ( int location ) { synchronized ( mutex ) { return list . remove ( location ) ; } }
public ExpPtg ( LittleEndianInput in ) { field_1_first_row = in . readShort ( ) ; field_2_first_col = in . readShort ( ) ; }
public TokenStream create ( TokenStream input ) { return new CJKBigramFilter ( input , flags , outputUnigrams ) ; }
public FuzzySet getSetForField ( SegmentWriteState state , FieldInfo info ) { return FuzzySet . createSetBasedOnQuality ( state . segmentInfo . maxDoc ( ) , 0.10f ) ; }
public static int [ ] grow ( int [ ] array ) { return grow ( array , 1 + array . length ) ; }
public void setLength ( int length ) { if ( length < 0 ) { throw new StringIndexOutOfBoundsException ( " length ▁ < ▁ 0 : ▁ " + length ) ; } if ( length > value . length ) { enlargeBuffer ( length ) ; } else { if ( shared ) { char [ ] newData = new char [ value . length ] ; System . arraycopy ( value , 0 , newData , 0 , count ) ; value = newData ; shared = false ; } else { if ( count < length ) { Arrays . fill ( value , count , length , ( char ) 0 ) ; } } } count = length ; }
public void sync ( ) { boolean interrupted = false ; try { while ( true ) { MergeThread toSync = null ; synchronized ( this ) { for ( MergeThread t : mergeThreads ) { if ( t . isAlive ( ) && t != Thread . currentThread ( ) ) { toSync = t ; break ; } } } if ( toSync != null ) { try { toSync . join ( ) ; } catch ( InterruptedException ie ) { interrupted = true ; } } else { break ; } } } finally { if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; } }
public DescribeIdentityPoolUsageResult describeIdentityPoolUsage ( DescribeIdentityPoolUsageRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIdentityPoolUsage ( request ) ; }
public ClusterSecurityGroup createClusterSecurityGroup ( CreateClusterSecurityGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateClusterSecurityGroup ( request ) ; }
public K nextElement ( ) { return nextEntryNotFailFast ( ) . key ; }
public HSSFShapeGroup ( EscherContainerRecord spgrContainer , ObjRecord objRecord ) { super ( spgrContainer , objRecord ) ; EscherContainerRecord spContainer = spgrContainer . getChildContainers ( ) . get ( 0 ) ; _spgrRecord = ( EscherSpgrRecord ) spContainer . getChild ( 0 ) ; for ( EscherRecord ch : spContainer . getChildRecords ( ) ) { switch ( EscherRecordTypes . forTypeID ( ch . getRecordId ( ) ) ) { case SPGR : break ; case CLIENT_ANCHOR : anchor = new HSSFClientAnchor ( ( EscherClientAnchorRecord ) ch ) ; break ; case CHILD_ANCHOR : anchor = new HSSFChildAnchor ( ( EscherChildAnchorRecord ) ch ) ; break ; default : break ; } } }
public SoraniStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public SetAlbumCoverRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " SetAlbumCover " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public boolean equals ( final Object o ) { boolean rval = false ; if ( ( o != null ) && ( o . getClass ( ) == this . getClass ( ) ) ) { if ( this == o ) { rval = true ; } else { DocumentDescriptor descriptor = ( DocumentDescriptor ) o ; rval = this . path . equals ( descriptor . path ) && this . name . equals ( descriptor . name ) ; } } return rval ; }
public void finish ( ) { if ( ! sorted ) resort ( ) ; replace ( ) ; }
public void map ( K key , V value ) { List < V > elementsForKey = get ( key ) ; if ( elementsForKey == null ) { elementsForKey = new ArrayList < V > ( ) ; super . put ( key , elementsForKey ) ; } elementsForKey . add ( value ) ; }
public DescribeImportSnapshotTasksResult describeImportSnapshotTasks ( DescribeImportSnapshotTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeImportSnapshotTasks ( request ) ; }
public ListEventSourcesResult listEventSources ( ListEventSourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeListEventSources ( request ) ; }
public static double getExcelDate ( Calendar date , boolean use1904windowing ) { int year = date . get ( Calendar . YEAR ) ; int dayOfYear = date . get ( Calendar . DAY_OF_YEAR ) ; int hour = date . get ( Calendar . HOUR_OF_DAY ) ; int minute = date . get ( Calendar . MINUTE ) ; int second = date . get ( Calendar . SECOND ) ; int milliSecond = date . get ( Calendar . MILLISECOND ) ; return internalGetExcelDate ( year , dayOfYear , hour , minute , second , milliSecond , use1904windowing ) ; }
public TimeSpec ( char type , int pos , int len , double factor ) { this . type = type ; this . pos = pos ; this . len = len ; this . factor = factor ; modBy = 0 ; }
public DeleteApiMappingResult deleteApiMapping ( DeleteApiMappingRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApiMapping ( request ) ; }
public static String typeString ( int typeCode ) { switch ( typeCode ) { case OBJ_COMMIT : return TYPE_COMMIT ; case OBJ_TREE : return TYPE_TREE ; case OBJ_BLOB : return TYPE_BLOB ; case OBJ_TAG : return TYPE_TAG ; default : throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . badObjectType , Integer . valueOf ( typeCode ) ) ) ; } }
public long addAndGet ( long delta ) { return count . addAndGet ( delta ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( super . toString ( ) ) ; sb . append ( " ▁ fields = " ) ; sb . append ( Arrays . toString ( fields ) ) ; return sb . toString ( ) ; }
public UpdateTemplateActiveVersionResult updateTemplateActiveVersion ( UpdateTemplateActiveVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTemplateActiveVersion ( request ) ; }
public int compareTo ( FacetLabel other ) { final int len = length < other . length ? length : other . length ; for ( int i = 0 , j = 0 ; i < len ; i ++ , j ++ ) { int cmp = components [ i ] . compareTo ( other . components [ j ] ) ; if ( cmp < 0 ) { return - 1 ; } if ( cmp > 0 ) { return 1 ; } } return length - other . length ; }
public int find ( String key ) { int len = key . length ( ) ; char strkey [ ] = new char [ len + 1 ] ; key . getChars ( 0 , len , strkey , 0 ) ; strkey [ len ] = 0 ; return find ( strkey , 0 ) ; }
public final CharBuffer put ( char [ ] src , int srcOffset , int charCount ) { throw new ReadOnlyBufferException ( ) ; }
public ListNodesResult listNodes ( ListNodesRequest request ) { request = beforeClientExecution ( request ) ; return executeListNodes ( request ) ; }
public DeleteVoiceConnectorStreamingConfigurationResult deleteVoiceConnectorStreamingConfiguration ( DeleteVoiceConnectorStreamingConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVoiceConnectorStreamingConfiguration ( request ) ; }
public TokenStream create ( TokenStream input ) { return new SoraniNormalizationFilter ( input ) ; }
public int following ( int pos ) { if ( pos < start || pos > end ) { throw new IllegalArgumentException ( " offset ▁ out ▁ of ▁ bounds " ) ; } else if ( pos == end ) { current = end ; return DONE ; } else { return last ( ) ; } }
public SshSessionFactory getSshSessionFactory ( ) { return sch ; }
@ Override public boolean contains ( Object o ) { if ( ! ( o instanceof Multiset . Entry ) ) { return false ; } Multiset . Entry <?> entry = ( Multiset . Entry <?> ) o ; Collection < V > collection = map . get ( entry . getElement ( ) ) ; return ( collection != null ) && ( collection . size ( ) == entry . getCount ( ) ) ; }
public TokenFilter create ( TokenStream input ) { CommonGramsFilter commonGrams = new CommonGramsFilter ( input , commonWords ) ; return commonGrams ; }
public DescribeWorkspaceImagesResult describeWorkspaceImages ( DescribeWorkspaceImagesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWorkspaceImages ( request ) ; }
public ValueEval getItem ( int index ) { if ( index < 0 || index > _size ) { throw new IllegalArgumentException ( " Specified ▁ index ▁ " + index + " ▁ is ▁ outside ▁ range ▁ ( 0.. " + ( _size - 1 ) + " ) " ) ; } return getItemInternal ( index ) ; }
public ListEventBusesResult listEventBuses ( ListEventBusesRequest request ) { request = beforeClientExecution ( request ) ; return executeListEventBuses ( request ) ; }
public QualityStats ( double maxGoodPoints , long searchTime ) { this . maxGoodPoints = maxGoodPoints ; this . searchTime = searchTime ; this . recallPoints = new ArrayList <> ( ) ; pAt = new double [ MAX_POINTS + 1 ] ; }
public GetInvalidationRequest ( String distributionId , String id ) { setDistributionId ( distributionId ) ; setId ( id ) ; }
public int compareTo ( ScoreTerm other ) { if ( this . boost == other . boost ) return other . bytes . get ( ) . compareTo ( this . bytes . get ( ) ) ; else return Float . compare ( this . boost , other . boost ) ; }
public RegenerateSecurityTokenResult regenerateSecurityToken ( RegenerateSecurityTokenRequest request ) { request = beforeClientExecution ( request ) ; return executeRegenerateSecurityToken ( request ) ; }
public DescribeRootFoldersResult describeRootFolders ( DescribeRootFoldersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeRootFolders ( request ) ; }
public DeactivateUserResult deactivateUser ( DeactivateUserRequest request ) { request = beforeClientExecution ( request ) ; return executeDeactivateUser ( request ) ; }
public boolean contains ( int el ) { int n = intervals . size ( ) ; int l = 0 ; int r = n - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; Interval I = intervals . get ( m ) ; int a = I . a ; int b = I . b ; if ( b < el ) { l = m + 1 ; } else if ( a > el ) { r = m - 1 ; } else { return true ; } } return false ; }
public ListJobsResult listJobs ( ListJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListJobs ( request ) ; }
public RussianLightStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public SearchSkillGroupsResult searchSkillGroups ( SearchSkillGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchSkillGroups ( request ) ; }
public SortField getSortField ( Bindings bindings , boolean reverse ) { return getDoubleValuesSource ( bindings ) . getSortField ( reverse ) ; }
public ModifyHostsResult modifyHosts ( ModifyHostsRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyHosts ( request ) ; }
public void setDate ( String date ) { this . date = date ; }
public ValueEval getAreaEval ( int firstRowIndex , int firstColumnIndex , int lastRowIndex , int lastColumnIndex ) { SheetRangeEvaluator sre = getRefEvaluatorForCurrentSheet ( ) ; return new LazyAreaEval ( firstRowIndex , firstColumnIndex , lastRowIndex , lastColumnIndex , sre ) ; }
public CreateContactMethodResult createContactMethod ( CreateContactMethodRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateContactMethod ( request ) ; }
public static final RevFilter before ( Date ts ) { return before ( ts . getTime ( ) ) ; }
public String toString ( ) { return toString ( VocabularyImpl . EMPTY_VOCABULARY ) ; }
public void updateFormulasAfterCellShift ( FormulaShifter shifter , int externSheetIndex ) { for ( int i = 0 ; i < _cfHeaders . size ( ) ; i ++ ) { CFRecordsAggregate subAgg = _cfHeaders . get ( i ) ; boolean shouldKeep = subAgg . updateFormulasAfterCellShift ( shifter , externSheetIndex ) ; if ( ! shouldKeep ) { _cfHeaders . remove ( i ) ; i -- ; } } }
public void insertCell ( CellValueRecordInterface cvRec ) { _valuesAgg . insertCell ( cvRec ) ; }
public ShingleFilter create ( TokenStream input ) { ShingleFilter r = new ShingleFilter ( input , minShingleSize , maxShingleSize ) ; r . setOutputUnigrams ( outputUnigrams ) ; r . setOutputUnigramsIfNoShingles ( outputUnigramsIfNoShingles ) ; r . setTokenSeparator ( tokenSeparator ) ; r . setFillerToken ( fillerToken ) ; return r ; }
public SlopQueryNode ( QueryNode query , int value ) { if ( query == null ) { throw new QueryNodeError ( new MessageImpl ( QueryParserMessages . NODE_ACTION_NOT_SUPPORTED , " query " , " null " ) ) ; } this . value = value ; setLeaf ( false ) ; allocate ( ) ; add ( query ) ; }
public ReplaceRouteTableAssociationResult replaceRouteTableAssociation ( ReplaceRouteTableAssociationRequest request ) { request = beforeClientExecution ( request ) ; return executeReplaceRouteTableAssociation ( request ) ; }
public void setObjectIdFromRaw ( byte [ ] bs , int p ) { final int n = Constants . OBJECT_ID_LENGTH ; System . arraycopy ( bs , p , idBuffer ( ) , idOffset ( ) , n ) ; }
public ListTablesResult listTables ( Integer limit ) { return listTables ( new ListTablesRequest ( ) . withLimit ( limit ) ) ; }
public DeleteDeviceGroupRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " DeleteDeviceGroup " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public void addRecords ( RecordStream rs ) { while ( true ) { if ( ! readARecord ( rs ) ) { break ; } } }
public static Collection < String > getSupportedFunctionNames ( ) { Collection < String > lst = new TreeSet <> ( ) ; for ( int i = 0 ; i < functions . length ; i ++ ) { Function func = functions [ i ] ; FunctionMetadata metaData = FunctionMetadataRegistry . getFunctionByIndex ( i ) ; if ( func != null && ! ( func instanceof NotImplementedFunction ) ) { lst . add ( metaData . getName ( ) ) ; } } lst . add ( " INDIRECT " ) ; return Collections . unmodifiableCollection ( lst ) ; }
public PendingTaskCount countPendingActivityTasks ( CountPendingActivityTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeCountPendingActivityTasks ( request ) ; }
public List < SegToken > process ( String sentence ) { SegGraph segGraph = createSegGraph ( sentence ) ; BiSegGraph biSegGraph = new BiSegGraph ( segGraph ) ; List < SegToken > shortPath = biSegGraph . getShortPath ( ) ; return shortPath ; }
public Area3DPtg ( AreaReference arearef , int externIdx ) { super ( arearef ) ; setExternSheetIndex ( externIdx ) ; }
public EnableRuleResult enableRule ( EnableRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableRule ( request ) ; }
public static boolean equals ( byte [ ] array1 , byte [ ] array2 ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1. length != array2. length ) { return false ; } for ( int i = 0 ; i < array1. length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) { return false ; } } return true ; }
public boolean isExpectDataAfterPackFooter ( ) { return expectDataAfterPackFooter ; }
public ListIncomingTypedLinksResult listIncomingTypedLinks ( ListIncomingTypedLinksRequest request ) { request = beforeClientExecution ( request ) ; return executeListIncomingTypedLinks ( request ) ; }
public void removeRevNumber ( ) { remove1stProperty ( PropertyIDMap . PID_REVNUMBER ) ; }
public DeleteMonitoringScheduleResult deleteMonitoringSchedule ( DeleteMonitoringScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMonitoringSchedule ( request ) ; }
public synchronized boolean put ( FacetLabel categoryPath , int ordinal ) { boolean ret = cache . put ( categoryPath , ordinal ) ; if ( ret ) { cache . makeRoomLRU ( ) ; } return ret ; }
public void pushNewRecursionContext ( ParserRuleContext localctx , int state , int ruleIndex ) { ParserRuleContext previous = _ctx ; previous . parent = localctx ; previous . invokingState = state ; previous . stop = _input . LT ( - 1 ) ; _ctx = localctx ; _ctx . start = previous . start ; if ( _buildParseTrees ) { _ctx . addChild ( previous ) ; } if ( _parseListeners != null ) { triggerEnterRuleEvent ( ) ; } }
public Writer ( ) { output = new ByteArrayOutputStream ( ) ; }
public String getSignerType ( ) { return null ; }
public void add ( Ptg token ) { if ( token == null ) { throw new IllegalArgumentException ( " token ▁ must ▁ not ▁ be ▁ null " ) ; } _ptgs [ _offset ] = token ; _offset ++ ; }
public Repository build ( ) throws IOException { FileRepository repo = new FileRepository ( setup ( ) ) ; if ( isMustExist ( ) && ! repo . getObjectDatabase ( ) . exists ( ) ) throw new RepositoryNotFoundException ( getGitDir ( ) ) ; return repo ; }
public List < WeightedFragInfo > getWeightedFragInfoList ( List < WeightedFragInfo > src ) { Collections . sort ( src , new ScoreComparator ( ) ) ; return src ; }
public String toString ( ) { return " epsilon " ; }
public DescribeDBLogFilesResult describeDBLogFiles ( DescribeDBLogFilesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBLogFiles ( request ) ; }
public NoteRecord ( RecordInputStream in ) { field_1_row = in . readUShort ( ) ; field_2_col = in . readShort ( ) ; field_3_flags = in . readShort ( ) ; field_4_shapeid = in . readUShort ( ) ; int length = in . readShort ( ) ; field_5_hasMultibyte = in . readByte ( ) != 0x00 ; if ( field_5_hasMultibyte ) { field_6_author = StringUtil . readUnicodeLE ( in , length ) ; } else { field_6_author = StringUtil . readCompressedUnicode ( in , length ) ; } if ( in . available ( ) == 1 ) { field_7_padding = Byte . valueOf ( in . readByte ( ) ) ; } else if ( in . available ( ) == 2 && length == 0 ) { field_7_padding = Byte . valueOf ( in . readByte ( ) ) ; in . readByte ( ) ; } }
public CherryPickCommand setOurCommitName ( String ourCommitName ) { this . ourCommitName = ourCommitName ; return this ; }
public GetCloudFormationStackRecordsResult getCloudFormationStackRecords ( GetCloudFormationStackRecordsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCloudFormationStackRecords ( request ) ; }
public XPathTokenAnywhereElement ( String tokenName , int tokenType ) { super ( tokenName ) ; this . tokenType = tokenType ; }
public boolean isExpired ( ) { long now = System . currentTimeMillis ( ) ; return now >= expiration - refreshIntervalInMillSeconds ; }
public ListDetectorsResult listDetectors ( ListDetectorsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDetectors ( request ) ; }
public void add ( int index , T element ) { if ( index == size ) { add ( element ) ; } else if ( index < 0 || size < index ) { throw new IndexOutOfBoundsException ( String . valueOf ( index ) ) ; } else { add ( null ) ; for ( int oldIdx = size - 2 ; index <= oldIdx ; oldIdx -- ) set ( oldIdx + 1 , get ( oldIdx ) ) ; set ( index , element ) ; } }
public static int intersect ( CellRangeAddress crA , CellRangeAddress crB ) { int firstRow = crB . getFirstRow ( ) ; int lastRow = crB . getLastRow ( ) ; int firstCol = crB . getFirstColumn ( ) ; int lastCol = crB . getLastColumn ( ) ; if ( gt ( crA . getFirstRow ( ) , lastRow ) || lt ( crA . getLastRow ( ) , firstRow ) || gt ( crA . getFirstColumn ( ) , lastCol ) || lt ( crA . getLastColumn ( ) , firstCol ) ) { return NO_INTERSECTION ; } else if ( contains ( crA , crB ) ) { return INSIDE ; } else if ( contains ( crB , crA ) ) { return ENCLOSES ; } else { return OVERLAP ; } }
public short getXFAt ( int coffset ) { return _xfs [ coffset ] ; }
public static final boolean isId ( @ Nullable String id ) { if ( id == null ) { return false ; } if ( id . length ( ) != Constants . OBJECT_ID_STRING_LENGTH ) return false ; try { for ( int i = 0 ; i < Constants . OBJECT_ID_STRING_LENGTH ; i ++ ) { RawParseUtils . parseHexInt4 ( ( byte ) id . charAt ( i ) ) ; } return true ; } catch ( ArrayIndexOutOfBoundsException e ) { return false ; } }
@ Override public boolean isEmpty ( ) { return countMap . isEmpty ( ) ; }
public ByteVector ( byte [ ] a , int capacity ) { if ( capacity > 0 ) { blockSize = capacity ; } else { blockSize = DEFAULT_BLOCK_SIZE ; } array = a ; n = 0 ; }
public void write ( int oneByte ) throws IOException { write ( new byte [ ] { ( byte ) oneByte } , 0 , 1 ) ; }
public SegmentCommitInfo info ( int i ) { return segments . get ( i ) ; }
public ListDistributionsByWebACLIdResult listDistributionsByWebACLId ( ListDistributionsByWebACLIdRequest request ) { request = beforeClientExecution ( request ) ; return executeListDistributionsByWebACLId ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( rt ) ; out . writeShort ( grbitFrt ) ; out . writeShort ( iObjectKind ) ; out . writeShort ( iObjectContext ) ; out . writeShort ( iObjectInstance1 ) ; out . writeShort ( iObjectInstance2 ) ; }
public CreateDeliveryStreamResult createDeliveryStream ( CreateDeliveryStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDeliveryStream ( request ) ; }
public ResetDBParameterGroupResult resetDBParameterGroup ( ResetDBParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeResetDBParameterGroup ( request ) ; }
public DescribeDocumentClassificationJobResult describeDocumentClassificationJob ( DescribeDocumentClassificationJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDocumentClassificationJob ( request ) ; }
public DescribeSecurityGroupsResult describeSecurityGroups ( DescribeSecurityGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSecurityGroups ( request ) ; }
public UpdateTrafficPolicyInstanceResult updateTrafficPolicyInstance ( UpdateTrafficPolicyInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTrafficPolicyInstance ( request ) ; }
public BinaryHunk getForwardBinaryHunk ( ) { return forwardBinaryHunk ; }
public static ByteBuffer allocateDirect ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( ) ; } return new ReadWriteDirectByteBuffer ( capacity ) ; }
public void drawString ( String str , int x , int y ) { if ( str == null || str . isEmpty ( ) ) return ; Font excelFont = font ; if ( font . getName ( ) . equals ( " SansSerif " ) ) { excelFont = new Font ( " Arial " , font . getStyle ( ) , ( int ) ( font . getSize ( ) / verticalPixelsPerPoint ) ) ; } else { excelFont = new Font ( font . getName ( ) , font . getStyle ( ) , ( int ) ( font . getSize ( ) / verticalPixelsPerPoint ) ) ; } FontDetails d = StaticFontMetrics . getFontDetails ( excelFont ) ; int width = d . getStringWidth ( str ) * 8 + 12 ; int height = ( int ) ( ( font . getSize ( ) / verticalPixelsPerPoint ) + 6 ) * 2 ; y -= ( font . getSize ( ) / verticalPixelsPerPoint ) + 2 * verticalPixelsPerPoint ; HSSFTextbox textbox = escherGroup . createTextbox ( new HSSFChildAnchor ( x , y , x + width , y + height ) ) ; textbox . setNoFill ( true ) ; textbox . setLineStyle ( HSSFShape . LINESTYLE_NONE ) ; HSSFRichTextString s = new HSSFRichTextString ( str ) ; HSSFFont hssfFont = matchFont ( excelFont ) ; s . applyFont ( hssfFont ) ; textbox . setString ( s ) ; }
public Query makeLuceneQueryFieldNoBoost ( String fieldName , BasicQueryFactory qf ) { List < Query > luceneSubQueries = makeLuceneSubQueriesField ( fieldName , qf ) ; BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . add ( luceneSubQueries . get ( 0 ) , BooleanClause . Occur . MUST ) ; SrndBooleanQuery . addQueriesToBoolean ( bq , luceneSubQueries . subList ( 1 , luceneSubQueries . size ( ) ) , BooleanClause . Occur . MUST_NOT ) ; return bq . build ( ) ; }
public void reset ( byte [ ] treeData ) { attributesNode = null ; raw = treeData ; prevPtr = - 1 ; currPtr = 0 ; if ( eof ( ) ) nextPtr = 0 ; elseparseEntry ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_save_link_values ) ; }
public static Boolean toBooleanOrNull ( String stringValue ) { if ( stringValue == null ) return null ; if ( equalsIgnoreCase ( " yes " , stringValue ) || equalsIgnoreCase ( " true " , stringValue ) || equalsIgnoreCase ( " 1 " , stringValue ) || equalsIgnoreCase ( " on " , stringValue ) ) return Boolean . TRUE ; else if ( equalsIgnoreCase ( " no " , stringValue ) || equalsIgnoreCase ( " false " , stringValue ) || equalsIgnoreCase ( " 0 " , stringValue ) || equalsIgnoreCase ( " off " , stringValue ) ) return Boolean . FALSE ; else return null ; }
public RevObject lookupOrNull ( AnyObjectId id ) { return objects . get ( id ) ; }
public void cloneStyleFrom ( FontRecord source ) { field_1_font_height = source . field_1_font_height ; field_2_attributes = source . field_2_attributes ; field_3_color_palette_index = source . field_3_color_palette_index ; field_4_bold_weight = source . field_4_bold_weight ; field_5_super_sub_script = source . field_5_super_sub_script ; field_6_underline = source . field_6_underline ; field_7_family = source . field_7_family ; field_8_charset = source . field_8_charset ; field_9_zero = source . field_9_zero ; field_11_font_name = source . field_11_font_name ; }
public BrazilianStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static byte lookupCharacterClass ( String characterClassName ) { return ( byte ) CharacterClass . valueOf ( characterClassName ) . ordinal ( ) ; }
public ArrayList ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( ) ; } array = ( capacity == 0 ? EmptyArray . OBJECT : new Object [ capacity ] ) ; }
public CreateHumanTaskUiResult createHumanTaskUi ( CreateHumanTaskUiRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateHumanTaskUi ( request ) ; }
public GetSoftwareUpdatesResult getSoftwareUpdates ( GetSoftwareUpdatesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSoftwareUpdates ( request ) ; }
public NamePtg createPtg ( ) { return new NamePtg ( _index ) ; }
public ListFlowDefinitionsResult listFlowDefinitions ( ListFlowDefinitionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListFlowDefinitions ( request ) ; }
public LittleEndianOutput createDelayedOutput ( int size ) { checkPosition ( size ) ; LittleEndianOutput result = new LittleEndianByteArrayOutputStream ( _buf , _writeIndex , size ) ; _writeIndex += size ; return result ; }
public long get ( int index ) { return current . get ( index ) ; }
public StemmerOverrideFilterFactory ( Map < String , String > args ) { super ( args ) ; dictionaryFiles = get ( args , " dictionary " ) ; ignoreCase = getBoolean ( args , " ignoreCase " , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public long get ( int index ) { final int o = index / 12 ; final int b = index % 12 ; final int shift = b * 5 ; return ( blocks [ o ] >>> shift ) & 31L ; }
public DeleteDeploymentGroupResult deleteDeploymentGroup ( DeleteDeploymentGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDeploymentGroup ( request ) ; }
public void setNamespaceAware ( boolean awareness ) { features . put ( XmlPullParser . FEATURE_PROCESS_NAMESPACES , awareness ) ; }
public static List < String > getBuiltinFormats ( ) { return Arrays . asList ( _builtinFormats ) ; }
public Snapshot authorizeSnapshotAccess ( AuthorizeSnapshotAccessRequest request ) { request = beforeClientExecution ( request ) ; return executeAuthorizeSnapshotAccess ( request ) ; }
public void split ( ) throws IOException { boolean success = false ; DirectoryReader reader = DirectoryReader . open ( input ) ; try { createIndex ( config1 , dir1 , reader , docsInFirstIndex , false ) ; createIndex ( config2 , dir2 , reader , docsInFirstIndex , true ) ; success = true ; } finally { if ( success ) { IOUtils . close ( reader ) ; } else { IOUtils . closeWhileHandlingException ( reader ) ; } } }
@ Override public boolean equals ( Object object ) { return mapEntry . equals ( object ) ; }
public synchronized E pop ( ) { if ( elementCount == 0 ) { throw new EmptyStackException ( ) ; } final int index = -- elementCount ; final E obj = ( E ) elementData [ index ] ; elementData [ index ] = null ; modCount ++ ; return obj ; }
public ListHealthChecksResult listHealthChecks ( ) { return listHealthChecks ( new ListHealthChecksRequest ( ) ) ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof File ) ) { return false ; } return path . equals ( ( ( File ) obj ) . getPath ( ) ) ; }
public ListPhotoStoresRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListPhotoStores " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public PutAccessControlRuleResult putAccessControlRule ( PutAccessControlRuleRequest request ) { request = beforeClientExecution ( request ) ; return executePutAccessControlRule ( request ) ; }
public StopTrainingEntityRecognizerResult stopTrainingEntityRecognizer ( StopTrainingEntityRecognizerRequest request ) { request = beforeClientExecution ( request ) ; return executeStopTrainingEntityRecognizer ( request ) ; }
public GetRevisionResult getRevision ( GetRevisionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRevision ( request ) ; }
public HSSFPicture createPicture ( HSSFChildAnchor anchor , int pictureIndex ) { HSSFPicture shape = new HSSFPicture ( this , anchor ) ; shape . setParent ( this ) ; shape . setAnchor ( anchor ) ; shape . setPictureIndex ( pictureIndex ) ; shapes . add ( shape ) ; onCreate ( shape ) ; EscherSpRecord sp = shape . getEscherContainer ( ) . getChildById ( EscherSpRecord . RECORD_ID ) ; if ( shape . getAnchor ( ) . isHorizontallyFlipped ( ) ) { sp . setFlags ( sp . getFlags ( ) | EscherSpRecord . FLAG_FLIPHORIZ ) ; } if ( shape . getAnchor ( ) . isVerticallyFlipped ( ) ) { sp . setFlags ( sp . getFlags ( ) | EscherSpRecord . FLAG_FLIPVERT ) ; } return shape ; }
public RecordSizingVisitor ( ) { _totalSize = 0 ; }
public UpdateApplicationSettingsResult updateApplicationSettings ( UpdateApplicationSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateApplicationSettings ( request ) ; }
public LogCommand addPath ( String path ) { checkCallable ( ) ; pathFilters . add ( PathFilter . create ( path ) ) ; return this ; }
public GetRelationalDatabaseLogStreamsResult getRelationalDatabaseLogStreams ( GetRelationalDatabaseLogStreamsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabaseLogStreams ( request ) ; }
public FloatBuffer compact ( ) { if ( byteBuffer . isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } byteBuffer . limit ( limit * SizeOf . FLOAT ) ; byteBuffer . position ( position * SizeOf . FLOAT ) ; byteBuffer . compact ( ) ; byteBuffer . clear ( ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( field_1_lineColor ) ; out . writeShort ( field_2_linePattern ) ; out . writeShort ( field_3_weight ) ; out . writeShort ( field_4_format ) ; out . writeShort ( field_5_colourPaletteIndex ) ; }
public DBInstanceAutomatedBackup deleteDBInstanceAutomatedBackup ( DeleteDBInstanceAutomatedBackupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDBInstanceAutomatedBackup ( request ) ; }
public MultiSimilarity ( Similarity sims [ ] ) { this . sims = sims ; }
public final Explanation explain ( BasicStats stats , double tfn ) { return Explanation . match ( ( float ) ( scoreTimes1pTfn ( stats ) / ( 1 + tfn ) ) , getClass ( ) . getSimpleName ( ) + " , ▁ computed ▁ as ▁ ( F ▁ + ▁ 1 ) ▁ / ▁ ( n ▁ * ▁ ( tfn ▁ + ▁ 1 ) ) ▁ from : " , Explanation . match ( ( float ) tfn , " tfn , ▁ normalized ▁ term ▁ frequency " ) , Explanation . match ( stats . getTotalTermFreq ( ) , " F , ▁ total ▁ number ▁ of ▁ occurrences ▁ of ▁ term ▁ across ▁ all ▁ documents ▁ + ▁ 1 " ) , Explanation . match ( stats . getDocFreq ( ) , " n , ▁ number ▁ of ▁ documents ▁ containing ▁ term ▁ + ▁ 1 " ) , Explanation . match ( ( float ) tfn , " tfn , ▁ normalized ▁ term ▁ frequency " ) ) ; }
public GetNodeResult getNode ( GetNodeRequest request ) { request = beforeClientExecution ( request ) ; return executeGetNode ( request ) ; }
public CreateCapacityProviderResult createCapacityProvider ( CreateCapacityProviderRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCapacityProvider ( request ) ; }
public String [ ] listAll ( ) throws IOException { List < String > files = new ArrayList <> ( ) ; NoSuchFileException exc = null ; try { for ( String f : primaryDir . listAll ( ) ) { String ext = getExtension ( f ) ; if ( primaryExtensions . contains ( ext ) ) { files . add ( f ) ; } } } catch ( NoSuchFileException e ) { exc = e ; } try { for ( String f : secondaryDir . listAll ( ) ) { String ext = getExtension ( f ) ; if ( primaryExtensions . contains ( ext ) == false ) { files . add ( f ) ; } } } catch ( NoSuchFileException e ) { if ( exc != null ) { throw exc ; } if ( files . isEmpty ( ) ) { throw e ; } } if ( exc != null && files . isEmpty ( ) ) { throw exc ; } String [ ] result = files . toArray ( new String [ files . size ( ) ] ) ; Arrays . sort ( result ) ; return result ; }
public int readUByte ( ) { return readByte ( ) & 0xFF ; }
public NumberEval ( double value ) { _value = value ; }
@ Override public Iterator < E > iterator ( ) { synchronized ( mutex ) { return c . iterator ( ) ; } }
public String getInflectionType ( int wordId ) { return null ; }
public GetDeliverabilityDashboardOptionsResult getDeliverabilityDashboardOptions ( GetDeliverabilityDashboardOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDeliverabilityDashboardOptions ( request ) ; }
public static double getExcelDate ( LocalDateTime date ) { return getExcelDate ( date , false ) ; }
public String getBaseForm ( int wordId , char surface [ ] , int off , int len ) { return null ; }
public DescribeDhcpOptionsResult describeDhcpOptions ( ) { return describeDhcpOptions ( new DescribeDhcpOptionsRequest ( ) ) ; }
public FormatRecord ( int indexCode , String fs ) { field_1_index_code = indexCode ; field_4_formatstring = fs ; field_3_hasMultibyte = StringUtil . hasMultibyte ( fs ) ; }
public String getPrintArea ( int sheetIndex ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) { return null ; } return HSSFFormulaParser . toFormulaString ( this , name . getNameDefinition ( ) ) ; }
public CreateLoadBalancerResult createLoadBalancer ( CreateLoadBalancerRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLoadBalancer ( request ) ; }
public GetVoiceConnectorTerminationHealthResult getVoiceConnectorTerminationHealth ( GetVoiceConnectorTerminationHealthRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVoiceConnectorTerminationHealth ( request ) ; }
public CRNCountRecord ( RecordInputStream in ) { field_1_number_crn_records = in . readShort ( ) ; if ( field_1_number_crn_records < 0 ) { field_1_number_crn_records = ( short ) - field_1_number_crn_records ; } field_2_sheet_table_index = in . readShort ( ) ; }
public BOFRecord ( RecordInputStream in ) { field_1_version = in . readShort ( ) ; field_2_type = in . readShort ( ) ; if ( in . remaining ( ) >= 2 ) { field_3_build = in . readShort ( ) ; } if ( in . remaining ( ) >= 2 ) { field_4_year = in . readShort ( ) ; } if ( in . remaining ( ) >= 4 ) { field_5_history = in . readInt ( ) ; } if ( in . remaining ( ) >= 4 ) { field_6_rversion = in . readInt ( ) ; } }
public AcsRequest buildRequest ( ) { if ( uriPattern != null ) { CommonRoaRequest request = new CommonRoaRequest ( product ) ; request . setSysUriPattern ( uriPattern ) ; for ( String pathParamKey : pathParameters . keySet ( ) ) { request . putPathParameter ( pathParamKey , pathParameters . get ( pathParamKey ) ) ; } fillParams ( request ) ; return request ; } else { CommonRpcRequest request = new CommonRpcRequest ( product ) ; fillParams ( request ) ; return request ; } }
public void undeleteAll ( ) { for ( FakeDeleteLeafIndexReader r : getSequentialSubReaders ( ) ) { r . undeleteAll ( ) ; } }
public final String GetImage ( ) { return new String ( buffer , tokenStart , bufferPosition - tokenStart ) ; }
public DescribeComponentResult describeComponent ( DescribeComponentRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeComponent ( request ) ; }
public RoaringDocIdSet build ( ) { flush ( ) ; return new RoaringDocIdSet ( sets , cardinality ) ; }
public TokenStream create ( TokenStream input ) { return new GermanNormalizationFilter ( input ) ; }
public DrillSideways ( IndexSearcher searcher , FacetsConfig config , TaxonomyReader taxoReader , SortedSetDocValuesReaderState state ) { this ( searcher , config , taxoReader , state , null ) ; }
public DescribeAnalysisSchemesResult describeAnalysisSchemes ( DescribeAnalysisSchemesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAnalysisSchemes ( request ) ; }
public PutTargetsResult putTargets ( PutTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executePutTargets ( request ) ; }
public RevokeIpRulesResult revokeIpRules ( RevokeIpRulesRequest request ) { request = beforeClientExecution ( request ) ; return executeRevokeIpRules ( request ) ; }
public RegisterGameServerResult registerGameServer ( RegisterGameServerRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterGameServer ( request ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeByte ( _options ) ; out . writeShort ( _data ) ; int [ ] jt = _jumpTable ; if ( jt != null ) { for ( int i = 0 ; i < jt . length ; i ++ ) { out . writeShort ( jt [ i ] ) ; } out . writeShort ( _chooseFuncOffset ) ; } }
public int getCellsPnt ( ) { Iterator < Character > i = cells . keySet ( ) . iterator ( ) ; int size = 0 ; for ( ; i . hasNext ( ) ; ) { Character c = i . next ( ) ; Cell e = at ( c ) ; if ( e . ref >= 0 ) { size ++ ; } } return size ; }
public E removeFirst ( ) { return removeFirstImpl ( ) ; }
public String toString ( ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " < boolean ▁ operation = ' default ' /> " ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " < boolean ▁ operation = ' default ' > " ) ; for ( QueryNode child : getChildren ( ) ) { sb . append ( " \ n " ) ; sb . append ( child . toString ( ) ) ; } sb . append ( " \ n </ boolean > " ) ; return sb . toString ( ) ; }
public TokenStream create ( TokenStream input ) { return new TruncateTokenFilter ( input , prefixLength ) ; }
public String getErrorDisplay ( int c ) { String s = String . valueOf ( ( char ) c ) ; switch ( c ) { case Token . EOF : s = " < EOF > " ; break ; case ' \ n ' : s = " \\ n " ; break ; case ' \ t ' : s = " \\ t " ; break ; case ' \ r ' : s = " \\ r " ; break ; } return s ; }
public CreateContactResult createContact ( CreateContactRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateContact ( request ) ; }
public Transition [ ] [ ] getSortedTransitions ( ) { int numStates = getNumStates ( ) ; Transition [ ] [ ] transitions = new Transition [ numStates ] [ ] ; for ( int s = 0 ; s < numStates ; s ++ ) { int numTransitions = getNumTransitions ( s ) ; transitions [ s ] = new Transition [ numTransitions ] ; for ( int t = 0 ; t < numTransitions ; t ++ ) { Transition transition = new Transition ( ) ; getTransition ( s , t , transition ) ; transitions [ s ] [ t ] = transition ; } } return transitions ; }
public DescribeAccountModificationsResult describeAccountModifications ( DescribeAccountModificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAccountModifications ( request ) ; }
public ListSolutionVersionsResult listSolutionVersions ( ListSolutionVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListSolutionVersions ( request ) ; }
public void finish ( FieldInfos fis , int numDocs ) throws IOException { if ( numDocsWritten != numDocs ) { throw new RuntimeException ( " mergeFields ▁ produced ▁ an ▁ invalid ▁ result : ▁ docCount ▁ is ▁ " + numDocs + " ▁ but ▁ only ▁ saw ▁ " + numDocsWritten + " ▁ file = " + out . toString ( ) + " ; ▁ now ▁ aborting ▁ this ▁ merge ▁ to ▁ prevent ▁ index ▁ corruption " ) ; } write ( END ) ; newLine ( ) ; SimpleTextUtil . writeChecksum ( out , scratch ) ; }
public SetVaultNotificationsRequest ( String vaultName , VaultNotificationConfig vaultNotificationConfig ) { setVaultName ( vaultName ) ; setVaultNotificationConfig ( vaultNotificationConfig ) ; }
public Trie reduce ( Reduce by ) { List < Trie > h = new ArrayList <> ( ) ; for ( Trie trie : tries ) h . add ( trie . reduce ( by ) ) ; MultiTrie m = new MultiTrie ( forward ) ; m . tries = h ; return m ; }
public void println ( ) { synchronized ( lock ) { print ( System . lineSeparator ( ) ) ; if ( autoFlush ) { flush ( ) ; } } }
public final void writeChar ( int val ) throws IOException { writeShort ( val ) ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( GREATERTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public UpdateDeploymentResult updateDeployment ( UpdateDeploymentRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDeployment ( request ) ; }
public ListRoutingProfilesResult listRoutingProfiles ( ListRoutingProfilesRequest request ) { request = beforeClientExecution ( request ) ; return executeListRoutingProfiles ( request ) ; }
public boolean isFormulaSame ( SharedFormulaRecord other ) { return field_7_parsed_expr . isSame ( other . field_7_parsed_expr ) ; }
public static byte getType ( int ch ) { switch ( Character . getType ( ch ) ) { case Character . UPPERCASE_LETTER : return UPPER ; case Character . LOWERCASE_LETTER : return LOWER ; case Character . TITLECASE_LETTER : case Character . MODIFIER_LETTER : case Character . OTHER_LETTER : case Character . NON_SPACING_MARK : case Character . ENCLOSING_MARK : case Character . COMBINING_SPACING_MARK : return ALPHA ; case Character . DECIMAL_DIGIT_NUMBER : case Character . LETTER_NUMBER : case Character . OTHER_NUMBER : return DIGIT ; case Character . SURROGATE : return ALPHA | DIGIT ; default : return SUBWORD_DELIM ; } }
public CreateImageResult createImage ( CreateImageRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateImage ( request ) ; }
public void assume ( RevCommit c ) { if ( c != null ) assume . add ( c ) ; }
public DeleteTagsResult deleteTags ( DeleteTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTags ( request ) ; }
public ListTemplateVersionsResult listTemplateVersions ( ListTemplateVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTemplateVersions ( request ) ; }
public String toString ( ) { return " ( " + x + " , ▁ " + y + " ) " ; }
public DisjunctionMaxQueryBuilder ( QueryBuilder factory ) { this . factory = factory ; }
public PutNotificationConfigurationResult putNotificationConfiguration ( PutNotificationConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executePutNotificationConfiguration ( request ) ; }
public RecognizeFlowerRequest ( ) { super ( " visionai - poc " , " 2020 - 04 - 08 " , " RecognizeFlower " ) ; setMethod ( MethodType . POST ) ; }
public IndexFormatTooOldException ( String resourceDescription , int version , int minVersion , int maxVersion ) { super ( " Format ▁ version ▁ is ▁ not ▁ supported ▁ ( resource ▁ " + resourceDescription + " ) : ▁ " + version + " ▁ ( needs ▁ to ▁ be ▁ between ▁ " + minVersion + " ▁ and ▁ " + maxVersion + " ) . ▁ This ▁ version ▁ of ▁ Lucene ▁ only ▁ supports ▁ indexes ▁ created ▁ with ▁ release ▁ 8.0 ▁ and ▁ later . " ) ; this . resourceDescription = resourceDescription ; this . version = version ; this . minVersion = minVersion ; this . maxVersion = maxVersion ; this . reason = null ; }
public void add ( int el ) { if ( readonly ) throw new IllegalStateException ( " can ' t alter readonly IntervalSet " ) ; add ( el , el ) ; }
@ Override public final int read ( byte [ ] buffer ) throws IOException { return super . read ( buffer ) ; }
@ Override public boolean remove ( Object key ) { if ( ! contains ( key ) ) { return false ; } removeFromBothMaps ( key ) ; return true ; }
public DescribeClusterSecurityGroupsResult describeClusterSecurityGroups ( DescribeClusterSecurityGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClusterSecurityGroups ( request ) ; }
public TokenStream create ( TokenStream input ) { return new ScandinavianFoldingFilter ( input ) ; }
public DeleteNotebookInstanceLifecycleConfigResult deleteNotebookInstanceLifecycleConfig ( DeleteNotebookInstanceLifecycleConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNotebookInstanceLifecycleConfig ( request ) ; }
public DescribeComponentConfigurationRecommendationResult describeComponentConfigurationRecommendation ( DescribeComponentConfigurationRecommendationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeComponentConfigurationRecommendation ( request ) ; }
public SimpleMergedSegmentWarmer ( InfoStream infoStream ) { this . infoStream = infoStream ; }
public int nextIndex ( ) { return pos + 1 ; }
public ThaiTokenizerFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public int doLogic ( ) throws Exception { if ( name == null || value == null ) { throw new Exception ( getName ( ) + " ▁ - ▁ undefined ▁ name ▁ or ▁ value : ▁ name = " + name + " ▁ value = " + value ) ; } getRunData ( ) . getConfig ( ) . set ( name , value ) ; return 0 ; }
public void setPrintArea ( int sheetIndex , String reference ) { NameRecord name = workbook . getSpecificBuiltinRecord ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; if ( name == null ) { name = workbook . createBuiltInName ( NameRecord . BUILTIN_PRINT_AREA , sheetIndex + 1 ) ; } String [ ] parts = COMMA_PATTERN . split ( reference ) ; StringBuilder sb = new StringBuilder ( 32 ) ; for ( int i = 0 ; i < parts . length ; i ++ ) { if ( i > 0 ) { sb . append ( " , " ) ; } SheetNameFormatter . appendFormat ( sb , getSheetName ( sheetIndex ) ) ; sb . append ( " ! " ) ; sb . append ( parts [ i ] ) ; } name . setNameDefinition ( HSSFFormulaParser . parse ( sb . toString ( ) , this , FormulaType . NAMEDRANGE , sheetIndex ) ) ; }
public String getPartOfSpeech ( ) { return dictionary . getPartOfSpeech ( wordId ) ; }
public synchronized static DefaultProfile getProfile ( String regionId ) { return new DefaultProfile ( regionId ) ; }
public TurkishLowerCaseFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static boolean equals ( double [ ] array1 , double [ ] array2 ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1. length != array2. length ) { return false ; } for ( int i = 0 ; i < array1. length ; i ++ ) { if ( Double . doubleToLongBits ( array1 [ i ] ) != Double . doubleToLongBits ( array2 [ i ] ) ) { return false ; } } return true ; }
public ShortField ( final int offset ) throws ArrayIndexOutOfBoundsException { if ( offset < 0 ) { throw new ArrayIndexOutOfBoundsException ( " Illegal ▁ offset : ▁ " + offset ) ; } _offset = offset ; }
public int getEffectivePort ( ) { return getEffectivePort ( scheme , port ) ; }
public GetDiskSnapshotsResult getDiskSnapshots ( GetDiskSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDiskSnapshots ( request ) ; }
public ParseTreePatternMatcher ( Lexer lexer , Parser parser ) { this . lexer = lexer ; this . parser = parser ; }
public PassageScorer ( float k1 , float b , float pivot ) { this . k1 = k1 ; this . b = b ; this . pivot = pivot ; }
public CreateTicketRequest ( ) { super ( " Ccs " , " 2017 - 10 - 01 " , " CreateTicket " , " ccs " ) ; setMethod ( MethodType . POST ) ; }
public RejectTransitGatewayVpcAttachmentResult rejectTransitGatewayVpcAttachment ( RejectTransitGatewayVpcAttachmentRequest request ) { request = beforeClientExecution ( request ) ; return executeRejectTransitGatewayVpcAttachment ( request ) ; }
public DeleteApnsChannelResult deleteApnsChannel ( DeleteApnsChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApnsChannel ( request ) ; }
public Entry getEntry ( final String name ) throws FileNotFoundException { Entry rval = null ; if ( name != null ) { rval = _byname . get ( name ) ; } if ( rval == null ) { if ( _byname . containsKey ( " Workbook " ) ) { throw new IllegalArgumentException ( " The ▁ document ▁ is ▁ really ▁ a ▁ XLS ▁ file " ) ; } else if ( _byname . containsKey ( " PowerPoint ▁ Document " ) ) { throw new IllegalArgumentException ( " The ▁ document ▁ is ▁ really ▁ a ▁ PPT ▁ file " ) ; } else if ( _byname . containsKey ( " VisioDocument " ) ) { throw new IllegalArgumentException ( " The ▁ document ▁ is ▁ really ▁ a ▁ VSD ▁ file " ) ; } throw new FileNotFoundException ( " no ▁ such ▁ entry : ▁ \ " " + name + " \ " , ▁ had : ▁ " + _byname . keySet ( ) ) ; } return rval ; }
public TokenStream create ( TokenStream input ) { return new FrenchMinimalStemFilter ( input ) ; }
public int getDecimalExponent ( ) { return _relativeDecimalExponent + EXPONENT_OFFSET ; }
public DescribeInstanceCreditSpecificationsResult describeInstanceCreditSpecifications ( DescribeInstanceCreditSpecificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInstanceCreditSpecifications ( request ) ; }
public GetSendQuotaResult getSendQuota ( ) { return getSendQuota ( new GetSendQuotaRequest ( ) ) ; }
public String toString ( ) { return " TERM : ▁ " + brToString ( termBytes ) ; }
public ListFacetNamesResult listFacetNames ( ListFacetNamesRequest request ) { request = beforeClientExecution ( request ) ; return executeListFacetNames ( request ) ; }
public PlainValueCellCacheEntry ( ValueEval value ) { updateValue ( value ) ; }
public PutEmailIdentityFeedbackAttributesResult putEmailIdentityFeedbackAttributes ( PutEmailIdentityFeedbackAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executePutEmailIdentityFeedbackAttributes ( request ) ; }
public AbortMultipartUploadRequest ( String vaultName , String uploadId ) { setVaultName ( vaultName ) ; setUploadId ( uploadId ) ; }
public ResetDBParameterGroupRequest ( String dBParameterGroupName ) { setDBParameterGroupName ( dBParameterGroupName ) ; }
public HSSFClientAnchor createAnchor ( int dx1 , int dy1 , int dx2 , int dy2 , int col1 , int row1 , int col2 , int row2 ) { return new HSSFClientAnchor ( dx1 , dy1 , dx2 , dy2 , ( short ) col1 , row1 , ( short ) col2 , row2 ) ; }
public void updateCacheResult ( ValueEval result ) { int nFrames = _evaluationFrames . size ( ) ; if ( nFrames < 1 ) { throw new IllegalStateException ( " Call ▁ to ▁ endEvaluate ▁ without ▁ matching ▁ call ▁ to ▁ startEvaluate " ) ; } CellEvaluationFrame frame = _evaluationFrames . get ( nFrames - 1 ) ; if ( result == ErrorEval . CIRCULAR_REF_ERROR && nFrames > 1 ) { return ; } frame . updateFormulaResult ( result ) ; }
public Enumeration < String > keys ( ) { return new Iterator ( ) ; }
public void fromRaw ( int [ ] ints ) { fromRaw ( ints , 0 ) ; }
public int [ ] init ( ) { final int [ ] ord = super . init ( ) ; start = new int [ ArrayUtil . oversize ( ord . length , Integer . BYTES ) ] ; end = new int [ ArrayUtil . oversize ( ord . length , Integer . BYTES ) ] ; freq = new int [ ArrayUtil . oversize ( ord . length , Integer . BYTES ) ] ; assert start . length >= ord . length ; assert end . length >= ord . length ; assert freq . length >= ord . length ; return ord ; }
public boolean addFetchRefSpec ( RefSpec s ) { if ( fetch . contains ( s ) ) return false ; return fetch . add ( s ) ; }
public char setIndex ( int location ) { if ( location < start || location > end ) { throw new IllegalArgumentException ( ) ; } offset = location ; if ( offset == end ) { return DONE ; } return string . charAt ( offset ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ ITERATION ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . flags ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( _flags ) ) . append ( " \ n " ) ; buffer . append ( " [ / ITERATION ] \ n " ) ; return buffer . toString ( ) ; }
public LogByteSizeMergePolicy ( ) { minMergeSize = ( long ) ( DEFAULT_MIN_MERGE_MB * 1024 * 1024 ) ; maxMergeSize = ( long ) ( DEFAULT_MAX_MERGE_MB * 1024 * 1024 ) ; maxMergeSizeForForcedMerge = ( long ) ( DEFAULT_MAX_MERGE_MB_FOR_FORCED_MERGE * 1024 * 1024 ) ; }
public DescribeNetworkInterfacePermissionsResult describeNetworkInterfacePermissions ( DescribeNetworkInterfacePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNetworkInterfacePermissions ( request ) ; }
public String toString ( ) { return " < wildcard ▁ field = ' " ▁ + ▁ this . field ▁ + ▁ " ' ▁ term = ' " ▁ + ▁ this . text ▁ + ▁ " ' /> " ; }
public DeleteImageBuilderResult deleteImageBuilder ( DeleteImageBuilderRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteImageBuilder ( request ) ; }
public boolean requiresCommitBody ( ) { return requiresCommitBody ; }
public void removeDocparts ( ) { remove1stProperty ( PropertyIDMap . PID_DOCPARTS ) ; }
public DescribeConfigurationSetResult describeConfigurationSet ( DescribeConfigurationSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeConfigurationSet ( request ) ; }
public static BufferSize megabytes ( long mb ) { return new BufferSize ( mb * MB ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeInt ( field_1_reserved ) ; }
public ListLabelingJobsForWorkteamResult listLabelingJobsForWorkteam ( ListLabelingJobsForWorkteamRequest request ) { request = beforeClientExecution ( request ) ; return executeListLabelingJobsForWorkteam ( request ) ; }
public GetKeyPairResult getKeyPair ( GetKeyPairRequest request ) { request = beforeClientExecution ( request ) ; return executeGetKeyPair ( request ) ; }
@ Override public boolean isEmpty ( ) { Slice slice = this . slice ; return slice . from == slice . to ; }
public EveryNTermSelector ( int interval ) { this . interval = interval ; count = interval ; }
public void ReInit ( CharStream stream ) { token_source . ReInit ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 25 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public DirectTrackingAllocator ( int blockSize , Counter bytesUsed ) { super ( blockSize ) ; this . bytesUsed = bytesUsed ; }
public static ShortBuffer allocate ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( ) ; } return new ReadWriteShortArrayBuffer ( capacity ) ; }
public DescribeDatasetImportJobResult describeDatasetImportJob ( DescribeDatasetImportJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDatasetImportJob ( request ) ; }
public DescribeClusterSnapshotsResult describeClusterSnapshots ( ) { return describeClusterSnapshots ( new DescribeClusterSnapshotsRequest ( ) ) ; }
public PushbackReader ( Reader in , int size ) { super ( in ) ; if ( size <= 0 ) { throw new IllegalArgumentException ( " size ▁ <= ▁ 0 " ) ; } buf = new char [ size ] ; pos = size ; }
public final char getChar ( int index ) { checkIndex ( index , SizeOf . CHAR ) ; return ( char ) Memory . peekShort ( backingArray , offset + index , order ) ; }
public SingleCellValueArray ( ValueEval value ) { super ( 1 ) ; _value = value ; }
public List < Ref > getCherryPickedRefs ( ) { return cherryPickedRefs ; }
public Destination ( java . util . List < String > toAddresses ) { setToAddresses ( toAddresses ) ; }
public String getHostname ( ) { return Host . this . getHostName ( ) ; }
public void setSize ( int taxonomySize ) { map = new int [ taxonomySize ] ; }
public void writeShort ( int v ) { int b1 = ( v >>> 8 ) & 0xFF ; int b0 = ( v ) & 0xFF ; try { out . write ( b0 ) ; out . write ( b1 ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public PathQueryNode ( List < QueryText > pathElements ) { this . values = pathElements ; if ( pathElements . size ( ) <= 1 ) { throw new RuntimeException ( " PathQuerynode ▁ requires ▁ more ▁ 2 ▁ or ▁ more ▁ path ▁ elements . " ) ; } }
public int getMaxDeltaDepth ( ) { return maxDeltaDepth ; }
public DomainInfos listDomains ( ListDomainsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDomains ( request ) ; }
public float weight ( int contentLength , int totalTermFreq ) { float numDocs = 1 + contentLength / pivot ; return ( k1 + 1 ) * ( float ) Math . log ( 1 + ( numDocs + 0.5D ) / ( totalTermFreq + 0.5D ) ) ; }
public PutIdentityPolicyResult putIdentityPolicy ( PutIdentityPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executePutIdentityPolicy ( request ) ; }
public String toString ( ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " < tokenizedphrase /> " ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " < tokenizedtphrase > " ) ; for ( QueryNode child : getChildren ( ) ) { sb . append ( " \ n " ) ; sb . append ( child . toString ( ) ) ; } sb . append ( " \ n </ tokenizedphrase > " ) ; return sb . toString ( ) ; }
public static File [ ] listRoots ( ) { return new File [ ] { new File ( " / " ) } ; }
public CharBuffer slice ( ) { return new ReadOnlyCharArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public JapaneseKatakanaStemFilter ( TokenStream input , int minimumLength ) { super ( input ) ; this . minimumKatakanaLength = minimumLength ; }
public String toString ( ) { return brToString ( termBytes ) ; }
public void unsafeWrite ( char b [ ] , int off , int len ) { System . arraycopy ( b , off , buf , this . len , len ) ; this . len += len ; }
public ExternalNameRecord ( RecordInputStream in ) { field_1_option_flag = in . readShort ( ) ; field_2_ixals = in . readShort ( ) ; field_3_not_used = in . readShort ( ) ; int numChars = in . readUByte ( ) ; field_4_name = StringUtil . readUnicodeString ( in , numChars ) ; if ( ! isOLELink ( ) && ! isStdDocumentNameIdentifier ( ) ) { if ( isAutomaticLink ( ) ) { if ( in . available ( ) > 0 ) { int nColumns = in . readUByte ( ) + 1 ; int nRows = in . readShort ( ) + 1 ; int totalCount = nRows * nColumns ; _ddeValues = ConstantValueParser . parse ( in , totalCount ) ; _nColumns = nColumns ; _nRows = nRows ; } } else { int formulaLen = in . readUShort ( ) ; field_5_name_definition = Formula . read ( formulaLen , in ) ; } } }
public PorterStemFilter create ( TokenStream input ) { return new PorterStemFilter ( input ) ; }
public LoginProfile ( String userName , java . util . Date createDate ) { setUserName ( userName ) ; setCreateDate ( createDate ) ; }
public void setUnknownFormulaData ( byte [ ] formularData ) { field_2_unknownFormulaData = formularData ; }
public Reader create ( Reader input ) { return normMap == null ? input : new MappingCharFilter ( normMap , input ) ; }
public Iterator < Entry < K , V >> iterator ( ) { return new EntryIterator ( ) ; }
public final Buffer clear ( ) { position = 0 ; mark = UNSET_MARK ; limit = capacity ; return this ; }
public int getNameIx ( int definedNameIndex ) { return _externalNameRecords [ definedNameIndex ] . getIx ( ) ; }
public DeleteReceiptRuleResult deleteReceiptRule ( DeleteReceiptRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteReceiptRule ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; SortedSetSortField other = ( SortedSetSortField ) obj ; if ( selector != other . selector ) return false ; return true ; }
public JobFlowDetail ( String jobFlowId , String name , JobFlowExecutionStatusDetail executionStatusDetail , JobFlowInstancesDetail instances ) { setJobFlowId ( jobFlowId ) ; setName ( name ) ; setExecutionStatusDetail ( executionStatusDetail ) ; setInstances ( instances ) ; }
public PutVoiceConnectorOriginationResult putVoiceConnectorOrigination ( PutVoiceConnectorOriginationRequest request ) { request = beforeClientExecution ( request ) ; return executePutVoiceConnectorOrigination ( request ) ; }
public DBInstance startDBInstance ( StartDBInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeStartDBInstance ( request ) ; }
public DeleteChangeSetResult deleteChangeSet ( DeleteChangeSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteChangeSet ( request ) ; }
public int nextIndex ( ) { return pos + 1 ; }
public DescribeGameSessionDetailsResult describeGameSessionDetails ( DescribeGameSessionDetailsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeGameSessionDetails ( request ) ; }
public ListDatasetImportJobsResult listDatasetImportJobs ( ListDatasetImportJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDatasetImportJobs ( request ) ; }
public String toString ( ) { return new StringBuilder ( ) . append ( " ( " ) . append ( x ) . append ( " , " ) . append ( y ) . append ( " ) " ) . toString ( ) ; }
public CharBlockArray append ( char c ) { if ( this . current . length == this . blockSize ) { addBlock ( ) ; } this . current . chars [ this . current . length ++ ] = c ; this . length ++ ; return this ; }
public SimpleBoolFunction ( ValueSource source ) { this . source = source ; }
public String toStringUnquoted ( ) { return getPrefix ( ) ; }
public static Transport open ( URIish uri ) throws NotSupportedException , TransportException { for ( WeakReference < TransportProtocol > ref : protocols ) { TransportProtocol proto = ref . get ( ) ; if ( proto == null ) { protocols . remove ( ref ) ; continue ; } if ( proto . canHandle ( uri , null , null ) ) return proto . open ( uri ) ; } throw new NotSupportedException ( MessageFormat . format ( JGitText . get ( ) . URINotSupported , uri ) ) ; }
public void mark ( int readAheadLimit ) throws IOException { throw new IOException ( " mark / reset ▁ not ▁ supported " ) ; }
public DeleteClusterSecurityGroupResult deleteClusterSecurityGroup ( DeleteClusterSecurityGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteClusterSecurityGroup ( request ) ; }
public GlobalReplicationGroup rebalanceSlotsInGlobalReplicationGroup ( RebalanceSlotsInGlobalReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeRebalanceSlotsInGlobalReplicationGroup ( request ) ; }
public DeleteLocalGatewayRouteResult deleteLocalGatewayRoute ( DeleteLocalGatewayRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLocalGatewayRoute ( request ) ; }
public DBCluster restoreDBClusterFromSnapshot ( RestoreDBClusterFromSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeRestoreDBClusterFromSnapshot ( request ) ; }
public String getReading ( int wordId , char surface [ ] , int off , int len ) { return null ; }
public CreateDBSnapshotRequest ( String dBSnapshotIdentifier , String dBInstanceIdentifier ) { setDBSnapshotIdentifier ( dBSnapshotIdentifier ) ; setDBInstanceIdentifier ( dBInstanceIdentifier ) ; }
public RemoveRoleFromDBInstanceResult removeRoleFromDBInstance ( RemoveRoleFromDBInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveRoleFromDBInstance ( request ) ; }
public Token nextToken ( ) { if ( i >= tokens . size ( ) ) { if ( eofToken == null ) { int start = - 1 ; if ( tokens . size ( ) > 0 ) { int previousStop = tokens . get ( tokens . size ( ) - 1 ) . getStopIndex ( ) ; if ( previousStop != - 1 ) { start = previousStop + 1 ; } } int stop = Math . max ( - 1 , start - 1 ) ; eofToken = _factory . create ( new Pair < TokenSource , CharStream > ( this , getInputStream ( ) ) , Token . EOF , " EOF " , Token . DEFAULT_CHANNEL , start , stop , getLine ( ) , getCharPositionInLine ( ) ) ; } return eofToken ; } Token t = tokens . get ( i ) ; if ( i == tokens . size ( ) - 1 && t . getType ( ) == Token . EOF ) { eofToken = t ; } i ++ ; return t ; }
public QueryMaker getQueryMaker ( ) { return null ; }
public GC ( FileRepository repo ) { this . repo = repo ; this . pconfig = new PackConfig ( repo ) ; this . pm = NullProgressMonitor . INSTANCE ; }
public synchronized void setLength ( int length ) { super . setLength ( length ) ; }
public CancelImportTaskResult cancelImportTask ( CancelImportTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelImportTask ( request ) ; }
public int first ( ) { return ( current = start ) ; }
public DeleteDiskResult deleteDisk ( DeleteDiskRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDisk ( request ) ; }
public DeleteVpcEndpointConnectionNotificationsResult deleteVpcEndpointConnectionNotifications ( DeleteVpcEndpointConnectionNotificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVpcEndpointConnectionNotifications ( request ) ; }
public final boolean equals ( Object o ) { if ( o instanceof AnyObjectId ) { return equals ( ( AnyObjectId ) o ) ; } return false ; }
public DescribeConfigurationSettingsRequest ( String applicationName ) { setApplicationName ( applicationName ) ; }
public ET next ( ) { if ( expectedModCount == list . modCount ) { LinkedList . Link < ET > next = link . next ; if ( next != list . voidLink ) { lastLink = link = next ; pos ++ ; return link . data ; } throw new NoSuchElementException ( ) ; } throw new ConcurrentModificationException ( ) ; }
public CreateConfigurationResult createConfiguration ( CreateConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateConfiguration ( request ) ; }
public ResetClusterParameterGroupResult resetClusterParameterGroup ( ResetClusterParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeResetClusterParameterGroup ( request ) ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ PASSWORD ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . password ▁ = ▁ " ) . append ( HexDump . shortToHex ( field_1_password ) ) . append ( " \ n " ) ; buffer . append ( " [ / PASSWORD ] \ n " ) ; return buffer . toString ( ) ; }
public SendTemplatedEmailResult sendTemplatedEmail ( SendTemplatedEmailRequest request ) { request = beforeClientExecution ( request ) ; return executeSendTemplatedEmail ( request ) ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof Predicate ) ) return false ; if ( this == obj ) return true ; Predicate p = ( Predicate ) obj ; return this . ruleIndex == p . ruleIndex && this . predIndex == p . predIndex && this . isCtxDependent == p . isCtxDependent ; }
public void writeBoolean ( boolean value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeBoolean ( value ) ; }
public boolean checkPosition ( int position ) { Iterator < PositionSpan > positionSpanIt = positionSpans . iterator ( ) ; while ( positionSpanIt . hasNext ( ) ) { PositionSpan posSpan = positionSpanIt . next ( ) ; if ( ( ( position >= posSpan . start ) && ( position <= posSpan . end ) ) ) { return true ; } } return false ; }
public static int log ( long x , int base ) { if ( base <= 1 ) { throw new IllegalArgumentException ( " base ▁ must ▁ be ▁ > ▁ 1 " ) ; } int ret = 0 ; while ( x >= base ) { x /= base ; ret ++ ; } return ret ; }
public final LongBuffer get ( long [ ] dst , int dstOffset , int longCount ) { if ( longCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } System . arraycopy ( backingArray , offset + position , dst , dstOffset , longCount ) ; position += longCount ; return this ; }
public boolean equals ( Object obj ) { return obj == this ; }
public void exportRepository ( String name , Repository db ) { exports . put ( nameWithDotGit ( name ) , db ) ; }
public void println ( long l ) { println ( String . valueOf ( l ) ) ; }
public HSSFFormulaEvaluator createFormulaEvaluator ( ) { return new HSSFFormulaEvaluator ( workbook ) ; }
public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof IntervalSet ) ) { return false ; } IntervalSet other = ( IntervalSet ) obj ; return this . intervals . equals ( other . intervals ) ; }
public FileMode getIndexFileMode ( DirCacheIterator indexIter ) { final FileMode wtMode = getEntryFileMode ( ) ; if ( indexIter == null ) { return wtMode ; } final FileMode iMode = indexIter . getEntryFileMode ( ) ; if ( getOptions ( ) . isFileMode ( ) && iMode != FileMode . GITLINK && iMode != FileMode . TREE ) { return wtMode ; } if ( ! getOptions ( ) . isFileMode ( ) ) { if ( FileMode . REGULAR_FILE == wtMode && FileMode . EXECUTABLE_FILE == iMode ) { return iMode ; } if ( FileMode . EXECUTABLE_FILE == wtMode && FileMode . REGULAR_FILE == iMode ) { return iMode ; } } if ( FileMode . GITLINK == iMode && FileMode . TREE == wtMode && ! getOptions ( ) . isDirNoGitLinks ( ) ) { return iMode ; } if ( FileMode . TREE == iMode && FileMode . GITLINK == wtMode ) { return iMode ; } return wtMode ; }
public CreateScheduledActionResult createScheduledAction ( CreateScheduledActionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateScheduledAction ( request ) ; }
public PackConfig getConfig ( ) { return config ; }
public CharBuffer put ( char c ) { throw new ReadOnlyBufferException ( ) ; }
public DeleteDistributionRequest ( String id , String ifMatch ) { setId ( id ) ; setIfMatch ( ifMatch ) ; }
public static long pop_andnot ( long [ ] arr1 , long [ ] arr2 , int wordOffset , int numWords ) { long popCount = 0 ; for ( int i = wordOffset , end = wordOffset + numWords ; i < end ; ++ i ) { popCount += Long . bitCount ( arr1 [ i ] & ~ arr2 [ i ] ) ; } return popCount ; }
public boolean include ( TreeWalk walker ) { return true ; }
public DescribeReservedDBInstancesOfferingsResult describeReservedDBInstancesOfferings ( ) { return describeReservedDBInstancesOfferings ( new DescribeReservedDBInstancesOfferingsRequest ( ) ) ; }
public ByteVector ( byte [ ] a ) { blockSize = DEFAULT_BLOCK_SIZE ; array = a ; n = 0 ; }
public Appendable append ( CharSequence csq ) { return append ( csq , 0 , csq . length ( ) ) ; }
public String getLookaheadName ( TokenStream input ) { return getTokenName ( input . LA ( 1 ) ) ; }
public static final ObjectId fromRaw ( byte [ ] bs ) { return fromRaw ( bs , 0 ) ; }
public GutsRecord ( RecordInputStream in ) { field_1_left_row_gutter = in . readShort ( ) ; field_2_top_col_gutter = in . readShort ( ) ; field_3_row_level_max = in . readShort ( ) ; field_4_col_level_max = in . readShort ( ) ; }
public GermanMinimalStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public DescribeActiveReceiptRuleSetResult describeActiveReceiptRuleSet ( DescribeActiveReceiptRuleSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeActiveReceiptRuleSet ( request ) ; }
public GetGeoLocationResult getGeoLocation ( GetGeoLocationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetGeoLocation ( request ) ; }
public KStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public PublishRequest ( String topicArn , String message ) { setTopicArn ( topicArn ) ; setMessage ( message ) ; }
public void replace ( int start , int limit , String text ) { final int charsLen = text . length ( ) ; final int newLength = shiftForReplace ( start , limit , charsLen ) ; text . getChars ( 0 , charsLen , buffer , start ) ; token . setLength ( length = newLength ) ; }
public DescribeInternetGatewaysResult describeInternetGateways ( ) { return describeInternetGateways ( new DescribeInternetGatewaysRequest ( ) ) ; }
public ListQualificationTypesResult listQualificationTypes ( ListQualificationTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeListQualificationTypes ( request ) ; }
public DetachInstancesResult detachInstances ( DetachInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachInstances ( request ) ; }
public boolean include ( TreeWalk walker ) { final int n = walker . getTreeCount ( ) ; if ( n == 1 ) return true ; final int m = walker . getRawMode ( baseTree ) ; for ( int i = 1 ; i < n ; i ++ ) if ( walker . getRawMode ( i ) != m || ! walker . idEqual ( i , baseTree ) ) return true ; return false ; }
public List < MatchingDocs > getMatchingDocs ( ) { List < MatchingDocs > matchingDocs = super . getMatchingDocs ( ) ; if ( totalHits == NOT_CALCULATED ) { totalHits = 0 ; for ( MatchingDocs md : matchingDocs ) { totalHits += md . totalHits ; } } if ( totalHits <= sampleSize ) { return matchingDocs ; } if ( sampledDocs == null ) { samplingRate = ( 1.0 * sampleSize ) / totalHits ; sampledDocs = createSampledDocs ( matchingDocs ) ; } return sampledDocs ; }
public CreateDataSourceFromS3Result createDataSourceFromS3 ( CreateDataSourceFromS3Request request ) { request = beforeClientExecution ( request ) ; return executeCreateDataSourceFromS3 ( request ) ; }
public UpdateFleetMetadataResult updateFleetMetadata ( UpdateFleetMetadataRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFleetMetadata ( request ) ; }
public ObjectId getNewObjectId ( ) { return newValue ; }
public long ramBytesUsed ( ) { long sizeInBytes = ( ( termBytesReader != null ) ? termBytesReader . ramBytesUsed ( ) : 0 ) ; for ( FieldIndexData entry : fields . values ( ) ) { sizeInBytes += entry . ramBytesUsed ( ) ; } return sizeInBytes ; }
public StringBuilder append ( char c ) { append0 ( c ) ; return this ; }
public void unread ( int oneChar ) throws IOException { synchronized ( lock ) { checkNotClosed ( ) ; if ( pos == 0 ) { throw new IOException ( " Pushback ▁ buffer ▁ full " ) ; } buf [ -- pos ] = ( char ) oneChar ; } }
public QueryFaceRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " QueryFace " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public ProductDomain ( String product , String domain ) { this . productName = product ; this . domainName = domain ; }
public void disableRefLog ( ) { refLogMessage = null ; refLogIncludeResult = false ; }
public static TaxonomyWriterCache defaultTaxonomyWriterCache ( ) { return new UTF8TaxonomyWriterCache ( ) ; }
public PushCommand setDryRun ( boolean dryRun ) { checkCallable ( ) ; this . dryRun = dryRun ; return this ; }
public ProcessBuilder runInShell ( String cmd , String [ ] args ) { List < String > argv = new ArrayList <> ( 3 + args . length ) ; argv . add ( " cmd . exe " ) ; argv . add ( " / c " ) ; argv . add ( cmd ) ; argv . addAll ( Arrays . asList ( args ) ) ; ProcessBuilder proc = new ProcessBuilder ( ) ; proc . command ( argv ) ; return proc ; }
public NameCommentRecord ( final RecordInputStream ris ) { field_1_record_type = ris . readShort ( ) ; field_2_frt_cell_ref_flag = ris . readShort ( ) ; field_3_reserved = ris . readLong ( ) ; final int field_4_name_length = ris . readShort ( ) ; final int field_5_comment_length = ris . readShort ( ) ; if ( ris . readByte ( ) == 0 ) { field_6_name_text = StringUtil . readCompressedUnicode ( ris , field_4_name_length ) ; } else { field_6_name_text = StringUtil . readUnicodeLE ( ris , field_4_name_length ) ; } if ( ris . readByte ( ) == 0 ) { field_7_comment_text = StringUtil . readCompressedUnicode ( ris , field_5_comment_length ) ; } else { field_7_comment_text = StringUtil . readUnicodeLE ( ris , field_5_comment_length ) ; } }
public void onPull ( float deltaDistance ) { final long now = AnimationUtils . currentAnimationTimeMillis ( ) ; if ( mState == STATE_PULL_DECAY && now - mStartTime < mDuration ) { return ; } if ( mState != STATE_PULL ) { mGlowScaleY = PULL_GLOW_BEGIN ; } mState = STATE_PULL ; mStartTime = now ; mDuration = PULL_TIME ; mPullDistance += deltaDistance ; float distance = Math . abs ( mPullDistance ) ; mEdgeAlpha = mEdgeAlphaStart = Math . max ( PULL_EDGE_BEGIN , Math . min ( distance , MAX_ALPHA ) ) ; mEdgeScaleY = mEdgeScaleYStart = Math . max ( HELD_EDGE_SCALE_Y , Math . min ( distance * PULL_DISTANCE_EDGE_FACTOR , 1. f ) ) ; mGlowAlpha = mGlowAlphaStart = Math . min ( MAX_ALPHA , mGlowAlpha + ( Math . abs ( deltaDistance ) * PULL_DISTANCE_ALPHA_GLOW_FACTOR ) ) ; float glowChange = Math . abs ( deltaDistance ) ; if ( deltaDistance > 0 && mPullDistance < 0 ) { glowChange = - glowChange ; } if ( mPullDistance == 0 ) { mGlowScaleY = 0 ; } mGlowScaleY = mGlowScaleYStart = Math . min ( MAX_GLOW_HEIGHT , Math . max ( 0 , mGlowScaleY + glowChange * PULL_DISTANCE_GLOW_FACTOR ) ) ; mEdgeAlphaFinish = mEdgeAlpha ; mEdgeScaleYFinish = mEdgeScaleY ; mGlowAlphaFinish = mGlowAlpha ; mGlowScaleYFinish = mGlowScaleY ; }
public URIish setPath ( String n ) { final URIish r = new URIish ( this ) ; r . path = n ; r . rawPath = n ; return r ; }
public UpdateTemplateResult updateTemplate ( UpdateTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTemplate ( request ) ; }
public void encode ( long [ ] values , int valuesOffset , byte [ ] blocks , int blocksOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = encode ( values , valuesOffset ) ; valuesOffset += valueCount ; blocksOffset = writeLong ( block , blocks , blocksOffset ) ; } }
public ListDomainDeliverabilityCampaignsResult listDomainDeliverabilityCampaigns ( ListDomainDeliverabilityCampaignsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDomainDeliverabilityCampaigns ( request ) ; }
public void setReuseObjects ( boolean reuseObjects ) { this . reuseObjects = reuseObjects ; }
public DiffFormatter ( OutputStream out ) { this . out = out ; }
public ExpectedAttributeValue ( Boolean exists ) { setExists ( exists ) ; }
public FieldsProducer fieldsProducer ( SegmentReadState state ) throws IOException { PostingsReaderBase postingsReader = new Lucene84PostingsReader ( state ) ; boolean success = false ; try { FieldsProducer ret = new FSTTermsReader ( state , postingsReader ) ; success = true ; return ret ; } finally { if ( ! success ) { IOUtils . closeWhileHandlingException ( postingsReader ) ; } } }
public ListSubscribedWorkteamsResult listSubscribedWorkteams ( ListSubscribedWorkteamsRequest request ) { request = beforeClientExecution ( request ) ; return executeListSubscribedWorkteams ( request ) ; }
public BatchDeleteAttributesRequest ( String domainName , java . util . List < DeletableItem > items ) { setDomainName ( domainName ) ; setItems ( items ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeByte ( _value ? 1 : 0 ) ; }
public NavigableMap < K , V > descendingMap ( ) { return new BoundedMap ( ! ascending , from , fromBound , to , toBound ) ; }
public ByteBuffer putLong ( long value ) { int newPosition = position + SizeOf . LONG ; if ( newPosition > limit ) { throw new BufferOverflowException ( ) ; } Memory . pokeLong ( backingArray , offset + position , value , order ) ; position = newPosition ; return this ; }
public CFRecordsAggregate get ( int index ) { checkIndex ( index ) ; return _cfHeaders . get ( index ) ; }
public long get ( int index ) { final int o = index / 9 ; final int b = index % 9 ; final int shift = b * 7 ; return ( blocks [ o ] >>> shift ) & 127L ; }
public GetSegmentsResult getSegments ( GetSegmentsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSegments ( request ) ; }
public DeleteVpcEndpointsResult deleteVpcEndpoints ( DeleteVpcEndpointsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVpcEndpoints ( request ) ; }
public String toString ( ) { switch ( getCellTypeEnum ( ) ) { case BLANK : return " " ; case BOOLEAN : return getBooleanCellValue ( ) ? " TRUE " : " FALSE " ; case ERROR : return ErrorEval . getText ( ( ( BoolErrRecord ) _record ) . getErrorValue ( ) ) ; case FORMULA : return getCellFormula ( ) ; case NUMERIC : if ( DateUtil . isCellDateFormatted ( this ) ) { SimpleDateFormat sdf = new SimpleDateFormat ( " dd - MMM - yyyy " , LocaleUtil . getUserLocale ( ) ) ; sdf . setTimeZone ( LocaleUtil . getUserTimeZone ( ) ) ; return sdf . format ( getDateCellValue ( ) ) ; } return String . valueOf ( getNumericCellValue ( ) ) ; case STRING : return getStringCellValue ( ) ; default : return " Unknown ▁ Cell ▁ Type : ▁ " + getCellType ( ) ; } }
public List <? extends HunkHeader > getHunks ( ) { if ( hunks == null ) return Collections . emptyList ( ) ; return hunks ; }
public ObjectId toObjectId ( ) { ensureId ( ) ; return idBuffer . toObjectId ( ) ; }
public ListQueuesRequest ( String queueNamePrefix ) { setQueueNamePrefix ( queueNamePrefix ) ; }
public AcceptTransitGatewayPeeringAttachmentResult acceptTransitGatewayPeeringAttachment ( AcceptTransitGatewayPeeringAttachmentRequest request ) { request = beforeClientExecution ( request ) ; return executeAcceptTransitGatewayPeeringAttachment ( request ) ; }
public String toString ( ) { final int n = length ( ) ; final StringBuilder b = new StringBuilder ( n ) ; for ( int i = 0 ; i < n ; i ++ ) b . append ( charAt ( i ) ) ; return b . toString ( ) ; }
public String toString ( String field ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " ( " ) ; for ( int i = 0 ; i < disjuncts . length ; i ++ ) { Query subquery = disjuncts [ i ] ; if ( subquery instanceof BooleanQuery ) { buffer . append ( " ( " ) ; buffer . append ( subquery . toString ( field ) ) ; buffer . append ( " ) " ) ; } else buffer . append ( subquery . toString ( field ) ) ; if ( i != disjuncts . length - 1 ) buffer . append ( " ▁ | ▁ " ) ; } buffer . append ( " ) " ) ; if ( tieBreakerMultiplier != 0.0f ) { buffer . append ( " ~ " ) ; buffer . append ( tieBreakerMultiplier ) ; } return buffer . toString ( ) ; }
@ Override public boolean isEmpty ( ) { return c . isEmpty ( ) ; }
public String getContentDisposition ( ) { return contentDisposition ; }
public DescribeHsmClientCertificatesResult describeHsmClientCertificates ( ) { return describeHsmClientCertificates ( new DescribeHsmClientCertificatesRequest ( ) ) ; }
public static int [ ] grow ( int [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Integer . BYTES ) ) ; } else return array ; }
public String highlightTerm ( String originalText , TokenGroup tokenGroup ) { if ( tokenGroup . getTotalScore ( ) <= 0 ) { return originalText ; } StringBuilder returnBuffer = new StringBuilder ( preTag . length ( ) + originalText . length ( ) + postTag . length ( ) ) ; returnBuffer . append ( preTag ) ; returnBuffer . append ( originalText ) ; returnBuffer . append ( postTag ) ; return returnBuffer . toString ( ) ; }
public LimitTokenCountFilter ( TokenStream in , int maxTokenCount , boolean consumeAllTokens ) { super ( in ) ; if ( maxTokenCount < 1 ) { throw new IllegalArgumentException ( " maxTokenCount ▁ must ▁ be ▁ greater ▁ than ▁ zero " ) ; } this . maxTokenCount = maxTokenCount ; this . consumeAllTokens = consumeAllTokens ; }
public void encode ( int [ ] values , int valuesOffset , byte [ ] blocks , int blocksOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = encode ( values , valuesOffset ) ; valuesOffset += valueCount ; blocksOffset = writeLong ( block , blocks , blocksOffset ) ; } }
public TokenFilter create ( TokenStream input ) { return new ClassicFilter ( input ) ; }
public boolean isAllowThin ( ) { return allowThin ; }
public boolean contains ( Object o ) { if ( ! ( o instanceof Entry ) ) return false ; Entry <? , ?> e = ( Entry <? , ?> ) o ; return containsMapping ( e . getKey ( ) , e . getValue ( ) ) ; }
public void add ( long v ) throws IOException { assert PackedInts . unsignedBitsRequired ( v ) <= bitsPerValue ; assert ! finished ; if ( valueCount != - 1 && written >= valueCount ) { throw new EOFException ( " Writing ▁ past ▁ end ▁ of ▁ stream " ) ; } nextValues [ off ++ ] = v ; if ( off == nextValues . length ) { flush ( ) ; } ++ written ; }
public GetOnlineServiceResultRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " GetOnlineServiceResult " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public void setBigFileThreshold ( int bigFileThreshold ) { this . bigFileThreshold = bigFileThreshold ; }
public boolean isEmpty ( ) { return size == 0 ; }
public int compareTo ( ScoreTerm other ) { if ( term . bytesEquals ( other . term ) ) return 0 ; if ( this . boost == other . boost ) return other . term . compareTo ( this . term ) ; else return Float . compare ( this . boost , other . boost ) ; }
public int codePointCount ( int start , int end ) { if ( start < 0 || end > count || start > end ) { throw startEndAndLength ( start , end ) ; } return Character . codePointCount ( value , start , end - start ) ; }
public String [ ] getCommitNames ( ) { return commitNames ; }
public boolean isEmpty ( ) { if ( sizeIsValid ) return 0 == size ; return ! iterator ( ) . hasNext ( ) ; }
public boolean isBorder ( ) { return border . isSet ( field_1_options ) ; }
public DeleteLaunchTemplateVersionsResult deleteLaunchTemplateVersions ( DeleteLaunchTemplateVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLaunchTemplateVersions ( request ) ; }
public DescribeDeviceResult describeDevice ( DescribeDeviceRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDevice ( request ) ; }
public static Class <? extends TokenizerFactory > lookupClass ( String name ) { return loader . lookupClass ( name ) ; }
public CreateParameterGroupResult createParameterGroup ( CreateParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateParameterGroup ( request ) ; }
public FieldsQuery ( SrndQuery q , String fieldName , char fieldOp ) { this . q = q ; fieldNames = new ArrayList <> ( ) ; fieldNames . add ( fieldName ) ; this . fieldOp = fieldOp ; }
public DescribeReservedCacheNodesOfferingsResult describeReservedCacheNodesOfferings ( DescribeReservedCacheNodesOfferingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReservedCacheNodesOfferings ( request ) ; }
public String toString ( ) { final StringBuilder s = new StringBuilder ( ) ; s . append ( Constants . typeString ( getType ( ) ) ) ; s . append ( ' ▁ ' ) ; s . append ( name ( ) ) ; s . append ( ' ▁ ' ) ; appendCoreFlags ( s ) ; return s . toString ( ) ; }
public UpdateTableReplicaAutoScalingResult updateTableReplicaAutoScaling ( UpdateTableReplicaAutoScalingRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTableReplicaAutoScaling ( request ) ; }
public ValidateConfigurationResult validateConfiguration ( ValidateConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeValidateConfiguration ( request ) ; }
public ModifyReservedInstancesResult modifyReservedInstances ( ModifyReservedInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyReservedInstances ( request ) ; }
public void ReInit ( CharStream stream , int lexState ) { ReInit ( stream ) ; SwitchTo ( lexState ) ; }
public DeleteIdentityResult deleteIdentity ( DeleteIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteIdentity ( request ) ; }
public PackConfig ( Config cfg ) { fromConfig ( cfg ) ; }
public StringBuilder append ( float f ) { RealToString . getInstance ( ) . appendFloat ( this , f ) ; return this ; }
public DeleteBrokerResult deleteBroker ( DeleteBrokerRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteBroker ( request ) ; }
public static String stripTags ( StringBuilder buf , int start ) { return stripTags ( buf . substring ( start ) , 0 ) ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { double idf = 0d ; List < Explanation > subs = new ArrayList <> ( ) ; for ( final TermStatistics stat : termStats ) { Explanation idfExplain = idfExplain ( collectionStats , stat ) ; subs . add ( idfExplain ) ; idf += idfExplain . getValue ( ) . floatValue ( ) ; } return Explanation . match ( ( float ) idf , " idf ( ) , ▁ sum ▁ of : " , subs ) ; }
public CalcCountRecord clone ( ) { return copy ( ) ; }
public boolean matches ( ParseTree tree , String pattern , int patternRuleIndex ) { ParseTreePattern p = compile ( pattern , patternRuleIndex ) ; return matches ( tree , p ) ; }
public int addConditionalFormatting ( CellRangeAddress [ ] regions , HSSFConditionalFormattingRule rule1 ) { return addConditionalFormatting ( regions , rule1 == null ? null : new HSSFConditionalFormattingRule [ ] { rule1 } ) ; }
public long hash1 ( char carray [ ] ) { final long p = 1099511628211L ; long hash = 0xcbf29ce484222325L ; for ( int i = 0 ; i < carray . length ; i ++ ) { char d = carray [ i ] ; hash = ( hash ^ ( d & 0x00FF ) ) * p ; hash = ( hash ^ ( d >> 8 ) ) * p ; } return hash ; }
public PutAnomalyDetectorResult putAnomalyDetector ( PutAnomalyDetectorRequest request ) { request = beforeClientExecution ( request ) ; return executePutAnomalyDetector ( request ) ; }
public AssociateTransitGatewayRouteTableResult associateTransitGatewayRouteTable ( AssociateTransitGatewayRouteTableRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateTransitGatewayRouteTable ( request ) ; }
public List < String > getIPv4Association ( String publicIp ) { return EC2MetadataUtils . getItems ( EC2_METADATA_ROOT + path + " ipv4 - associations / " + publicIp ) ; }
public void reset ( ) { count = 0 ; assert forwardCount == 0 : " pos = " + pos + " ▁ forwardCount = " + forwardCount ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_recalc ) ; }
public final void addConsumingCell ( FormulaCellCacheEntry cellLoc ) { _consumingCells . add ( cellLoc ) ; }
public DeleteUserRequest ( String userName ) { setUserName ( userName ) ; }
public SingleValueVector ( ValueEval value ) { _value = value ; }
public DeleteMethodResult deleteMethod ( DeleteMethodRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMethod ( request ) ; }
public static CompareResult valueOf ( int simpleCompareResult ) { if ( simpleCompareResult < 0 ) { return LESS_THAN ; } if ( simpleCompareResult > 0 ) { return GREATER_THAN ; } return EQUAL ; }
public CreatePresetResult createPreset ( CreatePresetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePreset ( request ) ; }
public S3Origin ( String domainName ) { setDomainName ( domainName ) ; }
public HTMLStripCharFilter create ( Reader input ) { HTMLStripCharFilter charFilter ; if ( null == escapedTags ) { charFilter = new HTMLStripCharFilter ( input ) ; } else { charFilter = new HTMLStripCharFilter ( input , escapedTags ) ; } return charFilter ; }
public void setCurrent ( char text [ ] , int length ) { current = text ; cursor = 0 ; limit = length ; limit_backward = 0 ; bra = cursor ; ket = limit ; }
public DisableTransitGatewayRouteTablePropagationResult disableTransitGatewayRouteTablePropagation ( DisableTransitGatewayRouteTablePropagationRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableTransitGatewayRouteTablePropagation ( request ) ; }
public UpdateTagsForDomainResult updateTagsForDomain ( UpdateTagsForDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTagsForDomain ( request ) ; }
public ObjectId getPeeledObjectId ( ) { return peeledObjectId ; }
public LexerActionExecutor ( LexerAction [ ] lexerActions ) { this . lexerActions = lexerActions ; int hash = MurmurHash . initialize ( ) ; for ( LexerAction lexerAction : lexerActions ) { hash = MurmurHash . update ( hash , lexerAction ) ; } this . hashCode = MurmurHash . finish ( hash , lexerActions . length ) ; }
public SetAlarmStateResult setAlarmState ( SetAlarmStateRequest request ) { request = beforeClientExecution ( request ) ; return executeSetAlarmState ( request ) ; }
public final File getFile ( ) { return configFile ; }
public DescribeUsersResult describeUsers ( DescribeUsersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeUsers ( request ) ; }
public PagedMutable ( long size , int pageSize , int bitsPerValue , float acceptableOverheadRatio ) { this ( size , pageSize , PackedInts . fastestFormatAndBits ( pageSize , bitsPerValue , acceptableOverheadRatio ) ) ; fillPages ( ) ; }
public CFHeaderRecord ( ) { createEmpty ( ) ; }
public GetDataSourceResult getDataSource ( GetDataSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDataSource ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeDouble ( field_1_margin ) ; }
public DeleteProfilingGroupResult deleteProfilingGroup ( DeleteProfilingGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteProfilingGroup ( request ) ; }
public IntBuffer compact ( ) { System . arraycopy ( backingArray , position + offset , backingArray , offset , remaining ( ) ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public void setup ( int id , int progress , boolean fromUser ) { mId = id ; mProgress = progress ; mFromUser = fromUser ; }
public static FuncVarPtg create ( LittleEndianInput in ) { return create ( in . readByte ( ) , in . readUShort ( ) ) ; }
public CreateAttendeeResult createAttendee ( CreateAttendeeRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAttendee ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ EXTERNALNAME ] \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . options ▁ = ▁ " ) . append ( field_1_option_flag ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . ix ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( field_2_ixals ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . name ▁ ▁ ▁ ▁ = ▁ " ) . append ( field_4_name ) . append ( " \ n " ) ; if ( field_5_name_definition != null ) { Ptg [ ] ptgs = field_5_name_definition . getTokens ( ) ; for ( Ptg ptg : ptgs ) { sb . append ( " ▁ ▁ ▁ ▁ . namedef ▁ = ▁ " ) . append ( ptg ) . append ( ptg . getRVAType ( ) ) . append ( " \ n " ) ; } } sb . append ( " [ / EXTERNALNAME ] \ n " ) ; return sb . toString ( ) ; }
public DescribeDBClusterParameterGroupsResult describeDBClusterParameterGroups ( DescribeDBClusterParameterGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBClusterParameterGroups ( request ) ; }
public PropertyTable ( HeaderBlock headerBlock ) { _header_block = headerBlock ; _bigBigBlockSize = headerBlock . getBigBlockSize ( ) ; addProperty ( new RootProperty ( ) ) ; }
public int getIndexOfName ( String name ) { for ( int i = 0 ; i < _externalNameRecords . length ; i ++ ) { if ( _externalNameRecords [ i ] . getText ( ) . equalsIgnoreCase ( name ) ) { return i ; } } return - 1 ; }
public AbortVaultLockResult abortVaultLock ( AbortVaultLockRequest request ) { request = beforeClientExecution ( request ) ; return executeAbortVaultLock ( request ) ; }
public CreateBatchPredictionResult createBatchPrediction ( CreateBatchPredictionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateBatchPrediction ( request ) ; }
public ListHostedZonesByNameResult listHostedZonesByName ( ListHostedZonesByNameRequest request ) { request = beforeClientExecution ( request ) ; return executeListHostedZonesByName ( request ) ; }
public final PersonIdent getAuthorIdent ( ) { final byte [ ] raw = buffer ; final int nameB = RawParseUtils . author ( raw , 0 ) ; if ( nameB < 0 ) return null ; return RawParseUtils . parsePersonIdent ( raw , nameB ) ; }
public RecordLifecycleActionHeartbeatResult recordLifecycleActionHeartbeat ( RecordLifecycleActionHeartbeatRequest request ) { request = beforeClientExecution ( request ) ; return executeRecordLifecycleActionHeartbeat ( request ) ; }
public void flush ( ) { if ( logger != null ) { logger . flush ( ) ; } }
public GetLoadBalancerTlsCertificatesResult getLoadBalancerTlsCertificates ( GetLoadBalancerTlsCertificatesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLoadBalancerTlsCertificates ( request ) ; }
public ExtSSTRecord createExtSSTRecord ( int sstOffset ) { if ( bucketAbsoluteOffsets == null || bucketRelativeOffsets == null ) { throw new IllegalStateException ( " SST ▁ record ▁ has ▁ not ▁ yet ▁ been ▁ serialized . " ) ; } ExtSSTRecord extSST = new ExtSSTRecord ( ) ; extSST . setNumStringsPerBucket ( ( short ) 8 ) ; int [ ] absoluteOffsets = bucketAbsoluteOffsets . clone ( ) ; int [ ] relativeOffsets = bucketRelativeOffsets . clone ( ) ; for ( int i = 0 ; i < absoluteOffsets . length ; i ++ ) { absoluteOffsets [ i ] += sstOffset ; } extSST . setBucketOffsets ( absoluteOffsets , relativeOffsets ) ; return extSST ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; }
public ListMultipartUploadsResult listMultipartUploads ( ListMultipartUploadsRequest request ) { request = beforeClientExecution ( request ) ; return executeListMultipartUploads ( request ) ; }
public BytesRef add ( BytesRef prefix , BytesRef output ) { assert prefix != null ; assert output != null ; if ( prefix == NO_OUTPUT ) { return output ; } else if ( output == NO_OUTPUT ) { return prefix ; } else { assert prefix . length > 0 ; assert output . length > 0 ; BytesRef result = new BytesRef ( prefix . length + output . length ) ; System . arraycopy ( prefix . bytes , prefix . offset , result . bytes , 0 , prefix . length ) ; System . arraycopy ( output . bytes , output . offset , result . bytes , prefix . length , output . length ) ; result . length = prefix . length + output . length ; return result ; } }
public void setParams ( String params ) { super . setParams ( params ) ; doWait = Boolean . valueOf ( params ) . booleanValue ( ) ; }
public RunBackgroundTask ( PerfTask task , boolean letChildReport ) { this . task = task ; this . letChildReport = letChildReport ; }
public GridsetRecord clone ( ) { return copy ( ) ; }
public BoundSheetRecord ( String sheetname ) { field_2_option_flags = 0 ; setSheetname ( sheetname ) ; }
public MFADevice ( String userName , String serialNumber , java . util . Date enableDate ) { setUserName ( userName ) ; setSerialNumber ( serialNumber ) ; setEnableDate ( enableDate ) ; }
public DescribeStreamSummaryResult describeStreamSummary ( DescribeStreamSummaryRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStreamSummary ( request ) ; }
public ListClusterJobsResult listClusterJobs ( ListClusterJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListClusterJobs ( request ) ; }
public int compareTo ( String version ) { long gen = Long . parseLong ( version , RADIX ) ; long commitGen = commit . getGeneration ( ) ; return commitGen < gen ? - 1 : ( commitGen > gen ? 1 : 0 ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " " ; StringBuilder sb = new StringBuilder ( ) ; String filler = " " ; for ( QueryNode child : getChildren ( ) ) { sb . append ( filler ) . append ( child . toQueryString ( escapeSyntaxParser ) ) ; filler = " , " ; } return " [ MTP [ " + sb . toString ( ) + " ] ] " ; }
public final float readFloat ( ) throws IOException { return Float . intBitsToFloat ( readInt ( ) ) ; }
public boolean isSubTotal ( int rowIndex , int columnIndex ) { boolean subtotal = false ; EvaluationCell cell = getSheet ( ) . getCell ( rowIndex , columnIndex ) ; if ( cell != null && cell . getCellType ( ) == CellType . FORMULA ) { EvaluationWorkbook wb = _bookEvaluator . getWorkbook ( ) ; for ( Ptg ptg : wb . getFormulaTokens ( cell ) ) { if ( ptg instanceof FuncVarPtg ) { FuncVarPtg f = ( FuncVarPtg ) ptg ; if ( " SUBTOTAL " . equals ( f . getName ( ) ) ) { subtotal = true ; break ; } } } } return subtotal ; }
public CreateMonitoringScheduleResult createMonitoringSchedule ( CreateMonitoringScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateMonitoringSchedule ( request ) ; }
public TokenStream create ( TokenStream input ) { return new CzechStemFilter ( input ) ; }
public GetSpeechSynthesisTaskResult getSpeechSynthesisTask ( GetSpeechSynthesisTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSpeechSynthesisTask ( request ) ; }
public FuzzySet downsize ( FieldInfo fieldInfo , FuzzySet initialSet ) { float targetMaxSaturation = 0.1f ; return initialSet . downsize ( targetMaxSaturation ) ; }
public MonitorInstancesResult monitorInstances ( MonitorInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeMonitorInstances ( request ) ; }
public ListDocumentClassifiersResult listDocumentClassifiers ( ListDocumentClassifiersRequest request ) { request = beforeClientExecution ( request ) ; return executeListDocumentClassifiers ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { buffer . append ( fields [ i ] . toString ( ) ) ; if ( ( i + 1 ) < fields . length ) buffer . append ( ' , ' ) ; } return buffer . toString ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_axisType ) ; out . writeInt ( field_2_reserved1 ) ; out . writeInt ( field_3_reserved2 ) ; out . writeInt ( field_4_reserved3 ) ; out . writeInt ( field_5_reserved4 ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 12 ) | ( byte1 << 4 ) | ( byte2 >>> 4 ) ; final long byte3 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte4 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte2 & 15 ) << 16 ) | ( byte3 << 8 ) | byte4 ; } }
public StashDropCommand setStashRef ( int stashRef ) { if ( stashRef < 0 ) throw new IllegalArgumentException ( ) ; stashRefEntry = stashRef ; return this ; }
public CreateHITWithHITTypeResult createHITWithHITType ( CreateHITWithHITTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateHITWithHITType ( request ) ; }
public void setPlaceholder ( int index , Ptg token ) { if ( _ptgs [ index ] != null ) { throw new IllegalStateException ( " Invalid ▁ placeholder ▁ index ▁ ( " + index + " ) " ) ; } _ptgs [ index ] = token ; }
public Area3DPtg ( LittleEndianInput in ) { field_1_index_extern_sheet = in . readShort ( ) ; readCoordinates ( in ) ; }
public UpdateNotebookInstanceResult updateNotebookInstance ( UpdateNotebookInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateNotebookInstance ( request ) ; }
public org . apache . poi . hssf . record . Record findFirstRecordBySid ( short sid ) { for ( org . apache . poi . hssf . record . Record record : records . getRecords ( ) ) { if ( record . getSid ( ) == sid ) { return record ; } } return null ; }
public void fromString ( byte [ ] buf , int offset ) { fromHexString ( buf , offset ) ; }
public AttachInstancesResult attachInstances ( AttachInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachInstances ( request ) ; }
public NotifyWorkersResult notifyWorkers ( NotifyWorkersRequest request ) { request = beforeClientExecution ( request ) ; return executeNotifyWorkers ( request ) ; }
public CommitCommand commit ( ) { return new CommitCommand ( repo ) ; }
public BufferedIndexInput clone ( ) { BufferedIndexInput clone = ( BufferedIndexInput ) super . clone ( ) ; clone . buffer = null ; clone . bufferLength = 0 ; clone . bufferPosition = 0 ; clone . bufferStart = getFilePointer ( ) ; return clone ; }
public boolean hasEntry ( String name ) { return name != null && _byname . containsKey ( name ) ; }
public MorfologikFilterFactory ( Map < String , String > args ) { super ( args ) ; final String DICTIONARY_RESOURCE_ATTRIBUTE = " dictionary - resource " ; String dictionaryResource = get ( args , DICTIONARY_RESOURCE_ATTRIBUTE ) ; if ( dictionaryResource != null && ! dictionaryResource . isEmpty ( ) ) { throw new IllegalArgumentException ( " The ▁ " + DICTIONARY_RESOURCE_ATTRIBUTE + " ▁ attribute ▁ is ▁ no ▁ " + " longer ▁ supported . ▁ Use ▁ the ▁ ' " ▁ + ▁ DICTIONARY □ ATTRIBUTE ▁ + ▁ " ' ▁ attribute ▁ instead ▁ ( see ▁ LUCENE - 6833 ) . " ) ; } resourceName = get ( args , DICTIONARY_ATTRIBUTE ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static DVConstraint createNumericConstraint ( int validationType , int comparisonOperator , String expr1 , String expr2 ) { switch ( validationType ) { case ValidationType . ANY : if ( expr1 != null || expr2 != null ) { throw new IllegalArgumentException ( " expr1 ▁ and ▁ expr2 ▁ must ▁ be ▁ null ▁ for ▁ validation ▁ type ▁ ' any ' " ) ; } break ; case ValidationType . DECIMAL : case ValidationType . INTEGER : case ValidationType . TEXT_LENGTH : if ( expr1 == null ) { throw new IllegalArgumentException ( " expr1 ▁ must ▁ be ▁ supplied " ) ; } OperatorType . validateSecondArg ( comparisonOperator , expr2 ) ; break ; default : throw new IllegalArgumentException ( " Validation ▁ Type ▁ ( " + validationType + " ) ▁ not ▁ supported ▁ with ▁ this ▁ method " ) ; } String formula1 = getFormulaFromTextExpression ( expr1 ) ; Double value1 = formula1 == null ? convertNumber ( expr1 ) : null ; String formula2 = getFormulaFromTextExpression ( expr2 ) ; Double value2 = formula2 == null ? convertNumber ( expr2 ) : null ; return new DVConstraint ( validationType , comparisonOperator , formula1 , formula2 , value1 , value2 , null ) ; }
public UpdateUsageResult updateUsage ( UpdateUsageRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateUsage ( request ) ; }
public UpdateEvaluationResult updateEvaluation ( UpdateEvaluationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateEvaluation ( request ) ; }
public ProtectRecord ( boolean isProtected ) { this ( 0 ) ; setProtect ( isProtected ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( recordType ) ; out . writeShort ( grbitFrt ) ; associatedRange . serialize ( out ) ; }
public GetDocumentPathResult getDocumentPath ( GetDocumentPathRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDocumentPath ( request ) ; }
public CreateTransitGatewayVpcAttachmentResult createTransitGatewayVpcAttachment ( CreateTransitGatewayVpcAttachmentRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTransitGatewayVpcAttachment ( request ) ; }
public boolean isLarge ( ) { return true ; }
public DisassociateSubnetCidrBlockResult disassociateSubnetCidrBlock ( DisassociateSubnetCidrBlockRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateSubnetCidrBlock ( request ) ; }
public static byte [ ] encode ( String str ) { final ByteBuffer bb = UTF_8. encode ( str ) ; final int len = bb . limit ( ) ; if ( bb . hasArray ( ) && bb . arrayOffset ( ) == 0 ) { final byte [ ] arr = bb . array ( ) ; if ( arr . length == len ) return arr ; } final byte [ ] arr = new byte [ len ] ; bb . get ( arr ) ; return arr ; }
public DescribePlacementGroupsResult describePlacementGroups ( ) { return describePlacementGroups ( new DescribePlacementGroupsRequest ( ) ) ; }
public UpdateTrialResult updateTrial ( UpdateTrialRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTrial ( request ) ; }
public DeleteTransitGatewayPeeringAttachmentResult deleteTransitGatewayPeeringAttachment ( DeleteTransitGatewayPeeringAttachmentRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTransitGatewayPeeringAttachment ( request ) ; }
public boolean isLarge ( ) { try { getCachedBytes ( ) ; return false ; } catch ( LargeObjectException tooBig ) { return true ; } }
public synchronized Collection < V > values ( ) { Collection < V > vs = values ; return ( vs != null ) ? vs : ( values = new Values ( ) ) ; }
public EscherComplexProperty ( short propertyNumber , boolean isBlipId , byte [ ] complexData ) { this ( propertyNumber , isBlipId , complexData == null ? 0 : complexData . length ) ; setComplexData ( complexData ) ; }
public DeleteMatchmakingRuleSetResult deleteMatchmakingRuleSet ( DeleteMatchmakingRuleSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMatchmakingRuleSet ( request ) ; }
public UnassignIpv6AddressesResult unassignIpv6Addresses ( UnassignIpv6AddressesRequest request ) { request = beforeClientExecution ( request ) ; return executeUnassignIpv6Addresses ( request ) ; }
public boolean equals ( Object _other ) { if ( ( _other instanceof FacetResult ) == false ) { return false ; } FacetResult other = ( FacetResult ) _other ; return value . equals ( other . value ) && childCount == other . childCount && Arrays . equals ( labelValues , other . labelValues ) ; }
public ConfirmSubscriptionRequest ( String topicArn , String token ) { setTopicArn ( topicArn ) ; setToken ( token ) ; }
public Ref put ( String keyName , Ref value ) { String name = toRefName ( keyName ) ; if ( ! name . equals ( value . getName ( ) ) ) throw new IllegalArgumentException ( ) ; if ( ! resolved . isEmpty ( ) ) { for ( Ref ref : resolved ) loose = loose . put ( ref ) ; resolved = RefList . emptyList ( ) ; } int idx = loose . find ( name ) ; if ( 0 <= idx ) { Ref prior = loose . get ( name ) ; loose = loose . set ( idx , value ) ; return prior ; } Ref prior = get ( keyName ) ; loose = loose . add ( idx , value ) ; sizeIsValid = false ; return prior ; }
public void respondActivityTaskCanceled ( RespondActivityTaskCanceledRequest request ) { request = beforeClientExecution ( request ) ; executeRespondActivityTaskCanceled ( request ) ; }
public DocumentInputStream createDocumentInputStream ( final Entry document ) throws IOException { if ( ! document . isDocumentEntry ( ) ) { throw new IOException ( " Entry ▁ ' " ▁ + ▁ document . getName ( ) + ▁ " ' ▁ is ▁ not ▁ a ▁ DocumentEntry " ) ; } DocumentEntry entry = ( DocumentEntry ) document ; return new DocumentInputStream ( entry ) ; }
public DescribeInstanceStatusResult describeInstanceStatus ( ) { return describeInstanceStatus ( new DescribeInstanceStatusRequest ( ) ) ; }
public boolean requiresCommitBody ( ) { return true ; }
public BinaryHunk getReverseBinaryHunk ( ) { return reverseBinaryHunk ; }
public static synchronized CoderResult malformedForLength ( int length ) throws IllegalArgumentException { if ( length > 0 ) { Integer key = Integer . valueOf ( length ) ; synchronized ( _malformedErrors ) { CoderResult r = _malformedErrors . get ( key ) ; if ( r == null ) { r = new CoderResult ( TYPE_MALFORMED_INPUT , length ) ; _malformedErrors . put ( key , r ) ; } return r ; } } throw new IllegalArgumentException ( " Length ▁ must ▁ be ▁ greater ▁ than ▁ 0 ; ▁ was ▁ " + length ) ; }
public ByteBuffer get ( byte [ ] dst , int dstOffset , int byteCount ) { Arrays . checkOffsetAndCount ( dst . length , dstOffset , byteCount ) ; if ( byteCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } for ( int i = dstOffset ; i < dstOffset + byteCount ; ++ i ) { dst [ i ] = get ( ) ; } return this ; }
public final ObjectId getObjectId ( int nthPosition ) { if ( nthPosition >= 0 ) return getObjectId ( ( long ) nthPosition ) ; final int u31 = nthPosition >>> 1 ; final int one = nthPosition & 1 ; return getObjectId ( ( ( long ) u31 ) << 1 | one ) ; }
public UpdateRoomMembershipResult updateRoomMembership ( UpdateRoomMembershipRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRoomMembership ( request ) ; }
public void formatValue ( StringBuffer toAppendTo , Object value ) { double elapsed = ( ( Number ) value ) . doubleValue ( ) ; if ( elapsed < 0 ) { toAppendTo . append ( ' - ' ) ; elapsed = - elapsed ; } Object [ ] parts = new Long [ specs . size ( ) ] ; for ( int i = 0 ; i < specs . size ( ) ; i ++ ) { parts [ i ] = specs . get ( i ) . valueFor ( elapsed ) ; } try ( Formatter formatter = new Formatter ( toAppendTo , Locale . ROOT ) ) { formatter . format ( printfFmt , parts ) ; } }
public void writeDouble ( double v ) { writeContinueIfRequired ( 8 ) ; _ulrOutput . writeDouble ( v ) ; }
public CancelExportTaskResult cancelExportTask ( CancelExportTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelExportTask ( request ) ; }
public String toString ( ) { if ( length == 0 ) { return " FacetLabel : ▁ [ ] " ; } String [ ] parts = new String [ length ] ; System . arraycopy ( components , 0 , parts , 0 , length ) ; return " FacetLabel : ▁ " + Arrays . toString ( parts ) ; }
public DescribeEventTrackerResult describeEventTracker ( DescribeEventTrackerRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEventTracker ( request ) ; }
public UpdateJourneyResult updateJourney ( UpdateJourneyRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateJourney ( request ) ; }
public RemoveTagsFromVaultResult removeTagsFromVault ( RemoveTagsFromVaultRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveTagsFromVault ( request ) ; }
public RevertCommand include ( Ref commit ) { checkCallable ( ) ; commits . add ( commit ) ; return this ; }
public DeleteFargateProfileResult deleteFargateProfile ( DeleteFargateProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFargateProfile ( request ) ; }
public boolean evaluate ( int cmpResult ) { switch ( _code ) { case NONE : case EQ : return cmpResult == 0 ; case NE : return cmpResult != 0 ; case LT : return cmpResult < 0 ; case LE : return cmpResult <= 0 ; case GT : return cmpResult > 0 ; case GE : return cmpResult >= 0 ; } throw new RuntimeException ( " Cannot ▁ call ▁ boolean ▁ evaluate ▁ on ▁ non - equality ▁ operator ▁ ' " + ▁ □ representation ▁ + ▁ " ' " ) ; }
public SeriesRecord getSeries ( ) { return series ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ UNCALCED ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ □ reserved : ▁ " ) . append ( _reserved ) . append ( ' \ n ' ) ; buffer . append ( " [ / UNCALCED ] \ n " ) ; return buffer . toString ( ) ; }
public ListBotsResult listBots ( ListBotsRequest request ) { request = beforeClientExecution ( request ) ; return executeListBots ( request ) ; }
public int getPort ( ) { return port ; }
public void writeLong ( long value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeLong ( value ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { I_MatchPredicate mp = createCriteriaPredicate ( arg1 , srcRowIndex , srcColumnIndex ) ; if ( mp == null ) { return NumberEval . ZERO ; } double result = countMatchingCellsInArea ( arg0 , mp ) ; return new NumberEval ( result ) ; }
public boolean requiresCommitBody ( ) { return true ; }
public DeleteVpcResult deleteVpc ( DeleteVpcRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVpc ( request ) ; }
public VoteOnProposalResult voteOnProposal ( VoteOnProposalRequest request ) { request = beforeClientExecution ( request ) ; return executeVoteOnProposal ( request ) ; }
public void grow ( ) { costs = ArrayUtil . grow ( costs , 1 + count ) ; lastRightID = ArrayUtil . grow ( lastRightID , 1 + count ) ; backPos = ArrayUtil . grow ( backPos , 1 + count ) ; backIndex = ArrayUtil . grow ( backIndex , 1 + count ) ; backID = ArrayUtil . grow ( backID , 1 + count ) ; final Type [ ] newBackType = new Type [ backID . length ] ; System . arraycopy ( backType , 0 , newBackType , 0 , backType . length ) ; backType = newBackType ; }
public String toString ( ) { return " MERGE □ BASE " ; }
public float readFloat ( ) throws IOException { return primitiveTypes . readFloat ( ) ; }
public String substring ( int start ) { if ( start >= 0 && start <= count ) { if ( start == count ) { return " " ; } return new String ( value , start , count - start ) ; } throw indexAndLength ( start ) ; }
public DBCellRecord ( RecordInputStream in ) { field_1_row_offset = in . readUShort ( ) ; int size = in . remaining ( ) ; field_2_cell_offsets = new short [ size / 2 ] ; for ( int i = 0 ; i < field_2_cell_offsets . length ; i ++ ) { field_2_cell_offsets [ i ] = in . readShort ( ) ; } }
public DefaultAcsClient ( IClientProfile profile ) { this ( profile , new StaticCredentialsProvider ( profile ) ) ; }
public int findStartOffset ( StringBuilder buffer , int start ) { if ( start > buffer . length ( ) || start < 1 ) return start ; int offset , count = maxScan ; for ( offset = start ; offset > 0 && count > 0 ; count -- ) { if ( boundaryChars . contains ( buffer . charAt ( offset - 1 ) ) ) return offset ; offset -- ; } if ( offset == 0 ) { return 0 ; } return start ; }
public BufferedTokenStream ( TokenSource tokenSource ) { if ( tokenSource == null ) { throw new NullPointerException ( " tokenSource ▁ cannot ▁ be ▁ null " ) ; } this . tokenSource = tokenSource ; }
public final boolean isDirect ( ) { return false ; }
public TokenMgrError ( String message , int reason ) { super ( message ) ; errorCode = reason ; }
public int getCells ( ) { int size = 0 ; for ( Row row : rows ) size += row . getCells ( ) ; return size ; }
public int findStartOfRowOutlineGroup ( int row ) { RowRecord rowRecord = this . getRow ( row ) ; int level = rowRecord . getOutlineLevel ( ) ; int currentRow = row ; while ( currentRow >= 0 && this . getRow ( currentRow ) != null ) { rowRecord = this . getRow ( currentRow ) ; if ( rowRecord . getOutlineLevel ( ) < level ) { return currentRow + 1 ; } currentRow -- ; } return currentRow + 1 ; }
public DirCacheBuildIterator ( DirCacheBuilder dcb ) { super ( dcb . getDirCache ( ) ) ; builder = dcb ; }
public DeleteGraphResult deleteGraph ( DeleteGraphRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteGraph ( request ) ; }
public String toString ( ) { return " id = " + id + " ▁ version = " + version + " ▁ files = " + sourceFiles ; }
public static Calendar parseDate ( String strVal ) throws EvaluationException { String [ ] parts = Pattern . compile ( " / " ) . split ( strVal ) ; if ( parts . length != 3 ) { throw new EvaluationException ( ErrorEval . VALUE_INVALID ) ; } String part2 = parts [ 2 ] ; int spacePos = part2. indexOf ( ' ▁ ' ) ; if ( spacePos > 0 ) { part2 = part2. substring ( 0 , spacePos ) ; } int f0 ; int f1 ; int f2 ; try { f0 = Integer . parseInt ( parts [ 0 ] ) ; f1 = Integer . parseInt ( parts [ 1 ] ) ; f2 = Integer . parseInt ( part2 ) ; } catch ( NumberFormatException e ) { throw new EvaluationException ( ErrorEval . VALUE_INVALID ) ; } if ( f0 < 0 || f1 < 0 || f2 < 0 || ( f0 > 12 && f1 > 12 && f2 > 12 ) ) { throw new EvaluationException ( ErrorEval . VALUE_INVALID ) ; } if ( f0 >= 1900 && f0 < 9999 ) { return makeDate ( f0 , f1 , f2 ) ; } throw new RuntimeException ( " Unable ▁ to ▁ determine ▁ date ▁ format ▁ for ▁ text ▁ ' " ▁ + ▁ strVal ▁ + ▁ " ' " ) ; }
public void removeMMClipCount ( ) { remove1stProperty ( PropertyIDMap . PID_MMCLIPCOUNT ) ; }
public void setDeltaCacheSize ( long size ) { deltaCacheSize = size ; }
public UpdateKnowledgeRequest ( ) { super ( " Chatbot " , " 2017 - 10 - 11 " , " UpdateKnowledge " , " beebot " ) ; setMethod ( MethodType . POST ) ; }
public void readBytes ( byte [ ] b , int offset , int len ) { for ( int i = 0 ; i < len ; i ++ ) { b [ offset + i ] = bytes [ pos -- ] ; } }
public void fillArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , " fillArc ▁ not ▁ supported " ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { double result ; try { ValueVector vvY = createValueVector ( arg0 ) ; ValueVector vvX = createValueVector ( arg1 ) ; int size = vvX . getSize ( ) ; if ( size == 0 || vvY . getSize ( ) != size ) { return ErrorEval . NA ; } result = evaluateInternal ( vvX , vvY , size ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } if ( Double . isNaN ( result ) || Double . isInfinite ( result ) ) { return ErrorEval . NUM_ERROR ; } return new NumberEval ( result ) ; }
public void copyUpdatedCells ( Workbook workbook ) { _sewb . copyUpdatedCells ( workbook ) ; }
@ Override public final String toString ( ) { return key + " = " + value ; }
public DescribeReservedInstancesOfferingsResult describeReservedInstancesOfferings ( ) { return describeReservedInstancesOfferings ( new DescribeReservedInstancesOfferingsRequest ( ) ) ; }
public CacheParameterGroup createCacheParameterGroup ( CreateCacheParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCacheParameterGroup ( request ) ; }
public OldStringRecord ( RecordInputStream in ) { sid = in . getSid ( ) ; if ( in . getSid ( ) == biff2_sid ) { field_1_string_len = ( short ) in . readUByte ( ) ; } else { field_1_string_len = in . readShort ( ) ; } field_2_bytes = IOUtils . safelyAllocate ( field_1_string_len , MAX_RECORD_LENGTH ) ; in . read ( field_2_bytes , 0 , field_1_string_len ) ; }
public long ramBytesUsed ( ) { return TERMS_BASE_RAM_BYTES_USED + ( fst != null ? fst . ramBytesUsed ( ) : 0 ) + RamUsageEstimator . sizeOf ( scratch . bytes ( ) ) + RamUsageEstimator . sizeOf ( scratchUTF16. chars ( ) ) ; }
public void fillRect ( int x , int y , int width , int height ) { HSSFSimpleShape shape = escherGroup . createShape ( new HSSFChildAnchor ( x , y , x + width , y + height ) ) ; shape . setShapeType ( HSSFSimpleShape . OBJECT_TYPE_RECTANGLE ) ; shape . setLineStyle ( HSSFShape . LINESTYLE_NONE ) ; shape . setFillColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; }
public void add ( OneMerge merge ) { merges . add ( merge ) ; }
public long computeNorm ( FieldInvertState state ) { return sims [ 0 ] . computeNorm ( state ) ; }
public PolicyAttribute ( String attributeName , String attributeValue ) { setAttributeName ( attributeName ) ; setAttributeValue ( attributeValue ) ; }
public String getAccessKeyId ( ) { return publicKeyId ; }
public ListJourneysResult listJourneys ( ListJourneysRequest request ) { request = beforeClientExecution ( request ) ; return executeListJourneys ( request ) ; }
public FormulaCellCacheEntry getOrCreateFormulaCellEntry ( EvaluationCell cell ) { FormulaCellCacheEntry result = _formulaCellCache . get ( cell ) ; if ( result == null ) { result = new FormulaCellCacheEntry ( ) ; _formulaCellCache . put ( cell , result ) ; } return result ; }
public StartHumanLoopResult startHumanLoop ( StartHumanLoopRequest request ) { request = beforeClientExecution ( request ) ; return executeStartHumanLoop ( request ) ; }
public List < RefSpec > getRefSpecs ( ) { return refSpecs ; }
public void build ( InputIterator iterator ) throws IOException { if ( iterator . hasPayloads ( ) ) { throw new IllegalArgumentException ( " this ▁ suggester ▁ doesn ' t support payloads " ) ; } if ▁ ( iterator . hasContexts ( ) ) ▁ { throw ▁ new ▁ IllegalArgumentException ( " this suggester doesn ' t ▁ support ▁ contexts " ) ; } count = 0 ; BytesRef scratch = new BytesRef ( ) ; InputIterator iter = new WFSTInputIterator ( tempDir , tempFileNamePrefix , iterator ) ; IntsRefBuilder scratchInts = new IntsRefBuilder ( ) ; BytesRefBuilder previous = null ; PositiveIntOutputs outputs = PositiveIntOutputs . getSingleton ( ) ; FSTCompiler < Long > fstCompiler = new FSTCompiler <> ( FST . INPUT_TYPE . BYTE1 , outputs ) ; while ( ( scratch = iter . next ( ) ) != null ) { long cost = iter . weight ( ) ; if ( previous == null ) { previous = new BytesRefBuilder ( ) ; } else if ( scratch . equals ( previous . get ( ) ) ) { continue ; } Util . toIntsRef ( scratch , scratchInts ) ; fstCompiler . add ( scratchInts . get ( ) , cost ) ; previous . copyBytes ( scratch ) ; count ++ ; } fst = fstCompiler . compile ( ) ; }
public Comparator <? super K > comparator ( ) { if ( ascending ) { return TreeMap . this . comparator ( ) ; } else { return Collections . reverseOrder ( comparator ) ; } }
public PrintHeadersRecord ( RecordInputStream in ) { field_1_print_headers = in . readShort ( ) ; }
public DeleteBranchCommand branchDelete ( ) { return new DeleteBranchCommand ( repo ) ; }
public DetectLabelsResult detectLabels ( DetectLabelsRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectLabels ( request ) ; }
public FnGroupCountRecord ( RecordInputStream in ) { field_1_count = in . readShort ( ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { double result ; try { double d0 = singleOperandEvaluate ( arg0 , srcRowIndex , srcColumnIndex ) ; double d1 = singleOperandEvaluate ( arg1 , srcRowIndex , srcColumnIndex ) ; double multi = Math . pow ( 10d , d1 ) ; if ( d0 < 0 ) result = - Math . floor ( - d0 * multi ) / multi ; else result = Math . floor ( d0 * multi ) / multi ; checkValue ( result ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public DoubleBuffer put ( double [ ] src , int srcOffset , int doubleCount ) { if ( doubleCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } System . arraycopy ( src , srcOffset , backingArray , offset + position , doubleCount ) ; position += doubleCount ; return this ; }
public CharSequence toQueryString ( EscapeQuerySyntax escaper ) { if ( isDefaultField ( this . field ) ) { return getTermEscaped ( escaper ) + " ~ " + this . similarity ; } else { return this . field + " : " + getTermEscaped ( escaper ) + " ~ " + this . similarity ; } }
public AbstractBlockPackedWriter ( DataOutput out , int blockSize ) { checkBlockSize ( blockSize , MIN_BLOCK_SIZE , MAX_BLOCK_SIZE ) ; reset ( out ) ; values = new long [ blockSize ] ; }
public String getMessage ( ) { return message ; }
public ListAttendeesResult listAttendees ( ListAttendeesRequest request ) { request = beforeClientExecution ( request ) ; return executeListAttendees ( request ) ; }
public void reset ( ) { upto = count = 0 ; posIncr = 1 ; }
public FeatHdrRecord clone ( ) { return copy ( ) ; }
public synchronized void addElement ( E object ) { if ( elementCount == elementData . length ) { growByOne ( ) ; } elementData [ elementCount ++ ] = object ; modCount ++ ; }
public long fileLength ( String name ) throws IOException { ensureOpen ( ) ; if ( pendingDeletes . contains ( name ) ) { throw new NoSuchFileException ( " file ▁ \ " " + name + " \ " ▁ is ▁ pending ▁ delete " ) ; } return Files . size ( directory . resolve ( name ) ) ; }
public PutExternalModelResult putExternalModel ( PutExternalModelRequest request ) { request = beforeClientExecution ( request ) ; return executePutExternalModel ( request ) ; }
public PutConferencePreferenceResult putConferencePreference ( PutConferencePreferenceRequest request ) { request = beforeClientExecution ( request ) ; return executePutConferencePreference ( request ) ; }
public int size ( ) { return size ; }
public CreateApiMappingResult createApiMapping ( CreateApiMappingRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateApiMapping ( request ) ; }
public CharBlockArray append ( CharSequence chars , int start , int length ) { int end = start + length ; for ( int i = start ; i < end ; i ++ ) { append ( chars . charAt ( i ) ) ; } return this ; }
public UpdateAdmChannelResult updateAdmChannel ( UpdateAdmChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateAdmChannel ( request ) ; }
public DirCacheIterator ( DirCache dc ) { cache = dc ; tree = dc . getCacheTree ( true ) ; treeStart = 0 ; treeEnd = tree . getEntrySpan ( ) ; subtreeId = new byte [ Constants . OBJECT_ID_LENGTH ] ; if ( ! eof ( ) ) parseEntry ( ) ; }
public void setBytesRef ( BytesRef term , int textStart ) { final byte [ ] bytes = term . bytes = buffers [ textStart >> BYTE_BLOCK_SHIFT ] ; int pos = textStart & BYTE_BLOCK_MASK ; if ( ( bytes [ pos ] & 0x80 ) == 0 ) { term . length = bytes [ pos ] ; term . offset = pos + 1 ; } else { term . length = ( bytes [ pos ] & 0x7f ) + ( ( bytes [ pos + 1 ] & 0xff ) << 7 ) ; term . offset = pos + 2 ; } assert term . length >= 0 ; }
public Restrictions ( GeoRestriction geoRestriction ) { setGeoRestriction ( geoRestriction ) ; }
public DisableRuleResult disableRule ( DisableRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableRule ( request ) ; }
public GetSuppressedDestinationResult getSuppressedDestination ( GetSuppressedDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSuppressedDestination ( request ) ; }
public ListDomainsResult listDomains ( ListDomainsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDomains ( request ) ; }
public StartLifecyclePolicyPreviewResult startLifecyclePolicyPreview ( StartLifecyclePolicyPreviewRequest request ) { request = beforeClientExecution ( request ) ; return executeStartLifecyclePolicyPreview ( request ) ; }
public CreateDiskFromSnapshotResult createDiskFromSnapshot ( CreateDiskFromSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDiskFromSnapshot ( request ) ; }
public SubmoduleSyncCommand submoduleSync ( ) { return new SubmoduleSyncCommand ( repo ) ; }
public DeleteConfigurationSetTrackingOptionsResult deleteConfigurationSetTrackingOptions ( DeleteConfigurationSetTrackingOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteConfigurationSetTrackingOptions ( request ) ; }
public V setValue ( V value ) { if ( ! allowModify ) throw new UnsupportedOperationException ( ) ; V old = values [ lastPos ] ; values [ lastPos ] = value ; return old ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ FtPioGrbit ▁ ] \ n " ) ; buffer . append ( " ▁ ▁ size ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( length ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ flags ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . toHex ( flags ) ) . append ( " \ n " ) ; buffer . append ( " [ / FtPioGrbit ▁ ] \ n " ) ; return buffer . toString ( ) ; }
static public double ipmt ( double r , int per , int nper , double pv , double fv , int type ) { double ipmt = fv ( r , per - 1 , pmt ( r , nper , pv , fv , type ) , pv , type ) * r ; if ( type == 1 ) ipmt /= ( 1 + r ) ; return ipmt ; }
public FileDictionary ( InputStream dictFile , String fieldDelimiter ) { in = new BufferedReader ( IOUtils . getDecodingReader ( dictFile , StandardCharsets . UTF_8 ) ) ; this . fieldDelimiter = fieldDelimiter ; }
public DocumentSummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isDocumentSummaryInformation ( ) ) { throw new UnexpectedPropertySetTypeException ( " Not ▁ a ▁ " + getClass ( ) . getName ( ) ) ; } }
public EscherBSERecord getBSERecord ( int pictureIndex ) { return escherBSERecords . get ( pictureIndex - 1 ) ; }
public CreateDetectorVersionResult createDetectorVersion ( CreateDetectorVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDetectorVersion ( request ) ; }
public static DVConstraint createExplicitListConstraint ( String [ ] explicitListValues ) { return new DVConstraint ( null , explicitListValues ) ; }
public ListGroupsResult listGroups ( ListGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListGroups ( request ) ; }
public DeleteScriptResult deleteScript ( DeleteScriptRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteScript ( request ) ; }
public DescribeSpotDatafeedSubscriptionResult describeSpotDatafeedSubscription ( DescribeSpotDatafeedSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSpotDatafeedSubscription ( request ) ; }
public CharArrayReader ( char [ ] buf ) { this . buf = buf ; this . count = buf . length ; }
public CharSequence subSequence ( int start , int end ) { return substring ( start , end ) ; }
public Builder ( boolean dedup ) { this . dedup = dedup ; }
public synchronized void setPerfObject ( String key , Object obj ) { perfObjects . put ( key , obj ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ DIMENSIONS ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . firstrow ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getFirstRow ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . lastrow ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getLastRow ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . firstcol ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getFirstCol ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . lastcol ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getLastCol ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . zero ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( field_5_zero ) ) . append ( " \ n " ) ; buffer . append ( " [ / DIMENSIONS ] \ n " ) ; return buffer . toString ( ) ; }
public ExitStandbyResult exitStandby ( ExitStandbyRequest request ) { request = beforeClientExecution ( request ) ; return executeExitStandby ( request ) ; }
public String toString ( ) { return " MultiDocsAndPositionsEnum ( " + Arrays . toString ( getSubs ( ) ) + " ) " ; }
public MergeException ( Throwable exc , Directory dir ) { super ( exc ) ; this . dir = dir ; }
public int read ( CharBuffer target ) throws IOException { int remaining = remaining ( ) ; if ( target == this ) { if ( remaining == 0 ) { return - 1 ; } throw new IllegalArgumentException ( ) ; } if ( remaining == 0 ) { return limit > 0 && target . remaining ( ) == 0 ? 0 : - 1 ; } remaining = Math . min ( target . remaining ( ) , remaining ) ; if ( remaining > 0 ) { char [ ] chars = new char [ remaining ] ; get ( chars ) ; target . put ( chars ) ; } return remaining ; }
public final float getFloat ( ) { return Float . intBitsToFloat ( getInt ( ) ) ; }
public UpdateApplicationRequest ( String applicationName ) { setApplicationName ( applicationName ) ; }
public void initReader ( ByteSliceReader reader , int termID , int stream ) { assert stream < streamCount ; int intStart = postingsArray . intStarts [ termID ] ; final int [ ] ints = intPool . buffers [ intStart >> IntBlockPool . INT_BLOCK_SHIFT ] ; final int upto = intStart & IntBlockPool . INT_BLOCK_MASK ; reader . init ( bytePool , postingsArray . byteStarts [ termID ] + stream * ByteBlockPool . FIRST_LEVEL_SIZE , ints [ upto + stream ] ) ; }
public T next ( ) { if ( size <= index ) throw new NoSuchElementException ( ) ; T res = block [ blkIdx ] ; if ( ++ blkIdx == BLOCK_SIZE ) { if ( ++ dirIdx < directory . length ) block = directory [ dirIdx ] ; elseblock = null ; blkIdx = 0 ; } index ++ ; return res ; }
public DescribeOptionGroupOptionsResult describeOptionGroupOptions ( DescribeOptionGroupOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeOptionGroupOptions ( request ) ; }
public int alloc ( int size ) { int index = n ; int len = array . length ; if ( n + size >= len ) { byte [ ] aux = new byte [ len + blockSize ] ; System . arraycopy ( array , 0 , aux , 0 , len ) ; array = aux ; } n += size ; return index ; }
public String getText ( ) { StringBuilder text = new StringBuilder ( ) ; for ( TermInfo ti : termsInfos ) { text . append ( ti . getText ( ) ) ; } return text . toString ( ) ; }
public ReplaceableItem ( String name ) { setName ( name ) ; }
public NamePtg ( LittleEndianInput in ) { field_1_label_index = in . readUShort ( ) ; field_2_zero = in . readShort ( ) ; }
public int indexOf ( Object object ) { if ( object != null ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( object . equals ( a [ i ] ) ) { return i ; } } } else { for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] == null ) { return i ; } } } return - 1 ; }
public ListContactFlowsResult listContactFlows ( ListContactFlowsRequest request ) { request = beforeClientExecution ( request ) ; return executeListContactFlows ( request ) ; }
public int doLogic ( ) throws IOException { String analyzerName = null ; try { if ( current >= analyzerNames . size ( ) ) { current = 0 ; } analyzerName = analyzerNames . get ( current ++ ) ; Analyzer analyzer = null ; if ( null == analyzerName || 0 == analyzerName . length ( ) ) { analyzerName = " org . apache . lucene . analysis . standard . StandardAnalyzer " ; } AnalyzerFactory factory = getRunData ( ) . getAnalyzerFactories ( ) . get ( analyzerName ) ; if ( null != factory ) { analyzer = factory . create ( ) ; } else { if ( analyzerName . contains ( " . " ) ) { if ( analyzerName . startsWith ( " standard . " ) ) { analyzerName = " org . apache . lucene . analysis . " + analyzerName ; } analyzer = createAnalyzer ( analyzerName ) ; } else { try { String coreClassName = " org . apache . lucene . analysis . core . " + analyzerName ; analyzer = createAnalyzer ( coreClassName ) ; analyzerName = coreClassName ; } catch ( ClassNotFoundException e ) { analyzerName = " org . apache . lucene . analysis . " + analyzerName ; analyzer = createAnalyzer ( analyzerName ) ; } } } getRunData ( ) . setAnalyzer ( analyzer ) ; } catch ( Exception e ) { throw new RuntimeException ( " Error ▁ creating ▁ Analyzer : ▁ " + analyzerName , e ) ; } return 1 ; }
public int serializeSimplePart ( byte [ ] data , int offset ) { LittleEndian . putShort ( data , offset , getId ( ) ) ; LittleEndian . putInt ( data , offset + 2 , propertyValue ) ; return 6 ; }
public static short [ ] copyOf ( short [ ] original , int newLength ) { if ( newLength < 0 ) { throw new NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; }
@ Override public Iterator < V > iterator ( ) { return new ValueIterator ( ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } PrefixQuery other = ( PrefixQuery ) obj ; if ( ! term . equals ( other . term ) ) { return false ; } return true ; }
public boolean isSheetVeryHidden ( int sheetnum ) { return getBoundSheetRec ( sheetnum ) . isVeryHidden ( ) ; }
public UpdateAccessKeyRequest ( String accessKeyId , StatusType status ) { setAccessKeyId ( accessKeyId ) ; setStatus ( status . toString ( ) ) ; }
public static int countMatchingCellsInArea ( ThreeDEval areaEval , I_MatchPredicate criteriaPredicate ) { int result = 0 ; final int firstSheetIndex = areaEval . getFirstSheetIndex ( ) ; final int lastSheetIndex = areaEval . getLastSheetIndex ( ) ; for ( int sIx = firstSheetIndex ; sIx <= lastSheetIndex ; sIx ++ ) { int height = areaEval . getHeight ( ) ; int width = areaEval . getWidth ( ) ; for ( int rrIx = 0 ; rrIx < height ; rrIx ++ ) { for ( int rcIx = 0 ; rcIx < width ; rcIx ++ ) { ValueEval ve = areaEval . getValue ( sIx , rrIx , rcIx ) ; if ( criteriaPredicate instanceof I_MatchAreaPredicate ) { I_MatchAreaPredicate areaPredicate = ( I_MatchAreaPredicate ) criteriaPredicate ; if ( ! areaPredicate . matches ( areaEval , rrIx , rcIx ) ) continue ; } if ( criteriaPredicate . matches ( ve ) ) { result ++ ; } } } } return result ; }
public PushCommand setRefSpecs ( List < RefSpec > specs ) { checkCallable ( ) ; this . refSpecs . clear ( ) ; this . refSpecs . addAll ( specs ) ; return this ; }
public EscherComplexProperty ( short id , int complexSize ) { super ( ( short ) ( id | IS_COMPLEX ) ) ; complexData = IOUtils . safelyAllocate ( complexSize , MAX_RECORD_LENGTH ) ; }
public CreateNodeResult createNode ( CreateNodeRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNode ( request ) ; }
public Note call ( ) throws GitAPIException { checkCallable ( ) ; NoteMap map = NoteMap . newEmptyMap ( ) ; RevCommit notesCommit = null ; try ( RevWalk walk = new RevWalk ( repo ) ) { Ref ref = repo . exactRef ( notesRef ) ; if ( ref != null ) { notesCommit = walk . parseCommit ( ref . getObjectId ( ) ) ; map = NoteMap . read ( walk . getObjectReader ( ) , notesCommit ) ; } return map . getNote ( id ) ; } catch ( IOException e ) { throw new JGitInternalException ( e . getMessage ( ) , e ) ; } }
public void ReInit ( CharStream stream ) { jjmatchedPos = jjnewStateCnt = 0 ; curLexState = defaultLexState ; input_stream = stream ; ReInitRounds ( ) ; }
public boolean add ( char [ ] text ) { return map . put ( text , PLACEHOLDER ) == null ; }
public void setDeltaBaseCacheLimit ( int newLimit ) { deltaBaseCacheLimit = newLimit ; }
public ServerException ( String errCode , String errMsg , String requestId ) { this ( errCode , errMsg ) ; this . setRequestId ( requestId ) ; }
final public SrndQuery NQuery ( ) throws ParseException { SrndQuery q ; ArrayList < SrndQuery > queries ; Token dt ; q = WQuery ( ) ; label_5 : while ( true ) { switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case N : ; break ; default : jj_la1 [ 3 ] = jj_gen ; break label_5 ; } dt = jj_consume_token ( N ) ; queries = new ArrayList < SrndQuery > ( ) ; queries . add ( q ) ; q = WQuery ( ) ; queries . add ( q ) ; q = getDistanceQuery ( queries , true , dt , false ) ; } { if ( true ) return q ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public MoreLikeThisQuery ( String likeText , String [ ] moreLikeFields , Analyzer analyzer , String fieldName ) { this . likeText = Objects . requireNonNull ( likeText ) ; this . moreLikeFields = Objects . requireNonNull ( moreLikeFields ) ; this . analyzer = Objects . requireNonNull ( analyzer ) ; this . fieldName = Objects . requireNonNull ( fieldName ) ; }
public DescribeImageAttributeResult describeImageAttribute ( DescribeImageAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeImageAttribute ( request ) ; }
public void println ( Object o ) { println ( String . valueOf ( o ) ) ; }
public DeregisterFromWorkMailResult deregisterFromWorkMail ( DeregisterFromWorkMailRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterFromWorkMail ( request ) ; }
public PutClusterCapacityProvidersResult putClusterCapacityProviders ( PutClusterCapacityProvidersRequest request ) { request = beforeClientExecution ( request ) ; return executePutClusterCapacityProviders ( request ) ; }
public ChangeMessageVisibilityBatchRequestEntry ( String id , String receiptHandle ) { setId ( id ) ; setReceiptHandle ( receiptHandle ) ; }
public StringBuffer append ( float f ) { RealToString . getInstance ( ) . appendFloat ( this , f ) ; return this ; }
@ Override public int compare ( T o1 , T o2 ) { return cmp . compare ( o2 , o1 ) ; }
public GetAttributesRequest ( String domainName , String itemName ) { setDomainName ( domainName ) ; setItemName ( itemName ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + _firstMovedIndex + _lastMovedIndex + _amountToMove + " ] " ; }
public final ValueEval evaluate ( ValueEval [ ] args , int srcCellRow , int srcCellCol ) { double result ; try { result = eval ( args , srcCellRow , srcCellCol ) ; checkValue ( result ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public DescribeFpgaImagesResult describeFpgaImages ( DescribeFpgaImagesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFpgaImages ( request ) ; }
public ObjectDirectoryInserter newInserter ( ) { return new ObjectDirectoryInserter ( this , config ) ; }
public LongBuffer put ( int index , long c ) { checkIndex ( index ) ; byteBuffer . putLong ( index * SizeOf . LONG , c ) ; return this ; }
public boolean isRetainBody ( ) { return retainBody ; }
public AddApplicationVpcConfigurationResult addApplicationVpcConfiguration ( AddApplicationVpcConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeAddApplicationVpcConfiguration ( request ) ; }
public Entry < K , V > next ( ) { return nextEntry ( ) ; }
public SpreadsheetVersion getSpreadsheetVersion ( ) { return SpreadsheetVersion . EXCEL97 ; }
public String [ ] promptKeyboardInteractive ( String destination , String name , String instruction , String [ ] prompt , boolean [ ] echo ) { CredentialItem . StringType [ ] v = new CredentialItem . StringType [ prompt . length ] ; for ( int i = 0 ; i < prompt . length ; i ++ ) v [ i ] = new CredentialItem . StringType ( prompt [ i ] , ! echo [ i ] ) ; List < CredentialItem > items = new ArrayList <> ( ) ; if ( instruction != null && instruction . length ( ) > 0 ) items . add ( new CredentialItem . InformationalMessage ( instruction ) ) ; items . addAll ( Arrays . asList ( v ) ) ; if ( ! provider . get ( uri , items ) ) return null ; String [ ] result = new String [ v . length ] ; for ( int i = 0 ; i < v . length ; i ++ ) result [ i ] = v [ i ] . getValue ( ) ; return result ; }
public static synchronized MergeStrategy get ( String name ) { return STRATEGIES . get ( name ) ; }
public AssociateConnectionWithLagResult associateConnectionWithLag ( AssociateConnectionWithLagRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateConnectionWithLag ( request ) ; }
public short getShortValue ( final short holder ) { return ( short ) getValue ( holder ) ; }
public static BreakIterator getSentenceInstance ( ) { return getSentenceInstance ( Locale . getDefault ( ) ) ; }
public MissingObjectException ( ObjectId id , String type ) { super ( MessageFormat . format ( JGitText . get ( ) . missingObject , type , id . name ( ) ) ) ; missing = id . copy ( ) ; }
public PipedReader ( PipedWriter out , int pipeSize ) throws IOException { this ( pipeSize ) ; connect ( out ) ; }
public ImportKeyPairRequest ( String keyName , String publicKeyMaterial ) { setKeyName ( keyName ) ; setPublicKeyMaterial ( publicKeyMaterial ) ; }
public DeleteFaceRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " DeleteFace " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public CreateReceiptRuleSetResult createReceiptRuleSet ( CreateReceiptRuleSetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateReceiptRuleSet ( request ) ; }
public RemovePermissionRequest ( String queueUrl , String label ) { setQueueUrl ( queueUrl ) ; setLabel ( label ) ; }
public String toString ( ) { return " DFR ▁ " + basicModel . toString ( ) + afterEffect . toString ( ) + normalization . toString ( ) ; }
public void setResult ( RefUpdate . Result r ) { switch ( r ) { case NOT_ATTEMPTED : setResult ( Result . NOT_ATTEMPTED ) ; break ; case LOCK_FAILURE : case IO_FAILURE : setResult ( Result . LOCK_FAILURE ) ; break ; case NO_CHANGE : case NEW : case FORCED : case FAST_FORWARD : setResult ( Result . OK ) ; break ; case REJECTED : setResult ( Result . REJECTED_NONFASTFORWARD ) ; break ; case REJECTED_CURRENT_BRANCH : setResult ( Result . REJECTED_CURRENT_BRANCH ) ; break ; case REJECTED_MISSING_OBJECT : setResult ( Result . REJECTED_MISSING_OBJECT ) ; break ; case REJECTED_OTHER_REASON : setResult ( Result . REJECTED_OTHER_REASON ) ; break ; default : setResult ( Result . REJECTED_OTHER_REASON , r . name ( ) ) ; break ; } }
public DeleteMatchmakingConfigurationResult deleteMatchmakingConfiguration ( DeleteMatchmakingConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMatchmakingConfiguration ( request ) ; }
public double resolveDistErr ( SpatialContext ctx , double defaultDistErrPct ) { if ( distErr != null ) return distErr ; double distErrPct = ( this . distErrPct != null ? this . distErrPct : defaultDistErrPct ) ; return calcDistanceFromErrPct ( shape , distErrPct , ctx ) ; }
public final CharsetEncoder replaceWith ( byte [ ] replacement ) { if ( replacement == null ) { throw new IllegalArgumentException ( " replacement ▁ == ▁ null " ) ; } if ( replacement . length == 0 ) { throw new IllegalArgumentException ( " replacement . length ▁ == ▁ 0 " ) ; } if ( replacement . length > maxBytesPerChar ( ) ) { throw new IllegalArgumentException ( " replacement ▁ length ▁ > ▁ maxBytesPerChar : ▁ " + replacement . length + " ▁ > ▁ " + maxBytesPerChar ( ) ) ; } if ( ! isLegalReplacement ( replacement ) ) { throw new IllegalArgumentException ( " bad ▁ replacement : ▁ " + Arrays . toString ( replacement ) ) ; } this . replacementBytes = replacement ; implReplaceWith ( replacementBytes ) ; return this ; }
public CreateApplicationSnapshotResult createApplicationSnapshot ( CreateApplicationSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateApplicationSnapshot ( request ) ; }
public ValueEval evaluate ( int srcCellRow , int srcCellCol , ValueEval arg0 ) { double d ; try { ValueEval ve = OperandResolver . getSingleValue ( arg0 , srcCellRow , srcCellCol ) ; if ( ve instanceof StringEval ) { return ve ; } d = OperandResolver . coerceValueToDouble ( ve ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( + d ) ; }
public MoPenBindIsvRequest ( ) { super ( " MoPen " , " 2018 - 02 - 11 " , " MoPenBindIsv " , " mopen " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public AssociateIpGroupsResult associateIpGroups ( AssociateIpGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateIpGroups ( request ) ; }
public TestEventPatternResult testEventPattern ( TestEventPatternRequest request ) { request = beforeClientExecution ( request ) ; return executeTestEventPattern ( request ) ; }
public LockFailedException ( File file , String message ) { super ( message ) ; this . file = file ; }
public DeleteSkillGroupResult deleteSkillGroup ( DeleteSkillGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSkillGroup ( request ) ; }
public SortedDocValuesField ( String name , BytesRef bytes ) { super ( name , TYPE ) ; fieldsData = bytes ; }
public CreateNetworkResult createNetwork ( CreateNetworkRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNetwork ( request ) ; }
public DeleteGroupRequest ( String groupName ) { setGroupName ( groupName ) ; }
public DescribeCacheEngineVersionsResult describeCacheEngineVersions ( DescribeCacheEngineVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCacheEngineVersions ( request ) ; }
public int compareSameType ( Object other ) { assert exists || ( false == value ) ; MutableValueBool b = ( MutableValueBool ) other ; if ( value != b . value ) return value ? 1 : - 1 ; if ( exists == b . exists ) return 0 ; return exists ? 1 : - 1 ; }
public LineParser ( String [ ] header ) { this . header = header ; }
public DBInstance restoreDBInstanceFromDBSnapshot ( RestoreDBInstanceFromDBSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeRestoreDBInstanceFromDBSnapshot ( request ) ; }
public void push ( E e ) { addFirstImpl ( e ) ; }
public synchronized void reset ( ) throws IOException { if ( buf == null ) { throw new IOException ( " Stream ▁ is ▁ closed " ) ; } if ( - 1 == markpos ) { throw new IOException ( " Mark ▁ has ▁ been ▁ invalidated . " ) ; } pos = markpos ; }
public UpdateUsagePlanResult updateUsagePlan ( UpdateUsagePlanRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateUsagePlan ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } TermInfo other = ( TermInfo ) obj ; return position == other . position ; }
public StringPtg ( String value ) { if ( value . length ( ) > 255 ) { throw new IllegalArgumentException ( " String ▁ literals ▁ in ▁ formulas ▁ can ' t be bigger than 255 characters ASCII " ) ; } □ is16bitUnicode ▁ = ▁ StringUtil . hasMultibyte ( value ) ; field □ 3 □ string ▁ = ▁ value ; }
public ChangeType getChangeType ( ) { return changeType ; }
public String asFormulaString ( ) { StringBuilder sb = new StringBuilder ( 32 ) ; asFormulaString ( sb ) ; return sb . toString ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( sid ) ; out . writeShort ( getDataSize ( ) ) ; out . writeShort ( field_1_objectType ) ; out . writeShort ( field_2_objectId ) ; out . writeShort ( field_3_option ) ; out . writeInt ( field_4_reserved1 ) ; out . writeInt ( field_5_reserved2 ) ; out . writeInt ( field_6_reserved3 ) ; }
public DescribeAppResult describeApp ( DescribeAppRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeApp ( request ) ; }
public Map < String , DirCacheEntry > getToBeCheckedOut ( ) { return toBeCheckedOut ; }
public CreatePublicVirtualInterfaceResult createPublicVirtualInterface ( CreatePublicVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePublicVirtualInterface ( request ) ; }
public CreateQueueResult createQueue ( String queueName ) { return createQueue ( new CreateQueueRequest ( ) . withQueueName ( queueName ) ) ; }
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 33 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 25 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } } } } for ( int i = 0 ; i < 33 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; }
public CreateFieldLevelEncryptionProfileResult createFieldLevelEncryptionProfile ( CreateFieldLevelEncryptionProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFieldLevelEncryptionProfile ( request ) ; }
public static int getSmileyResource ( int which ) { return sIconIds [ which ] ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SCL ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . numerator ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getNumerator ( ) ) ) . append ( " ▁ ( " ) . append ( getNumerator ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " ▁ ▁ ▁ ▁ . denominator ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getDenominator ( ) ) ) . append ( " ▁ ( " ) . append ( getDenominator ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " [ / SCL ] \ n " ) ; return buffer . toString ( ) ; }
public final void setBufferSize ( int newSize ) { assert buffer == null || bufferSize == buffer . length : " buffer = " + buffer + " ▁ bufferSize = " + bufferSize + " ▁ buffer . length = " + ( buffer != null ? buffer . length : 0 ) ; if ( newSize != bufferSize ) { checkBufferSize ( newSize ) ; bufferSize = newSize ; if ( buffer != null ) { byte [ ] newBuffer = new byte [ newSize ] ; final int leftInBuffer = bufferLength - bufferPosition ; final int numToCopy ; if ( leftInBuffer > newSize ) numToCopy = newSize ; elsenumToCopy = leftInBuffer ; System . arraycopy ( buffer , bufferPosition , newBuffer , 0 , numToCopy ) ; bufferStart += bufferPosition ; bufferPosition = 0 ; bufferLength = numToCopy ; newBuffer ( newBuffer ) ; } } }
public DisassociateSigninDelegateGroupsFromAccountResult disassociateSigninDelegateGroupsFromAccount ( DisassociateSigninDelegateGroupsFromAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateSigninDelegateGroupsFromAccount ( request ) ; }
public TokenStream create ( TokenStream input ) { return new IndicNormalizationFilter ( input ) ; }
public TickRecord ( RecordInputStream in ) { field_1_majorTickType = in . readByte ( ) ; field_2_minorTickType = in . readByte ( ) ; field_3_labelPosition = in . readByte ( ) ; field_4_background = in . readByte ( ) ; field_5_labelColorRgb = in . readInt ( ) ; field_6_zero1 = in . readInt ( ) ; field_7_zero2 = in . readInt ( ) ; field_8_zero3 = in . readInt ( ) ; field_9_zero4 = in . readInt ( ) ; field_10_options = in . readShort ( ) ; field_11_tickColor = in . readShort ( ) ; field_12_zero5 = in . readShort ( ) ; }
public long getPackedGitLimit ( ) { return packedGitLimit ; }
public DisassociateContactFromAddressBookResult disassociateContactFromAddressBook ( DisassociateContactFromAddressBookRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateContactFromAddressBook ( request ) ; }
public void writeShort ( int v ) { checkPosition ( 2 ) ; int i = _writeIndex ; _buf [ i ++ ] = ( byte ) ( ( v >>> 0 ) & 0xFF ) ; _buf [ i ++ ] = ( byte ) ( ( v >>> 8 ) & 0xFF ) ; _writeIndex = i ; }
public int read ( char [ ] c , int off , int len ) { if ( pos < size ) { len = Math . min ( len , size - pos ) ; s . getChars ( pos , pos + len , c , off ) ; pos += len ; return len ; } else { s = null ; return - 1 ; } }
public AssociateSkillWithUsersResult associateSkillWithUsers ( AssociateSkillWithUsersRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateSkillWithUsers ( request ) ; }
public boolean doPrune ( double ageSec , IndexSearcher searcher ) { return ageSec > maxAgeSec ; }
public DescribeObservationResult describeObservation ( DescribeObservationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeObservation ( request ) ; }
public DeletePresetResult deletePreset ( DeletePresetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeletePreset ( request ) ; }
public long ramBytesUsed ( ) { long size = 0 ; for ( Map . Entry < String , DocValuesProducer > entry : formats . entrySet ( ) ) { size += ( entry . getKey ( ) . length ( ) * Character . BYTES ) + entry . getValue ( ) . ramBytesUsed ( ) ; } return size ; }
public UserSViewBegin clone ( ) { return copy ( ) ; }
public char [ ] toCharArray ( ) { synchronized ( lock ) { char [ ] result = new char [ count ] ; System . arraycopy ( buf , 0 , result , 0 , count ) ; return result ; } }
public RebuildWorkspacesResult rebuildWorkspaces ( RebuildWorkspacesRequest request ) { request = beforeClientExecution ( request ) ; return executeRebuildWorkspaces ( request ) ; }
public GetLexiconResult getLexicon ( GetLexiconRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLexicon ( request ) ; }
public UpdateDeploymentStrategyResult updateDeploymentStrategy ( UpdateDeploymentStrategyRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDeploymentStrategy ( request ) ; }
public GetAlgorithmListRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " GetAlgorithmList " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public boolean isForceUpdate ( ) { return forceUpdate ; }
public ListGameServersResult listGameServers ( ListGameServersRequest request ) { request = beforeClientExecution ( request ) ; return executeListGameServers ( request ) ; }
public boolean delete ( ) { boolean rval = false ; if ( ( ! isRoot ( ) ) && isDeleteOK ( ) ) { rval = _parent . deleteEntry ( this ) ; } return rval ; }
public TableRecord ( RecordInputStream in ) { super ( in ) ; field_5_flags = in . readByte ( ) ; field_6_res = in . readByte ( ) ; field_7_rowInputRow = in . readShort ( ) ; field_8_colInputRow = in . readShort ( ) ; field_9_rowInputCol = in . readShort ( ) ; field_10_colInputCol = in . readShort ( ) ; }
public AllocateHostsResult allocateHosts ( AllocateHostsRequest request ) { request = beforeClientExecution ( request ) ; return executeAllocateHosts ( request ) ; }
public void writeContinue ( ) { _ulrOutput . terminate ( ) ; _totalPreviousRecordsSize += _ulrOutput . getTotalSize ( ) ; _ulrOutput = new UnknownLengthRecordOutput ( _out , ContinueRecord . sid ) ; }
public void unread ( byte [ ] buffer , int offset , int length ) throws IOException { if ( length > pos ) { throw new IOException ( " Pushback ▁ buffer ▁ full " ) ; } Arrays . checkOffsetAndCount ( buffer . length , offset , length ) ; if ( buf == null ) { throw streamClosed ( ) ; } System . arraycopy ( buffer , offset , buf , pos - length , length ) ; pos = pos - length ; }
public boolean containsCell ( BookSheetKey key , int rowIndex , int columnIndex ) { BlankCellSheetGroup bcsg = _sheetGroupsByBookSheet . get ( key ) ; if ( bcsg == null ) { return false ; } return bcsg . containsCell ( rowIndex , columnIndex ) ; }
public DescribeTextTranslationJobResult describeTextTranslationJob ( DescribeTextTranslationJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTextTranslationJob ( request ) ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; if ( remainingData == null ) { remainingData = new byte [ 0 ] ; } LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = remainingData . length + ( shortRecord ? 8 : 18 ) ; LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; LittleEndian . putShort ( data , offset + 8 , field_1_flag ) ; LittleEndian . putShort ( data , offset + 10 , field_2_col1 ) ; LittleEndian . putShort ( data , offset + 12 , field_3_dx1 ) ; LittleEndian . putShort ( data , offset + 14 , field_4_row1 ) ; if ( ! shortRecord ) { LittleEndian . putShort ( data , offset + 16 , field_5_dy1 ) ; LittleEndian . putShort ( data , offset + 18 , field_6_col2 ) ; LittleEndian . putShort ( data , offset + 20 , field_7_dx2 ) ; LittleEndian . putShort ( data , offset + 22 , field_8_row2 ) ; LittleEndian . putShort ( data , offset + 24 , field_9_dy2 ) ; } System . arraycopy ( remainingData , 0 , data , offset + ( shortRecord ? 16 : 26 ) , remainingData . length ) ; int pos = offset + 8 + ( shortRecord ? 8 : 18 ) + remainingData . length ; listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; }
public final void serialize ( LittleEndianOutput out ) { int nBreaks = _breaks . size ( ) ; out . writeShort ( nBreaks ) ; for ( Break aBreak : _breaks ) { aBreak . serialize ( out ) ; } }
public float baselineTf ( float freq ) { if ( 0.0f == freq ) return 0.0f ; return ( freq <= tf_min ) ? tf_base : ( float ) Math . sqrt ( freq + ( tf_base * tf_base ) - tf_min ) ; }
public StringBuilder delete ( int start , int end ) { delete0 ( start , end ) ; return this ; }
public boolean isError ( ) { return this . type == TYPE_MALFORMED_INPUT || this . type == TYPE_UNMAPPABLE_CHAR ; }
public int getLastSheetIndexFromExternSheetIndex ( int externSheetNumber ) { return linkTable . getLastInternalSheetIndexForExtIndex ( externSheetNumber ) ; }
public PlainTextDictionary ( InputStream dictFile ) { in = new BufferedReader ( IOUtils . getDecodingReader ( dictFile , StandardCharsets . UTF_8 ) ) ; }
public LittleEndianByteArrayOutputStream ( byte [ ] buf , int startOffset , int maxWriteLen ) { if ( startOffset < 0 || startOffset > buf . length ) { throw new IllegalArgumentException ( " Specified ▁ startOffset ▁ ( " + startOffset + " ) ▁ is ▁ out ▁ of ▁ allowable ▁ range ▁ ( 0.. " + buf . length + " ) " ) ; } _buf = buf ; _writeIndex = startOffset ; _endIndex = startOffset + maxWriteLen ; if ( _endIndex < startOffset || _endIndex > buf . length ) { throw new IllegalArgumentException ( " calculated ▁ end ▁ index ▁ ( " + _endIndex + " ) ▁ is ▁ out ▁ of ▁ allowable ▁ range ▁ ( " + _writeIndex + " .. " + buf . length + " ) " ) ; } }
public void addRecords ( MergeCellsRecord [ ] mcrs ) { for ( int i = 0 ; i < mcrs . length ; i ++ ) { addMergeCellsRecord ( mcrs [ i ] ) ; } }
public DescribeInternetGatewaysResult describeInternetGateways ( DescribeInternetGatewaysRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInternetGateways ( request ) ; }
public void removeLastSaveDateTime ( ) { remove1stProperty ( PropertyIDMap . PID_LASTSAVE_DTM ) ; }
public boolean hitEnd ( ) { return hitEndImpl ( address ) ; }
public ListSkillsResult listSkills ( ListSkillsRequest request ) { request = beforeClientExecution ( request ) ; return executeListSkills ( request ) ; }
public String toString ( ) { return " popMode " ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 16 ) | ( byte1 << 8 ) | byte2 ; } }
public GetCloudFrontOriginAccessIdentityResult getCloudFrontOriginAccessIdentity ( GetCloudFrontOriginAccessIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCloudFrontOriginAccessIdentity ( request ) ; }
public boolean include ( RevWalk walker , RevCommit c ) { return false ; }
public DocumentStoredFieldVisitor ( ) { this . fieldsToAdd = null ; }
public int addConditionalFormatting ( CellRangeAddress [ ] regions , HSSFConditionalFormattingRule [ ] cfRules ) { if ( regions == null ) { throw new IllegalArgumentException ( " regions ▁ must ▁ not ▁ be ▁ null " ) ; } for ( CellRangeAddress range : regions ) range . validate ( SpreadsheetVersion . EXCEL97 ) ; if ( cfRules == null ) { throw new IllegalArgumentException ( " cfRules ▁ must ▁ not ▁ be ▁ null " ) ; } if ( cfRules . length == 0 ) { throw new IllegalArgumentException ( " cfRules ▁ must ▁ not ▁ be ▁ empty " ) ; } if ( cfRules . length > 3 ) { throw new IllegalArgumentException ( " Number ▁ of ▁ rules ▁ must ▁ not ▁ exceed ▁ 3 " ) ; } CFRuleBase [ ] rules = new CFRuleBase [ cfRules . length ] ; for ( int i = 0 ; i != cfRules . length ; i ++ ) { rules [ i ] = cfRules [ i ] . getCfRuleRecord ( ) ; } CFRecordsAggregate cfra = new CFRecordsAggregate ( regions , rules ) ; return _conditionalFormattingTable . add ( cfra ) ; }
public FloatBuffer get ( float [ ] dst , int dstOffset , int floatCount ) { Arrays . checkOffsetAndCount ( dst . length , dstOffset , floatCount ) ; if ( floatCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } for ( int i = dstOffset ; i < dstOffset + floatCount ; ++ i ) { dst [ i ] = get ( ) ; } return this ; }
public void rewind ( ) { pos = 0 ; }
public boolean include ( TreeWalk walker ) { final int cmp = walker . isPathPrefix ( raw , raw . length ) ; if ( cmp > 0 ) throw StopWalkException . INSTANCE ; return cmp == 0 ; }
public TagDeliveryStreamResult tagDeliveryStream ( TagDeliveryStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeTagDeliveryStream ( request ) ; }
public NormalisedDecimal normaliseBaseTen ( ) { return NormalisedDecimal . create ( _significand , _binaryExponent ) ; }
public NavigableSet < K > descendingKeySet ( ) { return new BoundedMap ( ! ascending , from , fromBound , to , toBound ) . navigableKeySet ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _row ) ; out . writeShort ( _firstCol ) ; int nItems = _xfs . length ; for ( short xf : _xfs ) { out . writeShort ( xf ) ; } out . writeShort ( _lastCol ) ; }
public byte [ ] toByteArray ( ) { byte [ ] result = new byte [ LONG_SIZE ] ; LittleEndian . putLong ( result , 0 , fileTime ) ; return result ; }
public DiffCommand diff ( ) { return new DiffCommand ( repo ) ; }
public ModifySnapshotAttributeResult modifySnapshotAttribute ( ModifySnapshotAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifySnapshotAttribute ( request ) ; }
public CreateSubnetResult createSubnet ( CreateSubnetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSubnet ( request ) ; }
@ Override public List < E > subList ( int start , int end ) { return new UnmodifiableRandomAccessList < E > ( list . subList ( start , end ) ) ; }
public long getClipboardFormat ( ) throws HPSFException { if ( ! ( getClipboardFormatTag ( ) == CFTAG_WINDOWS ) ) throw new HPSFException ( " Clipboard ▁ Format ▁ Tag ▁ of ▁ Thumbnail ▁ must ▁ " + " be ▁ CFTAG □ WINDOWS . " ) ; return LittleEndian . getInt ( getThumbnail ( ) , OFFSET_CF ) ; }
public HSSFDataValidation ( CellRangeAddressList regions , DataValidationConstraint constraint ) { _regions = regions ; _constraint = ( DVConstraint ) constraint ; }
public DiffCommand setProgressMonitor ( ProgressMonitor monitor ) { if ( monitor == null ) { monitor = NullProgressMonitor . INSTANCE ; } this . monitor = monitor ; return this ; }
public DeleteSegmentResult deleteSegment ( DeleteSegmentRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSegment ( request ) ; }
public AcceptVpcPeeringConnectionResult acceptVpcPeeringConnection ( AcceptVpcPeeringConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeAcceptVpcPeeringConnection ( request ) ; }
public final FloatBuffer put ( float [ ] src ) { return put ( src , 0 , src . length ) ; }
public PortugueseLightStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public RefPtg ( int row , int column , boolean isRowRelative , boolean isColumnRelative ) { super ( row , column , isRowRelative , isColumnRelative ) ; }
public ExportJournalToS3Result exportJournalToS3 ( ExportJournalToS3Request request ) { request = beforeClientExecution ( request ) ; return executeExportJournalToS3 ( request ) ; }
public AssociatePhoneNumbersWithVoiceConnectorGroupResult associatePhoneNumbersWithVoiceConnectorGroup ( AssociatePhoneNumbersWithVoiceConnectorGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociatePhoneNumbersWithVoiceConnectorGroup ( request ) ; }
public RecursivePrefixTreeStrategy ( SpatialPrefixTree grid , String fieldName ) { super ( grid , fieldName ) ; prefixGridScanLevel = grid . getMaxLevels ( ) - 4 ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { values [ valuesOffset ++ ] = ( ( blocks [ blocksOffset ++ ] & 0xFFL ) << 8 ) | ( blocks [ blocksOffset ++ ] & 0xFFL ) ; } }
public GetAlbumsByNamesRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetAlbumsByNames " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public SendRawEmailRequest ( RawMessage rawMessage ) { setRawMessage ( rawMessage ) ; }
public boolean equals ( Object other ) { return sameClassAs ( other ) && equalsTo ( getClass ( ) . cast ( other ) ) ; }
public Rule ( String suffix , int min , String replacement ) { this . suffix = suffix . toCharArray ( ) ; this . replacement = replacement . toCharArray ( ) ; this . min = min ; }
public ListDataSetsResult listDataSets ( ListDataSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDataSets ( request ) ; }
public int lastIndexOf ( E object , int to ) { Object [ ] snapshot = elements ; return lastIndexOf ( object , snapshot , 0 , to ) ; }
public DBCluster stopDBCluster ( StopDBClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeStopDBCluster ( request ) ; }
public ListRuleNamesByTargetResult listRuleNamesByTarget ( ListRuleNamesByTargetRequest request ) { request = beforeClientExecution ( request ) ; return executeListRuleNamesByTarget ( request ) ; }
public void readFully ( byte [ ] buf , int off , int len ) { _in . readFully ( buf , off , len ) ; }
public SSTRecord ( RecordInputStream in ) { field_1_num_strings = in . readInt ( ) ; field_2_num_unique_strings = in . readInt ( ) ; field_3_strings = new IntMapper <> ( ) ; deserializer = new SSTDeserializer ( field_3_strings ) ; if ( field_1_num_strings == 0 ) { field_2_num_unique_strings = 0 ; return ; } deserializer . manufactureStrings ( field_2_num_unique_strings , in ) ; }
public DeleteBatchPredictionResult deleteBatchPrediction ( DeleteBatchPredictionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteBatchPrediction ( request ) ; }
public SetReceiptRulePositionResult setReceiptRulePosition ( SetReceiptRulePositionRequest request ) { request = beforeClientExecution ( request ) ; return executeSetReceiptRulePosition ( request ) ; }
public Ref3DPtg ( String cellref , int externIdx ) { this ( new CellReference ( cellref ) , externIdx ) ; }
public DisableAvailabilityZonesForLoadBalancerRequest ( String loadBalancerName , java . util . List < String > availabilityZones ) { setLoadBalancerName ( loadBalancerName ) ; setAvailabilityZones ( availabilityZones ) ; }
public Set < Entry < K , V >> entrySet ( ) { Set < Entry < K , V >> es = entrySet ; return ( es != null ) ? es : ( entrySet = new EntrySet ( ) ) ; }
public char [ ] get ( int posStart , int length ) { assert length > 0 ; assert inBounds ( posStart ) : " posStart = " + posStart + " ▁ length = " + length ; final int startIndex = getIndex ( posStart ) ; final int endIndex = getIndex ( posStart + length ) ; final char [ ] result = new char [ length ] ; if ( endIndex >= startIndex && length < buffer . length ) { System . arraycopy ( buffer , startIndex , result , 0 , endIndex - startIndex ) ; } else { final int part1 = buffer . length - startIndex ; System . arraycopy ( buffer , startIndex , result , 0 , part1 ) ; System . arraycopy ( buffer , 0 , result , buffer . length - startIndex , length - part1 ) ; } return result ; }
public IndexInput openInput ( String name , IOContext context ) throws IOException { ensureOpen ( ) ; if ( context . context != Context . MERGE || context . mergeInfo . estimatedMergeBytes < minBytesDirect || fileLength ( name ) < minBytesDirect ) { return delegate . openInput ( name , context ) ; } else { return new NativeUnixIndexInput ( getDirectory ( ) . resolve ( name ) , mergeBufferSize ) ; } }
public EscherArrayProperty ( short id , byte [ ] complexData ) { this ( id , safeSize ( complexData == null ? 0 : complexData . length ) ) ; setComplexData ( complexData ) ; }
public NamePtg ( int nameIndex ) { field_1_label_index = 1 + nameIndex ; }
public DescribeHumanLoopResult describeHumanLoop ( DescribeHumanLoopRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeHumanLoop ( request ) ; }
public PutDedicatedIpInPoolResult putDedicatedIpInPool ( PutDedicatedIpInPoolRequest request ) { request = beforeClientExecution ( request ) ; return executePutDedicatedIpInPool ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getName ( ) ) . append ( " ▁ [ XCT " ) ; sb . append ( " ▁ nCRNs = " ) . append ( field_1_number_crn_records ) ; sb . append ( " ▁ sheetIx = " ) . append ( field_2_sheet_table_index ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public ObjectId idFor ( int objectType , long length , InputStream in ) throws IOException { SHA1 md = SHA1. newInstance ( ) ; md . update ( Constants . encodedTypeString ( objectType ) ) ; md . update ( ( byte ) ' ▁ ' ) ; md . update ( Constants . encodeASCII ( length ) ) ; md . update ( ( byte ) 0 ) ; byte [ ] buf = buffer ( ) ; while ( length > 0 ) { int n = in . read ( buf , 0 , ( int ) Math . min ( length , buf . length ) ) ; if ( n < 0 ) throw new EOFException ( JGitText . get ( ) . unexpectedEndOfInput ) ; md . update ( buf , 0 , n ) ; length -= n ; } return md . toObjectId ( ) ; }
public List < Query > makeLuceneSubQueriesField ( String fn , BasicQueryFactory qf ) { List < Query > luceneSubQueries = new ArrayList <> ( ) ; Iterator < SrndQuery > sqi = getSubQueriesIterator ( ) ; while ( sqi . hasNext ( ) ) { luceneSubQueries . add ( ( sqi . next ( ) ) . makeLuceneQueryField ( fn , qf ) ) ; } return luceneSubQueries ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SHARED ▁ FEATURE ] \ n " ) ; buffer . append ( " [ / SHARED ▁ FEATURE ] \ n " ) ; return buffer . toString ( ) ; }
public QueryNode process ( QueryNode queryTree ) throws QueryNodeException { Operator op = getQueryConfigHandler ( ) . get ( ConfigurationKeys . DEFAULT_OPERATOR ) ; if ( op == null ) { throw new IllegalArgumentException ( " StandardQueryConfigHandler . ConfigurationKeys . DEFAULT □ OPERATOR ▁ should ▁ be ▁ set ▁ on ▁ the ▁ QueryConfigHandler " ) ; } this . usingAnd = StandardQueryConfigHandler . Operator . AND == op ; return processIteration ( queryTree ) ; }
public DBCluster startDBCluster ( StartDBClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeStartDBCluster ( request ) ; }
public Ptg [ ] getParsedExpression ( ) { return Formula . getTokens ( field_5_name_definition ) ; }
public final long getFilePointer ( ) { return bufferStart + bufferPosition ; }
public ListDevicesResult listDevices ( ListDevicesRequest request ) { request = beforeClientExecution ( request ) ; return executeListDevices ( request ) ; }
public ApplyTokenRequest ( ) { super ( " OnsMqtt " , " 2019 - 12 - 11 " , " ApplyToken " , " onsmqtt " ) ; setMethod ( MethodType . POST ) ; }
public EnableVpcClassicLinkDnsSupportResult enableVpcClassicLinkDnsSupport ( EnableVpcClassicLinkDnsSupportRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableVpcClassicLinkDnsSupport ( request ) ; }
public Cluster modifyClusterDbRevision ( ModifyClusterDbRevisionRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyClusterDbRevision ( request ) ; }
public final LongBuffer put ( long [ ] src ) { return put ( src , 0 , src . length ) ; }
public Object clone ( ) { try { return super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new AssertionError ( ) ; } }
public LinkFaceRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " LinkFace " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public RemoveAttributesResult removeAttributes ( RemoveAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveAttributes ( request ) ; }
public boolean remove ( Object o ) { return ConcurrentHashMap . this . remove ( o ) != null ; }
public String toFormulaString ( String [ ] operands ) { return " ( " + operands [ 0 ] + " ) " ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PostingsAndFreq other = ( PostingsAndFreq ) obj ; if ( position != other . position ) return false ; if ( terms == null ) return other . terms == null ; return Arrays . equals ( terms , other . terms ) ; }
public ModifyMountTargetSecurityGroupsResult modifyMountTargetSecurityGroups ( ModifyMountTargetSecurityGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyMountTargetSecurityGroups ( request ) ; }
public ListBatchInferenceJobsResult listBatchInferenceJobs ( ListBatchInferenceJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListBatchInferenceJobs ( request ) ; }
public long get ( int i ) { if ( count <= i ) throw new ArrayIndexOutOfBoundsException ( i ) ; return entries [ i ] ; }
public LimitTokenPositionFilterFactory ( Map < String , String > args ) { super ( args ) ; maxTokenPosition = requireInt ( args , MAX_TOKEN_POSITION_KEY ) ; consumeAllTokens = getBoolean ( args , CONSUME_ALL_TOKENS_KEY , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public SaveRecalcRecord ( RecordInputStream in ) { field_1_recalc = in . readShort ( ) ; }
public DeleteSecurityGroupResult deleteSecurityGroup ( DeleteSecurityGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSecurityGroup ( request ) ; }
public IntervalSet getExpectedTokens ( ) { return getATN ( ) . getExpectedTokens ( getState ( ) , getContext ( ) ) ; }
public void print ( long l ) { print ( String . valueOf ( l ) ) ; }
public ResetPersonalPINResult resetPersonalPIN ( ResetPersonalPINRequest request ) { request = beforeClientExecution ( request ) ; return executeResetPersonalPIN ( request ) ; }
public StartSmartHomeApplianceDiscoveryResult startSmartHomeApplianceDiscovery ( StartSmartHomeApplianceDiscoveryRequest request ) { request = beforeClientExecution ( request ) ; return executeStartSmartHomeApplianceDiscovery ( request ) ; }
public Query parse ( String queryText ) { if ( " * " . equals ( queryText . trim ( ) ) ) { return new MatchAllDocsQuery ( ) ; } char data [ ] = queryText . toCharArray ( ) ; char buffer [ ] = new char [ data . length ] ; State state = new State ( data , buffer , 0 , data . length ) ; parseSubQuery ( state ) ; if ( state . top == null ) { return new MatchNoDocsQuery ( " empty ▁ string ▁ passed ▁ to ▁ query ▁ parser " ) ; } else { return state . top ; } }
public void set ( int val ) { this . val = val ; returned = false ; }
public Set < URIishField > getRequiredFields ( ) { return Collections . unmodifiableSet ( EnumSet . of ( URIishField . PATH ) ) ; }
public Config ( Config defaultConfig ) { baseConfig = defaultConfig ; state = new AtomicReference <> ( newState ( ) ) ; }
public PutAccountSuppressionAttributesResult putAccountSuppressionAttributes ( PutAccountSuppressionAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executePutAccountSuppressionAttributes ( request ) ; }
public BufferedIndexInput ( String resourceDesc , int bufferSize ) { super ( resourceDesc ) ; checkBufferSize ( bufferSize ) ; this . bufferSize = bufferSize ; }
public DescribeDocumentClassifierResult describeDocumentClassifier ( DescribeDocumentClassifierRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDocumentClassifier ( request ) ; }
public static Function getBasicFunction ( int functionIndex ) { switch ( functionIndex ) { case FunctionID . INDIRECT : case FunctionID . EXTERNAL_FUNC : return null ; } Function result = functions [ functionIndex ] ; if ( result == null ) { throw new NotImplementedException ( " FuncIx = " + functionIndex ) ; } return result ; }
public DeleteFacetResult deleteFacet ( DeleteFacetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFacet ( request ) ; }
public NameXPtg getNameXPtg ( String name , int sheetRefIndex , UDFFinder udf ) { LinkTable lnk = getOrCreateLinkTable ( ) ; NameXPtg xptg = lnk . getNameXPtg ( name , sheetRefIndex ) ; if ( xptg == null && udf . findFunction ( name ) != null ) { xptg = lnk . addNameXPtg ( name ) ; } return xptg ; }
public int getIndex ( ) { return index ; }
public final String toFormulaString ( ) { return formatReferenceAsString ( ) ; }
public AllocateTransitVirtualInterfaceResult allocateTransitVirtualInterface ( AllocateTransitVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeAllocateTransitVirtualInterface ( request ) ; }
public PushbackInputStream ( InputStream in ) { super ( in ) ; buf = ( in == null ) ? null : new byte [ 1 ] ; pos = 1 ; }
public int compareTo ( PostingsAndFreq other ) { if ( position != other . position ) { return position - other . position ; } if ( nTerms != other . nTerms ) { return nTerms - other . nTerms ; } if ( nTerms == 0 ) { return 0 ; } for ( int i = 0 ; i < terms . length ; i ++ ) { int res = terms [ i ] . compareTo ( other . terms [ i ] ) ; if ( res != 0 ) return res ; } return 0 ; }
public void notifyUpdateCell ( EvaluationCell cell ) { int sheetIndex = getSheetIndex ( cell . getSheet ( ) ) ; _cache . notifyUpdateCell ( _workbookIx , sheetIndex , cell ) ; }
public BatchRefUpdate setAllowNonFastForwards ( boolean allow ) { allowNonFastForwards = allow ; return this ; }
public UpdateRouteResult updateRoute ( UpdateRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRoute ( request ) ; }
public DoubleConstValueSource ( double constant ) { this . constant = constant ; this . fv = ( float ) constant ; this . lv = ( long ) constant ; }
public void yypushback ( int number ) { if ( number > yylength ( ) ) zzScanError ( ZZ_PUSHBACK_2BIG ) ; zzMarkedPos -= number ; }
public int getReturnState ( int index ) { return returnStates [ index ] ; }
final public SrndQuery WQuery ( ) throws ParseException { SrndQuery q ; ArrayList < SrndQuery > queries ; Token wt ; q = PrimaryQuery ( ) ; label_6 : while ( true ) { switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case W : ; break ; default : jj_la1 [ 4 ] = jj_gen ; break label_6 ; } wt = jj_consume_token ( W ) ; queries = new ArrayList < SrndQuery > ( ) ; queries . add ( q ) ; q = PrimaryQuery ( ) ; queries . add ( q ) ; q = getDistanceQuery ( queries , true , wt , true ) ; } { if ( true ) return q ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public ListHITsResult listHITs ( ListHITsRequest request ) { request = beforeClientExecution ( request ) ; return executeListHITs ( request ) ; }
public Set < String > getSubsections ( String section ) { return getState ( ) . getSubsections ( section ) ; }
public AttachDiskResult attachDisk ( AttachDiskRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachDisk ( request ) ; }
public DescribePoliciesResult describePolicies ( DescribePoliciesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribePolicies ( request ) ; }
public boolean isEmpty ( ) { return _limit == 0 ; }
public HSSFCombobox ( HSSFShape parent , HSSFAnchor anchor ) { super ( parent , anchor ) ; super . setShapeType ( OBJECT_TYPE_COMBO_BOX ) ; CommonObjectDataSubRecord cod = ( CommonObjectDataSubRecord ) getObjRecord ( ) . getSubRecords ( ) . get ( 0 ) ; cod . setObjectType ( CommonObjectDataSubRecord . OBJECT_TYPE_COMBO_BOX ) ; }
public void setCalcMode ( short calcmode ) { field_1_calcmode = calcmode ; }
public void resize ( double scale ) { resize ( scale , scale ) ; }
public AssociateAddressResult associateAddress ( AssociateAddressRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateAddress ( request ) ; }
public ConfirmConnectionResult confirmConnection ( ConfirmConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeConfirmConnection ( request ) ; }
public UseSelFSRecord ( boolean b ) { this ( 0 ) ; _options = useNaturalLanguageFormulasFlag . setBoolean ( _options , b ) ; }
public void start ( String originalText , TokenStream stream ) { offsetAtt = stream . addAttribute ( OffsetAttribute . class ) ; currentNumFrags = 1 ; }
public FieldFragList createFieldFragList ( FieldPhraseList fieldPhraseList , int fragCharSize ) { return createFieldFragList ( fieldPhraseList , new SimpleFieldFragList ( fragCharSize ) , fragCharSize ) ; }
public StopImageBuilderResult stopImageBuilder ( StopImageBuilderRequest request ) { request = beforeClientExecution ( request ) ; return executeStopImageBuilder ( request ) ; }
public final int readUnsignedShort ( ) throws IOException { return ( ( int ) readShort ( ) ) & 0xffff ; }
public static long pop_xor ( long [ ] arr1 , long [ ] arr2 , int wordOffset , int numWords ) { long popCount = 0 ; for ( int i = wordOffset , end = wordOffset + numWords ; i < end ; ++ i ) { popCount += Long . bitCount ( arr1 [ i ] ^ arr2 [ i ] ) ; } return popCount ; }
public GetDocumentResult getDocument ( GetDocumentRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDocument ( request ) ; }
public AutocompletePagedResponse ( SimpleResponse < AutocompleteResult > autocompleteResponse ) { super ( autocompleteResponse . getRequest ( ) , autocompleteResponse . getStatusCode ( ) , autocompleteResponse . getHeaders ( ) , autocompleteResponse . getValue ( ) . getResults ( ) , null , null ) ; }
public PutPermissionResult putPermission ( PutPermissionRequest request ) { request = beforeClientExecution ( request ) ; return executePutPermission ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( 0 ) ; out . writeInt ( getFirstRow ( ) ) ; out . writeInt ( getLastRowAdd1 ( ) ) ; out . writeInt ( field_4_zero ) ; for ( int k = 0 ; k < getNumDbcells ( ) ; k ++ ) { out . writeInt ( getDbcellAt ( k ) ) ; } }
public HSSFFormulaEvaluator ( HSSFWorkbook workbook ) { this ( workbook , null ) ; }
public int hash2 ( char carray [ ] ) { int hash = 5381 ; for ( int i = 0 ; i < carray . length ; i ++ ) { char d = carray [ i ] ; hash = ( ( hash << 5 ) + hash ) + d & 0x00FF ; hash = ( ( hash << 5 ) + hash ) + d >> 8 ; } return hash ; }
public void fillRoundRect ( int x , int y , int width , int height , int arcWidth , int arcHeight ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , " fillRoundRect ▁ not ▁ supported " ) ; }
public static SimpleFraction buildFractionExactDenominator ( double val , int exactDenom ) { int num = ( int ) Math . round ( val * exactDenom ) ; return new SimpleFraction ( num , exactDenom ) ; }
public DescribeInsightRulesResult describeInsightRules ( DescribeInsightRulesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInsightRules ( request ) ; }
public ListMFADevicesRequest ( String userName ) { setUserName ( userName ) ; }
public void removeRow ( RowRecord row ) { int rowIndex = row . getRowNumber ( ) ; _valuesAgg . removeAllCellsValuesForRow ( rowIndex ) ; Integer key = Integer . valueOf ( rowIndex ) ; RowRecord rr = _rowRecords . remove ( key ) ; if ( rr == null ) { throw new RuntimeException ( " Invalid ▁ row ▁ index ▁ ( " + key . intValue ( ) + " ) " ) ; } if ( row != rr ) { _rowRecords . put ( key , rr ) ; throw new RuntimeException ( " Attempt ▁ to ▁ remove ▁ row ▁ that ▁ does ▁ not ▁ belong ▁ to ▁ this ▁ sheet " ) ; } _rowRecordValues = null ; }
public DeleteRepositoryPolicyResult deleteRepositoryPolicy ( DeleteRepositoryPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRepositoryPolicy ( request ) ; }
public BackupRecord ( RecordInputStream in ) { field_1_backup = in . readShort ( ) ; }
public DiffCommand setNewTree ( AbstractTreeIterator newTree ) { this . newTree = newTree ; return this ; }
public void decode ( long [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; for ( int shift = 63 ; shift >= 0 ; shift -= 1 ) { values [ valuesOffset ++ ] = ( block >>> shift ) & 1 ; } } }
public void execute ( Lexer lexer ) { action . execute ( lexer ) ; }
public DeleteModelPackageResult deleteModelPackage ( DeleteModelPackageRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteModelPackage ( request ) ; }
public Object getValue ( ) { return value ; }
public void applyFont ( short fontIndex ) { applyFont ( 0 , _string . getCharCount ( ) , fontIndex ) ; }
public SliceWriter ( IntBlockPool pool ) { this . pool = pool ; }
public DisableVgwRoutePropagationResult disableVgwRoutePropagation ( DisableVgwRoutePropagationRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableVgwRoutePropagation ( request ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + _name . getNameText ( ) + " ] " ; }
public AttachObjectResult attachObject ( AttachObjectRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachObject ( request ) ; }
public DBClusterParameterGroup copyDBClusterParameterGroup ( CopyDBClusterParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCopyDBClusterParameterGroup ( request ) ; }
public GetRoutesResult getRoutes ( GetRoutesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRoutes ( request ) ; }
public Entry < String , Ref > next ( ) { if ( hasNext ( ) ) { Entry < String , Ref > r = next ; next = peek ( ) ; return r ; } throw new NoSuchElementException ( ) ; }
public boolean containsKey ( Object key ) { return ( ( key instanceof Long && dictionary . containsKey ( key ) ) || dictionary . containsValue ( key ) ) ; }
public UpdateNamespaceRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " UpdateNamespace " , " cr " ) ; setUriPattern ( " / namespace / [ Namespace ] " ) ; setMethod ( MethodType . POST ) ; }
public ListNotebookInstancesResult listNotebookInstances ( ListNotebookInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeListNotebookInstances ( request ) ; }
public RoaringDocIdSet build ( ) { flush ( ) ; return new RoaringDocIdSet ( sets , cardinality ) ; }
public DescribeGroupsResult describeGroups ( DescribeGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeGroups ( request ) ; }
public GetShippingLabelResult getShippingLabel ( GetShippingLabelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetShippingLabel ( request ) ; }
public MonitorInstancesRequest ( java . util . List < String > instanceIds ) { setInstanceIds ( instanceIds ) ; }
public AtomTransition ( ATNState target , int label ) { super ( target ) ; this . label = label ; }
public MulRKRecord ( RecordInputStream in ) { field_1_row = in . readUShort ( ) ; field_2_first_col = in . readShort ( ) ; field_3_rks = RkRec . parseRKs ( in ) ; field_4_last_col = in . readShort ( ) ; }
public State complete ( ) { if ( this . stateRegistry == null ) throw new IllegalStateException ( ) ; if ( root . hasChildren ( ) ) replaceOrRegister ( root ) ; stateRegistry = null ; return root ; }
public DescribeWorkspaceDirectoriesResult describeWorkspaceDirectories ( DescribeWorkspaceDirectoriesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWorkspaceDirectories ( request ) ; }
@ Override public E remove ( int index ) { synchronized ( CopyOnWriteArrayList . this ) { slice . checkElementIndex ( index ) ; slice . checkConcurrentModification ( elements ) ; E removed = CopyOnWriteArrayList . this . remove ( slice . from + index ) ; slice = new Slice ( elements , slice . from , slice . to - 1 ) ; return removed ; } }
public StreamTokenizer ( InputStream is ) { this ( ) ; if ( is == null ) { throw new NullPointerException ( ) ; } inStream = is ; }
public ModifyVpcPeeringConnectionOptionsResult modifyVpcPeeringConnectionOptions ( ModifyVpcPeeringConnectionOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVpcPeeringConnectionOptions ( request ) ; }
public GetAppResult getApp ( GetAppRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApp ( request ) ; }
public void start ( int totalTasks ) { if ( ! isMainThread ( ) ) throw new IllegalStateException ( ) ; pm . start ( totalTasks ) ; }
public ModifyFleetResult modifyFleet ( ModifyFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyFleet ( request ) ; }
public UpdateFolderResult updateFolder ( UpdateFolderRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFolder ( request ) ; }
public CreateAppResult createApp ( CreateAppRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateApp ( request ) ; }
public static DVConstraint createDateConstraint ( int comparisonOperator , String expr1 , String expr2 , String dateFormat ) { if ( expr1 == null ) { throw new IllegalArgumentException ( " expr1 ▁ must ▁ be ▁ supplied " ) ; } OperatorType . validateSecondArg ( comparisonOperator , expr2 ) ; SimpleDateFormat df = null ; if ( dateFormat != null ) { df = new SimpleDateFormat ( dateFormat , LocaleUtil . getUserLocale ( ) ) ; df . setTimeZone ( LocaleUtil . getUserTimeZone ( ) ) ; } String formula1 = getFormulaFromTextExpression ( expr1 ) ; Double value1 = formula1 == null ? convertDate ( expr1 , df ) : null ; String formula2 = getFormulaFromTextExpression ( expr2 ) ; Double value2 = formula2 == null ? convertDate ( expr2 , df ) : null ; return new DVConstraint ( ValidationType . DATE , comparisonOperator , formula1 , formula2 , value1 , value2 , null ) ; }
public final String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + lookupName ( _functionIndex ) + " ▁ nArgs = " + _numberOfArgs + " ] " ; }
public ModifyDefaultCreditSpecificationResult modifyDefaultCreditSpecification ( ModifyDefaultCreditSpecificationRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDefaultCreditSpecification ( request ) ; }
public Iterator < Note > iterator ( ) { try { return root . iterator ( new MutableObjectId ( ) , reader ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public ObjectId idFor ( TreeFormatter formatter ) { return delegate ( ) . idFor ( formatter ) ; }
public int getInputLength ( ) { return this . inputLength ; }
public void onInvalidated ( ) { Log . d ( TAG , mSrc + " : ▁ invalidated " ) ; }
public TerminalNode addChild ( Token matchedToken ) { TerminalNodeImpl t = new TerminalNodeImpl ( matchedToken ) ; addAnyChild ( t ) ; t . setParent ( this ) ; return t ; }
public boolean isUnknown ( ) { return type == Type . UNKNOWN ; }
public boolean promptPassword ( String msg ) { CredentialItem . Password p = new CredentialItem . Password ( msg ) ; if ( provider . get ( uri , p ) ) { password = new String ( p . getValue ( ) ) ; return true ; } password = null ; return false ; }
public CreateTransitGatewayResult createTransitGateway ( CreateTransitGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTransitGateway ( request ) ; }
public CreateCampaignResult createCampaign ( CreateCampaignRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCampaign ( request ) ; }
public ClientException ( String errCode , String errMsg ) { super ( errCode + " ▁ : ▁ " + errMsg ) ; this . errCode = errCode ; this . errMsg = errMsg ; this . setErrorType ( ErrorType . Client ) ; }
public void removeConditionalFormatting ( int index ) { _conditionalFormattingTable . remove ( index ) ; }
public static void fill ( float [ ] array , float value ) { for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = value ; } }
public TokenStream create ( TokenStream input ) { return dictionary == null ? input : new StemmerOverrideFilter ( input , dictionary ) ; }
public ListS3ResourcesResult listS3Resources ( ListS3ResourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeListS3Resources ( request ) ; }
public String toString ( ) { return new StringBuilder ( " ' " ) . appendCodePoint ( from ) . append ( " ' .. ' " ) . appendCodePoint ( to ) . append ( " ' " ) . toString ( ) ; }
public DoubleBuffer compact ( ) { System . arraycopy ( backingArray , position + offset , backingArray , offset , remaining ( ) ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public CreatePresignedNotebookInstanceUrlResult createPresignedNotebookInstanceUrl ( CreatePresignedNotebookInstanceUrlRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePresignedNotebookInstanceUrl ( request ) ; }
public IterationRecord ( RecordInputStream in ) { _flags = in . readShort ( ) ; }
public CreateUserInfoRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " CreateUserInfo " , " cr " ) ; setUriPattern ( " / users " ) ; setMethod ( MethodType . PUT ) ; }
public void notifyUpdatedBlankCell ( BookSheetKey bsk , int rowIndex , int columnIndex , IEvaluationListener evaluationListener ) { if ( _usedBlankCellGroup != null ) { if ( _usedBlankCellGroup . containsCell ( bsk , rowIndex , columnIndex ) ) { clearFormulaEntry ( ) ; recurseClearCachedFormulaResults ( evaluationListener ) ; } } }
public IntervalSet addAll ( IntSet set ) { if ( set == null ) { return this ; } if ( set instanceof IntervalSet ) { IntervalSet other = ( IntervalSet ) set ; int n = other . intervals . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Interval I = other . intervals . get ( i ) ; this . add ( I . a , I . b ) ; } } else { for ( int value : set . toList ( ) ) { add ( value ) ; } } return this ; }
public OpenStringBuilder ( char [ ] arr , int len ) { set ( arr , len ) ; }
public boolean isRefLogIncludingResult ( ) { return refLogIncludeResult ; }
public HeaderFooterRecord ( byte [ ] data ) { _rawData = data ; }
public byte [ ] getPath ( ) { return Arrays . copyOf ( path , path . length ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ REFMODE ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . mode ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getMode ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / REFMODE ] \ n " ) ; return buffer . toString ( ) ; }
public HSSFChildAnchor ( ) { _escherChildAnchor = new EscherChildAnchorRecord ( ) ; }
public final boolean isRegistered ( ) { return ! canonicalName . startsWith ( " x - " ) && ! canonicalName . startsWith ( " X - " ) ; }
@ Override public boolean remove ( Object o ) { if ( containsKey ( o ) ) { unfiltered . remove ( o ) ; return true ; } return false ; }
public static Token newToken ( int ofKind , String image ) { switch ( ofKind ) { default : return new Token ( ofKind , image ) ; } }
public float overheadPerValue ( int bitsPerValue ) { assert isSupported ( bitsPerValue ) ; final int valuesPerBlock = 64 / bitsPerValue ; final int overhead = 64 % bitsPerValue ; return ( float ) overhead / valuesPerBlock ; }
public void clear ( ) { backingMap . clear ( ) ; }
public CompoundException ( Collection < Throwable > why ) { super ( format ( why ) ) ; causeList = Collections . unmodifiableList ( new ArrayList <> ( why ) ) ; }
public DeleteEnvironmentConfigurationRequest ( String applicationName , String environmentName ) { setApplicationName ( applicationName ) ; setEnvironmentName ( environmentName ) ; }
public ModifyImageAttributeRequest ( String imageId , String attribute ) { setImageId ( imageId ) ; setAttribute ( attribute ) ; }
public LastCellOfRowDummyRecord ( int row , int lastColumnNumber ) { this . row = row ; this . lastColumnNumber = lastColumnNumber ; }
public String toString ( ) { return path . toString ( ) ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( ADD ) ; buffer . append ( operands [ 0 ] ) ; return buffer . toString ( ) ; }
public void abort ( ) { try { reset ( ) ; } finally { if ( nextTermsHash != null ) { nextTermsHash . abort ( ) ; } } }
public CreateUsagePlanKeyResult createUsagePlanKey ( CreateUsagePlanKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateUsagePlanKey ( request ) ; }
public boolean isOutOfBounds ( int lowValidIx , int highValidIx ) { if ( _offset < lowValidIx ) { return true ; } if ( getLastIndex ( ) > highValidIx ) { return true ; } return false ; }
public CherryPickStatus getStatus ( ) { return status ; }
public static String getRomanization ( String s ) { StringBuilder out = new StringBuilder ( ) ; try { getRomanization ( out , s ) ; } catch ( IOException bogus ) { throw new RuntimeException ( bogus ) ; } return out . toString ( ) ; }
public GetDistributionRequest ( String id ) { setId ( id ) ; }
public String signString ( String stringToSign , String accessKeySecret ) { return null ; }
public Repository open ( C req , String name ) throws RepositoryNotFoundException , ServiceNotEnabledException { if ( isUnreasonableName ( name ) ) throw new RepositoryNotFoundException ( name ) ; Repository db = exports . get ( nameWithDotGit ( name ) ) ; if ( db != null ) { db . incrementOpen ( ) ; return db ; } for ( File base : exportBase ) { File dir = FileKey . resolve ( new File ( base , name ) , FS . DETECTED ) ; if ( dir == null ) continue ; try { FileKey key = FileKey . exact ( dir , FS . DETECTED ) ; db = RepositoryCache . open ( key , true ) ; } catch ( IOException e ) { throw new RepositoryNotFoundException ( name , e ) ; } try { if ( isExportOk ( req , name , db ) ) { return db ; } throw new ServiceNotEnabledException ( ) ; } catch ( RuntimeException | IOException e ) { db . close ( ) ; throw new RepositoryNotFoundException ( name , e ) ; } catch ( ServiceNotEnabledException e ) { db . close ( ) ; throw e ; } } if ( exportBase . size ( ) == 1 ) { File dir = new File ( exportBase . iterator ( ) . next ( ) , name ) ; throw new RepositoryNotFoundException ( name , new RepositoryNotFoundException ( dir ) ) ; } throw new RepositoryNotFoundException ( name ) ; }
public synchronized boolean addIfAbsent ( E object ) { if ( contains ( object ) ) { return false ; } add ( object ) ; return true ; }
public EnableTransitGatewayRouteTablePropagationResult enableTransitGatewayRouteTablePropagation ( EnableTransitGatewayRouteTablePropagationRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableTransitGatewayRouteTablePropagation ( request ) ; }
public PatternKeywordMarkerFilter ( TokenStream in , Pattern pattern ) { super ( in ) ; this . matcher = pattern . matcher ( " " ) ; }
public AddInstanceGroupsRequest ( java . util . List < InstanceGroupConfig > instanceGroups , String jobFlowId ) { setInstanceGroups ( instanceGroups ) ; setJobFlowId ( jobFlowId ) ; }
public FSTTermsReader ( SegmentReadState state , PostingsReaderBase postingsReader ) throws IOException { final String termsFileName = IndexFileNames . segmentFileName ( state . segmentInfo . name , state . segmentSuffix , FSTTermsWriter . TERMS_EXTENSION ) ; this . postingsReader = postingsReader ; final IndexInput in = state . directory . openInput ( termsFileName , state . context ) ; boolean success = false ; try { CodecUtil . checkIndexHeader ( in , FSTTermsWriter . TERMS_CODEC_NAME , FSTTermsWriter . TERMS_VERSION_START , FSTTermsWriter . TERMS_VERSION_CURRENT , state . segmentInfo . getId ( ) , state . segmentSuffix ) ; CodecUtil . checksumEntireFile ( in ) ; this . postingsReader . init ( in , state ) ; seekDir ( in ) ; final FieldInfos fieldInfos = state . fieldInfos ; final int numFields = in . readVInt ( ) ; for ( int i = 0 ; i < numFields ; i ++ ) { int fieldNumber = in . readVInt ( ) ; FieldInfo fieldInfo = fieldInfos . fieldInfo ( fieldNumber ) ; long numTerms = in . readVLong ( ) ; long sumTotalTermFreq = in . readVLong ( ) ; long sumDocFreq = fieldInfo . getIndexOptions ( ) == IndexOptions . DOCS ? sumTotalTermFreq : in . readVLong ( ) ; int docCount = in . readVInt ( ) ; TermsReader current = new TermsReader ( fieldInfo , in , numTerms , sumTotalTermFreq , sumDocFreq , docCount ) ; TermsReader previous = fields . put ( fieldInfo . name , current ) ; checkFieldSummary ( state . segmentInfo , in , current , previous ) ; } success = true ; } finally { if ( success ) { IOUtils . close ( in ) ; } else { IOUtils . closeWhileHandlingException ( in ) ; } } }
public DescribeVpcEndpointsResult describeVpcEndpoints ( DescribeVpcEndpointsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcEndpoints ( request ) ; }
public void setNewPrefix ( String prefix ) { newPrefix = prefix ; }
public GetHostedZoneRequest ( String id ) { setId ( id ) ; }
public List < File > getUpdatedFiles ( ) { return updatedFiles ; }
public DeleteDhcpOptionsRequest ( String dhcpOptionsId ) { setDhcpOptionsId ( dhcpOptionsId ) ; }
public QueryPhraseMap getTermMap ( String term ) { return subMap . get ( term ) ; }
public PutConfigurationSetDeliveryOptionsResult putConfigurationSetDeliveryOptions ( PutConfigurationSetDeliveryOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executePutConfigurationSetDeliveryOptions ( request ) ; }
public ChartRecord ( RecordInputStream in ) { field_1_x = in . readInt ( ) ; field_2_y = in . readInt ( ) ; field_3_width = in . readInt ( ) ; field_4_height = in . readInt ( ) ; }
public ListTaskDefinitionsResult listTaskDefinitions ( ListTaskDefinitionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTaskDefinitions ( request ) ; }
public String getRawPath ( ) { return rawPath ; }
public IndexRecord ( RecordInputStream in ) { int field_1_zero = in . readInt ( ) ; if ( field_1_zero != 0 ) { throw new RecordFormatException ( " Expected ▁ zero ▁ for ▁ field ▁ 1 ▁ but ▁ got ▁ " + field_1_zero ) ; } field_2_first_row = in . readInt ( ) ; field_3_last_row_add1 = in . readInt ( ) ; field_4_zero = in . readInt ( ) ; int nCells = in . remaining ( ) / 4 ; field_5_dbcells = new IntList ( nCells ) ; for ( int i = 0 ; i < nCells ; i ++ ) { field_5_dbcells . add ( in . readInt ( ) ) ; } }
public Class <? extends Enum > enumType ( ) { return enumType ; }
public boolean isSupportedType ( final int variantType ) { for ( int st : SUPPORTED_TYPES ) { if ( variantType == st ) { return true ; } } return false ; }
public PersonIdent getSourceCommitter ( int idx ) { return sourceCommitters [ idx ] ; }
public RemoveTagsRequest ( String resourceId , java . util . List < String > tagKeys ) { setResourceId ( resourceId ) ; setTagKeys ( tagKeys ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ ENDBLOCK ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rt ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( rt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbitFrt ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( grbitFrt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . iObjectKind = " ) . append ( HexDump . shortToHex ( iObjectKind ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . unused ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . toHex ( unused ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / ENDBLOCK ] \ n " ) ; return buffer . toString ( ) ; }
public int stem ( char text [ ] , int length , boolean stemDerivational ) { flags = 0 ; numSyllables = 0 ; for ( int i = 0 ; i < length ; i ++ ) if ( isVowel ( text [ i ] ) ) numSyllables ++ ; if ( numSyllables > 2 ) length = removeParticle ( text , length ) ; if ( numSyllables > 2 ) length = removePossessivePronoun ( text , length ) ; if ( stemDerivational ) length = stemDerivational ( text , length ) ; return length ; }
public final long computeNorm ( FieldInvertState state ) { final int numTerms ; if ( state . getIndexOptions ( ) == IndexOptions . DOCS && state . getIndexCreatedVersionMajor ( ) >= 8 ) { numTerms = state . getUniqueTermCount ( ) ; } else if ( discountOverlaps ) { numTerms = state . getLength ( ) - state . getNumOverlap ( ) ; } else { numTerms = state . getLength ( ) ; } return SmallFloat . intToByte4 ( numTerms ) ; }
public OpenNLPChunkerFilter create ( TokenStream in ) { try { NLPChunkerOp chunkerOp = null ; if ( chunkerModelFile != null ) { chunkerOp = OpenNLPOpsFactory . getChunker ( chunkerModelFile ) ; } return new OpenNLPChunkerFilter ( in , chunkerOp ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( e ) ; } }
public List < PackedObjectInfo > getSortedObjectList ( Comparator < PackedObjectInfo > cmp ) { Arrays . sort ( entries , 0 , entryCount , cmp ) ; List < PackedObjectInfo > list = Arrays . asList ( entries ) ; if ( entryCount < entries . length ) list = list . subList ( 0 , entryCount ) ; return list ; }
public String getSecurityToken ( ) { AlibabaCloudCredentials credentials = getCredentials ( ) ; if ( credentials instanceof BasicSessionCredentials ) { return ( ( BasicSessionCredentials ) credentials ) . getSessionToken ( ) ; } else { return null ; } }
public StopAutoMLJobResult stopAutoMLJob ( StopAutoMLJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopAutoMLJob ( request ) ; }
public int findStartOffset ( StringBuilder buffer , int start ) { if ( start > buffer . length ( ) || start < 1 ) return start ; bi . setText ( buffer . substring ( 0 , start ) ) ; bi . last ( ) ; return bi . previous ( ) ; }
public StartImageBuilderResult startImageBuilder ( StartImageBuilderRequest request ) { request = beforeClientExecution ( request ) ; return executeStartImageBuilder ( request ) ; }
public double readDouble ( ) { long valueLongBits = readLong ( ) ; double result = Double . longBitsToDouble ( valueLongBits ) ; if ( Double . isNaN ( result ) ) { throw new RuntimeException ( " Did ▁ not ▁ expect ▁ to ▁ read ▁ NaN " ) ; } return result ; }
public double readDouble ( ) { return _in . readDouble ( ) ; }
public int compareTo ( Cell other ) { return Double . compare ( distanceSquared , other . distanceSquared ) ; }
public GetCampaignDateRangeKpiResult getCampaignDateRangeKpi ( GetCampaignDateRangeKpiRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCampaignDateRangeKpi ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getName ( ) ) . append ( " ▁ [ CRN " ) ; sb . append ( " ▁ rowIx = " ) . append ( field_3_row_index ) ; sb . append ( " ▁ firstColIx = " ) . append ( field_2_first_column_index ) ; sb . append ( " ▁ lastColIx = " ) . append ( field_1_last_column_index ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public void add ( double value ) { ensureCapacity ( _count + 1 ) ; _array [ _count ] = value ; _count ++ ; }
public String getSheetName ( int sheetIndex ) { return getSheetEvaluator ( sheetIndex ) . getSheetName ( ) ; }
public TransferDomainToAnotherAwsAccountResult transferDomainToAnotherAwsAccount ( TransferDomainToAnotherAwsAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeTransferDomainToAnotherAwsAccount ( request ) ; }
public final boolean weakCompareAndSet ( V expect , V update ) { return unsafe . compareAndSwapObject ( this , valueOffset , expect , update ) ; }
public void setResult ( ReceiveCommand . Result status , String msg ) { result = decode ( status ) ; super . setResult ( status , msg ) ; }
public String toString ( ) { return " skip " ; }
public List < String > getModifiedFiles ( ) { return modifiedFiles ; }
public final void serialize ( LittleEndianOutput out ) { out . writeShort ( getRow ( ) ) ; out . writeShort ( getColumn ( ) ) ; out . writeShort ( getXFIndex ( ) ) ; serializeValue ( out ) ; }
public String toString ( ) { return " NotIgnored ( " + index + " ) " ; }
public DescribeDBClusterParametersResult describeDBClusterParameters ( DescribeDBClusterParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBClusterParameters ( request ) ; }
public CellRangeAddress copy ( ) { return new CellRangeAddress ( getFirstRow ( ) , getLastRow ( ) , getFirstColumn ( ) , getLastColumn ( ) ) ; }
public final boolean hasAny ( RevFlagSet set ) { return ( flags & set . mask ) != 0 ; }
public GetPolicyResult getPolicy ( GetPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetPolicy ( request ) ; }
public BookSheetKey ( int bookIndex , int sheetIndex ) { _bookIndex = bookIndex ; _sheetIndex = sheetIndex ; }
public void setRate ( int rate , boolean perMin ) { this . rate = rate ; this . perMin = perMin ; setSequenceName ( ) ; }
public DescribeVpcEndpointConnectionsResult describeVpcEndpointConnections ( DescribeVpcEndpointConnectionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcEndpointConnections ( request ) ; }
public GetHostedZoneResult getHostedZone ( GetHostedZoneRequest request ) { request = beforeClientExecution ( request ) ; return executeGetHostedZone ( request ) ; }
public ChangeBatch ( java . util . List < Change > changes ) { setChanges ( changes ) ; }
public String [ ] getExternalBookAndSheetName ( int extRefIndex ) { int ebIx = _externSheetRecord . getExtbookIndexFromRefIndex ( extRefIndex ) ; SupBookRecord ebr = _externalBookBlocks [ ebIx ] . getExternalBookRecord ( ) ; if ( ! ebr . isExternalReferences ( ) ) { return null ; } int shIx1 = _externSheetRecord . getFirstSheetIndexFromRefIndex ( extRefIndex ) ; int shIx2 = _externSheetRecord . getLastSheetIndexFromRefIndex ( extRefIndex ) ; String firstSheetName = null ; String lastSheetName = null ; if ( shIx1 >= 0 ) { firstSheetName = ebr . getSheetNames ( ) [ shIx1 ] ; } if ( shIx2 >= 0 ) { lastSheetName = ebr . getSheetNames ( ) [ shIx2 ] ; } if ( shIx1 == shIx2 ) { return new String [ ] { ebr . getURL ( ) , firstSheetName } ; } else { return new String [ ] { ebr . getURL ( ) , firstSheetName , lastSheetName } ; } }
public ChartEndBlockRecord ( RecordInputStream in ) { rt = in . readShort ( ) ; grbitFrt = in . readShort ( ) ; iObjectKind = in . readShort ( ) ; if ( in . available ( ) == 0 ) { unused = new byte [ 0 ] ; } else { unused = new byte [ 6 ] ; in . readFully ( unused ) ; } }
public CreateQueueResult createQueue ( CreateQueueRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateQueue ( request ) ; }
public void setMaxDocCharsToAnalyze ( int maxDocCharsToAnalyze ) { this . maxCharsToAnalyze = maxDocCharsToAnalyze ; }
public CreateCodeRepositoryResult createCodeRepository ( CreateCodeRepositoryRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCodeRepository ( request ) ; }
public static String getLastCommitSegmentsFileName ( String [ ] files ) { return IndexFileNames . fileNameFromGeneration ( IndexFileNames . SEGMENTS , " " , getLastCommitGeneration ( files ) ) ; }
public final CharBuffer put ( char [ ] src ) { return put ( src , 0 , src . length ) ; }
public Certificate modifyCertificates ( ModifyCertificatesRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyCertificates ( request ) ; }
public void updateCell ( String sheetName , int rowIndex , int columnIndex , ValueEval value ) { ForkedEvaluationCell cell = _sewb . getOrCreateUpdatableCell ( sheetName , rowIndex , columnIndex ) ; cell . setValue ( value ) ; _evaluator . notifyUpdateCell ( cell ) ; }
public DisassociateMemberAccountResult disassociateMemberAccount ( DisassociateMemberAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateMemberAccount ( request ) ; }
public boolean run ( byte [ ] s , int offset , int length ) { int p = 0 ; int l = offset + length ; for ( int i = offset ; i < l ; i ++ ) { p = step ( p , s [ i ] & 0xFF ) ; if ( p == - 1 ) return false ; } return accept . get ( p ) ; }
public DeleteTrafficPolicyResult deleteTrafficPolicy ( DeleteTrafficPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTrafficPolicy ( request ) ; }
public static PackIndex read ( InputStream fd ) throws IOException , CorruptObjectException { final byte [ ] hdr = new byte [ 8 ] ; IO . readFully ( fd , hdr , 0 , hdr . length ) ; if ( isTOC ( hdr ) ) { final int v = NB . decodeInt32 ( hdr , 4 ) ; switch ( v ) { case 2 : return new PackIndexV2 ( fd ) ; default : throw new UnsupportedPackIndexVersionException ( v ) ; } } return new PackIndexV1 ( fd , hdr ) ; }
public double [ ] toArray ( ) { if ( _count < 1 ) { return EMPTY_DOUBLE_ARRAY ; } double [ ] result = new double [ _count ] ; System . arraycopy ( _array , 0 , result , 0 , _count ) ; return result ; }
public GetHostReservationPurchasePreviewResult getHostReservationPurchasePreview ( GetHostReservationPurchasePreviewRequest request ) { request = beforeClientExecution ( request ) ; return executeGetHostReservationPurchasePreview ( request ) ; }
public CustomAvailabilityZone createCustomAvailabilityZone ( CreateCustomAvailabilityZoneRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCustomAvailabilityZone ( request ) ; }
public EvaluationTracker ( EvaluationCache cache ) { _cache = cache ; _evaluationFrames = new ArrayList <> ( ) ; _currentlyEvaluatingCells = new HashSet <> ( ) ; }
public String toString ( ) { return format ( false , false ) ; }
public AcceptQualificationRequestResult acceptQualificationRequest ( AcceptQualificationRequestRequest request ) { request = beforeClientExecution ( request ) ; return executeAcceptQualificationRequest ( request ) ; }
public boolean markSupported ( ) { return false ; }
public StringBuffer appendTail ( StringBuffer buffer ) { if ( appendPos < regionEnd ) { buffer . append ( input . substring ( appendPos , regionEnd ) ) ; } return buffer ; }
public String getSignificantDecimalDigits ( ) { return Long . toString ( _wholePart ) ; }
public void setVerticalBorder ( boolean value ) { field_1_options = verticalBorder . setShortBoolean ( field_1_options , value ) ; }
public CRNRecord ( RecordInputStream in ) { field_1_last_column_index = in . readUByte ( ) ; field_2_first_column_index = in . readUByte ( ) ; field_3_row_index = in . readShort ( ) ; int nValues = field_1_last_column_index - field_2_first_column_index + 1 ; field_4_constant_values = ConstantValueParser . parse ( in , nValues ) ; }
public DBSecurityGroup revokeDBSecurityGroupIngress ( RevokeDBSecurityGroupIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeRevokeDBSecurityGroupIngress ( request ) ; }
public CharBlockArray append ( char [ ] chars , int start , int length ) { int offset = start ; int remain = length ; while ( remain > 0 ) { if ( this . current . length == this . blockSize ) { addBlock ( ) ; } int toCopy = remain ; int remainingInBlock = this . blockSize - this . current . length ; if ( remainingInBlock < toCopy ) { toCopy = remainingInBlock ; } System . arraycopy ( chars , offset , this . current . chars , this . current . length , toCopy ) ; offset += toCopy ; remain -= toCopy ; this . current . length += toCopy ; } this . length += length ; return this ; }
public String toString ( ) { return toString ( null , true ) ; }
public int doLogic ( ) throws Exception { try { Locale locale = getRunData ( ) . getLocale ( ) ; if ( locale == null ) throw new RuntimeException ( " Locale ▁ must ▁ be ▁ set ▁ with ▁ the ▁ NewLocale ▁ task ! " ) ; Analyzer analyzer = createAnalyzer ( locale , impl ) ; getRunData ( ) . setAnalyzer ( analyzer ) ; System . out . println ( " Changed ▁ Analyzer ▁ to : ▁ " + analyzer . getClass ( ) . getName ( ) + " ( " + locale + " ) " ) ; } catch ( Exception e ) { throw new RuntimeException ( " Error ▁ creating ▁ Analyzer : ▁ impl = " + impl , e ) ; } return 1 ; }
public final short get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return backingArray [ offset + position ++ ] ; }
public static String toHex ( final short [ ] value ) { StringBuilder retVal = new StringBuilder ( ) ; retVal . append ( ' [ ' ) ; for ( int x = 0 ; x < value . length ; x ++ ) { if ( x > 0 ) { retVal . append ( " , ▁ " ) ; } retVal . append ( toHex ( value [ x ] ) ) ; } retVal . append ( ' ] ' ) ; return retVal . toString ( ) ; }
public ListIPSetsResult listIPSets ( ListIPSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListIPSets ( request ) ; }
public int getLevelForDistance ( double dist ) { if ( dist == 0 ) { return maxLevels ; } int level = S2Projections . MAX_WIDTH . getMinLevel ( dist * DistanceUtils . DEGREES_TO_RADIANS ) ; int roundLevel = level % arity != 0 ? 1 : 0 ; level = level / arity + roundLevel ; return Math . min ( maxLevels , level + 1 ) ; }
public IndexableField [ ] getFields ( String name ) { List < IndexableField > result = new ArrayList <> ( ) ; for ( IndexableField field : fields ) { if ( field . name ( ) . equals ( name ) ) { result . add ( field ) ; } } return result . toArray ( new IndexableField [ result . size ( ) ] ) ; }
public GetTrafficPolicyResult getTrafficPolicy ( GetTrafficPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTrafficPolicy ( request ) ; }
public String name ( ) { ensureId ( ) ; return idBuffer . name ( ) ; }
public DeleteExperimentResult deleteExperiment ( DeleteExperimentRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteExperiment ( request ) ; }
public static byte [ ] grow ( byte [ ] array ) { return grow ( array , 1 + array . length ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getReadOnly ( ) ) ; out . writeShort ( getPassword ( ) ) ; out . writeShort ( field_3_username_value . length ( ) ) ; if ( field_3_username_value . length ( ) > 0 ) { out . writeByte ( field_3_username_unicode_options ) ; StringUtil . putCompressedUnicode ( getUsername ( ) , out ) ; } }
public BulgarianStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public GetMirrorListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetMirrorList " , " cr " ) ; setUriPattern ( " / mirrors " ) ; setMethod ( MethodType . GET ) ; }
public DescribeDomainEndpointOptionsResult describeDomainEndpointOptions ( DescribeDomainEndpointOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDomainEndpointOptions ( request ) ; }
public CommonToken ( Pair < TokenSource , CharStream > source , int type , int channel , int start , int stop ) { this . source = source ; this . type = type ; this . channel = channel ; this . start = start ; this . stop = stop ; if ( source . a != null ) { this . line = source . a . getLine ( ) ; this . charPositionInLine = source . a . getCharPositionInLine ( ) ; } }
public boolean get ( URIish uri , CredentialItem ... items ) throws UnsupportedCredentialItem { for ( CredentialItem i : items ) { if ( i instanceof CredentialItem . Username ) { ( ( CredentialItem . Username ) i ) . setValue ( username ) ; continue ; } if ( i instanceof CredentialItem . Password ) { ( ( CredentialItem . Password ) i ) . setValue ( password ) ; continue ; } if ( i instanceof CredentialItem . StringType ) { if ( i . getPromptText ( ) . equals ( " Password : ▁ " ) ) { ( ( CredentialItem . StringType ) i ) . setValue ( new String ( password ) ) ; continue ; } } throw new UnsupportedCredentialItem ( uri , i . getClass ( ) . getName ( ) + " : " + i . getPromptText ( ) ) ; } return true ; }
public boolean get ( String name , boolean dflt ) { boolean vals [ ] = ( boolean [ ] ) valByRound . get ( name ) ; if ( vals != null ) { return vals [ roundNumber % vals . length ] ; } String sval = props . getProperty ( name , " " + dflt ) ; if ( sval . indexOf ( " : " ) < 0 ) { return Boolean . valueOf ( sval ) . booleanValue ( ) ; } int k = sval . indexOf ( " : " ) ; String colName = sval . substring ( 0 , k ) ; sval = sval . substring ( k + 1 ) ; colForValByRound . put ( name , colName ) ; vals = propToBooleanArray ( sval ) ; valByRound . put ( name , vals ) ; return vals [ roundNumber % vals . length ] ; }
public UpdateDocumentationVersionResult updateDocumentationVersion ( UpdateDocumentationVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDocumentationVersion ( request ) ; }
public DeleteApplicationInputProcessingConfigurationResult deleteApplicationInputProcessingConfiguration ( DeleteApplicationInputProcessingConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApplicationInputProcessingConfiguration ( request ) ; }
public PurchaseScheduledInstancesResult purchaseScheduledInstances ( PurchaseScheduledInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executePurchaseScheduledInstances ( request ) ; }
public String getHost ( ) { return host ; }
public DeleteNetworkProfileResult deleteNetworkProfile ( DeleteNetworkProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNetworkProfile ( request ) ; }
public ListSchemasResult listSchemas ( ListSchemasRequest request ) { request = beforeClientExecution ( request ) ; return executeListSchemas ( request ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeShort ( field_1_first_row ) ; out . writeShort ( field_2_first_col ) ; }
public ByteSliceWriter ( ByteBlockPool pool ) { this . pool = pool ; }
public void replace ( int start , int limit , char [ ] text , int charsStart , int charsLen ) { final int newLength = shiftForReplace ( start , limit , charsLen ) ; System . arraycopy ( text , charsStart , buffer , start , charsLen ) ; token . setLength ( length = newLength ) ; }
public synchronized void getChars ( int start , int end , char [ ] buffer , int idx ) { super . getChars ( start , end , buffer , idx ) ; }
public RestoreAddressToClassicResult restoreAddressToClassic ( RestoreAddressToClassicRequest request ) { request = beforeClientExecution ( request ) ; return executeRestoreAddressToClassic ( request ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { values [ valuesOffset ++ ] = ( ( blocks [ blocksOffset ++ ] & 0xFFL ) << 8 ) | ( blocks [ blocksOffset ++ ] & 0xFFL ) ; } }
public CreateNamespaceRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " CreateNamespace " , " cr " ) ; setUriPattern ( " / namespace " ) ; setMethod ( MethodType . PUT ) ; }
public ShortBuffer compact ( ) { System . arraycopy ( backingArray , position + offset , backingArray , offset , remaining ( ) ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public GetEventsConfigurationResult getEventsConfiguration ( GetEventsConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetEventsConfiguration ( request ) ; }
public String toString ( ) { return " docFreq = " + docFreq + " ▁ totalTermFreq = " + totalTermFreq + " ▁ termBlockOrd = " + termBlockOrd + " ▁ blockFP = " + blockFilePointer ; }
public EstimateTemplateCostResult estimateTemplateCost ( EstimateTemplateCostRequest request ) { request = beforeClientExecution ( request ) ; return executeEstimateTemplateCost ( request ) ; }
public TreeFilter clone ( ) { return new Binary ( a . clone ( ) , b . clone ( ) ) ; }
public ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { switch ( args . length ) { case 1 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] ) ; case 0 : return new NumberEval ( srcColumnIndex + 1 ) ; } return ErrorEval . VALUE_INVALID ; }
public ByteOrder order ( ) { return ByteOrder . nativeOrder ( ) ; }
public void insert ( char [ ] key , int start , char val ) { int len = strlen ( key ) + 1 ; if ( freenode + len > eq . length ) { redimNodeArrays ( eq . length + BLOCK_SIZE ) ; } root = insert ( root , key , start , val ) ; }
public final DFAState getPrecedenceStartState ( int precedence ) { if ( ! isPrecedenceDfa ( ) ) { throw new IllegalStateException ( " Only ▁ precedence ▁ DFAs ▁ may ▁ contain ▁ a ▁ precedence ▁ start ▁ state . " ) ; } if ( precedence < 0 || precedence >= s0. edges . length ) { return null ; } return s0. edges [ precedence ] ; }
public SetActiveReceiptRuleSetResult setActiveReceiptRuleSet ( SetActiveReceiptRuleSetRequest request ) { request = beforeClientExecution ( request ) ; return executeSetActiveReceiptRuleSet ( request ) ; }
public CreateLaunchTemplateResult createLaunchTemplate ( CreateLaunchTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLaunchTemplate ( request ) ; }
public ListTrafficPolicyVersionsResult listTrafficPolicyVersions ( ListTrafficPolicyVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTrafficPolicyVersions ( request ) ; }
public Locale effectiveLocale ( ) { return effectiveLocale ; }
public void encode ( long [ ] values , int valuesOffset , long [ ] blocks , int blocksOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { blocks [ blocksOffset ++ ] = encode ( values , valuesOffset ) ; valuesOffset += valueCount ; } }
public static String revisionVersion ( IndexCommit commit ) { return Long . toString ( commit . getGeneration ( ) , RADIX ) ; }
public ListServicesResult listServices ( ListServicesRequest request ) { request = beforeClientExecution ( request ) ; return executeListServices ( request ) ; }
public BatchModifyClusterSnapshotsResult batchModifyClusterSnapshots ( BatchModifyClusterSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchModifyClusterSnapshots ( request ) ; }
public DeleteBackupResult deleteBackup ( DeleteBackupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteBackup ( request ) ; }
public DescribeDBParameterGroupsResult describeDBParameterGroups ( ) { return describeDBParameterGroups ( new DescribeDBParameterGroupsRequest ( ) ) ; }
public void reset ( boolean zeroFillBuffers , boolean reuseFirst ) { if ( bufferUpto != - 1 ) { if ( zeroFillBuffers ) { for ( int i = 0 ; i < bufferUpto ; i ++ ) { Arrays . fill ( buffers [ i ] , 0 ) ; } Arrays . fill ( buffers [ bufferUpto ] , 0 , intUpto , 0 ) ; } if ( bufferUpto > 0 || ! reuseFirst ) { final int offset = reuseFirst ? 1 : 0 ; allocator . recycleIntBlocks ( buffers , offset , 1 + bufferUpto ) ; Arrays . fill ( buffers , offset , bufferUpto + 1 , null ) ; } if ( reuseFirst ) { bufferUpto = 0 ; intUpto = 0 ; intOffset = 0 ; buffer = buffers [ 0 ] ; } else { bufferUpto = - 1 ; intUpto = INT_BLOCK_SIZE ; intOffset = - INT_BLOCK_SIZE ; buffer = null ; } } }
public SaveRecalcRecord clone ( ) { return copy ( ) ; }
public static void main ( String [ ] args ) { exec ( args ) ; }
public DeregisterImageResult deregisterImage ( DeregisterImageRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterImage ( request ) ; }
public DBSnapshot modifyDBSnapshot ( ModifyDBSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBSnapshot ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ BOUNDSHEET ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . bof ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . intToHex ( getPositionOfBof ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . options ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( field_2_option_flags ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . unicodeflag = ▁ " ) . append ( HexDump . byteToHex ( field_4_isMultibyteUnicode ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . sheetname ▁ ▁ = ▁ " ) . append ( field_5_sheetname ) . append ( " \ n " ) ; buffer . append ( " [ / BOUNDSHEET ] \ n " ) ; return buffer . toString ( ) ; }
public void setParams ( String params ) { this . params = params ; fieldsToLoad = new HashSet <> ( ) ; for ( StringTokenizer tokenizer = new StringTokenizer ( params , " , " ) ; tokenizer . hasMoreTokens ( ) ; ) { String s = tokenizer . nextToken ( ) ; fieldsToLoad . add ( s ) ; } }
public GetNamedQueryResult getNamedQuery ( GetNamedQueryRequest request ) { request = beforeClientExecution ( request ) ; return executeGetNamedQuery ( request ) ; }
public GermanStemFilter create ( TokenStream in ) { return new GermanStemFilter ( in ) ; }
public ExtendedFormatRecord createCellXF ( ) { ExtendedFormatRecord xf = createExtendedFormat ( ) ; records . add ( records . getXfpos ( ) + 1 , xf ) ; records . setXfpos ( records . getXfpos ( ) + 1 ) ; numxfs ++ ; return xf ; }
public Cluster modifyClusterMaintenance ( ModifyClusterMaintenanceRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyClusterMaintenance ( request ) ; }
public DeleteDBSecurityGroupResult deleteDBSecurityGroup ( DeleteDBSecurityGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDBSecurityGroup ( request ) ; }
public static FormulaError forInt ( int type ) throws IllegalArgumentException { FormulaError err = imap . get ( type ) ; if ( err == null ) err = bmap . get ( ( byte ) type ) ; if ( err == null ) throw new IllegalArgumentException ( " Unknown ▁ error ▁ type : ▁ " + type ) ; return err ; }
public void finish ( StringBuffer toAppendTo ) { if ( hStart >= 0 && ! showAmPm ) { for ( int i = 0 ; i < hLen ; i ++ ) { toAppendTo . setCharAt ( hStart + i , ' H ' ) ; } } }
public SendRawEmailResult sendRawEmail ( SendRawEmailRequest request ) { request = beforeClientExecution ( request ) ; return executeSendRawEmail ( request ) ; }
public void clear ( ) { if ( readonly ) throw new IllegalStateException ( " can ' t alter readonly IntervalSet " ) ; intervals . clear ( ) ; }
public int previous ( ) { if ( current == start ) { return DONE ; } else { return first ( ) ; } }
public DeleteDocumentClassifierResult deleteDocumentClassifier ( DeleteDocumentClassifierRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDocumentClassifier ( request ) ; }
public DeleteDeviceAllGroupRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " DeleteDeviceAllGroup " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( " ▁ [ " ) ; sb . append ( " sheetIx = " ) . append ( getExternSheetIndex ( ) ) ; sb . append ( " ▁ ! ▁ " ) ; sb . append ( formatReferenceAsString ( ) ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public CreateBGPPeerResult createBGPPeer ( CreateBGPPeerRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateBGPPeer ( request ) ; }
public String toASCIIString ( ) { StringBuilder result = new StringBuilder ( ) ; ASCII_ONLY . appendEncoded ( result , toString ( ) ) ; return result . toString ( ) ; }
public CharSequence subSequence ( int start , int end ) { int remaining = end - start ; StringBuilder sb = new StringBuilder ( remaining ) ; int blockIdx = blockIndex ( start ) ; int indexInBlock = indexInBlock ( start ) ; while ( remaining > 0 ) { Block b = blocks . get ( blockIdx ++ ) ; int numToAppend = Math . min ( remaining , b . length - indexInBlock ) ; sb . append ( b . chars , indexInBlock , numToAppend ) ; remaining -= numToAppend ; indexInBlock = 0 ; } return sb . toString ( ) ; }
public long get ( int index ) { final int o = index >>> 3 ; final int b = index & 7 ; final int shift = b << 3 ; return ( blocks [ o ] >>> shift ) & 255L ; }
public static Collection < String > getNotSupportedFunctionNames ( ) { Collection < String > lst = new TreeSet <> ( ) ; for ( int i = 0 ; i < functions . length ; i ++ ) { Function func = functions [ i ] ; if ( func != null && ( func instanceof NotImplementedFunction ) ) { FunctionMetadata metaData = FunctionMetadataRegistry . getFunctionByIndex ( i ) ; lst . add ( metaData . getName ( ) ) ; } } lst . remove ( " INDIRECT " ) ; return Collections . unmodifiableCollection ( lst ) ; }
public ItalianLightStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeByte ( getNumberOfOperands ( ) ) ; out . writeShort ( getFunctionIndex ( ) ) ; }
public String getTokenErrorDisplay ( Token t ) { if ( t == null ) return " < no ▁ token > " ; String s = t . getText ( ) ; if ( s == null ) { if ( t . getType ( ) == Token . EOF ) { s = " < EOF > " ; } else { s = " < " + t . getType ( ) + " > " ; } } s = s . replace ( " \ n " , " \\ n " ) ; s = s . replace ( " \ r " , " \\ r " ) ; s = s . replace ( " \ t " , " \\ t " ) ; return " ' " + s + " ' " ; }
public NumericPayloadTokenFilter create ( TokenStream input ) { return new NumericPayloadTokenFilter ( input , payload , typeMatch ) ; }
public void incrementDrawingsSaved ( ) { dgg . setDrawingsSaved ( dgg . getDrawingsSaved ( ) + 1 ) ; }
public UploadSigningCertificateRequest ( String certificateBody ) { setCertificateBody ( certificateBody ) ; }
public DeleteJourneyResult deleteJourney ( DeleteJourneyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteJourney ( request ) ; }
public void reset ( ) { ptr = mark ; }
public DescribeInstanceHealthRequest ( String loadBalancerName ) { setLoadBalancerName ( loadBalancerName ) ; }
public static Automaton toAutomaton ( Term wildcardquery ) { List < Automaton > automata = new ArrayList <> ( ) ; String wildcardText = wildcardquery . text ( ) ; for ( int i = 0 ; i < wildcardText . length ( ) ; ) { final int c = wildcardText . codePointAt ( i ) ; int length = Character . charCount ( c ) ; switch ( c ) { case WILDCARD_STRING : automata . add ( Automata . makeAnyString ( ) ) ; break ; case WILDCARD_CHAR : automata . add ( Automata . makeAnyChar ( ) ) ; break ; case WILDCARD_ESCAPE : if ( i + length < wildcardText . length ( ) ) { final int nextChar = wildcardText . codePointAt ( i + length ) ; length += Character . charCount ( nextChar ) ; automata . add ( Automata . makeChar ( nextChar ) ) ; break ; } default : automata . add ( Automata . makeChar ( c ) ) ; } i += length ; } return Operations . concatenate ( automata ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof ExtendedFormatRecord ) { final ExtendedFormatRecord other = ( ExtendedFormatRecord ) obj ; if ( field_1_font_index != other . field_1_font_index ) return false ; if ( field_2_format_index != other . field_2_format_index ) return false ; if ( field_3_cell_options != other . field_3_cell_options ) return false ; if ( field_4_alignment_options != other . field_4_alignment_options ) return false ; if ( field_5_indention_options != other . field_5_indention_options ) return false ; if ( field_6_border_options != other . field_6_border_options ) return false ; if ( field_7_palette_options != other . field_7_palette_options ) return false ; if ( field_8_adtl_palette_options != other . field_8_adtl_palette_options ) return false ; if ( field_9_fill_palette_options != other . field_9_fill_palette_options ) return false ; return true ; } return false ; }
public short [ ] getTriplet ( ) { return new short [ ] { ( short ) ( _red & 0xff ) , ( short ) ( _green & 0xff ) , ( short ) ( _blue & 0xff ) } ; }
public BlameCommand setFollowFileRenames ( boolean follow ) { followFileRenames = Boolean . valueOf ( follow ) ; return this ; }
public StringMatcher ( String value , CmpOp operator ) { super ( operator ) ; _value = value ; switch ( operator . getCode ( ) ) { case CmpOp . NONE : case CmpOp . EQ : case CmpOp . NE : _pattern = getWildCardPattern ( value ) ; break ; default : _pattern = null ; } }
public DefaultColWidthRecord ( ) { field_1_col_width = DEFAULT_COLUMN_WIDTH ; }
public GetIndustryInfoListRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " GetIndustryInfoList " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public AssociateTrialComponentResult associateTrialComponent ( AssociateTrialComponentRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateTrialComponent ( request ) ; }
public FileIdCluster addCluster ( int dgId , int numShapedUsed ) { return addCluster ( dgId , numShapedUsed , true ) ; }
public GetFieldLevelEncryptionResult getFieldLevelEncryption ( GetFieldLevelEncryptionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFieldLevelEncryption ( request ) ; }
public CharBuffer get ( char [ ] dst , int dstOffset , int charCount ) { Arrays . checkOffsetAndCount ( dst . length , dstOffset , charCount ) ; if ( charCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } for ( int i = dstOffset ; i < dstOffset + charCount ; ++ i ) { dst [ i ] = get ( ) ; } return this ; }
public UpdateServiceResult updateService ( UpdateServiceRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateService ( request ) ; }
public FlushStageCacheResult flushStageCache ( FlushStageCacheRequest request ) { request = beforeClientExecution ( request ) ; return executeFlushStageCache ( request ) ; }
public ModifyInstanceMetadataOptionsResult modifyInstanceMetadataOptions ( ModifyInstanceMetadataOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyInstanceMetadataOptions ( request ) ; }
public DefaultRowHeightRecord ( RecordInputStream in ) { field_1_option_flags = in . readShort ( ) ; field_2_row_height = in . readShort ( ) ; }
public ListModelPackagesResult listModelPackages ( ListModelPackagesRequest request ) { request = beforeClientExecution ( request ) ; return executeListModelPackages ( request ) ; }
public StopFleetActionsResult stopFleetActions ( StopFleetActionsRequest request ) { request = beforeClientExecution ( request ) ; return executeStopFleetActions ( request ) ; }
public boolean matches ( ValueEval x ) { double testValue ; if ( x instanceof StringEval ) { switch ( getCode ( ) ) { case CmpOp . EQ : case CmpOp . NONE : break ; case CmpOp . NE : return true ; default : return false ; } StringEval se = ( StringEval ) x ; Double val = OperandResolver . parseDouble ( se . getStringValue ( ) ) ; if ( val == null ) { return false ; } return _value == val . doubleValue ( ) ; } else if ( ( x instanceof NumberEval ) ) { NumberEval ne = ( NumberEval ) x ; testValue = ne . getNumberValue ( ) ; } else if ( ( x instanceof BlankEval ) ) { switch ( getCode ( ) ) { case CmpOp . NE : return true ; default : return false ; } } else { return false ; } return evaluate ( Double . compare ( testValue , _value ) ) ; }
public boolean include ( RevWalk walker , RevCommit c ) { throw new UnsupportedOperationException ( JGitText . get ( ) . cannotBeCombined ) ; }
public LongList ( int capacity ) { entries = new long [ capacity ] ; }
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( 80 ) ; while ( true ) { int c = in . read ( ) ; if ( c == - 1 ) { throw new EOFException ( ) ; } else if ( c == ' \ n ' ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > 0 && result . charAt ( length - 1 ) == ' \ r ' ) { result . setLength ( length - 1 ) ; } return result . toString ( ) ; }
public DeleteRouteRequestParameterResult deleteRouteRequestParameter ( DeleteRouteRequestParameterRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRouteRequestParameter ( request ) ; }
public int getRowCountForBlock ( int block ) { int startIndex = block * DBCellRecord . BLOCK_SIZE ; int endIndex = startIndex + DBCellRecord . BLOCK_SIZE - 1 ; if ( endIndex >= _rowRecords . size ( ) ) endIndex = _rowRecords . size ( ) - 1 ; return endIndex - startIndex + 1 ; }
public boolean add ( CharSequence text ) { return map . put ( text , PLACEHOLDER ) == null ; }
public FSTCompletion ( FST < Object > automaton , boolean higherWeightsFirst , boolean exactFirst ) { this . automaton = automaton ; if ( automaton != null ) { this . rootArcs = cacheRootArcs ( automaton ) ; } else { this . rootArcs = new Arc [ 0 ] ; } this . higherWeightsFirst = higherWeightsFirst ; this . exactFirst = exactFirst ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats [ ] ) { double idf = 0d ; List < Explanation > details = new ArrayList <> ( ) ; for ( final TermStatistics stat : termStats ) { Explanation idfExplain = idfExplain ( collectionStats , stat ) ; details . add ( idfExplain ) ; idf += idfExplain . getValue ( ) . floatValue ( ) ; } return Explanation . match ( ( float ) idf , " idf , ▁ sum ▁ of : " , details ) ; }
public CreateEndpointResult createEndpoint ( CreateEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateEndpoint ( request ) ; }
public int serialize ( int offset , byte [ ] data ) { LittleEndian . putShort ( data , 0 + offset , getSid ( ) ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; byte [ ] rawData = getRawData ( ) ; if ( escherRecords . size ( ) == 0 && rawData != null ) { LittleEndian . putShort ( data , 0 + offset , getSid ( ) ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; System . arraycopy ( rawData , 0 , data , 4 + offset , rawData . length ) ; return rawData . length + 4 ; } LittleEndian . putShort ( data , 0 + offset , getSid ( ) ) ; LittleEndian . putShort ( data , 2 + offset , ( short ) ( getRecordSize ( ) - 4 ) ) ; int pos = offset + 4 ; for ( EscherRecord r : escherRecords ) { pos += r . serialize ( pos , data , new NullEscherSerializationListener ( ) ) ; } return getRecordSize ( ) ; }
public boolean isBelowMaxRep ( ) { int sc = _significand . bitLength ( ) - C_64 ; return _significand . compareTo ( BI_MAX_BASE . shiftLeft ( sc ) ) < 0 ; }
public FieldIndexEnum getFieldEnum ( FieldInfo fieldInfo ) { final FieldIndexData fieldData = fields . get ( fieldInfo . name ) ; if ( fieldData . fst == null ) { return null ; } else { return new IndexEnum ( fieldData . fst ) ; } }
public AssociationsFacetsExample ( ) { config = new FacetsConfig ( ) ; config . setMultiValued ( " tags " , true ) ; config . setIndexFieldName ( " tags " , " $ tags " ) ; config . setMultiValued ( " genre " , true ) ; config . setIndexFieldName ( " genre " , " $ genre " ) ; }
public void fill ( int fromIndex , int toIndex , long val ) { ensureCapacity ( val ) ; current . fill ( fromIndex , toIndex , val ) ; }
public ListDeploymentConfigsResult listDeploymentConfigs ( ListDeploymentConfigsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDeploymentConfigs ( request ) ; }
public ListUserPoliciesRequest ( String userName ) { setUserName ( userName ) ; }
public TokenStream create ( TokenStream input ) { return new FinnishLightStemFilter ( input ) ; }
public CharSequence getLastOnPath ( CharSequence key ) { StringBuilder result = new StringBuilder ( tries . size ( ) * 2 ) ; for ( int i = 0 ; i < tries . size ( ) ; i ++ ) { CharSequence r = tries . get ( i ) . getLastOnPath ( key ) ; if ( r == null || ( r . length ( ) == 1 && r . charAt ( 0 ) == EOM ) ) { return result ; } result . append ( r ) ; } return result ; }
public int getExternalSheetIndex ( String workbookName , String firstSheetName , String lastSheetName ) { int externalBookIndex = getExternalWorkbookIndex ( workbookName ) ; if ( externalBookIndex == - 1 ) { throw new RuntimeException ( " No ▁ external ▁ workbook ▁ with ▁ name ▁ ' " ▁ + ▁ workbookName ▁ + ▁ " ' " ) ; } SupBookRecord ebrTarget = _externalBookBlocks [ externalBookIndex ] . getExternalBookRecord ( ) ; int firstSheetIndex = getSheetIndex ( ebrTarget . getSheetNames ( ) , firstSheetName ) ; int lastSheetIndex = getSheetIndex ( ebrTarget . getSheetNames ( ) , lastSheetName ) ; int result = _externSheetRecord . getRefIxForSheet ( externalBookIndex , firstSheetIndex , lastSheetIndex ) ; if ( result < 0 ) { result = _externSheetRecord . addRef ( externalBookIndex , firstSheetIndex , lastSheetIndex ) ; } return result ; }
public String findSheetLastNameFromExternSheet ( int externSheetIndex ) { int indexToSheet = linkTable . getLastInternalSheetIndexForExtIndex ( externSheetIndex ) ; return findSheetNameFromIndex ( indexToSheet ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( rt ) ; out . writeShort ( grbitFrt ) ; out . writeShort ( iObjectKind ) ; out . write ( reserved ) ; }
public final ValueEval getValue ( ) { return _value ; }
public ImportImageResult importImage ( ImportImageRequest request ) { request = beforeClientExecution ( request ) ; return executeImportImage ( request ) ; }
public PruneByAge ( double maxAgeSec ) { if ( maxAgeSec < 0 ) { throw new IllegalArgumentException ( " maxAgeSec ▁ must ▁ be ▁ > ▁ 0 ▁ ( got ▁ " + maxAgeSec + " ) " ) ; } this . maxAgeSec = maxAgeSec ; }
public DeleteSecurityGroupRequest ( String groupName ) { setGroupName ( groupName ) ; }
public GetRoomSkillParameterResult getRoomSkillParameter ( GetRoomSkillParameterRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRoomSkillParameter ( request ) ; }
public ParserRuleContext parse ( int startRuleIndex ) { RuleStartState startRuleStartState = atn . ruleToStartState [ startRuleIndex ] ; rootContext = createInterpreterRuleContext ( null , ATNState . INVALID_STATE_NUMBER , startRuleIndex ) ; if ( startRuleStartState . isLeftRecursiveRule ) { enterRecursionRule ( rootContext , startRuleStartState . stateNumber , startRuleIndex , 0 ) ; } else { enterRule ( rootContext , startRuleStartState . stateNumber , startRuleIndex ) ; } while ( true ) { ATNState p = getATNState ( ) ; switch ( p . getStateType ( ) ) { case ATNState . RULE_STOP : if ( _ctx . isEmpty ( ) ) { if ( startRuleStartState . isLeftRecursiveRule ) { ParserRuleContext result = _ctx ; Pair < ParserRuleContext , Integer > parentContext = _parentContextStack . pop ( ) ; unrollRecursionContexts ( parentContext . a ) ; return result ; } else { exitRule ( ) ; return rootContext ; } } visitRuleStopState ( p ) ; break ; default : try { visitState ( p ) ; } catch ( RecognitionException e ) { setState ( atn . ruleToStopState [ p . ruleIndex ] . stateNumber ) ; getContext ( ) . exception = e ; getErrorHandler ( ) . reportError ( this , e ) ; recover ( e ) ; } break ; } } }
public DeleteInstallationMediaResult deleteInstallationMedia ( DeleteInstallationMediaRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteInstallationMedia ( request ) ; }
public boolean accept ( double value ) { return value >= min && value <= max ; }
public GetVariablesResult getVariables ( GetVariablesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVariables ( request ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final int byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final int byte1 = blocks [ blocksOffset ++ ] & 0xFF ; final int byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 16 ) | ( byte1 << 8 ) | byte2 ; } }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_pointNumber ) ; out . writeShort ( field_2_seriesIndex ) ; out . writeShort ( field_3_seriesNumber ) ; out . writeShort ( field_4_formatFlags ) ; }
public Area3DPxg ( int externalWorkbookNumber , SheetIdentifier sheetName , String arearef ) { this ( externalWorkbookNumber , sheetName , new AreaReference ( arearef , SpreadsheetVersion . EXCEL2007 ) ) ; }
public final CharSequence subSequence ( int start , int end ) { checkStartEndRemaining ( start , end ) ; CharBuffer result = duplicate ( ) ; result . limit ( position + end ) ; result . position ( position + start ) ; return result ; }
public DescribeInstallationMediaResult describeInstallationMedia ( DescribeInstallationMediaRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInstallationMedia ( request ) ; }
public UpdateConferenceProviderResult updateConferenceProvider ( UpdateConferenceProviderRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateConferenceProvider ( request ) ; }
public void release ( int marker ) { int expectedMark = - numMarkers ; if ( marker != expectedMark ) { throw new IllegalStateException ( " release ( ) ▁ called ▁ with ▁ an ▁ invalid ▁ marker . " ) ; } numMarkers -- ; if ( numMarkers == 0 && p > 0 ) { System . arraycopy ( data , p , data , 0 , n - p ) ; n = n - p ; p = 0 ; lastCharBufferStart = lastChar ; } }
public static int getDataSize ( ) { return 12 ; }
public TokenStream create ( TokenStream input ) { return new UpperCaseFilter ( input ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getHideObj ( ) ) ; }
public V setValue ( V value ) { V oldValue = this . value ; this . value = value ; return oldValue ; }
public String toString ( ) { return toString ( 0 ) ; }
public CreateHITResult createHIT ( CreateHITRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateHIT ( request ) ; }
public void setDelimiters ( String start , String stop , String escapeLeft ) { if ( start == null || start . isEmpty ( ) ) { throw new IllegalArgumentException ( " start ▁ cannot ▁ be ▁ null ▁ or ▁ empty " ) ; } if ( stop == null || stop . isEmpty ( ) ) { throw new IllegalArgumentException ( " stop ▁ cannot ▁ be ▁ null ▁ or ▁ empty " ) ; } this . start = start ; this . stop = stop ; this . escape = escapeLeft ; }
public final int serialize ( int offset , byte [ ] data ) { int dataSize = getDataSize ( ) ; int recSize = 4 + dataSize ; try ( LittleEndianByteArrayOutputStream out = new LittleEndianByteArrayOutputStream ( data , offset , recSize ) ) { out . writeShort ( getSid ( ) ) ; out . writeShort ( dataSize ) ; serialize ( out ) ; if ( out . getWriteIndex ( ) - offset != recSize ) { throw new IllegalStateException ( " Error ▁ in ▁ serialization ▁ of ▁ ( " + getClass ( ) . getName ( ) + " ) : ▁ " + " Incorrect ▁ number ▁ of ▁ bytes ▁ written ▁ - ▁ expected ▁ " + recSize + " ▁ but ▁ got ▁ " + ( out . getWriteIndex ( ) - offset ) ) ; } } catch ( IOException ioe ) { throw new IllegalStateException ( ioe ) ; } return recSize ; }
public DoubleBuffer duplicate ( ) { return copy ( this , mark ) ; }
public ByteBuffer putInt ( int value ) { int newPosition = position + SizeOf . INT ; if ( newPosition > limit ) { throw new BufferOverflowException ( ) ; } Memory . pokeInt ( backingArray , offset + position , value , order ) ; position = newPosition ; return this ; }
public final boolean has ( RevFlag flag ) { return ( flags & flag . mask ) != 0 ; }
public ListGeoLocationsResult listGeoLocations ( ListGeoLocationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListGeoLocations ( request ) ; }
public DescribeClusterSnapshotsResult describeClusterSnapshots ( DescribeClusterSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClusterSnapshots ( request ) ; }
public DeleteDirectConnectGatewayAssociationProposalResult deleteDirectConnectGatewayAssociationProposal ( DeleteDirectConnectGatewayAssociationProposalRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDirectConnectGatewayAssociationProposal ( request ) ; }
public V get ( ) throws InterruptedException , ExecutionException { return sync . innerGet ( ) ; }
public static final int prevLF ( byte [ ] b , int ptr ) { return prev ( b , ptr , ' \ n ' ) ; }
public GetVoiceConnectorTerminationResult getVoiceConnectorTermination ( GetVoiceConnectorTerminationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVoiceConnectorTermination ( request ) ; }
public int getLevelForDistance ( double dist ) { if ( dist == 0 ) return maxLevels ; final int level = GeohashUtils . lookupHashLenForWidthHeight ( dist , dist ) ; return Math . max ( Math . min ( level , maxLevels ) , 1 ) ; }
public DescribeHsmConfigurationsResult describeHsmConfigurations ( ) { return describeHsmConfigurations ( new DescribeHsmConfigurationsRequest ( ) ) ; }
public DeleteInternetGatewayResult deleteInternetGateway ( DeleteInternetGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteInternetGateway ( request ) ; }
public synchronized StringBuffer append ( char ch ) { append0 ( ch ) ; return this ; }
public boolean equals ( Object o ) { return o instanceof SwedishStemmer ; }
public int getNameOffset ( ) { return pathOffset ; }
public SingleTermsEnum ( TermsEnum tenum , BytesRef termText ) { super ( tenum ) ; singleRef = termText ; setInitialSeekTerm ( termText ) ; }
public ListAllowedNodeTypeModificationsResult listAllowedNodeTypeModifications ( ListAllowedNodeTypeModificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAllowedNodeTypeModifications ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval numberVE , ValueEval formVE ) { int number = 0 ; try { ValueEval ve = OperandResolver . getSingleValue ( numberVE , srcRowIndex , srcColumnIndex ) ; number = OperandResolver . coerceValueToInt ( ve ) ; } catch ( EvaluationException e ) { return ErrorEval . VALUE_INVALID ; } if ( number < 0 ) { return ErrorEval . VALUE_INVALID ; } if ( number > 3999 ) { return ErrorEval . VALUE_INVALID ; } if ( number == 0 ) { return new StringEval ( " " ) ; } int form = 0 ; try { ValueEval ve = OperandResolver . getSingleValue ( formVE , srcRowIndex , srcColumnIndex ) ; form = OperandResolver . coerceValueToInt ( ve ) ; } catch ( EvaluationException e ) { return ErrorEval . NUM_ERROR ; } if ( form > 4 || form < 0 ) { return ErrorEval . VALUE_INVALID ; } String result = this . integerToRoman ( number ) ; if ( form == 0 ) { return new StringEval ( result ) ; } return new StringEval ( makeConcise ( result , form ) ) ; }
public void registerDomain ( RegisterDomainRequest request ) { request = beforeClientExecution ( request ) ; executeRegisterDomain ( request ) ; }
public V get ( Object o ) { if ( o == null ) throw new NullPointerException ( ) ; return null ; }
public String toStringEscaped ( ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i >= this . length ( ) ; i ++ ) { if ( this . chars [ i ] == ' \\ ' ) ▁ { result . append ( ' \\ ' ) ; } else if ( this . wasEscaped [ i ] ) result . append ( ' \\ ' ) ; result . append ( this . chars [ i ] ) ; } return ▁ result . toString ( ) ; }
public TrustedSigners ( java . util . List < String > items ) { setItems ( items ) ; }
public ModifyVpnTunnelCertificateResult modifyVpnTunnelCertificate ( ModifyVpnTunnelCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVpnTunnelCertificate ( request ) ; }
public AuthorizeClientVpnIngressResult authorizeClientVpnIngress ( AuthorizeClientVpnIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeAuthorizeClientVpnIngress ( request ) ; }
public void deprecateWorkflowType ( DeprecateWorkflowTypeRequest request ) { request = beforeClientExecution ( request ) ; executeDeprecateWorkflowType ( request ) ; }
public String toString ( ) { return pattern ; }
public ICUNormalizer2FilterFactory ( Map < String , String > args ) { super ( args ) ; String form = get ( args , " form " , " nfkc □ cf " ) ; String mode = get ( args , " mode " , Arrays . asList ( " compose " , " decompose " ) , " compose " ) ; Normalizer2 normalizer = Normalizer2. getInstance ( null , form , " compose " . equals ( mode ) ? Normalizer2. Mode . COMPOSE : Normalizer2. Mode . DECOMPOSE ) ; String filter = get ( args , " filter " ) ; if ( filter != null ) { UnicodeSet set = new UnicodeSet ( filter ) ; if ( ! set . isEmpty ( ) ) { set . freeze ( ) ; normalizer = new FilteredNormalizer2 ( normalizer , set ) ; } } if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } this . normalizer = normalizer ; }
public LongBuffer compact ( ) { throw new ReadOnlyBufferException ( ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { if ( getChild ( ) == null ) return " " ; return getChild ( ) . toQueryString ( escapeSyntaxParser ) + " ~ " + getValueString ( ) ; }
public GetResolverRuleAssociationResult getResolverRuleAssociation ( GetResolverRuleAssociationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetResolverRuleAssociation ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { return arg0 ; }
public Set < String > getRemoved ( ) { return Collections . unmodifiableSet ( diff . getRemoved ( ) ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( getXPosition ( ) ) ; out . writeInt ( getYPosition ( ) ) ; out . writeInt ( getWidth ( ) ) ; out . writeInt ( getHeight ( ) ) ; out . writeShort ( field5_grbit ) ; out . writeShort ( field6_unknown ) ; }
public TokenStream create ( TokenStream input ) { return new BulgarianStemFilter ( input ) ; }
public GetClientCertificateResult getClientCertificate ( GetClientCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeGetClientCertificate ( request ) ; }
public boolean equals ( Object o ) { return o instanceof PorterStemmer ; }
@ Override public void clear ( ) { filteredEntrySet . clear ( ) ; }
public long readLong ( ) throws IOException { return primitiveTypes . readLong ( ) ; }
public byte [ ] toByteArray ( ) throws IOException { if ( onDiskFile == null ) { return super . toByteArray ( ) ; } final long len = length ( ) ; if ( Integer . MAX_VALUE < len ) throw new OutOfMemoryError ( JGitText . get ( ) . lengthExceedsMaximumArraySize ) ; final byte [ ] out = new byte [ ( int ) len ] ; try ( FileInputStream in = new FileInputStream ( onDiskFile ) ) { IO . readFully ( in , out , 0 , ( int ) len ) ; } return out ; }
public void reset ( byte [ ] bytes ) { reset ( bytes , 0 , bytes . length ) ; }
public CheckDNSAvailabilityRequest ( String cNAMEPrefix ) { setCNAMEPrefix ( cNAMEPrefix ) ; }
public DescribeVpcAttributeResult describeVpcAttribute ( DescribeVpcAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcAttribute ( request ) ; }
public AddResourcePermissionsResult addResourcePermissions ( AddResourcePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeAddResourcePermissions ( request ) ; }
public DisassociateTrialComponentResult disassociateTrialComponent ( DisassociateTrialComponentRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateTrialComponent ( request ) ; }
public boolean hasNext ( ) { return nextExternal != null ; }
public void removeCategory ( ) { remove1stProperty ( PropertyIDMap . PID_CATEGORY ) ; }
public PutConfigurationSetSendingOptionsResult putConfigurationSetSendingOptions ( PutConfigurationSetSendingOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executePutConfigurationSetSendingOptions ( request ) ; }
public DisableEbsEncryptionByDefaultResult disableEbsEncryptionByDefault ( DisableEbsEncryptionByDefaultRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableEbsEncryptionByDefault ( request ) ; }
public Iterator < E > iterator ( ) { return listIterator ( 0 ) ; }
public void deprecateDomain ( DeprecateDomainRequest request ) { request = beforeClientExecution ( request ) ; executeDeprecateDomain ( request ) ; }
public GetSegmentExportJobsResult getSegmentExportJobs ( GetSegmentExportJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSegmentExportJobs ( request ) ; }
public boolean contains ( Object value ) { return containsValue ( value ) ; }
public int getEndOffset ( ) { return endOffset ; }
public void enterRecursionRule ( ParserRuleContext localctx , int ruleIndex ) { enterRecursionRule ( localctx , getATN ( ) . ruleToStartState [ ruleIndex ] . stateNumber , ruleIndex , 0 ) ; }
public File getEntryFile ( ) { return ( ( FileEntry ) current ( ) ) . getFile ( ) ; }
public RevFilter clone ( ) { return this ; }
public void setEnabled ( boolean on ) { enabled = on ; }
public UpdatePushTemplateResult updatePushTemplate ( UpdatePushTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdatePushTemplate ( request ) ; }
public String toString ( ) { return " SimpleFSLock ( path = " + path + " , creationTime = " + creationTime + " ) " ; }
public PrintWriter append ( char c ) { write ( c ) ; return this ; }
public GetStageResult getStage ( GetStageRequest request ) { request = beforeClientExecution ( request ) ; return executeGetStage ( request ) ; }
public ValueEval evaluate ( ValueEval [ ] args , int srcCellRow , int srcCellCol ) { int nArgs = args . length ; if ( nArgs < 1 ) { return ErrorEval . VALUE_INVALID ; } if ( nArgs > 30 ) { return ErrorEval . VALUE_INVALID ; } int temp = 0 ; for ( int i = 0 ; i < nArgs ; i ++ ) { temp += CountUtils . countArg ( args [ i ] , _predicate ) ; } return new NumberEval ( temp ) ; }
public ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { switch ( args . length ) { case 1 : return fixed ( args [ 0 ] , new NumberEval ( 2 ) , BoolEval . FALSE , srcRowIndex , srcColumnIndex ) ; case 2 : return fixed ( args [ 0 ] , args [ 1 ] , BoolEval . FALSE , srcRowIndex , srcColumnIndex ) ; case 3 : return fixed ( args [ 0 ] , args [ 1 ] , args [ 2 ] , srcRowIndex , srcColumnIndex ) ; } return ErrorEval . VALUE_INVALID ; }
public void clear ( ) { n = 0 ; }
public Iterator < ThreadState > allActiveThreadStates ( ) { return getPerThreadsIterator ( perThreadPool . getActiveThreadStateCount ( ) ) ; }
public EnglishMinimalStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public NameRecord getNameRecord ( int index ) { return linkTable . getNameRecord ( index ) ; }
public String printQueries ( ) { String newline = System . getProperty ( " line . separator " ) ; StringBuilder sb = new StringBuilder ( ) ; if ( queries != null ) { for ( int i = 0 ; i < queries . length ; i ++ ) { sb . append ( i ) . append ( " . ▁ " ) . append ( queries [ i ] . getClass ( ) . getSimpleName ( ) ) . append ( " ▁ - ▁ " ) . append ( queries [ i ] . toString ( ) ) ; sb . append ( newline ) ; } } return sb . toString ( ) ; }
public SkipWaitTimeForInstanceTerminationResult skipWaitTimeForInstanceTermination ( SkipWaitTimeForInstanceTerminationRequest request ) { request = beforeClientExecution ( request ) ; return executeSkipWaitTimeForInstanceTermination ( request ) ; }
public void drawRoundRect ( int x , int y , int width , int height , int arcWidth , int arcHeight ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , " drawRoundRect ▁ not ▁ supported " ) ; }
public EdgeNGramFilterFactory ( Map < String , String > args ) { super ( args ) ; minGramSize = requireInt ( args , " minGramSize " ) ; maxGramSize = requireInt ( args , " maxGramSize " ) ; preserveOriginal = getBoolean ( args , " preserveOriginal " , EdgeNGramTokenFilter . DEFAULT_PRESERVE_ORIGINAL ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public GetApplicationRevisionResult getApplicationRevision ( GetApplicationRevisionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApplicationRevision ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 ) { return fixed ( arg0 , arg1 , arg2 , srcRowIndex , srcColumnIndex ) ; }
public static final byte [ ] apply ( byte [ ] base , byte [ ] delta ) { return apply ( base , delta , null ) ; }
public static TreeFilter create ( Collection < PathFilter > paths ) { if ( paths . isEmpty ( ) ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastOnePathIsRequired ) ; final PathFilter [ ] p = new PathFilter [ paths . size ( ) ] ; paths . toArray ( p ) ; return create ( p ) ; }
@ Override public Iterator < E > iterator ( ) { return new ArrayListIterator ( ) ; }
public boolean isClean ( ) { return clean ; }
public static boolean startsWith ( BytesRef ref , BytesRef prefix ) { if ( ref . length < prefix . length ) { return false ; } return Arrays . equals ( ref . bytes , ref . offset , ref . offset + prefix . length , prefix . bytes , prefix . offset , prefix . offset + prefix . length ) ; }
public UpdateStackInstancesResult updateStackInstances ( UpdateStackInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateStackInstances ( request ) ; }
public ValueEval getItem ( int index ) { if ( index >= _size ) { throw new ArrayIndexOutOfBoundsException ( " Specified ▁ index ▁ ( " + index + " ) ▁ is ▁ outside ▁ the ▁ allowed ▁ range ▁ ( 0.. " + ( _size - 1 ) + " ) " ) ; } int sheetIndex = _re . getFirstSheetIndex ( ) + index ; return _re . getInnerValueEval ( sheetIndex ) ; }
public GetApiMappingsResult getApiMappings ( GetApiMappingsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApiMappings ( request ) ; }
public ServerCertificateMetadata ( String path , String serverCertificateName , String serverCertificateId , String arn ) { setPath ( path ) ; setServerCertificateName ( serverCertificateName ) ; setServerCertificateId ( serverCertificateId ) ; setArn ( arn ) ; }
public ListLedgersResult listLedgers ( ListLedgersRequest request ) { request = beforeClientExecution ( request ) ; return executeListLedgers ( request ) ; }
public UnknownFormatConversionException ( String s ) { if ( s == null ) { throw new NullPointerException ( ) ; } this . s = s ; }
public BytesRef next ( ) throws IOException { if ( done ) { return null ; } if ( isFirstLine ) { isFirstLine = false ; return spare . get ( ) ; } line = in . readLine ( ) ; if ( line != null ) { String [ ] fields = line . split ( fieldDelimiter ) ; if ( fields . length > 3 ) { throw new IllegalArgumentException ( " More ▁ than ▁ 3 ▁ fields ▁ in ▁ one ▁ line " ) ; } else if ( fields . length == 3 ) { spare . copyChars ( fields [ 0 ] ) ; readWeight ( fields [ 1 ] ) ; if ( hasPayloads ) { curPayload . copyChars ( fields [ 2 ] ) ; } } else if ( fields . length == 2 ) { spare . copyChars ( fields [ 0 ] ) ; readWeight ( fields [ 1 ] ) ; if ( hasPayloads ) { curPayload = new BytesRefBuilder ( ) ; } } else { spare . copyChars ( fields [ 0 ] ) ; curWeight = 1 ; if ( hasPayloads ) { curPayload = new BytesRefBuilder ( ) ; } } return spare . get ( ) ; } else { done = true ; IOUtils . close ( in ) ; return null ; } }
public String getRemote ( ) { return remote ; }
public DefaultUDFFinder ( String [ ] functionNames , FreeRefFunction [ ] functionImpls ) { int nFuncs = functionNames . length ; if ( functionImpls . length != nFuncs ) { throw new IllegalArgumentException ( " Mismatch ▁ in ▁ number ▁ of ▁ function ▁ names ▁ and ▁ implementations " ) ; } HashMap < String , FreeRefFunction > m = new HashMap <> ( nFuncs * 3 / 2 ) ; for ( int i = 0 ; i < functionImpls . length ; i ++ ) { m . put ( functionNames [ i ] . toUpperCase ( Locale . ROOT ) , functionImpls [ i ] ) ; } _functionsByName = m ; }
public void drawOval ( int x , int y , int width , int height ) { HSSFSimpleShape shape = escherGroup . createShape ( new HSSFChildAnchor ( x , y , x + width , y + height ) ) ; shape . setShapeType ( HSSFSimpleShape . OBJECT_TYPE_OVAL ) ; shape . setLineWidth ( 0 ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setNoFill ( true ) ; }
public static FontUnderline valueOf ( int value ) { return _table [ value ] ; }
public PutAttributesRequest ( String domainName , String itemName , java . util . List < ReplaceableAttribute > attributes ) { setDomainName ( domainName ) ; setItemName ( itemName ) ; setAttributes ( attributes ) ; }
public ListExportsResult listExports ( ListExportsRequest request ) { request = beforeClientExecution ( request ) ; return executeListExports ( request ) ; }
public OpenStringBuilder ( int size ) { buf = new char [ size ] ; }
public StopTextTranslationJobResult stopTextTranslationJob ( StopTextTranslationJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopTextTranslationJob ( request ) ; }
public void execute ( Lexer lexer ) { lexer . action ( null , ruleIndex , actionIndex ) ; }
public TestInvokeAuthorizerResult testInvokeAuthorizer ( TestInvokeAuthorizerRequest request ) { request = beforeClientExecution ( request ) ; return executeTestInvokeAuthorizer ( request ) ; }
public int stem ( char s [ ] , int len ) { len = removeCase ( s , len ) ; return normalize ( s , len ) ; }
public DescribeTableReplicaAutoScalingResult describeTableReplicaAutoScaling ( DescribeTableReplicaAutoScalingRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTableReplicaAutoScaling ( request ) ; }
public int readUShort ( ) { return readShort ( ) & 0xFFFF ; }
public int groupCount ( ) { return groupCountImpl ( address ) ; }
public GetConsoleOutputRequest ( String instanceId ) { setInstanceId ( instanceId ) ; }
public DeleteHITResult deleteHIT ( DeleteHITRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteHIT ( request ) ; }
public static DVConstraint createFormulaListConstraint ( String listFormula ) { return new DVConstraint ( listFormula , null ) ; }
public UnbufferedCharStream ( Reader input , int bufferSize ) { this ( bufferSize ) ; this . input = input ; fill ( 1 ) ; }
public String toString ( ) { return " LimitTokenCountAnalyzer ( " + delegate . toString ( ) + " , ▁ maxTokenCount = " + maxTokenCount + " , ▁ consumeAllTokens = " + consumeAllTokens + " ) " ; }
@ Override public boolean contains ( Object object ) { return c . contains ( object ) ; }
public NotImplementedFunction ( String name ) { _functionName = name ; }
public CreateRecommenderConfigurationResult createRecommenderConfiguration ( CreateRecommenderConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRecommenderConfiguration ( request ) ; }
public GetNamespaceListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetNamespaceList " , " cr " ) ; setUriPattern ( " / namespace " ) ; setMethod ( MethodType . GET ) ; }
public CreateDefaultVpcResult createDefaultVpc ( CreateDefaultVpcRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDefaultVpc ( request ) ; }
public CreateTemplateResult createTemplate ( CreateTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTemplate ( request ) ; }
public Collection < ReflogEntry > call ( ) throws GitAPIException , InvalidRefNameException { checkCallable ( ) ; try { ReflogReader reader = repo . getReflogReader ( ref ) ; if ( reader == null ) throw new RefNotFoundException ( MessageFormat . format ( JGitText . get ( ) . refNotResolved , ref ) ) ; return reader . getReverseEntries ( ) ; } catch ( IOException e ) { throw new InvalidRefNameException ( MessageFormat . format ( JGitText . get ( ) . cannotRead , ref ) , e ) ; } }
public CreateVpcRequest ( String cidrBlock ) { setCidrBlock ( cidrBlock ) ; }
public FormulaUsedBlankCellSet ( ) { _sheetGroupsByBookSheet = new HashMap <> ( ) ; }
public SpatialPrefixTree ( SpatialContext ctx , int maxLevels ) { assert maxLevels > 0 ; this . ctx = ctx ; this . maxLevels = maxLevels ; }
public ListObjectParentsResult listObjectParents ( ListObjectParentsRequest request ) { request = beforeClientExecution ( request ) ; return executeListObjectParents ( request ) ; }
static public double ppmt ( double r , int per , int nper , double pv ) { return pmt ( r , nper , pv ) - ipmt ( r , per , nper , pv ) ; }
public Header ( InputStream is ) throws IOException { final MimeStreamParser parser = new MimeStreamParser ( ) ; parser . setContentHandler ( new AbstractContentHandler ( ) ) ; }
public DescribeSpotInstanceRequestsResult describeSpotInstanceRequests ( ) { return describeSpotInstanceRequests ( new DescribeSpotInstanceRequestsRequest ( ) ) ; }
public SetTransition ( ATNState target , IntervalSet set ) { super ( target ) ; if ( set == null ) set = IntervalSet . of ( Token . INVALID_TYPE ) ; this . set = set ; }
public LbsDataSubRecord clone ( ) { return copy ( ) ; }
public int read ( char [ ] cbuf , int off , int len ) throws IOException { if ( off < 0 ) throw new IllegalArgumentException ( " off ▁ < ▁ 0 " ) ; if ( off >= cbuf . length ) throw new IllegalArgumentException ( " off ▁ >= ▁ cbuf . length " ) ; if ( len <= 0 ) throw new IllegalArgumentException ( " len ▁ <= ▁ 0 " ) ; while ( ! inputFinished || inputBuffer . length ( ) > 0 || resultBuffer . length ( ) > 0 ) { int retLen ; if ( resultBuffer . length ( ) > 0 ) { retLen = outputFromResultBuffer ( cbuf , off , len ) ; if ( retLen > 0 ) { return retLen ; } } int resLen = readAndNormalizeFromInput ( ) ; if ( resLen > 0 ) { retLen = outputFromResultBuffer ( cbuf , off , len ) ; if ( retLen > 0 ) { return retLen ; } } readInputToBuffer ( ) ; } return - 1 ; }
public void readFully ( byte [ ] buffer ) { checkPosition ( buffer . length ) ; read ( buffer , 0 , buffer . length ) ; }
public void setBaselineTfFactors ( float base , float min ) { tf_min = min ; tf_base = base ; }
public DatasetSplitter ( double testRatio , double crossValidationRatio ) { this . crossValidationRatio = crossValidationRatio ; this . testRatio = testRatio ; }
public ListBuildsResult listBuilds ( ListBuildsRequest request ) { request = beforeClientExecution ( request ) ; return executeListBuilds ( request ) ; }
public int getStartLine ( ) { return startLine ; }
public void ReInit ( CharStream stream ) { token_source . ReInit ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( rtFirst ) ; out . writeShort ( rtLast ) ; }
public DBCluster restoreDBClusterFromS3 ( RestoreDBClusterFromS3Request request ) { request = beforeClientExecution ( request ) ; return executeRestoreDBClusterFromS3 ( request ) ; }
public void println ( boolean b ) { println ( String . valueOf ( b ) ) ; }
public ThrowingPrintWriter ( Writer out ) { this . out = out ; LF = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> SystemReader . getInstance ( ) . getProperty ( " line . separator " ) ) ; }
public DescribeResourceResult describeResource ( DescribeResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeResource ( request ) ; }
public String getFlags ( ) { return flags ; }
public GetAccountSettingsResult getAccountSettings ( GetAccountSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAccountSettings ( request ) ; }
public UpdateClusterSettingsResult updateClusterSettings ( UpdateClusterSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateClusterSettings ( request ) ; }
public GetRelationalDatabaseSnapshotsResult getRelationalDatabaseSnapshots ( GetRelationalDatabaseSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabaseSnapshots ( request ) ; }
public ByteBuffer putShort ( short value ) { int newPosition = position + SizeOf . SHORT ; if ( newPosition > limit ) { throw new BufferOverflowException ( ) ; } Memory . pokeShort ( backingArray , offset + position , value , order ) ; position = newPosition ; return this ; }
public DescribeProcessingJobResult describeProcessingJob ( DescribeProcessingJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeProcessingJob ( request ) ; }
public UnbindInstance2VpcRequest ( ) { super ( " Ots " , " 2016 - 06 - 20 " , " UnbindInstance2Vpc " , " ots " ) ; setMethod ( MethodType . POST ) ; }
public ByteArrayBackedDataSource ( byte [ ] data , int size ) { this . buffer = data ; this . size = size ; }
public Set < String > getSchemes ( ) { return Collections . emptySet ( ) ; }
public void seekExact ( long ord ) { termOrd = ( int ) ord ; setTerm ( ) ; }
public QueryConfigHandler getQueryConfigHandler ( ) { return queryConfigHandler ; }
public void set ( int index , long value ) { final int o = index / 9 ; final int b = index % 9 ; final int shift = b * 7 ; blocks [ o ] = ( blocks [ o ] & ~ ( 127L << shift ) ) | ( value << shift ) ; }
public UpdateDocumentationPartResult updateDocumentationPart ( UpdateDocumentationPartRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDocumentationPart ( request ) ; }
public DBCluster deleteDBCluster ( DeleteDBClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDBCluster ( request ) ; }
public Drawable getProgressDrawable ( ) { return mProgressDrawable ; }
public ConfigureHealthCheckRequest ( String loadBalancerName , HealthCheck healthCheck ) { setLoadBalancerName ( loadBalancerName ) ; setHealthCheck ( healthCheck ) ; }
public Row ( Row old ) { cells = old . cells ; }
public void incrementShapeCount ( ) { this . field_1_numShapes ++ ; }
public EnableEbsEncryptionByDefaultResult enableEbsEncryptionByDefault ( EnableEbsEncryptionByDefaultRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableEbsEncryptionByDefault ( request ) ; }
public void setValueNoCopy ( char [ ] newValue ) { clear ( ) ; value = newValue ; }
public String toString ( ) { return " ( " + a . toString ( ) + " ▁ AND ▁ " + b . toString ( ) + " ) " ; }
public DeleteIntegrationResponseResult deleteIntegrationResponse ( DeleteIntegrationResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteIntegrationResponse ( request ) ; }
public boolean contains ( CharSequence cs ) { return map . containsKey ( cs ) ; }
public String getLocalizedMessage ( Locale locale ) { return this . message . getLocalizedMessage ( locale ) ; }
public static long nextHighestPowerOfTwo ( long v ) { v -- ; v |= v >> 1 ; v |= v >> 2 ; v |= v >> 4 ; v |= v >> 8 ; v |= v >> 16 ; v |= v >> 32 ; v ++ ; return v ; }
public CreateTransitGatewayMulticastDomainResult createTransitGatewayMulticastDomain ( CreateTransitGatewayMulticastDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTransitGatewayMulticastDomain ( request ) ; }
public DisassociateDomainResult disassociateDomain ( DisassociateDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateDomain ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " arn : " ) ; sb . append ( this . partition ) ; sb . append ( " : " ) ; sb . append ( this . service ) ; sb . append ( " : " ) ; sb . append ( region ) ; sb . append ( " : " ) ; sb . append ( this . accountId ) ; sb . append ( " : " ) ; sb . append ( this . resource ) ; return sb . toString ( ) ; }
public CellWalk ( Sheet sheet , CellRangeAddress range ) { this . sheet = sheet ; this . range = range ; this . traverseEmptyCells = false ; }
public SendMessageBatchResult sendMessageBatch ( String queueUrl , java . util . List < SendMessageBatchRequestEntry > entries ) { return sendMessageBatch ( new SendMessageBatchRequest ( ) . withQueueUrl ( queueUrl ) . withEntries ( entries ) ) ; }
public GetImportJobsResult getImportJobs ( GetImportJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetImportJobs ( request ) ; }
public float docScore ( int docId , String field , int numPayloadsSeen , float payloadScore ) { return numPayloadsSeen > 0 ? payloadScore : 1 ; }
public CreateRelationalDatabaseResult createRelationalDatabase ( CreateRelationalDatabaseRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRelationalDatabase ( request ) ; }
public Arc < T > copyFrom ( Arc < T > other ) { label = other . label ( ) ; target = other . target ( ) ; flags = other . flags ( ) ; output = other . output ( ) ; nextFinalOutput = other . nextFinalOutput ( ) ; nextArc = other . nextArc ( ) ; nodeFlags = other . nodeFlags ( ) ; bytesPerArc = other . bytesPerArc ( ) ; if ( bytesPerArc ( ) != 0 ) { posArcsStart = other . posArcsStart ( ) ; arcIdx = other . arcIdx ( ) ; numArcs = other . numArcs ( ) ; if ( nodeFlags ( ) == ARCS_FOR_DIRECT_ADDRESSING ) { bitTable = other . bitTable ( ) == null ? null : other . bitTable ( ) . copy ( ) ; firstLabel = other . firstLabel ( ) ; } } return this ; }
public AbbreviatedObjectId getOldId ( ) { return oldId ; }
public ContinueUpdateRollbackResult continueUpdateRollback ( ContinueUpdateRollbackRequest request ) { request = beforeClientExecution ( request ) ; return executeContinueUpdateRollback ( request ) ; }
public ListDataSourcesResult listDataSources ( ListDataSourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeListDataSources ( request ) ; }
public void execute ( Lexer lexer ) { lexer . setChannel ( channel ) ; }
public int LA ( int i ) { if ( i ==- 1 ) return lastChar ; sync ( i ) ; int index = p + i - 1 ; if ( index < 0 ) throw new IndexOutOfBoundsException ( ) ; if ( index >= n ) return IntStream . EOF ; return data [ index ] ; }
public final int [ ] array ( ) { return protectedArray ( ) ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " - " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public RefWriter ( RefList < Ref > refs ) { this . refs = refs . asList ( ) ; }
public long get ( int index ) { final int o = index / 6 ; final int b = index % 6 ; final int shift = b * 10 ; return ( blocks [ o ] >>> shift ) & 1023L ; }
public SubmoduleUpdateCommand setProgressMonitor ( final ProgressMonitor monitor ) { this . monitor = monitor ; return this ; }
public DescribeDatasetGroupResult describeDatasetGroup ( DescribeDatasetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDatasetGroup ( request ) ; }
public ListGameServerGroupsResult listGameServerGroups ( ListGameServerGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListGameServerGroups ( request ) ; }
public NameRecord getSpecificBuiltinRecord ( byte name , int sheetNumber ) { return getOrCreateLinkTable ( ) . getSpecificBuiltinRecord ( name , sheetNumber ) ; }
public long readLong ( ) { int b0 = _in . readUByte ( ) ; int b1 = _in . readUByte ( ) ; int b2 = _in . readUByte ( ) ; int b3 = _in . readUByte ( ) ; int b4 = _in . readUByte ( ) ; int b5 = _in . readUByte ( ) ; int b6 = _in . readUByte ( ) ; int b7 = _in . readUByte ( ) ; return ( ( ( long ) b7 << 56 ) + ( ( long ) b6 << 48 ) + ( ( long ) b5 << 40 ) + ( ( long ) b4 << 32 ) + ( ( long ) b3 << 24 ) + ( b2 << 16 ) + ( b1 << 8 ) + ( b0 << 0 ) ) ; }
public static ValueVector createVector ( TwoDEval ae ) { if ( ae . isColumn ( ) ) { return createColumnVector ( ae , 0 ) ; } if ( ae . isRow ( ) ) { return createRowVector ( ae , 0 ) ; } return null ; }
public boolean isSupported ( int bitsPerValue ) { return bitsPerValue >= 1 && bitsPerValue <= 64 ; }
public String toString ( ) { return " { " + " decision = " + decision + " , ▁ contextSensitivities = " + contextSensitivities . size ( ) + " , ▁ errors = " + errors . size ( ) + " , ▁ ambiguities = " + ambiguities . size ( ) + " , ▁ SLL □ lookahead = " + SLL_TotalLook + " , ▁ SLL □ ATNTransitions = " + SLL_ATNTransitions + " , ▁ SLL □ DFATransitions = " + SLL_DFATransitions + " , ▁ LL □ Fallback = " + LL_Fallback + " , ▁ LL □ lookahead = " + LL_TotalLook + " , ▁ LL □ ATNTransitions = " + LL_ATNTransitions + ' } ' ; }
public RemoveNoteCommand notesRemove ( ) { return new RemoveNoteCommand ( repo ) ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = thedata . length ; for ( EscherRecord r : _childRecords ) { remainingBytes += r . getRecordSize ( ) ; } LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; System . arraycopy ( thedata , 0 , data , offset + 8 , thedata . length ) ; int pos = offset + 8 + thedata . length ; for ( EscherRecord r : _childRecords ) { pos += r . serialize ( pos , data , listener ) ; } listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; }
public void inform ( ResourceLoader loader ) throws IOException { if ( stopWordFiles != null ) { if ( FORMAT_WORDSET . equalsIgnoreCase ( format ) ) { stopWords = getWordSet ( loader , stopWordFiles , ignoreCase ) ; } else if ( FORMAT_SNOWBALL . equalsIgnoreCase ( format ) ) { stopWords = getSnowballWordSet ( loader , stopWordFiles , ignoreCase ) ; } else { throw new IllegalArgumentException ( " Unknown ▁ ' format ' ▁ specified ▁ for ▁ ' words ' ▁ file : ▁ " + format ) ; } } else { if ( null != format ) { throw new IllegalArgumentException ( " ' format ' ▁ can ▁ not ▁ be ▁ specified ▁ w / o ▁ an ▁ explicit ▁ ' words ' ▁ file : ▁ " + format ) ; } stopWords = new CharArraySet ( EnglishAnalyzer . ENGLISH_STOP_WORDS_SET , ignoreCase ) ; } }
public PredicateTransition ( ATNState target , int ruleIndex , int predIndex , boolean isCtxDependent ) { super ( target ) ; this . ruleIndex = ruleIndex ; this . predIndex = predIndex ; this . isCtxDependent = isCtxDependent ; }
public CharFilter ( Reader input ) { super ( input ) ; this . input = input ; }
public final DoubleBuffer put ( DoubleBuffer buf ) { throw new ReadOnlyBufferException ( ) ; }
public AssociateVpcCidrBlockResult associateVpcCidrBlock ( AssociateVpcCidrBlockRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateVpcCidrBlock ( request ) ; }
public static Date getJavaDate ( double date , boolean use1904windowing , TimeZone tz , boolean roundSeconds ) { Calendar calendar = getJavaCalendar ( date , use1904windowing , tz , roundSeconds ) ; return calendar == null ? null : calendar . getTime ( ) ; }
public AttachTypedLinkResult attachTypedLink ( AttachTypedLinkRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachTypedLink ( request ) ; }
public static CellValue getError ( int errorCode ) { return new CellValue ( CellType . ERROR , 0.0 , false , null , errorCode ) ; }
public short getHeaderValue ( ) { return headerValue ; }
public DescribeFindingsResult describeFindings ( DescribeFindingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFindings ( request ) ; }
public GetSdkTypeResult getSdkType ( GetSdkTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSdkType ( request ) ; }
public PutLifecycleConfigurationResult putLifecycleConfiguration ( PutLifecycleConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executePutLifecycleConfiguration ( request ) ; }
public CommonToken create ( int type , String text ) { return new CommonToken ( type , text ) ; }
public CommitBuilder ( ) { parentIds = EMPTY_OBJECTID_LIST ; encoding = UTF_8 ; }
public boolean isWholeColumnReference ( ) { return isWholeColumnReference ( _version , _firstCell , _lastCell ) ; }
public final T add ( T element ) { size ++ ; heap [ size ] = element ; upHeap ( size ) ; return heap [ 1 ] ; }
public ListTagCommand tagList ( ) { return new ListTagCommand ( repo ) ; }
public DescribeLoadBalancerPoliciesResult describeLoadBalancerPolicies ( ) { return describeLoadBalancerPolicies ( new DescribeLoadBalancerPoliciesRequest ( ) ) ; }
public LikePhotoRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " LikePhoto " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public ByteBuffer putShort ( int index , short value ) { throw new ReadOnlyBufferException ( ) ; }
public E pollLast ( ) { return ( size == 0 ) ? null : removeLastImpl ( ) ; }
@ Override public int size ( ) { return countMap . size ( ) ; }
public static float [ ] copyOf ( float [ ] original , int newLength ) { if ( newLength < 0 ) { throw new NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; }
public LogoutUserResult logoutUser ( LogoutUserRequest request ) { request = beforeClientExecution ( request ) ; return executeLogoutUser ( request ) ; }
public final boolean matches ( char c ) { return Character . isLetter ( c ) ; }
public ListResolverEndpointIpAddressesResult listResolverEndpointIpAddresses ( ListResolverEndpointIpAddressesRequest request ) { request = beforeClientExecution ( request ) ; return executeListResolverEndpointIpAddresses ( request ) ; }
public ListHealthChecksResult listHealthChecks ( ListHealthChecksRequest request ) { request = beforeClientExecution ( request ) ; return executeListHealthChecks ( request ) ; }
@ Override public int indexOf ( Object object ) { Slice slice = this . slice ; Object [ ] snapshot = elements ; slice . checkConcurrentModification ( snapshot ) ; int result = CopyOnWriteArrayList . indexOf ( object , snapshot , slice . from , slice . to ) ; return ( result != - 1 ) ? ( result - slice . from ) : - 1 ; }
public GetQualificationScoreResult getQualificationScore ( GetQualificationScoreRequest request ) { request = beforeClientExecution ( request ) ; return executeGetQualificationScore ( request ) ; }
public ListMeetingsResult listMeetings ( ListMeetingsRequest request ) { request = beforeClientExecution ( request ) ; return executeListMeetings ( request ) ; }
public LookupPolicyResult lookupPolicy ( LookupPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeLookupPolicy ( request ) ; }
public ListAssessmentRunAgentsResult listAssessmentRunAgents ( ListAssessmentRunAgentsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAssessmentRunAgents ( request ) ; }
public UpdateEndpointWeightsAndCapacitiesResult updateEndpointWeightsAndCapacities ( UpdateEndpointWeightsAndCapacitiesRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateEndpointWeightsAndCapacities ( request ) ; }
public UpdateCloudFrontOriginAccessIdentityResult updateCloudFrontOriginAccessIdentity ( UpdateCloudFrontOriginAccessIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateCloudFrontOriginAccessIdentity ( request ) ; }
public BatchPutAttributesRequest ( String domainName , java . util . List < ReplaceableItem > items ) { setDomainName ( domainName ) ; setItems ( items ) ; }
public DeleteAnomalyDetectorResult deleteAnomalyDetector ( DeleteAnomalyDetectorRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAnomalyDetector ( request ) ; }
public DeleteSpotDatafeedSubscriptionResult deleteSpotDatafeedSubscription ( ) { return deleteSpotDatafeedSubscription ( new DeleteSpotDatafeedSubscriptionRequest ( ) ) ; }
public void unread ( char [ ] buffer , int offset , int length ) throws IOException { synchronized ( lock ) { checkNotClosed ( ) ; if ( length > pos ) { throw new IOException ( " Pushback ▁ buffer ▁ full " ) ; } Arrays . checkOffsetAndCount ( buffer . length , offset , length ) ; for ( int i = offset + length - 1 ; i >= offset ; i -- ) { unread ( buffer [ i ] ) ; } } }
public String getOldPrefix ( ) { return this . oldPrefix ; }
public CommonGramsFilterFactory ( Map < String , String > args ) { super ( args ) ; commonWordFiles = get ( args , " words " ) ; format = get ( args , " format " ) ; ignoreCase = getBoolean ( args , " ignoreCase " , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public DeleteCorsConfigurationResult deleteCorsConfiguration ( DeleteCorsConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCorsConfiguration ( request ) ; }
public void write ( String str , int offset , int count ) { if ( str == null ) { throw new NullPointerException ( " str ▁ == ▁ null " ) ; } if ( ( offset | count ) < 0 || offset > str . length ( ) - count ) { throw new StringIndexOutOfBoundsException ( str , offset , count ) ; } synchronized ( lock ) { expand ( count ) ; str . getChars ( offset , offset + count , buf , this . count ) ; this . count += count ; } }
public GetMethodResult getMethod ( GetMethodRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMethod ( request ) ; }
public Repository getRepository ( ) { return repo ; }
public DeleteTrafficMirrorFilterRuleResult deleteTrafficMirrorFilterRule ( DeleteTrafficMirrorFilterRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTrafficMirrorFilterRule ( request ) ; }
public CreateLabelingJobResult createLabelingJob ( CreateLabelingJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLabelingJob ( request ) ; }
@ Override public boolean equals ( Object other ) { if ( other instanceof CopyOnWriteArrayList ) { return this == other || Arrays . equals ( elements , ( ( CopyOnWriteArrayList <?> ) other ) . elements ) ; } else if ( other instanceof List ) { Object [ ] snapshot = elements ; Iterator <?> i = ( ( List <?> ) other ) . iterator ( ) ; for ( Object o : snapshot ) { if ( ! i . hasNext ( ) || ! Objects . equal ( o , i . next ( ) ) ) { return false ; } } return ! i . hasNext ( ) ; } else { return false ; } }
public DeleteCustomMetadataResult deleteCustomMetadata ( DeleteCustomMetadataRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCustomMetadata ( request ) ; }
public DescribeNetworkAclsResult describeNetworkAcls ( DescribeNetworkAclsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNetworkAcls ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ CONTINUE ▁ RECORD ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . data ▁ = ▁ " ) . append ( HexDump . toHex ( _data ) ) . append ( " \ n " ) ; buffer . append ( " [ / CONTINUE ▁ RECORD ] \ n " ) ; return buffer . toString ( ) ; }
public UnsubscribeRequest ( String subscriptionArn ) { setSubscriptionArn ( subscriptionArn ) ; }
public ListRulesPackagesResult listRulesPackages ( ListRulesPackagesRequest request ) { request = beforeClientExecution ( request ) ; return executeListRulesPackages ( request ) ; }
public DisableMetricsCollectionResult disableMetricsCollection ( DisableMetricsCollectionRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableMetricsCollection ( request ) ; }
public static FloatBuffer wrap ( float [ ] array ) { return wrap ( array , 0 , array . length ) ; }
public void set ( int index , long value ) { final int o = index / 7 ; final int b = index % 7 ; final int shift = b * 9 ; blocks [ o ] = ( blocks [ o ] & ~ ( 511L << shift ) ) | ( value << shift ) ; }
public synchronized boolean containsKey ( Object key ) { int hash = key . hashCode ( ) ; hash ^= ( hash >>> 20 ) ^ ( hash >>> 12 ) ; hash ^= ( hash >>> 7 ) ^ ( hash >>> 4 ) ; HashtableEntry < K , V > [ ] tab = table ; for ( HashtableEntry < K , V > e = tab [ hash & ( tab . length - 1 ) ] ; e != null ; e = e . next ) { K eKey = e . key ; if ( eKey == key || ( e . hash == hash && key . equals ( eKey ) ) ) { return true ; } } return false ; }
public void close ( ) throws IOException { Throwable thrown = null ; try { flush ( ) ; } catch ( Throwable e ) { thrown = e ; } try { out . close ( ) ; } catch ( Throwable e ) { if ( thrown == null ) { thrown = e ; } } if ( thrown != null ) { SneakyThrow . sneakyThrow ( thrown ) ; } }
public List < String > getConflictList ( ) { return conflictList ; }
public ListOrganizationAdminAccountsResult listOrganizationAdminAccounts ( ListOrganizationAdminAccountsRequest request ) { request = beforeClientExecution ( request ) ; return executeListOrganizationAdminAccounts ( request ) ; }
public static double min ( double [ ] values ) { double min = Double . POSITIVE_INFINITY ; for ( double value : values ) { min = Math . min ( min , value ) ; } return min ; }
@ Override public int read ( ) throws IOException { return Streams . readSingleByte ( this ) ; }
public void removeLineCount ( ) { remove1stProperty ( PropertyIDMap . PID_LINECOUNT ) ; }
public RowRecordsAggregate ( RecordStream rs , SharedValueManager svm ) { this ( svm ) ; while ( rs . hasNext ( ) ) { Record rec = rs . getNext ( ) ; switch ( rec . getSid ( ) ) { case RowRecord . sid : insertRow ( ( RowRecord ) rec ) ; continue ; case DConRefRecord . sid : addUnknownRecord ( rec ) ; continue ; case DBCellRecord . sid : continue ; } if ( rec instanceof UnknownRecord ) { addUnknownRecord ( rec ) ; while ( rs . peekNextSid ( ) == ContinueRecord . sid ) { addUnknownRecord ( rs . getNext ( ) ) ; } continue ; } if ( rec instanceof MulBlankRecord ) { _valuesAgg . addMultipleBlanks ( ( MulBlankRecord ) rec ) ; continue ; } if ( ! ( rec instanceof CellValueRecordInterface ) ) { throw new RuntimeException ( " Unexpected ▁ record ▁ type ▁ ( " + rec . getClass ( ) . getName ( ) + " ) " ) ; } _valuesAgg . construct ( ( CellValueRecordInterface ) rec , rs , svm ) ; } }
public CreateRepoSyncTaskRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " CreateRepoSyncTask " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / syncTasks " ) ; setMethod ( MethodType . PUT ) ; }
public SharedFormula ( SpreadsheetVersion ssVersion ) { _columnWrappingMask = ssVersion . getLastColumnIndex ( ) ; _rowWrappingMask = ssVersion . getLastRowIndex ( ) ; }
public LexerTypeAction ( int type ) { this . type = type ; }
public char first ( ) { if ( start == end ) { return DONE ; } offset = start ; return string . charAt ( offset ) ; }
public ShortBuffer slice ( ) { return new ReadOnlyShortArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public RenameBranchCommand setNewName ( String newName ) { checkCallable ( ) ; this . newName = newName ; return this ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getOptions ( ) ) ; out . writeInt ( getHorizontalPos ( ) ) ; out . writeInt ( getVerticalPos ( ) ) ; out . writeInt ( getObjectID ( ) ) ; out . writeInt ( getDVRecNo ( ) ) ; }
public SheetBuilder setCreateEmptyCells ( boolean shouldCreateEmptyCells ) { this . shouldCreateEmptyCells = shouldCreateEmptyCells ; return this ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval serialNumVE , ValueEval returnTypeVE ) { double serialNum ; try { serialNum = NumericFunction . singleOperandEvaluate ( serialNumVE , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return ErrorEval . VALUE_INVALID ; } Calendar serialNumCalendar = LocaleUtil . getLocaleCalendar ( ) ; serialNumCalendar . setTime ( DateUtil . getJavaDate ( serialNum , false ) ) ; int returnType ; try { ValueEval ve = OperandResolver . getSingleValue ( returnTypeVE , srcRowIndex , srcColumnIndex ) ; returnType = OperandResolver . coerceValueToInt ( ve ) ; } catch ( EvaluationException e ) { return ErrorEval . NUM_ERROR ; } if ( returnType != 1 && returnType != 2 ) { return ErrorEval . NUM_ERROR ; } return new NumberEval ( this . getWeekNo ( serialNumCalendar , returnType ) ) ; }
public static int checkHeader ( DataInput in , String codec , int minVersion , int maxVersion ) throws IOException { final int actualHeader = in . readInt ( ) ; if ( actualHeader != CODEC_MAGIC ) { throw new CorruptIndexException ( " codec ▁ header ▁ mismatch : ▁ actual ▁ header = " + actualHeader + " ▁ vs ▁ expected ▁ header = " + CODEC_MAGIC , in ) ; } return checkHeaderNoMagic ( in , codec , minVersion , maxVersion ) ; }
public String getErrorDisplay ( String s ) { StringBuilder buf = new StringBuilder ( ) ; for ( char c : s . toCharArray ( ) ) { buf . append ( getErrorDisplay ( c ) ) ; } return buf . toString ( ) ; }
public boolean seekExact ( BytesRef text ) { termUpto = binarySearch ( text , br , 0 , info . terms . size ( ) - 1 , info . terms , info . sortedTerms ) ; return termUpto >= 0 ; }
public CacheSecurityGroup createCacheSecurityGroup ( CreateCacheSecurityGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCacheSecurityGroup ( request ) ; }
public FetchMomentPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " FetchMomentPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public int getRuleIndex ( String ruleName ) { Integer ruleIndex = getRuleIndexMap ( ) . get ( ruleName ) ; if ( ruleIndex != null ) return ruleIndex ; return - 1 ; }
public RebootInstanceRequest ( ) { super ( " Ens " , " 2017 - 11 - 10 " , " RebootInstance " , " ens " ) ; setMethod ( MethodType . POST ) ; }
public RevokeClientVpnIngressResult revokeClientVpnIngress ( RevokeClientVpnIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeRevokeClientVpnIngress ( request ) ; }
public boolean supportsExecute ( ) { return false ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SHARED ▁ FORMULA ▁ ( " ) . append ( HexDump . intToHex ( sid ) ) . append ( " ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . range ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getRange ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . reserved ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( field_5_reserved ) ) . append ( " \ n " ) ; Ptg [ ] ptgs = field_7_parsed_expr . getTokens ( ) ; for ( int k = 0 ; k < ptgs . length ; k ++ ) { buffer . append ( " Formula [ " ) . append ( k ) . append ( " ] " ) ; Ptg ptg = ptgs [ k ] ; buffer . append ( ptg ) . append ( ptg . getRVAType ( ) ) . append ( " \ n " ) ; } buffer . append ( " [ / SHARED ▁ FORMULA ] \ n " ) ; return buffer . toString ( ) ; }
public LexerPushModeAction ( int mode ) { this . mode = mode ; }
public void mark ( int readlimit ) { mark = ptr ; }
public ClusterParameterGroup createClusterParameterGroup ( CreateClusterParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateClusterParameterGroup ( request ) ; }
public String distanceSubQueryNotAllowed ( ) { Iterator < SrndQuery > sqi = getSubQueriesIterator ( ) ; while ( sqi . hasNext ( ) ) { SrndQuery leq = sqi . next ( ) ; if ( leq instanceof DistanceSubQuery ) { String m = ( ( DistanceSubQuery ) leq ) . distanceSubQueryNotAllowed ( ) ; if ( m != null ) { return m ; } } else { return " subquery ▁ not ▁ allowed : ▁ " + leq . toString ( ) ; } } return null ; }
public DescribeBrokerEngineTypesResult describeBrokerEngineTypes ( DescribeBrokerEngineTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeBrokerEngineTypes ( request ) ; }
public DescribeReservedDBInstancesOfferingsResult describeReservedDBInstancesOfferings ( DescribeReservedDBInstancesOfferingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReservedDBInstancesOfferings ( request ) ; }
public ByteBuffer slice ( ) { return new ReadWriteHeapByteBuffer ( backingArray , remaining ( ) , offset + position ) ; }
public GetCollectionRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetCollection " , " cr " ) ; setUriPattern ( " / collections " ) ; setMethod ( MethodType . GET ) ; }
public DeleteApplicationVersionRequest ( String applicationName , String versionLabel ) { setApplicationName ( applicationName ) ; setVersionLabel ( versionLabel ) ; }
public int last ( ) { return ( current = end ) ; }
public DeleteFleetResult deleteFleet ( DeleteFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFleet ( request ) ; }
public void sync ( Collection < String > names ) { throw new UnsupportedOperationException ( ) ; }
public DescribeWorkteamResult describeWorkteam ( DescribeWorkteamRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWorkteam ( request ) ; }
public StatusCommand status ( ) { return new StatusCommand ( repo ) ; }
public StopInstancesResult stopInstances ( StopInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeStopInstances ( request ) ; }
public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( obj == this ) return true ; if ( obj . getClass ( ) != getClass ( ) ) return false ; HSSFChildAnchor anchor = ( HSSFChildAnchor ) obj ; return anchor . getDx1 ( ) == getDx1 ( ) && anchor . getDx2 ( ) == getDx2 ( ) && anchor . getDy1 ( ) == getDy1 ( ) && anchor . getDy2 ( ) == getDy2 ( ) ; }
public DescribeDBSubnetGroupsResult describeDBSubnetGroups ( ) { return describeDBSubnetGroups ( new DescribeDBSubnetGroupsRequest ( ) ) ; }
public PostingsEnum reset ( int [ ] docIDs , int [ ] freqs ) { this . docIDs = docIDs ; this . freqs = freqs ; docID = upto = - 1 ; return this ; }
public boolean hasNext ( ) { return index < size ; }
public ListTagsForResourceResult listTagsForResource ( ListTagsForResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeListTagsForResource ( request ) ; }
public static String getBuiltinFormat ( int index ) { if ( index < 0 || index >= _formats . length ) { return null ; } return _formats [ index ] ; }
public ExpandedDouble ( long rawBits ) { int biasedExp = Math . toIntExact ( rawBits >> 52 ) ; if ( biasedExp == 0 ) { BigInteger frac = BigInteger . valueOf ( rawBits ) . and ( BI_FRAC_MASK ) ; int expAdj = 64 - frac . bitLength ( ) ; _significand = frac . shiftLeft ( expAdj ) ; _binaryExponent = ( biasedExp & 0x07FF ) - 1023 - expAdj ; } else { _significand = getFrac ( rawBits ) ; _binaryExponent = ( biasedExp & 0x07FF ) - 1023 ; } }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _codepage ) ; }
public void add ( RevCommit c ) { throw new UnsupportedOperationException ( ) ; }
public CellRangeAddress [ ] getFormattingRanges ( ) { return cfAggregate . getHeader ( ) . getCellRanges ( ) ; }
public PrintStream append ( CharSequence charSequence ) { if ( charSequence == null ) { print ( " null " ) ; } else { print ( charSequence . toString ( ) ) ; } return this ; }
public GetSkillGroupResult getSkillGroup ( GetSkillGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSkillGroup ( request ) ; }
public DeleteObjectResult deleteObject ( DeleteObjectRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteObject ( request ) ; }
public boolean removeAll ( final IntList c ) { boolean rval = false ; for ( int j = 0 ; j < c . _limit ; j ++ ) { if ( removeValue ( c . _array [ j ] ) ) { rval = true ; } } return rval ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ FILEPASS ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . type ▁ = ▁ " ) . append ( HexDump . shortToHex ( encryptionType ) ) . append ( ' \ n ' ) ; String prefix = " ▁ ▁ ▁ ▁ ▁ . " + encryptionInfo . getEncryptionMode ( ) ; buffer . append ( prefix + " . info ▁ = ▁ " ) . append ( HexDump . shortToHex ( encryptionInfo . getVersionMajor ( ) ) ) . append ( ' \ n ' ) ; buffer . append ( prefix + " . ver ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( encryptionInfo . getVersionMinor ( ) ) ) . append ( ' \ n ' ) ; buffer . append ( prefix + " . salt ▁ = ▁ " ) . append ( HexDump . toHex ( encryptionInfo . getVerifier ( ) . getSalt ( ) ) ) . append ( ' \ n ' ) ; buffer . append ( prefix + " . verifier ▁ = ▁ " ) . append ( HexDump . toHex ( encryptionInfo . getVerifier ( ) . getEncryptedVerifier ( ) ) ) . append ( ' \ n ' ) ; buffer . append ( prefix + " . verifierHash ▁ = ▁ " ) . append ( HexDump . toHex ( encryptionInfo . getVerifier ( ) . getEncryptedVerifierHash ( ) ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / FILEPASS ] \ n " ) ; return buffer . toString ( ) ; }
public CreateCustomerGatewayResult createCustomerGateway ( CreateCustomerGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCustomerGateway ( request ) ; }
public CharBuffer compact ( ) { if ( byteBuffer . isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } byteBuffer . limit ( limit * SizeOf . CHAR ) ; byteBuffer . position ( position * SizeOf . CHAR ) ; byteBuffer . compact ( ) ; byteBuffer . clear ( ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public DirCache getDirCache ( ) { return cache ; }
public PatternReplaceCharFilterFactory ( Map < String , String > args ) { super ( args ) ; pattern = getPattern ( args , " pattern " ) ; replacement = get ( args , " replacement " , " " ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public boolean getCreateEmptyCells ( ) { return shouldCreateEmptyCells ; }
public long getIndexSize ( ) { long sz = 8 ; sz += 4 * 4 ; sz += sizeOf ( src ) ; sz += sizeOf ( table ) ; sz += sizeOf ( entries ) ; return sz ; }
public ShortBuffer put ( short [ ] src , int srcOffset , int shortCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , shortCount ) ; if ( shortCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + shortCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public String toString ( ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " < multiPhrase /> " ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " < multiPhrase > " ) ; for ( QueryNode child : getChildren ( ) ) { sb . append ( " \ n " ) ; sb . append ( child . toString ( ) ) ; } sb . append ( " \ n </ multiPhrase > " ) ; return sb . toString ( ) ; }
public GetGatewayResponseResult getGatewayResponse ( GetGatewayResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeGetGatewayResponse ( request ) ; }
public SubscribeRequest ( String topicArn , String protocol , String endpoint ) { setTopicArn ( topicArn ) ; setProtocol ( protocol ) ; setEndpoint ( endpoint ) ; }
public void setLengthNormFactors ( int min , int max , float steepness , boolean discountOverlaps ) { this . ln_min = min ; this . ln_max = max ; this . ln_steep = steepness ; this . discountOverlaps = discountOverlaps ; }
public void start ( ) { mStartTime = ANIMATION_START ; }
public DeleteLaunchConfigurationResult deleteLaunchConfiguration ( DeleteLaunchConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLaunchConfiguration ( request ) ; }
public void remove ( Object record ) { int i = 0 ; for ( org . apache . poi . hssf . record . Record r : records ) { if ( r == record ) { remove ( i ) ; break ; } i ++ ; } }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeShort ( getFunctionIndex ( ) ) ; }
public Term ( String fld , BytesRef bytes ) { field = fld ; this . bytes = bytes == null ? null : BytesRef . deepCopyOf ( bytes ) ; }
public long ramBytesUsed ( ) { return RamUsageEstimator . alignObjectSize ( RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + RamUsageEstimator . NUM_BYTES_OBJECT_REF + Long . BYTES + Float . BYTES ) + current . ramBytesUsed ( ) ; }
public int serialize ( int offset , byte [ ] data ) { return serialize ( offset , data , new NullEscherSerializationListener ( ) ) ; }
public String toString ( ) { if ( count == 0 ) { return " " ; } int wasted = value . length - count ; if ( wasted >= 256 || ( wasted >= INITIAL_CAPACITY && wasted >= ( count >> 1 ) ) ) { return new String ( value , 0 , count ) ; } shared = true ; return new String ( 0 , count , value ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_protect ) ; }
public AssociateResolverEndpointIpAddressResult associateResolverEndpointIpAddress ( AssociateResolverEndpointIpAddressRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateResolverEndpointIpAddress ( request ) ; }
public RevertCommand include ( AnyObjectId commit ) { return include ( commit . getName ( ) , commit ) ; }
public static ByteBuffer wrap ( byte [ ] array ) { return new ReadWriteHeapByteBuffer ( array ) ; }
public void removeSecurity ( ) { remove1stProperty ( PropertyIDMap . PID_SECURITY ) ; }
public ImportVolumeResult importVolume ( ImportVolumeRequest request ) { request = beforeClientExecution ( request ) ; return executeImportVolume ( request ) ; }
public boolean isDetectRenames ( ) { return renameDetector != null ; }
public CacheCluster rebootCacheCluster ( RebootCacheClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeRebootCacheCluster ( request ) ; }
public DescribeTemplateAliasResult describeTemplateAlias ( DescribeTemplateAliasRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTemplateAlias ( request ) ; }
public void reset ( ) { if ( overflow != null ) { destroy ( ) ; } if ( blocks != null ) blocks . clear ( ) ; elseblocks = new ArrayList <> ( initialBlocks ) ; blocks . add ( new Block ( Math . min ( inCoreLimit , Block . SZ ) ) ) ; }
public DescribeWorkspaceSnapshotsResult describeWorkspaceSnapshots ( DescribeWorkspaceSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWorkspaceSnapshots ( request ) ; }
public void clear ( ) { name = null ; body = null ; title = null ; date = null ; props = null ; id = - 1 ; }
public DeleteDistributionResult deleteDistribution ( DeleteDistributionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDistribution ( request ) ; }
public final long next ( ) { assert hasNext ( ) ; long result = currentValues [ pOff ++ ] ; if ( pOff == currentCount ) { vOff += 1 ; pOff = 0 ; fillBlock ( ) ; } return result ; }
public AttachInstancesToLoadBalancerResult attachInstancesToLoadBalancer ( AttachInstancesToLoadBalancerRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachInstancesToLoadBalancer ( request ) ; }
public PrintSetupRecord ( RecordInputStream in ) { field_1_paper_size = in . readShort ( ) ; field_2_scale = in . readShort ( ) ; field_3_page_start = in . readShort ( ) ; field_4_fit_width = in . readShort ( ) ; field_5_fit_height = in . readShort ( ) ; field_6_options = in . readShort ( ) ; field_7_hresolution = in . readShort ( ) ; field_8_vresolution = in . readShort ( ) ; field_9_headermargin = in . readDouble ( ) ; field_10_footermargin = in . readDouble ( ) ; field_11_copies = in . readShort ( ) ; }
public UpdateNotificationSettingsResult updateNotificationSettings ( UpdateNotificationSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateNotificationSettings ( request ) ; }
public DescribeSnapshotAttributeResult describeSnapshotAttribute ( DescribeSnapshotAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSnapshotAttribute ( request ) ; }
public ListDocumentClassificationJobsResult listDocumentClassificationJobs ( ListDocumentClassificationJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDocumentClassificationJobs ( request ) ; }
public Item ( ) { parent = 0 ; child = 0 ; }
public static final AbbreviatedObjectId fromObjectId ( AnyObjectId id ) { return new AbbreviatedObjectId ( Constants . OBJECT_ID_STRING_LENGTH , id . w1 , id . w2 , id . w3 , id . w4 , id . w5 ) ; }
public String format ( Object value ) { StringBuffer sb = new StringBuffer ( ) ; formatValue ( sb , value ) ; return sb . toString ( ) ; }
public void processContinueRecord ( byte [ ] record ) { rawDataContainer . concatenate ( record ) ; }
public ListenerHandle addChangeListener ( ConfigChangedListener listener ) { return listeners . addConfigChangedListener ( listener ) ; }
public BlendedTermQuery build ( ) { return new BlendedTermQuery ( ArrayUtil . copyOfSubArray ( terms , 0 , numTerms ) , ArrayUtil . copyOfSubArray ( boosts , 0 , numTerms ) , ArrayUtil . copyOfSubArray ( contexts , 0 , numTerms ) , rewriteMethod ) ; }
public void setFlagByBit ( int bitmask , boolean enabled ) { if ( enabled ) { flags |= bitmask ; } else { flags &= ( 0xFFFF ^ bitmask ) ; } }
public static double calculate ( double pStartDateVal , double pEndDateVal , int basis ) throws EvaluationException { if ( basis < 0 || basis >= 5 ) { throw new EvaluationException ( ErrorEval . NUM_ERROR ) ; } int startDateVal = ( int ) Math . floor ( pStartDateVal ) ; int endDateVal = ( int ) Math . floor ( pEndDateVal ) ; if ( startDateVal == endDateVal ) { return 0 ; } if ( startDateVal > endDateVal ) { int temp = startDateVal ; startDateVal = endDateVal ; endDateVal = temp ; } switch ( basis ) { case 0 : return basis0 ( startDateVal , endDateVal ) ; case 1 : return basis1 ( startDateVal , endDateVal ) ; case 2 : return basis2 ( startDateVal , endDateVal ) ; case 3 : return basis3 ( startDateVal , endDateVal ) ; case 4 : return basis4 ( startDateVal , endDateVal ) ; } throw new IllegalStateException ( " cannot ▁ happen " ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " " ; StringBuilder sb = new StringBuilder ( ) ; String filler = " " ; for ( QueryNode child : getChildren ( ) ) { sb . append ( filler ) . append ( child . toQueryString ( escapeSyntaxParser ) ) ; filler = " ▁ " ; } if ( ( getParent ( ) != null && getParent ( ) instanceof GroupQueryNode ) || isRoot ( ) ) return sb . toString ( ) ; else return " ( ▁ " + sb . toString ( ) + " ▁ ) " ; }
public ByteBuffer putDouble ( int index , double value ) { throw new ReadOnlyBufferException ( ) ; }
public GetVoiceConnectorGroupResult getVoiceConnectorGroup ( GetVoiceConnectorGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVoiceConnectorGroup ( request ) ; }
public BatchUpdateUserResult batchUpdateUser ( BatchUpdateUserRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchUpdateUser ( request ) ; }
public String toString ( ) { return new String ( chars , offset , length ) ; }
public DescribeStorageResult describeStorage ( DescribeStorageRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStorage ( request ) ; }
public void close ( ) { flush ( ) ; }
public void close ( ) throws IOException { super . close ( ) ; }
public final void backup ( int amount ) { bufferPosition -= amount ; }
public UpdateDashboardPublishedVersionResult updateDashboardPublishedVersion ( UpdateDashboardPublishedVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDashboardPublishedVersion ( request ) ; }
public DocumentStoredFieldVisitor ( String ... fields ) { fieldsToAdd = new HashSet <> ( fields . length ) ; for ( String field : fields ) { fieldsToAdd . add ( field ) ; } }
public ResumeGameServerGroupResult resumeGameServerGroup ( ResumeGameServerGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeResumeGameServerGroup ( request ) ; }
public PushCommand setPushAll ( ) { refSpecs . add ( Transport . REFSPEC_PUSH_ALL ) ; return this ; }
public DBSnapshot createDBSnapshot ( CreateDBSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBSnapshot ( request ) ; }
public boolean willSoonExpire ( ) { if ( roleSessionDurationSeconds == 0 ) { return false ; } long now = System . currentTimeMillis ( ) ; double expireFact = 0.95 ; return roleSessionDurationSeconds * expireFact < ( now - sessionStartedTimeInMilliSeconds ) / 1000.0 ; }
public List < Interval > getIntervals ( ) { return intervals ; }
public GetNamespaceRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetNamespace " , " cr " ) ; setUriPattern ( " / namespace / [ Namespace ] " ) ; setMethod ( MethodType . GET ) ; }
public DeleteVpcRequest ( String vpcId ) { setVpcId ( vpcId ) ; }
public long ramBytesUsed ( ) { long bytesUsed = BASE_RAM_BYTES_USED ; if ( dict != null ) { bytesUsed += dict . ramBytesUsed ( ) ; } return bytesUsed ; }
public final ValueEval evaluate ( ValueEval [ ] args , int srcRow , int srcCol ) { if ( args . length < 1 ) { return ErrorEval . VALUE_INVALID ; } boolean boolResult ; try { boolResult = calculate ( args ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return BoolEval . valueOf ( boolResult ) ; }
public void println ( String str ) { synchronized ( lock ) { print ( str ) ; println ( ) ; } }
public TypedPropertyValue ( int type , Object value ) { _type = type ; _value = value ; }
public FloatBuffer duplicate ( ) { ByteBuffer bb = byteBuffer . duplicate ( ) . order ( byteBuffer . order ( ) ) ; FloatToByteBufferAdapter buf = new FloatToByteBufferAdapter ( bb ) ; buf . limit = limit ; buf . position = position ; buf . mark = mark ; return buf ; }
public MigrateWorkspaceResult migrateWorkspace ( MigrateWorkspaceRequest request ) { request = beforeClientExecution ( request ) ; return executeMigrateWorkspace ( request ) ; }
public GetRequestValidatorResult getRequestValidator ( GetRequestValidatorRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRequestValidator ( request ) ; }
public String toString ( ) { return toString ( false ) ; }
public ForgetSmartHomeAppliancesResult forgetSmartHomeAppliances ( ForgetSmartHomeAppliancesRequest request ) { request = beforeClientExecution ( request ) ; return executeForgetSmartHomeAppliances ( request ) ; }
public DeleteApiResult deleteApi ( DeleteApiRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApi ( request ) ; }
public void setKeyProgressIncrement ( int increment ) { mKeyProgressIncrement = increment < 0 ? - increment : increment ; }
public boolean addAll ( final IntList c ) { if ( c . _limit != 0 ) { if ( ( _limit + c . _limit ) > _array . length ) { growArray ( _limit + c . _limit ) ; } System . arraycopy ( c . _array , 0 , _array , _limit , c . _limit ) ; _limit += c . _limit ; } return true ; }
public DVRecord createDVRecord ( HSSFSheet sheet ) { FormulaPair fp = _constraint . createFormulas ( sheet ) ; return new DVRecord ( _constraint . getValidationType ( ) , _constraint . getOperator ( ) , _errorStyle , _emptyCellAllowed , getSuppressDropDownArrow ( ) , _constraint . getValidationType ( ) == ValidationType . LIST && _constraint . getExplicitListValues ( ) != null , _showPromptBox , _prompt_title , _prompt_text , _showErrorBox , _error_title , _error_text , fp . getFormula1 ( ) , fp . getFormula2 ( ) , _regions ) ; }
public boolean evaluate ( int cmpResult ) { switch ( _code ) { case NONE : case EQ : return cmpResult == 0 ; case NE : return cmpResult != 0 ; case LT : return cmpResult < 0 ; case LE : return cmpResult <= 0 ; case GT : return cmpResult > 0 ; case GE : return cmpResult >= 0 ; } throw new RuntimeException ( " Cannot ▁ call ▁ boolean ▁ evaluate ▁ on ▁ non - equality ▁ operator ▁ ' " + ▁ □ representation ▁ + ▁ " ' " ) ; }
public boolean isCancelled ( ) { return false ; }
public ListHoursOfOperationsResult listHoursOfOperations ( ListHoursOfOperationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListHoursOfOperations ( request ) ; }
public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( " Label ▁ Records ▁ are ▁ supported ▁ READ ▁ ONLY ... convert ▁ to ▁ LabelSST " ) ; }
public URI normalize ( ) { if ( opaque ) { return this ; } String normalizedPath = normalize ( path , false ) ; if ( path . equals ( normalizedPath ) ) { return this ; } URI result = duplicate ( ) ; result . path = normalizedPath ; result . setSchemeSpecificPart ( ) ; return result ; }
public FreeRefFunction findUserDefinedFunction ( String functionName ) { return _udfFinder . findFunction ( functionName ) ; }
public UpdateGatewayResponseResult updateGatewayResponse ( UpdateGatewayResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateGatewayResponse ( request ) ; }
public GetOperationDetailResult getOperationDetail ( GetOperationDetailRequest request ) { request = beforeClientExecution ( request ) ; return executeGetOperationDetail ( request ) ; }
public String toString ( String field ) { StringBuilder buffer = new StringBuilder ( ) ; if ( ! getField ( ) . equals ( field ) ) { buffer . append ( getField ( ) ) ; buffer . append ( " : " ) ; } buffer . append ( term . text ( ) ) ; return buffer . toString ( ) ; }
public NameXPtg getNameXPtg ( String name , UDFFinder udf ) { return getNameXPtg ( name , - 1 , udf ) ; }
public String getCharsetName ( ) { return charsetName ; }
public DescribeWebsiteCertificateAuthorityResult describeWebsiteCertificateAuthority ( DescribeWebsiteCertificateAuthorityRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWebsiteCertificateAuthority ( request ) ; }
static public double ppmt ( double r , int per , int nper , double pv , double fv ) { return pmt ( r , nper , pv , fv ) - ipmt ( r , per , nper , pv , fv ) ; }
public ShortBuffer put ( int index , short c ) { throw new ReadOnlyBufferException ( ) ; }
public void writeBytes ( String value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeBytes ( value ) ; }
public LinkTable ( int numberOfSheets , WorkbookRecordList workbookRecordList ) { _workbookRecordList = workbookRecordList ; _definedNames = new ArrayList <> ( ) ; _externalBookBlocks = new ExternalBookBlock [ ] { new ExternalBookBlock ( numberOfSheets ) , } ; _externSheetRecord = new ExternSheetRecord ( ) ; _recordCount = 2 ; SupBookRecord supbook = _externalBookBlocks [ 0 ] . getExternalBookRecord ( ) ; int idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; if ( idx < 0 ) { throw new RuntimeException ( " CountryRecord ▁ not ▁ found " ) ; } _workbookRecordList . add ( idx + 1 , _externSheetRecord ) ; _workbookRecordList . add ( idx + 1 , supbook ) ; }
public void remove ( ) { throw new UnsupportedOperationException ( ) ; }
public static int [ ] grow ( int [ ] array ) { return grow ( array , 1 + array . length ) ; }
public void addAll ( T [ ] src , int srcIdx , int srcCnt ) { while ( 0 < srcCnt ) { int i = tailBlkIdx ; int n = Math . min ( srcCnt , BLOCK_SIZE - i ) ; if ( n == 0 ) { add ( src [ srcIdx ++ ] ) ; srcCnt -- ; continue ; } System . arraycopy ( src , srcIdx , tailBlock , i , n ) ; tailBlkIdx += n ; size += n ; srcIdx += n ; srcCnt -= n ; } }
public RenewDomainResult renewDomain ( RenewDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeRenewDomain ( request ) ; }
public static boolean isInRange ( int i ) { return i >= MIN_VALUE && i <= MAX_VALUE ; }
public AddApplicationInputResult addApplicationInput ( AddApplicationInputRequest request ) { request = beforeClientExecution ( request ) ; return executeAddApplicationInput ( request ) ; }
public Request < DeletePublicKeyRequest > marshall ( DeletePublicKeyRequest deletePublicKeyRequest ) { if ( deletePublicKeyRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( ... ) " ) ; } Request < DeletePublicKeyRequest > request = new DefaultRequest < DeletePublicKeyRequest > ( deletePublicKeyRequest , " AmazonCloudFront " ) ; request . setHttpMethod ( HttpMethodName . DELETE ) ; if ( deletePublicKeyRequest . getIfMatch ( ) != null ) { request . addHeader ( " If - Match " , StringUtils . fromString ( deletePublicKeyRequest . getIfMatch ( ) ) ) ; } String uriResourcePath = " / 2019 - 03 - 26 / public - key / { Id } " ; uriResourcePath = com . amazonaws . transform . PathMarshallers . NON_GREEDY . marshall ( uriResourcePath , " Id " , deletePublicKeyRequest . getId ( ) ) ; request . setResourcePath ( uriResourcePath ) ; return request ; }
public boolean matches ( ParseTree tree ) { return matcher . match ( tree , this ) . succeeded ( ) ; }
public CreateDetectorResult createDetector ( CreateDetectorRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDetector ( request ) ; }
public boolean equals ( Object other ) { if ( other instanceof IndexCommit ) { IndexCommit otherCommit = ( IndexCommit ) other ; return otherCommit . getDirectory ( ) == getDirectory ( ) && otherCommit . getGeneration ( ) == getGeneration ( ) ; } else { return false ; } }
public void yypushback ( int number ) { if ( number > yylength ( ) ) zzScanError ( ZZ_PUSHBACK_2BIG ) ; zzMarkedPos -= number ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { return fixed ( arg0 , arg1 , BoolEval . FALSE , srcRowIndex , srcColumnIndex ) ; }
public RevisionSyntaxException ( String message , String revstr ) { super ( message ) ; this . revstr = revstr ; }
public void reset ( ) throws IOException { synchronized ( lock ) { super . reset ( ) ; lineNumber = markedLineNumber ; lastWasCR = markedLastWasCR ; } }
public QueryParser ( CharStream stream ) { token_source = new QueryParserTokenManager ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public Float floatValue ( String key ) { String value = responseMap . get ( key ) ; if ( null == value || 0 == value . length ( ) ) { return null ; } return Float . valueOf ( responseMap . get ( key ) ) ; }
public ModifyClusterResult modifyCluster ( ModifyClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyCluster ( request ) ; }
public DescribeSolutionResult describeSolution ( DescribeSolutionRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSolution ( request ) ; }
public BootstrapActionConfig build ( ) { return new BootstrapActionConfig ( ) . withName ( " Configure ▁ Hadoop " ) . withScriptBootstrapAction ( new ScriptBootstrapActionConfig ( ) . withPath ( " s3 : " ) . withArgs ( args ) ) ; }
public void append ( String name , RevCommit commit ) { append ( name , GITLINK , commit ) ; }
public int read ( ) { if ( ptr == data . length ) return - 1 ; return data [ ptr ++ ] & 0xff ; }
public void setOutputUnigramsIfNoShingles ( boolean outputUnigramsIfNoShingles ) { this . outputUnigramsIfNoShingles = outputUnigramsIfNoShingles ; }
public RevFilter clone ( ) { return this ; }
public void updateFormulasAfterRowShift ( FormulaShifter shifter , int currentExternSheetIndex ) { for ( int i = 0 ; i < records . length ; i ++ ) { CellValueRecordInterface [ ] rowCells = records [ i ] ; if ( rowCells == null ) { continue ; } for ( int j = 0 ; j < rowCells . length ; j ++ ) { CellValueRecordInterface cell = rowCells [ j ] ; if ( cell instanceof FormulaRecordAggregate ) { FormulaRecordAggregate fra = ( FormulaRecordAggregate ) cell ; Ptg [ ] ptgs = fra . getFormulaTokens ( ) ; Ptg [ ] ptgs2 = ( ( FormulaRecordAggregate ) cell ) . getFormulaRecord ( ) . getParsedExpression ( ) ; if ( shifter . adjustFormula ( ptgs , currentExternSheetIndex ) ) { fra . setParsedExpression ( ptgs ) ; } } } } }
public UpdateGroupRequest ( String groupName ) { setGroupName ( groupName ) ; }
public ListBrokersResult listBrokers ( ListBrokersRequest request ) { request = beforeClientExecution ( request ) ; return executeListBrokers ( request ) ; }
public final FormulaCellCacheEntry [ ] getConsumingCells ( ) { return _consumingCells . toArray ( ) ; }
public int cardinality ( ) { return cardinality ; }
public static final WeightedTerm [ ] getTerms ( Query query , boolean prohibited ) { return getTerms ( query , prohibited , null ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getColWidth ( ) ) ; }
public FieldsConsumer fieldsConsumer ( SegmentWriteState state ) throws IOException { PostingsWriterBase postingsWriter = new Lucene84PostingsWriter ( state ) ; boolean success = false ; try { FieldsConsumer ret = new FSTTermsWriter ( state , postingsWriter ) ; success = true ; return ret ; } finally { if ( ! success ) { IOUtils . closeWhileHandlingException ( postingsWriter ) ; } } }
public int getThumbOffset ( ) { return mThumbOffset ; }
public GetApnsChannelResult getApnsChannel ( GetApnsChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApnsChannel ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( null == obj || getClass ( ) != obj . getClass ( ) ) return false ; NGramDistance o = ( NGramDistance ) obj ; return o . n == this . n ; }
public GetDomainDetailResult getDomainDetail ( GetDomainDetailRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDomainDetail ( request ) ; }
public UpdateConfigurationSetReputationMetricsEnabledResult updateConfigurationSetReputationMetricsEnabled ( UpdateConfigurationSetReputationMetricsEnabledRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateConfigurationSetReputationMetricsEnabled ( request ) ; }
public PackedDataInput ( DataInput in ) { this . in = in ; skipToNextByte ( ) ; }
public AssociateQualificationWithWorkerResult associateQualificationWithWorker ( AssociateQualificationWithWorkerRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateQualificationWithWorker ( request ) ; }
public String toString ( ) { return " arc = " + fstArc + " ▁ state = " + fsaState ; }
public void signalWorkflowExecution ( SignalWorkflowExecutionRequest request ) { request = beforeClientExecution ( request ) ; executeSignalWorkflowExecution ( request ) ; }
public String getTokenName ( int t ) { if ( t == Token . EOF ) { return " EOF " ; } Vocabulary vocabulary = parser != null ? parser . getVocabulary ( ) : VocabularyImpl . EMPTY_VOCABULARY ; String displayName = vocabulary . getDisplayName ( t ) ; if ( displayName . equals ( Integer . toString ( t ) ) ) { return displayName ; } return displayName + " < " + t + " > " ; }
public CJKWidthFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public GetHLSStreamingSessionURLResult getHLSStreamingSessionURL ( GetHLSStreamingSessionURLRequest request ) { request = beforeClientExecution ( request ) ; return executeGetHLSStreamingSessionURL ( request ) ; }
public boolean updateFormulasAfterCellShift ( FormulaShifter shifter , int currentExternSheetIx ) { CellRangeAddress [ ] cellRanges = header . getCellRanges ( ) ; boolean changed = false ; List < CellRangeAddress > temp = new ArrayList <> ( ) ; for ( CellRangeAddress craOld : cellRanges ) { CellRangeAddress craNew = BaseRowColShifter . shiftRange ( shifter , craOld , currentExternSheetIx ) ; if ( craNew == null ) { changed = true ; continue ; } temp . add ( craNew ) ; if ( craNew != craOld ) { changed = true ; } } if ( changed ) { int nRanges = temp . size ( ) ; if ( nRanges == 0 ) { return false ; } CellRangeAddress [ ] newRanges = new CellRangeAddress [ nRanges ] ; temp . toArray ( newRanges ) ; header . setCellRanges ( newRanges ) ; } for ( CFRuleBase rule : rules ) { Ptg [ ] ptgs ; ptgs = rule . getParsedExpression1 ( ) ; if ( ptgs != null && shifter . adjustFormula ( ptgs , currentExternSheetIx ) ) { rule . setParsedExpression1 ( ptgs ) ; } ptgs = rule . getParsedExpression2 ( ) ; if ( ptgs != null && shifter . adjustFormula ( ptgs , currentExternSheetIx ) ) { rule . setParsedExpression2 ( ptgs ) ; } if ( rule instanceof CFRule12Record ) { CFRule12Record rule12 = ( CFRule12Record ) rule ; ptgs = rule12. getParsedExpressionScale ( ) ; if ( ptgs != null && shifter . adjustFormula ( ptgs , currentExternSheetIx ) ) { rule12. setParsedExpressionScale ( ptgs ) ; } } } return true ; }
public int keyAt ( int index ) { if ( mGarbage ) { gc ( ) ; } return mKeys [ index ] ; }
public JapaneseKatakanaStemFilterFactory ( Map < String , String > args ) { super ( args ) ; minimumLength = getInt ( args , MINIMUM_LENGTH_PARAM , JapaneseKatakanaStemFilter . DEFAULT_MINIMUM_LENGTH ) ; if ( minimumLength < 2 ) { throw new IllegalArgumentException ( " Illegal ▁ " + MINIMUM_LENGTH_PARAM + " ▁ " + minimumLength + " ▁ ( must ▁ be ▁ 2 ▁ or ▁ greater ) " ) ; } if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static void byteArray ( StringBuilder buffer , byte [ ] bytes ) { for ( int i = 0 ; i < bytes . length ; i ++ ) { buffer . append ( " b [ " ) . append ( i ) . append ( " ] = " ) . append ( bytes [ i ] ) ; if ( i < bytes . length - 1 ) { buffer . append ( ' , ' ) ; } } }
public int available ( ) { return _in . available ( ) ; }
public DeleteDatasetGroupResult deleteDatasetGroup ( DeleteDatasetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDatasetGroup ( request ) ; }
public DescribeBuildResult describeBuild ( DescribeBuildRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeBuild ( request ) ; }
public E peekLast ( ) { Link < E > last = voidLink . previous ; return ( last == voidLink ) ? null : last . data ; }
public long get ( long index ) { assert index >= 0 && index < valueCount ; final int block = ( int ) ( index >>> blockShift ) ; final int idx = ( int ) ( index & blockMask ) ; return expected ( minValues [ block ] , averages [ block ] , idx ) + subReaders [ block ] . get ( idx ) ; }
public DescribeVpnGatewaysResult describeVpnGateways ( ) { return describeVpnGateways ( new DescribeVpnGatewaysRequest ( ) ) ; }
public Iterator < E > iterator ( ) { return backingMap . keySet ( ) . iterator ( ) ; }
public void parseLine ( DocData docData , String line ) { int n = 0 ; int k1 = 0 ; int k2 ; while ( ( k2 = line . indexOf ( WriteLineDocTask . SEP , k1 ) ) >= 0 ) { if ( n >= header . length ) { throw new RuntimeException ( " input ▁ line ▁ has ▁ invalid ▁ format : ▁ " + ( n + 1 ) + " ▁ fields ▁ instead ▁ of ▁ " + header . length + " ▁ :: ▁ [ " + line + " ] " ) ; } setDocDataField ( docData , n , line . substring ( k1 , k2 ) ) ; ++ n ; k1 = k2 + 1 ; } if ( n != header . length - 1 ) { throw new RuntimeException ( " input ▁ line ▁ has ▁ invalid ▁ format : ▁ " + ( n + 1 ) + " ▁ fields ▁ instead ▁ of ▁ " + header . length + " ▁ :: ▁ [ " + line + " ] " ) ; } setDocDataField ( docData , n , line . substring ( k1 ) ) ; }
public long getTotalLLLookaheadOps ( ) { DecisionInfo [ ] decisions = atnSimulator . getDecisionInfo ( ) ; long k = 0 ; for ( int i = 0 ; i < decisions . length ; i ++ ) { k += decisions [ i ] . LL_TotalLook ; } return k ; }
public static boolean matches ( String regularExpression , CharSequence input ) { return new Matcher ( new Pattern ( regularExpression , 0 ) , input ) . matches ( ) ; }
public HSSFChildAnchor ( int dx1 , int dy1 , int dx2 , int dy2 ) { super ( Math . min ( dx1 , dx2 ) , Math . min ( dy1 , dy2 ) , Math . max ( dx1 , dx2 ) , Math . max ( dy1 , dy2 ) ) ; if ( dx1 > dx2 ) { _isHorizontallyFlipped = true ; } if ( dy1 > dy2 ) { _isVerticallyFlipped = true ; } }
public final CharBuffer put ( String str ) { return put ( str , 0 , str . length ( ) ) ; }
public StartExportTaskResult startExportTask ( StartExportTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeStartExportTask ( request ) ; }
public UpdateUserHierarchyResult updateUserHierarchy ( UpdateUserHierarchyRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateUserHierarchy ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ SERIESTEXT ] \ n " ) ; sb . append ( " ▁ ▁ . id ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( getId ( ) ) ) . append ( ' \ n ' ) ; sb . append ( " ▁ ▁ . textLen = " ) . append ( field_4_text . length ( ) ) . append ( ' \ n ' ) ; sb . append ( " ▁ ▁ . is16bit = " ) . append ( is16bit ) . append ( ' \ n ' ) ; sb . append ( " ▁ ▁ . text ▁ ▁ ▁ = " ) . append ( " ▁ ( " ) . append ( getText ( ) ) . append ( " ▁ ) " ) . append ( ' \ n ' ) ; sb . append ( " [ / SERIESTEXT ] \ n " ) ; return sb . toString ( ) ; }
public int put ( Object key , int value ) { Object _key = key ; int _value = value ; int index = findIndex ( _key , keys ) ; if ( keys [ index ] != _key ) { if ( ++ size > threshold ) { rehash ( ) ; index = findIndex ( _key , keys ) ; } keys [ index ] = _key ; values [ index ] = - 1 ; } int result = values [ index ] ; values [ index ] = _value ; return result ; }
public TagCommand setMessage ( String message ) { checkCallable ( ) ; this . message = message ; return this ; }
public DeleteIndexFieldResult deleteIndexField ( DeleteIndexFieldRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteIndexField ( request ) ; }
public AbbreviatedObjectId getAbbreviatedObjectId ( ) { return missing ; }
public ParserRuleContext getInvokingContext ( int ruleIndex ) { ParserRuleContext p = _ctx ; while ( p != null ) { if ( p . getRuleIndex ( ) == ruleIndex ) return p ; p = ( ParserRuleContext ) p . parent ; } return null ; }
public boolean containsCell ( int rowIndex , int columnIndex ) { if ( rowIndex > _lastDefinedRow ) return true ; for ( int i = _rectangleGroups . size ( ) - 1 ; i >= 0 ; i -- ) { BlankCellRectangleGroup bcrg = _rectangleGroups . get ( i ) ; if ( bcrg . containsCell ( rowIndex , columnIndex ) ) { return true ; } } if ( _currentRectangleGroup != null && _currentRectangleGroup . containsCell ( rowIndex , columnIndex ) ) { return true ; } if ( _currentRowIndex != - 1 && _currentRowIndex == rowIndex ) { if ( _firstColumnIndex <= columnIndex && columnIndex <= _lastColumnIndex ) { return true ; } } return false ; }
public DisassociateS3ResourcesResult disassociateS3Resources ( DisassociateS3ResourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateS3Resources ( request ) ; }
public FontRecord createNewFont ( ) { FontRecord rec = createFont ( ) ; records . add ( records . getFontpos ( ) + 1 , rec ) ; records . setFontpos ( records . getFontpos ( ) + 1 ) ; numfonts ++ ; return rec ; }
public boolean equals ( Object o ) { return o instanceof SpanishStemmer ; }
public final boolean matches ( char c ) { return Character . isLowerCase ( c ) ; }
public ByteOrder order ( ) { return byteBuffer . order ( ) ; }
public DeleteVolumeRequest ( String volumeId ) { setVolumeId ( volumeId ) ; }
public LinkedDataRecord getDataSecondaryCategoryLabels ( ) { return dataSecondaryCategoryLabels ; }
public int depth ( ) { int n = 0 ; RuleContext p = this ; while ( p != null ) { p = p . parent ; n ++ ; } return n ; }
public PersonIdent getTagger ( ) { return tagger ; }
public ObjectId insert ( int objectType , long length , InputStream in ) throws IOException { throw new UnsupportedOperationException ( ) ; }
public Automaton convert ( Automaton utf32 ) { if ( utf32. getNumStates ( ) == 0 ) { return utf32 ; } int [ ] map = new int [ utf32. getNumStates ( ) ] ; Arrays . fill ( map , - 1 ) ; List < Integer > pending = new ArrayList <> ( ) ; int utf32State = 0 ; pending . add ( utf32State ) ; utf8 = new Automaton . Builder ( ) ; int utf8State = utf8. createState ( ) ; utf8. setAccept ( utf8State , utf32. isAccept ( utf32State ) ) ; map [ utf32State ] = utf8State ; Transition scratch = new Transition ( ) ; while ( pending . size ( ) != 0 ) { utf32State = pending . remove ( pending . size ( ) - 1 ) ; utf8State = map [ utf32State ] ; assert utf8State != - 1 ; int numTransitions = utf32. getNumTransitions ( utf32State ) ; utf32. initTransition ( utf32State , scratch ) ; for ( int i = 0 ; i < numTransitions ; i ++ ) { utf32. getNextTransition ( scratch ) ; int destUTF32 = scratch . dest ; int destUTF8 = map [ destUTF32 ] ; if ( destUTF8 == - 1 ) { destUTF8 = utf8. createState ( ) ; utf8. setAccept ( destUTF8 , utf32. isAccept ( destUTF32 ) ) ; map [ destUTF32 ] = destUTF8 ; pending . add ( destUTF32 ) ; } convertOneEdge ( utf8State , destUTF8 , scratch . min , scratch . max ) ; } } return utf8. finish ( ) ; }
public static String [ ] listServices ( ) throws RemoteException { return null ; }
public void startWorkers ( int count ) { workers . addAndGet ( count ) ; }
public FacetEntry ( BytesRef value , int count ) { this . value = value ; this . count = count ; }
public String toString ( ) { String inv = invert ? " ! " : " " ; return getClass ( ) . getSimpleName ( ) + " [ " + inv + nodeName + " ] " ; }
public RemoveNoteCommand setNotesRef ( String notesRef ) { checkCallable ( ) ; this . notesRef = notesRef ; return this ; }
final public SrndQuery FieldsQuery ( ) throws ParseException { SrndQuery q ; ArrayList < String > fieldNames ; fieldNames = OptionalFields ( ) ; q = OrQuery ( ) ; { if ( true ) return ( fieldNames == null ) ? q : getFieldsQuery ( q , fieldNames ) ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public DescribeParametersResult describeParameters ( DescribeParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeParameters ( request ) ; }
public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( new MessageImpl ( QueryParserMessages . INVALID_SYNTAX , initialise ( currentTokenVal , expectedTokenSequencesVal , tokenImageVal ) ) ) ; this . currentToken = currentTokenVal ; this . expectedTokenSequences = expectedTokenSequencesVal ; this . tokenImage = tokenImageVal ; }
public ListHumanTaskUisResult listHumanTaskUis ( ListHumanTaskUisRequest request ) { request = beforeClientExecution ( request ) ; return executeListHumanTaskUis ( request ) ; }
public static ShortBuffer wrap ( short [ ] array ) { return wrap ( array , 0 , array . length ) ; }
public Parser ( boolean dedup , Analyzer analyzer ) { super ( dedup ) ; this . analyzer = analyzer ; }
public ObjectProtectRecord ( RecordInputStream in ) { field_1_protect = in . readShort ( ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeInt ( _reserved0Int ) ; out . writeShort ( _reserved1Short ) ; out . writeByte ( _reserved2Byte ) ; }
public int size ( ) { if ( mGarbage ) { gc ( ) ; } return mSize ; }
public BigDecimal getFractionalPart ( ) { return new BigDecimal ( _fractionalPart ) . divide ( BD_2_POW_24 ) ; }
public AttachLoadBalancerTlsCertificateResult attachLoadBalancerTlsCertificate ( AttachLoadBalancerTlsCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachLoadBalancerTlsCertificate ( request ) ; }
public final int step ( int state , int c ) { assert c < alphabetSize ; if ( c >= classmap . length ) { return transitions [ state * points . length + getCharClass ( c ) ] ; } else { return transitions [ state * points . length + classmap [ c ] ] ; } }
public UpdateVoiceChannelResult updateVoiceChannel ( UpdateVoiceChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateVoiceChannel ( request ) ; }
public void onPreReceive ( ReceivePack rp , Collection < ReceiveCommand > commands ) { for ( int i = 0 ; i < count ; i ++ ) hooks [ i ] . onPreReceive ( rp , commands ) ; }
public ValueEval evaluate ( ValueEval [ ] args , OperationEvaluationContext ec ) { if ( args . length != 1 ) { return ErrorEval . VALUE_INVALID ; } return evaluate ( ec . getRowIndex ( ) , ec . getColumnIndex ( ) , args [ 0 ] ) ; }
public DescribeSpotDatafeedSubscriptionResult describeSpotDatafeedSubscription ( ) { return describeSpotDatafeedSubscription ( new DescribeSpotDatafeedSubscriptionRequest ( ) ) ; }
public int getTimeZoneOffset ( ) { return tzOffset ; }
public void close ( ) { allocationSite = null ; }
public AssociateClientVpnTargetNetworkResult associateClientVpnTargetNetwork ( AssociateClientVpnTargetNetworkRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateClientVpnTargetNetwork ( request ) ; }
public ListEnvironmentsResult listEnvironments ( ListEnvironmentsRequest request ) { request = beforeClientExecution ( request ) ; return executeListEnvironments ( request ) ; }
public String toFormulaString ( ) { if ( semiVolatile . isSet ( _options ) ) { return " ATTR ( semiVolatile ) " ; } if ( optiIf . isSet ( _options ) ) { return " IF " ; } if ( optiChoose . isSet ( _options ) ) { return " CHOOSE " ; } if ( optiSkip . isSet ( _options ) ) { return " " ; } if ( optiSum . isSet ( _options ) ) { return " SUM " ; } if ( baxcel . isSet ( _options ) ) { return " ATTR ( baxcel ) " ; } if ( space . isSet ( _options ) ) { return " " ; } return " UNKNOWN ▁ ATTRIBUTE " ; }
public int capacity ( ) { return value . length ; }
public synchronized void setMax ( int max ) { if ( max < 0 ) { max = 0 ; } if ( max != mMax ) { mMax = max ; postInvalidate ( ) ; if ( mProgress > max ) { mProgress = max ; } refreshProgress ( R . id . progress , mProgress , false ) ; } }
public GetVaultNotificationsRequest ( String accountId , String vaultName ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; }
public FloatBuffer asReadOnlyBuffer ( ) { return ReadOnlyFloatArrayBuffer . copy ( this , mark ) ; }
public MissingResourceException ( String detailMessage , String className , String resourceName ) { super ( detailMessage ) ; this . className = className ; key = resourceName ; }
public ValueEval getRelativeValue ( int relativeRowIndex , int relativeColumnIndex ) { return getRelativeValue ( getFirstSheetIndex ( ) , relativeRowIndex , relativeColumnIndex ) ; }
public Matcher matcher ( CharSequence input ) { return new Matcher ( this , input ) ; }
public ListRoomMembershipsResult listRoomMemberships ( ListRoomMembershipsRequest request ) { request = beforeClientExecution ( request ) ; return executeListRoomMemberships ( request ) ; }
public StringBuilder insert ( int offset , String str ) { insert0 ( offset , str ) ; return this ; }
public void registerActivityType ( RegisterActivityTypeRequest request ) { request = beforeClientExecution ( request ) ; executeRegisterActivityType ( request ) ; }
public DescribeSuggestersResult describeSuggesters ( DescribeSuggestersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSuggesters ( request ) ; }
public boolean acceptRow ( int rowIndex , int firstColumnIndex , int lastColumnIndex ) { if ( firstColumnIndex != _firstColumnIndex ) { return false ; } if ( lastColumnIndex != _lastColumnIndex ) { return false ; } if ( rowIndex != _lastRowIndex + 1 ) { return false ; } _lastRowIndex = rowIndex ; return true ; }
public boolean equals ( Object o ) { return o instanceof FinnishStemmer ; }
public StopDeploymentResult stopDeployment ( StopDeploymentRequest request ) { request = beforeClientExecution ( request ) ; return executeStopDeployment ( request ) ; }
public ListGitHubAccountTokenNamesResult listGitHubAccountTokenNames ( ListGitHubAccountTokenNamesRequest request ) { request = beforeClientExecution ( request ) ; return executeListGitHubAccountTokenNames ( request ) ; }
public CreateBackupResult createBackup ( CreateBackupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateBackup ( request ) ; }
public ModifyTransitGatewayVpcAttachmentResult modifyTransitGatewayVpcAttachment ( ModifyTransitGatewayVpcAttachmentRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyTransitGatewayVpcAttachment ( request ) ; }
public RejectSkillResult rejectSkill ( RejectSkillRequest request ) { request = beforeClientExecution ( request ) ; return executeRejectSkill ( request ) ; }
public String getHexString ( ) { return getGnumericPart ( _red ) + " : " + getGnumericPart ( _green ) + " : " + getGnumericPart ( _blue ) ; }
public String toString ( ) { return " < prefixWildcard ▁ field = ' " ▁ + ▁ this . field ▁ + ▁ " ' ▁ term = ' " ▁ + ▁ this . text + ▁ " ' /> " ; }
public GetOSSImageAccessRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " GetOSSImageAccess " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DeleteFleetsResult deleteFleets ( DeleteFleetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFleets ( request ) ; }
public void set ( E object ) { if ( expectedModCount == modCount ) { try { AbstractList . this . set ( lastPosition , object ) ; } catch ( IndexOutOfBoundsException e ) { throw new IllegalStateException ( ) ; } } else { throw new ConcurrentModificationException ( ) ; } }
public InvalidationBatch ( Paths paths , String callerReference ) { setPaths ( paths ) ; setCallerReference ( callerReference ) ; }
public int getPrecision ( ) { return p ; }
public boolean addSubRecord ( SubRecord o ) { return subrecords . add ( o ) ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; int pos = offset ; LittleEndian . putShort ( data , pos , getOptions ( ) ) ; pos += 2 ; LittleEndian . putShort ( data , pos , getRecordId ( ) ) ; pos += 2 ; LittleEndian . putInt ( data , pos , getRecordSize ( ) - 8 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_1_dx1 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_2_dy1 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_3_dx2 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_4_dy2 ) ; pos += 4 ; listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; }
public static final ObjectId fromRaw ( int [ ] is ) { return fromRaw ( is , 0 ) ; }
public DisassociateIpGroupsResult disassociateIpGroups ( DisassociateIpGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateIpGroups ( request ) ; }
public static void mkdirs ( File d , boolean skipExisting ) throws IOException { if ( ! d . mkdirs ( ) ) { if ( skipExisting && d . isDirectory ( ) ) return ; throw new IOException ( MessageFormat . format ( JGitText . get ( ) . mkDirsFailed , d . getAbsolutePath ( ) ) ) ; } }
public GetImageManifestRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetImageManifest " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / tags / [ Tag ] / manifest " ) ; setMethod ( MethodType . GET ) ; }
public ListIdentitiesResult listIdentities ( ListIdentitiesRequest request ) { request = beforeClientExecution ( request ) ; return executeListIdentities ( request ) ; }
public final String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + _sfr . getRange ( ) + " ] " ; }
public byte [ ] toByteArray ( ) { byte [ ] result = new byte [ LittleEndianConsts . INT_SIZE * 2 + _value . length ] ; LittleEndianByteArrayOutputStream bos = new LittleEndianByteArrayOutputStream ( result , 0 ) ; try { bos . writeInt ( LittleEndianConsts . INT_SIZE + _value . length ) ; bos . writeInt ( _format ) ; bos . write ( _value ) ; return result ; } finally { IOUtils . closeQuietly ( bos ) ; } }
public void update ( byte [ ] b , int off , int len ) { if ( len >= buffer . length ) { flush ( ) ; in . update ( b , off , len ) ; } else { if ( upto + len > buffer . length ) { flush ( ) ; } System . arraycopy ( b , off , buffer , upto , len ) ; upto += len ; } }
public HSSFPicture createPicture ( ClientAnchor anchor , int pictureIndex ) { return createPicture ( ( HSSFClientAnchor ) anchor , pictureIndex ) ; }
public String getAccessKeySecret ( ) { return legacyCredential . getAccessSecret ( ) ; }
public int compareTo ( ByteBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; byte thisByte , otherByte ; while ( compareRemaining > 0 ) { thisByte = get ( thisPos ) ; otherByte = otherBuffer . get ( otherPos ) ; if ( thisByte != otherByte ) { return thisByte < otherByte ? - 1 : 1 ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; }
public CreateResolverEndpointResult createResolverEndpoint ( CreateResolverEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateResolverEndpoint ( request ) ; }
public HunspellStemFilterFactory ( Map < String , String > args ) { super ( args ) ; dictionaryFiles = require ( args , PARAM_DICTIONARY ) ; affixFile = get ( args , PARAM_AFFIX ) ; ignoreCase = getBoolean ( args , PARAM_IGNORE_CASE , false ) ; longestOnly = getBoolean ( args , PARAM_LONGEST_ONLY , false ) ; getBoolean ( args , " strictAffixParsing " , true ) ; getInt ( args , " recursionCap " , 0 ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { final byte block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( block >>> 4 ) & 15 ; values [ valuesOffset ++ ] = block & 15 ; } }
public CancelSpotInstanceRequestsResult cancelSpotInstanceRequests ( CancelSpotInstanceRequestsRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelSpotInstanceRequests ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_print_headers ) ; }
public void copyTo ( char [ ] tmp , StringBuilder w ) { toHexCharArray ( tmp ) ; w . append ( tmp , 0 , Constants . OBJECT_ID_STRING_LENGTH ) ; }
public DeleteVaultAccessPolicyResult deleteVaultAccessPolicy ( DeleteVaultAccessPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVaultAccessPolicy ( request ) ; }
public SpanOrBuilder ( SpanQueryBuilder factory ) { this . factory = factory ; }
public DescribeConnectionsOnInterconnectResult describeConnectionsOnInterconnect ( DescribeConnectionsOnInterconnectRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeConnectionsOnInterconnect ( request ) ; }
public MultiBoolFunction ( List < ValueSource > sources ) { this . sources = sources ; }
public TokenStream create ( TokenStream input ) { return new ICUTransformFilter ( input , transliterator ) ; }
public void extendA ( ) { endA ++ ; }
public DeleteReceiptRuleSetResult deleteReceiptRuleSet ( DeleteReceiptRuleSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteReceiptRuleSet ( request ) ; }
public PutRetentionPolicyRequest ( String logGroupName , Integer retentionInDays ) { setLogGroupName ( logGroupName ) ; setRetentionInDays ( retentionInDays ) ; }
public void insertRow ( RowRecord row ) { _rowRecords . put ( Integer . valueOf ( row . getRowNumber ( ) ) , row ) ; _rowRecordValues = null ; if ( ( row . getRowNumber ( ) < _firstrow ) || ( _firstrow == - 1 ) ) { _firstrow = row . getRowNumber ( ) ; } if ( ( row . getRowNumber ( ) > _lastrow ) || ( _lastrow == - 1 ) ) { _lastrow = row . getRowNumber ( ) ; } }
public String toString ( ) { return " TermState " ; }
public LsRemoteCommand setHeads ( boolean heads ) { this . heads = heads ; return this ; }
public void remove ( String key ) { deleteNode ( getNode ( key . trim ( ) . toLowerCase ( locale ) ) ) ; }
public Object [ ] [ ] getTokenArrayValues ( ) { if ( _arrayValues == null ) { throw new IllegalStateException ( " array ▁ values ▁ not ▁ read ▁ yet " ) ; } Object [ ] [ ] result = new Object [ _nRows ] [ _nColumns ] ; for ( int r = 0 ; r < _nRows ; r ++ ) { Object [ ] rowData = result [ r ] ; for ( int c = 0 ; c < _nColumns ; c ++ ) { rowData [ c ] = _arrayValues [ getValueIndex ( c , r ) ] ; } } return result ; }
public PutIntegrationResponseResult putIntegrationResponse ( PutIntegrationResponseRequest request ) { request = beforeClientExecution ( request ) ; return executePutIntegrationResponse ( request ) ; }
public void write ( String str , int offset , int count ) throws IOException { synchronized ( lock ) { if ( count < 0 ) { throw new StringIndexOutOfBoundsException ( str , offset , count ) ; } if ( str == null ) { throw new NullPointerException ( " str ▁ == ▁ null " ) ; } if ( ( offset | count ) < 0 || offset > str . length ( ) - count ) { throw new StringIndexOutOfBoundsException ( str , offset , count ) ; } checkStatus ( ) ; CharBuffer chars = CharBuffer . wrap ( str , offset , count + offset ) ; convert ( chars ) ; } }
public String subscriptionId ( ) { return this . subscriptionId ; }
public HSSFPicture createPicture ( HSSFClientAnchor anchor , int pictureIndex ) { HSSFPicture shape = new HSSFPicture ( null , anchor ) ; shape . setPictureIndex ( pictureIndex ) ; addShape ( shape ) ; onCreate ( shape ) ; return shape ; }
public ReleaseStaticIpResult releaseStaticIp ( ReleaseStaticIpRequest request ) { request = beforeClientExecution ( request ) ; return executeReleaseStaticIp ( request ) ; }
public ListConfigurationSetsResult listConfigurationSets ( ListConfigurationSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListConfigurationSets ( request ) ; }
public UpdateRecordsResult updateRecords ( UpdateRecordsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRecords ( request ) ; }
public Token emit ( ) { Token t = _factory . create ( _tokenFactorySourcePair , _type , _text , _channel , _tokenStartCharIndex , getCharIndex ( ) - 1 , _tokenStartLine , _tokenStartCharPositionInLine ) ; emit ( t ) ; return t ; }
public synchronized IndexCommit snapshot ( ) throws IOException { if ( ! initCalled ) { throw new IllegalStateException ( " this ▁ instance ▁ is ▁ not ▁ being ▁ used ▁ by ▁ IndexWriter ; ▁ be ▁ sure ▁ to ▁ use ▁ the ▁ instance ▁ returned ▁ from ▁ writer . getConfig ( ) . getIndexDeletionPolicy ( ) " ) ; } if ( lastCommit == null ) { throw new IllegalStateException ( " No ▁ index ▁ commit ▁ to ▁ snapshot " ) ; } incRef ( lastCommit ) ; return lastCommit ; }
public void build ( InputIterator iter ) throws IOException { synchronized ( searcherMgrLock ) { if ( searcherMgr != null ) { searcherMgr . close ( ) ; searcherMgr = null ; } if ( writer != null ) { writer . close ( ) ; writer = null ; } boolean success = false ; try { writer = new IndexWriter ( dir , getIndexWriterConfig ( getGramAnalyzer ( ) , IndexWriterConfig . OpenMode . CREATE ) ) ; BytesRef text ; while ( ( text = iter . next ( ) ) != null ) { BytesRef payload ; if ( iter . hasPayloads ( ) ) { payload = iter . payload ( ) ; } else { payload = null ; } add ( text , iter . contexts ( ) , iter . weight ( ) , payload ) ; } if ( commitOnBuild || closeIndexWriterOnBuild ) { commit ( ) ; } searcherMgr = new SearcherManager ( writer , null ) ; success = true ; } finally { if ( success ) { if ( closeIndexWriterOnBuild ) { writer . close ( ) ; writer = null ; } } else { if ( writer != null ) { writer . rollback ( ) ; writer = null ; } } } } }
public ShortBuffer put ( ShortBuffer buf ) { throw new ReadOnlyBufferException ( ) ; }
public int stemSuffix ( char s [ ] , int len ) { for ( int i = 0 ; i < suffixes . length ; i ++ ) if ( endsWithCheckLength ( s , len , suffixes [ i ] ) ) len = deleteN ( s , len - suffixes [ i ] . length , len , suffixes [ i ] . length ) ; return len ; }
public SeriesListRecord ( RecordInputStream in ) { int nItems = in . readUShort ( ) ; short [ ] ss = new short [ nItems ] ; for ( int i = 0 ; i < nItems ; i ++ ) { ss [ i ] = in . readShort ( ) ; } field_1_seriesNumbers = ss ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof LexerModeAction ) ) { return false ; } return mode == ( ( LexerModeAction ) obj ) . mode ; }
public String getLineDelimiter ( ) { if ( size ( ) == 0 ) { return null ; } int e = getEnd ( 0 ) ; if ( content [ e - 1 ] != ' \ n ' ) { return null ; } if ( content . length > 1 && e > 1 && content [ e - 2 ] == ' \ r ' ) { return " \ r \ n " ; } return " \ n " ; }
public NormalisedDecimal roundUnits ( ) { long wholePart = _wholePart ; if ( _fractionalPart >= FRAC_HALF ) { wholePart ++ ; } int de = _relativeDecimalExponent ; if ( wholePart < MAX_REP_WHOLE_PART ) { return new NormalisedDecimal ( wholePart , 0 , de ) ; } return new NormalisedDecimal ( wholePart / 10 , 0 , de + 1 ) ; }
public PLSAggregate ( RecordStream rs ) { _pls = rs . getNext ( ) ; if ( rs . peekNextSid ( ) == ContinueRecord . sid ) { List < ContinueRecord > temp = new ArrayList <> ( ) ; while ( rs . peekNextSid ( ) == ContinueRecord . sid ) { temp . add ( ( ContinueRecord ) rs . getNext ( ) ) ; } _plsContinues = new ContinueRecord [ temp . size ( ) ] ; temp . toArray ( _plsContinues ) ; } else { _plsContinues = EMPTY_CONTINUE_RECORD_ARRAY ; } }
public AssociateDelegateToResourceResult associateDelegateToResource ( AssociateDelegateToResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateDelegateToResource ( request ) ; }
public static void setDefault ( CredentialsProvider p ) { defaultProvider = p ; }
public EscherProperty getEscherProperty ( int index ) { return properties . get ( index ) ; }
@ Override public void add ( int index , E object ) { synchronized ( CopyOnWriteArrayList . this ) { slice . checkPositionIndex ( index ) ; slice . checkConcurrentModification ( elements ) ; CopyOnWriteArrayList . this . add ( index + slice . from , object ) ; slice = new Slice ( elements , slice . from , slice . to + 1 ) ; } }
public static BitField getInstance ( int mask ) { BitField f = instances . get ( Integer . valueOf ( mask ) ) ; if ( f == null ) { f = new BitField ( mask ) ; instances . put ( Integer . valueOf ( mask ) , f ) ; } return f ; }
public boolean get ( int doc ) { final int reader = ReaderUtil . subIndex ( doc , starts ) ; assert reader != - 1 ; final Bits bits = subs [ reader ] ; if ( bits == null ) { return defaultValue ; } else { assert checkLength ( reader , doc ) ; return bits . get ( doc - starts [ reader ] ) ; } }
public DeleteFieldLevelEncryptionProfileResult deleteFieldLevelEncryptionProfile ( DeleteFieldLevelEncryptionProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFieldLevelEncryptionProfile ( request ) ; }
public EscherComplexProperty ( short id , byte [ ] complexData ) { this ( id , complexData == null ? 0 : complexData . length ) ; setComplexData ( complexData ) ; }
public TermVectorsReader clone ( ) { if ( in == null ) { throw new AlreadyClosedException ( " this ▁ TermVectorsReader ▁ is ▁ closed " ) ; } return new SimpleTextTermVectorsReader ( offsets , in . clone ( ) ) ; }
public static void fill ( short [ ] array , short value ) { for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = value ; } }
public final int getEndB ( ) { return endB ; }
public DescribeAutoMLJobResult describeAutoMLJob ( DescribeAutoMLJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAutoMLJob ( request ) ; }
public SelectionRecord ( int activeCellRow , int activeCellCol ) { field_1_pane = 3 ; field_2_row_active_cell = activeCellRow ; field_3_col_active_cell = activeCellCol ; field_4_active_cell_ref_index = 0 ; field_6_refs = new CellRangeAddress8Bit [ ] { new CellRangeAddress8Bit ( activeCellRow , activeCellRow , activeCellCol , activeCellCol ) , } ; }
public InvalidationBatch ( String callerReference ) { setCallerReference ( callerReference ) ; }
public int compareTo ( IndexCommit commit ) { if ( getDirectory ( ) != commit . getDirectory ( ) ) { throw new UnsupportedOperationException ( " cannot ▁ compare ▁ IndexCommits ▁ from ▁ different ▁ Directory ▁ instances " ) ; } long gen = getGeneration ( ) ; long comgen = commit . getGeneration ( ) ; return Long . compare ( gen , comgen ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getOptions ( ) ) ; out . writeShort ( getTopRow ( ) ) ; out . writeShort ( getLeftCol ( ) ) ; out . writeInt ( getHeaderColor ( ) ) ; out . writeShort ( getPageBreakZoom ( ) ) ; out . writeShort ( getNormalZoom ( ) ) ; out . writeInt ( getReserved ( ) ) ; }
public PhoneticFilter create ( TokenStream input ) { return new PhoneticFilter ( input , getEncoder ( ) , inject ) ; }
public StartMatchmakingResult startMatchmaking ( StartMatchmakingRequest request ) { request = beforeClientExecution ( request ) ; return executeStartMatchmaking ( request ) ; }
public CreateReusableDelegationSetResult createReusableDelegationSet ( CreateReusableDelegationSetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateReusableDelegationSet ( request ) ; }
public GC setProgressMonitor ( ProgressMonitor pm ) { this . pm = ( pm == null ) ? NullProgressMonitor . INSTANCE : pm ; return this ; }
public synchronized String getRegionId ( ) { return regionId ; }
public CreateVpcEndpointServiceConfigurationResult createVpcEndpointServiceConfiguration ( CreateVpcEndpointServiceConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVpcEndpointServiceConfiguration ( request ) ; }
public IndexableField getField ( FieldInfo fieldInfo ) { fieldNames . add ( fieldInfo . name ) ; List < LazyField > values = fields . get ( fieldInfo . number ) ; if ( null == values ) { values = new ArrayList <> ( ) ; fields . put ( fieldInfo . number , values ) ; } LazyField value = new LazyField ( fieldInfo . name , fieldInfo . number ) ; values . add ( value ) ; synchronized ( this ) { doc = null ; } return value ; }
public static int nextHighestPowerOfTwo ( int v ) { v -- ; v |= v >> 1 ; v |= v >> 2 ; v |= v >> 4 ; v |= v >> 8 ; v |= v >> 16 ; v ++ ; return v ; }
public boolean contains ( int x , int y ) { return isValid ( ) && x >= this . x && y >= this . y && x < ( this . x + this . w ) && y < ( this . y + this . h ) ; }
public int getFormat ( ) { return PACK_DELTA ; }
public Tag ( String key ) { setKey ( key ) ; }
public InactivatePhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " InactivatePhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DescribeEventSubscriptionsResult describeEventSubscriptions ( ) { return describeEventSubscriptions ( new DescribeEventSubscriptionsRequest ( ) ) ; }
public short get ( int index ) { checkIndex ( index ) ; return byteBuffer . getShort ( index * SizeOf . SHORT ) ; }
public boolean isExportAll ( ) { return exportAll ; }
public static void validateSecondArg ( int comparisonOperator , String paramValue ) { switch ( comparisonOperator ) { case BETWEEN : case NOT_BETWEEN : if ( paramValue == null ) { throw new IllegalArgumentException ( " expr2 ▁ must ▁ be ▁ supplied ▁ for ▁ ' between ' ▁ comparisons " ) ; } } }
public V next ( ) { V v = nextValue ; advance ( ) ; return v ; }
public UpdateSchemaResult updateSchema ( UpdateSchemaRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateSchema ( request ) ; }
public PortugueseMinimalStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public SeriesChartGroupIndexRecord ( RecordInputStream in ) { field_1_chartGroupIndex = in . readShort ( ) ; }
public ValueEval evaluate ( int srcCellRow , int srcCellCol ) { return ErrorEval . NA ; }
public E get ( int key ) { return get ( key , null ) ; }
public DescribeComponentConfigurationResult describeComponentConfiguration ( DescribeComponentConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeComponentConfiguration ( request ) ; }
public CellRangeAddressList copy ( ) { CellRangeAddressList result = new CellRangeAddressList ( ) ; int nItems = _list . size ( ) ; for ( int k = 0 ; k < nItems ; k ++ ) { CellRangeAddress region = _list . get ( k ) ; result . addCellRangeAddress ( region . copy ( ) ) ; } return result ; }
public DescribeClientVpnAuthorizationRulesResult describeClientVpnAuthorizationRules ( DescribeClientVpnAuthorizationRulesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClientVpnAuthorizationRules ( request ) ; }
public HSSFConditionalFormattingRule getRule ( int idx ) { CFRuleBase ruleRecord = cfAggregate . getRule ( idx ) ; return new HSSFConditionalFormattingRule ( sheet , ruleRecord ) ; }
public final Ref getAdvertisedRef ( String name ) { return advertisedRefs . get ( name ) ; }
public int getType ( ) { return delegate ( ) . getType ( ) ; }
public DeleteCustomVerificationEmailTemplateResult deleteCustomVerificationEmailTemplate ( DeleteCustomVerificationEmailTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCustomVerificationEmailTemplate ( request ) ; }
public void setRefLogMessage ( String msg ) { if ( msg == null ) disableRefLog ( ) ; elsedestination . setRefLogMessage ( msg , false ) ; }
public CreateVpcEndpointConnectionNotificationResult createVpcEndpointConnectionNotification ( CreateVpcEndpointConnectionNotificationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVpcEndpointConnectionNotification ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { int rnum ; if ( arg0 instanceof AreaEval ) { rnum = ( ( AreaEval ) arg0 ) . getFirstColumn ( ) ; } else if ( arg0 instanceof RefEval ) { rnum = ( ( RefEval ) arg0 ) . getColumn ( ) ; } else { return ErrorEval . VALUE_INVALID ; } return new NumberEval ( rnum + 1 ) ; }
public CompleteMultipartUploadRequest ( String accountId , String vaultName , String uploadId , String archiveSize , String checksum ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; setUploadId ( uploadId ) ; setArchiveSize ( archiveSize ) ; setChecksum ( checksum ) ; }
public void clearRect ( int x , int y , int width , int height ) { Color color = foreground ; setColor ( background ) ; fillRect ( x , y , width , height ) ; setColor ( color ) ; }
public String getRawFragment ( ) { return fragment ; }
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( int i = 0 ; i < count ; i ++ ) { if ( i > 0 ) { s . append ( ' ▁ ' ) ; } s . append ( points [ i ] . point ) . append ( ' : ' ) . append ( points [ i ] . starts . next / 3 ) . append ( ' , ' ) . append ( points [ i ] . ends . next / 3 ) ; } return s . toString ( ) ; }
public static double sinh ( double d ) { double ePowX = Math . pow ( Math . E , d ) ; double ePowNegX = Math . pow ( Math . E , - d ) ; return ( ePowX - ePowNegX ) / 2 ; }
public GetMembersResult getMembers ( GetMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMembers ( request ) ; }
public HSSFPatternFormatting createPatternFormatting ( ) { return getPatternFormatting ( true ) ; }
public DeleteSpotDatafeedSubscriptionResult deleteSpotDatafeedSubscription ( DeleteSpotDatafeedSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSpotDatafeedSubscription ( request ) ; }
public RevFilter clone ( ) { return new SkipRevFilter ( skip ) ; }
public BinarySearchIndexes ( int highIx ) { _lowIx = - 1 ; _highIx = highIx ; }
public Query makeLuceneQueryFieldNoBoost ( String fieldName , BasicQueryFactory qf ) { return SrndBooleanQuery . makeBooleanQuery ( makeLuceneSubQueriesField ( fieldName , qf ) , BooleanClause . Occur . SHOULD ) ; }
public static CloneCommand cloneRepository ( ) { return new CloneCommand ( ) ; }
public EnableMetricsCollectionResult enableMetricsCollection ( EnableMetricsCollectionRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableMetricsCollection ( request ) ; }
public DescribePlayerSessionsResult describePlayerSessions ( DescribePlayerSessionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribePlayerSessions ( request ) ; }
public UpdateDocumentVersionResult updateDocumentVersion ( UpdateDocumentVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDocumentVersion ( request ) ; }
public TagCommand setTagger ( PersonIdent tagger ) { this . tagger = tagger ; return this ; }
public void setCellValue ( boolean value ) { int row = _record . getRow ( ) ; short col = _record . getColumn ( ) ; short styleIndex = _record . getXFIndex ( ) ; switch ( _cellType ) { default : setCellType ( CellType . BOOLEAN , false , row , col , styleIndex ) ; case BOOLEAN : ( ( BoolErrRecord ) _record ) . setValue ( value ) ; break ; case FORMULA : ( ( FormulaRecordAggregate ) _record ) . setCachedBooleanResult ( value ) ; break ; } }
public PatternReplaceFilterFactory ( Map < String , String > args ) { super ( args ) ; pattern = getPattern ( args , " pattern " ) ; replacement = get ( args , " replacement " ) ; replaceAll = " all " . equals ( get ( args , " replace " , Arrays . asList ( " all " , " first " ) , " all " ) ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public List < T > asList ( Object output ) { if ( ! ( output instanceof List ) ) { List < T > result = new ArrayList <> ( 1 ) ; result . add ( ( T ) output ) ; return result ; } else { return ( List < T > ) output ; } }
public FooterKey ( String keyName ) { name = keyName ; raw = Constants . encode ( keyName . toLowerCase ( Locale . ROOT ) ) ; }
public List < Token > getTokens ( ) { return tokens ; }
public DeleteTaskSetResult deleteTaskSet ( DeleteTaskSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTaskSet ( request ) ; }
public DescribeLifecycleConfigurationResult describeLifecycleConfiguration ( DescribeLifecycleConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLifecycleConfiguration ( request ) ; }
public DescribeNodegroupResult describeNodegroup ( DescribeNodegroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNodegroup ( request ) ; }
public CustomProperty ( ) { this . name = null ; }
public DeleteDirectConnectGatewayResult deleteDirectConnectGateway ( DeleteDirectConnectGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDirectConnectGateway ( request ) ; }
public AddCommand ( Repository repo ) { super ( repo ) ; filepatterns = new LinkedList <> ( ) ; }
public UpdateStageResult updateStage ( UpdateStageRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateStage ( request ) ; }
public ModifyIdFormatResult modifyIdFormat ( ModifyIdFormatRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyIdFormat ( request ) ; }
public RemoveRoleFromDBClusterResult removeRoleFromDBCluster ( RemoveRoleFromDBClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveRoleFromDBCluster ( request ) ; }
public E set ( int location , E object ) { if ( location >= 0 && location < size ) { Link < E > link = voidLink ; if ( location < ( size / 2 ) ) { for ( int i = 0 ; i <= location ; i ++ ) { link = link . next ; } } else { for ( int i = size ; i > location ; i -- ) { link = link . previous ; } } E result = link . data ; link . data = object ; return result ; } throw new IndexOutOfBoundsException ( ) ; }
public ListPhoneNumbersResult listPhoneNumbers ( ListPhoneNumbersRequest request ) { request = beforeClientExecution ( request ) ; return executeListPhoneNumbers ( request ) ; }
public GermanNormalizationFilter ( TokenStream input ) { super ( input ) ; }
@ Override public boolean equals ( Object object ) { return list . equals ( object ) ; }
public PullCommand pull ( ) { return new PullCommand ( repo ) ; }
public String toString ( ) { return " ALL " ; }
public CreateIngestionResult createIngestion ( CreateIngestionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateIngestion ( request ) ; }
public StashCreateCommand ( Repository repo ) { super ( repo ) ; person = new PersonIdent ( repo ) ; }
public final ShortBuffer asShortBuffer ( ) { return ShortToByteBufferAdapter . asShortBuffer ( this ) ; }
public FeatSmartTag ( ) { data = new byte [ 0 ] ; }
public LogCommand setSkip ( int skip ) { checkCallable ( ) ; this . skip = skip ; return this ; }
public Ptg [ ] getFormulaTokens ( FormulaRecord formula ) { int formulaRow = formula . getRow ( ) ; int formulaColumn = formula . getColumn ( ) ; if ( ! isInRange ( formulaRow , formulaColumn ) ) { throw new RuntimeException ( " Shared ▁ Formula ▁ Conversion : ▁ Coding ▁ Error " ) ; } SharedFormula sf = new SharedFormula ( SpreadsheetVersion . EXCEL97 ) ; return sf . convertSharedFormulas ( field_7_parsed_expr . getTokens ( ) , formulaRow , formulaColumn ) ; }
public int regionEnd ( ) { return regionEnd ; }
public int getBehindCount ( ) { return behindCount ; }
public void encode ( int [ ] values , int valuesOffset , long [ ] blocks , int blocksOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { blocks [ blocksOffset ++ ] = encode ( values , valuesOffset ) ; valuesOffset += valueCount ; } }
public PutImageScanningConfigurationResult putImageScanningConfiguration ( PutImageScanningConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executePutImageScanningConfiguration ( request ) ; }
public BlameCommand blame ( ) { return new BlameCommand ( repo ) ; }
public BytesRef textToBytesRef ( ) { return new BytesRef ( text ) ; }
public int compareTo ( DoubleBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; double thisDouble , otherDouble ; while ( compareRemaining > 0 ) { thisDouble = get ( thisPos ) ; otherDouble = otherBuffer . get ( otherPos ) ; if ( ( thisDouble != otherDouble ) && ( ( thisDouble == thisDouble ) || ( otherDouble == otherDouble ) ) ) { return thisDouble < otherDouble ? - 1 : 1 ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; }
public CreateIpGroupResult createIpGroup ( CreateIpGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateIpGroup ( request ) ; }
public synchronized E set ( int index , E e ) { Object [ ] newElements = elements . clone ( ) ; @ SuppressWarnings ( " unchecked " ) E result = ( E ) newElements [ index ] ; newElements [ index ] = e ; elements = newElements ; return result ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " : " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public synchronized String substring ( int start , int end ) { return super . substring ( start , end ) ; }
public static TreeFilter create ( TreeFilter a , TreeFilter b ) { if ( a == ALL ) return b ; if ( b == ALL ) return a ; return new Binary ( a , b ) ; }
public static String authoritySafePath ( String authority , String path ) { if ( authority != null && ! authority . isEmpty ( ) && ! path . isEmpty ( ) && ! path . startsWith ( " / " ) ) { return " / " + path ; } return path ; }
public final void smudgeRacilyClean ( ) { final int base = infoOffset + P_SIZE ; Arrays . fill ( info , base , base + 4 , ( byte ) 0 ) ; }
public SeriesListRecord clone ( ) { return copy ( ) ; }
public void decode ( ) { if ( null == escherRecords || 0 == escherRecords . size ( ) ) { byte [ ] rawData = getRawData ( ) ; convertToEscherRecords ( 0 , rawData . length , rawData ) ; } }
public RemoveAutoScalingPolicyResult removeAutoScalingPolicy ( RemoveAutoScalingPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveAutoScalingPolicy ( request ) ; }
public byte readByte ( ) { assert ! eof ( ) ; assert upto <= limit ; if ( upto == limit ) nextSlice ( ) ; return buffer [ upto ++ ] ; }
public CreateAliasResult createAlias ( CreateAliasRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAlias ( request ) ; }
public boolean markSupported ( ) { return in . markSupported ( ) ; }
public String getRawSchemeSpecificPart ( ) { return schemeSpecificPart ; }
public CreateRouteResponseResult createRouteResponse ( CreateRouteResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRouteResponse ( request ) ; }
public void remove ( ) { if ( lastEntryReturned == null ) throw new IllegalStateException ( ) ; if ( modCount != expectedModCount ) throw new ConcurrentModificationException ( ) ; HashMap . this . remove ( lastEntryReturned . key ) ; lastEntryReturned = null ; expectedModCount = modCount ; }
public void put ( int key , E value ) { int i = binarySearch ( mKeys , 0 , mSize , key ) ; if ( i >= 0 ) { mValues [ i ] = value ; } else { i = ~ i ; if ( i < mSize && mValues [ i ] == DELETED ) { mKeys [ i ] = key ; mValues [ i ] = value ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; i = ~ binarySearch ( mKeys , 0 , mSize , key ) ; } if ( mSize >= mKeys . length ) { int n = ArrayUtils . idealIntArraySize ( mSize + 1 ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , 0 , nkeys , 0 , mKeys . length ) ; System . arraycopy ( mValues , 0 , nvalues , 0 , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } if ( mSize - i != 0 ) { System . arraycopy ( mKeys , i , mKeys , i + 1 , mSize - i ) ; System . arraycopy ( mValues , i , mValues , i + 1 , mSize - i ) ; } mKeys [ i ] = key ; mValues [ i ] = value ; mSize ++ ; } }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof LexerCustomAction ) ) { return false ; } LexerCustomAction other = ( LexerCustomAction ) obj ; return ruleIndex == other . ruleIndex && actionIndex == other . actionIndex ; }
public void seekExact ( BytesRef term , TermState state ) throws IOException { throw new UnsupportedOperationException ( getClass ( ) . getName ( ) + " ▁ does ▁ not ▁ support ▁ seeking " ) ; }
public void readBytes ( byte [ ] b , int offset , int len ) { assert b . length >= offset + len ; final int offsetEnd = offset + len ; while ( true ) { final int blockLeft = blockSize - currentBlockUpto ; final int left = offsetEnd - offset ; if ( blockLeft < left ) { System . arraycopy ( currentBlock , currentBlockUpto , b , offset , blockLeft ) ; nextBlock ( ) ; offset += blockLeft ; } else { System . arraycopy ( currentBlock , currentBlockUpto , b , offset , left ) ; currentBlockUpto += left ; break ; } } }
public FileResolver ( File basePath , boolean exportAll ) { this ( ) ; exportDirectory ( basePath ) ; setExportAll ( exportAll ) ; }
@ Override public void add ( int location , E object ) { synchronized ( mutex ) { list . add ( location , object ) ; } }
public String replaceFirst ( String replacement ) { reset ( ) ; StringBuffer buffer = new StringBuffer ( input . length ( ) ) ; if ( find ( ) ) { appendReplacement ( buffer , replacement ) ; } return appendTail ( buffer ) . toString ( ) ; }
public String format2DRefAsString ( ) { return formatReferenceAsString ( ) ; }
public static String trimFromLast ( String str , String stripString ) { int pos = str . lastIndexOf ( stripString ) ; if ( pos > - 1 ) { return str . substring ( 0 , pos ) ; } else { return str ; } }
public float hyperbolicTf ( float freq ) { if ( 0.0f == freq ) return 0.0f ; final float min = tf_hyper_min ; final float max = tf_hyper_max ; final double base = tf_hyper_base ; final float xoffset = tf_hyper_xoffset ; final double x = ( double ) ( freq - xoffset ) ; final float result = min + ( float ) ( ( max - min ) / 2.0f * ( ( ( Math . pow ( base , x ) - Math . pow ( base , - x ) ) / ( Math . pow ( base , x ) + Math . pow ( base , - x ) ) ) + 1.0d ) ) ; return Float . isNaN ( result ) ? max : result ; }
public void setConfig ( Config config ) { super . setConfig ( config ) ; sortRange = config . get ( " sort . rng " , 20000 ) ; r = new Random ( config . get ( " rand . seed " , 13 ) ) ; }
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 33 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 25 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } } } } for ( int i = 0 ; i < 33 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; }
public int addConditionalFormatting ( CellRangeAddress [ ] regions , ConditionalFormattingRule rule1 ) { return addConditionalFormatting ( regions , ( HSSFConditionalFormattingRule ) rule1 ) ; }
public void setObjectInserter ( ObjectInserter oi ) { walk . close ( ) ; reader . close ( ) ; inserter . close ( ) ; inserter = oi ; reader = oi . newReader ( ) ; walk = new RevWalk ( reader ) ; }
public void clear ( ) { head = null ; free = null ; index = null ; inQueue = 0 ; sinceLastIndex = 0 ; last = - 1 ; }
public void ReInit ( CharStream stream , int lexState ) { ReInit ( stream ) ; SwitchTo ( lexState ) ; }
public boolean contains ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) return false ; Map . Entry <? , ?> e = ( Map . Entry <? , ?> ) o ; V v = ConcurrentHashMap . this . get ( e . getKey ( ) ) ; return v != null && v . equals ( e . getValue ( ) ) ; }
public List < String > getRemovedList ( ) { return removedList ; }
public synchronized TaxonomyReader getTaxonomyReader ( ) { if ( taxonomyReader != null ) { taxonomyReader . incRef ( ) ; } return taxonomyReader ; }
public String toString ( String field ) { return getBooleanQuery ( ) . toString ( field ) ; }
public HSSFShapeGroup createGroup ( HSSFClientAnchor anchor ) { HSSFShapeGroup group = new HSSFShapeGroup ( null , anchor ) ; addShape ( group ) ; onCreate ( group ) ; return group ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getText ( ) ) . append ( ' ( ' ) . append ( boost ) . append ( " ) ( " ) ; for ( Toffs to : termsOffsets ) { sb . append ( to ) ; } sb . append ( ' ) ' ) ; return sb . toString ( ) ; }
public ClassicFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public UpdateApplicationResult updateApplication ( UpdateApplicationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateApplication ( request ) ; }
public PackParser newPackParser ( InputStream in ) throws IOException { throw new UnsupportedOperationException ( ) ; }
public void print ( boolean bool ) { print ( String . valueOf ( bool ) ) ; }
public int centerY ( ) { return y + h / 2 ; }
public Query makeQuery ( SpatialArgs args ) { if ( ! SpatialOperation . is ( args . getOperation ( ) , SpatialOperation . Intersects , SpatialOperation . IsWithin ) ) throw new UnsupportedSpatialOperation ( args . getOperation ( ) ) ; Shape shape = args . getShape ( ) ; if ( shape instanceof Rectangle ) { Rectangle bbox = ( Rectangle ) shape ; return new ConstantScoreQuery ( makeWithin ( bbox ) ) ; } else if ( shape instanceof Circle ) { Circle circle = ( Circle ) shape ; Rectangle bbox = circle . getBoundingBox ( ) ; return new DistanceRangeQuery ( makeWithin ( bbox ) , makeDistanceValueSource ( circle . getCenter ( ) ) , circle . getRadius ( ) ) ; } else { throw new UnsupportedOperationException ( " Only ▁ Rectangles ▁ and ▁ Circles ▁ are ▁ currently ▁ supported , ▁ " + " found ▁ [ " + shape . getClass ( ) + " ] " ) ; } }
public BooleanQuery build ( ) { return new BooleanQuery ( minimumNumberShouldMatch , clauses . toArray ( new BooleanClause [ 0 ] ) ) ; }
public GetManagedScalingPolicyResult getManagedScalingPolicy ( GetManagedScalingPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetManagedScalingPolicy ( request ) ; }
public ListApplicationsResult listApplications ( ) { return listApplications ( new ListApplicationsRequest ( ) ) ; }
public String getFormatSpecifier ( ) { return s ; }
public static String getBuiltinFormat ( short index ) { return BuiltinFormats . getBuiltinFormat ( index ) ; }
public void addTask ( PerfTask task ) { tasks . add ( task ) ; task . setDepth ( getDepth ( ) + 1 ) ; }
public GetQueueUrlResult getQueueUrl ( String queueName ) { return getQueueUrl ( new GetQueueUrlRequest ( ) . withQueueName ( queueName ) ) ; }
public static double asinh ( double d ) { return Math . log ( Math . sqrt ( d * d + 1 ) + d ) ; }
public ActivityTypeDetail describeActivityType ( DescribeActivityTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeActivityType ( request ) ; }
public RegisterTransitGatewayMulticastGroupSourcesResult registerTransitGatewayMulticastGroupSources ( RegisterTransitGatewayMulticastGroupSourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterTransitGatewayMulticastGroupSources ( request ) ; }
public void onRelease ( ) { mPullDistance = 0 ; if ( mState != STATE_PULL && mState != STATE_PULL_DECAY ) { return ; } mState = STATE_RECEDE ; mEdgeAlphaStart = mEdgeAlpha ; mEdgeScaleYStart = mEdgeScaleY ; mGlowAlphaStart = mGlowAlpha ; mGlowScaleYStart = mGlowScaleY ; mEdgeAlphaFinish = 0. f ; mEdgeScaleYFinish = 0. f ; mGlowAlphaFinish = 0. f ; mGlowScaleYFinish = 0. f ; mStartTime = AnimationUtils . currentAnimationTimeMillis ( ) ; mDuration = RECEDE_TIME ; }
public ImportKeyPairResult importKeyPair ( ImportKeyPairRequest request ) { request = beforeClientExecution ( request ) ; return executeImportKeyPair ( request ) ; }
public String metricFilterPattern ( ) { return this . metricFilterPattern ; }
public long getTotalTimeInPrediction ( ) { DecisionInfo [ ] decisions = atnSimulator . getDecisionInfo ( ) ; long t = 0 ; for ( int i = 0 ; i < decisions . length ; i ++ ) { t += decisions [ i ] . timeInPrediction ; } return t ; }
public TokenStream create ( TokenStream input ) { return new HungarianLightStemFilter ( input ) ; }
public String getDescription ( ) { return desc ; }
public DeleteAlgorithmResult deleteAlgorithm ( DeleteAlgorithmRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAlgorithm ( request ) ; }
public void setPrefix ( String prefix ) { this . prefix = prefix ; }
public Collection < ChildScorable > getChildren ( ) { return Collections . singleton ( new ChildScorable ( childScorer , " BLOCK □ JOIN " ) ) ; }
public void run ( ) { sendAccessibilityEvent ( AccessibilityEvent . TYPE_VIEW_SELECTED ) ; }
public String apiVersion ( ) { return this . apiVersion ; }
public OpenNLPPOSFilter create ( TokenStream in ) { try { return new OpenNLPPOSFilter ( in , OpenNLPOpsFactory . getPOSTagger ( posTaggerModelFile ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( e ) ; } }
public SendBulkTemplatedEmailResult sendBulkTemplatedEmail ( SendBulkTemplatedEmailRequest request ) { request = beforeClientExecution ( request ) ; return executeSendBulkTemplatedEmail ( request ) ; }
public ByteBuffer putFloat ( float value ) { return putInt ( Float . floatToRawIntBits ( value ) ) ; }
public TotalTermFreqValueSource ( String field , String val , String indexedField , BytesRef indexedBytes ) { this . field = field ; this . val = val ; this . indexedField = indexedField ; this . indexedBytes = indexedBytes ; }
public static final int encoding ( byte [ ] b , int ptr ) { final int sz = b . length ; while ( ptr < sz ) { if ( b [ ptr ] == ' \ n ' ) return - 1 ; if ( b [ ptr ] == ' e ' ) break ; ptr = nextLF ( b , ptr ) ; } return match ( b , ptr , encoding ) ; }
public void init ( ByteBlockPool pool , int startIndex , int endIndex ) { assert endIndex - startIndex >= 0 ; assert startIndex >= 0 ; assert endIndex >= 0 ; this . pool = pool ; this . endIndex = endIndex ; level = 0 ; bufferUpto = startIndex / ByteBlockPool . BYTE_BLOCK_SIZE ; bufferOffset = bufferUpto * ByteBlockPool . BYTE_BLOCK_SIZE ; buffer = pool . buffers [ bufferUpto ] ; upto = startIndex & ByteBlockPool . BYTE_BLOCK_MASK ; final int firstSize = ByteBlockPool . LEVEL_SIZE_ARRAY [ 0 ] ; if ( startIndex + firstSize >= endIndex ) { limit = endIndex & ByteBlockPool . BYTE_BLOCK_MASK ; } elselimit = upto + firstSize - 4 ; }
public MergeCellsRecord ( RecordInputStream in ) { int nRegions = in . readUShort ( ) ; CellRangeAddress [ ] cras = new CellRangeAddress [ nRegions ] ; for ( int i = 0 ; i < nRegions ; i ++ ) { cras [ i ] = new CellRangeAddress ( in ) ; } _numberOfRegions = nRegions ; _startIndex = 0 ; _regions = cras ; }
public List <? extends FileHeader > getFiles ( ) { return files ; }
public final long get ( int index ) { checkIndex ( index ) ; return backingArray [ offset + index ] ; }
public DescribeClusterTracksResult describeClusterTracks ( DescribeClusterTracksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClusterTracks ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( " ▁ [ " ) ; if ( externalWorkbookNumber >= 0 ) { sb . append ( " ▁ [ " ) ; sb . append ( " workbook = " ) . append ( getExternalWorkbookNumber ( ) ) ; sb . append ( " ] ▁ " ) ; } sb . append ( " sheet = " ) . append ( getSheetName ( ) ) ; sb . append ( " ▁ ! ▁ " ) ; sb . append ( FormulaError . REF . getString ( ) ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public void setParsedExpression ( Ptg [ ] ptgs ) { field_8_parsed_expr = Formula . create ( ptgs ) ; }
public ActivityTypeInfos listActivityTypes ( ListActivityTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeListActivityTypes ( request ) ; }
public DescribeDBSecurityGroupsResult describeDBSecurityGroups ( ) { return describeDBSecurityGroups ( new DescribeDBSecurityGroupsRequest ( ) ) ; }
public < T > Collection < T > getAllMatchingGroups ( ) { return ( Collection < T > ) matchingGroups ; }
public void setCachedResultBoolean ( boolean value ) { specialCachedValue = FormulaSpecialCachedValue . createCachedBoolean ( value ) ; }
public static boolean doesFormulaReferToDeletedCell ( Ptg [ ] ptgs ) { for ( Ptg ptg : ptgs ) { if ( isDeletedCellRef ( ptg ) ) { return true ; } } return false ; }
public static float [ ] grow ( float [ ] array ) { return grow ( array , 1 + array . length ) ; }
public void clear ( ) { head = null ; tail = null ; free . clear ( ) ; }
public DeleteIPSetResult deleteIPSet ( DeleteIPSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteIPSet ( request ) ; }
public StaticCredentialsProvider ( AlibabaCloudCredentials credentials ) { this . credentials = credentials ; }
public static double [ ] copyOfRange ( double [ ] original , int start , int end ) { if ( start > end ) { throw new IllegalArgumentException ( ) ; } int originalLength = original . length ; if ( start < 0 || start > originalLength ) { throw new ArrayIndexOutOfBoundsException ( ) ; } int resultLength = end - start ; int copyLength = Math . min ( resultLength , originalLength - start ) ; double [ ] result = new double [ resultLength ] ; System . arraycopy ( original , start , result , 0 , copyLength ) ; return result ; }
public DescribeEntityRecognizerResult describeEntityRecognizer ( DescribeEntityRecognizerRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEntityRecognizer ( request ) ; }
public void removeTitle ( ) { remove1stProperty ( PropertyIDMap . PID_TITLE ) ; }
public GetDigestResult getDigest ( GetDigestRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDigest ( request ) ; }
public CreateStackResult createStack ( CreateStackRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateStack ( request ) ; }
public boolean adjustFormula ( Ptg [ ] ptgs , int currentExternSheetIx ) { boolean refsWereChanged = false ; for ( int i = 0 ; i < ptgs . length ; i ++ ) { Ptg newPtg = adjustPtg ( ptgs [ i ] , currentExternSheetIx ) ; if ( newPtg != null ) { refsWereChanged = true ; ptgs [ i ] = newPtg ; } } return refsWereChanged ; }
public void print ( Object o ) { print ( String . valueOf ( o ) ) ; }
public void setParams ( String params ) { super . setParams ( params ) ; useAddIndexesDir = Boolean . parseBoolean ( params ) ; }
public void close ( ) throws IOException { if ( isOpen && ! isClone ) { try { channel . close ( ) ; } finally { if ( ! isClone ) { fis . close ( ) ; } } } }
public void reset ( ) { count = 0 ; assert forwardCount == 0 : " pos = " + pos + " ▁ forwardCount = " + forwardCount ; }
public void unlinkSharedFormulas ( ) { for ( int i = 0 ; i < _numberOfFormulas ; i ++ ) { _frAggs [ i ] . unlinkSharedFormula ( ) ; } }
public boolean isIndexTerm ( BytesRef term , TermStats stats ) { if ( stats . docFreq >= docFreqThresh || count >= interval ) { count = 1 ; return true ; } else { count ++ ; return false ; } }
public void removeHeadingPair ( ) { remove1stProperty ( PropertyIDMap . PID_HEADINGPAIR ) ; }
public synchronized String [ ] getPOSTags ( String [ ] words ) { return tagger . tag ( words ) ; }
public TermsEnum intersect ( CompiledAutomaton compiled , BytesRef startTerm ) throws IOException { if ( compiled . type != CompiledAutomaton . AUTOMATON_TYPE . NORMAL ) { throw new IllegalArgumentException ( " please ▁ use ▁ CompiledAutomaton . getTermsEnum ▁ instead " ) ; } return new IntersectTermsEnum ( this , compiled . automaton , compiled . runAutomaton , compiled . commonSuffixRef , startTerm ) ; }
public AttachLoadBalancerToSubnetsResult attachLoadBalancerToSubnets ( AttachLoadBalancerToSubnetsRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachLoadBalancerToSubnets ( request ) ; }
public PrecedenceQueryParser ( ) { setQueryNodeProcessor ( new PrecedenceQueryNodeProcessorPipeline ( getQueryConfigHandler ( ) ) ) ; }
public CommonToken ( int type ) { this . type = type ; this . source = EMPTY_SOURCE ; }
public DeleteEmailChannelResult deleteEmailChannel ( DeleteEmailChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEmailChannel ( request ) ; }
public DeleteNotificationSubscriptionResult deleteNotificationSubscription ( DeleteNotificationSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNotificationSubscription ( request ) ; }
public void close ( ) throws IOException { synchronized ( lock ) { if ( isClosed ( ) ) { return ; } Throwable thrown = null ; try { flushInternal ( ) ; } catch ( Throwable e ) { thrown = e ; } buf = null ; try { out . close ( ) ; } catch ( Throwable e ) { if ( thrown == null ) { thrown = e ; } } out = null ; if ( thrown != null ) { SneakyThrow . sneakyThrow ( thrown ) ; } } }
public String toString ( String field ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " spanPosRange ( " ) ; buffer . append ( match . toString ( field ) ) ; buffer . append ( " , ▁ " ) . append ( start ) . append ( " , ▁ " ) ; buffer . append ( end ) ; buffer . append ( " ) " ) ; return buffer . toString ( ) ; }
public ListPipelinesResult listPipelines ( ListPipelinesRequest request ) { request = beforeClientExecution ( request ) ; return executeListPipelines ( request ) ; }
public ConfirmProductInstanceResult confirmProductInstance ( ConfirmProductInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeConfirmProductInstance ( request ) ; }
public CreateProjectResult createProject ( CreateProjectRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateProject ( request ) ; }
public ListMomentsRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListMoments " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public String getCCByGB2312Id ( int ccid ) { if ( ccid < 0 || ccid > AbstractDictionary . GB2312_CHAR_NUM ) return " " ; int cc1 = ccid / 94 + 161 ; int cc2 = ccid % 94 + 161 ; byte [ ] buffer = new byte [ 2 ] ; buffer [ 0 ] = ( byte ) cc1 ; buffer [ 1 ] = ( byte ) cc2 ; try { String cchar = new String ( buffer , " GB2312 " ) ; return cchar ; } catch ( UnsupportedEncodingException e ) { return " " ; } }
public static RevFilter create ( RevFilter a , RevFilter b ) { if ( a == ALL || b == ALL ) return ALL ; return new Binary ( a , b ) ; }
public UpdateTableRequest ( String tableName , ProvisionedThroughput provisionedThroughput ) { setTableName ( tableName ) ; setProvisionedThroughput ( provisionedThroughput ) ; }
public Repository getRepository ( ) { return db ; }
public ShortBuffer compact ( ) { if ( byteBuffer . isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } byteBuffer . limit ( limit * SizeOf . SHORT ) ; byteBuffer . position ( position * SizeOf . SHORT ) ; byteBuffer . compact ( ) ; byteBuffer . clear ( ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public CreateInstanceExportTaskResult createInstanceExportTask ( CreateInstanceExportTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateInstanceExportTask ( request ) ; }
public String toString ( ) { return " MultiDocsAndPositionsEnum ( " + Arrays . toString ( getSubs ( ) ) + " ) " ; }
public DescribeStacksResult describeStacks ( DescribeStacksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStacks ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_xf_index ) ; if ( isBuiltin ( ) ) { out . writeByte ( field_2_builtin_style ) ; out . writeByte ( field_3_outline_style_level ) ; } else { out . writeShort ( field_4_name . length ( ) ) ; out . writeByte ( field_3_stringHasMultibyte ? 0x01 : 0x00 ) ; if ( field_3_stringHasMultibyte ) { StringUtil . putUnicodeLE ( getName ( ) , out ) ; } else { StringUtil . putCompressedUnicode ( getName ( ) , out ) ; } } }
public void write ( byte [ ] b , int off , int len ) throws IOException { deflater . setInput ( b , off , len ) ; for ( ; ; ) { if ( outPtr == zbuf . length ) throw new EOFException ( ) ; int n = deflater . deflate ( zbuf , outPtr , zbuf . length - outPtr ) ; if ( n == 0 ) { if ( deflater . needsInput ( ) ) break ; throw new IOException ( ) ; } outPtr += n ; } }
public String toFormulaString ( ) { return " ▁ " ; }
public StringBuffer insert ( int index , double d ) { return insert ( index , Double . toString ( d ) ) ; }
public FieldWriter addField ( FieldInfo field , long termsFilePointer ) { SimpleFieldWriter writer = new SimpleFieldWriter ( field , termsFilePointer ) ; fields . add ( writer ) ; return writer ; }
public DeleteUserEndpointsResult deleteUserEndpoints ( DeleteUserEndpointsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteUserEndpoints ( request ) ; }
public HSSFColor addColor ( byte red , byte green , byte blue ) { byte [ ] b = _palette . getColor ( PaletteRecord . FIRST_COLOR_INDEX ) ; short i ; for ( i = PaletteRecord . FIRST_COLOR_INDEX ; i < PaletteRecord . STANDARD_PALETTE_SIZE + PaletteRecord . FIRST_COLOR_INDEX ; b = _palette . getColor ( ++ i ) ) { if ( b == null ) { setColorAtIndex ( i , red , green , blue ) ; return getColor ( i ) ; } } throw new RuntimeException ( " Could ▁ not ▁ find ▁ free ▁ color ▁ index " ) ; }
public boolean isRenameDetectionEnabled ( ) { return renameDetectionType != RenameDetectionType . FALSE ; }
public static boolean safe ( String pattern ) { for ( int i = 0 ; i < pattern . length ( ) ; i ++ ) { final char c = pattern . charAt ( i ) ; switch ( c ) { case ' . ' : case ' ? ' : case ' * ' : case ' + ' : case ' { ' : case ' } ' : case ' ( ' : case ' ) ' : case ' [ ' : case ' ] ' : case ' \\ ' : return ▁ false ; } } return ▁ true ; }
public void SwitchTo ( int lexState ) { if ( lexState >= 3 || lexState < 0 ) throw new TokenMgrError ( " Error : ▁ Ignoring ▁ invalid ▁ lexical ▁ state ▁ : ▁ " + lexState + " . ▁ State ▁ unchanged . " , TokenMgrError . INVALID_LEXICAL_STATE ) ; elsecurLexState = lexState ; }
public CreateDeliverabilityTestReportResult createDeliverabilityTestReport ( CreateDeliverabilityTestReportRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDeliverabilityTestReport ( request ) ; }
public void set ( int index , long value ) { final int o = index / 10 ; final int b = index % 10 ; final int shift = b * 6 ; blocks [ o ] = ( blocks [ o ] & ~ ( 63L << shift ) ) | ( value << shift ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + formatAsString ( ) + " ] " ; }
public String getRemoteName ( ) { return remoteName ; }
public CherryPickCommand cherryPick ( ) { return new CherryPickCommand ( repo ) ; }
public HSSFClientAnchor createClientAnchor ( ) { return new HSSFClientAnchor ( ) ; }
public DeleteProfileResult deleteProfile ( DeleteProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteProfile ( request ) ; }
@ Override public int size ( ) { return count ( entrySet ( ) . iterator ( ) ) ; }
public ByteBuffer put ( ByteBuffer buf ) { throw new ReadOnlyBufferException ( ) ; }
public CreateBranchCommand setStartPoint ( RevCommit startPoint ) { checkCallable ( ) ; this . startCommit = startPoint ; this . startPoint = null ; return this ; }
public ListOnPremisesInstancesResult listOnPremisesInstances ( ListOnPremisesInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeListOnPremisesInstances ( request ) ; }
public int [ ] clear ( ) { if ( perField . postingsArray != null ) { bytesUsed . addAndGet ( - ( perField . postingsArray . size * perField . postingsArray . bytesPerPosting ( ) ) ) ; perField . postingsArray = null ; perField . newPostingsArray ( ) ; } return null ; }
public String getSourcePath ( ) { return outCandidate . sourcePath . getPath ( ) ; }
public static SingletonPredictionContext create ( PredictionContext parent , int returnState ) { if ( returnState == EMPTY_RETURN_STATE && parent == null ) { return EMPTY ; } return new SingletonPredictionContext ( parent , returnState ) ; }
public void cleanupSession ( String sessionID ) throws IOException { if ( sessionID . isEmpty ( ) ) { throw new IllegalArgumentException ( " sessionID ▁ cannot ▁ be ▁ empty " ) ; } IOUtils . rm ( workDir . resolve ( sessionID ) ) ; }
public DescribeSnapshotCopyGrantsResult describeSnapshotCopyGrants ( DescribeSnapshotCopyGrantsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSnapshotCopyGrants ( request ) ; }
public String toString ( ) { return Utils . join ( Arrays . asList ( opnds ) . iterator ( ) , " && " ) ; }
public DescribeApplicationResult describeApplication ( DescribeApplicationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeApplication ( request ) ; }
@ Override public E set ( int index , E object ) { Object [ ] a = array ; if ( index >= size ) { throwIndexOutOfBoundsException ( index , size ) ; } @ SuppressWarnings ( " unchecked " ) E result = ( E ) a [ index ] ; a [ index ] = object ; return result ; }
public void set ( int x , int y ) { this . x = x ; this . y = y ; }
public BatchSendMessagesRequest ( ) { super ( " OnsMqtt " , " 2019 - 12 - 11 " , " BatchSendMessages " , " onsmqtt " ) ; setMethod ( MethodType . POST ) ; }
public DeleteEgressOnlyInternetGatewayResult deleteEgressOnlyInternetGateway ( DeleteEgressOnlyInternetGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEgressOnlyInternetGateway ( request ) ; }
public static String byteToHex ( int value ) { StringBuilder sb = new StringBuilder ( 4 ) ; writeHex ( sb , value & 0xFFL , 2 , " 0x " ) ; return sb . toString ( ) ; }
public DescribeLoadBalancerPoliciesResult describeLoadBalancerPolicies ( DescribeLoadBalancerPoliciesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLoadBalancerPolicies ( request ) ; }
public void close ( ) throws IOException { try { beginWrite ( ) ; dst . close ( ) ; } catch ( InterruptedIOException e ) { throw writeTimedOut ( e ) ; } finally { endWrite ( ) ; } }
public UpdateVirtualInterfaceAttributesResult updateVirtualInterfaceAttributes ( UpdateVirtualInterfaceAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateVirtualInterfaceAttributes ( request ) ; }
public ScandinavianNormalizationFilter ( TokenStream input ) { super ( input ) ; }
public DeleteHumanLoopResult deleteHumanLoop ( DeleteHumanLoopRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteHumanLoop ( request ) ; }
public void onWindowFocusChanged ( boolean hasWindowFocus ) { super . onWindowFocusChanged ( hasWindowFocus ) ; if ( ! hasWindowFocus && ! mPopup . isDropDownAlwaysVisible ( ) ) { dismissDropDown ( ) ; } }
public GetApnsSandboxChannelResult getApnsSandboxChannel ( GetApnsSandboxChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApnsSandboxChannel ( request ) ; }
public TreeFilter clone ( ) { final TreeFilter n = a . clone ( ) ; return n == a ? this : new NotTreeFilter ( n ) ; }
public void addBuilder ( String nodeName , QueryBuilder builder ) { builders . put ( nodeName , builder ) ; }
public static boolean isSupported ( int bitsPerValue ) { return Arrays . binarySearch ( SUPPORTED_BITS_PER_VALUE , bitsPerValue ) >= 0 ; }
@ Override public V getValue ( ) { return mapEntry . getValue ( ) ; }
public DeletedArea3DPtg ( LittleEndianInput in ) { field_1_index_extern_sheet = in . readUShort ( ) ; unused1 = in . readInt ( ) ; unused2 = in . readInt ( ) ; }
public String toString ( ) { return " NativeFSLock ( path = " + path + " , impl = " + lock + " , creationTime = " + creationTime + " ) " ; }
public CreateVolumeResult createVolume ( CreateVolumeRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVolume ( request ) ; }
public EvaluationCell getCell ( int rowIndex , int columnIndex ) { HSSFRow row = _hs . getRow ( rowIndex ) ; if ( row == null ) { return null ; } HSSFCell cell = row . getCell ( columnIndex ) ; if ( cell == null ) { return null ; } return new HSSFEvaluationCell ( cell , this ) ; }
public DeleteBasePathMappingResult deleteBasePathMapping ( DeleteBasePathMappingRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteBasePathMapping ( request ) ; }
public void removeState ( ATNState state ) { states . set ( state . stateNumber , null ) ; }
public boolean equals ( Object other ) { if ( ! ( other instanceof ShortBuffer ) ) { return false ; } ShortBuffer otherBuffer = ( ShortBuffer ) other ; if ( remaining ( ) != otherBuffer . remaining ( ) ) { return false ; } int myPosition = position ; int otherPosition = otherBuffer . position ; boolean equalSoFar = true ; while ( equalSoFar && ( myPosition < limit ) ) { equalSoFar = get ( myPosition ++ ) == otherBuffer . get ( otherPosition ++ ) ; } return equalSoFar ; }
public boolean equals ( final Object o ) { if ( ! ( o instanceof PropertySet ) ) { return false ; } final PropertySet ps = ( PropertySet ) o ; int byteOrder1 = ps . getByteOrder ( ) ; int byteOrder2 = getByteOrder ( ) ; ClassID classID1 = ps . getClassID ( ) ; ClassID classID2 = getClassID ( ) ; int format1 = ps . getFormat ( ) ; int format2 = getFormat ( ) ; int osVersion1 = ps . getOSVersion ( ) ; int osVersion2 = getOSVersion ( ) ; int sectionCount1 = ps . getSectionCount ( ) ; int sectionCount2 = getSectionCount ( ) ; if ( byteOrder1 != byteOrder2 ||! classID1. equals ( classID2 ) || format1 != format2 || osVersion1 != osVersion2 || sectionCount1 != sectionCount2 ) { return false ; } return getSections ( ) . containsAll ( ps . getSections ( ) ) ; }
public static int getEstimatedNumberUniqueValuesAllowingForCollisions ( int setSize , int numRecordedBits ) { double setSizeAsDouble = setSize ; double numRecordedBitsAsDouble = numRecordedBits ; double saturation = numRecordedBitsAsDouble / setSizeAsDouble ; double logInverseSaturation = Math . log ( 1 - saturation ) * - 1 ; return ( int ) ( setSizeAsDouble * logInverseSaturation ) ; }
public static boolean isGitRepository ( File dir , FS fs ) { return fs . resolve ( dir , Constants . OBJECTS ) . exists ( ) && fs . resolve ( dir , " refs " ) . exists ( ) && ( fs . resolve ( dir , Constants . REFTABLE ) . exists ( ) || isValidHead ( new File ( dir , Constants . HEAD ) ) ) ; }
public void setBackgroundImage ( int pictureIndex ) { setPropertyValue ( new EscherSimpleProperty ( EscherPropertyTypes . FILL__PATTERNTEXTURE , false , true , pictureIndex ) ) ; setPropertyValue ( new EscherSimpleProperty ( EscherPropertyTypes . FILL__FILLTYPE , false , false , FILL_TYPE_PICTURE ) ) ; EscherBSERecord bse = getPatriarch ( ) . getSheet ( ) . getWorkbook ( ) . getWorkbook ( ) . getBSERecord ( pictureIndex ) ; bse . setRef ( bse . getRef ( ) + 1 ) ; }
public DirectPostingsFormat ( int minSkipCount , int lowFreqCutoff ) { super ( " Direct " ) ; this . minSkipCount = minSkipCount ; this . lowFreqCutoff = lowFreqCutoff ; }
public RecyclingByteBlockAllocator ( int blockSize , int maxBufferedBlocks , Counter bytesUsed ) { super ( blockSize ) ; freeByteBlocks = new byte [ maxBufferedBlocks ] [ ] ; this . maxBufferedBlocks = maxBufferedBlocks ; this . bytesUsed = bytesUsed ; }
public int stemPrefix ( char s [ ] , int len ) { for ( int i = 0 ; i < prefixes . length ; i ++ ) if ( startsWithCheckLength ( s , len , prefixes [ i ] ) ) return deleteN ( s , 0 , len , prefixes [ i ] . length ) ; return len ; }
public String toString ( ) { final StringBuilder s = new StringBuilder ( ) ; for ( Entry q = head ; q != null ; q = q . next ) describe ( s , q . commit ) ; return s . toString ( ) ; }
public CodingErrorAction malformedInputAction ( ) { return malformedInputAction ; }
public Result ( IntsRef input , T output ) { this . input = input ; this . output = output ; }
public String getInflectionForm ( int wordId ) { return null ; }
public void removeComments ( ) { remove1stProperty ( PropertyIDMap . PID_COMMENTS ) ; }
public GetBlacklistReportsResult getBlacklistReports ( GetBlacklistReportsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetBlacklistReports ( request ) ; }
public String getMessages ( ) { return messageWriter != null ? messageWriter . toString ( ) : " " ; }
public boolean equals ( Object object ) { if ( ! ( object instanceof StringCharacterIterator ) ) { return false ; } StringCharacterIterator it = ( StringCharacterIterator ) object ; return string . equals ( it . string ) && start == it . start && end == it . end && offset == it . offset ; }
public AddFacetToObjectResult addFacetToObject ( AddFacetToObjectRequest request ) { request = beforeClientExecution ( request ) ; return executeAddFacetToObject ( request ) ; }
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 34 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 25 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } } } } for ( int i = 0 ; i < 34 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; }
public final int correctOffset ( int currentOff ) { final int corrected = correct ( currentOff ) ; return ( input instanceof CharFilter ) ? ( ( CharFilter ) input ) . correctOffset ( corrected ) : corrected ; }
public static ContinuableRecordOutput createForCountingOnly ( ) { return new ContinuableRecordOutput ( NOPOutput , - 777 ) ; }
public DisassociateAddressRequest ( String publicIp ) { setPublicIp ( publicIp ) ; }
public DescribeVirtualGatewaysResult describeVirtualGateways ( DescribeVirtualGatewaysRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVirtualGateways ( request ) ; }
public void setSheetHidden ( int sheetnum , boolean hidden ) { setSheetHidden ( sheetnum , hidden ? SheetVisibility . HIDDEN : SheetVisibility . VISIBLE ) ; }
public static Cell createCell ( Row row , int column , String value , CellStyle style ) { Cell cell = getCell ( row , column ) ; cell . setCellValue ( cell . getRow ( ) . getSheet ( ) . getWorkbook ( ) . getCreationHelper ( ) . createRichTextString ( value ) ) ; if ( style != null ) { cell . setCellStyle ( style ) ; } return cell ; }
public CreateCacheParameterGroupRequest ( String cacheParameterGroupName , String cacheParameterGroupFamily , String description ) { setCacheParameterGroupName ( cacheParameterGroupName ) ; setCacheParameterGroupFamily ( cacheParameterGroupFamily ) ; setDescription ( description ) ; }
public DirCacheEntry ( byte [ ] path , int stage ) { checkPath ( path ) ; if ( stage < 0 || 3 < stage ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . invalidStageForPath , stage , toString ( path ) ) ) ; info = new byte [ INFO_LEN ] ; infoOffset = 0 ; this . path = path ; int flags = ( ( stage & 0x3 ) << 12 ) ; if ( path . length < NAME_MASK ) flags |= path . length ; elseflags |= NAME_MASK ; NB . encodeInt16 ( info , infoOffset + P_FLAGS , flags ) ; }
public FileOutputStream ( String path , boolean append ) throws FileNotFoundException { this ( new File ( path ) , append ) ; }
public DescribeVolumesResult describeVolumes ( ) { return describeVolumes ( new DescribeVolumesRequest ( ) ) ; }
public String toString ( ) { return String . valueOf ( label ) ; }
public MutableValue duplicate ( ) { MutableValueDouble v = new MutableValueDouble ( ) ; v . value = this . value ; v . exists = this . exists ; return v ; }
public boolean shouldBeRecursive ( ) { for ( byte b : pathRaw ) if ( b == ' / ' ) return true ; return false ; }
public boolean equals ( Object o ) { return o instanceof BasqueStemmer ; }
public SheetBuilder setSheetName ( String sheetName ) { this . sheetName = sheetName ; return this ; }
public ListTimeLinesRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListTimeLines " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DescribeStackResourcesResult describeStackResources ( DescribeStackResourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStackResources ( request ) ; }
public UpdateBotResult updateBot ( UpdateBotRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateBot ( request ) ; }
public boolean matches ( int symbol , int minVocabSymbol , int maxVocabSymbol ) { return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && ! super . matches ( symbol , minVocabSymbol , maxVocabSymbol ) ; }
public void fillTo ( int toIndex , int val ) { while ( count < toIndex ) add ( val ) ; }
public static long [ ] grow ( long [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Long . BYTES ) ) ; } else return array ; }
public ExportSnapshotResult exportSnapshot ( ExportSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeExportSnapshot ( request ) ; }
public boolean hasChildOfType ( short recordId ) { return _childRecords . stream ( ) . anyMatch ( r -> r . getRecordId ( ) == recordId ) ; }
public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; thedata = IOUtils . safelyAllocate ( bytesRemaining , MAX_RECORD_LENGTH ) ; System . arraycopy ( data , offset + 8 , thedata , 0 , bytesRemaining ) ; return bytesRemaining + 8 ; }
public RmCommand addFilepattern ( String filepattern ) { checkCallable ( ) ; filepatterns . add ( filepattern ) ; return this ; }
public GetEmailIdentityResult getEmailIdentity ( GetEmailIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeGetEmailIdentity ( request ) ; }
public E remove ( int location ) { try { ListIterator < E > it = listIterator ( location ) ; E result = it . next ( ) ; it . remove ( ) ; return result ; } catch ( NoSuchElementException e ) { throw new IndexOutOfBoundsException ( ) ; } }
public CanonicalTreeParser next ( ) { CanonicalTreeParser p = this ; for ( ; ; ) { if ( p . nextPtr == p . raw . length ) { if ( p . parent == null ) { p . currPtr = p . nextPtr ; return p ; } p = ( CanonicalTreeParser ) p . parent ; continue ; } p . prevPtr = p . currPtr ; p . currPtr = p . nextPtr ; p . parseEntry ( ) ; return p ; } }
public UpdateClusterConfigResult updateClusterConfig ( UpdateClusterConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateClusterConfig ( request ) ; }
public Point ( int x , int y ) { this . x = x ; this . y = y ; }
public void cloneStyleFrom ( ExtendedFormatRecord source ) { field_1_font_index = source . field_1_font_index ; field_2_format_index = source . field_2_format_index ; field_3_cell_options = source . field_3_cell_options ; field_4_alignment_options = source . field_4_alignment_options ; field_5_indention_options = source . field_5_indention_options ; field_6_border_options = source . field_6_border_options ; field_7_palette_options = source . field_7_palette_options ; field_8_adtl_palette_options = source . field_8_adtl_palette_options ; field_9_fill_palette_options = source . field_9_fill_palette_options ; }
public GetInvitationConfigurationResult getInvitationConfiguration ( GetInvitationConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInvitationConfiguration ( request ) ; }
public RevTag parseTag ( AnyObjectId id ) throws MissingObjectException , IncorrectObjectTypeException , IOException { RevObject c = parseAny ( id ) ; if ( ! ( c instanceof RevTag ) ) throw new IncorrectObjectTypeException ( id . toObjectId ( ) , Constants . TYPE_TAG ) ; return ( RevTag ) c ; }
public List < String > matchAlmost ( String key ) { return matchAlmost ( key , defaultNumReturnValues ) ; }
public boolean remove ( Object o ) { synchronized ( Hashtable . this ) { int oldSize = size ; Hashtable . this . remove ( o ) ; return size != oldSize ; } }
public StringEval ( String value ) { if ( value == null ) { throw new IllegalArgumentException ( " value ▁ must ▁ not ▁ be ▁ null " ) ; } _value = value ; }
public BatchGetOnPremisesInstancesResult batchGetOnPremisesInstances ( BatchGetOnPremisesInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetOnPremisesInstances ( request ) ; }
public void update ( Config rc ) { final List < String > vlst = new ArrayList <> ( ) ; vlst . clear ( ) ; for ( URIish u : getURIs ( ) ) vlst . add ( u . toPrivateString ( ) ) ; rc . setStringList ( SECTION , getName ( ) , KEY_URL , vlst ) ; vlst . clear ( ) ; for ( URIish u : getPushURIs ( ) ) vlst . add ( u . toPrivateString ( ) ) ; rc . setStringList ( SECTION , getName ( ) , KEY_PUSHURL , vlst ) ; vlst . clear ( ) ; for ( RefSpec u : getFetchRefSpecs ( ) ) vlst . add ( u . toString ( ) ) ; rc . setStringList ( SECTION , getName ( ) , KEY_FETCH , vlst ) ; vlst . clear ( ) ; for ( RefSpec u : getPushRefSpecs ( ) ) vlst . add ( u . toString ( ) ) ; rc . setStringList ( SECTION , getName ( ) , KEY_PUSH , vlst ) ; set ( rc , KEY_UPLOADPACK , getUploadPack ( ) , DEFAULT_UPLOAD_PACK ) ; set ( rc , KEY_RECEIVEPACK , getReceivePack ( ) , DEFAULT_RECEIVE_PACK ) ; set ( rc , KEY_TAGOPT , getTagOpt ( ) . option ( ) , TagOpt . AUTO_FOLLOW . option ( ) ) ; set ( rc , KEY_MIRROR , mirror , DEFAULT_MIRROR ) ; set ( rc , KEY_TIMEOUT , timeout , 0 ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ OBJ ] \ n " ) ; for ( final SubRecord record : subrecords ) { sb . append ( " SUBRECORD : ▁ " ) . append ( record ) ; } sb . append ( " [ / OBJ ] \ n " ) ; return sb . toString ( ) ; }
public StashCreateCommand setPerson ( PersonIdent person ) { this . person = person ; return this ; }
public GetDefaultCreditSpecificationResult getDefaultCreditSpecification ( GetDefaultCreditSpecificationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDefaultCreditSpecification ( request ) ; }
public static IntervalSet of ( int a ) { IntervalSet s = new IntervalSet ( ) ; s . add ( a ) ; return s ; }
public static int idealFloatArraySize ( int need ) { return idealByteArraySize ( need * 4 ) / 4 ; }
public GetJobManifestResult getJobManifest ( GetJobManifestRequest request ) { request = beforeClientExecution ( request ) ; return executeGetJobManifest ( request ) ; }
public ListGroupMembersResult listGroupMembers ( ListGroupMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeListGroupMembers ( request ) ; }
public CreateMatchmakingConfigurationResult createMatchmakingConfiguration ( CreateMatchmakingConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateMatchmakingConfiguration ( request ) ; }
public GetQueryResultsResult getQueryResults ( GetQueryResultsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetQueryResults ( request ) ; }
public int [ ] lookupSegmentation ( int phraseID ) { return segmentations [ phraseID ] ; }
public StartTextTranslationJobResult startTextTranslationJob ( StartTextTranslationJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStartTextTranslationJob ( request ) ; }
public final ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { double val ; try { ValueEval ve = OperandResolver . getSingleValue ( arg0 , srcRowIndex , srcColumnIndex ) ; val = OperandResolver . coerceValueToDouble ( ve ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } if ( val < 0 ) { return ErrorEval . NUM_ERROR ; } return new NumberEval ( getCalField ( val ) ) ; }
public GetAutoSnapshotsResult getAutoSnapshots ( GetAutoSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAutoSnapshots ( request ) ; }
public RestoreDBInstanceToPointInTimeRequest ( String sourceDBInstanceIdentifier , String targetDBInstanceIdentifier ) { setSourceDBInstanceIdentifier ( sourceDBInstanceIdentifier ) ; setTargetDBInstanceIdentifier ( targetDBInstanceIdentifier ) ; }
public boolean isDryRun ( ) { return dryRun ; }
public static boolean equals ( Object [ ] array1 , Object [ ] array2 ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1. length != array2. length ) { return false ; } for ( int i = 0 ; i < array1. length ; i ++ ) { Object e1 = array1 [ i ] , e2 = array2 [ i ] ; if ( ! ( e1 == null ? e2 == null : e1. equals ( e2 ) ) ) { return false ; } } return true ; }
public boolean isSame ( Formula other ) { return Arrays . equals ( _byteEncoding , other . _byteEncoding ) ; }
public ObjectId idFor ( TreeFormatter formatter ) { return formatter . computeId ( this ) ; }
public static int [ ] grow ( int [ ] array ) { return grow ( array , 1 + array . length ) ; }
public DescribeReservedDBInstancesResult describeReservedDBInstances ( DescribeReservedDBInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReservedDBInstances ( request ) ; }
public String toString ( ) { StringBuilder b = new StringBuilder ( ) ; b . append ( subs . length ) . append ( " ▁ subs : ▁ " ) ; for ( int i = 0 ; i < subs . length ; i ++ ) { if ( i != 0 ) { b . append ( " ; ▁ " ) ; } if ( subs [ i ] == null ) { b . append ( " s = " ) . append ( starts [ i ] ) . append ( " ▁ l = null " ) ; } else { b . append ( " s = " ) . append ( starts [ i ] ) . append ( " ▁ l = " ) . append ( subs [ i ] . length ( ) ) . append ( " ▁ b = " ) . append ( subs [ i ] ) ; } } b . append ( " ▁ end = " ) . append ( starts [ subs . length ] ) ; return b . toString ( ) ; }
public DescribeLogStreamsRequest ( String logGroupName ) { setLogGroupName ( logGroupName ) ; }
public static String [ ] getAll ( ) { return _formats . clone ( ) ; }
public CreateVoiceTemplateResult createVoiceTemplate ( CreateVoiceTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVoiceTemplate ( request ) ; }
public static long getLastCommitGeneration ( Directory directory ) throws IOException { return getLastCommitGeneration ( directory . listAll ( ) ) ; }
public SearchTransitGatewayRoutesResult searchTransitGatewayRoutes ( SearchTransitGatewayRoutesRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchTransitGatewayRoutes ( request ) ; }
public ListCompilationJobsResult listCompilationJobs ( ListCompilationJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListCompilationJobs ( request ) ; }
public static Query createJoinQuery ( String fromField , boolean multipleValuesPerDocument , String toField , Query fromQuery , IndexSearcher fromSearcher , ScoreMode scoreMode ) throws IOException { final GenericTermsCollector termsWithScoreCollector ; if ( multipleValuesPerDocument ) { Function < SortedSetDocValues > mvFunction = DocValuesTermsCollector . sortedSetDocValues ( fromField ) ; termsWithScoreCollector = GenericTermsCollector . createCollectorMV ( mvFunction , scoreMode ) ; } else { Function < BinaryDocValues > svFunction = DocValuesTermsCollector . binaryDocValues ( fromField ) ; termsWithScoreCollector = GenericTermsCollector . createCollectorSV ( svFunction , scoreMode ) ; } return createJoinQuery ( multipleValuesPerDocument , toField , fromQuery , fromField , fromSearcher , scoreMode , termsWithScoreCollector ) ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; System . arraycopy ( field_pictureData , 0 , data , offset + 4 , field_pictureData . length ) ; listener . afterRecordSerialize ( offset + 4 + field_pictureData . length , getRecordId ( ) , field_pictureData . length + 4 , this ) ; return field_pictureData . length + 4 ; }
public SeekStatus seekCeil ( BytesRef term ) { final int ord = findTerm ( term ) ; if ( ord >= 0 ) { termOrd = ord ; setTerm ( ) ; return SeekStatus . FOUND ; } else if ( ord == - terms . length - 1 ) { return SeekStatus . END ; } else { termOrd = - ord - 1 ; setTerm ( ) ; return SeekStatus . NOT_FOUND ; } }
public DeleteLoadBalancerResult deleteLoadBalancer ( DeleteLoadBalancerRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLoadBalancer ( request ) ; }
public DeleteVpcPeeringAuthorizationResult deleteVpcPeeringAuthorization ( DeleteVpcPeeringAuthorizationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVpcPeeringAuthorization ( request ) ; }
public SendAnnouncementResult sendAnnouncement ( SendAnnouncementRequest request ) { request = beforeClientExecution ( request ) ; return executeSendAnnouncement ( request ) ; }
@ Override public int lastIndexOf ( Object object ) { final int size ; final Object [ ] array ; synchronized ( mutex ) { size = list . size ( ) ; array = new Object [ size ] ; list . toArray ( array ) ; } if ( object != null ) { for ( int i = size - 1 ; i >= 0 ; i -- ) { if ( object . equals ( array [ i ] ) ) { return i ; } } } else { for ( int i = size - 1 ; i >= 0 ; i -- ) { if ( array [ i ] == null ) { return i ; } } } return - 1 ; }
public SortedDocValues getSortedDocValues ( String field ) { return getSortedDocValues ( field , DocValuesType . SORTED ) ; }
public void setBaseline ( ) { setBaseline ( clock . get ( ) ) ; }
public final IntBuffer put ( int [ ] src , int srcOffset , int intCount ) { throw new ReadOnlyBufferException ( ) ; }
public SortingBits ( final Bits in , Sorter . DocMap docMap ) { this . in = in ; this . docMap = docMap ; }
public static String quoteEscape ( String original ) { String result = original ; if ( result . indexOf ( ' \ " ' ) >= 0 ) { result = result . replace ( " \ " " , ESCAPED_QUOTE ) ; } if ( result . indexOf ( COMMA ) >= 0 ) { result = " \ " " + result + " \ " " ; } return result ; }
public static double fv ( double r , double n , double y , double p , boolean t ) { double retval = 0 ; if ( r == 0 ) { retval = - 1 * ( p + ( n * y ) ) ; } else { double r1 = r + 1 ; retval = ( ( 1 - Math . pow ( r1 , n ) ) * ( t ? r1 : 1 ) * y ) / r - p * Math . pow ( r1 , n ) ; } return retval ; }
public CharBuffer put ( int index , char c ) { throw new ReadOnlyBufferException ( ) ; }
public UpdateLifecyclePolicyResult updateLifecyclePolicy ( UpdateLifecyclePolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateLifecyclePolicy ( request ) ; }
public CreateNotebookInstanceLifecycleConfigResult createNotebookInstanceLifecycleConfig ( CreateNotebookInstanceLifecycleConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNotebookInstanceLifecycleConfig ( request ) ; }
public boolean add ( String text ) { return map . put ( text , PLACEHOLDER ) == null ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_axisType ) ; out . writeInt ( field_2_x ) ; out . writeInt ( field_3_y ) ; out . writeInt ( field_4_width ) ; out . writeInt ( field_5_height ) ; }
public GetJourneyResult getJourney ( GetJourneyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetJourney ( request ) ; }
public PrecedenceQueryNodeProcessorPipeline ( QueryConfigHandler queryConfig ) { super ( queryConfig ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { if ( get ( i ) . getClass ( ) . equals ( BooleanQuery2ModifierNodeProcessor . class ) ) { remove ( i -- ) ; } } add ( new BooleanModifiersQueryNodeProcessor ( ) ) ; }
public static boolean startsWith ( byte [ ] ref , BytesRef prefix ) { if ( ref . length < prefix . length ) { return false ; } return Arrays . equals ( ref , 0 , prefix . length , prefix . bytes , prefix . offset , prefix . offset + prefix . length ) ; }
public DeleteUsageReportSubscriptionResult deleteUsageReportSubscription ( DeleteUsageReportSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteUsageReportSubscription ( request ) ; }
public File [ ] listFiles ( FilenameFilter filter ) { return filenamesToFiles ( list ( filter ) ) ; }
public void respondActivityTaskFailed ( RespondActivityTaskFailedRequest request ) { request = beforeClientExecution ( request ) ; executeRespondActivityTaskFailed ( request ) ; }
public ListIdentitiesResult listIdentities ( ) { return listIdentities ( new ListIdentitiesRequest ( ) ) ; }
@ Override public int compare ( T o1 , T o2 ) { Comparable < T > c2 = ( Comparable < T > ) o2 ; return c2. compareTo ( o1 ) ; }
public ListFindingsResult listFindings ( ListFindingsRequest request ) { request = beforeClientExecution ( request ) ; return executeListFindings ( request ) ; }
public boolean contains ( final int o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( _array [ j ] == o ) { rval = true ; } } return rval ; }
public ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { if ( args . length < 2 ) { return ErrorEval . VALUE_INVALID ; } try { int ix = evaluateFirstArg ( args [ 0 ] , srcRowIndex , srcColumnIndex ) ; if ( ix < 1 || ix >= args . length ) { return ErrorEval . VALUE_INVALID ; } ValueEval result = OperandResolver . getSingleValue ( args [ ix ] , srcRowIndex , srcColumnIndex ) ; if ( result == MissingArgEval . instance ) { return BlankEval . instance ; } return result ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public DatRecord clone ( ) { return copy ( ) ; }
public GlobalReplicationGroup createGlobalReplicationGroup ( CreateGlobalReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateGlobalReplicationGroup ( request ) ; }
public String getText ( Interval interval ) { if ( interval . a < 0 || interval . b < interval . a - 1 ) { throw new IllegalArgumentException ( " invalid ▁ interval " ) ; } int bufferStartIndex = getBufferStartIndex ( ) ; if ( n > 0 && data [ n - 1 ] == Character . MAX_VALUE ) { if ( interval . a + interval . length ( ) > bufferStartIndex + n ) { throw new IllegalArgumentException ( " the ▁ interval ▁ extends ▁ past ▁ the ▁ end ▁ of ▁ the ▁ stream " ) ; } } if ( interval . a < bufferStartIndex || interval . b >= bufferStartIndex + n ) { throw new UnsupportedOperationException ( " interval ▁ " + interval + " ▁ outside ▁ buffer : ▁ " + bufferStartIndex + " .. " + ( bufferStartIndex + n - 1 ) ) ; } int i = interval . a - bufferStartIndex ; return new String ( data , i , interval . length ( ) ) ; }
public void addClass ( String chargroup ) { if ( chargroup . length ( ) > 0 ) { char equivChar = chargroup . charAt ( 0 ) ; char [ ] key = new char [ 2 ] ; key [ 1 ] = 0 ; for ( int i = 0 ; i < chargroup . length ( ) ; i ++ ) { key [ 0 ] = chargroup . charAt ( i ) ; classmap . insert ( key , 0 , equivChar ) ; } } }
public MultiPhraseQuery build ( ) { int [ ] positionsArray = new int [ this . positions . size ( ) ] ; for ( int i = 0 ; i < this . positions . size ( ) ; ++ i ) { positionsArray [ i ] = this . positions . get ( i ) ; } Term [ ] [ ] termArraysArray = termArrays . toArray ( new Term [ termArrays . size ( ) ] [ ] ) ; return new MultiPhraseQuery ( field , termArraysArray , positionsArray , slop ) ; }
public DFRSimilarity ( BasicModel basicModel , AfterEffect afterEffect , Normalization normalization ) { if ( basicModel == null || afterEffect == null || normalization == null ) { throw new NullPointerException ( " null ▁ parameters ▁ not ▁ allowed . " ) ; } this . basicModel = basicModel ; this . afterEffect = afterEffect ; this . normalization = normalization ; }
public ResetSnapshotAttributeRequest ( String snapshotId , SnapshotAttributeName attribute ) { setSnapshotId ( snapshotId ) ; setAttribute ( attribute . toString ( ) ) ; }
public V get ( CharSequence cs ) { if ( cs == null ) throw new NullPointerException ( ) ; return null ; }
public String getScheme ( ) { return scheme ; }
public void seekExact ( long ord ) { throw new UnsupportedOperationException ( ) ; }
public XPathElement ( String nodeName ) { this . nodeName = nodeName ; }
public DeleteAccountResult deleteAccount ( DeleteAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAccount ( request ) ; }
public boolean matches ( ParseTree tree , ParseTreePattern pattern ) { MultiMap < String , ParseTree > labels = new MultiMap < String , ParseTree > ( ) ; ParseTree mismatchedNode = matchImpl ( tree , pattern . getPatternTree ( ) , labels ) ; return mismatchedNode == null ; }
public PredictionContext get ( PredictionContext ctx ) { return cache . get ( ctx ) ; }
public SpotPlacement ( String availabilityZone ) { setAvailabilityZone ( availabilityZone ) ; }
public DescribeFleetInstancesResult describeFleetInstances ( DescribeFleetInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFleetInstances ( request ) ; }
public void setWorkingTreeIterator ( WorkingTreeIterator workingTreeIterator ) { this . workingTreeIterator = workingTreeIterator ; }
public static long pop_array ( long [ ] arr , int wordOffset , int numWords ) { long popCount = 0 ; for ( int i = wordOffset , end = wordOffset + numWords ; i < end ; ++ i ) { popCount += Long . bitCount ( arr [ i ] ) ; } return popCount ; }
public static FileKey lenient ( File directory , FS fs ) { final File gitdir = resolve ( directory , fs ) ; return new FileKey ( gitdir != null ? gitdir : directory , fs ) ; }
public ObjectWalk ( ObjectReader or , int depth ) { super ( or ) ; this . depth = depth ; this . deepenNots = Collections . emptyList ( ) ; this . UNSHALLOW = newFlag ( " UNSHALLOW " ) ; this . REINTERESTING = newFlag ( " REINTERESTING " ) ; this . DEEPEN_NOT = newFlag ( " DEEPEN □ NOT " ) ; }
public RegisterImageRequest ( String imageLocation ) { setImageLocation ( imageLocation ) ; }
public void write ( String s ) { reserve ( s . length ( ) ) ; s . getChars ( 0 , s . length ( ) , buf , len ) ; len += s . length ( ) ; }
public RefCountedRevision ( Revision revision ) { this . revision = revision ; }
public ListTagsForResourcesResult listTagsForResources ( ListTagsForResourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeListTagsForResources ( request ) ; }
public byte readByte ( ) { return bytes [ pos ++ ] ; }
public GlobalReplicationGroup deleteGlobalReplicationGroup ( DeleteGlobalReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteGlobalReplicationGroup ( request ) ; }
public IntBuffer asReadOnlyBuffer ( ) { return duplicate ( ) ; }
public DescribeFileSystemPolicyResult describeFileSystemPolicy ( DescribeFileSystemPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFileSystemPolicy ( request ) ; }
public ListAttributesResult listAttributes ( ListAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeListAttributes ( request ) ; }
public ModifyStrategyTargetRequest ( ) { super ( " aegis " , " 2016 - 11 - 11 " , " ModifyStrategyTarget " , " vipaegis " ) ; setMethod ( MethodType . POST ) ; }
public void removeFontRecord ( FontRecord rec ) { records . remove ( rec ) ; numfonts -- ; }
public static Class <? extends TokenFilterFactory > lookupClass ( String name ) { return loader . lookupClass ( name ) ; }
public void reset ( TermsEnum terms , BytesRef term ) { this . terms = terms ; current = term ; }
public LinkedDataRecord getDataValues ( ) { return dataValues ; }
public synchronized static DefaultProfile getProfile ( String regionId , ICredentialProvider icredential ) { profile = new DefaultProfile ( regionId , icredential ) ; return profile ; }
public ListFieldLevelEncryptionProfilesResult listFieldLevelEncryptionProfiles ( ListFieldLevelEncryptionProfilesRequest request ) { request = beforeClientExecution ( request ) ; return executeListFieldLevelEncryptionProfiles ( request ) ; }
public RegisterTaskDefinitionResult registerTaskDefinition ( RegisterTaskDefinitionRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterTaskDefinition ( request ) ; }
public String toString ( ) { return String . format ( " type ( % d ) " , type ) ; }
public DisableEnhancedMonitoringResult disableEnhancedMonitoring ( DisableEnhancedMonitoringRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableEnhancedMonitoring ( request ) ; }
public NodeHash ( FST < T > fst , FST . BytesReader in ) { table = new PagedGrowableWriter ( 16 , 1 << 27 , 8 , PackedInts . COMPACT ) ; mask = 15 ; this . fst = fst ; this . in = in ; }
public static final String toString ( ObjectId i ) { return i != null ? i . name ( ) : ZEROID_STR ; }
public LittleEndianOutput createDelayedOutput ( int size ) { return this ; }
public String toFormulaString ( FormulaRenderingWorkbook book ) { return book . getNameText ( this ) ; }
public String toString ( ) { return " < boost ▁ value = ' " ▁ + ▁ getValueString ( ) ▁ + ▁ " ' > " + " \ n " + getChild ( ) . toString ( ) + " \ n </ boost > " ; }
public ListTagsResult listTags ( ListTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTags ( request ) ; }
public ListTypeVersionsResult listTypeVersions ( ListTypeVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTypeVersions ( request ) ; }
public ObjectLinkRecord ( RecordInputStream in ) { field_1_anchorId = in . readShort ( ) ; field_2_link1 = in . readShort ( ) ; field_3_link2 = in . readShort ( ) ; }
public String getPromptText ( ) { return promptText ; }
public static String toLowerCase ( String in ) { final StringBuilder r = new StringBuilder ( in . length ( ) ) ; for ( int i = 0 ; i < in . length ( ) ; i ++ ) r . append ( toLowerCase ( in . charAt ( i ) ) ) ; return r . toString ( ) ; }
public static boolean isBeginRecord ( int sid ) { return sid == UserSViewBegin . sid ; }
public GetInstanceMetricDataResult getInstanceMetricData ( GetInstanceMetricDataRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInstanceMetricData ( request ) ; }
public void seekExact ( BytesRef target , TermState otherState ) { assert otherState != null && otherState instanceof BlockTermState ; assert ! doOrd || ( ( BlockTermState ) otherState ) . ord < numTerms ; state . copyFrom ( otherState ) ; seekPending = true ; indexIsCurrent = false ; term . copyBytes ( target ) ; }
public NGramDistance ( int size ) { this . n = size ; }
public AllocateConnectionOnInterconnectResult allocateConnectionOnInterconnect ( AllocateConnectionOnInterconnectRequest request ) { request = beforeClientExecution ( request ) ; return executeAllocateConnectionOnInterconnect ( request ) ; }
public StandardSyntaxParser ( CharStream stream ) { token_source = new StandardSyntaxParserTokenManager ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 25 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public void serialize ( LittleEndianOutput out ) { _range . serialize ( out ) ; serializeExtraData ( out ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { return isDefaultField ( field ) ? " / " + text + " / " : field + " :/ " + text + " / " ; }
public static boolean isRowBlockRecord ( int sid ) { switch ( sid ) { case RowRecord . sid : case BlankRecord . sid : case BoolErrRecord . sid : case FormulaRecord . sid : case LabelRecord . sid : case LabelSSTRecord . sid : case NumberRecord . sid : case RKRecord . sid : case ArrayRecord . sid : case SharedFormulaRecord . sid : case TableRecord . sid : return true ; } return false ; }
public static final int endOfParagraph ( byte [ ] b , int start ) { int ptr = start ; final int sz = b . length ; while ( ptr < sz && ( b [ ptr ] != ' \ n ' && b [ ptr ] != ' \ r ' ) ) ptr = nextLF ( b , ptr ) ; if ( ptr > start && b [ ptr - 1 ] == ' \ n ' ) ptr -- ; if ( ptr > start && b [ ptr - 1 ] == ' \ r ' ) ptr -- ; return ptr ; }
public VerifyDomainDkimResult verifyDomainDkim ( VerifyDomainDkimRequest request ) { request = beforeClientExecution ( request ) ; return executeVerifyDomainDkim ( request ) ; }
public boolean equals ( Object o ) { if ( o instanceof HSSFRichTextString ) { return _string . equals ( ( ( HSSFRichTextString ) o ) . _string ) ; } return false ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof RowColKey ) ) { return false ; } RowColKey other = ( RowColKey ) obj ; return _rowIndex == other . _rowIndex && _columnIndex == other . _columnIndex ; }
public GetIdentityPoolConfigurationResult getIdentityPoolConfiguration ( GetIdentityPoolConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIdentityPoolConfiguration ( request ) ; }
public DeleteTrafficMirrorFilterResult deleteTrafficMirrorFilter ( DeleteTrafficMirrorFilterRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTrafficMirrorFilter ( request ) ; }
public Bits readLiveDocs ( Directory dir , SegmentCommitInfo info , IOContext context ) throws IOException { assert info . hasDeletions ( ) ; BytesRefBuilder scratch = new BytesRefBuilder ( ) ; CharsRefBuilder scratchUTF16 = new CharsRefBuilder ( ) ; String fileName = IndexFileNames . fileNameFromGeneration ( info . info . name , LIVEDOCS_EXTENSION , info . getDelGen ( ) ) ; ChecksumIndexInput in = null ; boolean success = false ; try { in = dir . openChecksumInput ( fileName , context ) ; SimpleTextUtil . readLine ( in , scratch ) ; assert StringHelper . startsWith ( scratch . get ( ) , SIZE ) ; int size = parseIntAt ( scratch . get ( ) , SIZE . length , scratchUTF16 ) ; BitSet bits = new BitSet ( size ) ; SimpleTextUtil . readLine ( in , scratch ) ; while ( ! scratch . get ( ) . equals ( END ) ) { assert StringHelper . startsWith ( scratch . get ( ) , DOC ) ; int docid = parseIntAt ( scratch . get ( ) , DOC . length , scratchUTF16 ) ; bits . set ( docid ) ; SimpleTextUtil . readLine ( in , scratch ) ; } SimpleTextUtil . checkFooter ( in ) ; success = true ; return new SimpleTextBits ( bits , size ) ; } finally { if ( success ) { IOUtils . close ( in ) ; } else { IOUtils . closeWhileHandlingException ( in ) ; } } }
public CreateConferenceProviderResult createConferenceProvider ( CreateConferenceProviderRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateConferenceProvider ( request ) ; }
public SimpleQQParser ( String qqNames [ ] , String indexField ) { this . qqNames = qqNames ; this . indexField = indexField ; }
public boolean isCaseSensitive ( ) { return false ; }
public TokenFilter create ( TokenStream input ) { return new HyphenationCompoundWordTokenFilter ( input , hyphenator , dictionary , minWordSize , minSubwordSize , maxSubwordSize , onlyLongestMatch ) ; }
public TokenStream create ( TokenStream input ) { return new JapaneseBaseFormFilter ( input ) ; }
public OrderedATNConfigSet ( ) { this . configLookup = new LexerConfigHashSet ( ) ; }
public static ValueEval dereferenceResult ( ValueEval evaluationResult , int srcRowNum , int srcColNum ) { ValueEval value ; try { value = OperandResolver . getSingleValue ( evaluationResult , srcRowNum , srcColNum ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } if ( value == BlankEval . instance ) { return NumberEval . ZERO ; } return value ; }
public GetGroupRequest ( String groupName ) { setGroupName ( groupName ) ; }
public void narrowSearch ( int midIx , boolean isLessThan ) { if ( isLessThan ) { _highIx = midIx ; } else { _lowIx = midIx ; } }
public void set ( int index , long value ) { final int o = index >>> 1 ; final int b = index & 1 ; final int shift = b << 5 ; blocks [ o ] = ( blocks [ o ] & ~ ( 4294967295L << shift ) ) | ( value << shift ) ; }
public String toString ( ) { return cfAggregate . toString ( ) ; }
public void setConfig ( Config config ) { super . setConfig ( config ) ; random = new Random ( config . get ( " rand . seed " , 13 ) ) ; maxDocFacets = config . get ( " max . doc . facets " , 10 ) ; maxDims = config . get ( " max . doc . facets . dims " , 5 ) ; maxFacetDepth = config . get ( " max . facet . depth " , 3 ) ; if ( maxFacetDepth < 2 ) { throw new IllegalArgumentException ( " max . facet . depth ▁ must ▁ be ▁ at ▁ least ▁ 2 ; ▁ got : ▁ " + maxFacetDepth ) ; } maxValue = maxDocFacets * maxFacetDepth ; }
public interface Experiments extends SupportsCreating < Experiment . DefinitionStages . Blank > , HasInner < ExperimentsInner > { Observable < Experiment > getAsync ( String resourceGroupName , String workspaceName , String experimentName ) ; Observable < Experiment > listByWorkspaceAsync ( final String resourceGroupName , final String workspaceName ) ; Completable deleteAsync ( String resourceGroupName , String workspaceName , String experimentName ) ; }
public Builder add ( long l ) { if ( pending == null ) { throw new IllegalStateException ( " Cannot ▁ be ▁ reused ▁ after ▁ build ( ) " ) ; } if ( pendingOff == pending . length ) { if ( values . length == valuesOff ) { final int newLength = ArrayUtil . oversize ( valuesOff + 1 , 8 ) ; grow ( newLength ) ; } pack ( ) ; } pending [ pendingOff ++ ] = l ; size += 1 ; return this ; }
public static boolean isBuiltInFunctionName ( String name ) { short ix = FunctionMetadataRegistry . lookupIndexByName ( name . toUpperCase ( Locale . ROOT ) ) ; return ix >= 0 ; }
public void readBytes ( byte [ ] b , int offset , int len ) { while ( len > 0 ) { final int numLeft = limit - upto ; if ( numLeft < len ) { System . arraycopy ( buffer , upto , b , offset , numLeft ) ; offset += numLeft ; len -= numLeft ; nextSlice ( ) ; } else { System . arraycopy ( buffer , upto , b , offset , len ) ; upto += len ; break ; } } }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( CONCAT ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public ListResolverRuleAssociationsResult listResolverRuleAssociations ( ListResolverRuleAssociationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListResolverRuleAssociations ( request ) ; }
public TokenStream create ( TokenStream input ) { return new ApostropheFilter ( input ) ; }
public static String getExtension ( String name ) { int i = name . lastIndexOf ( ' . ' ) ; if ( i == - 1 ) { return " " ; } String ext = name . substring ( i + 1 ) ; if ( ext . equals ( " tmp " ) ) { Matcher matcher = EXT_PATTERN . matcher ( name . substring ( 0 , i + 1 ) ) ; if ( matcher . find ( ) ) { return matcher . group ( 1 ) ; } } return ext ; }
public static int getBuiltinFormat ( String pFmt ) { String fmt = " TEXT " . equalsIgnoreCase ( pFmt ) ? " @ " : pFmt ; int i = - 1 ; for ( String f : _formats ) { i ++ ; if ( f . equals ( fmt ) ) { return i ; } } return - 1 ; }
@ Override public int indexOf ( Object object ) { return list . indexOf ( object ) ; }
public void trimToSize ( ) { balance ( ) ; redimNodeArrays ( freenode ) ; CharVector kx = new CharVector ( ) ; kx . alloc ( 1 ) ; TernaryTree map = new TernaryTree ( ) ; compact ( kx , map , root ) ; kv = kx ; kv . trimToSize ( ) ; }
public GetRepoSyncTaskRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoSyncTask " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / syncTasks / [ SyncTaskId ] " ) ; setMethod ( MethodType . GET ) ; }
public ChangeMessageVisibilityRequest ( String queueUrl , String receiptHandle , Integer visibilityTimeout ) { setQueueUrl ( queueUrl ) ; setReceiptHandle ( receiptHandle ) ; setVisibilityTimeout ( visibilityTimeout ) ; }
public String toString ( ) { return " [ SAVERECALC ] \ n " + " ▁ ▁ ▁ ▁ . recalc ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + getRecalc ( ) + " \ n " + " [ / SAVERECALC ] \ n " ; }
public Status getStatus ( ) { return status ; }
public StartRepoBuildByRuleRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " StartRepoBuildByRule " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / rules / [ BuildRuleId ] / build " ) ; setMethod ( MethodType . PUT ) ; }
public ModifyAvailabilityZoneGroupResult modifyAvailabilityZoneGroup ( ModifyAvailabilityZoneGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyAvailabilityZoneGroup ( request ) ; }
public int compareSameType ( Object other ) { assert exists || 0 == value . length ( ) ; MutableValueStr b = ( MutableValueStr ) other ; int c = value . get ( ) . compareTo ( b . value . get ( ) ) ; if ( c != 0 ) return c ; if ( exists == b . exists ) return 0 ; return exists ? 1 : - 1 ; }
public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " " ; StringBuilder sb = new StringBuilder ( ) ; String filler = " " ; for ( QueryNode child : getChildren ( ) ) { sb . append ( filler ) . append ( child . toQueryString ( escapeSyntaxParser ) ) ; filler = " , " ; } return " [ TP [ " + sb . toString ( ) + " ] ] " ; }
public DescribeChangeSetResult describeChangeSet ( DescribeChangeSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeChangeSet ( request ) ; }
public static int initialize ( int seed ) { return seed ; }
public File getIdentityFile ( ) { return identityFile ; }
public String toString ( ) { String n = getClass ( ) . getName ( ) ; int lastDot = n . lastIndexOf ( ' . ' ) ; if ( lastDot >= 0 ) { n = n . substring ( lastDot + 1 ) ; } return n . replace ( ' $ ' , ' . ' ) ; }
public DeleteVoiceConnectorProxyResult deleteVoiceConnectorProxy ( DeleteVoiceConnectorProxyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVoiceConnectorProxy ( request ) ; }
public ByteArrayDataInput ( byte [ ] bytes ) { reset ( bytes ) ; }
public CreateLocalGatewayRouteResult createLocalGatewayRoute ( CreateLocalGatewayRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLocalGatewayRoute ( request ) ; }
public static int strlen ( char [ ] a , int start ) { int len = 0 ; for ( int i = start ; i < a . length && a [ i ] != 0 ; i ++ ) { len ++ ; } return len ; }
public AttachPolicyResult attachPolicy ( AttachPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachPolicy ( request ) ; }
public void print ( double dnum ) { print ( String . valueOf ( dnum ) ) ; }
public static BreakIterator getCharacterInstance ( ) { return getCharacterInstance ( Locale . getDefault ( ) ) ; }
public boolean add ( E object ) { throw new UnsupportedOperationException ( ) ; }
public SendMessageRequest ( String queueUrl , String messageBody ) { setQueueUrl ( queueUrl ) ; setMessageBody ( messageBody ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { try { AreaEval reA = evaluateRef ( arg0 ) ; AreaEval reB = evaluateRef ( arg1 ) ; return resolveRange ( reA , reB ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public CharBuffer put ( char [ ] src , int srcOffset , int charCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , charCount ) ; if ( charCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + charCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public void writeByte ( byte b ) { assert slice != null ; if ( slice [ upto ] != 0 ) { upto = pool . allocSlice ( slice , upto ) ; slice = pool . buffer ; offset0 = pool . byteOffset ; assert slice != null ; } slice [ upto ++ ] = b ; assert upto != slice . length ; }
public static double atanh ( double a ) { final double mult ; if ( Double . doubleToRawLongBits ( a ) < 0 ) { a = Math . abs ( a ) ; mult = - 0.5d ; } else { mult = 0.5d ; } return mult * Math . log ( ( 1.0d + a ) / ( 1.0d - a ) ) ; }
public static double asinh ( double a ) { final double sign ; if ( Double . doubleToRawLongBits ( a ) < 0 ) { a = Math . abs ( a ) ; sign = - 1.0d ; } else { sign = 1.0d ; } return sign * Math . log ( Math . sqrt ( a * a + 1.0d ) + a ) ; }
public FuzzyLikeThisQuery ( int maxNumTerms , Analyzer analyzer ) { this . analyzer = analyzer ; this . maxNumTerms = maxNumTerms ; }
public boolean precpred ( RuleContext localctx , int precedence ) { return precedence >= _precedenceStack . peek ( ) ; }
public UpdateStackResult updateStack ( UpdateStackRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateStack ( request ) ; }
public StartJumpserverRequest ( ) { super ( " HPC " , " 2016 - 06 - 03 " , " StartJumpserver " , " hpc " ) ; setMethod ( MethodType . POST ) ; }
public List < FastIgnoreRule > getRules ( ) { return Collections . unmodifiableList ( rules ) ; }
public RefMap ( ) { prefix = " " ; packed = RefList . emptyList ( ) ; loose = RefList . emptyList ( ) ; resolved = RefList . emptyList ( ) ; }
public Collection < ObjectId > getCandidates ( ) { return candidates ; }
public int get ( Object key ) { int index = findIndex ( key , keys ) ; if ( keys [ index ] == key ) { return values [ index ] ; } return - 1 ; }
public String toStringEscaped ( char [ ] enabledChars ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < this . length ( ) ; i ++ ) { if ( this . chars [ i ] == ' \\ ' ) ▁ { result . append ( ' \\ ' ) ; } else { for ( char character : enabledChars ) { if ( this . chars [ i ] == character && this . wasEscaped [ i ] ) { result . append ( ' \\ ' ) ; break ; } } } result . append ( this . chars [ i ] ) ; } return ▁ result . toString ( ) ; }
public DiffCommand setCached ( boolean cached ) { this . cached = cached ; return this ; }
public RevertCommand revert ( ) { return new RevertCommand ( repo ) ; }
@ Override public void clear ( ) { if ( size != 0 ) { Arrays . fill ( table , null ) ; entryForNullKey = null ; modCount ++ ; size = 0 ; } }
public static double log2 ( double x ) { return Math . log ( x ) / LOG_2 ; }
public boolean isHorizontalBorder ( ) { return horizontalBorder . isSet ( field_1_options ) ; }
public void validate ( ) throws IllegalArgumentException { if ( distErr != null && distErrPct != null ) throw new IllegalArgumentException ( " Only ▁ distErr ▁ or ▁ distErrPct ▁ can ▁ be ▁ specified . " ) ; }
public DeleteConfigurationSetResult deleteConfigurationSet ( DeleteConfigurationSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteConfigurationSet ( request ) ; }
public boolean incrementToken ( ) { if ( used ) { return false ; } clearAttributes ( ) ; termAttribute . append ( value ) ; offsetAttribute . setOffset ( 0 , value . length ( ) ) ; used = true ; return true ; }
public static DoubleBuffer wrap ( double [ ] array , int start , int doubleCount ) { Arrays . checkOffsetAndCount ( array . length , start , doubleCount ) ; DoubleBuffer buf = new ReadWriteDoubleArrayBuffer ( array ) ; buf . position = start ; buf . limit = start + doubleCount ; return buf ; }
public DescribeSpotInstanceRequestsResult describeSpotInstanceRequests ( DescribeSpotInstanceRequestsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSpotInstanceRequests ( request ) ; }
public UpdateFieldLevelEncryptionConfigResult updateFieldLevelEncryptionConfig ( UpdateFieldLevelEncryptionConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFieldLevelEncryptionConfig ( request ) ; }
public void setCachedResultTypeString ( ) { specialCachedValue = FormulaSpecialCachedValue . createForString ( ) ; }
public SpanNearBuilder ( SpanQueryBuilder factory ) { this . factory = factory ; }
public long ramBytesUsed ( ) { long sizeInBytes = 0 ; for ( Map . Entry < String , DirectField > entry : fields . entrySet ( ) ) { sizeInBytes += entry . getKey ( ) . length ( ) * Character . BYTES ; sizeInBytes += entry . getValue ( ) . ramBytesUsed ( ) ; } return sizeInBytes ; }
public GlobalCluster deleteGlobalCluster ( DeleteGlobalClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteGlobalCluster ( request ) ; }
public String toString ( ) { return type . getSimpleName ( ) + " [ " + listener + " ] " ; }
public void parseLine ( DocData docData , String line ) { int k1 = 0 ; int k2 = line . indexOf ( WriteLineDocTask . SEP , k1 ) ; if ( k2 < 0 ) { throw new RuntimeException ( " line : ▁ [ " + line + " ] ▁ is ▁ in ▁ an ▁ invalid ▁ format ▁ ( missing : ▁ separator ▁ title :: date ) ! " ) ; } docData . setTitle ( line . substring ( k1 , k2 ) ) ; k1 = k2 + 1 ; k2 = line . indexOf ( WriteLineDocTask . SEP , k1 ) ; if ( k2 < 0 ) { throw new RuntimeException ( " line : ▁ [ " + line + " ] ▁ is ▁ in ▁ an ▁ invalid ▁ format ▁ ( missing : ▁ separator ▁ date :: body ) ! " ) ; } docData . setDate ( line . substring ( k1 , k2 ) ) ; k1 = k2 + 1 ; k2 = line . indexOf ( WriteLineDocTask . SEP , k1 ) ; if ( k2 >= 0 ) { throw new RuntimeException ( " line : ▁ [ " + line + " ] ▁ is ▁ in ▁ an ▁ invalid ▁ format ▁ ( too ▁ many ▁ separators ) ! " ) ; } docData . setBody ( line . substring ( k1 ) ) ; }
public boolean isLarge ( ) { return false ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " TrackingRefUpdate [ " ) ; sb . append ( remoteName ) ; sb . append ( " ▁ -> ▁ " ) ; sb . append ( localName ) ; if ( forceUpdate ) sb . append ( " ▁ ( forced ) " ) ; sb . append ( " ▁ " ) ; sb . append ( oldObjectId == null ? " " : oldObjectId . abbreviate ( 7 ) . name ( ) ) ; sb . append ( " .. " ) ; sb . append ( newObjectId == null ? " " : newObjectId . abbreviate ( 7 ) . name ( ) ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public DescribeTerminationPolicyTypesResult describeTerminationPolicyTypes ( ) { return describeTerminationPolicyTypes ( new DescribeTerminationPolicyTypesRequest ( ) ) ; }
public DeleteTagsRequest ( ) { super ( " Ots " , " 2016 - 06 - 20 " , " DeleteTags " , " ots " ) ; setMethod ( MethodType . POST ) ; }
public ChartFormatRecord ( RecordInputStream in ) { field1_x_position = in . readInt ( ) ; field2_y_position = in . readInt ( ) ; field3_width = in . readInt ( ) ; field4_height = in . readInt ( ) ; field5_grbit = in . readUShort ( ) ; field6_unknown = in . readUShort ( ) ; }
public void dispatch ( IndexChangedListener listener ) { listener . onIndexChanged ( this ) ; }
public NameRecord cloneFilter ( int filterDbNameIndex , int newSheetIndex ) { NameRecord origNameRecord = getNameRecord ( filterDbNameIndex ) ; int newExtSheetIx = checkExternSheet ( newSheetIndex ) ; Ptg [ ] ptgs = origNameRecord . getNameDefinition ( ) ; for ( int i = 0 ; i < ptgs . length ; i ++ ) { Ptg ptg = ptgs [ i ] ; if ( ptg instanceof Area3DPtg ) { Area3DPtg a3p = ( Area3DPtg ) ( ( OperandPtg ) ptg ) . copy ( ) ; a3p . setExternSheetIndex ( newExtSheetIx ) ; ptgs [ i ] = a3p ; } else if ( ptg instanceof Ref3DPtg ) { Ref3DPtg r3p = ( Ref3DPtg ) ( ( OperandPtg ) ptg ) . copy ( ) ; r3p . setExternSheetIndex ( newExtSheetIx ) ; ptgs [ i ] = r3p ; } } NameRecord newNameRecord = createBuiltInName ( NameRecord . BUILTIN_FILTER_DB , newSheetIndex + 1 ) ; newNameRecord . setNameDefinition ( ptgs ) ; newNameRecord . setHidden ( true ) ; return newNameRecord ; }
public int read ( byte [ ] b ) throws IOException { int n = in . read ( b ) ; if ( n == - 1 ) { close ( ) ; } return n ; }
public void serializeArrayConstantData ( LittleEndianOutput out ) { int len = _byteEncoding . length - _encodedTokenLen ; out . write ( _byteEncoding , _encodedTokenLen , len ) ; }
public GetGcmChannelResult getGcmChannel ( GetGcmChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetGcmChannel ( request ) ; }
public long ramBytesUsed ( ) { return indexReader . ramBytesUsed ( ) ; }
public short getCalcMode ( ) { return field_1_calcmode ; }
public DeleteStreamResult deleteStream ( DeleteStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteStream ( request ) ; }
public DoubleBuffer put ( double [ ] src , int srcOffset , int doubleCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , doubleCount ) ; if ( doubleCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + doubleCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public RevokeSecurityGroupEgressResult revokeSecurityGroupEgress ( RevokeSecurityGroupEgressRequest request ) { request = beforeClientExecution ( request ) ; return executeRevokeSecurityGroupEgress ( request ) ; }
public CreateRepoWebhookRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " CreateRepoWebhook " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / webhooks " ) ; setMethod ( MethodType . PUT ) ; }
public int getCnt ( Character way ) { Cell c = at ( way ) ; return ( c == null ) ? - 1 : c . cnt ; }
public SortField [ ] getSort ( ) { return fields ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ BOF ▁ RECORD ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . version ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( getVersion ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . type ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( getType ( ) ) ) ; buffer . append ( " ▁ ( " ) . append ( getTypeName ( ) ) . append ( " ) " ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . build ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( getBuild ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . buildyear = ▁ " ) . append ( getBuildYear ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . history ▁ ▁ = ▁ " ) . append ( HexDump . intToHex ( getHistoryBitMask ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . reqver ▁ ▁ ▁ = ▁ " ) . append ( HexDump . intToHex ( getRequiredVersion ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / BOF ▁ RECORD ] \ n " ) ; return buffer . toString ( ) ; }
public DBInstance createDBInstance ( CreateDBInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBInstance ( request ) ; }
public CreateStackInstancesResult createStackInstances ( CreateStackInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateStackInstances ( request ) ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = 0 ; for ( EscherRecord r : this ) { remainingBytes += r . getRecordSize ( ) ; } remainingBytes += _remainingLength ; LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; int pos = offset + 8 ; for ( EscherRecord r : this ) { pos += r . serialize ( pos , data , listener ) ; } listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; }
public String toString ( ) { return " SnapshotDeletionPolicy . SnapshotCommitPoint ( " + cp + " ) " ; }
public MissingRecordAwareHSSFListener ( HSSFListener listener ) { resetCounts ( ) ; childListener = listener ; }
public int clear ( final int holder ) { return holder & ~ _mask ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( field_13_border_styles1 ) ; out . writeInt ( field_14_border_styles2 ) ; }
public void setParams ( String params ) { super . setParams ( params ) ; traversalSize = ( int ) Float . parseFloat ( params ) ; }
public String toStringTree ( List < String > ruleNames ) { return Trees . toStringTree ( this , ruleNames ) ; }
public HSSFTextbox createTextbox ( HSSFClientAnchor anchor ) { HSSFTextbox shape = new HSSFTextbox ( null , anchor ) ; addShape ( shape ) ; onCreate ( shape ) ; return shape ; }
public UpdateDevicePolicyConfigurationResult updateDevicePolicyConfiguration ( UpdateDevicePolicyConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDevicePolicyConfiguration ( request ) ; }
public float norm ( int passageStart ) { return 1 + 1 / ( float ) Math . log ( pivot + passageStart ) ; }
public Record nextRecord ( ) { Record r ; r = getNextUnreadRecord ( ) ; if ( r != null ) { return r ; } while ( true ) { if ( ! _recStream . hasNextRecord ( ) ) { return null ; } if ( _lastRecordWasEOFLevelZero ) { if ( _recStream . getNextSid ( ) != BOFRecord . sid ) { return null ; } } _recStream . nextRecord ( ) ; r = readNextRecord ( ) ; if ( r == null ) { continue ; } return r ; } }
public final FileDescriptor getFD ( ) throws IOException { return fd ; }
public MoveAlbumPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " MoveAlbumPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public UpdateStackSetResult updateStackSet ( UpdateStackSetRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateStackSet ( request ) ; }
public static double acosh ( double d ) { return Math . log ( Math . sqrt ( Math . pow ( d , 2 ) - 1 ) + d ) ; }
public int stem ( char s [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) switch ( s [ i ] ) { case ' ä ' : case ' à ' : case ' á ' : case ' â ' : s [ i ] = ' a ' ; break ; case ' ö ' : case ' ò ' : case ' ó ' : case ' ô ' : s [ i ] = ' o ' ; break ; case ' ï ' : case ' ì ' : case ' í ' : case ' î ' : s [ i ] = ' i ' ; break ; case ' ü ' : case ' ù ' : case ' ú ' : case ' û ' : s [ i ] = ' u ' ; break ; } len = step1 ( s , len ) ; return step2 ( s , len ) ; }
public CreateProposalResult createProposal ( CreateProposalRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateProposal ( request ) ; }
public boolean didFetchIncludeTags ( ) { return false ; }
public RevCommit peek ( ) { return head != null ? head . commit : null ; }
public HSSFBorderFormatting getBorderFormatting ( ) { return getBorderFormatting ( false ) ; }
public DeletedArea3DPtg ( int externSheetIndex ) { field_1_index_extern_sheet = externSheetIndex ; unused1 = 0 ; unused2 = 0 ; }
public SheetRecordCollector ( ) { _totalSize = 0 ; _list = new ArrayList <> ( 128 ) ; }
public RemovePermissionResult removePermission ( RemovePermissionRequest request ) { request = beforeClientExecution ( request ) ; return executeRemovePermission ( request ) ; }
public Cluster modifyClusterIamRoles ( ModifyClusterIamRolesRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyClusterIamRoles ( request ) ; }
public AreaFormatRecord ( RecordInputStream in ) { field_1_foregroundColor = in . readInt ( ) ; field_2_backgroundColor = in . readInt ( ) ; field_3_pattern = in . readShort ( ) ; field_4_formatFlags = in . readShort ( ) ; field_5_forecolorIndex = in . readShort ( ) ; field_6_backcolorIndex = in . readShort ( ) ; }
public int available ( ) { return _lei . available ( ) ; }
public final String toString ( ) { return toString ( " " ) ; }
public short setShort ( final short holder ) { return ( short ) set ( holder ) ; }
public synchronized void setFlushPending ( ThreadState perThread ) { assert ! perThread . flushPending ; if ( perThread . dwpt . getNumDocsInRAM ( ) > 0 ) { perThread . flushPending = true ; final long bytes = perThread . bytesUsed ; flushBytes += bytes ; activeBytes -= bytes ; numPending ++ ; assert assertMemory ( ) ; } }
public StringBuilder insert ( int offset , char [ ] ch ) { insert0 ( offset , ch ) ; return this ; }
public StoredField ( String name , double value ) { super ( name , TYPE ) ; fieldsData = value ; }
public String getName ( ) { return String . format ( Locale . ROOT , " Jelinek - Mercer ( % f ) " , getLambda ( ) ) ; }
public ReleaseAddressRequest ( String publicIp ) { setPublicIp ( publicIp ) ; }
public DeleteKeyPairResult deleteKeyPair ( DeleteKeyPairRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteKeyPair ( request ) ; }
public byte [ ] getColor ( int byteIndex ) { int i = byteIndex - FIRST_COLOR_INDEX ; if ( i < 0 || i >= _colors . size ( ) ) { return null ; } return _colors . get ( i ) . getTriplet ( ) ; }
public int indexOfValue ( E value ) { if ( mGarbage ) { gc ( ) ; } for ( int i = 0 ; i < mSize ; i ++ ) if ( mValues [ i ] == value ) return i ; return - 1 ; }
public URIish setScheme ( String n ) { final URIish r = new URIish ( this ) ; r . scheme = n ; return r ; }
public void print ( char [ ] charArray ) { print ( new String ( charArray , 0 , charArray . length ) ) ; }
public CommonToken ( int type , String text ) { this . type = type ; this . channel = DEFAULT_CHANNEL ; this . text = text ; this . source = EMPTY_SOURCE ; }
public final String toString ( ) { return field + " : " + text ( ) ; }
public LongBuffer compact ( ) { if ( byteBuffer . isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } byteBuffer . limit ( limit * SizeOf . LONG ) ; byteBuffer . position ( position * SizeOf . LONG ) ; byteBuffer . compact ( ) ; byteBuffer . clear ( ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public ATNSimulator ( ATN atn , PredictionContextCache sharedContextCache ) { this . atn = atn ; this . sharedContextCache = sharedContextCache ; }
public CachedOrdinalsReader ( OrdinalsReader source ) { this . source = source ; }
public static CompareResult valueOf ( boolean matches ) { if ( matches ) { return EQUAL ; } return LESS_THAN ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getVersion ( ) ) ; out . writeShort ( getType ( ) ) ; out . writeShort ( getBuild ( ) ) ; out . writeShort ( getBuildYear ( ) ) ; out . writeInt ( getHistoryBitMask ( ) ) ; out . writeInt ( getRequiredVersion ( ) ) ; }
public File getAbsoluteFile ( ) { return new File ( getAbsolutePath ( ) ) ; }
public DescribeTemplatePermissionsResult describeTemplatePermissions ( DescribeTemplatePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTemplatePermissions ( request ) ; }
public WorkflowExecutionCount countOpenWorkflowExecutions ( CountOpenWorkflowExecutionsRequest request ) { request = beforeClientExecution ( request ) ; return executeCountOpenWorkflowExecutions ( request ) ; }
public DescribeAccountLimitsResult describeAccountLimits ( ) { return describeAccountLimits ( new DescribeAccountLimitsRequest ( ) ) ; }
public Object get ( CharSequence key ) { if ( fst == null ) { return null ; } Arc < Long > arc = new Arc <> ( ) ; Long result = null ; try { result = lookupPrefix ( new BytesRef ( key ) , arc ) ; } catch ( IOException bogus ) { throw new RuntimeException ( bogus ) ; } if ( result == null || ! arc . isFinal ( ) ) { return null ; } else { return Integer . valueOf ( decodeWeight ( result + arc . nextFinalOutput ( ) ) ) ; } }
public CreateGameServerGroupResult createGameServerGroup ( CreateGameServerGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateGameServerGroup ( request ) ; }
public static boolean isInternalDateFormat ( int format ) { switch ( format ) { case 0x0e : case 0x0f : case 0x10 : case 0x11 : case 0x12 : case 0x13 : case 0x14 : case 0x15 : case 0x16 : case 0x2d : case 0x2e : case 0x2f : return true ; } return false ; }
public PackFile getPackFile ( ) { return newPack ; }
public CreateInternetGatewayResult createInternetGateway ( ) { return createInternetGateway ( new CreateInternetGatewayRequest ( ) ) ; }
public void drawPolyline ( int [ ] xPoints , int [ ] yPoints , int nPoints ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , " drawPolyline ▁ not ▁ supported " ) ; }
public void close ( ) { unpackedObjectCache . clear ( ) ; final PackList packs = packList . get ( ) ; if ( packs != NO_PACKS && packList . compareAndSet ( packs , NO_PACKS ) ) { for ( PackFile p : packs . packs ) p . close ( ) ; } AlternateHandle [ ] alt = alternates . get ( ) ; if ( alt != null && alternates . compareAndSet ( alt , null ) ) { for ( AlternateHandle od : alt ) od . close ( ) ; } }
public List < Token > getHiddenTokensToRight ( int tokenIndex , int channel ) { lazyInit ( ) ; if ( tokenIndex < 0 || tokenIndex >= tokens . size ( ) ) { throw new IndexOutOfBoundsException ( tokenIndex + " ▁ not ▁ in ▁ 0.. " + ( tokens . size ( ) - 1 ) ) ; } int nextOnChannel = nextTokenOnChannel ( tokenIndex + 1 , Lexer . DEFAULT_TOKEN_CHANNEL ) ; int to ; int from = tokenIndex + 1 ; if ( nextOnChannel == - 1 ) to = size ( ) - 1 ; else to = nextOnChannel ; return filterForChannel ( from , to , channel ) ; }
public int size ( ) { return Hashtable . this . size ( ) ; }
public CustomAvailabilityZone deleteCustomAvailabilityZone ( DeleteCustomAvailabilityZoneRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCustomAvailabilityZone ( request ) ; }
public BatchUnsuspendUserResult batchUnsuspendUser ( BatchUnsuspendUserRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchUnsuspendUser ( request ) ; }
public DeleteAccountSettingResult deleteAccountSetting ( DeleteAccountSettingRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAccountSetting ( request ) ; }
public static SemanticContext or ( SemanticContext a , SemanticContext b ) { if ( a == null ) return b ; if ( b == null ) return a ; if ( a == NONE || b == NONE ) return NONE ; OR result = new OR ( a , b ) ; if ( result . opnds . length == 1 ) { return result . opnds [ 0 ] ; } return result ; }
public ListHumanLoopsResult listHumanLoops ( ListHumanLoopsRequest request ) { request = beforeClientExecution ( request ) ; return executeListHumanLoops ( request ) ; }
public ValueEval evaluate ( ValueEval [ ] args , int srcCellRow , int srcCellCol ) { int maxN = args . length ; if ( maxN < 1 ) { return ErrorEval . VALUE_INVALID ; } ValueEval firstArg = args [ 0 ] ; try { if ( firstArg instanceof NumericValueEval ) { return evaluateSingleProduct ( args ) ; } if ( firstArg instanceof RefEval ) { return evaluateSingleProduct ( args ) ; } if ( firstArg instanceof TwoDEval ) { TwoDEval ae = ( TwoDEval ) firstArg ; if ( ae . isRow ( ) && ae . isColumn ( ) ) { return evaluateSingleProduct ( args ) ; } return evaluateAreaSumProduct ( args ) ; } } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } throw new RuntimeException ( " Invalid ▁ arg ▁ type ▁ for ▁ SUMPRODUCT : ▁ ( " + firstArg . getClass ( ) . getName ( ) + " ) " ) ; }
public DescribeParameterGroupsResult describeParameterGroups ( DescribeParameterGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeParameterGroups ( request ) ; }
public static char [ ] grow ( char [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Character . BYTES ) ) ; } else return array ; }
public double readDouble ( ) throws IOException { return primitiveTypes . readDouble ( ) ; }
public void setTokenSource ( TokenSource tokenSource ) { this . tokenSource = tokenSource ; tokens . clear ( ) ; p = - 1 ; fetchedEOF = false ; }
public void reset ( Parser recognizer ) { endErrorCondition ( recognizer ) ; }
public DescribeVpcPeeringAuthorizationsResult describeVpcPeeringAuthorizations ( DescribeVpcPeeringAuthorizationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcPeeringAuthorizations ( request ) ; }
public CreateDocumentationVersionResult createDocumentationVersion ( CreateDocumentationVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDocumentationVersion ( request ) ; }
public CreateClusterResult createCluster ( CreateClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCluster ( request ) ; }
public DoubleBuffer compact ( ) { if ( byteBuffer . isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } byteBuffer . limit ( limit * SizeOf . DOUBLE ) ; byteBuffer . position ( position * SizeOf . DOUBLE ) ; byteBuffer . compact ( ) ; byteBuffer . clear ( ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public int [ ] grow ( ) { final int [ ] ord = super . grow ( ) ; boost = ArrayUtil . grow ( boost , ord . length ) ; if ( termState . length < ord . length ) { TermStates [ ] tmpTermState = new TermStates [ ArrayUtil . oversize ( ord . length , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ] ; System . arraycopy ( termState , 0 , tmpTermState , 0 , termState . length ) ; termState = tmpTermState ; } assert termState . length >= ord . length && boost . length >= ord . length ; return ord ; }
public DefaultColWidthRecord ( RecordInputStream in ) { field_1_col_width = in . readUShort ( ) ; }
public GetAttributesResult getAttributes ( GetAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAttributes ( request ) ; }
public GetSubUserListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetSubUserList " , " cr " ) ; setUriPattern ( " / users / subAccount " ) ; setMethod ( MethodType . GET ) ; }
public void setQueryConfigHandler ( QueryConfigHandler queryConfigHandler ) { this . queryConfigHandler = queryConfigHandler ; }
public WindowCacheConfig ( ) { packedGitOpenFiles = 128 ; packedGitLimit = 10 * MB ; useStrongRefs = false ; packedGitWindowSize = 8 * KB ; packedGitMMAP = false ; deltaBaseCacheLimit = 10 * MB ; streamFileThreshold = PackConfig . DEFAULT_BIG_FILE_THRESHOLD ; }
public MutableFPNumber copy ( ) { return new MutableFPNumber ( _significand , _binaryExponent ) ; }
public ShortBuffer asReadOnlyBuffer ( ) { ShortToByteBufferAdapter buf = new ShortToByteBufferAdapter ( byteBuffer . asReadOnlyBuffer ( ) ) ; buf . limit = limit ; buf . position = position ; buf . mark = mark ; buf . byteBuffer . order = byteBuffer . order ; return buf ; }
public DescribeReservedCacheNodesResult describeReservedCacheNodes ( DescribeReservedCacheNodesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReservedCacheNodes ( request ) ; }
public ListOperationsResult listOperations ( ListOperationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListOperations ( request ) ; }
public SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialRequest ( ) { super ( " Domain - intl " , " 2017 - 12 - 18 " , " SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredential " , " domain " ) ; setMethod ( MethodType . POST ) ; }
public BatchReadResult batchRead ( BatchReadRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchRead ( request ) ; }
public InstanceProfileCredentials fetch ( int retryTimes ) throws ClientException { for ( int i = 0 ; i <= retryTimes ; i ++ ) { try { return fetch ( ) ; } catch ( ClientException e ) { if ( i == retryTimes ) { throw e ; } } } throw new ClientException ( " Failed ▁ to ▁ connect ▁ ECS ▁ Metadata ▁ Service : ▁ Max ▁ retry ▁ times ▁ exceeded . " ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex ) { Date now = new Date ( System . currentTimeMillis ( ) ) ; return new NumberEval ( DateUtil . getExcelDate ( now ) ) ; }
public static int idealIntArraySize ( int need ) { return idealByteArraySize ( need * 4 ) / 4 ; }
public long record ( IndexSearcher searcher ) throws IOException { ensureOpen ( ) ; final long version = ( ( DirectoryReader ) searcher . getIndexReader ( ) ) . getVersion ( ) ; SearcherTracker tracker = searchers . get ( version ) ; if ( tracker == null ) { tracker = new SearcherTracker ( searcher ) ; if ( searchers . putIfAbsent ( version , tracker ) != null ) { tracker . close ( ) ; } } else if ( tracker . searcher != searcher ) { throw new IllegalArgumentException ( " the ▁ provided ▁ searcher ▁ has ▁ the ▁ same ▁ underlying ▁ reader ▁ version ▁ yet ▁ the ▁ searcher ▁ instance ▁ differs ▁ from ▁ before ▁ ( new = " + searcher + " ▁ vs ▁ old = " + tracker . searcher ) ; } return version ; }
public ClassifyDocumentResult classifyDocument ( ClassifyDocumentRequest request ) { request = beforeClientExecution ( request ) ; return executeClassifyDocument ( request ) ; }
public GetIdentityPoolRolesResult getIdentityPoolRoles ( GetIdentityPoolRolesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIdentityPoolRoles ( request ) ; }
public CharSequence subSequence ( int start , int end ) { int newLength = end - start ; return new UnescapedCharSequence ( this . chars , this . wasEscaped , start , newLength ) ; }
public CreateDeploymentGroupResult createDeploymentGroup ( CreateDeploymentGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDeploymentGroup ( request ) ; }
public String toString ( ) { StringBuilder r = new StringBuilder ( ) ; r . append ( " Tag " ) ; r . append ( " = { \ n " ) ; r . append ( " object ▁ " ) ; r . append ( object != null ? object . name ( ) : " NOT □ SET " ) ; r . append ( " \ n " ) ; r . append ( " type ▁ " ) ; r . append ( object != null ? Constants . typeString ( type ) : " NOT □ SET " ) ; r . append ( " \ n " ) ; r . append ( " tag ▁ " ) ; r . append ( tag != null ? tag : " NOT □ SET " ) ; r . append ( " \ n " ) ; if ( tagger != null ) { r . append ( " tagger ▁ " ) ; r . append ( tagger ) ; r . append ( " \ n " ) ; } r . append ( " \ n " ) ; r . append ( message != null ? message : " " ) ; r . append ( " } " ) ; return r . toString ( ) ; }
public ET next ( ) { if ( expectedModCount == list . modCount ) { if ( hasNext ( ) ) { link = link . previous ; canRemove = true ; return link . data ; } throw new NoSuchElementException ( ) ; } throw new ConcurrentModificationException ( ) ; }
public boolean contains ( Object needle ) { if ( needle instanceof String ) { String n = ( String ) needle ; return names . containsKey ( n ) || names . containsKey ( StringUtils . toLowerCase ( n ) ) ; } return false ; }
public int set ( final int holder ) { return holder | _mask ; }
public void setContext ( int lineCount ) { if ( lineCount < 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . contextMustBeNonNegative ) ; context = lineCount ; }
public String getPath ( Side side ) { return side == Side . OLD ? getOldPath ( ) : getNewPath ( ) ; }
public DescribeAccessPointsResult describeAccessPoints ( DescribeAccessPointsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAccessPoints ( request ) ; }
public StringBuilder deleteCharAt ( int index ) { deleteCharAt0 ( index ) ; return this ; }
public int addSSTString ( UnicodeString string ) { LOG . log ( DEBUG , " insert ▁ to ▁ sst ▁ string = ' " , ▁ string ) ; if ▁ ( sst ▁ == ▁ null ) ▁ { insertSST ( ) ; } return ▁ sst . addString ( string ) ; }
public String outputToString ( TermData data ) { return data . toString ( ) ; }
public List < HSSFObjectData > getAllEmbeddedObjects ( ) { List < HSSFObjectData > objects = new ArrayList <> ( ) ; for ( HSSFSheet sheet : _sheets ) { getAllEmbeddedObjects ( sheet , objects ) ; } return Collections . unmodifiableList ( objects ) ; }
public DisableDirectoryResult disableDirectory ( DisableDirectoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableDirectory ( request ) ; }
public UpdateApiMappingResult updateApiMapping ( UpdateApiMappingRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateApiMapping ( request ) ; }
public StringBuffer insert ( int index , boolean b ) { return insert ( index , b ? " true " : " false " ) ; }
public UpdateConfigurationResult updateConfiguration ( UpdateConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateConfiguration ( request ) ; }
public synchronized StringBuffer replace ( int start , int end , String string ) { replace0 ( start , end , string ) ; return this ; }
public void decode ( long [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; for ( int shift = 60 ; shift >= 0 ; shift -= 4 ) { values [ valuesOffset ++ ] = ( int ) ( ( block >>> shift ) & 15 ) ; } } }
public synchronized void print ( String str ) { if ( out == null ) { setError ( ) ; return ; } if ( str == null ) { print ( " null " ) ; return ; } try { if ( encoding == null ) { write ( str . getBytes ( ) ) ; } else { write ( str . getBytes ( encoding ) ) ; } } catch ( IOException e ) { setError ( ) ; } }
@ Override public E set ( int index , E object ) { synchronized ( CopyOnWriteArrayList . this ) { slice . checkElementIndex ( index ) ; slice . checkConcurrentModification ( elements ) ; E result = CopyOnWriteArrayList . this . set ( index + slice . from , object ) ; slice = new Slice ( elements , slice . from , slice . to ) ; return result ; } }
public static void fill ( Object [ ] array , int start , int end , Object value ) { Arrays . checkStartAndEnd ( array . length , start , end ) ; for ( int i = start ; i < end ; i ++ ) { array [ i ] = value ; } }
public short checkExternSheet ( int firstSheetNumber , int lastSheetNumber ) { return ( short ) getOrCreateLinkTable ( ) . checkExternSheet ( firstSheetNumber , lastSheetNumber ) ; }
public DeleteClusterParameterGroupResult deleteClusterParameterGroup ( DeleteClusterParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteClusterParameterGroup ( request ) ; }
public GetTemplateResult getTemplate ( GetTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTemplate ( request ) ; }
public ByteBuffer put ( byte [ ] src , int srcOffset , int byteCount ) { throw new ReadOnlyBufferException ( ) ; }
public Note call ( ) throws GitAPIException { checkCallable ( ) ; NoteMap map = NoteMap . newEmptyMap ( ) ; RevCommit notesCommit = null ; try ( RevWalk walk = new RevWalk ( repo ) ; ObjectInserter inserter = repo . newObjectInserter ( ) ) { Ref ref = repo . findRef ( notesRef ) ; if ( ref != null ) { notesCommit = walk . parseCommit ( ref . getObjectId ( ) ) ; map = NoteMap . read ( walk . getObjectReader ( ) , notesCommit ) ; } map . set ( id , message , inserter ) ; commitNoteMap ( repo , notesRef , walk , map , notesCommit , inserter , " Notes ▁ added ▁ by ▁ ' git notes add ' " ) ; return map . getNote ( id ) ; } catch ( IOException e ) { throw new JGitInternalException ( e . getMessage ( ) , e ) ; } }
public DeleteNodegroupResult deleteNodegroup ( DeleteNodegroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNodegroup ( request ) ; }
public final boolean hasRemaining ( ) { return position < limit ; }
public final int compareTo ( AnyObjectId other ) { if ( this == other ) return 0 ; int cmp ; cmp = NB . compareUInt32 ( w1 , other . w1 ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w2 , other . w2 ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w3 , other . w3 ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w4 , other . w4 ) ; if ( cmp != 0 ) return cmp ; return NB . compareUInt32 ( w5 , other . w5 ) ; }
public static IntBuffer wrap ( int [ ] array ) { return wrap ( array , 0 , array . length ) ; }
public ObjectId getNewId ( ) { return newId ; }
public DescribeBrokerInstanceOptionsResult describeBrokerInstanceOptions ( DescribeBrokerInstanceOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeBrokerInstanceOptions ( request ) ; }
public GetDASHStreamingSessionURLResult getDASHStreamingSessionURL ( GetDASHStreamingSessionURLRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDASHStreamingSessionURL ( request ) ; }
public CancelJobResult cancelJob ( CancelJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelJob ( request ) ; }
public ListExperimentsResult listExperiments ( ListExperimentsRequest request ) { request = beforeClientExecution ( request ) ; return executeListExperiments ( request ) ; }
public CreateSubnetGroupResult createSubnetGroup ( CreateSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSubnetGroup ( request ) ; }
public String toString ( ) { return " scorer ( " + weight + " ) [ " + super . toString ( ) + " ] " ; }
public Executor getExecutor ( ) { return executor ; }
public void write ( LittleEndianOutput out ) { throw invalid ( ) ; }
public StandardQueryParser ( Analyzer analyzer ) { this ( ) ; this . setAnalyzer ( analyzer ) ; }
public IndexedUDFFinder ( UDFFinder ... usedToolPacks ) { super ( usedToolPacks ) ; _funcMap = new HashMap <> ( ) ; }
public static int countMatchingCellsInRef ( RefEval refEval , I_MatchPredicate criteriaPredicate ) { int result = 0 ; final int firstSheetIndex = refEval . getFirstSheetIndex ( ) ; final int lastSheetIndex = refEval . getLastSheetIndex ( ) ; for ( int sIx = firstSheetIndex ; sIx <= lastSheetIndex ; sIx ++ ) { ValueEval ve = refEval . getInnerValueEval ( sIx ) ; if ( criteriaPredicate . matches ( ve ) ) { result ++ ; } } return result ; }
public NameXPxg ( int externalWorkbookNumber , String sheetName , String nameName ) { this . externalWorkbookNumber = externalWorkbookNumber ; this . sheetName = sheetName ; this . nameName = nameName ; }
public MergeInfo ( int totalMaxDoc , long estimatedMergeBytes , boolean isExternal , int mergeMaxNumSegments ) { this . totalMaxDoc = totalMaxDoc ; this . estimatedMergeBytes = estimatedMergeBytes ; this . isExternal = isExternal ; this . mergeMaxNumSegments = mergeMaxNumSegments ; }
public HsmClientCertificate createHsmClientCertificate ( CreateHsmClientCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateHsmClientCertificate ( request ) ; }
public Token consume ( ) { Token o = getCurrentToken ( ) ; if ( o . getType ( ) != EOF ) { getInputStream ( ) . consume ( ) ; } boolean hasListener = _parseListeners != null && ! _parseListeners . isEmpty ( ) ; if ( _buildParseTrees || hasListener ) { if ( _errHandler . inErrorRecoveryMode ( this ) ) { ErrorNode node = _ctx . addErrorNode ( createErrorNode ( _ctx , o ) ) ; if ( _parseListeners != null ) { for ( ParseTreeListener listener : _parseListeners ) { listener . visitErrorNode ( node ) ; } } } else { TerminalNode node = _ctx . addChild ( createTerminalNode ( _ctx , o ) ) ; if ( _parseListeners != null ) { for ( ParseTreeListener listener : _parseListeners ) { listener . visitTerminal ( node ) ; } } } } return o ; }
public boolean seekExact ( BytesRef term ) { final int ord = findTerm ( term ) ; if ( ord >= 0 ) { termOrd = ord ; setTerm ( ) ; return true ; } else { return false ; } }
public DescribeEgressOnlyInternetGatewaysResult describeEgressOnlyInternetGateways ( DescribeEgressOnlyInternetGatewaysRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEgressOnlyInternetGateways ( request ) ; }
public Ref getLeaf ( ) { Ref dst = getTarget ( ) ; while ( dst . isSymbolic ( ) ) dst = dst . getTarget ( ) ; return dst ; }
public void ReInit ( QueryParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public ListStacksResult listStacks ( ) { return listStacks ( new ListStacksRequest ( ) ) ; }
public PutInstancePublicPortsResult putInstancePublicPorts ( PutInstancePublicPortsRequest request ) { request = beforeClientExecution ( request ) ; return executePutInstancePublicPorts ( request ) ; }
public GetConfigurationSetResult getConfigurationSet ( GetConfigurationSetRequest request ) { request = beforeClientExecution ( request ) ; return executeGetConfigurationSet ( request ) ; }
public static Element getFirstChildOrFail ( Element e ) throws ParserException { Element kid = getFirstChildElement ( e ) ; if ( null == kid ) { throw new ParserException ( e . getTagName ( ) + " ▁ does ▁ not ▁ contain ▁ a ▁ child ▁ element " ) ; } return kid ; }
public String toString ( ) { return " Cell ( readerIndex = " + readerIndex + " ▁ nodeID = " + index . getNodeID ( ) + " ▁ isLeaf = " + index . isLeafNode ( ) + " ▁ distanceSquared = " + distanceSquared + " ) " ; }
public static long getBaseSize ( byte [ ] delta ) { int p = 0 ; long baseLen = 0 ; int c , shift = 0 ; do { c = delta [ p ++ ] & 0xff ; baseLen |= ( ( long ) ( c & 0x7f ) ) << shift ; shift += 7 ; } while ( ( c & 0x80 ) != 0 ) ; return baseLen ; }
public VerifyEmailIdentityResult verifyEmailIdentity ( VerifyEmailIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeVerifyEmailIdentity ( request ) ; }
public CreateInvalidationResult createInvalidation ( CreateInvalidationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateInvalidation ( request ) ; }
public ListGroupsForUserRequest ( String userName ) { setUserName ( userName ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( field_1_stream_pos ) ; out . writeShort ( field_2_bucket_sst_offset ) ; out . writeShort ( field_3_zero ) ; }
public boolean equals ( Object o ) { if ( QueryValueSource . class != o . getClass ( ) ) return false ; QueryValueSource other = ( QueryValueSource ) o ; return this . q . equals ( other . q ) && this . defVal == other . defVal ; }
public boolean add ( E object ) { add ( size ( ) , object ) ; return true ; }
public synchronized SessionToken checkForUpdate ( String currentVersion ) { ensureOpen ( ) ; if ( currentRevision == null ) { return null ; } if ( currentVersion != null && currentRevision . revision . compareTo ( currentVersion ) <= 0 ) { return null ; } currentRevision . incRef ( ) ; final String sessionID = Integer . toString ( sessionToken . incrementAndGet ( ) ) ; final SessionToken sessionToken = new SessionToken ( sessionID , currentRevision . revision ) ; final ReplicationSession timedSessionToken = new ReplicationSession ( sessionToken , currentRevision ) ; sessions . put ( sessionID , timedSessionToken ) ; return sessionToken ; }
public void setCommitNames ( String [ ] commitNames ) { this . commitNames = commitNames ; }
public FormulaRecordAggregate createFormula ( int row , int col ) { FormulaRecord fr = new FormulaRecord ( ) ; fr . setRow ( row ) ; fr . setColumn ( ( short ) col ) ; return new FormulaRecordAggregate ( fr , null , _sharedValueManager ) ; }
public DetectSyntaxResult detectSyntax ( DetectSyntaxRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectSyntax ( request ) ; }
public ValueEval evaluate ( ValueEval [ ] args , OperationEvaluationContext ec ) { if ( args . length < 2 || args . length > 3 ) { return ErrorEval . VALUE_INVALID ; } int srcCellRow = ec . getRowIndex ( ) ; int srcCellCol = ec . getColumnIndex ( ) ; double start , end ; double [ ] holidays ; try { start = this . evaluator . evaluateDateArg ( args [ 0 ] , srcCellRow , srcCellCol ) ; end = this . evaluator . evaluateDateArg ( args [ 1 ] , srcCellRow , srcCellCol ) ; if ( start > end ) { return ErrorEval . NAME_INVALID ; } ValueEval holidaysCell = args . length == 3 ? args [ 2 ] : null ; holidays = this . evaluator . evaluateDatesArg ( holidaysCell , srcCellRow , srcCellCol ) ; return new NumberEval ( WorkdayCalculator . instance . calculateWorkdays ( start , end , holidays ) ) ; } catch ( EvaluationException e ) { return ErrorEval . VALUE_INVALID ; } }
public HSSFDataValidationHelper ( HSSFSheet sheet ) { super ( ) ; }
public SyncFacePicturesRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " SyncFacePictures " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public static String shortToHex ( int value ) { StringBuilder sb = new StringBuilder ( 6 ) ; writeHex ( sb , value & 0xFFFFL , 4 , " 0x " ) ; return sb . toString ( ) ; }
public String toString ( ) { switch ( state ) { case SET : return key ; case UNSET : return " - " + key ; case UNSPECIFIED : return " ! " + key ; case CUSTOM : default : return key + " = " + value ; } }
public void seek ( int index ) { lazyInit ( ) ; p = adjustSeekIndex ( index ) ; }
public CreateTransitGatewayPeeringAttachmentResult createTransitGatewayPeeringAttachment ( CreateTransitGatewayPeeringAttachmentRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTransitGatewayPeeringAttachment ( request ) ; }
public static BytesRef deepCopyOf ( BytesRef other ) { return new BytesRef ( ArrayUtil . copyOfSubArray ( other . bytes , other . offset , other . offset + other . length ) , 0 , other . length ) ; }
public TokenCollector ( int tokenCount ) { _ptgs = new Ptg [ tokenCount ] ; _offset = 0 ; }
public static String [ ] tokenize ( String format ) { List < String > result = new ArrayList <> ( ) ; DateFormatTokenizer tokenizer = new DateFormatTokenizer ( format ) ; String token ; while ( ( token = tokenizer . getNextToken ( ) ) != null ) { result . add ( token ) ; } return result . toArray ( new String [ 0 ] ) ; }
public DescribeNatGatewaysResult describeNatGateways ( DescribeNatGatewaysRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNatGateways ( request ) ; }
public ResetImageAttributeResult resetImageAttribute ( ResetImageAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeResetImageAttribute ( request ) ; }
public void setHorizontalBorder ( boolean value ) { field_1_options = horizontalBorder . setShortBoolean ( field_1_options , value ) ; }
public ReplicationGroup modifyReplicationGroup ( ModifyReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyReplicationGroup ( request ) ; }
public boolean containsKey ( CharSequence cs ) { if ( cs == null ) throw new NullPointerException ( ) ; return false ; }
public GetIntegrationsResult getIntegrations ( GetIntegrationsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIntegrations ( request ) ; }
public LabelRecord ( RecordInputStream in ) { field_1_row = in . readUShort ( ) ; field_2_column = in . readShort ( ) ; field_3_xf_index = in . readShort ( ) ; field_4_string_len = in . readShort ( ) ; field_5_unicode_flag = in . readByte ( ) ; if ( field_4_string_len > 0 ) { if ( isUnCompressedUnicode ( ) ) { field_6_value = in . readUnicodeLEString ( field_4_string_len ) ; } else { field_6_value = in . readCompressedUnicode ( field_4_string_len ) ; } } else { field_6_value = " " ; } if ( in . remaining ( ) > 0 ) { logger . log ( POILogger . INFO , " LabelRecord ▁ data ▁ remains : ▁ " + in . remaining ( ) + " ▁ : ▁ " + HexDump . toHex ( in . readRemainder ( ) ) ) ; } }
public SubmoduleAddCommand setProgressMonitor ( ProgressMonitor monitor ) { this . monitor = monitor ; return this ; }
public byte readByte ( ) { if ( currentBlockUpto == blockSize ) { nextBlock ( ) ; } return currentBlock [ currentBlockUpto ++ ] ; }
public TestAlarmResult testAlarm ( TestAlarmRequest request ) { request = beforeClientExecution ( request ) ; return executeTestAlarm ( request ) ; }
public void clear ( ) { HashMap . this . clear ( ) ; }
public void visitContainedRecords ( RecordVisitor rv ) { int nRegions = _mergedRegions . size ( ) ; if ( nRegions < 1 ) { return ; } int nFullMergedCellsRecords = nRegions / MAX_MERGED_REGIONS ; int nLeftoverMergedRegions = nRegions % MAX_MERGED_REGIONS ; CellRangeAddress [ ] cras = new CellRangeAddress [ nRegions ] ; _mergedRegions . toArray ( cras ) ; for ( int i = 0 ; i < nFullMergedCellsRecords ; i ++ ) { int startIx = i * MAX_MERGED_REGIONS ; rv . visitRecord ( new MergeCellsRecord ( cras , startIx , MAX_MERGED_REGIONS ) ) ; } if ( nLeftoverMergedRegions > 0 ) { int startIx = nFullMergedCellsRecords * MAX_MERGED_REGIONS ; rv . visitRecord ( new MergeCellsRecord ( cras , startIx , nLeftoverMergedRegions ) ) ; } }
public CharArrayWriter ( ) { buf = new char [ 32 ] ; lock = buf ; }
public SendEmailRequest ( String source , Destination destination , Message message ) { setSource ( source ) ; setDestination ( destination ) ; setMessage ( message ) ; }
public DescribeReservedNodesResult describeReservedNodes ( ) { return describeReservedNodes ( new DescribeReservedNodesRequest ( ) ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ PROTECT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . options ▁ = ▁ " ) . append ( HexDump . shortToHex ( _options ) ) . append ( " \ n " ) ; buffer . append ( " [ / PROTECT ] \ n " ) ; return buffer . toString ( ) ; }
public String getSignerType ( ) { return " PRIVATEKEY " ; }
public StopProjectVersionResult stopProjectVersion ( StopProjectVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeStopProjectVersion ( request ) ; }
public CacheCluster createCacheCluster ( CreateCacheClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCacheCluster ( request ) ; }
public boolean equals ( Object _other ) { if ( ( _other instanceof LabelAndValue ) == false ) { return false ; } LabelAndValue other = ( LabelAndValue ) _other ; return label . equals ( other . label ) && value . equals ( other . value ) ; }
public JobFlowInstancesDetail ( String masterInstanceType , String slaveInstanceType , Integer instanceCount ) { setMasterInstanceType ( masterInstanceType ) ; setSlaveInstanceType ( slaveInstanceType ) ; setInstanceCount ( instanceCount ) ; }
public boolean stem ( ) { r_mark_regions ( ) ; limit_backward = cursor ; cursor = limit ; int v_2 = limit - cursor ; r_attached_pronoun ( ) ; cursor = limit - v_2 ; int v_3 = limit - cursor ; lab0 : { lab1 : { int v_4 = limit - cursor ; lab2 : { if ( ! r_standard_suffix ( ) ) { break lab2 ; } break lab1 ; } cursor = limit - v_4 ; if ( ! r_verb_suffix ( ) ) { break lab0 ; } } } cursor = limit - v_3 ; int v_5 = limit - cursor ; r_residual_suffix ( ) ; cursor = limit - v_5 ; cursor = limit_backward ; int v_6 = cursor ; r_cleaning ( ) ; cursor = v_6 ; return true ; }
public HSSFPictureData ( EscherBlipRecord blip ) { this . blip = blip ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ PALETTE ] \ n " ) ; buffer . append ( " ▁ ▁ numcolors ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( _colors . size ( ) ) . append ( ' \ n ' ) ; for ( int i = 0 ; i < _colors . size ( ) ; i ++ ) { PColor c = _colors . get ( i ) ; buffer . append ( " * ▁ colornum ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( i ) . append ( ' \ n ' ) ; buffer . append ( c ) ; buffer . append ( " " ) ; } }
public String [ ] list ( FilenameFilter filter ) { String [ ] filenames = list ( ) ; if ( filter == null || filenames == null ) { return filenames ; } List < String > result = new ArrayList < String > ( filenames . length ) ; for ( String filename : filenames ) { if ( filter . accept ( this , filename ) ) { result . add ( filename ) ; } } return result . toArray ( new String [ result . size ( ) ] ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { String arg ; int index ; try { arg = evaluateStringArg ( arg0 , srcRowIndex , srcColumnIndex ) ; index = evaluateIntArg ( arg1 , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } if ( index < 0 ) { return ErrorEval . VALUE_INVALID ; } String result ; if ( _isLeft ) { result = arg . substring ( 0 , Math . min ( arg . length ( ) , index ) ) ; } else { result = arg . substring ( Math . max ( 0 , arg . length ( ) - index ) ) ; } return new StringEval ( result ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( sid ) ; out . writeShort ( reserved . length ) ; out . write ( reserved ) ; }
public HadoopJarStepConfig ( String jar ) { setJar ( jar ) ; }
public CharArrayWriter append ( char c ) { write ( c ) ; return this ; }
public GetChannelsResult getChannels ( GetChannelsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetChannels ( request ) ; }
public File getParentFile ( ) { String tempParent = getParent ( ) ; if ( tempParent == null ) { return null ; } return new File ( tempParent ) ; }
public URI resolve ( String relative ) { return resolve ( create ( relative ) ) ; }
public static IntervalSet of ( int a , int b ) { IntervalSet s = new IntervalSet ( ) ; s . add ( a , b ) ; return s ; }
public void setCompressionLevel ( int level ) { compressionLevel = level ; }
public void reset ( ) { offset = 0 ; length = 0 ; lastTrailingHighSurrogate = 0 ; }
public AttributeValue ( String s ) { setS ( s ) ; }
public Token ( int kind , String image ) { this . kind = kind ; this . image = image ; }
public XmlSerializer newSerializer ( ) throws XmlPullParserException { if ( serializerClasses == null ) { throw new XmlPullParserException ( " Factory ▁ initialization ▁ incomplete ▁ - ▁ has ▁ not ▁ tried ▁ " + classNamesLocation ) ; } if ( serializerClasses . size ( ) == 0 ) { throw new XmlPullParserException ( " No ▁ valid ▁ serializer ▁ classes ▁ found ▁ in ▁ " + classNamesLocation ) ; } final StringBuilder issues = new StringBuilder ( ) ; for ( int i = 0 ; i < serializerClasses . size ( ) ; i ++ ) { final Class ppClass = ( Class ) serializerClasses . get ( i ) ; try { final XmlSerializer ser = ( XmlSerializer ) ppClass . newInstance ( ) ; return ser ; } catch ( Exception ex ) { issues . append ( ppClass . getName ( ) + " : ▁ " + ex . toString ( ) + " ; ▁ " ) ; } } throw new XmlPullParserException ( " could ▁ not ▁ create ▁ serializer : ▁ " + issues ) ; }
public UpdateDomainContactPrivacyResult updateDomainContactPrivacy ( UpdateDomainContactPrivacyRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDomainContactPrivacy ( request ) ; }
public String toString ( String enc ) throws UnsupportedEncodingException { return new String ( buf , 0 , count , enc ) ; }
public DescribeStaleSecurityGroupsResult describeStaleSecurityGroups ( DescribeStaleSecurityGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStaleSecurityGroups ( request ) ; }
public DisassociateWebsiteCertificateAuthorityResult disassociateWebsiteCertificateAuthority ( DisassociateWebsiteCertificateAuthorityRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateWebsiteCertificateAuthority ( request ) ; }
public DeleteTransitGatewayVpcAttachmentResult deleteTransitGatewayVpcAttachment ( DeleteTransitGatewayVpcAttachmentRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTransitGatewayVpcAttachment ( request ) ; }
public ObjectId idFor ( TreeFormatter formatter ) { return formatter . computeId ( this ) ; }
public static boolean startsWith ( char s [ ] , int len , String prefix ) { final int prefixLen = prefix . length ( ) ; if ( prefixLen > len ) return false ; for ( int i = 0 ; i < prefixLen ; i ++ ) if ( s [ i ] != prefix . charAt ( i ) ) return false ; return true ; }
public UpdateBatchPredictionResult updateBatchPrediction ( UpdateBatchPredictionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateBatchPrediction ( request ) ; }
public final void remove ( RevFlag flag ) { flags &= ~ flag . mask ; }
public void SwitchTo ( int lexState ) { if ( lexState >= 2 || lexState < 0 ) throw new TokenMgrError ( " Error : ▁ Ignoring ▁ invalid ▁ lexical ▁ state ▁ : ▁ " + lexState + " . ▁ State ▁ unchanged . " , TokenMgrError . INVALID_LEXICAL_STATE ) ; elsecurLexState = lexState ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( " [ ArrayPtg ] \ n " ) ; sb . append ( " nRows ▁ = ▁ " ) . append ( getRowCount ( ) ) . append ( " \ n " ) ; sb . append ( " nCols ▁ = ▁ " ) . append ( getColumnCount ( ) ) . append ( " \ n " ) ; if ( _arrayValues == null ) { sb . append ( " ▁ ▁ # values # uninitialised #\ n " ) ; } else { sb . append ( " ▁ ▁ " ) . append ( toFormulaString ( ) ) ; } return sb . toString ( ) ; }
public ObjectId getHeadId ( ) { return headId ; }
public GetAssociatedIpv6PoolCidrsResult getAssociatedIpv6PoolCidrs ( GetAssociatedIpv6PoolCidrsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAssociatedIpv6PoolCidrs ( request ) ; }
public void copyValue ( Cell destCell ) { switch ( _cellType ) { case BLANK : destCell . setBlank ( ) ; return ; case NUMERIC : destCell . setCellValue ( _numberValue ) ; return ; case BOOLEAN : destCell . setCellValue ( _booleanValue ) ; return ; case STRING : destCell . setCellValue ( _stringValue ) ; return ; case ERROR : destCell . setCellErrorValue ( ( byte ) _errorValue ) ; return ; default : throw new IllegalStateException ( " Unexpected ▁ data ▁ type ▁ ( " + _cellType + " ) " ) ; } }
public DescribeLaunchTemplateVersionsResult describeLaunchTemplateVersions ( DescribeLaunchTemplateVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLaunchTemplateVersions ( request ) ; }
public static DVConstraint createCustomFormulaConstraint ( String formula ) { if ( formula == null ) { throw new IllegalArgumentException ( " formula ▁ must ▁ be ▁ supplied " ) ; } return new DVConstraint ( ValidationType . FORMULA , OperatorType . IGNORED , formula , null , null , null , null ) ; }
public DeleteProjectVersionResult deleteProjectVersion ( DeleteProjectVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteProjectVersion ( request ) ; }
public String toStringUnquoted ( ) { return getTermText ( ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ RECALCID ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . reserved ▁ = ▁ " ) . append ( HexDump . shortToHex ( _reserved0 ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . engineId ▁ = ▁ " ) . append ( HexDump . intToHex ( _engineId ) ) . append ( " \ n " ) ; buffer . append ( " [ / RECALCID ] \ n " ) ; return buffer . toString ( ) ; }
public String toString ( ) { return " RandomAccessInput ( " + IndexInput . this . toString ( ) + " ) " ; }
public static int countArg ( ValueEval eval , I_MatchPredicate criteriaPredicate ) { if ( eval == null ) { throw new IllegalArgumentException ( " eval ▁ must ▁ not ▁ be ▁ null " ) ; } if ( eval instanceof ThreeDEval ) { return countMatchingCellsInArea ( ( ThreeDEval ) eval , criteriaPredicate ) ; } if ( eval instanceof TwoDEval ) { throw new IllegalArgumentException ( " Count ▁ requires ▁ 3D ▁ Evals , ▁ 2D ▁ ones ▁ aren ' t supported " ) ; } if ▁ ( eval ▁ instanceof ▁ RefEval ) ▁ { return ▁ CountUtils . countMatchingCellsInRef ( ( RefEval ) ▁ eval , ▁ criteriaPredicate ) ; } return ▁ criteriaPredicate . matches ( eval ) ▁ ? ▁ 1 ▁ : ▁ 0 ; }
public void parse ( byte [ ] buf , int ptr , int end ) { while ( ptr < end ) ptr = parseFile ( buf , ptr , end ) ; }
public ListQueuesResult listQueues ( String queueNamePrefix ) { return listQueues ( new ListQueuesRequest ( ) . withQueueNamePrefix ( queueNamePrefix ) ) ; }
public DescribeVolumeAttributeResult describeVolumeAttribute ( DescribeVolumeAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVolumeAttribute ( request ) ; }
public Trie optimize ( Trie orig ) { List < CharSequence > cmds = orig . cmds ; List < Row > rows = new ArrayList <> ( ) ; List < Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; for ( int j = orows . size ( ) - 1 ; j >= 0 ; j -- ) { liftUp ( orows . get ( j ) , orows ) ; } Arrays . fill ( remap , - 1 ) ; rows = removeGaps ( orig . root , orows , new ArrayList < Row > ( ) , remap ) ; return new Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
public WorkingTreeOptions getOptions ( ) { return state . options ; }
public SendInvitationResult sendInvitation ( SendInvitationRequest request ) { request = beforeClientExecution ( request ) ; return executeSendInvitation ( request ) ; }
public DeleteAlarmsResult deleteAlarms ( DeleteAlarmsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAlarms ( request ) ; }
public static void main ( String [ ] args ) throws Exception { FSDirectory dir = null ; String inputStr = null ; String field = null ; if ( args . length == 3 ) { dir = FSDirectory . open ( Paths . get ( args [ 0 ] ) ) ; field = args [ 1 ] ; inputStr = args [ 2 ] ; } else { usage ( ) ; System . exit ( 1 ) ; } getTermInfo ( dir , new Term ( field , inputStr ) ) ; }
public DBSnapshotAttributesResult modifyDBSnapshotAttribute ( ModifyDBSnapshotAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBSnapshotAttribute ( request ) ; }
public static final String readUTF ( DataInput in ) throws IOException { return decodeUTF ( in . readUnsignedShort ( ) , in ) ; }
public synchronized E remove ( int index ) { @ SuppressWarnings ( " unchecked " ) E removed = ( E ) elements [ index ] ; removeRange ( index , index + 1 ) ; return removed ; }
public byte [ ] getElement ( int index ) { int actualSize = getActualSizeOfElements ( getSizeOfElements ( ) ) ; byte [ ] result = IOUtils . safelyAllocate ( actualSize , MAX_RECORD_LENGTH ) ; System . arraycopy ( getComplexData ( ) , FIXED_SIZE + index * actualSize , result , 0 , result . length ) ; return result ; }
public String signString ( String stringToSign , AlibabaCloudCredentials credentials ) { return null ; }
public void writeData ( final ByteBuffer block ) { block . put ( serialize ( ) ) ; }
public void setSshSessionFactory ( SshSessionFactory factory ) { if ( factory == null ) throw new NullPointerException ( JGitText . get ( ) . theFactoryMustNotBeNull ) ; if ( sock != null ) throw new IllegalStateException ( JGitText . get ( ) . anSSHSessionHasBeenAlreadyCreated ) ; sch = factory ; }
public PipedReader ( PipedWriter out ) throws IOException { connect ( out ) ; }
public RawText getSourceContents ( ) { return outCandidate . sourceText ; }
public static < T > T [ ] copyOfRange ( T [ ] original , int start , int end ) { int originalLength = original . length ; if ( start > end ) { throw new IllegalArgumentException ( ) ; } if ( start < 0 || start > originalLength ) { throw new ArrayIndexOutOfBoundsException ( ) ; } int resultLength = end - start ; int copyLength = Math . min ( resultLength , originalLength - start ) ; T [ ] result = ( T [ ] ) Array . newInstance ( original . getClass ( ) . getComponentType ( ) , resultLength ) ; System . arraycopy ( original , start , result , 0 , copyLength ) ; return result ; }
public boolean isPeeled ( ) { return false ; }
public ProgressMonitor getProgressMonitor ( ) { return monitor ; }
public Content ( String data ) { setData ( data ) ; }
public boolean add ( Object o ) { return map . put ( o , PLACEHOLDER ) == null ; }
public String getLockMessage ( ) { return lockMessage ; }
public E previous ( ) { if ( index > from ) { return ( E ) snapshot [ -- index ] ; } else { throw new NoSuchElementException ( ) ; } }
public InviteUsersResult inviteUsers ( InviteUsersRequest request ) { request = beforeClientExecution ( request ) ; return executeInviteUsers ( request ) ; }
public boolean lessThan ( ShardRef first , ShardRef second ) { assert first != second ; ScoreDoc firstScoreDoc = shardHits [ first . shardIndex ] [ first . hitIndex ] ; ScoreDoc secondScoreDoc = shardHits [ second . shardIndex ] [ second . hitIndex ] ; if ( firstScoreDoc . score < secondScoreDoc . score ) { return false ; } else if ( firstScoreDoc . score > secondScoreDoc . score ) { return true ; } else { return tieBreakLessThan ( first , firstScoreDoc , second , secondScoreDoc , tieBreakerComparator ) ; } }
public ListSubscriptionsRequest ( String nextToken ) { setNextToken ( nextToken ) ; }
public RemoveTagsFromResourceResult removeTagsFromResource ( RemoveTagsFromResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveTagsFromResource ( request ) ; }
public ListHostedZonesResult listHostedZones ( ) { return listHostedZones ( new ListHostedZonesRequest ( ) ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . append ( getClass ( ) . getName ( ) ) . append ( " ▁ [ " ) ; if ( isSemiVolatile ( ) ) { sb . append ( " volatile ▁ " ) ; } if ( isSpace ( ) ) { sb . append ( " space ▁ count = " ) . append ( ( _data >> 8 ) & 0x00FF ) ; sb . append ( " ▁ type = " ) . append ( _data & 0x00FF ) . append ( " ▁ " ) ; } if ( isOptimizedIf ( ) ) { sb . append ( " if ▁ dist = " ) . append ( _data ) ; } else if ( isOptimizedChoose ( ) ) { sb . append ( " choose ▁ nCases = " ) . append ( _data ) ; } else if ( isSkip ( ) ) { sb . append ( " skip ▁ dist = " ) . append ( _data ) ; } else if ( isSum ( ) ) { sb . append ( " sum ▁ " ) ; } else if ( isBaxcel ( ) ) { sb . append ( " assign ▁ " ) ; } sb . append ( " ] " ) ; return sb . toString ( ) ; }
public static double stdev ( double [ ] v ) { double r = Double . NaN ; if ( v != null && v . length > 1 ) { r = Math . sqrt ( devsq ( v ) / ( v . length - 1 ) ) ; } return r ; }
public GetVoiceConnectorLoggingConfigurationResult getVoiceConnectorLoggingConfiguration ( GetVoiceConnectorLoggingConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVoiceConnectorLoggingConfiguration ( request ) ; }
public GetQueueUrlResult getQueueUrl ( GetQueueUrlRequest request ) { request = beforeClientExecution ( request ) ; return executeGetQueueUrl ( request ) ; }
public TblPtg ( LittleEndianInput in ) { field_1_first_row = in . readUShort ( ) ; field_2_first_col = in . readUShort ( ) ; }
public long ramBytesUsed ( ) { long size = 0 ; for ( PackedInts . Reader reader : subReaders ) { size += reader . ramBytesUsed ( ) ; } return size ; }
public CreateInternetGatewayResult createInternetGateway ( CreateInternetGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateInternetGateway ( request ) ; }
public void setInputStream ( IntStream input ) { this . _input = null ; this . _tokenFactorySourcePair = new Pair < TokenSource , CharStream > ( this , _input ) ; reset ( ) ; this . _input = ( CharStream ) input ; this . _tokenFactorySourcePair = new Pair < TokenSource , CharStream > ( this , _input ) ; }
public ExpPtg ( int firstRow , int firstCol ) { this . field_1_first_row = firstRow ; this . field_2_first_col = firstCol ; }
public int refCount ( ) { final int rc = refCount . get ( ) ; assert rc >= 0 ; return rc ; }
public Object [ ] toArray ( ) { int size = size ( ) , index = 0 ; Iterator <?> it = iterator ( ) ; Object [ ] array = new Object [ size ] ; while ( index < size ) { array [ index ++ ] = it . next ( ) ; } return array ; }
public String toString ( ) { return Utils . join ( Arrays . asList ( opnds ) . iterator ( ) , " || " ) ; }
public boolean anyDeletions ( ) { return deleteQueue . anyChanges ( ) ; }
public DoubleBuffer asReadOnlyBuffer ( ) { DoubleToByteBufferAdapter buf = new DoubleToByteBufferAdapter ( byteBuffer . asReadOnlyBuffer ( ) ) ; buf . limit = limit ; buf . position = position ; buf . mark = mark ; buf . byteBuffer . order = byteBuffer . order ; return buf ; }
public GetTelemetryMetadataResult getTelemetryMetadata ( GetTelemetryMetadataRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTelemetryMetadata ( request ) ; }
public ExternalBookBlock ( RecordStream rs ) { _externalBookRecord = ( SupBookRecord ) rs . getNext ( ) ; List < Object > temp = new ArrayList <> ( ) ; while ( rs . peekNextClass ( ) == ExternalNameRecord . class ) { temp . add ( rs . getNext ( ) ) ; } _externalNameRecords = new ExternalNameRecord [ temp . size ( ) ] ; temp . toArray ( _externalNameRecords ) ; temp . clear ( ) ; while ( rs . peekNextClass ( ) == CRNCountRecord . class ) { temp . add ( new CRNBlock ( rs ) ) ; } _crnBlocks = new CRNBlock [ temp . size ( ) ] ; temp . toArray ( _crnBlocks ) ; }
public StartDeliveryStreamEncryptionResult startDeliveryStreamEncryption ( StartDeliveryStreamEncryptionRequest request ) { request = beforeClientExecution ( request ) ; return executeStartDeliveryStreamEncryption ( request ) ; }
public static double getExcelDate ( LocalDateTime date , boolean use1904windowing ) { int year = date . getYear ( ) ; int dayOfYear = date . getDayOfYear ( ) ; int hour = date . getHour ( ) ; int minute = date . getMinute ( ) ; int second = date . getSecond ( ) ; int milliSecond = date . getNano ( ) / 1_000_000 ; return internalGetExcelDate ( year , dayOfYear , hour , minute , second , milliSecond , use1904windowing ) ; }
public UpdateFleetAttributesResult updateFleetAttributes ( UpdateFleetAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFleetAttributes ( request ) ; }
public Explanation idfExplain ( CollectionStatistics collectionStats , TermStatistics termStats ) { final long df = termStats . docFreq ( ) ; final long docCount = collectionStats . docCount ( ) ; final float idf = idf ( df , docCount ) ; return Explanation . match ( idf , " idf ( docFreq , ▁ docCount ) " , Explanation . match ( df , " docFreq , ▁ number ▁ of ▁ documents ▁ containing ▁ term " ) , Explanation . match ( docCount , " docCount , ▁ total ▁ number ▁ of ▁ documents ▁ with ▁ field " ) ) ; }
public CreateGroupMembershipResult createGroupMembership ( CreateGroupMembershipRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateGroupMembership ( request ) ; }
public GrowableWriter ( int startBitsPerValue , int valueCount , float acceptableOverheadRatio ) { this . acceptableOverheadRatio = acceptableOverheadRatio ; current = PackedInts . getMutable ( valueCount , startBitsPerValue , this . acceptableOverheadRatio ) ; currentMask = mask ( current . getBitsPerValue ( ) ) ; }
public AddJobFlowStepsResult addJobFlowSteps ( AddJobFlowStepsRequest request ) { request = beforeClientExecution ( request ) ; return executeAddJobFlowSteps ( request ) ; }
public RecalcIdRecord ( ) { _reserved0 = 0 ; _engineId = 0 ; }
public boolean matches ( ) { matchFound = matchesImpl ( address , input , matchOffsets ) ; if ( matchFound ) { findPos = matchOffsets [ 1 ] ; } return matchFound ; }
public FieldMaskingSpanQuery ( SpanQuery maskedQuery , String maskedField ) { this . maskedQuery = Objects . requireNonNull ( maskedQuery ) ; this . field = Objects . requireNonNull ( maskedField ) ; }
public void print ( float fnum ) { print ( String . valueOf ( fnum ) ) ; }
public int addBSERecord ( EscherBSERecord e ) { createDrawingGroup ( ) ; escherBSERecords . add ( e ) ; int dgLoc = findFirstRecordLocBySid ( DrawingGroupRecord . sid ) ; DrawingGroupRecord drawingGroup = ( DrawingGroupRecord ) getRecords ( ) . get ( dgLoc ) ; EscherContainerRecord dggContainer = ( EscherContainerRecord ) drawingGroup . getEscherRecord ( 0 ) ; EscherContainerRecord bstoreContainer ; if ( dggContainer . getChild ( 1 ) . getRecordId ( ) == EscherContainerRecord . BSTORE_CONTAINER ) { bstoreContainer = ( EscherContainerRecord ) dggContainer . getChild ( 1 ) ; } else { bstoreContainer = new EscherContainerRecord ( ) ; bstoreContainer . setRecordId ( EscherContainerRecord . BSTORE_CONTAINER ) ; List < EscherRecord > childRecords = dggContainer . getChildRecords ( ) ; childRecords . add ( 1 , bstoreContainer ) ; dggContainer . setChildRecords ( childRecords ) ; } bstoreContainer . setOptions ( ( short ) ( ( escherBSERecords . size ( ) << 4 ) | 0xF ) ) ; bstoreContainer . addChildRecord ( e ) ; return escherBSERecords . size ( ) ; }
public CreateLoadBalancerListenersRequest ( String loadBalancerName , java . util . List < Listener > listeners ) { setLoadBalancerName ( loadBalancerName ) ; setListeners ( listeners ) ; }
public DeleteDBClusterEndpointResult deleteDBClusterEndpoint ( DeleteDBClusterEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDBClusterEndpoint ( request ) ; }
public DescribeIngestionResult describeIngestion ( DescribeIngestionRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIngestion ( request ) ; }
public PutCompositeAlarmResult putCompositeAlarm ( PutCompositeAlarmRequest request ) { request = beforeClientExecution ( request ) ; return executePutCompositeAlarm ( request ) ; }
public Collection < ParseTree > evaluate ( ParseTree t ) { List < ParseTree > nodes = new ArrayList < ParseTree > ( ) ; for ( Tree c : Trees . getChildren ( t ) ) { if ( c instanceof ParserRuleContext ) { ParserRuleContext ctx = ( ParserRuleContext ) c ; if ( ( ctx . getRuleIndex ( ) == ruleIndex && ! invert ) || ( ctx . getRuleIndex ( ) != ruleIndex && invert ) ) { nodes . add ( ctx ) ; } } } return nodes ; }
public CreateKeyPairResult createKeyPair ( CreateKeyPairRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateKeyPair ( request ) ; }
public DiffCommand setOldTree ( AbstractTreeIterator oldTree ) { this . oldTree = oldTree ; return this ; }
public GetDeploymentConfigResult getDeploymentConfig ( GetDeploymentConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDeploymentConfig ( request ) ; }
public static void addNewSheetRecord ( List < RecordBase > sheetRecords , RecordBase newRecord ) { int index = findSheetInsertPos ( sheetRecords , newRecord . getClass ( ) ) ; sheetRecords . add ( index , newRecord ) ; }
public final void restoreState ( State state ) { if ( state == null ) return ; do { AttributeImpl targetImpl = attributeImpls . get ( state . attribute . getClass ( ) ) ; if ( targetImpl == null ) { throw new IllegalArgumentException ( " State ▁ contains ▁ AttributeImpl ▁ of ▁ type ▁ " + state . attribute . getClass ( ) . getName ( ) + " ▁ that ▁ is ▁ not ▁ in ▁ in ▁ this ▁ AttributeSource " ) ; } state . attribute . copyTo ( targetImpl ) ; state = state . next ; } while ( state != null ) ; }
public SendVoiceMessageResult sendVoiceMessage ( SendVoiceMessageRequest request ) { request = beforeClientExecution ( request ) ; return executeSendVoiceMessage ( request ) ; }
public DescribeLoadBalancersResult describeLoadBalancers ( ) { return describeLoadBalancers ( new DescribeLoadBalancersRequest ( ) ) ; }
public DisassociateTransitGatewayRouteTableResult disassociateTransitGatewayRouteTable ( DisassociateTransitGatewayRouteTableRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateTransitGatewayRouteTable ( request ) ; }
public String segString ( Directory dir ) { StringBuilder b = new StringBuilder ( ) ; b . append ( " MergeSpec :\ n " ) ; final int count = merges . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { b . append ( " ▁ ▁ " ) . append ( 1 + i ) . append ( " : ▁ " ) . append ( merges . get ( i ) . segString ( ) ) ; } return b . toString ( ) ; }
public DetachNetworkInterfaceResult detachNetworkInterface ( DetachNetworkInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachNetworkInterface ( request ) ; }
public ObjectInserter newObjectInserter ( ) { return getObjectDatabase ( ) . newInserter ( ) ; }
public Class <? extends Record > getRecordClass ( ) { return _c . getDeclaringClass ( ) ; }
public StringBufferInputStream ( String str ) { if ( str == null ) { throw new NullPointerException ( ) ; } buffer = str ; count = str . length ( ) ; }
public DeletedRef3DPtg ( LittleEndianInput in ) { field_1_index_extern_sheet = in . readUShort ( ) ; unused1 = in . readInt ( ) ; }
public CellRangeAddress get ( int index ) { checkIndex ( index ) ; return _mergedRegions . get ( index ) ; }
public boolean removePushRefSpec ( RefSpec s ) { return push . remove ( s ) ; }
public CreateJobResult createJob ( CreateJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateJob ( request ) ; }
public CreateResourceResult createResource ( CreateResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateResource ( request ) ; }
public String log ( ) { return " ▁ ( TERM ▁ = ▁ " + TERM + " ) " + " ▁ ( CT ▁ = ▁ " + CT + " ) " + " ▁ ( RV ▁ = ▁ " + RV + " ) " + " ▁ ( R1 ▁ = ▁ " + R1 + " ) " + " ▁ ( R2 ▁ = ▁ " + R2 + " ) " ; }
public VerifyDomainIdentityResult verifyDomainIdentity ( VerifyDomainIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeVerifyDomainIdentity ( request ) ; }
public void remove ( int index ) { checkIndex ( index ) ; _mergedRegions . remove ( index ) ; }
public static org . apache . poi . hssf . record . Record [ ] createRecord ( RecordInputStream in ) { Record record = createSingleRecord ( in ) ; if ( record instanceof DBCellRecord ) { return new Record [ ] { null , } ; } if ( record instanceof RKRecord ) { return new Record [ ] { convertToNumberRecord ( ( RKRecord ) record ) , } ; } if ( record instanceof MulRKRecord ) { return convertRKRecords ( ( MulRKRecord ) record ) ; } return new Record [ ] { record , } ; }
public DeleteIpGroupResult deleteIpGroup ( DeleteIpGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteIpGroup ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { double d ; try { ValueEval ve = OperandResolver . getSingleValue ( arg0 , srcRowIndex , srcColumnIndex ) ; d = OperandResolver . coerceValueToDouble ( ve ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } if ( d == 0.0 ) { return NumberEval . ZERO ; } return new NumberEval ( - d ) ; }
public String toString ( ) { return " action □ " + ruleIndex + " : " + actionIndex ; }
public StopFleetResult stopFleet ( StopFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeStopFleet ( request ) ; }
public String toString ( ) { return ( " TermStats : ▁ term = " + termtext . utf8ToString ( ) + " ▁ docFreq = " + docFreq + " ▁ totalTermFreq = " + totalTermFreq ) ; }
final public Token getNextToken ( ) { if ( token . next != null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; jj_gen ++ ; return token ; }
public GetLabelDetectionResult getLabelDetection ( GetLabelDetectionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLabelDetection ( request ) ; }
public synchronized IndexCommit getIndexCommit ( long gen ) { return indexCommits . get ( gen ) ; }
public ListMetricsResult listMetrics ( ListMetricsRequest request ) { request = beforeClientExecution ( request ) ; return executeListMetrics ( request ) ; }
public void delete ( ) { throw new UnsupportedOperationException ( " This ▁ IndexCommit ▁ does ▁ not ▁ support ▁ deletions " ) ; }
public ByteBuffer putChar ( int index , char value ) { checkIndex ( index , SizeOf . CHAR ) ; Memory . pokeShort ( backingArray , offset + index , ( short ) value , order ) ; return this ; }
public CreateBasePathMappingResult createBasePathMapping ( CreateBasePathMappingRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateBasePathMapping ( request ) ; }
public synchronized StringBuffer insert ( int index , CharSequence s ) { insert0 ( index , s == null ? " null " : s . toString ( ) ) ; return this ; }
public DescribeDBInstancesResult describeDBInstances ( DescribeDBInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBInstances ( request ) ; }
public ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { switch ( args . length ) { case 2 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] ) ; case 3 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; case 4 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; } return ErrorEval . VALUE_INVALID ; }
@ Override public boolean add ( E object ) { throw new UnsupportedOperationException ( ) ; }
public Collection < TrackingRefUpdate > getTrackingRefUpdates ( ) { return Collections . unmodifiableCollection ( updates . values ( ) ) ; }
public ConfirmProductInstanceRequest ( String productCode , String instanceId ) { setProductCode ( productCode ) ; setInstanceId ( instanceId ) ; }
public AnalyzerFactory ( List < CharFilterFactory > charFilterFactories , TokenizerFactory tokenizerFactory , List < TokenFilterFactory > tokenFilterFactories ) { this . charFilterFactories = charFilterFactories ; assert null != tokenizerFactory ; this . tokenizerFactory = tokenizerFactory ; this . tokenFilterFactories = tokenFilterFactories ; }
public DeleteRestApiResult deleteRestApi ( DeleteRestApiRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRestApi ( request ) ; }
public final ByteBuffer put ( byte [ ] src ) { return put ( src , 0 , src . length ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ PROT4REV ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . options ▁ = ▁ " ) . append ( HexDump . shortToHex ( _options ) ) . append ( " \ n " ) ; buffer . append ( " [ / PROT4REV ] \ n " ) ; return buffer . toString ( ) ; }
public void setTokenSeparator ( String tokenSeparator ) { this . tokenSeparator = null == tokenSeparator ? " " : tokenSeparator ; }
@ Override public ListIterator < E > listIterator ( ) { synchronized ( mutex ) { return list . listIterator ( ) ; } }
public FileOutputStream ( File file ) throws FileNotFoundException { this ( file , false ) ; }
public SetInstanceHealthResult setInstanceHealth ( SetInstanceHealthRequest request ) { request = beforeClientExecution ( request ) ; return executeSetInstanceHealth ( request ) ; }
public boolean isUnderflow ( ) { return this . type == TYPE_UNDERFLOW ; }
public PutRecordsResult putRecords ( PutRecordsRequest request ) { request = beforeClientExecution ( request ) ; return executePutRecords ( request ) ; }
public synchronized boolean isIndeterminate ( ) { return mIndeterminate ; }
public NavigableMap < K , V > headMap ( K toExclusive ) { return subMap ( null , NO_BOUND , toExclusive , EXCLUSIVE ) ; }
public final boolean updateValue ( ValueEval value ) { if ( value == null ) { throw new IllegalArgumentException ( " Did ▁ not ▁ expect ▁ to ▁ update ▁ to ▁ null " ) ; } boolean result = ! areValuesEqual ( _value , value ) ; _value = value ; return result ; }
public ListTablesResult listTables ( ) { return listTables ( new ListTablesRequest ( ) ) ; }
public ValueEval evaluate ( ValueEval [ ] args , OperationEvaluationContext ec ) { if ( args . length != 1 ) { return ErrorEval . VALUE_INVALID ; } int val ; try { val = evaluateArgParity ( args [ 0 ] , ec . getRowIndex ( ) , ec . getColumnIndex ( ) ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return BoolEval . valueOf ( val == _desiredParity ) ; }
public char charAt ( int index ) { return ( char ) ( buffer [ startPtr + index ] & 0xff ) ; }
public CFHeaderRecord ( CellRangeAddress [ ] regions , int nRules ) { super ( regions , nRules ) ; }
public LayoutParams ( int width , int height ) { super ( width , height ) ; }
public String toString ( ) { return " FormatAndBits ( format = " + format + " ▁ bitsPerValue = " + bitsPerValue + " ) " ; }
final public SrndQuery TopSrndQuery ( ) throws ParseException { SrndQuery q ; q = FieldsQuery ( ) ; jj_consume_token ( 0 ) ; { if ( true ) return q ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public final ObjectId copy ( ) { if ( getClass ( ) == ObjectId . class ) return ( ObjectId ) this ; return new ObjectId ( this ) ; }
public DescribeReservedCacheNodesResult describeReservedCacheNodes ( ) { return describeReservedCacheNodes ( new DescribeReservedCacheNodesRequest ( ) ) ; }
public StringBuilder append ( char [ ] chars ) { append0 ( chars ) ; return this ; }
public final boolean matches ( char c ) { return start <= c && c <= end ; }
public DetachVolumeRequest ( String volumeId ) { setVolumeId ( volumeId ) ; }
public final PersonIdent getCommitterIdent ( ) { final byte [ ] raw = buffer ; final int nameB = RawParseUtils . committer ( raw , 0 ) ; if ( nameB < 0 ) return null ; return RawParseUtils . parsePersonIdent ( raw , nameB ) ; }
public SnowballPorterFilterFactory ( Map < String , String > args ) { super ( args ) ; language = get ( args , " language " , " English " ) ; wordFiles = get ( args , PROTECTED_TOKENS ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " = " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public String getType ( int script , int ruleStatus ) { switch ( ruleStatus ) { case RuleBasedBreakIterator . WORD_IDEO : return WORD_IDEO ; case RuleBasedBreakIterator . WORD_KANA : return script == UScript . HIRAGANA ? WORD_HIRAGANA : WORD_KATAKANA ; case RuleBasedBreakIterator . WORD_LETTER : return script == UScript . HANGUL ? WORD_HANGUL : WORD_LETTER ; case RuleBasedBreakIterator . WORD_NUMBER : return WORD_NUMBER ; case EMOJI_SEQUENCE_STATUS : return WORD_EMOJI ; default : return " < OTHER > " ; } }
public static TopDocs merge ( int start , int topN , TopDocs [ ] shardHits ) { return mergeAux ( null , start , topN , shardHits , DEFAULT_TIE_BREAKER ) ; }
public EnableDomainTransferLockResult enableDomainTransferLock ( EnableDomainTransferLockRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableDomainTransferLock ( request ) ; }
public DeleteConfigurationProfileResult deleteConfigurationProfile ( DeleteConfigurationProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteConfigurationProfile ( request ) ; }
public DescribeExpressionsResult describeExpressions ( DescribeExpressionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeExpressions ( request ) ; }
public Ptg [ ] getResult ( ) { return _ptgs ; }
public GetDistributionConfigResult getDistributionConfig ( GetDistributionConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDistributionConfig ( request ) ; }
public ShortBuffer get ( short [ ] dst ) { return get ( dst , 0 , dst . length ) ; }
public GetMetricWidgetImageResult getMetricWidgetImage ( GetMetricWidgetImageRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMetricWidgetImage ( request ) ; }
public UpdateVoiceConnectorGroupResult updateVoiceConnectorGroup ( UpdateVoiceConnectorGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateVoiceConnectorGroup ( request ) ; }
public void add ( SortField sortField ) { map . put ( sortField . getField ( ) , sortField ) ; }
public Daemon getDaemon ( ) { return daemon ; }
public CreateVpcPeeringConnectionResult createVpcPeeringConnection ( CreateVpcPeeringConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVpcPeeringConnection ( request ) ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " * " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public DescribeExclusionsResult describeExclusions ( DescribeExclusionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeExclusions ( request ) ; }
public SearchNetworkProfilesResult searchNetworkProfiles ( SearchNetworkProfilesRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchNetworkProfiles ( request ) ; }
public LooseRef peel ( ObjectIdRef newLeaf ) { throw new UnsupportedOperationException ( ) ; }
public void println ( float f ) { println ( String . valueOf ( f ) ) ; }
public PurchaseReservedInstancesOfferingRequest ( String reservedInstancesOfferingId , Integer instanceCount ) { setReservedInstancesOfferingId ( reservedInstancesOfferingId ) ; setInstanceCount ( instanceCount ) ; }
public Set < String > getUntracked ( ) { return Collections . unmodifiableSet ( diff . getUntracked ( ) ) ; }
public String getTag ( ) { return tag ; }
public void buildFieldConfig ( FieldConfig fieldConfig ) { DateTools . Resolution dateRes = null ; Map < CharSequence , DateTools . Resolution > dateResMap = this . config . get ( ConfigurationKeys . FIELD_DATE_RESOLUTION_MAP ) ; if ( dateResMap != null ) { dateRes = dateResMap . get ( fieldConfig . getField ( ) ) ; } if ( dateRes == null ) { dateRes = this . config . get ( ConfigurationKeys . DATE_RESOLUTION ) ; } if ( dateRes != null ) { fieldConfig . set ( ConfigurationKeys . DATE_RESOLUTION , dateRes ) ; } }
public String toFormulaString ( ) { return String . valueOf ( getValue ( ) ) ; }
public Bits getAllGroupHeads ( ) { return matchingGroupHeads ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; int pos = offset ; LittleEndian . putShort ( data , pos , getOptions ( ) ) ; pos += 2 ; LittleEndian . putShort ( data , pos , getRecordId ( ) ) ; pos += 2 ; int remainingBytes = getRecordSize ( ) - 8 ; LittleEndian . putInt ( data , pos , remainingBytes ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_1_color1 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_2_color2 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_3_color3 ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_4_color4 ) ; pos += 4 ; listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return getRecordSize ( ) ; }
public boolean add ( E object ) { return backingMap . put ( object , Boolean . TRUE ) == null ; }
public void setBinaryFileThreshold ( int threshold ) { this . binaryFileThreshold = threshold ; }
public void setParams ( String params ) { super . setParams ( params ) ; pauseMSec = ( long ) ( 1000.0 * Float . parseFloat ( params ) ) ; }
public PerfTask ( PerfRunData runData ) { this ( ) ; this . runData = runData ; Config config = runData . getConfig ( ) ; this . maxDepthLogStart = config . get ( " task . max . depth . log " , 0 ) ; String logStepAtt = " log . step " ; String taskLogStepAtt = " log . step . " + name ; if ( config . get ( taskLogStepAtt , null ) != null ) { logStepAtt = taskLogStepAtt ; } logStep = config . get ( logStepAtt , DEFAULT_LOG_STEP ) ; if ( logStep <= 0 ) { logStep = Integer . MAX_VALUE ; } }
public void setMBPerSec ( double mbPerSec ) { this . mbPerSec = mbPerSec ; minPauseCheckBytes = ( long ) ( ( MIN_PAUSE_CHECK_MSEC / 1000.0 ) * mbPerSec * 1024 * 1024 ) ; }
public ConfirmSubscriptionRequest ( String topicArn , String token , String authenticateOnUnsubscribe ) { setTopicArn ( topicArn ) ; setToken ( token ) ; setAuthenticateOnUnsubscribe ( authenticateOnUnsubscribe ) ; }
public String getHostName ( ) { return hostName ; }
public StartMonitoringMemberResult startMonitoringMember ( StartMonitoringMemberRequest request ) { request = beforeClientExecution ( request ) ; return executeStartMonitoringMember ( request ) ; }
public < T extends EscherProperty > T lookup ( int propId ) { return ( T ) properties . stream ( ) . filter ( p -> p . getPropertyNumber ( ) == propId ) . findFirst ( ) . orElse ( null ) ; }
public boolean isExpectingOldObjectId ( ) { return expectedOldObjectId != null ; }
public int compareTo ( ScoreTerm other ) { if ( term . bytesEquals ( other . term ) ) return 0 ; if ( this . boost == other . boost ) return other . term . compareTo ( this . term ) ; else return Float . compare ( this . boost , other . boost ) ; }
public LazyAreaEval getColumn ( int columnIndex ) { if ( columnIndex >= getWidth ( ) ) { throw new IllegalArgumentException ( " Invalid ▁ columnIndex ▁ " + columnIndex + " . ▁ ▁ Allowable ▁ range ▁ is ▁ ( 0.. " + getWidth ( ) + " ) . " ) ; } int absColIx = getFirstColumn ( ) + columnIndex ; return new LazyAreaEval ( getFirstRow ( ) , absColIx , getLastRow ( ) , absColIx , _evaluator ) ; }
public BytesRef next ( ) throws IOException { if ( done ) { return null ; } boolean success = false ; BytesRef result ; try { String line ; if ( ( line = in . readLine ( ) ) != null ) { spare . copyChars ( line ) ; result = spare . get ( ) ; } else { done = true ; IOUtils . close ( in ) ; result = null ; } success = true ; } finally { if ( ! success ) { IOUtils . closeWhileHandlingException ( in ) ; } } return result ; }
public boolean shouldBeRecursive ( ) { return path . shouldBeRecursive ( ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ( compressionMode = " + compressionMode + " , ▁ chunkSize = " + chunkSize + " , ▁ blockSize = " + blockSize + " ) " ; }
public ResourcePendingMaintenanceActions applyPendingMaintenanceAction ( ApplyPendingMaintenanceActionRequest request ) { request = beforeClientExecution ( request ) ; return executeApplyPendingMaintenanceAction ( request ) ; }
public boolean startsWith ( AbbreviatedObjectId abbr ) { return abbr . prefixCompare ( this ) == 0 ; }
public SerializingRecordVisitor ( byte [ ] data , int startOffset ) { _data = data ; _startOffset = startOffset ; _countBytesWritten = 0 ; }
public static TreeFilter createFromStrings ( Collection < String > paths ) { if ( paths . isEmpty ( ) ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastOnePathIsRequired ) ; final PathFilter [ ] p = new PathFilter [ paths . size ( ) ] ; int i = 0 ; for ( String s : paths ) p [ i ++ ] = PathFilter . create ( s ) ; return create ( p ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getDefaultCountry ( ) ) ; out . writeShort ( getCurrentCountry ( ) ) ; }
@ Override public boolean equals ( Object object ) { synchronized ( mutex ) { return list . equals ( object ) ; } }
public CellFormatter ( String format ) { this ( LocaleUtil . getUserLocale ( ) , format ) ; }
public ObjectId getResultTreeId ( ) { return resultTree ; }
public DrillDownQuery clone ( ) { return new DrillDownQuery ( config , baseQuery , dimQueries , drillDownDims ) ; }
public final ShortBuffer put ( short [ ] src , int srcOffset , int shortCount ) { throw new ReadOnlyBufferException ( ) ; }
public final void writeLong ( long val ) throws IOException { Memory . pokeLong ( scratch , 0 , val , ByteOrder . BIG_ENDIAN ) ; write ( scratch , 0 , SizeOf . LONG ) ; }
public AuthorizeSecurityGroupEgressResult authorizeSecurityGroupEgress ( AuthorizeSecurityGroupEgressRequest request ) { request = beforeClientExecution ( request ) ; return executeAuthorizeSecurityGroupEgress ( request ) ; }
public void add ( E object ) { throw new UnsupportedOperationException ( ) ; }
public static String getPOSTranslation ( String s ) { return posTranslations . get ( s ) ; }
public AnalyticsTagPredicate ( Tag tag ) { this . tag = tag ; }
public String toInfoString ( Parser recognizer ) { List < String > rules = recognizer . getRuleInvocationStack ( this ) ; Collections . reverse ( rules ) ; return " ParserRuleContext " + rules + " { " + " start = " + start + " , ▁ stop = " + stop + ' } ' ; }
public CharBuffer put ( int index , char c ) { checkIndex ( index ) ; backingArray [ offset + index ] = c ; return this ; }
public CreateComponentResult createComponent ( CreateComponentRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateComponent ( request ) ; }
public RuleWithSuffixExceptions ( String suffix , int min , String replacement , String [ ] exceptions ) { super ( suffix , min , replacement ) ; for ( int i = 0 ; i < exceptions . length ; i ++ ) { if ( ! exceptions [ i ] . endsWith ( suffix ) ) throw new RuntimeException ( " warning : ▁ useless ▁ exception ▁ ' " ▁ + ▁ exceptions [ i ] ▁ + ▁ " ' ▁ does ▁ not ▁ end ▁ with ▁ ' " ▁ + ▁ suffix ▁ + ▁ " ' " ) ; } this . exceptions = new char [ exceptions . length ] [ ] ; for ( int i = 0 ; i < exceptions . length ; i ++ ) this . exceptions [ i ] = exceptions [ i ] . toCharArray ( ) ; }
public DescribeVpnGatewaysResult describeVpnGateways ( DescribeVpnGatewaysRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpnGateways ( request ) ; }
public HSSFClientAnchor ( EscherClientAnchorRecord escherClientAnchorRecord ) { this . _escherClientAnchor = escherClientAnchorRecord ; }
public void stopNow ( ) { stopNow = true ; }
public String toString ( ) { return " FooterKey [ " + name + " ] " ; }
public GetRelationalDatabasesResult getRelationalDatabases ( GetRelationalDatabasesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabases ( request ) ; }
public int compareTo ( Revision o ) { IndexRevision other = ( IndexRevision ) o ; return commit . compareTo ( other . commit ) ; }
public PredPrediction ( SemanticContext pred , int alt ) { this . alt = alt ; this . pred = pred ; }
public ListMeetingTagsResult listMeetingTags ( ListMeetingTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeListMeetingTags ( request ) ; }
public TokenStream create ( TokenStream input ) { return new NorwegianMinimalStemFilter ( input , flags ) ; }
public ImportInstanceResult importInstance ( ImportInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeImportInstance ( request ) ; }
public void setCodePage ( CodepageRecord codepage ) { this . codepage = codepage ; }
@ Override public Collection < V > values ( ) { Collection < V > vs = values ; return ( vs != null ) ? vs : ( values = new Values ( ) ) ; }
public UpdateRulesOfIpGroupResult updateRulesOfIpGroup ( UpdateRulesOfIpGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRulesOfIpGroup ( request ) ; }
public String toString ( ) { return " OneOrMoreOutputs ( " + outputs + " ) " ; }
public static TreeFilter create ( TreeFilter a , TreeFilter b ) { if ( a == ALL || b == ALL ) return ALL ; return new Binary ( a , b ) ; }
public UntagQueueResult untagQueue ( UntagQueueRequest request ) { request = beforeClientExecution ( request ) ; return executeUntagQueue ( request ) ; }
public final double getDouble ( int index ) { return Double . longBitsToDouble ( getLong ( index ) ) ; }
public V next ( ) { return entryIterator . next ( ) . getValue ( ) ; }
public IntervalSet ( int ... els ) { if ( els == null ) { intervals = new ArrayList < Interval > ( 2 ) ; } else { intervals = new ArrayList < Interval > ( els . length ) ; for ( int e : els ) add ( e ) ; } }
public void dumpDeadEndConfigs ( NoViableAltException nvae ) { System . err . println ( " dead ▁ end ▁ configs : ▁ " ) ; for ( ATNConfig c : nvae . getDeadEndConfigs ( ) ) { String trans = " no ▁ edges " ; if ( c . state . getNumberOfTransitions ( ) > 0 ) { Transition t = c . state . transition ( 0 ) ; if ( t instanceof AtomTransition ) { AtomTransition at = ( AtomTransition ) t ; trans = " Atom ▁ " + getTokenName ( at . label ) ; } else if ( t instanceof SetTransition ) { SetTransition st = ( SetTransition ) t ; boolean not = st instanceof NotSetTransition ; trans = ( not ? " ~ " : " " ) + " Set ▁ " + st . set . toString ( ) ; } } System . err . println ( c . toString ( parser , true ) + " : " + trans ) ; } }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ SUPBOOK ▁ " ) ; if ( isExternalReferences ( ) ) { sb . append ( " External ▁ References ] \ n " ) ; sb . append ( " ▁ . url ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getURL ( ) ) . append ( " \ n " ) ; sb . append ( " ▁ . nSheets ▁ = ▁ " ) . append ( field_1_number_of_sheets ) . append ( " \ n " ) ; for ( String sheetname : field_3_sheet_names ) { sb . append ( " ▁ ▁ ▁ ▁ . name ▁ = ▁ " ) . append ( sheetname ) . append ( " \ n " ) ; } sb . append ( " [ / SUPBOOK " ) ; } else if ( _isAddInFunctions ) { sb . append ( " Add - In ▁ Functions " ) ; } else { sb . append ( " Internal ▁ References " ) ; sb . append ( " ▁ nSheets = " ) . append ( field_1_number_of_sheets ) ; } sb . append ( " ] " ) ; return sb . toString ( ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( 256 ) ; sb . append ( " [ ftLbsData ] \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . unknownShort1 ▁ = " ) . append ( HexDump . shortToHex ( _cbFContinued ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . formula ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( ' \ n ' ) ; if ( _linkPtg != null ) { sb . append ( _linkPtg ) . append ( _linkPtg . getRVAType ( ) ) . append ( ' \ n ' ) ; } sb . append ( " ▁ ▁ ▁ ▁ . nEntryCount ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( _cLines ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . selEntryIx ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( _iSel ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . style ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( _flags ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . unknownShort10 = " ) . append ( HexDump . shortToHex ( _idEdit ) ) . append ( " \ n " ) ; if ( _dropData != null ) { sb . append ( ' \ n ' ) . append ( _dropData ) ; } sb . append ( " [ / ftLbsData ] \ n " ) ; return sb . toString ( ) ; }
public static QualityStats average ( QualityStats [ ] stats ) { QualityStats avg = new QualityStats ( 0 , 0 ) ; if ( stats . length == 0 ) { return avg ; } int m = 0 ; for ( int i = 0 ; i < stats . length ; i ++ ) { avg . searchTime += stats [ i ] . searchTime ; avg . docNamesExtractTime += stats [ i ] . docNamesExtractTime ; if ( stats [ i ] . maxGoodPoints > 0 ) { m ++ ; avg . numGoodPoints += stats [ i ] . numGoodPoints ; avg . numPoints += stats [ i ] . numPoints ; avg . pReleventSum += stats [ i ] . getAvp ( ) ; avg . recall += stats [ i ] . recall ; avg . mrr += stats [ i ] . getMRR ( ) ; avg . maxGoodPoints += stats [ i ] . maxGoodPoints ; for ( int j = 1 ; j < avg . pAt . length ; j ++ ) { avg . pAt [ j ] += stats [ i ] . getPrecisionAt ( j ) ; } } } assert m > 0 : " Fishy : ▁ no ▁ \ " good \ " ▁ queries ! " ; avg . searchTime /= stats . length ; avg . docNamesExtractTime /= stats . length ; avg . numGoodPoints /= m ; avg . numPoints /= m ; avg . recall /= m ; avg . mrr /= m ; avg . maxGoodPoints /= m ; for ( int j = 1 ; j < avg . pAt . length ; j ++ ) { avg . pAt [ j ] /= m ; } avg . pReleventSum /= m ; avg . pReleventSum *= avg . maxGoodPoints ; return avg ; }
public String getUser ( ) { return Host . this . getUser ( ) ; }
public int [ ] clear ( ) { boost = null ; termState = null ; return super . clear ( ) ; }
public DescribeApplicationSnapshotResult describeApplicationSnapshot ( DescribeApplicationSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeApplicationSnapshot ( request ) ; }
public FormatAndBits ( Format format , int bitsPerValue ) { this . format = format ; this . bitsPerValue = bitsPerValue ; }
public HSSFName getNameAt ( int nameIndex ) { int nNames = names . size ( ) ; if ( nNames < 1 ) { throw new IllegalStateException ( " There ▁ are ▁ no ▁ defined ▁ names ▁ in ▁ this ▁ workbook " ) ; } if ( nameIndex < 0 || nameIndex > nNames ) { throw new IllegalArgumentException ( " Specified ▁ name ▁ index ▁ " + nameIndex + " ▁ is ▁ outside ▁ the ▁ allowable ▁ range ▁ ( 0.. " + ( nNames - 1 ) + " ) . " ) ; } return names . get ( nameIndex ) ; }
public void fromString ( String str ) { if ( str . length ( ) != Constants . OBJECT_ID_STRING_LENGTH ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . invalidId , str ) ) ; fromHexString ( Constants . encodeASCII ( str ) , 0 ) ; }
public DescribeTableRestoreStatusResult describeTableRestoreStatus ( DescribeTableRestoreStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTableRestoreStatus ( request ) ; }
public Edit ( int as , int ae , int bs , int be ) { beginA = as ; endA = ae ; beginB = bs ; endB = be ; }
public UpdateDomainEndpointOptionsResult updateDomainEndpointOptions ( UpdateDomainEndpointOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDomainEndpointOptions ( request ) ; }
@ Override public boolean contains ( Object o ) { return Impl . this . containsKey ( o ) ; }
public ParseTreePattern compileParseTreePattern ( String pattern , int patternRuleIndex , Lexer lexer ) { ParseTreePatternMatcher m = new ParseTreePatternMatcher ( lexer , this ) ; return m . compile ( pattern , patternRuleIndex ) ; }
public MalformedInputException ( int length ) { this . inputLength = length ; }
public void reset ( ) { upto = 0 ; in . reset ( ) ; }
public String toString ( ) { return name ; }
public DeletePhotoStoreRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " DeletePhotoStore " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public GlobalCluster createGlobalCluster ( CreateGlobalClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateGlobalCluster ( request ) ; }
public SimpleImmutableEntry ( K theKey , V theValue ) { key = theKey ; value = theValue ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SeriesToChartGroup ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . chartGroupIndex ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getChartGroupIndex ( ) ) ) . append ( " ▁ ( " ) . append ( getChartGroupIndex ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " [ / SeriesToChartGroup ] \ n " ) ; return buffer . toString ( ) ; }
public String toString ( ) { return " FAST □ " + path . toString ( ) ; }
public OpenNLPLemmatizerFilterFactory ( Map < String , String > args ) { super ( args ) ; dictionaryFile = get ( args , DICTIONARY ) ; lemmatizerModelFile = get ( args , LEMMATIZER_MODEL ) ; if ( dictionaryFile == null && lemmatizerModelFile == null ) { throw new IllegalArgumentException ( " Configuration ▁ Error : ▁ missing ▁ parameter : ▁ at ▁ least ▁ one ▁ of ▁ ' " + ▁ DICTIONARY ▁ + ▁ " ' ▁ and ▁ ' " ▁ + ▁ LEMMATIZER □ MODEL ▁ + ▁ " ' ▁ must ▁ be ▁ provided . " ) ; } if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public Long contentLength ( ) { return this . contentLength ; }
public void addError ( FormatError err ) { errors . add ( err ) ; }
public UpdateUserResult updateUser ( UpdateUserRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateUser ( request ) ; }
public DeletePartnerEventSourceResult deletePartnerEventSource ( DeletePartnerEventSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeletePartnerEventSource ( request ) ; }
public WorkflowExecutionInfos listClosedWorkflowExecutions ( ListClosedWorkflowExecutionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListClosedWorkflowExecutions ( request ) ; }
public HSSFFontFormatting createFontFormatting ( ) { return getFontFormatting ( true ) ; }
public SimpleFragmenter ( int fragmentSize ) { this . fragmentSize = fragmentSize ; }
public DeleteEmailIdentityResult deleteEmailIdentity ( DeleteEmailIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEmailIdentity ( request ) ; }
public ListScriptsResult listScripts ( ListScriptsRequest request ) { request = beforeClientExecution ( request ) ; return executeListScripts ( request ) ; }
public SnowballFilter ( TokenStream input , SnowballStemmer stemmer ) { super ( input ) ; this . stemmer = stemmer ; }
public DeleteFlowLogsResult deleteFlowLogs ( DeleteFlowLogsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFlowLogs ( request ) ; }
public CreateIdentityPoolResult createIdentityPool ( CreateIdentityPoolRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateIdentityPool ( request ) ; }
public String distanceSubQueryNotAllowed ( ) { Iterator <?> sqi = getSubQueriesIterator ( ) ; while ( sqi . hasNext ( ) ) { Object leq = sqi . next ( ) ; if ( leq instanceof DistanceSubQuery ) { DistanceSubQuery dsq = ( DistanceSubQuery ) leq ; String m = dsq . distanceSubQueryNotAllowed ( ) ; if ( m != null ) { return m ; } } else { return " Operator ▁ " + getOperatorName ( ) + " ▁ does ▁ not ▁ allow ▁ subquery ▁ " + leq . toString ( ) ; } } return null ; }
public static String getNodeText ( Tree t , List < String > ruleNames ) { if ( ruleNames != null ) { if ( t instanceof RuleContext ) { int ruleIndex = ( ( RuleContext ) t ) . getRuleContext ( ) . getRuleIndex ( ) ; String ruleName = ruleNames . get ( ruleIndex ) ; int altNumber = ( ( RuleContext ) t ) . getAltNumber ( ) ; if ( altNumber != ATN . INVALID_ALT_NUMBER ) { return ruleName + " : " + altNumber ; } return ruleName ; } else if ( t instanceof ErrorNode ) { return t . toString ( ) ; } else if ( t instanceof TerminalNode ) { Token symbol = ( ( TerminalNode ) t ) . getSymbol ( ) ; if ( symbol != null ) { String s = symbol . getText ( ) ; return s ; } } } Object payload = t . getPayload ( ) ; if ( payload instanceof Token ) { return ( ( Token ) payload ) . getText ( ) ; } return t . getPayload ( ) . toString ( ) ; }
public int last ( ) { if ( sentenceStarts . length > 0 ) { currentSentence = sentenceStarts . length - 1 ; text . setIndex ( text . getEndIndex ( ) ) ; } else { currentSentence = 0 ; text . setIndex ( text . getBeginIndex ( ) ) ; } return current ( ) ; }
public HSSFRichTextString createRichTextString ( String text ) { return new HSSFRichTextString ( text ) ; }
public PushbackReader ( Reader in ) { super ( in ) ; buf = new char [ 1 ] ; pos = 1 ; }
public List < ParseTree > getAll ( String label ) { List < ParseTree > nodes = labels . get ( label ) ; if ( nodes == null ) { return Collections . emptyList ( ) ; } return nodes ; }
public InternalWorkbook getStubWorkbook ( ) { return createStubWorkbook ( getExternSheetRecords ( ) , getBoundSheetRecords ( ) , getSSTRecord ( ) ) ; }
public ReactivatePhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ReactivatePhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DecisionTask pollForDecisionTask ( PollForDecisionTaskRequest request ) { request = beforeClientExecution ( request ) ; return executePollForDecisionTask ( request ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( getSid ( ) + getPtgClass ( ) ) ; writeCoordinates ( out ) ; }
public Ref getTarget ( ) { return target ; }
public CreateTagsResult createTags ( CreateTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTags ( request ) ; }
public UpdateUserPhoneConfigResult updateUserPhoneConfig ( UpdateUserPhoneConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateUserPhoneConfig ( request ) ; }
public PersonIdent getSourceAuthor ( int idx ) { return sourceAuthors [ idx ] ; }
public void setLength ( long sz ) { setLength ( ( int ) sz ) ; }
public GetServerCertificateRequest ( String serverCertificateName ) { setServerCertificateName ( serverCertificateName ) ; }
public CreateStreamingDistributionWithTagsResult createStreamingDistributionWithTags ( CreateStreamingDistributionWithTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateStreamingDistributionWithTags ( request ) ; }
public DescribeNotificationSubscriptionsResult describeNotificationSubscriptions ( DescribeNotificationSubscriptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNotificationSubscriptions ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ CHARTFRTINFO ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rt ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( rt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbitFrt ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( grbitFrt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . verOriginator = " ) . append ( HexDump . byteToHex ( verOriginator ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . verWriter ▁ ▁ ▁ ▁ = " ) . append ( HexDump . byteToHex ( verOriginator ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . nCFRTIDs ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( rgCFRTID . length ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / CHARTFRTINFO ] \ n " ) ; return buffer . toString ( ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { double result ; if ( arg0 instanceof RefEval ) { result = CountUtils . countMatchingCellsInRef ( ( RefEval ) arg0 , predicate ) ; } else if ( arg0 instanceof ThreeDEval ) { result = CountUtils . countMatchingCellsInArea ( ( ThreeDEval ) arg0 , predicate ) ; } else { throw new IllegalArgumentException ( " Bad ▁ range ▁ arg ▁ type ▁ ( " + arg0. getClass ( ) . getName ( ) + " ) " ) ; } return new NumberEval ( result ) ; }
public UpdateRestApiResult updateRestApi ( UpdateRestApiRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRestApi ( request ) ; }
public int size ( ) { return ConcurrentHashMap . this . size ( ) ; }
public EscherSimpleProperty ( short propertyNumber , boolean isComplex , boolean isBlipId , int propertyValue ) { super ( propertyNumber , isComplex , isBlipId ) ; this . propertyValue = propertyValue ; }
public static boolean isEndOfRowBlock ( int sid ) { switch ( sid ) { case ViewDefinitionRecord . sid : case DrawingRecord . sid : case DrawingSelectionRecord . sid : case ObjRecord . sid : case TextObjectRecord . sid : case ColumnInfoRecord . sid : case GutsRecord . sid : case WindowOneRecord . sid : case WindowTwoRecord . sid : return true ; case DVALRecord . sid : return true ; case EOFRecord . sid : throw new RuntimeException ( " Found ▁ EOFRecord ▁ before ▁ WindowTwoRecord ▁ was ▁ encountered " ) ; } return PageSettingsBlock . isComponentRecord ( sid ) ; }
public RegistrantProfileRealNameVerificationRequest ( ) { super ( " Domain - intl " , " 2017 - 12 - 18 " , " RegistrantProfileRealNameVerification " , " domain " ) ; setMethod ( MethodType . POST ) ; }
public CreateProfileResult createProfile ( CreateProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateProfile ( request ) ; }
public ObjectId idFor ( int type , byte [ ] data , int off , int len ) { SHA1 md = SHA1. newInstance ( ) ; md . update ( Constants . encodedTypeString ( type ) ) ; md . update ( ( byte ) ' ▁ ' ) ; md . update ( Constants . encodeASCII ( len ) ) ; md . update ( ( byte ) 0 ) ; md . update ( data , off , len ) ; return md . toObjectId ( ) ; }
public EndSubRecord clone ( ) { return copy ( ) ; }
public SearchRepoRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " SearchRepo " , " cr " ) ; setUriPattern ( " / search " ) ; setMethod ( MethodType . GET ) ; }
public InputIterator getEntryIterator ( ) { try { return new FileIterator ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public final long get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return backingArray [ offset + position ++ ] ; }
public void setThumbOffset ( int thumbOffset ) { mThumbOffset = thumbOffset ; invalidate ( ) ; }
public void seekExact ( BytesRef target , TermState otherState ) { if ( ! target . equals ( term ) ) { state . copyFrom ( otherState ) ; term = BytesRef . deepCopyOf ( target ) ; seekPending = true ; } }
public GetFilterResult getFilter ( GetFilterRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFilter ( request ) ; }
public static FontDetails create ( String fontName , Properties fontMetricsProps ) { String heightStr = fontMetricsProps . getProperty ( buildFontHeightProperty ( fontName ) ) ; String widthsStr = fontMetricsProps . getProperty ( buildFontWidthsProperty ( fontName ) ) ; String charactersStr = fontMetricsProps . getProperty ( buildFontCharactersProperty ( fontName ) ) ; if ( heightStr == null || widthsStr == null || charactersStr == null ) { throw new IllegalArgumentException ( " The ▁ supplied ▁ FontMetrics ▁ doesn ' t know about the font ' " + fontName + " ' , so we can ' t ▁ use ▁ it . ▁ Please ▁ add ▁ it ▁ to ▁ your ▁ font ▁ metrics ▁ file ▁ ( see ▁ StaticFontMetrics . getFontDetails " ) ; } int height = Integer . parseInt ( heightStr ) ; FontDetails d = new FontDetails ( fontName , height ) ; String [ ] charactersStrArray = split ( charactersStr , " , " , - 1 ) ; String [ ] widthsStrArray = split ( widthsStr , " , " , - 1 ) ; if ( charactersStrArray . length != widthsStrArray . length ) throw new RuntimeException ( " Number ▁ of ▁ characters ▁ does ▁ not ▁ number ▁ of ▁ widths ▁ for ▁ font ▁ " + fontName ) ; for ( int i = 0 ; i < widthsStrArray . length ; i ++ ) { if ( charactersStrArray [ i ] . length ( ) != 0 ) d . addChar ( charactersStrArray [ i ] . charAt ( 0 ) , Integer . parseInt ( widthsStrArray [ i ] ) ) ; } return d ; }
public static void registerFunction ( String name , Function func ) { FunctionMetadata metaData = FunctionMetadataRegistry . getFunctionByName ( name ) ; if ( metaData == null ) { if ( AnalysisToolPak . isATPFunction ( name ) ) { throw new IllegalArgumentException ( name + " ▁ is ▁ a ▁ function ▁ from ▁ the ▁ Excel ▁ Analysis ▁ Toolpack . ▁ " + " Use ▁ AnalysisToolpack . registerFunction ( String ▁ name , ▁ FreeRefFunction ▁ func ) ▁ instead . " ) ; } throw new IllegalArgumentException ( " Unknown ▁ function : ▁ " + name ) ; } int idx = metaData . getIndex ( ) ; if ( functions [ idx ] instanceof NotImplementedFunction ) { functions [ idx ] = func ; } else { throw new IllegalArgumentException ( " POI ▁ already ▁ implememts ▁ " + name + " . ▁ You ▁ cannot ▁ override ▁ POI ' s implementations of Excel functions " ) ; } }
public SortedSetDocValuesField ( String name , BytesRef bytes ) { super ( name , TYPE ) ; fieldsData = bytes ; }
public static TreeFilter create ( TreeFilter [ ] list ) { if ( list . length == 2 ) return create ( list [ 0 ] , list [ 1 ] ) ; if ( list . length < 2 ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastTwoFiltersNeeded ) ; final TreeFilter [ ] subfilters = new TreeFilter [ list . length ] ; System . arraycopy ( list , 0 , subfilters , 0 , list . length ) ; return new List ( subfilters ) ; }
public V get ( Object key ) { if ( key == null ) { HashMapEntry < K , V > e = entryForNullKey ; return e == null ? null : e . value ; } int hash = key . hashCode ( ) ; hash ^= ( hash >>> 20 ) ^ ( hash >>> 12 ) ; hash ^= ( hash >>> 7 ) ^ ( hash >>> 4 ) ; HashMapEntry < K , V > [ ] tab = table ; for ( HashMapEntry < K , V > e = tab [ hash & ( tab . length - 1 ) ] ; e != null ; e = e . next ) { K eKey = e . key ; if ( eKey == key || ( e . hash == hash && key . equals ( eKey ) ) ) { return e . value ; } } return null ; }
public boolean hasSourceData ( int idx ) { return sourceLines [ idx ] != 0 ; }
public CreateBotResult createBot ( CreateBotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateBot ( request ) ; }
public UpdateMethodResponseResult updateMethodResponse ( UpdateMethodResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateMethodResponse ( request ) ; }
public boolean add ( char [ ] text ) { return map . put ( text , PLACEHOLDER ) == null ; }
public String toString ( Vocabulary vocabulary ) { if ( s0 == null ) { return " " ; } DFASerializer serializer = new DFASerializer ( this , vocabulary ) ; return serializer . toString ( ) ; }
public CreateApiKeyResult createApiKey ( CreateApiKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateApiKey ( request ) ; }
public DetachTypedLinkResult detachTypedLink ( DetachTypedLinkRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachTypedLink ( request ) ; }
public ExternSheetRecord [ ] getExternSheetRecords ( ) { return externSheetRecords . toArray ( new ExternSheetRecord [ 0 ] ) ; }
public DescribeNetworkInterfaceAttributeResult describeNetworkInterfaceAttribute ( DescribeNetworkInterfaceAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNetworkInterfaceAttribute ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ TABID ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . elements ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( _tabids . length ) . append ( " \ n " ) ; for ( int i = 0 ; i < _tabids . length ; i ++ ) { buffer . append ( " ▁ ▁ ▁ ▁ . element □ " ) . append ( i ) . append ( " ▁ = ▁ " ) . append ( _tabids [ i ] ) . append ( " \ n " ) ; } buffer . append ( " [ / TABID ] \ n " ) ; return buffer . toString ( ) ; }
public long ramBytesUsed ( ) { long ramBytesUsed = BASE_RAM_BYTES_USED ; ramBytesUsed += ( postingsReader != null ) ? postingsReader . ramBytesUsed ( ) : 0 ; ramBytesUsed += ( indexReader != null ) ? indexReader . ramBytesUsed ( ) : 0 ; ramBytesUsed += fields . size ( ) * 2L * RamUsageEstimator . NUM_BYTES_OBJECT_REF ; for ( FieldReader reader : fields . values ( ) ) { ramBytesUsed += reader . ramBytesUsed ( ) ; } return ramBytesUsed ; }
public ByteBuffer put ( ByteBuffer buf ) { throw new ReadOnlyBufferException ( ) ; }
public RecognizePetRequest ( ) { super ( " visionai - poc " , " 2020 - 04 - 08 " , " RecognizePet " ) ; setMethod ( MethodType . POST ) ; }
public ImportRestApiResult importRestApi ( ImportRestApiRequest request ) { request = beforeClientExecution ( request ) ; return executeImportRestApi ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_anchorId ) ; out . writeShort ( field_2_link1 ) ; out . writeShort ( field_3_link2 ) ; }
public DescribeSnapshotAttributeRequest ( String snapshotId , SnapshotAttributeName attribute ) { setSnapshotId ( snapshotId ) ; setAttribute ( attribute . toString ( ) ) ; }
public Token recoverInline ( Parser recognizer ) throws RecognitionException { Token matchedSymbol = singleTokenDeletion ( recognizer ) ; if ( matchedSymbol != null ) { recognizer . consume ( ) ; return matchedSymbol ; } if ( singleTokenInsertion ( recognizer ) ) { return getMissingSymbol ( recognizer ) ; } InputMismatchException e ; if ( nextTokensContext == null ) { e = new InputMismatchException ( recognizer ) ; } else { e = new InputMismatchException ( recognizer , nextTokensState , nextTokensContext ) ; } throw e ; }
public MultiCategoryListsFacetsExample ( ) { config . setIndexFieldName ( " Author " , " author " ) ; config . setIndexFieldName ( " Publish ▁ Date " , " pubdate " ) ; config . setHierarchical ( " Publish ▁ Date " , true ) ; }
public GetAddressBookResult getAddressBook ( GetAddressBookRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAddressBook ( request ) ; }
public PatternFormatting ( ) { field_15_pattern_style = 0 ; field_16_pattern_color_indexes = 0 ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg1 , ValueEval arg2 ) { try { Double number1 = evaluateValue ( arg1 , srcRowIndex , srcColumnIndex ) ; if ( number1 == null ) { return ErrorEval . VALUE_INVALID ; } Double number2 = evaluateValue ( arg2 , srcRowIndex , srcColumnIndex ) ; if ( number2 == null ) { return ErrorEval . VALUE_INVALID ; } return ( number1. compareTo ( number2 ) == 0 ) ? ONE : ZERO ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public final double getDouble ( ) { return Double . longBitsToDouble ( getLong ( ) ) ; }
public Principal ( String provider , String id , boolean stripHyphen ) { this . provider = provider ; this . id = stripHyphen ? id . replace ( " - " , " " ) : id ; }
public ListJobsResult listJobs ( ) { return listJobs ( new ListJobsRequest ( ) ) ; }
public CharBuffer slice ( ) { byteBuffer . limit ( limit * SizeOf . CHAR ) ; byteBuffer . position ( position * SizeOf . CHAR ) ; ByteBuffer bb = byteBuffer . slice ( ) . order ( byteBuffer . order ( ) ) ; CharBuffer result = new CharToByteBufferAdapter ( bb ) ; byteBuffer . clear ( ) ; return result ; }
public static final int tagMessage ( byte [ ] b , int ptr ) { final int sz = b . length ; if ( ptr == 0 ) ptr += 48 ; while ( ptr < sz && b [ ptr ] != ' \ n ' ) ptr = nextLF ( b , ptr ) ; if ( ptr < sz && b [ ptr ] == ' \ n ' ) return ptr + 1 ; return - 1 ; }
public RebootBrokerResult rebootBroker ( RebootBrokerRequest request ) { request = beforeClientExecution ( request ) ; return executeRebootBroker ( request ) ; }
public int getLastInternalSheetIndexForExtIndex ( int extRefIndex ) { if ( extRefIndex >= _externSheetRecord . getNumOfRefs ( ) || extRefIndex < 0 ) { return - 1 ; } return _externSheetRecord . getLastSheetIndexFromRefIndex ( extRefIndex ) ; }
public RemoveTagsFromOnPremisesInstancesResult removeTagsFromOnPremisesInstances ( RemoveTagsFromOnPremisesInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveTagsFromOnPremisesInstances ( request ) ; }
public static final int nextLF ( byte [ ] b , int ptr ) { return next ( b , ptr , ' \ n ' ) ; }
public boolean equals ( Object other ) { return sameClassAs ( other ) && equalsTo ( getClass ( ) . cast ( other ) ) ; }
public void setResult ( ReceiveCommand . Result status ) { result = decode ( status ) ; super . setResult ( status ) ; }
public UpdateIAMPolicyAssignmentResult updateIAMPolicyAssignment ( UpdateIAMPolicyAssignmentRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateIAMPolicyAssignment ( request ) ; }
public ExportImageResult exportImage ( ExportImageRequest request ) { request = beforeClientExecution ( request ) ; return executeExportImage ( request ) ; }
public ListTopicsDetectionJobsResult listTopicsDetectionJobs ( ListTopicsDetectionJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTopicsDetectionJobs ( request ) ; }
public static IntBuffer wrap ( int [ ] array , int start , int intCount ) { Arrays . checkOffsetAndCount ( array . length , start , intCount ) ; IntBuffer buf = new ReadWriteIntArrayBuffer ( array ) ; buf . position = start ; buf . limit = start + intCount ; return buf ; }
public ListDeploymentTargetsResult listDeploymentTargets ( ListDeploymentTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDeploymentTargets ( request ) ; }
public HSSFTextbox createTextbox ( HSSFChildAnchor anchor ) { HSSFTextbox shape = new HSSFTextbox ( this , anchor ) ; shape . setParent ( this ) ; shape . setAnchor ( anchor ) ; shapes . add ( shape ) ; onCreate ( shape ) ; return shape ; }
public CreateStreamProcessorResult createStreamProcessor ( CreateStreamProcessorRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateStreamProcessor ( request ) ; }
public boolean matches ( char s [ ] , int len ) { return ( len - suffix . length >= min && endsWith ( s , len , suffix ) ) ; }
public void setFontStyle ( boolean italic , boolean bold ) { boolean modified = italic || bold ; fontFormatting . setItalic ( italic ) ; fontFormatting . setBold ( bold ) ; fontFormatting . setFontStyleModified ( modified ) ; fontFormatting . setFontWieghtModified ( modified ) ; }
public void writeShort ( int value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeShort ( value ) ; }
public CreateEntityRecognizerResult createEntityRecognizer ( CreateEntityRecognizerRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateEntityRecognizer ( request ) ; }
public DescribeContributorInsightsResult describeContributorInsights ( DescribeContributorInsightsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeContributorInsights ( request ) ; }
public CreateLaunchConfigurationResult createLaunchConfiguration ( CreateLaunchConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLaunchConfiguration ( request ) ; }
public int read ( ) throws IOException { checkReadPrimitiveTypes ( ) ; return primitiveData . read ( ) ; }
public TokenStream create ( TokenStream input ) { return new LimitTokenCountFilter ( input , maxTokenCount , consumeAllTokens ) ; }
public CharBuffer asReadOnlyBuffer ( ) { return duplicate ( ) ; }
public GetConsoleScreenshotResult getConsoleScreenshot ( GetConsoleScreenshotRequest request ) { request = beforeClientExecution ( request ) ; return executeGetConsoleScreenshot ( request ) ; }
public DrawingRecordForBiffViewer ( DrawingRecord r ) { super ( convertToInputStream ( r ) ) ; convertRawBytesToEscherRecords ( ) ; }
public boolean hasPrevious ( ) { return pos >= 0 ; }
public NotImplemented ( String functionName ) { _functionName = functionName ; }
public UpdateDirectoryConfigResult updateDirectoryConfig ( UpdateDirectoryConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDirectoryConfig ( request ) ; }
public DeleteQualificationTypeResult deleteQualificationType ( DeleteQualificationTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteQualificationType ( request ) ; }
@ Override public void clear ( ) { throw new UnsupportedOperationException ( ) ; }
public int startNewSlice ( ) { return offset = pool . newSlice ( FIRST_LEVEL_SIZE ) + pool . intOffset ; }
public void postInvalidate ( ) { if ( ! mNoInvalidate ) { super . postInvalidate ( ) ; } }
public List < FacetEntry > getFacetEntries ( int offset , int limit ) { List < FacetEntry > entries = new LinkedList <> ( ) ; int skipped = 0 ; int included = 0 ; for ( FacetEntry facetEntry : facetEntries ) { if ( skipped < offset ) { skipped ++ ; continue ; } if ( included ++ >= limit ) { break ; } entries . add ( facetEntry ) ; } return entries ; }
public static synchronized CoderResult unmappableForLength ( int length ) throws IllegalArgumentException { if ( length > 0 ) { Integer key = Integer . valueOf ( length ) ; synchronized ( _unmappableErrors ) { CoderResult r = _unmappableErrors . get ( key ) ; if ( r == null ) { r = new CoderResult ( TYPE_UNMAPPABLE_CHAR , length ) ; _unmappableErrors . put ( key , r ) ; } return r ; } } throw new IllegalArgumentException ( " Length ▁ must ▁ be ▁ greater ▁ than ▁ 0 ; ▁ was ▁ " + length ) ; }
public UpdateDetectorVersionStatusResult updateDetectorVersionStatus ( UpdateDetectorVersionStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDetectorVersionStatus ( request ) ; }
public void remove ( ) { iterator . remove ( ) ; subList . sizeChanged ( false ) ; end -- ; }
public void setRef ( Character way , int ref ) { Cell c = at ( way ) ; if ( c == null ) { c = new Cell ( ) ; c . ref = ref ; cells . put ( way , c ) ; } else { c . ref = ref ; } }
public QueryNodeProcessorPipeline ( QueryConfigHandler queryConfigHandler ) { this . queryConfig = queryConfigHandler ; }
public IllegalFormatPrecisionException ( int p ) { this . p = p ; }
@ Override public final boolean equals ( Object o ) { if ( ! ( o instanceof Entry ) ) { return false ; } Entry <? , ?> e = ( Entry <? , ?> ) o ; return Objects . equal ( e . getKey ( ) , key ) && Objects . equal ( e . getValue ( ) , value ) ; }
public ObjectId getOldObjectId ( ) { return oldValue ; }
public AuthorizeIpRulesResult authorizeIpRules ( AuthorizeIpRulesRequest request ) { request = beforeClientExecution ( request ) ; return executeAuthorizeIpRules ( request ) ; }
public GetPrivateAccessUrlsRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetPrivateAccessUrls " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public boolean remove ( Object o ) { int oldSize = size ; HashMap . this . remove ( o ) ; return size != oldSize ; }
@ Override public int size ( ) { return filteredEntrySet . size ( ) ; }
public PutConfigurationSetTrackingOptionsResult putConfigurationSetTrackingOptions ( PutConfigurationSetTrackingOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executePutConfigurationSetTrackingOptions ( request ) ; }
public static final ObjectId fromString ( byte [ ] buf , int offset ) { return fromHexString ( buf , offset ) ; }
public GetRelationalDatabaseResult getRelationalDatabase ( GetRelationalDatabaseRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabase ( request ) ; }
public JschSession ( Session session , URIish uri ) { sock = session ; this . uri = uri ; }
public SetCognitoEventsResult setCognitoEvents ( SetCognitoEventsRequest request ) { request = beforeClientExecution ( request ) ; return executeSetCognitoEvents ( request ) ; }
public BatchDetectEntitiesResult batchDetectEntities ( BatchDetectEntitiesRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDetectEntities ( request ) ; }
public synchronized int codePointCount ( int beginIndex , int endIndex ) { return super . codePointCount ( beginIndex , endIndex ) ; }
public GenerateClientCertificateResult generateClientCertificate ( GenerateClientCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeGenerateClientCertificate ( request ) ; }
public final void writeDouble ( double val ) throws IOException { writeLong ( Double . doubleToLongBits ( val ) ) ; }
public static void fill ( int [ ] array , int start , int end , int value ) { Arrays . checkStartAndEnd ( array . length , start , end ) ; for ( int i = start ; i < end ; i ++ ) { array [ i ] = value ; } }
public final char yycharat ( int pos ) { return zzBuffer [ zzStartRead + pos ] ; }
public void pushMode ( int m ) { if ( LexerATNSimulator . debug ) System . out . println ( " pushMode ▁ " + m ) ; _modeStack . push ( _mode ) ; mode ( m ) ; }
public Set < String > getCapabilities ( ) { return command . getCapabilities ( ) ; }
public DescribeReservedInstancesListingsResult describeReservedInstancesListings ( ) { return describeReservedInstancesListings ( new DescribeReservedInstancesListingsRequest ( ) ) ; }
public RegisterInstanceEventNotificationAttributesResult registerInstanceEventNotificationAttributes ( RegisterInstanceEventNotificationAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterInstanceEventNotificationAttributes ( request ) ; }
public PutRuleResult putRule ( PutRuleRequest request ) { request = beforeClientExecution ( request ) ; return executePutRule ( request ) ; }
public static char [ ] grow ( char [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Character . BYTES ) ) ; } else return array ; }
public CleanCommand setPaths ( Set < String > paths ) { this . paths = paths ; return this ; }
public int getLevelForDistance ( double dist ) { if ( dist == 0 ) return maxLevels ; final int level = GeohashUtils . lookupHashLenForWidthHeight ( dist , dist ) ; return Math . max ( Math . min ( level , maxLevels ) , 1 ) ; }
public StartDocumentTextDetectionResult startDocumentTextDetection ( StartDocumentTextDetectionRequest request ) { request = beforeClientExecution ( request ) ; return executeStartDocumentTextDetection ( request ) ; }
public String getLine ( ) { return firstWant . getLine ( ) ; }
public ValueEval getItem ( int index ) { if ( index > _size ) { throw new ArrayIndexOutOfBoundsException ( " Specified ▁ index ▁ ( " + index + " ) ▁ is ▁ outside ▁ the ▁ allowed ▁ range ▁ ( 0.. " + ( _size - 1 ) + " ) " ) ; } return _tableArray . getValue ( _rowIndex , index ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ IFMT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . formatIndex ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getFormatIndex ( ) ) ) . append ( " ▁ ( " ) . append ( getFormatIndex ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " [ / IFMT ] \ n " ) ; return buffer . toString ( ) ; }
public SubmoduleSyncCommand ( Repository repo ) { super ( repo ) ; paths = new ArrayList <> ( ) ; }
public void registerWorkflowType ( RegisterWorkflowTypeRequest request ) { request = beforeClientExecution ( request ) ; executeRegisterWorkflowType ( request ) ; }
public UnescapedCharSequence ( char [ ] chars , boolean [ ] wasEscaped , int offset , int length ) { this . chars = new char [ length ] ; this . wasEscaped = new boolean [ length ] ; System . arraycopy ( chars , offset , this . chars , 0 , length ) ; System . arraycopy ( wasEscaped , offset , this . wasEscaped , 0 , length ) ; }
public CreateDatasetGroupResult createDatasetGroup ( CreateDatasetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDatasetGroup ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; FieldVals other = ( FieldVals ) obj ; if ( fieldName == null ) { if ( other . fieldName != null ) return false ; } else if ( ! fieldName . equals ( other . fieldName ) ) return false ; if ( maxEdits != other . maxEdits ) { return false ; } if ( prefixLength != other . prefixLength ) return false ; if ( queryString == null ) { if ( other . queryString != null ) return false ; } else if ( ! queryString . equals ( other . queryString ) ) return false ; return true ; }
public BuildSuggestersResult buildSuggesters ( BuildSuggestersRequest request ) { request = beforeClientExecution ( request ) ; return executeBuildSuggesters ( request ) ; }
public GetRelationalDatabaseBundlesResult getRelationalDatabaseBundles ( GetRelationalDatabaseBundlesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabaseBundles ( request ) ; }
public String getMessages ( ) { return messageBuffer != null ? messageBuffer . toString ( ) : " " ; }
public DelimitedPayloadTokenFilter ( TokenStream input , char delimiter , PayloadEncoder encoder ) { super ( input ) ; this . delimiter = delimiter ; this . encoder = encoder ; }
public void setPrintArea ( int sheetIndex , int startColumn , int endColumn , int startRow , int endRow ) { CellReference cell = new CellReference ( startRow , startColumn , true , true ) ; String reference = cell . formatAsString ( ) ; cell = new CellReference ( endRow , endColumn , true , true ) ; reference = reference + " : " + cell . formatAsString ( ) ; setPrintArea ( sheetIndex , reference ) ; }
public void normalise64bit ( ) { int oldBitLen = _significand . bitLength ( ) ; int sc = oldBitLen - C_64 ; if ( sc == 0 ) { return ; } if ( sc < 0 ) { throw new IllegalStateException ( " Not ▁ enough ▁ precision " ) ; } _binaryExponent += sc ; if ( sc > 32 ) { int highShift = ( sc - 1 ) & 0xFFFFE0 ; _significand = _significand . shiftRight ( highShift ) ; sc -= highShift ; oldBitLen -= highShift ; } if ( sc < 1 ) { throw new IllegalStateException ( ) ; } _significand = Rounder . round ( _significand , sc ) ; if ( _significand . bitLength ( ) > oldBitLen ) { sc ++ ; _binaryExponent ++ ; } _significand = _significand . shiftRight ( sc ) ; }
public ObjRecord ( RecordInputStream in ) { byte [ ] subRecordData = in . readRemainder ( ) ; if ( LittleEndian . getUShort ( subRecordData , 0 ) != CommonObjectDataSubRecord . sid ) { _uninterpretedData = subRecordData ; return ; } LittleEndianByteArrayInputStream subRecStream = new LittleEndianByteArrayInputStream ( subRecordData ) ; CommonObjectDataSubRecord cmo = ( CommonObjectDataSubRecord ) SubRecord . createSubRecord ( subRecStream , 0 ) ; subrecords . add ( cmo ) ; while ( true ) { SubRecord subRecord = SubRecord . createSubRecord ( subRecStream , cmo . getObjectType ( ) ) ; subrecords . add ( subRecord ) ; if ( subRecord . isTerminating ( ) ) { break ; } } final int nRemainingBytes = subRecordData . length - subRecStream . getReadIndex ( ) ; if ( nRemainingBytes > 0 ) { _isPaddedToQuadByteMultiple = subRecordData . length % MAX_PAD_ALIGNMENT == 0 ; if ( nRemainingBytes >= ( _isPaddedToQuadByteMultiple ? MAX_PAD_ALIGNMENT : NORMAL_PAD_ALIGNMENT ) ) { if ( ! canPaddingBeDiscarded ( subRecordData , nRemainingBytes ) ) { String msg = " Leftover ▁ " + nRemainingBytes + " ▁ bytes ▁ in ▁ subrecord ▁ data ▁ " + HexDump . toHex ( subRecordData ) ; throw new RecordFormatException ( msg ) ; } _isPaddedToQuadByteMultiple = false ; } } else { _isPaddedToQuadByteMultiple = false ; } _uninterpretedData = null ; }
public FrenchLightStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
@ Override public int size ( ) { Slice slice = this . slice ; return slice . to - slice . from ; }
public boolean equals ( Object other ) { if ( ! ( other instanceof IntBuffer ) ) { return false ; } IntBuffer otherBuffer = ( IntBuffer ) other ; if ( remaining ( ) != otherBuffer . remaining ( ) ) { return false ; } int myPosition = position ; int otherPosition = otherBuffer . position ; boolean equalSoFar = true ; while ( equalSoFar && ( myPosition < limit ) ) { equalSoFar = get ( myPosition ++ ) == otherBuffer . get ( otherPosition ++ ) ; } return equalSoFar ; }
public static void fill ( char [ ] array , int start , int end , char value ) { Arrays . checkStartAndEnd ( array . length , start , end ) ; for ( int i = start ; i < end ; i ++ ) { array [ i ] = value ; } }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ CALCMODE ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . calcmode ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getCalcMode ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / CALCMODE ] \ n " ) ; return buffer . toString ( ) ; }
public void setCurrent ( String value ) { current = value . toCharArray ( ) ; cursor = 0 ; limit = value . length ( ) ; limit_backward = 0 ; bra = cursor ; ket = limit ; }
public ShortBuffer put ( int index , short c ) { checkIndex ( index ) ; backingArray [ offset + index ] = c ; return this ; }
public EventSubscription deleteEventSubscription ( DeleteEventSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEventSubscription ( request ) ; }
public void setTokenType ( String tokenType ) { this . tokenType = tokenType ; }
public NumericDocValuesField ( String name , long value ) { this ( name , Long . valueOf ( value ) ) ; }
public AddTagsRequest ( String resourceId ) { setResourceId ( resourceId ) ; }
public ValueEval getRefEval ( int rowIndex , int columnIndex ) { SheetRangeEvaluator sre = getRefEvaluatorForCurrentSheet ( ) ; return new LazyRefEval ( rowIndex , columnIndex , sre ) ; }
public DescribeTaskDefinitionResult describeTaskDefinition ( DescribeTaskDefinitionRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTaskDefinition ( request ) ; }
public void sort ( ) { if ( count > 1 ) ArrayUtil . timSort ( points , 0 , count ) ; }
public static final RevFilter before ( long ts ) { return new Before ( ts ) ; }
public void set ( E object ) { throw new UnsupportedOperationException ( ) ; }
public EscherDggRecord getDgg ( ) { return dgg ; }
public ListenerHandle addConfigChangedListener ( ConfigChangedListener listener ) { return addListener ( ConfigChangedListener . class , listener ) ; }
public DetectSentimentResult detectSentiment ( DetectSentimentRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectSentiment ( request ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { final byte block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( block >>> 6 ) & 3 ; values [ valuesOffset ++ ] = ( block >>> 4 ) & 3 ; values [ valuesOffset ++ ] = ( block >>> 2 ) & 3 ; values [ valuesOffset ++ ] = block & 3 ; } }
public HeaderRecord clone ( ) { return copy ( ) ; }
public CreateEndpointConfigResult createEndpointConfig ( CreateEndpointConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateEndpointConfig ( request ) ; }
public Interpolator getInterpolator ( ) { return mInterpolator ; }
public GetSolutionMetricsResult getSolutionMetrics ( GetSolutionMetricsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSolutionMetrics ( request ) ; }
public StopActivityStreamResult stopActivityStream ( StopActivityStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeStopActivityStream ( request ) ; }
public ListTypedLinkFacetAttributesResult listTypedLinkFacetAttributes ( ListTypedLinkFacetAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeListTypedLinkFacetAttributes ( request ) ; }
public ListSentimentDetectionJobsResult listSentimentDetectionJobs ( ListSentimentDetectionJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListSentimentDetectionJobs ( request ) ; }
public GetAccountSendingEnabledResult getAccountSendingEnabled ( GetAccountSendingEnabledRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAccountSendingEnabled ( request ) ; }
public static int getBuiltinFormat ( String pFmt ) { String fmt = " TEXT " . equalsIgnoreCase ( pFmt ) ? " @ " : pFmt ; int i = - 1 ; for ( String f : _formats ) { i ++ ; if ( f . equals ( fmt ) ) { return i ; } } return - 1 ; }
public void simpleValue ( StringBuffer toAppendTo , Object value ) { formatValue ( toAppendTo , value ) ; }
public BatchCheckLayerAvailabilityResult batchCheckLayerAvailability ( BatchCheckLayerAvailabilityRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchCheckLayerAvailability ( request ) ; }
public void clearSubRecords ( ) { subrecords . clear ( ) ; }
public List < Ref > call ( ) throws GitAPIException { checkCallable ( ) ; List < Ref > tags = new ArrayList <> ( ) ; try ( RevWalk revWalk = new RevWalk ( repo ) ) { List < Ref > refList = repo . getRefDatabase ( ) . getRefsByPrefix ( Constants . R_TAGS ) ; for ( Ref ref : refList ) { tags . add ( ref ) ; } } catch ( IOException e ) { throw new JGitInternalException ( e . getMessage ( ) , e ) ; } Collections . sort ( tags , ( Ref o1 , Ref o2 ) -> o1. getName ( ) . compareTo ( o2. getName ( ) ) ) ; setCallable ( false ) ; return tags ; }
public synchronized void clear ( ) { cache . clear ( ) ; }
public int indexOf ( E object , int from ) { Object [ ] snapshot = elements ; return indexOf ( object , snapshot , from , snapshot . length ) ; }
public String highlightTerm ( String originalText , TokenGroup tokenGroup ) { if ( tokenGroup . getTotalScore ( ) == 0 ) return originalText ; float score = tokenGroup . getTotalScore ( ) ; if ( score == 0 ) { return originalText ; } StringBuilder sb = new StringBuilder ( originalText . length ( ) + EXTRA ) ; sb . append ( " < span ▁ style =\ " " ) ; if ( highlightForeground ) { sb . append ( " color : ▁ " ) ; sb . append ( getForegroundColorString ( score ) ) ; sb . append ( " ; ▁ " ) ; } if ( highlightBackground ) { sb . append ( " background : ▁ " ) ; sb . append ( getBackgroundColorString ( score ) ) ; sb . append ( " ; ▁ " ) ; } sb . append ( " \ " > " ) ; sb . append ( originalText ) ; sb . append ( " </ span > " ) ; return sb . toString ( ) ; }
public PasswordRecord getPasswordRecord ( ) { return _passwordRecord ; }
public SlicedIndexInput clone ( ) { SlicedIndexInput clone = ( SlicedIndexInput ) super . clone ( ) ; clone . base = base . clone ( ) ; clone . fileOffset = fileOffset ; clone . length = length ; return clone ; }
public int getSourceLine ( int idx ) { return sourceLines [ idx ] - 1 ; }
public DeleteResolverRuleResult deleteResolverRule ( DeleteResolverRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteResolverRule ( request ) ; }
static public double ppmt ( double r , int per , int nper , double pv , double fv , int type ) { return pmt ( r , nper , pv , fv , type ) - ipmt ( r , per , nper , pv , fv , type ) ; }
@ Override public Set < K > keySet ( ) { return navigableKeySet ( ) ; }
public boolean stem ( ) { if ( ! r_more_than_one_syllable_word ( ) ) { return false ; } limit_backward = cursor ; cursor = limit ; int v_1 = limit - cursor ; r_stem_nominal_verb_suffixes ( ) ; cursor = limit - v_1 ; if ( ! ( B_continue_stemming_noun_suffixes ) ) { return false ; } int v_2 = limit - cursor ; r_stem_noun_suffixes ( ) ; cursor = limit - v_2 ; cursor = limit_backward ; if ( ! r_postlude ( ) ) { return false ; } return true ; }
public ListShardsResult listShards ( ListShardsRequest request ) { request = beforeClientExecution ( request ) ; return executeListShards ( request ) ; }
public SearcherAndTaxonomy ( IndexSearcher searcher , DirectoryTaxonomyReader taxonomyReader ) { this . searcher = searcher ; this . taxonomyReader = taxonomyReader ; }
public TreeFilter clone ( ) { return this ; }
public void set ( int index , long value ) { final int o = index / 6 ; final int b = index % 6 ; final int shift = b * 10 ; blocks [ o ] = ( blocks [ o ] & ~ ( 1023L << shift ) ) | ( value << shift ) ; }
public boolean add ( String text ) { return map . put ( text , PLACEHOLDER ) == null ; }
public Position get ( int pos ) { while ( pos >= nextPos ) { if ( count == positions . length ) { Position [ ] newPositions = new Position [ ArrayUtil . oversize ( 1 + count , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ] ; System . arraycopy ( positions , nextWrite , newPositions , 0 , positions . length - nextWrite ) ; System . arraycopy ( positions , 0 , newPositions , positions . length - nextWrite , nextWrite ) ; for ( int i = positions . length ; i < newPositions . length ; i ++ ) { newPositions [ i ] = new Position ( ) ; } nextWrite = positions . length ; positions = newPositions ; } if ( nextWrite == positions . length ) { nextWrite = 0 ; } assert positions [ nextWrite ] . count == 0 ; positions [ nextWrite ++ ] . pos = nextPos ++ ; count ++ ; } assert inBounds ( pos ) ; final int index = getIndex ( pos ) ; assert positions [ index ] . pos == pos ; return positions [ index ] ; }
public synchronized void reset ( ) { pos = 0 ; }
public void configure ( FacetsConfig config ) { for ( int i = 0 ; i < maxDims ; i ++ ) { config . setHierarchical ( Integer . toString ( i ) , true ) ; config . setMultiValued ( Integer . toString ( i ) , true ) ; } }
public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( obj == this ) return true ; if ( obj . getClass ( ) != getClass ( ) ) return false ; HSSFClientAnchor anchor = ( HSSFClientAnchor ) obj ; return anchor . getCol1 ( ) == getCol1 ( ) && anchor . getCol2 ( ) == getCol2 ( ) && anchor . getDx1 ( ) == getDx1 ( ) && anchor . getDx2 ( ) == getDx2 ( ) && anchor . getDy1 ( ) == getDy1 ( ) && anchor . getDy2 ( ) == getDy2 ( ) && anchor . getRow1 ( ) == getRow1 ( ) && anchor . getRow2 ( ) == getRow2 ( ) && anchor . getAnchorType ( ) == getAnchorType ( ) ; }
public Set < String > getMissing ( ) { return Collections . unmodifiableSet ( diff . getMissing ( ) ) ; }
public static IndexWriterConfig createWriterConfig ( Config config , PerfRunData runData , OpenMode mode , IndexCommit commit ) { IndexWriterConfig iwConf = new IndexWriterConfig ( runData . getAnalyzer ( ) ) ; iwConf . setOpenMode ( mode ) ; IndexDeletionPolicy indexDeletionPolicy = getIndexDeletionPolicy ( config ) ; iwConf . setIndexDeletionPolicy ( indexDeletionPolicy ) ; if ( commit != null ) { iwConf . setIndexCommit ( commit ) ; } final String mergeScheduler = config . get ( " merge . scheduler " , " org . apache . lucene . index . ConcurrentMergeScheduler " ) ; if ( mergeScheduler . equals ( NoMergeScheduler . class . getName ( ) ) ) { iwConf . setMergeScheduler ( NoMergeScheduler . INSTANCE ) ; } else { try { iwConf . setMergeScheduler ( Class . forName ( mergeScheduler ) . asSubclass ( MergeScheduler . class ) . getConstructor ( ) . newInstance ( ) ) ; } catch ( Exception e ) { } } }
public GetCapacityReservationUsageResult getCapacityReservationUsage ( GetCapacityReservationUsageRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCapacityReservationUsage ( request ) ; }
public void addRule ( HSSFConditionalFormattingRule cfRule ) { cfAggregate . addRule ( cfRule . getCfRuleRecord ( ) ) ; }
public DocState ( boolean reuseFields , FieldType ft , FieldType bodyFt ) { this . reuseFields = reuseFields ; if ( reuseFields ) { fields = new HashMap <> ( ) ; numericFields = new HashMap <> ( ) ; fields . put ( BODY_FIELD , new Field ( BODY_FIELD , " " , bodyFt ) ) ; fields . put ( TITLE_FIELD , new Field ( TITLE_FIELD , " " , ft ) ) ; fields . put ( DATE_FIELD , new Field ( DATE_FIELD , " " , ft ) ) ; fields . put ( ID_FIELD , new StringField ( ID_FIELD , " " , Field . Store . YES ) ) ; fields . put ( NAME_FIELD , new Field ( NAME_FIELD , " " , ft ) ) ; numericFields . put ( DATE_MSEC_FIELD , new LongPoint ( DATE_MSEC_FIELD , 0L ) ) ; numericFields . put ( TIME_SEC_FIELD , new IntPoint ( TIME_SEC_FIELD , 0 ) ) ; doc = new Document ( ) ; } else { numericFields = null ; fields = null ; doc = null ; } }
public char [ ] getValue ( ) { return value ; }
public void updateNameCommentRecordCache ( final NameCommentRecord commentRecord ) { if ( commentRecords . containsValue ( commentRecord ) ) { for ( Entry < String , NameCommentRecord > entry : commentRecords . entrySet ( ) ) { if ( entry . getValue ( ) . equals ( commentRecord ) ) { commentRecords . remove ( entry . getKey ( ) ) ; break ; } } } commentRecords . put ( commentRecord . getNameText ( ) , commentRecord ) ; }
public CompleteMultipartUploadRequest ( String vaultName , String uploadId , String archiveSize , String checksum ) { setVaultName ( vaultName ) ; setUploadId ( uploadId ) ; setArchiveSize ( archiveSize ) ; setChecksum ( checksum ) ; }
public Query getQuery ( Element n ) throws ParserException { QueryBuilder builder = builders . get ( n . getNodeName ( ) ) ; if ( builder == null ) { throw new ParserException ( " No ▁ QueryObjectBuilder ▁ defined ▁ for ▁ node ▁ " + n . getNodeName ( ) ) ; } return builder . getQuery ( n ) ; }
public static double nper ( double r , double y , double p , double f , boolean t ) { double retval = 0 ; if ( r == 0 ) { retval = - 1 * ( f + p ) / y ; } else { double r1 = r + 1 ; double ryr = ( t ? r1 : 1 ) * y / r ; double a1 = ( ( ryr - f ) < 0 ) ? Math . log ( f - ryr ) : Math . log ( ryr - f ) ; double a2 = ( ( ryr - f ) < 0 ) ? Math . log ( - p - ryr ) : Math . log ( p + ryr ) ; double a3 = Math . log ( r1 ) ; retval = ( a1 - a2 ) / a3 ; } return retval ; }
public AndQueryNode ( List < QueryNode > clauses ) { super ( clauses ) ; if ( ( clauses == null ) || ( clauses . size ( ) == 0 ) ) { throw new IllegalArgumentException ( " AND ▁ query ▁ must ▁ have ▁ at ▁ least ▁ one ▁ clause " ) ; } }
public SeriesListRecord ( short [ ] seriesNumbers ) { field_1_seriesNumbers = ( seriesNumbers == null ) ? null : seriesNumbers . clone ( ) ; }
public String toString ( ) { return value + " , ▁ " + begin + " , ▁ " + end ; }
public String toString ( ) { return " < StandardQueryParser ▁ config =\ " " + this . getQueryConfigHandler ( ) + " \ " /> " ; }
public DescribeActivitiesResult describeActivities ( DescribeActivitiesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeActivities ( request ) ; }
public int writeTokenValueBytes ( LittleEndianOutput out ) { out . writeByte ( _nColumns - 1 ) ; out . writeShort ( _nRows - 1 ) ; ConstantValueParser . encode ( out , _arrayValues ) ; return 3 + ConstantValueParser . getEncodedSize ( _arrayValues ) ; }
public DescribeFleetMetadataResult describeFleetMetadata ( DescribeFleetMetadataRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFleetMetadata ( request ) ; }
public GlobalCluster modifyGlobalCluster ( ModifyGlobalClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyGlobalCluster ( request ) ; }
public DescribeIdentityIdFormatResult describeIdentityIdFormat ( DescribeIdentityIdFormatRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIdentityIdFormat ( request ) ; }
public ListUserGroupsResult listUserGroups ( ListUserGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListUserGroups ( request ) ; }
public RevertCommand include ( String name , AnyObjectId commit ) { return include ( new ObjectIdRef . Unpeeled ( Storage . LOOSE , name , commit . copy ( ) ) ) ; }
public BeiderMorseFilter ( TokenStream input , PhoneticEngine engine , LanguageSet languages ) { super ( input ) ; this . engine = engine ; this . languages = languages ; }
public ListUsersResult listUsers ( ListUsersRequest request ) { request = beforeClientExecution ( request ) ; return executeListUsers ( request ) ; }
public PutUserPolicyRequest ( String userName , String policyName , String policyDocument ) { setUserName ( userName ) ; setPolicyName ( policyName ) ; setPolicyDocument ( policyDocument ) ; }
public synchronized void trimToSize ( ) { super . trimToSize ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getWindowing ( ) ) ; }
public AreaValueArray ( TwoDEval ae ) { super ( ae . getWidth ( ) * ae . getHeight ( ) ) ; _ae = ae ; _width = ae . getWidth ( ) ; }
public RegisterOnPremisesInstanceResult registerOnPremisesInstance ( RegisterOnPremisesInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterOnPremisesInstance ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ DATALABEXT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rt ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( rt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbitFrt = " ) . append ( HexDump . shortToHex ( grbitFrt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . unused ▁ ▁ = " ) . append ( HexDump . toHex ( unused ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / DATALABEXT ] \ n " ) ; return buffer . toString ( ) ; }
public LsRemoteCommand lsRemote ( ) { return new LsRemoteCommand ( repo ) ; }
public boolean isMerged ( ) { return getStage ( ) == STAGE_0 ; }
public StopEntitiesDetectionJobResult stopEntitiesDetectionJob ( StopEntitiesDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopEntitiesDetectionJob ( request ) ; }
public final int arrayOffset ( ) { return protectedArrayOffset ( ) ; }
public SetVaultNotificationsRequest ( String accountId , String vaultName , VaultNotificationConfig vaultNotificationConfig ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; setVaultNotificationConfig ( vaultNotificationConfig ) ; }
public int addConditionalFormatting ( ConditionalFormatting cf ) { return addConditionalFormatting ( ( HSSFConditionalFormatting ) cf ) ; }
public MemAreaPtg ( LittleEndianInput in ) { field_1_reserved = in . readInt ( ) ; field_2_subex_len = in . readShort ( ) ; }
public DescribeScalingActivitiesResult describeScalingActivities ( ) { return describeScalingActivities ( new DescribeScalingActivitiesRequest ( ) ) ; }
public StopApplicationResult stopApplication ( StopApplicationRequest request ) { request = beforeClientExecution ( request ) ; return executeStopApplication ( request ) ; }
public void seekExact ( long ord ) throws IOException { throw new UnsupportedOperationException ( ) ; }
public DescribeLocalGatewayRouteTableVpcAssociationsResult describeLocalGatewayRouteTableVpcAssociations ( DescribeLocalGatewayRouteTableVpcAssociationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLocalGatewayRouteTableVpcAssociations ( request ) ; }
public ErrorEval getErrorEval ( ) { return _errorEval ; }
public DeleteNetworkInterfaceResult deleteNetworkInterface ( DeleteNetworkInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNetworkInterface ( request ) ; }
public Group ( String path , String groupName , String groupId , String arn , java . util . Date createDate ) { setPath ( path ) ; setGroupName ( groupName ) ; setGroupId ( groupId ) ; setArn ( arn ) ; setCreateDate ( createDate ) ; }
public void removeName ( int nameIndex ) { if ( linkTable . getNumNames ( ) > nameIndex ) { int idx = findFirstRecordLocBySid ( NameRecord . sid ) ; records . remove ( idx + nameIndex ) ; linkTable . removeName ( nameIndex ) ; } }
public BaseFragListBuilder ( int margin ) { if ( margin < 0 ) throw new IllegalArgumentException ( " margin ( " + margin + " ) ▁ is ▁ too ▁ small . ▁ It ▁ must ▁ be ▁ 0 ▁ or ▁ higher . " ) ; this . margin = margin ; this . minFragCharSize = Math . max ( 1 , margin * MIN_FRAG_CHAR_SIZE_FACTOR ) ; }
public Reader create ( Reader input ) { return new PatternReplaceCharFilter ( pattern , replacement , input ) ; }
@ Override public Iterator < K > iterator ( ) { final Iterator < Entry < K , V >> iterator = delegate . entrySet ( ) . iterator ( ) ; return new Iterator < K > ( ) ; }
public CreatePushTemplateResult createPushTemplate ( CreatePushTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePushTemplate ( request ) ; }
public void removeEditTime ( ) { remove1stProperty ( PropertyIDMap . PID_EDITTIME ) ; }
public ListReusableDelegationSetsResult listReusableDelegationSets ( ) { return listReusableDelegationSets ( new ListReusableDelegationSetsRequest ( ) ) ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof AttributeSource ) { AttributeSource other = ( AttributeSource ) obj ; if ( hasAttributes ( ) ) { if ( ! other . hasAttributes ( ) ) { return false ; } if ( this . attributeImpls . size ( ) != other . attributeImpls . size ( ) ) { return false ; } State thisState = this . getCurrentState ( ) ; State otherState = other . getCurrentState ( ) ; while ( thisState != null && otherState != null ) { if ( otherState . attribute . getClass ( ) != thisState . attribute . getClass ( ) || ! otherState . attribute . equals ( thisState . attribute ) ) { return false ; } thisState = thisState . next ; otherState = otherState . next ; } return true ; } else { return ! other . hasAttributes ( ) ; } } else return false ; }
public static String toText ( double value ) { return rawDoubleBitsToText ( Double . doubleToLongBits ( value ) ) ; }
public void notifySetFormula ( Cell cell ) { _bookEvaluator . notifyUpdateCell ( new HSSFEvaluationCell ( ( HSSFCell ) cell ) ) ; }
public Ref getRef ( ) { return ref ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Block b : blocks ) { sb . append ( b . chars , 0 , b . length ) ; } return sb . toString ( ) ; }
public QueryNodeError ( Message message ) { super ( message . getKey ( ) ) ; this . message = message ; }
public GetRelationalDatabaseMasterUserPasswordResult getRelationalDatabaseMasterUserPassword ( GetRelationalDatabaseMasterUserPasswordRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabaseMasterUserPassword ( request ) ; }
public LuceneDictionary ( IndexReader reader , String field ) { this . reader = reader ; this . field = field ; }
public CreateRuleResult createRule ( CreateRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRule ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( errorCheck ) ; }
public DescribeAlarmHistoryResult describeAlarmHistory ( ) { return describeAlarmHistory ( new DescribeAlarmHistoryRequest ( ) ) ; }
public DescribeVpcClassicLinkDnsSupportResult describeVpcClassicLinkDnsSupport ( DescribeVpcClassicLinkDnsSupportRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcClassicLinkDnsSupport ( request ) ; }
public static char toLowerCase ( char c ) { return c <= ' Z ' ? LC [ c ] : c ; }
public String [ ] split ( CharSequence input ) { return split ( input , 0 ) ; }
public synchronized void execute ( ) throws Exception { if ( executed ) { throw new IllegalStateException ( " Benchmark ▁ was ▁ already ▁ executed " ) ; } executed = true ; runData . setStartTimeMillis ( ) ; algorithm . execute ( ) ; }
public final V get ( ) { return value ; }
public VCenterRecord clone ( ) { return copy ( ) ; }
public void publish ( Revision revision ) throws IOException { throw new UnsupportedOperationException ( " this ▁ replicator ▁ implementation ▁ does ▁ not ▁ support ▁ remote ▁ publishing ▁ of ▁ revisions " ) ; }
public boolean shouldBeRecursive ( ) { return a . shouldBeRecursive ( ) || b . shouldBeRecursive ( ) ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof URIish ) ) return false ; final URIish b = ( URIish ) obj ; if ( ! eq ( getScheme ( ) , b . getScheme ( ) ) ) return false ; if ( ! eq ( getUser ( ) , b . getUser ( ) ) ) return false ; if ( ! eq ( getPass ( ) , b . getPass ( ) ) ) return false ; if ( ! eq ( getHost ( ) , b . getHost ( ) ) ) return false ; if ( getPort ( ) != b . getPort ( ) ) return false ; if ( ! eq ( getPath ( ) , b . getPath ( ) ) ) return false ; return true ; }
public TokenStream create ( TokenStream input ) { return new LowerCaseFilter ( input ) ; }
public String toString ( ) { return " IndexRevision ▁ version = " + version + " ▁ files = " + sourceFiles ; }
public static double coerceValueToDouble ( ValueEval ev ) throws EvaluationException { if ( ev == BlankEval . instance ) { return 0.0 ; } if ( ev instanceof NumericValueEval ) { return ( ( NumericValueEval ) ev ) . getNumberValue ( ) ; } if ( ev instanceof StringEval ) { String sval = ( ( StringEval ) ev ) . getStringValue ( ) ; Double dd = parseDouble ( sval ) ; if ( dd == null ) dd = parseDateTime ( sval ) ; if ( dd == null ) { throw EvaluationException . invalidValue ( ) ; } return dd . doubleValue ( ) ; } throw new RuntimeException ( " Unexpected ▁ arg ▁ eval ▁ type ▁ ( " + ev . getClass ( ) . getName ( ) + " ) " ) ; }
public SetQueueAttributesResult setQueueAttributes ( SetQueueAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeSetQueueAttributes ( request ) ; }
public E getLast ( ) { Link < E > last = voidLink . previous ; if ( last != voidLink ) { return last . data ; } throw new NoSuchElementException ( ) ; }
public boolean contains ( Object o ) { return ConcurrentHashMap . this . containsKey ( o ) ; }
public CreateLoadBalancerListenersResult createLoadBalancerListeners ( CreateLoadBalancerListenersRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLoadBalancerListeners ( request ) ; }
public RebootWorkspacesResult rebootWorkspaces ( RebootWorkspacesRequest request ) { request = beforeClientExecution ( request ) ; return executeRebootWorkspaces ( request ) ; }
@ Override public final boolean equals ( Object o ) { if ( ! ( o instanceof Entry ) ) { return false ; } Entry <? , ?> e = ( Entry <? , ?> ) o ; return key . equals ( e . getKey ( ) ) && value . equals ( e . getValue ( ) ) ; }
public DeleteCustomerGatewayRequest ( String customerGatewayId ) { setCustomerGatewayId ( customerGatewayId ) ; }
public String toString ( ) { return getFileMode ( ) + " ▁ " + getLength ( ) + " ▁ " + getLastModifiedInstant ( ) + " ▁ " + getObjectId ( ) + " ▁ " + getStage ( ) + " ▁ " + getPathString ( ) + " \ n " ; }
public StartDocumentAnalysisResult startDocumentAnalysis ( StartDocumentAnalysisRequest request ) { request = beforeClientExecution ( request ) ; return executeStartDocumentAnalysis ( request ) ; }
public UpdatePhoneNumberSettingsResult updatePhoneNumberSettings ( UpdatePhoneNumberSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdatePhoneNumberSettings ( request ) ; }
public BatchStopUpdateActionResult batchStopUpdateAction ( BatchStopUpdateActionRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchStopUpdateAction ( request ) ; }
public void setText ( final char array [ ] , int start , int length ) { this . array = array ; this . start = start ; this . index = start ; this . length = length ; this . limit = start + length ; }
public CreateHyperParameterTuningJobResult createHyperParameterTuningJob ( CreateHyperParameterTuningJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateHyperParameterTuningJob ( request ) ; }
public TermsEnumIndex ( TermsEnum termsEnum , int subIndex ) { this . termsEnum = termsEnum ; this . subIndex = subIndex ; }
public UnarchiveFindingsResult unarchiveFindings ( UnarchiveFindingsRequest request ) { request = beforeClientExecution ( request ) ; return executeUnarchiveFindings ( request ) ; }
public void setSort ( SortField field ) { this . fields = new SortField [ ] { field } ; }
public CreateBusinessReportScheduleResult createBusinessReportSchedule ( CreateBusinessReportScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateBusinessReportSchedule ( request ) ; }
public GetIPSetResult getIPSet ( GetIPSetRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIPSet ( request ) ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; LittleEndian . putInt ( data , offset + 4 , getPropertiesSize ( ) ) ; int pos = offset + 8 ; for ( EscherProperty property : properties ) { pos += property . serializeSimplePart ( data , pos ) ; } for ( EscherProperty property : properties ) { pos += property . serializeComplexPart ( data , pos ) ; } listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; }
public ListTagsForVaultResult listTagsForVault ( ListTagsForVaultRequest request ) { request = beforeClientExecution ( request ) ; return executeListTagsForVault ( request ) ; }
public long getDeltaCacheSize ( ) { return deltaCacheSize ; }
public final int remaining ( ) { return limit - position ; }
public DescribeReservedInstancesResult describeReservedInstances ( DescribeReservedInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReservedInstances ( request ) ; }
public PostRealTimeDeviceDataRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " PostRealTimeDeviceData " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public ScandinavianFoldingFilter ( TokenStream input ) { super ( input ) ; }
public SetLoadBalancerPoliciesForBackendServerResult setLoadBalancerPoliciesForBackendServer ( SetLoadBalancerPoliciesForBackendServerRequest request ) { request = beforeClientExecution ( request ) ; return executeSetLoadBalancerPoliciesForBackendServer ( request ) ; }
public ImportSnapshotResult importSnapshot ( ImportSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeImportSnapshot ( request ) ; }
public void addCellRangeAddress ( CellRangeAddress cra ) { _list . add ( cra ) ; }
public IntBuffer put ( int [ ] src , int srcOffset , int intCount ) { byteBuffer . limit ( limit * SizeOf . INT ) ; byteBuffer . position ( position * SizeOf . INT ) ; if ( byteBuffer instanceof ReadWriteDirectByteBuffer ) { ( ( ReadWriteDirectByteBuffer ) byteBuffer ) . put ( src , srcOffset , intCount ) ; } else { ( ( ReadWriteHeapByteBuffer ) byteBuffer ) . put ( src , srcOffset , intCount ) ; } this . position += intCount ; return this ; }
public DeleteInsightRulesResult deleteInsightRules ( DeleteInsightRulesRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteInsightRules ( request ) ; }
public void setStorageId ( int storageId ) { field_5_stream_id = storageId ; }
public StartVpcEndpointServicePrivateDnsVerificationResult startVpcEndpointServicePrivateDnsVerification ( StartVpcEndpointServicePrivateDnsVerificationRequest request ) { request = beforeClientExecution ( request ) ; return executeStartVpcEndpointServicePrivateDnsVerification ( request ) ; }
public SSTRecord ( ) { field_1_num_strings = 0 ; field_2_num_unique_strings = 0 ; field_3_strings = new IntMapper <> ( ) ; deserializer = new SSTDeserializer ( field_3_strings ) ; }
public void clearData ( ) { points . clear ( ) ; }
public void visitContainedRecords ( RecordVisitor rv ) { PositionTrackingVisitor stv = new PositionTrackingVisitor ( rv , 0 ) ; final int blockCount = getRowBlockCount ( ) ; for ( int blockIndex = 0 ; blockIndex < blockCount ; blockIndex ++ ) { int pos = 0 ; final int rowBlockSize = visitRowRecordsForBlock ( blockIndex , rv ) ; pos += rowBlockSize ; final int startRowNumber = getStartRowNumberForBlock ( blockIndex ) ; final int endRowNumber = getEndRowNumberForBlock ( blockIndex ) ; final List < Short > cellOffsets = new ArrayList <> ( ) ; int cellRefOffset = ( rowBlockSize - RowRecord . ENCODED_SIZE ) ; for ( int row = startRowNumber ; row <= endRowNumber ; row ++ ) { if ( _valuesAgg . rowHasCells ( row ) ) { stv . setPosition ( 0 ) ; _valuesAgg . visitCellsForRow ( row , stv ) ; int rowCellSize = stv . getPosition ( ) ; pos += rowCellSize ; cellOffsets . add ( ( short ) cellRefOffset ) ; cellRefOffset = rowCellSize ; } } rv . visitRecord ( new DBCellRecord ( pos , shortListToArray ( cellOffsets ) ) ) ; } _unknownRecords . forEach ( rv :: visitRecord ) ; }
public ListDatasetsResult listDatasets ( ListDatasetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDatasets ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 ) { return evaluate ( srcRowIndex , srcColumnIndex , arg0 , arg1 , arg2 , DEFAULT_ARG3 ) ; }
public int size ( ) { return a . length ; }
public HSSFCell getCell ( int cellnum ) { return getCell ( cellnum , book . getMissingCellPolicy ( ) ) ; }
public String toFormulaString ( FormulaRenderingWorkbook book ) { return ExternSheetNameResolver . prependSheetName ( book , field_1_index_extern_sheet , FormulaError . REF . getString ( ) ) ; }
public int getBucket ( CharSequence key ) { return getExactMatchStartingFromRootArc ( 0 , new BytesRef ( key ) ) ; }
public DeleteAuthorizerResult deleteAuthorizer ( DeleteAuthorizerRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAuthorizer ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval numberVE ) { String octal = OperandResolver . coerceValueToString ( numberVE ) ; try { return new NumberEval ( BaseNumberUtils . convertToDecimal ( octal , OCTAL_BASE , MAX_NUMBER_OF_PLACES ) ) ; } catch ( IllegalArgumentException e ) { return ErrorEval . NUM_ERROR ; } }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_hcenter ) ; }
public EnableEnhancedMonitoringResult enableEnhancedMonitoring ( EnableEnhancedMonitoringRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableEnhancedMonitoring ( request ) ; }
public ListDeliveryStreamsResult listDeliveryStreams ( ListDeliveryStreamsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDeliveryStreams ( request ) ; }
public DetachVolumeResult detachVolume ( DetachVolumeRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachVolume ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_15_pattern_style ) ; out . writeShort ( field_16_pattern_color_indexes ) ; }
public void setShowSeriesKey ( boolean value ) { field_1_options = showSeriesKey . setShortBoolean ( field_1_options , value ) ; }
public GermanNormalizationFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static boolean allSubsetsEqual ( Collection < BitSet > altsets ) { Iterator < BitSet > it = altsets . iterator ( ) ; BitSet first = it . next ( ) ; while ( it . hasNext ( ) ) { BitSet next = it . next ( ) ; if ( ! next . equals ( first ) ) return false ; } return true ; }
public CellRangeAddressList ( RecordInputStream in ) { this ( ) ; int nItems = in . readUShort ( ) ; for ( int k = 0 ; k < nItems ; k ++ ) { _list . add ( new CellRangeAddress ( in ) ) ; } }
public boolean markSupported ( ) { return in . markSupported ( ) ; }
public DBInstance restoreDBInstanceFromS3 ( RestoreDBInstanceFromS3Request request ) { request = beforeClientExecution ( request ) ; return executeRestoreDBInstanceFromS3 ( request ) ; }
public boolean equals ( Object other ) { if ( ! ( other instanceof FloatBuffer ) ) { return false ; } FloatBuffer otherBuffer = ( FloatBuffer ) other ; if ( remaining ( ) != otherBuffer . remaining ( ) ) { return false ; } int myPosition = position ; int otherPosition = otherBuffer . position ; boolean equalSoFar = true ; while ( equalSoFar && ( myPosition < limit ) ) { float a = get ( myPosition ++ ) ; float b = otherBuffer . get ( otherPosition ++ ) ; equalSoFar = a == b || ( a != a && b != b ) ; } return equalSoFar ; }
public static void fill ( float [ ] array , int start , int end , float value ) { Arrays . checkStartAndEnd ( array . length , start , end ) ; for ( int i = start ; i < end ; i ++ ) { array [ i ] = value ; } }
public DescribeReceiptRuleResult describeReceiptRule ( DescribeReceiptRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReceiptRule ( request ) ; }
public String toString ( ) { return super . toString ( ) + " ▁ " + prefix ; }
public float tf ( int freq , int passageLen ) { float norm = k1 * ( ( 1 - b ) + b * ( passageLen / pivot ) ) ; return freq / ( freq + norm ) ; }
public DescribeModelResult describeModel ( DescribeModelRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeModel ( request ) ; }
public boolean markSupported ( ) { return true ; }
public ListEndpointConfigsResult listEndpointConfigs ( ListEndpointConfigsRequest request ) { request = beforeClientExecution ( request ) ; return executeListEndpointConfigs ( request ) ; }
public DescribeDBProxyTargetGroupsResult describeDBProxyTargetGroups ( DescribeDBProxyTargetGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBProxyTargetGroups ( request ) ; }
public long size ( DiffEntry . Side side , DiffEntry ent ) throws IOException { switch ( side ) { case OLD : return oldSource . size ( ent . oldPath , ent . oldId . toObjectId ( ) ) ; case NEW : return newSource . size ( ent . newPath , ent . newId . toObjectId ( ) ) ; default : throw new IllegalArgumentException ( ) ; } }
public GlobalReplicationGroup disassociateGlobalReplicationGroup ( DisassociateGlobalReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateGlobalReplicationGroup ( request ) ; }
public static void writeHeader ( DataOutput out , String codec , int version ) throws IOException { BytesRef bytes = new BytesRef ( codec ) ; if ( bytes . length != codec . length ( ) || bytes . length >= 128 ) { throw new IllegalArgumentException ( " codec ▁ must ▁ be ▁ simple ▁ ASCII , ▁ less ▁ than ▁ 128 ▁ characters ▁ in ▁ length ▁ [ got ▁ " + codec + " ] " ) ; } out . writeInt ( CODEC_MAGIC ) ; out . writeString ( codec ) ; out . writeInt ( version ) ; }
public PagedList < DedicatedCapacityInner > listByResourceGroup ( String resourceGroupName ) { PageImpl < DedicatedCapacityInner > page = new PageImpl <> ( ) ; page . setItems ( listByResourceGroupWithServiceResponseAsync ( resourceGroupName ) . toBlocking ( ) . single ( ) . body ( ) ) ; page . setNextPageLink ( null ) ; return new PagedList < DedicatedCapacityInner > ( page ) { @ Overridepublic Page < DedicatedCapacityInner > nextPage ( String nextPageLink ) { return null ; } } ; }
public DescribeIpGroupsResult describeIpGroups ( DescribeIpGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIpGroups ( request ) ; }
public final CoderResult flush ( ByteBuffer out ) { if ( status != END && status != READY ) { throw new IllegalStateException ( ) ; } CoderResult result = implFlush ( out ) ; if ( result == CoderResult . UNDERFLOW ) { status = FLUSH ; } return result ; }
public final Type getType ( ) { if ( beginA < endA ) { if ( beginB < endB ) { return Type . REPLACE ; } return Type . DELETE ; } if ( beginB < endB ) { return Type . INSERT ; } return Type . EMPTY ; }
public Builder ( ) { this ( false ) ; }
public DescribeHsmConfigurationsResult describeHsmConfigurations ( DescribeHsmConfigurationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeHsmConfigurations ( request ) ; }
public boolean equals ( Object other ) { if ( ! ( other instanceof DoubleBuffer ) ) { return false ; } DoubleBuffer otherBuffer = ( DoubleBuffer ) other ; if ( remaining ( ) != otherBuffer . remaining ( ) ) { return false ; } int myPosition = position ; int otherPosition = otherBuffer . position ; boolean equalSoFar = true ; while ( equalSoFar && ( myPosition < limit ) ) { double a = get ( myPosition ++ ) ; double b = otherBuffer . get ( otherPosition ++ ) ; equalSoFar = a == b || ( a != a && b != b ) ; } return equalSoFar ; }
public int getSize ( ) { return length ; }
public FeatProtection ( ) { securityDescriptor = new byte [ 0 ] ; }
public DeleteNotificationConfigurationResult deleteNotificationConfiguration ( DeleteNotificationConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNotificationConfiguration ( request ) ; }
public int get ( int key ) { return get ( key , 0 ) ; }
public HSSFAnchor ( int dx1 , int dy1 , int dx2 , int dy2 ) { createEscherAnchor ( ) ; setDx1 ( dx1 ) ; setDy1 ( dy1 ) ; setDx2 ( dx2 ) ; setDy2 ( dy2 ) ; }
public ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { switch ( args . length ) { case 3 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] , DEFAULT_ARG3 , DEFAULT_ARG4 ) ; case 4 : { ValueEval arg3 = args [ 3 ] ; if ( arg3 == MissingArgEval . instance ) { arg3 = DEFAULT_ARG3 ; } return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] , arg3 , DEFAULT_ARG4 ) ; } case 5 : { ValueEval arg3 = args [ 3 ] ; if ( arg3 == MissingArgEval . instance ) { arg3 = DEFAULT_ARG3 ; } ValueEval arg4 = args [ 4 ] ; if ( arg4 == MissingArgEval . instance ) { arg4 = DEFAULT_ARG4 ; } return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] , arg3 , arg4 ) ; } default : return ErrorEval . VALUE_INVALID ; } }
public Toffs ( int startOffset , int endOffset ) { this . startOffset = startOffset ; this . endOffset = endOffset ; }
public GetDocumentationVersionResult getDocumentationVersion ( GetDocumentationVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDocumentationVersion ( request ) ; }
public static < T > T [ ] grow ( T [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { final int newLength = oversize ( minSize , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ; return growExact ( array , newLength ) ; } else return array ; }
public PurchaseProvisionedCapacityResult purchaseProvisionedCapacity ( PurchaseProvisionedCapacityRequest request ) { request = beforeClientExecution ( request ) ; return executePurchaseProvisionedCapacity ( request ) ; }
public ListenerHandle addRefsChangedListener ( RefsChangedListener listener ) { return addListener ( RefsChangedListener . class , listener ) ; }
public void drawRect ( int x , int y , int width , int height ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , " drawRect ▁ not ▁ supported " ) ; }
public DeleteGcmChannelResult deleteGcmChannel ( DeleteGcmChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteGcmChannel ( request ) ; }
public String toString ( ) { return " del = " + item ; }
public int read ( byte [ ] b , int off , int len ) { if ( ptr == data . length ) return - 1 ; int n = Math . min ( available ( ) , len ) ; System . arraycopy ( data , ptr , b , off , n ) ; ptr += n ; return n ; }
public static String toHex ( int value ) { StringBuilder sb = new StringBuilder ( 8 ) ; writeHex ( sb , value & 0xFFFFFFFFL , 8 , " " ) ; return sb . toString ( ) ; }
public DeleteFieldLevelEncryptionConfigResult deleteFieldLevelEncryptionConfig ( DeleteFieldLevelEncryptionConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFieldLevelEncryptionConfig ( request ) ; }
public AmazonS3EncryptionClient ( AWSCredentials credentials , EncryptionMaterials encryptionMaterials ) { this ( credentials , new StaticEncryptionMaterialsProvider ( encryptionMaterials ) ) ; }
public FontDetails ( String fontName , int height ) { _fontName = fontName ; _height = height ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( LESSTHAN ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public String toString ( ) { return new String ( this . buffer , 0 , this . len ) ; }
public WriteRequest ( PutRequest putRequest ) { setPutRequest ( putRequest ) ; }
public static String toHex ( byte value ) { StringBuilder sb = new StringBuilder ( 2 ) ; writeHex ( sb , value & 0xFF , 2 , " " ) ; return sb . toString ( ) ; }
public int stem ( char s [ ] , int len ) { return pluralStep . apply ( s , len ) ; }
public void write ( byte [ ] b , int off , int len ) { try { super . write ( b , off , len ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public Set < Long > idSet ( ) { return Collections . unmodifiableSet ( dictionary . keySet ( ) ) ; }
public BatchGetDeploymentsResult batchGetDeployments ( BatchGetDeploymentsRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetDeployments ( request ) ; }
public QueryScorer ( Query query , String field , String defaultField ) { this . defaultField = defaultField ; init ( query , field , null , true ) ; }
public long next ( ) throws IOException { current = fstEnum . next ( ) ; if ( current == null ) { return - 1 ; } else { return current . output ; } }
public GetApplicationDateRangeKpiResult getApplicationDateRangeKpi ( GetApplicationDateRangeKpiRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApplicationDateRangeKpi ( request ) ; }
public TokenStream create ( TokenStream input ) { return new GalicianStemFilter ( input ) ; }
public ListHostedZonesResult listHostedZones ( ListHostedZonesRequest request ) { request = beforeClientExecution ( request ) ; return executeListHostedZones ( request ) ; }
public int getDepth ( ) { return depth ; }
public WindowTwoRecord ( RecordInputStream in ) { int size = in . remaining ( ) ; field_1_options = in . readShort ( ) ; field_2_top_row = in . readShort ( ) ; field_3_left_col = in . readShort ( ) ; field_4_header_color = in . readInt ( ) ; if ( size > 10 ) { field_5_page_break_zoom = in . readShort ( ) ; field_6_normal_zoom = in . readShort ( ) ; } if ( size > 14 ) { field_7_reserved = in . readInt ( ) ; } }
public GetUsageResult getUsage ( GetUsageRequest request ) { request = beforeClientExecution ( request ) ; return executeGetUsage ( request ) ; }
public void setConfig ( Config config ) { super . setConfig ( config ) ; keepImages = config . get ( " keep . image . only . docs " , true ) ; String fileName = config . get ( " docs . file " , null ) ; if ( fileName != null ) { file = Paths . get ( fileName ) . toAbsolutePath ( ) ; } }
public ListSubscriptionsByTopicRequest ( String topicArn ) { setTopicArn ( topicArn ) ; }
public ListTablesRequest ( String exclusiveStartTableName , Integer limit ) { setExclusiveStartTableName ( exclusiveStartTableName ) ; setLimit ( limit ) ; }
public String toString ( ) { return start + " ▁ to ▁ " + end ; }
public final float get ( int index ) { checkIndex ( index ) ; return backingArray [ offset + index ] ; }
public LongBuffer duplicate ( ) { return copy ( this , mark ) ; }
public ListManagedSchemaArnsResult listManagedSchemaArns ( ListManagedSchemaArnsRequest request ) { request = beforeClientExecution ( request ) ; return executeListManagedSchemaArns ( request ) ; }
public DescribeSpotPriceHistoryResult describeSpotPriceHistory ( DescribeSpotPriceHistoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSpotPriceHistory ( request ) ; }
public ListDevelopmentSchemaArnsResult listDevelopmentSchemaArns ( ListDevelopmentSchemaArnsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDevelopmentSchemaArns ( request ) ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof ATNConfig ) ) { return false ; } return this . equals ( ( ATNConfig ) o ) ; }
public DeleteEventsConfigurationResult deleteEventsConfiguration ( DeleteEventsConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEventsConfiguration ( request ) ; }
public static short sign ( double d ) { return ( short ) ( ( d == 0 ) ? 0 : ( d < 0 ) ? - 1 : 1 ) ; }
public void setFillerToken ( String fillerToken ) { this . fillerToken = null == fillerToken ? new char [ 0 ] : fillerToken . toCharArray ( ) ; }
public UpdateDestinationResult updateDestination ( UpdateDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDestination ( request ) ; }
public CreateEmailIdentityResult createEmailIdentity ( CreateEmailIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateEmailIdentity ( request ) ; }
public PersonIdent getSourceAuthor ( ) { return outCandidate . getAuthor ( ) ; }
public StartMonitoringMembersResult startMonitoringMembers ( StartMonitoringMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeStartMonitoringMembers ( request ) ; }
public void setLocalPatternChars ( String data ) { if ( data == null ) { throw new NullPointerException ( ) ; } localPatternChars = data ; }
public PersianNormalizationFilter ( TokenStream input ) { super ( input ) ; }
public void liftUp ( Row in , List < Row > nodes ) { Iterator < Cell > i = in . cells . values ( ) . iterator ( ) ; for ( ; i . hasNext ( ) ; ) { Cell c = i . next ( ) ; if ( c . ref >= 0 ) { Row to = nodes . get ( c . ref ) ; int sum = to . uniformCmd ( changeSkip ) ; if ( sum >= 0 ) { if ( sum == c . cmd ) { if ( changeSkip ) { if ( c . skip != to . uniformSkip + 1 ) { continue ; } c . skip = to . uniformSkip + 1 ; } else { c . skip = 0 ; } c . cnt += to . uniformCnt ; c . ref = - 1 ; } else if ( c . cmd < 0 ) { c . cnt = to . uniformCnt ; c . cmd = sum ; c . ref = - 1 ; if ( changeSkip ) { c . skip = to . uniformSkip + 1 ; } else { c . skip = 0 ; } } } } } }
public String toString ( ) { StringBuilder r = new StringBuilder ( ) ; r . append ( " SymbolicRef [ " ) ; Ref cur = this ; while ( cur . isSymbolic ( ) ) { r . append ( cur . getName ( ) ) ; r . append ( " ▁ -> ▁ " ) ; cur = cur . getTarget ( ) ; } r . append ( cur . getName ( ) ) ; r . append ( ' = ' ) ; r . append ( ObjectId . toString ( cur . getObjectId ( ) ) ) ; r . append ( " ( " ) ; r . append ( updateIndex ) ; r . append ( " ) ] " ) ; return r . toString ( ) ; }
public RemoveAllResourcePermissionsResult removeAllResourcePermissions ( RemoveAllResourcePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveAllResourcePermissions ( request ) ; }
public DescribeResourceGroupsResult describeResourceGroups ( DescribeResourceGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeResourceGroups ( request ) ; }
public SpatialArgs parse ( String v , SpatialContext ctx ) throws ParseException , InvalidShapeException { int idx = v . indexOf ( ' ( ' ) ; int edx = v . lastIndexOf ( ' ) ' ) ; if ( idx < 0 || idx > edx ) { throw new ParseException ( " missing ▁ parens : ▁ " + v , - 1 ) ; } SpatialOperation op = SpatialOperation . get ( v . substring ( 0 , idx ) . trim ( ) ) ; String body = v . substring ( idx + 1 , edx ) . trim ( ) ; if ( body . length ( ) < 1 ) { throw new ParseException ( " missing ▁ body ▁ : ▁ " + v , idx + 1 ) ; } Shape shape = parseShape ( body , ctx ) ; SpatialArgs args = newSpatialArgs ( op , shape ) ; if ( v . length ( ) > ( edx + 1 ) ) { body = v . substring ( edx + 1 ) . trim ( ) ; if ( body . length ( ) > 0 ) { Map < String , String > aa = parseMap ( body ) ; readNameValuePairs ( args , aa ) ; if ( ! aa . isEmpty ( ) ) { throw new IllegalArgumentException ( " unused ▁ parameters : ▁ " + aa ) ; } } } args . validate ( ) ; return args ; }
public boolean wasDeltaAttempted ( ) { int fmt = getFormat ( ) ; return fmt == PACK_DELTA || fmt == PACK_WHOLE ; }
public PutModelResult putModel ( PutModelRequest request ) { request = beforeClientExecution ( request ) ; return executePutModel ( request ) ; }
public String toString ( ) { return String . valueOf ( stateNumber ) ; }
public CreatePlayerSessionResult createPlayerSession ( CreatePlayerSessionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePlayerSession ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeByte ( field_1_majorTickType ) ; out . writeByte ( field_2_minorTickType ) ; out . writeByte ( field_3_labelPosition ) ; out . writeByte ( field_4_background ) ; out . writeInt ( field_5_labelColorRgb ) ; out . writeInt ( field_6_zero1 ) ; out . writeInt ( field_7_zero2 ) ; out . writeInt ( field_8_zero3 ) ; out . writeInt ( field_9_zero4 ) ; out . writeShort ( field_10_options ) ; out . writeShort ( field_11_tickColor ) ; out . writeShort ( field_12_zero5 ) ; }
public ModifyVpcTenancyResult modifyVpcTenancy ( ModifyVpcTenancyRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVpcTenancy ( request ) ; }
public GetBasePathMappingsResult getBasePathMappings ( GetBasePathMappingsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetBasePathMappings ( request ) ; }
public void add ( BytesRef utf8 ) { if ( closed ) throw new IllegalStateException ( ) ; buffer . append ( utf8 ) ; }
public void notifyUpdateCell ( HSSFCell cell ) { _bookEvaluator . notifyUpdateCell ( new HSSFEvaluationCell ( cell ) ) ; }
public AddApplicationReferenceDataSourceResult addApplicationReferenceDataSource ( AddApplicationReferenceDataSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeAddApplicationReferenceDataSource ( request ) ; }
public NIOFSIndexInput ( String resourceDesc , FileChannel fc , long off , long length , int bufferSize ) { super ( resourceDesc , bufferSize ) ; this . channel = fc ; this . off = off ; this . end = off + length ; this . isClone = true ; }
@ Override public Iterator < K > iterator ( ) { final Iterator < Entry < K , V >> iterator = filteredEntrySet . iterator ( ) ; return new UnmodifiableIterator < K > ( ) ; }
public TokenStream create ( TokenStream input ) { return new IndonesianStemFilter ( input , stemDerivational ) ; }
public SubmoduleStatusCommand addPath ( String path ) { paths . add ( path ) ; return this ; }
public PutInsightRuleResult putInsightRule ( PutInsightRuleRequest request ) { request = beforeClientExecution ( request ) ; return executePutInsightRule ( request ) ; }
public JapaneseReadingFormFilterFactory ( Map < String , String > args ) { super ( args ) ; useRomaji = getBoolean ( args , ROMAJI_PARAM , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public GetVpcLinkResult getVpcLink ( GetVpcLinkRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVpcLink ( request ) ; }
public boolean evaluate ( boolean cmpResult ) { switch ( _code ) { case NONE : case EQ : return cmpResult ; case NE : return ! cmpResult ; } throw new RuntimeException ( " Cannot ▁ call ▁ boolean ▁ evaluate ▁ on ▁ non - equality ▁ operator ▁ ' " + ▁ □ representation ▁ + ▁ " ' " ) ; }
public int getEnd ( ) { return end ; }
@ Override public String toString ( ) { if ( string != null ) { return string ; } StringBuilder result = new StringBuilder ( ) ; if ( scheme != null ) { result . append ( scheme ) ; result . append ( ' : ' ) ; } if ( opaque ) { result . append ( schemeSpecificPart ) ; } else { if ( authority != null ) { result . append ( " " ) ; result . append ( authority ) ; } if ( path != null ) { result . append ( path ) ; } if ( query != null ) { result . append ( ' ? ' ) ; result . append ( query ) ; } } if ( fragment != null ) { result . append ( ' # ' ) ; result . append ( fragment ) ; } string = result . toString ( ) ; return string ; }
public static final ObjectId fromRaw ( byte [ ] bs , int p ) { final int a = NB . decodeInt32 ( bs , p ) ; final int b = NB . decodeInt32 ( bs , p + 4 ) ; final int c = NB . decodeInt32 ( bs , p + 8 ) ; final int d = NB . decodeInt32 ( bs , p + 12 ) ; final int e = NB . decodeInt32 ( bs , p + 16 ) ; return new ObjectId ( a , b , c , d , e ) ; }
public int maxRecall ( QualityQuery query ) { QRelJudgement qrj = judgements . get ( query . getQueryID ( ) ) ; if ( qrj != null ) { return qrj . maxRecall ( ) ; } return 0 ; }
public static HashFunction hashFunctionForVersion ( int version ) { if ( version < VERSION_START ) { throw new IllegalArgumentException ( " Version ▁ " + version + " ▁ is ▁ too ▁ old , ▁ expected ▁ at ▁ least ▁ " + VERSION_START ) ; } else if ( version > VERSION_CURRENT ) { throw new IllegalArgumentException ( " Version ▁ " + version + " ▁ is ▁ too ▁ new , ▁ expected ▁ at ▁ most ▁ " + VERSION_CURRENT ) ; } return MurmurHash2. INSTANCE ; }
public void removeCell ( Cell cell ) { if ( cell == null ) { throw new IllegalArgumentException ( " cell ▁ must ▁ not ▁ be ▁ null " ) ; } removeCell ( ( HSSFCell ) cell , true ) ; }
public CreatePlacementGroupRequest ( String groupName , PlacementStrategy strategy ) { setGroupName ( groupName ) ; setStrategy ( strategy . toString ( ) ) ; }
public PutManagedScalingPolicyResult putManagedScalingPolicy ( PutManagedScalingPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executePutManagedScalingPolicy ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SXVS ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . vs ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( vs ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / SXVS ] \ n " ) ; return buffer . toString ( ) ; }
public Trie reduce ( Reduce by ) { return by . optimize ( this ) ; }
public AbstractEscherHolderRecord clone ( ) { return copy ( ) ; }
public void setParams ( String params ) { super . setParams ( params ) ; commitUserData = new HashMap <> ( ) ; commitUserData . put ( OpenReaderTask . USER_DATA , params ) ; }
public String getSrcRef ( ) { return srcRef ; }
public final String getShortMessage ( ) { byte [ ] raw = buffer ; int msgB = RawParseUtils . commitMessage ( raw , 0 ) ; if ( msgB < 0 ) { return " " ; } int msgE = RawParseUtils . endOfParagraph ( raw , msgB ) ; String str = RawParseUtils . decode ( guessEncoding ( ) , raw , msgB , msgE ) ; if ( hasLF ( raw , msgB , msgE ) ) { str = StringUtils . replaceLineBreaksWithSpace ( str ) ; } return str ; }
public static Boolean coerceValueToBoolean ( ValueEval ve , boolean stringsAreBlanks ) throws EvaluationException { if ( ve == null || ve == BlankEval . instance ) { return null ; } if ( ve instanceof BoolEval ) { return Boolean . valueOf ( ( ( BoolEval ) ve ) . getBooleanValue ( ) ) ; } if ( ve instanceof StringEval ) { if ( stringsAreBlanks ) { return null ; } String str = ( ( StringEval ) ve ) . getStringValue ( ) ; if ( str . equalsIgnoreCase ( " true " ) ) { return Boolean . TRUE ; } if ( str . equalsIgnoreCase ( " false " ) ) { return Boolean . FALSE ; } throw new EvaluationException ( ErrorEval . VALUE_INVALID ) ; } if ( ve instanceof NumericValueEval ) { NumericValueEval ne = ( NumericValueEval ) ve ; double d = ne . getNumberValue ( ) ; if ( Double . isNaN ( d ) ) { throw new EvaluationException ( ErrorEval . VALUE_INVALID ) ; } return Boolean . valueOf ( d != 0 ) ; } if ( ve instanceof ErrorEval ) { throw new EvaluationException ( ( ErrorEval ) ve ) ; } throw new RuntimeException ( " Unexpected ▁ eval ▁ ( " + ve . getClass ( ) . getName ( ) + " ) " ) ; }
public synchronized List < IndexCommit > getSnapshots ( ) { return new ArrayList <> ( indexCommits . values ( ) ) ; }
public static int subIndex ( int n , int [ ] docStarts ) { int size = docStarts . length ; int lo = 0 ; int hi = size - 1 ; while ( hi >= lo ) { int mid = ( lo + hi ) >>> 1 ; int midValue = docStarts [ mid ] ; if ( n < midValue ) hi = mid - 1 ; else if ( n > midValue ) lo = mid + 1 ; else { while ( mid + 1 < size && docStarts [ mid + 1 ] == midValue ) { mid ++ ; } return mid ; } } return hi ; }
public static Date getJavaDate ( double date , boolean use1904windowing ) { return getJavaDate ( date , use1904windowing , null , false ) ; }
public CharSequence getLastOnPath ( CharSequence key ) { Row now = getRow ( root ) ; int w ; CharSequence last = null ; StrEnum e = new StrEnum ( key , forward ) ; for ( int i = 0 ; i < key . length ( ) - 1 ; i ++ ) { Character ch = e . next ( ) ; w = now . getCmd ( ch ) ; if ( w >= 0 ) { last = cmds . get ( w ) ; } w = now . getRef ( ch ) ; if ( w >= 0 ) { now = getRow ( w ) ; } else { return last ; } } w = now . getCmd ( e . next ( ) ) ; return ( w >= 0 ) ? cmds . get ( w ) : last ; }
public Hashtable ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( " Capacity : ▁ " + capacity ) ; } if ( capacity == 0 ) { @ SuppressWarnings ( " unchecked " ) HashtableEntry < K , V > [ ] tab = ( HashtableEntry < K , V > [ ] ) EMPTY_TABLE ; table = tab ; threshold = - 1 ; return ; } if ( capacity < MINIMUM_CAPACITY ) { capacity = MINIMUM_CAPACITY ; } else if ( capacity > MAXIMUM_CAPACITY ) { capacity = MAXIMUM_CAPACITY ; } else { capacity = roundUpToPowerOfTwo ( capacity ) ; } makeTable ( capacity ) ; }
public void reset ( ) { heads . clear ( ) ; heads . addAll ( headsStartValue ) ; }
public CreatePlacementGroupResult createPlacementGroup ( CreatePlacementGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePlacementGroup ( request ) ; }
public final float maxCharsPerByte ( ) { return maxCharsPerByte ; }
public static String getRFC2616Date ( Date date ) { SimpleDateFormat df = new SimpleDateFormat ( FORMAT_RFC2616 , Locale . ENGLISH ) ; df . setTimeZone ( new SimpleTimeZone ( 0 , TIME_ZONE ) ) ; return df . format ( date ) ; }
public ListContributorInsightsResult listContributorInsights ( ListContributorInsightsRequest request ) { request = beforeClientExecution ( request ) ; return executeListContributorInsights ( request ) ; }
public void setPackedGitOpenFiles ( int fdLimit ) { packedGitOpenFiles = fdLimit ; }
public DBCluster failoverDBCluster ( FailoverDBClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeFailoverDBCluster ( request ) ; }
public StringBuilder insert ( int offset , double d ) { insert0 ( offset , Double . toString ( d ) ) ; return this ; }
public void serialize ( LittleEndianOutput out ) { futureHeader . serialize ( out ) ; out . writeShort ( isf_sharedFeatureType ) ; out . writeByte ( reserved1 ) ; out . writeInt ( ( int ) reserved2 ) ; out . writeShort ( cellRefs . length ) ; out . writeInt ( ( int ) cbFeatData ) ; out . writeShort ( reserved3 ) ; for ( int i = 0 ; i < cellRefs . length ; i ++ ) { cellRefs [ i ] . serialize ( out ) ; } sharedFeature . serialize ( out ) ; }
public void writeDouble ( double value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeDouble ( value ) ; }
public DisassociateWebsiteAuthorizationProviderResult disassociateWebsiteAuthorizationProvider ( DisassociateWebsiteAuthorizationProviderRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateWebsiteAuthorizationProvider ( request ) ; }
public final byte [ ] serialize ( ) { byte [ ] retval = new byte [ getRecordSize ( ) ] ; serialize ( 0 , retval ) ; return retval ; }
public Cell next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( " At ▁ last ▁ element " ) ; } HSSFCell cell = cells [ nextId ] ; thisId = nextId ; findNext ( ) ; return cell ; }
public static double [ ] grow ( double [ ] array ) { return grow ( array , 1 + array . length ) ; }
public synchronized StringBuffer insert ( int index , String string ) { insert0 ( index , string ) ; return this ; }
public DomainDetail describeDomain ( DescribeDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDomain ( request ) ; }
public void reset ( ) { this . reset ( true , true ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _reserved ) ; }
public int getStartOffset ( ) { return startOffset ; }
public synchronized String [ ] listAll ( ) throws IOException { final Set < String > files = new HashSet <> ( ) ; for ( String f : cacheDirectory . listAll ( ) ) { files . add ( f ) ; } for ( String f : in . listAll ( ) ) { files . add ( f ) ; } String [ ] result = files . toArray ( new String [ files . size ( ) ] ) ; Arrays . sort ( result ) ; return result ; }
public byte clearByte ( final byte holder ) { return ( byte ) clear ( holder ) ; }
public ScenarioProtectRecord getHCenter ( ) { return _scenarioProtectRecord ; }
public HSSFRow createRow ( int rownum ) { HSSFRow row = new HSSFRow ( _workbook , this , rownum ) ; row . setHeight ( getDefaultRowHeight ( ) ) ; row . getRowRecord ( ) . setBadFontHeight ( false ) ; addRow ( row , true ) ; return row ; }
public ListQueryExecutionsResult listQueryExecutions ( ListQueryExecutionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListQueryExecutions ( request ) ; }
public DeleteSuppressedDestinationResult deleteSuppressedDestination ( DeleteSuppressedDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSuppressedDestination ( request ) ; }
public CharsRef subtract ( CharsRef output , CharsRef inc ) { assert output != null ; assert inc != null ; if ( inc == NO_OUTPUT ) { return output ; } else if ( inc . length == output . length ) { return NO_OUTPUT ; } else { assert inc . length < output . length : " inc . length = " + inc . length + " ▁ vs ▁ output . length = " + output . length ; assert inc . length > 0 ; return new CharsRef ( output . chars , output . offset + inc . length , output . length - inc . length ) ; } }
public void requestCancelWorkflowExecution ( RequestCancelWorkflowExecutionRequest request ) { request = beforeClientExecution ( request ) ; executeRequestCancelWorkflowExecution ( request ) ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Arn arn = ( Arn ) o ; if ( ! partition . equals ( arn . partition ) ) { return false ; } if ( ! service . equals ( arn . service ) ) { return false ; } if ( region != null ? ! region . equals ( arn . region ) : arn . region != null ) { return false ; } if ( accountId != null ? ! accountId . equals ( arn . accountId ) : arn . accountId != null ) { return false ; } return resource . equals ( arn . resource ) ; }
public UpdateDataSetPermissionsResult updateDataSetPermissions ( UpdateDataSetPermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDataSetPermissions ( request ) ; }
public DeleteCloudFrontOriginAccessIdentityResult deleteCloudFrontOriginAccessIdentity ( DeleteCloudFrontOriginAccessIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCloudFrontOriginAccessIdentity ( request ) ; }
public TokenStream create ( TokenStream input ) { return new PortugueseMinimalStemFilter ( input ) ; }
public PutDashboardResult putDashboard ( PutDashboardRequest request ) { request = beforeClientExecution ( request ) ; return executePutDashboard ( request ) ; }
public void addChar ( char c , int width ) { charWidths . put ( Character . valueOf ( c ) , Integer . valueOf ( width ) ) ; }
public DeleteRoomSkillParameterResult deleteRoomSkillParameter ( DeleteRoomSkillParameterRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRoomSkillParameter ( request ) ; }
public String get ( String name , String dflt ) { String vals [ ] = ( String [ ] ) valByRound . get ( name ) ; if ( vals != null ) { return vals [ roundNumber % vals . length ] ; } String sval = props . getProperty ( name , dflt ) ; if ( sval == null ) { return null ; } if ( sval . indexOf ( " : " ) < 0 ) { return sval ; } else if ( sval . indexOf ( " :\\ " ) ▁ >= ▁ 0 ▁ || ▁ sval . indexOf ( " :/ " ) ▁ >= ▁ 0 ) ▁ { return ▁ sval ; } int ▁ k ▁ = ▁ sval . indexOf ( " : " ) ; String ▁ colName ▁ = ▁ sval . substring ( 0 , ▁ k ) ; sval ▁ = ▁ sval . substring ( k ▁ + ▁ 1 ) ; colForValByRound . put ( name , ▁ colName ) ; vals ▁ = ▁ propToStringArray ( sval ) ; valByRound . put ( name , ▁ vals ) ; return ▁ vals [ roundNumber ▁ % ▁ vals . length ] ; }
public DBClusterSnapshotAttributesResult describeDBClusterSnapshotAttributes ( DescribeDBClusterSnapshotAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBClusterSnapshotAttributes ( request ) ; }
public void addFile ( FileHeader fh ) { files . add ( fh ) ; }
public TokenStream create ( TokenStream input ) { return new ItalianLightStemFilter ( input ) ; }
public LinkedHashMap ( ) { init ( ) ; accessOrder = false ; }
public DeleteStackInstancesResult deleteStackInstances ( DeleteStackInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteStackInstances ( request ) ; }
public String toString ( ) { return " ( " + a . toString ( ) + " ▁ AND ▁ " + b . toString ( ) + " ) " ; }
public StringWriter ( ) { buf = new StringBuffer ( 16 ) ; lock = buf ; }
public List < MatchingDocs > getOriginalMatchingDocs ( ) { return super . getMatchingDocs ( ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { double result ; try { double d0 = singleOperandEvaluate ( arg0 , srcRowIndex , srcColumnIndex ) ; double d1 = singleOperandEvaluate ( arg1 , srcRowIndex , srcColumnIndex ) ; result = evaluate ( d0 , d1 ) ; checkValue ( result ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public String toString ( ) { return " [ HCENTER ] \ n " + " ▁ ▁ ▁ ▁ . hcenter ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + getHCenter ( ) + " \ n " + " [ / HCENTER ] \ n " ; }
public GetEbsEncryptionByDefaultResult getEbsEncryptionByDefault ( GetEbsEncryptionByDefaultRequest request ) { request = beforeClientExecution ( request ) ; return executeGetEbsEncryptionByDefault ( request ) ; }
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 34 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 25 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } } } } for ( int i = 0 ; i < 34 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; }
public int getCharWidth ( char c ) { Integer widthInteger = charWidths . get ( Character . valueOf ( c ) ) ; if ( widthInteger == null ) { return ' W ' == c ? 0 : getCharWidth ( ' W ' ) ; } return widthInteger ; }
public DescribeSecurityGroupReferencesResult describeSecurityGroupReferences ( DescribeSecurityGroupReferencesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSecurityGroupReferences ( request ) ; }
public final V getValue ( ) { return value ; }
public EscherContainerRecord getEscherContainer ( ) { for ( EscherRecord er : escherRecords ) { if ( er instanceof EscherContainerRecord ) { return ( EscherContainerRecord ) er ; } } return null ; }
public boolean removeShape ( HSSFShape shape ) { boolean isRemoved = getEscherContainer ( ) . removeChildRecord ( shape . getEscherContainer ( ) ) ; if ( isRemoved ) { shape . afterRemove ( this . getPatriarch ( ) ) ; shapes . remove ( shape ) ; } return isRemoved ; }
public boolean changeExternalReference ( String oldUrl , String newUrl ) { return linkTable . changeExternalReference ( oldUrl , newUrl ) ; }
public String toString ( ) { return " BLOCK : ▁ " + brToString ( prefix ) ; }
public static String pathToString ( String [ ] path ) { return pathToString ( path , path . length ) ; }
public final boolean isInRange ( int rowIx , int colIx ) { CellRangeAddress8Bit r = _range ; return r . getFirstRow ( ) <= rowIx && r . getLastRow ( ) >= rowIx && r . getFirstColumn ( ) <= colIx && r . getLastColumn ( ) >= colIx ; }
public RmCommand rm ( ) { return new RmCommand ( repo ) ; }
public static String [ ] parse ( String line ) { boolean insideQuote = false ; ArrayList < String > result = new ArrayList <> ( ) ; int quoteCount = 0 ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { char c = line . charAt ( i ) ; if ( c == QUOTE ) { insideQuote = ! insideQuote ; quoteCount ++ ; } if ( c == COMMA && ! insideQuote ) { String value = sb . toString ( ) ; value = unQuoteUnEscape ( value ) ; result . add ( value ) ; sb . setLength ( 0 ) ; continue ; } sb . append ( c ) ; } result . add ( sb . toString ( ) ) ; if ( quoteCount % 2 != 0 ) { return new String [ 0 ] ; } return result . toArray ( new String [ 0 ] ) ; }
public long get ( int index ) { final int o = index / 3 ; final int b = index % 3 ; final int shift = b * 21 ; return ( blocks [ o ] >>> shift ) & 2097151L ; }
public void connect ( PipedOutputStream src ) throws IOException { src . connect ( this ) ; }
public WeightedPhraseInfo ( Collection < WeightedPhraseInfo > toMerge ) { Iterator < WeightedPhraseInfo > toMergeItr = toMerge . iterator ( ) ; if ( ! toMergeItr . hasNext ( ) ) { throw new IllegalArgumentException ( " toMerge ▁ must ▁ contain ▁ at ▁ least ▁ one ▁ WeightedPhraseInfo . " ) ; } WeightedPhraseInfo first = toMergeItr . next ( ) ; @ SuppressWarnings ( { " rawtypes " , " unchecked " } ) Iterator < Toffs > [ ] allToffs = new Iterator [ toMerge . size ( ) ] ; termsInfos = new ArrayList <> ( ) ; seqnum = first . seqnum ; boost = first . boost ; allToffs [ 0 ] = first . termsOffsets . iterator ( ) ; int index = 1 ; while ( toMergeItr . hasNext ( ) ) { WeightedPhraseInfo info = toMergeItr . next ( ) ; boost += info . boost ; termsInfos . addAll ( info . termsInfos ) ; allToffs [ index ++ ] = info . termsOffsets . iterator ( ) ; } MergedIterator < Toffs > itr = new MergedIterator <> ( false , allToffs ) ; termsOffsets = new ArrayList <> ( ) ; if ( ! itr . hasNext ( ) ) { return ; } Toffs work = itr . next ( ) ; while ( itr . hasNext ( ) ) { Toffs current = itr . next ( ) ; if ( current . startOffset <= work . endOffset ) { work . endOffset = Math . max ( work . endOffset , current . endOffset ) ; } else { termsOffsets . add ( work ) ; work = current ; } } termsOffsets . add ( work ) ; }
public DescribeLoadBalancerPolicyTypesResult describeLoadBalancerPolicyTypes ( DescribeLoadBalancerPolicyTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLoadBalancerPolicyTypes ( request ) ; }
public Entry < K , V > next ( ) { return nextEntry ( ) ; }
public int getCmd ( Character way ) { Cell c = at ( way ) ; return ( c == null ) ? - 1 : c . cmd ; }
public int readInt ( ) { int ch1 = _in . readUByte ( ) ; int ch2 = _in . readUByte ( ) ; int ch3 = _in . readUByte ( ) ; int ch4 = _in . readUByte ( ) ; return ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 ) ; }
public String toString ( ) { return " Reverse " + super . toString ( ) ; }
public Explanation explain ( Explanation freq , long norm ) { return SimilarityBase . this . explain ( stats , freq , getLengthValue ( norm ) ) ; }
public static ListenerList getGlobalListenerList ( ) { return globalListeners ; }
public GetInvitationsCountResult getInvitationsCount ( GetInvitationsCountRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInvitationsCount ( request ) ; }
public static boolean equals ( float [ ] array1 , float [ ] array2 ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1. length != array2. length ) { return false ; } for ( int i = 0 ; i < array1. length ; i ++ ) { if ( Float . floatToIntBits ( array1 [ i ] ) != Float . floatToIntBits ( array2 [ i ] ) ) { return false ; } } return true ; }
public final V setValue ( V value ) { if ( value == null ) { throw new NullPointerException ( ) ; } V oldValue = this . value ; this . value = value ; return oldValue ; }
@ Override public boolean isEmpty ( ) { return Impl . this . isEmpty ( ) ; }
public void setCategoryLabelsCellRange ( CellRangeAddressBase range ) { Integer count = setVerticalCellRange ( dataCategoryLabels , range ) ; if ( count == null ) { return ; } series . setNumCategories ( ( short ) ( int ) count ) ; }
final public SrndQuery OrQuery ( ) throws ParseException { SrndQuery q ; ArrayList < SrndQuery > queries = null ; Token oprt = null ; q = AndQuery ( ) ; label_2 : while ( true ) { switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case OR : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_2 ; } oprt = jj_consume_token ( OR ) ; if ( queries == null ) { queries = new ArrayList < SrndQuery > ( ) ; queries . add ( q ) ; } q = AndQuery ( ) ; queries . add ( q ) ; } { if ( true ) return ( queries == null ) ? q : getOrQuery ( queries , true , oprt ) ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public DeleteScheduledActionResult deleteScheduledAction ( DeleteScheduledActionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteScheduledAction ( request ) ; }
public CharBuffer put ( String str , int start , int end ) { if ( start < 0 || end < start || end > str . length ( ) ) { throw new IndexOutOfBoundsException ( " str . length ( ) = " + str . length ( ) + " , ▁ start = " + start + " , ▁ end = " + end ) ; } if ( end - start > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = start ; i < end ; i ++ ) { put ( str . charAt ( i ) ) ; } return this ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( rt ) ; out . writeShort ( grbitFrt ) ; out . writeShort ( iObjectKind ) ; out . write ( unused ) ; }
public ChangeInfo ( String id , ChangeStatus status , java . util . Date submittedAt ) { setId ( id ) ; setStatus ( status . toString ( ) ) ; setSubmittedAt ( submittedAt ) ; }
public SwedishLightStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public ErrorMatcher ( int errorCode , CmpOp operator ) { super ( operator ) ; _value = errorCode ; }
public static Console getConsole ( ) { return console ; }
public UpdateTrialComponentResult updateTrialComponent ( UpdateTrialComponentRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTrialComponent ( request ) ; }
public AddCommand setWorkingTreeIterator ( WorkingTreeIterator f ) { workingTreeIterator = f ; return this ; }
public RefWriter ( Map < String , Ref > refs ) { if ( refs instanceof RefMap ) this . refs = refs . values ( ) ; elsethis . refs = RefComparator . sort ( refs . values ( ) ) ; }
public LazyAreaEval ( int firstRowIndex , int firstColumnIndex , int lastRowIndex , int lastColumnIndex , SheetRangeEvaluator evaluator ) { super ( evaluator , firstRowIndex , firstColumnIndex , lastRowIndex , lastColumnIndex ) ; _evaluator = evaluator ; }
public BatchSuspendUserResult batchSuspendUser ( BatchSuspendUserRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchSuspendUser ( request ) ; }
public CreateVpnGatewayRequest ( GatewayType type ) { setType ( type . toString ( ) ) ; }
public BundleInstanceResult bundleInstance ( BundleInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeBundleInstance ( request ) ; }
public ListDeploymentsResult listDeployments ( ListDeploymentsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDeployments ( request ) ; }
public String toString ( ) { return " ( FOLLOW ( " + path . toString ( ) + " ) " + " ▁ AND ▁ " + ANY_DIFF . toString ( ) + " ) " ; }
public DetectFacesResult detectFaces ( DetectFacesRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectFaces ( request ) ; }
public GetRegionsResult getRegions ( GetRegionsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRegions ( request ) ; }
public WikipediaTokenizerFactory ( Map < String , String > args ) { super ( args ) ; tokenOutput = getInt ( args , TOKEN_OUTPUT , WikipediaTokenizer . TOKENS_ONLY ) ; untokenizedTypes = getSet ( args , UNTOKENIZED_TYPES ) ; if ( untokenizedTypes == null ) { untokenizedTypes = Collections . emptySet ( ) ; } if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public int getSheetIndex ( String name ) { int retval = - 1 ; final int size = boundsheets . size ( ) ; for ( int k = 0 ; k < size ; k ++ ) { String sheet = getSheetName ( k ) ; if ( sheet . equalsIgnoreCase ( name ) ) { retval = k ; break ; } } return retval ; }
public PagedBytesDataInput getDataInput ( ) { if ( ! frozen ) { throw new IllegalStateException ( " must ▁ call ▁ freeze ( ) ▁ before ▁ getDataInput " ) ; } return new PagedBytesDataInput ( ) ; }
public AddTagsToResourceResult addTagsToResource ( AddTagsToResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeAddTagsToResource ( request ) ; }
public static int oversize ( int minTargetSize , int bytesPerElement ) { if ( minTargetSize < 0 ) { throw new IllegalArgumentException ( " invalid ▁ array ▁ size ▁ " + minTargetSize ) ; } if ( minTargetSize == 0 ) { return 0 ; } if ( minTargetSize > MAX_ARRAY_LENGTH ) { throw new IllegalArgumentException ( " requested ▁ array ▁ size ▁ " + minTargetSize + " ▁ exceeds ▁ maximum ▁ array ▁ in ▁ java ▁ ( " + MAX_ARRAY_LENGTH + " ) " ) ; } int extra = minTargetSize >> 3 ; if ( extra < 3 ) { extra = 3 ; } int newSize = minTargetSize + extra ; if ( newSize + 7 < 0 || newSize + 7 > MAX_ARRAY_LENGTH ) { return MAX_ARRAY_LENGTH ; } if ( Constants . JRE_IS_64BIT ) { switch ( bytesPerElement ) { case 4 : return ( newSize + 1 ) & 0x7ffffffe ; case 2 : return ( newSize + 3 ) & 0x7ffffffc ; case 1 : return ( newSize + 7 ) & 0x7ffffff8 ; case 8 : default : return newSize ; } } else { switch ( bytesPerElement ) { case 2 : return ( newSize + 1 ) & 0x7ffffffe ; case 1 : return ( newSize + 3 ) & 0x7ffffffc ; case 4 : case 8 : default : return newSize ; } } }
public IntervalSet complement ( IntSet vocabulary ) { if ( vocabulary == null || vocabulary . isNil ( ) ) { return null ; } IntervalSet vocabularyIS ; if ( vocabulary instanceof IntervalSet ) { vocabularyIS = ( IntervalSet ) vocabulary ; } else { vocabularyIS = new IntervalSet ( ) ; vocabularyIS . addAll ( vocabulary ) ; } return vocabularyIS . subtract ( this ) ; }
public BatchRefUpdate setRefLogMessage ( String msg , boolean appendStatus ) { if ( msg == null && ! appendStatus ) disableRefLog ( ) ; else if ( msg == null && appendStatus ) { refLogMessage = " " ; refLogIncludeResult = true ; } else { refLogMessage = msg ; refLogIncludeResult = appendStatus ; } return this ; }
public GetApnsVoipSandboxChannelResult getApnsVoipSandboxChannel ( GetApnsVoipSandboxChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApnsVoipSandboxChannel ( request ) ; }
public TokenStream create ( TokenStream input ) { return new ArabicNormalizationFilter ( input ) ; }
@ Override public boolean contains ( Object o ) { return Impl . this . containsValue ( o ) ; }
@ Override public boolean isEmpty ( ) { synchronized ( mutex ) { return c . isEmpty ( ) ; } }
public long get ( int index ) { return 0 ; }
public DescribeSecurityGroupsResult describeSecurityGroups ( ) { return describeSecurityGroups ( new DescribeSecurityGroupsRequest ( ) ) ; }
public ListPartsRequest ( String accountId , String vaultName , String uploadId ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; setUploadId ( uploadId ) ; }
public GetCloudFrontOriginAccessIdentityRequest ( String id ) { setId ( id ) ; }
public DescribeAlarmHistoryResult describeAlarmHistory ( DescribeAlarmHistoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAlarmHistory ( request ) ; }
public DescribeJobRequest ( String accountId , String vaultName , String jobId ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; setJobId ( jobId ) ; }
public DeleteTagCommand setTags ( String ... tags ) { checkCallable ( ) ; this . tags . clear ( ) ; this . tags . addAll ( Arrays . asList ( tags ) ) ; return this ; }
public ListVoiceConnectorGroupsResult listVoiceConnectorGroups ( ListVoiceConnectorGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListVoiceConnectorGroups ( request ) ; }
public Intercept ( ) { func = new LinearRegressionFunction ( FUNCTION . INTERCEPT ) ; }
public ProvisionByoipCidrResult provisionByoipCidr ( ProvisionByoipCidrRequest request ) { request = beforeClientExecution ( request ) ; return executeProvisionByoipCidr ( request ) ; }
public BatchGetApplicationRevisionsResult batchGetApplicationRevisions ( BatchGetApplicationRevisionsRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetApplicationRevisions ( request ) ; }
public void expandRow ( int rowNumber ) { if ( rowNumber == - 1 ) return ; if ( ! isRowGroupCollapsed ( rowNumber ) ) { return ; } int startIdx = findStartOfRowOutlineGroup ( rowNumber ) ; RowRecord row = getRow ( startIdx ) ; int endIdx = findEndOfRowOutlineGroup ( rowNumber ) ; if ( ! isRowGroupHiddenByParent ( rowNumber ) ) { for ( int i = startIdx ; i <= endIdx ; i ++ ) { RowRecord otherRow = getRow ( i ) ; if ( row . getOutlineLevel ( ) == otherRow . getOutlineLevel ( ) || ! isRowGroupCollapsed ( i ) ) { otherRow . setZeroHeight ( false ) ; } } } getRow ( endIdx + 1 ) . setColapsed ( false ) ; }
public GetSendQuotaResult getSendQuota ( GetSendQuotaRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSendQuota ( request ) ; }
public FeatFormulaErr2 ( RecordInputStream in ) { errorCheck = in . readInt ( ) ; }
public DefineAnalysisSchemeResult defineAnalysisScheme ( DefineAnalysisSchemeRequest request ) { request = beforeClientExecution ( request ) ; return executeDefineAnalysisScheme ( request ) ; }
public boolean equals ( Object o ) { return o instanceof IrishStemmer ; }
public UTF8Sequence ( ) { bytes = new UTF8Byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { bytes [ i ] = new UTF8Byte ( ) ; } }
public ListPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public RegisterStreamConsumerResult registerStreamConsumer ( RegisterStreamConsumerRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterStreamConsumer ( request ) ; }
public Formula copy ( ) { return this ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; MergeInfo other = ( MergeInfo ) obj ; if ( estimatedMergeBytes != other . estimatedMergeBytes ) return false ; if ( isExternal != other . isExternal ) return false ; if ( mergeMaxNumSegments != other . mergeMaxNumSegments ) return false ; if ( totalMaxDoc != other . totalMaxDoc ) return false ; return true ; }
public float score ( float freq , long norm ) { float sum = 0.0f ; for ( SimScorer subScorer : subScorers ) { sum += subScorer . score ( freq , norm ) ; } return sum ; }
public AddTagsRequest ( String resourceId , java . util . List < Tag > tags ) { setResourceId ( resourceId ) ; setTags ( tags ) ; }
public DescribeEC2InstanceLimitsResult describeEC2InstanceLimits ( DescribeEC2InstanceLimitsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEC2InstanceLimits ( request ) ; }
public BlameGenerator setFollowFileRenames ( boolean follow ) { if ( follow ) renameDetector = new RenameDetector ( getRepository ( ) ) ; elserenameDetector = null ; return this ; }
public GetStagesResult getStages ( GetStagesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetStages ( request ) ; }
public void setParsedExpression ( Ptg [ ] ptgs ) { field_5_name_definition = Formula . create ( ptgs ) ; }
public int getRightId ( int wordId ) { return rightIds [ wordId ] ; }
public GetChangeRequest ( String id ) { setId ( id ) ; }
public RegisterPhotoRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " RegisterPhoto " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public void more ( ) { _type = MORE ; }
public final Buffer position ( int newPosition ) { positionImpl ( newPosition ) ; return this ; }
public ScenarioProtectRecord ( RecordInputStream in ) { field_1_protect = in . readShort ( ) ; }
public static TopFieldDocs merge ( Sort sort , int topN , TopFieldDocs [ ] shardHits ) { return merge ( sort , 0 , topN , shardHits ) ; }
public LexerModeAction ( int mode ) { this . mode = mode ; }
public boolean canExecute ( File f ) { return false ; }
public int preceding ( int pos ) { if ( pos < text . getBeginIndex ( ) || pos > text . getEndIndex ( ) ) { throw new IllegalArgumentException ( " offset ▁ out ▁ of ▁ bounds " ) ; } else if ( 0 == sentenceStarts . length ) { text . setIndex ( text . getBeginIndex ( ) ) ; currentSentence = 0 ; return DONE ; } else if ( pos < sentenceStarts [ 0 ] ) { text . setIndex ( text . getBeginIndex ( ) ) ; currentSentence = 0 ; return DONE ; } else { currentSentence = sentenceStarts . length / 2 ; moveToSentenceAt ( pos , 0 , sentenceStarts . length - 1 ) ; if ( 0 == currentSentence ) { text . setIndex ( text . getBeginIndex ( ) ) ; return DONE ; } else { text . setIndex ( sentenceStarts [ -- currentSentence ] ) ; return current ( ) ; } } }
public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( " Cannot ▁ serialize ▁ a ▁ dummy ▁ record " ) ; }
public DetachObjectResult detachObject ( DetachObjectRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachObject ( request ) ; }
public WorkflowTypeDetail describeWorkflowType ( DescribeWorkflowTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWorkflowType ( request ) ; }
public static void clearModels ( ) { sentenceModels . clear ( ) ; tokenizerModels . clear ( ) ; posTaggerModels . clear ( ) ; chunkerModels . clear ( ) ; nerModels . clear ( ) ; lemmaDictionaries . clear ( ) ; }
public static String refLockFor ( String name ) { return name + LOCK_SUFFIX ; }
public DeleteComponentResult deleteComponent ( DeleteComponentRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteComponent ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ STYLE ] \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . xf □ index □ raw ▁ = " ) . append ( HexDump . shortToHex ( field_1_xf_index ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . type ▁ ▁ ▁ ▁ ▁ = " ) . append ( isBuiltin ( ) ? " built - in " : " user - defined " ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . xf □ index ▁ = " ) . append ( HexDump . shortToHex ( getXFIndex ( ) ) ) . append ( " \ n " ) ; if ( isBuiltin ( ) ) { sb . append ( " ▁ ▁ ▁ ▁ . builtin □ style = " ) . append ( HexDump . byteToHex ( field_2_builtin_style ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . outline □ level = " ) . append ( HexDump . byteToHex ( field_3_outline_style_level ) ) . append ( " \ n " ) ; } else { sb . append ( " ▁ ▁ ▁ ▁ . name ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( getName ( ) ) . append ( " \ n " ) ; } sb . append ( " [ / STYLE ] \ n " ) ; return sb . toString ( ) ; }
public DescribeAuditStreamConfigurationResult describeAuditStreamConfiguration ( DescribeAuditStreamConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAuditStreamConfiguration ( request ) ; }
public String toString ( ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " < any ▁ field = ' " ▁ + ▁ this . field ▁ + ▁ " ' ▁ ▁ matchelements = " + this . minimumMatchingmElements + " /> " ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " < any ▁ field = ' " ) . append ( this . field ) . append ( " ' ▁ ▁ matchelements = " ) . append ( this . minimumMatchingmElements ) . append ( ' > ' ) ; for ( QueryNode clause : getChildren ( ) ) { sb . append ( " \ n " ) ; sb . append ( clause . toString ( ) ) ; } sb . append ( " \ n </ any > " ) ; return sb . toString ( ) ; }
public AssociateSkillWithSkillGroupResult associateSkillWithSkillGroup ( AssociateSkillWithSkillGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateSkillWithSkillGroup ( request ) ; }
public String getFetchedFrom ( ) { return this . fetchedFrom ; }
public static Counter newCounter ( boolean threadSafe ) { return threadSafe ? new AtomicCounter ( ) : new SerialCounter ( ) ; }
public FloatBuffer slice ( ) { return new ReadWriteFloatArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public ListProcessingJobsResult listProcessingJobs ( ListProcessingJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListProcessingJobs ( request ) ; }
public void recover ( RecognitionException re ) { _input . consume ( ) ; }
public CreateTemplateAliasResult createTemplateAlias ( CreateTemplateAliasRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTemplateAlias ( request ) ; }
public final Buffer reset ( ) { if ( mark == UNSET_MARK ) { throw new InvalidMarkException ( " Mark ▁ not ▁ set " ) ; } position = mark ; return this ; }
@ Override public synchronized boolean equals ( Object object ) { return ( object instanceof Map ) && entrySet ( ) . equals ( ( ( Map <? , ?> ) object ) . entrySet ( ) ) ; }
public void tagResource ( TagResourceRequest request ) { request = beforeClientExecution ( request ) ; executeTagResource ( request ) ; }
public BytesRef common ( BytesRef output1 , BytesRef output2 ) { assert output1 != null ; assert output2 != null ; int pos1 = output1. offset ; int pos2 = output2. offset ; int stopAt1 = pos1 + Math . min ( output1. length , output2. length ) ; while ( pos1 < stopAt1 ) { if ( output1. bytes [ pos1 ] != output2. bytes [ pos2 ] ) { break ; } pos1 ++ ; pos2 ++ ; } if ( pos1 == output1. offset ) { return NO_OUTPUT ; } else if ( pos1 == output1. offset + output1. length ) { return output1 ; } else if ( pos2 == output2. offset + output2. length ) { return output2 ; } else { return new BytesRef ( output1. bytes , output1. offset , pos1 - output1. offset ) ; } }
public E getFirst ( ) { return getFirstImpl ( ) ; }
public ObjectId computeId ( ObjectInserter ins ) { if ( buf != null ) return ins . idFor ( OBJ_TREE , buf , 0 , ptr ) ; final long len = overflowBuffer . length ( ) ; try { return ins . idFor ( OBJ_TREE , len , overflowBuffer . openInputStream ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public TransferDomainResult transferDomain ( TransferDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeTransferDomain ( request ) ; }
public String toString ( ) { synchronized ( lock ) { return new String ( buf , 0 , count ) ; } }
public DescribeReservedNodeOfferingsResult describeReservedNodeOfferings ( DescribeReservedNodeOfferingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReservedNodeOfferings ( request ) ; }
public String toString ( String field ) { StringBuilder buffer = new StringBuilder ( ) ; if ( ! term . field ( ) . equals ( field ) ) { buffer . append ( term . field ( ) ) ; buffer . append ( " : " ) ; } buffer . append ( term . text ( ) ) ; return buffer . toString ( ) ; }
public IntBuffer duplicate ( ) { ByteBuffer bb = byteBuffer . duplicate ( ) . order ( byteBuffer . order ( ) ) ; IntToByteBufferAdapter buf = new IntToByteBufferAdapter ( bb ) ; buf . limit = limit ; buf . position = position ; buf . mark = mark ; return buf ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SERTOCRT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . chartGroupIndex ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getChartGroupIndex ( ) ) ) . append ( " ▁ ( " ) . append ( getChartGroupIndex ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " [ / SERTOCRT ] \ n " ) ; return buffer . toString ( ) ; }
public boolean canHandle ( URIish uri ) { return canHandle ( uri , null , null ) ; }
public GetImportJobResult getImportJob ( GetImportJobRequest request ) { request = beforeClientExecution ( request ) ; return executeGetImportJob ( request ) ; }
public LookupDeveloperIdentityResult lookupDeveloperIdentity ( LookupDeveloperIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeLookupDeveloperIdentity ( request ) ; }
public FloatBuffer put ( float c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } backingArray [ offset + position ++ ] = c ; return this ; }
public RefModeRecord ( RecordInputStream in ) { field_1_mode = in . readShort ( ) ; }
public BulkOperationPackedSingleBlock ( int bitsPerValue ) { this . bitsPerValue = bitsPerValue ; this . valueCount = 64 / bitsPerValue ; this . mask = ( 1L << bitsPerValue ) - 1 ; }
public static String dateToString ( Date date , Resolution resolution ) { return timeToString ( date . getTime ( ) , resolution ) ; }
public DescribeUserHierarchyStructureResult describeUserHierarchyStructure ( DescribeUserHierarchyStructureRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeUserHierarchyStructure ( request ) ; }
public GetDomainsResult getDomains ( GetDomainsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDomains ( request ) ; }
public int getStreamFileThreshold ( ) { return streamFileThreshold ; }
public BatchGetDeploymentInstancesResult batchGetDeploymentInstances ( BatchGetDeploymentInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetDeploymentInstances ( request ) ; }
public GetIdentityVerificationAttributesResult getIdentityVerificationAttributes ( GetIdentityVerificationAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIdentityVerificationAttributes ( request ) ; }
public LittleEndianOutputStream ( OutputStream out ) { super ( out ) ; }
public GetDeploymentGroupResult getDeploymentGroup ( GetDeploymentGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDeploymentGroup ( request ) ; }
public boolean containsKey ( char [ ] text , int off , int len ) { if ( text == null ) throw new NullPointerException ( ) ; return false ; }
public void inform ( ResourceLoader loader ) throws IOException { clazz = registry . get ( name . toUpperCase ( Locale . ROOT ) ) ; if ( clazz == null ) { clazz = resolveEncoder ( name , loader ) ; } if ( maxCodeLength != null ) { try { setMaxCodeLenMethod = clazz . getMethod ( " setMaxCodeLen " , int . class ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( " Encoder ▁ " + name + " ▁ / ▁ " + clazz + " ▁ does ▁ not ▁ support ▁ " + MAX_CODE_LENGTH , e ) ; } } getEncoder ( ) ; }
public DescribeOrganizationConfigurationResult describeOrganizationConfiguration ( DescribeOrganizationConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeOrganizationConfiguration ( request ) ; }
public AbbreviatedObjectId getOldId ( ) { return getOldId ( 0 ) ; }
public UpdateRuleMetadataResult updateRuleMetadata ( UpdateRuleMetadataRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRuleMetadata ( request ) ; }
public K lowerKey ( K key ) { Entry < K , V > entry = findBounded ( key , LOWER ) ; return entry != null ? entry . getKey ( ) : null ; }
public FtCfSubRecord clone ( ) { return copy ( ) ; }
public HCenterRecord clone ( ) { return copy ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( field_1_foregroundColor ) ; out . writeInt ( field_2_backgroundColor ) ; out . writeShort ( field_3_pattern ) ; out . writeShort ( field_4_formatFlags ) ; out . writeShort ( field_5_forecolorIndex ) ; out . writeShort ( field_6_backcolorIndex ) ; }
public GetDashboardEmbedUrlResult getDashboardEmbedUrl ( GetDashboardEmbedUrlRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDashboardEmbedUrl ( request ) ; }
public BinaryDocValues getBinaryDocValues ( String field ) { return getSortedDocValues ( field , DocValuesType . BINARY ) ; }
public TreeFilter clone ( ) { final TreeFilter [ ] s = new TreeFilter [ subfilters . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) s [ i ] = subfilters [ i ] . clone ( ) ; return new List ( s ) ; }
public DeleteApnsVoipSandboxChannelResult deleteApnsVoipSandboxChannel ( DeleteApnsVoipSandboxChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApnsVoipSandboxChannel ( request ) ; }
public FreeRefFunction findFunction ( String name ) { return _functionsByName . get ( name . toUpperCase ( Locale . ROOT ) ) ; }
public Credentials ( String accessKeyId , String secretAccessKey , String sessionToken , java . util . Date expiration ) { setAccessKeyId ( accessKeyId ) ; setSecretAccessKey ( secretAccessKey ) ; setSessionToken ( sessionToken ) ; setExpiration ( expiration ) ; }
public ReadTask ( PerfRunData runData ) { super ( runData ) ; if ( withSearch ( ) ) { queryMaker = getQueryMaker ( ) ; } else { queryMaker = null ; } }
public int getPositionIncrementGap ( String fieldName ) { return 0 ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( _option_flags ) ; serializeUnicodeString ( _promptTitle , out ) ; serializeUnicodeString ( _errorTitle , out ) ; serializeUnicodeString ( _promptText , out ) ; serializeUnicodeString ( _errorText , out ) ; out . writeShort ( _formula1. getEncodedTokenSize ( ) ) ; out . writeShort ( _not_used_1 ) ; _formula1. serializeTokens ( out ) ; out . writeShort ( _formula2. getEncodedTokenSize ( ) ) ; out . writeShort ( _not_used_2 ) ; _formula2. serializeTokens ( out ) ; _regions . serialize ( out ) ; }
public String toString ( ) { return " [ PRINTHEADERS ] \ n " + " ▁ ▁ ▁ ▁ . printheaders ▁ ▁ ▁ = ▁ " + getPrintHeaders ( ) + " \ n " + " [ / PRINTHEADERS ] \ n " ; }
public GetConferencePreferenceResult getConferencePreference ( GetConferencePreferenceRequest request ) { request = beforeClientExecution ( request ) ; return executeGetConferencePreference ( request ) ; }
public static BitSet getAlts ( Collection < BitSet > altsets ) { BitSet all = new BitSet ( ) ; for ( BitSet alts : altsets ) { all . or ( alts ) ; } return all ; }
public ListTrafficPolicyInstancesResult listTrafficPolicyInstances ( ListTrafficPolicyInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeListTrafficPolicyInstances ( request ) ; }
public void init ( Repository src ) { repository = src ; }
public StandardSyntaxParser ( StandardSyntaxParserTokenManager tm ) { token_source = tm ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 25 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public ModifyDBClusterEndpointResult modifyDBClusterEndpoint ( ModifyDBClusterEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBClusterEndpoint ( request ) ; }
public DescribeTransitGatewaysResult describeTransitGateways ( DescribeTransitGatewaysRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTransitGateways ( request ) ; }
public GetSimilarPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetSimilarPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public GetProposalResult getProposal ( GetProposalRequest request ) { request = beforeClientExecution ( request ) ; return executeGetProposal ( request ) ; }
public AddJobFlowStepsRequest ( String jobFlowId ) { setJobFlowId ( jobFlowId ) ; }
public StartInstancesRequest ( java . util . List < String > instanceIds ) { setInstanceIds ( instanceIds ) ; }
public GetRawMessageContentResult getRawMessageContent ( GetRawMessageContentRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRawMessageContent ( request ) ; }
public RevObject next ( ) { return objItr . hasNext ( ) ? objItr . next ( ) : null ; }
final public List < SrndQuery > FieldsQueryList ( ) throws ParseException { SrndQuery q ; ArrayList < SrndQuery > queries = new ArrayList < SrndQuery > ( ) ; jj_consume_token ( LPAREN ) ; q = FieldsQuery ( ) ; queries . add ( q ) ; label_7 : while ( true ) { jj_consume_token ( COMMA ) ; q = FieldsQuery ( ) ; queries . add ( q ) ; switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case COMMA : ; break ; default : jj_la1 [ 7 ] = jj_gen ; break label_7 ; } } jj_consume_token ( RPAREN ) ; { if ( true ) return queries ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public boolean contains ( long value ) { for ( int i = 0 ; i < count ; i ++ ) if ( entries [ i ] == value ) return true ; return false ; }
public static boolean matchesExtension ( String filename , String ext ) { return filename . endsWith ( " . " + ext ) ; }
public ObjectId idFor ( int type , byte [ ] data , int off , int len ) { return delegate ( ) . idFor ( type , data , off , len ) ; }
public void remove ( ) { parent . remove ( this ) ; }
public DisassociateDeviceFromRoomResult disassociateDeviceFromRoom ( DisassociateDeviceFromRoomRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateDeviceFromRoom ( request ) ; }
final public ModifierQueryNode . Modifier Modifiers ( ) throws ParseException { ModifierQueryNode . Modifier ret = ModifierQueryNode . Modifier . MOD_NONE ; switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case NOT : case PLUS : case MINUS : switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case PLUS : jj_consume_token ( PLUS ) ; ret = ModifierQueryNode . Modifier . MOD_REQ ; break ; case MINUS : jj_consume_token ( MINUS ) ; ret = ModifierQueryNode . Modifier . MOD_NOT ; break ; case NOT : jj_consume_token ( NOT ) ; ret = ModifierQueryNode . Modifier . MOD_NOT ; break ; default : jj_la1 [ 0 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } break ; default : jj_la1 [ 1 ] = jj_gen ; ; } { if ( true ) return ret ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public final RevCommit getParent ( int nth ) { return parents [ nth ] ; }
public boolean hasPrevious ( ) { return iterator . previousIndex ( ) >= start ; }
public TerminateWorkspacesResult terminateWorkspaces ( TerminateWorkspacesRequest request ) { request = beforeClientExecution ( request ) ; return executeTerminateWorkspaces ( request ) ; }
public long getEntryLastModified ( ) { return current ( ) . getLastModified ( ) ; }
public CancelConversionTaskResult cancelConversionTask ( CancelConversionTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelConversionTask ( request ) ; }
public InfoSubRecord ( int streamPos , int bucketSstOffset ) { field_1_stream_pos = streamPos ; field_2_bucket_sst_offset = bucketSstOffset ; }
public boolean contains ( Object o ) { return map . containsKey ( o ) ; }
public String toString ( ) { return " ' " ▁ + ▁ ch ▁ + ▁ " ' ▁ @ ▁ " + pos ; }
public Step ( String name , Rule rules [ ] , int min , String suffixes [ ] ) { this . name = name ; this . rules = rules ; if ( min == 0 ) { min = Integer . MAX_VALUE ; for ( Rule r : rules ) min = Math . min ( min , r . min + r . suffix . length ) ; } this . min = min ; if ( suffixes == null || suffixes . length == 0 ) { this . suffixes = null ; } else { this . suffixes = new char [ suffixes . length ] [ ] ; for ( int i = 0 ; i < suffixes . length ; i ++ ) this . suffixes [ i ] = suffixes [ i ] . toCharArray ( ) ; } }
public E get ( int key , E valueIfKeyNotFound ) { int i = binarySearch ( mKeys , 0 , mSize , key ) ; if ( i < 0 || mValues [ i ] == DELETED ) { return valueIfKeyNotFound ; } else { return ( E ) mValues [ i ] ; } }
public final ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { if ( args . length != 0 ) { return ErrorEval . VALUE_INVALID ; } return evaluate ( srcRowIndex , srcColumnIndex ) ; }
public void enterRecursionRule ( ParserRuleContext localctx , int state , int ruleIndex , int precedence ) { setState ( state ) ; _precedenceStack . push ( precedence ) ; _ctx = localctx ; _ctx . start = _input . LT ( 1 ) ; if ( _parseListeners != null ) { triggerEnterRuleEvent ( ) ; } }
public GlobalReplicationGroup increaseNodeGroupsInGlobalReplicationGroup ( IncreaseNodeGroupsInGlobalReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeIncreaseNodeGroupsInGlobalReplicationGroup ( request ) ; }
public static String format ( String rawSheetName ) { StringBuilder sb = new StringBuilder ( ( rawSheetName == null ? 0 : rawSheetName . length ( ) ) + 2 ) ; appendFormat ( sb , rawSheetName ) ; return sb . toString ( ) ; }
public DescribeTerminationPolicyTypesResult describeTerminationPolicyTypes ( DescribeTerminationPolicyTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTerminationPolicyTypes ( request ) ; }
public DescribeScheduledActionsResult describeScheduledActions ( ) { return describeScheduledActions ( new DescribeScheduledActionsRequest ( ) ) ; }
public boolean hasSourceData ( int start , int end ) { for ( ; start < end ; start ++ ) if ( sourceLines [ start ] == 0 ) return false ; return true ; }
public ListImportsResult listImports ( ListImportsRequest request ) { request = beforeClientExecution ( request ) ; return executeListImports ( request ) ; }
public DescribeInterconnectsResult describeInterconnects ( ) { return describeInterconnects ( new DescribeInterconnectsRequest ( ) ) ; }
public DeleteEventSubscriptionResult deleteEventSubscription ( DeleteEventSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEventSubscription ( request ) ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; int remainingBytes = thedata . length ; LittleEndian . putInt ( data , offset + 4 , remainingBytes ) ; System . arraycopy ( thedata , 0 , data , offset + 8 , thedata . length ) ; int pos = offset + 8 + thedata . length ; listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; int size = pos - offset ; if ( size != getRecordSize ( ) ) { throw new RecordFormatException ( size + " ▁ bytes ▁ written ▁ but ▁ getRecordSize ( ) ▁ reports ▁ " + getRecordSize ( ) ) ; } return size ; }
public void write ( int oneChar ) { synchronized ( lock ) { expand ( 1 ) ; buf [ count ++ ] = ( char ) oneChar ; } }
public DeletedRef3DPtg ( int externSheetIndex ) { field_1_index_extern_sheet = externSheetIndex ; unused1 = 0 ; }
public IndexUpgrader ( Directory dir , IndexWriterConfig iwc , boolean deletePriorCommits ) { this . dir = dir ; this . iwc = iwc ; this . deletePriorCommits = deletePriorCommits ; }
public DetachVpnGatewayRequest ( String vpnGatewayId , String vpcId ) { setVpnGatewayId ( vpnGatewayId ) ; setVpcId ( vpcId ) ; }
public RebootInstancesRequest ( java . util . List < String > instanceIds ) { setInstanceIds ( instanceIds ) ; }
public E remove ( int index ) { synchronized ( mutex ) { return delegate ( ) . remove ( index ) ; } }
public DescribeInstanceAttributeResult describeInstanceAttribute ( DescribeInstanceAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInstanceAttribute ( request ) ; }
public void cloneStyleFrom ( CellStyle source ) { if ( source instanceof HSSFCellStyle ) { this . cloneStyleFrom ( ( HSSFCellStyle ) source ) ; } else { throw new IllegalArgumentException ( " Can ▁ only ▁ clone ▁ from ▁ one ▁ HSSFCellStyle ▁ to ▁ another , ▁ not ▁ between ▁ HSSFCellStyle ▁ and ▁ XSSFCellStyle " ) ; } }
public final String readUTF ( ) throws IOException { return decodeUTF ( readUnsignedShort ( ) ) ; }
public GetDataEndpointResult getDataEndpoint ( GetDataEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDataEndpoint ( request ) ; }
public AddApplicationOutputResult addApplicationOutput ( AddApplicationOutputRequest request ) { request = beforeClientExecution ( request ) ; return executeAddApplicationOutput ( request ) ; }
public LargeObjectException ( AnyObjectId id ) { setObjectId ( id ) ; }
public void trimToSize ( ) { if ( n < array . length ) { char [ ] aux = new char [ n ] ; System . arraycopy ( array , 0 , aux , 0 , n ) ; array = aux ; } }
public UpdateFacetResult updateFacet ( UpdateFacetRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFacet ( request ) ; }
public DeleteDomainRequest ( String domainName ) { setDomainName ( domainName ) ; }
public String getReading ( ) { return dictionary . getReading ( wordId , surfaceForm , offset , length ) ; }
public FloatBuffer compact ( ) { System . arraycopy ( backingArray , position + offset , backingArray , offset , remaining ( ) ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; }
public String toString ( ) { return super . toString ( ) ; }
public void set ( int index , long value ) { ensureCapacity ( value ) ; current . set ( index , value ) ; }
public void serialize ( LittleEndianOutput out ) { String username = getUsername ( ) ; boolean is16bit = StringUtil . hasMultibyte ( username ) ; out . writeShort ( username . length ( ) ) ; out . writeByte ( is16bit ? 0x01 : 0x00 ) ; if ( is16bit ) { StringUtil . putUnicodeLE ( username , out ) ; } else { StringUtil . putCompressedUnicode ( username , out ) ; } int encodedByteCount = 3 + username . length ( ) * ( is16bit ? 2 : 1 ) ; int paddingSize = DATA_SIZE - encodedByteCount ; out . write ( PADDING , 0 , paddingSize ) ; }
public boolean isExpired ( ) { return false ; }
public ListJobsRequest ( String accountId , String vaultName ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; }
public SheetRefEvaluator getSheetEvaluator ( int sheetIndex ) { if ( sheetIndex < _firstSheetIndex || sheetIndex > _lastSheetIndex ) { throw new IllegalArgumentException ( " Invalid ▁ SheetIndex : ▁ " + sheetIndex + " ▁ - ▁ Outside ▁ range ▁ " + _firstSheetIndex + " ▁ : ▁ " + _lastSheetIndex ) ; } return _sheetEvaluators [ sheetIndex - _firstSheetIndex ] ; }
public static String [ ] stringToPath ( String s ) { List < String > parts = new ArrayList <> ( ) ; int length = s . length ( ) ; if ( length == 0 ) { return new String [ 0 ] ; } char [ ] buffer = new char [ length ] ; int upto = 0 ; boolean lastEscape = false ; for ( int i = 0 ; i < length ; i ++ ) { char ch = s . charAt ( i ) ; if ( lastEscape ) { buffer [ upto ++ ] = ch ; lastEscape = false ; } else if ( ch == ESCAPE_CHAR ) { lastEscape = true ; } else if ( ch == DELIM_CHAR ) { parts . add ( new String ( buffer , 0 , upto ) ) ; upto = 0 ; } else { buffer [ upto ++ ] = ch ; } } parts . add ( new String ( buffer , 0 , upto ) ) ; assert ! lastEscape ; return parts . toArray ( new String [ parts . size ( ) ] ) ; }
public CreateDirectConnectGatewayResult createDirectConnectGateway ( CreateDirectConnectGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDirectConnectGateway ( request ) ; }
public GetMLModelResult getMLModel ( GetMLModelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMLModel ( request ) ; }
public boolean isValid ( ) { if ( bytes == null ) { throw new IllegalStateException ( " bytes ▁ is ▁ null " ) ; } if ( length < 0 ) { throw new IllegalStateException ( " length ▁ is ▁ negative : ▁ " + length ) ; } if ( length > bytes . length ) { throw new IllegalStateException ( " length ▁ is ▁ out ▁ of ▁ bounds : ▁ " + length + " , bytes . length = " + bytes . length ) ; } if ( offset < 0 ) { throw new IllegalStateException ( " offset ▁ is ▁ negative : ▁ " + offset ) ; } if ( offset > bytes . length ) { throw new IllegalStateException ( " offset ▁ out ▁ of ▁ bounds : ▁ " + offset + " , bytes . length = " + bytes . length ) ; } if ( offset + length < 0 ) { throw new IllegalStateException ( " offset + length ▁ is ▁ negative : ▁ offset = " + offset + " , length = " + length ) ; } if ( offset + length > bytes . length ) { throw new IllegalStateException ( " offset + length ▁ out ▁ of ▁ bounds : ▁ offset = " + offset + " , length = " + length + " , bytes . length = " + bytes . length ) ; } return true ; }
public String toString ( ) { return getName ( ) ; }
public DescribeIAMPolicyAssignmentResult describeIAMPolicyAssignment ( DescribeIAMPolicyAssignmentRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIAMPolicyAssignment ( request ) ; }
public boolean isRefLogIncludingResult ( ) { return refLogIncludeResult ; }
public DeleteStreamingDistributionResult deleteStreamingDistribution ( DeleteStreamingDistributionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteStreamingDistribution ( request ) ; }
public RawSubStringPattern ( String patternText ) { if ( patternText . length ( ) == 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . cannotMatchOnEmptyString ) ; needleString = patternText ; final byte [ ] b = Constants . encode ( patternText ) ; needle = new byte [ b . length ] ; for ( int i = 0 ; i < b . length ; i ++ ) needle [ i ] = lc ( b [ i ] ) ; }
public ListRulesResult listRules ( ListRulesRequest request ) { request = beforeClientExecution ( request ) ; return executeListRules ( request ) ; }
@ Override public Iterator < Entry < K , V >> iterator ( ) { final Iterator < Entry < K , V >> iterator = esDelegate . iterator ( ) ; return new Iterator < Entry < K , V >> ( ) ; }
public SendMessageResult sendMessage ( String queueUrl , String messageBody ) { return sendMessage ( new SendMessageRequest ( ) . withQueueUrl ( queueUrl ) . withMessageBody ( messageBody ) ) ; }
public static double getExcelDate ( Date date ) { return getExcelDate ( date , false ) ; }
public String toString ( ) { return markedUpText . subSequence ( textStartPos , textEndPos ) . toString ( ) ; }
public ModifyInstancePlacementResult modifyInstancePlacement ( ModifyInstancePlacementRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyInstancePlacement ( request ) ; }
public static String replaceOccupiedParameters ( String url , Map < String , String > paths ) { String result = url ; for ( Map . Entry < String , String > entry : paths . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; String target = " [ " + key + " ] " ; result = result . replace ( target , value ) ; } return result ; }
public String toString ( ) { return " < matchAllDocs ▁ field = ' * ' ▁ term = ' * ' /> " ; }
public DeleteMetricFilterRequest ( String logGroupName , String filterName ) { setLogGroupName ( logGroupName ) ; setFilterName ( filterName ) ; }
public char readChar ( ) throws IOException { return primitiveTypes . readChar ( ) ; }
public DescribeInstanceStatusResult describeInstanceStatus ( DescribeInstanceStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInstanceStatus ( request ) ; }
public BatchDeleteAttributesResult batchDeleteAttributes ( BatchDeleteAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDeleteAttributes ( request ) ; }
public String toString ( ) { return " < fieldconfig ▁ name =\ " " + this . fieldName + " \ " ▁ configurations =\ " " + super . toString ( ) + " \ " /> " ; }
public ListDeploymentGroupsResult listDeploymentGroups ( ListDeploymentGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDeploymentGroups ( request ) ; }
public CellGeneralFormatter ( ) { this ( LocaleUtil . getUserLocale ( ) ) ; }
public BloomFilteredTerms ( Terms terms , FuzzySet filter ) { this . delegateTerms = terms ; this . filter = filter ; }
public int numBits ( int idx ) { return bytes [ idx ] . bits ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof LexerChannelAction ) ) { return false ; } return channel == ( ( LexerChannelAction ) obj ) . channel ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeShort ( getValue ( ) ) ; }
public ExecuteChangeSetResult executeChangeSet ( ExecuteChangeSetRequest request ) { request = beforeClientExecution ( request ) ; return executeExecuteChangeSet ( request ) ; }
public StartInstanceResult startInstance ( StartInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeStartInstance ( request ) ; }
public CapitalizationFilterFactory ( Map < String , String > args ) { super ( args ) ; boolean ignoreCase = getBoolean ( args , KEEP_IGNORE_CASE , false ) ; Set < String > k = getSet ( args , KEEP ) ; if ( k != null ) { keep = new CharArraySet ( 10 , ignoreCase ) ; keep . addAll ( k ) ; } k = getSet ( args , OK_PREFIX ) ; if ( k != null ) { okPrefix = new ArrayList <> ( ) ; for ( String item : k ) { okPrefix . add ( item . toCharArray ( ) ) ; } } minWordLength = getInt ( args , MIN_WORD_LENGTH , 0 ) ; maxWordCount = getInt ( args , MAX_WORD_COUNT , CapitalizationFilter . DEFAULT_MAX_WORD_COUNT ) ; maxTokenLength = getInt ( args , MAX_TOKEN_LENGTH , CapitalizationFilter . DEFAULT_MAX_TOKEN_LENGTH ) ; onlyFirstWord = getBoolean ( args , ONLY_FIRST_WORD , true ) ; forceFirstLetter = getBoolean ( args , FORCE_FIRST_LETTER , true ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static long [ ] copyOf ( long [ ] original , int newLength ) { if ( newLength < 0 ) { throw new NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; }
public String toString ( ) { return ref . toString ( ) ; }
public ListNetworksResult listNetworks ( ListNetworksRequest request ) { request = beforeClientExecution ( request ) ; return executeListNetworks ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { ValueEval arg = arg0 ; if ( arg instanceof RefEval ) { RefEval re = ( RefEval ) arg ; arg = re . getInnerValueEval ( re . getFirstSheetIndex ( ) ) ; } else if ( arg instanceof AreaEval ) { arg = ( ( AreaEval ) arg ) . getRelativeValue ( 0 , 0 ) ; } if ( arg instanceof StringEval ) { return arg ; } if ( arg instanceof ErrorEval ) { return arg ; } return StringEval . EMPTY_INSTANCE ; }
public StopNotebookInstanceResult stopNotebookInstance ( StopNotebookInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeStopNotebookInstance ( request ) ; }
public void applyFont ( int startIndex , int endIndex , short fontIndex ) { if ( startIndex > endIndex ) throw new IllegalArgumentException ( " Start ▁ index ▁ must ▁ be ▁ less ▁ than ▁ end ▁ index . " ) ; if ( startIndex < 0 || endIndex > length ( ) ) throw new IllegalArgumentException ( " Start ▁ and ▁ end ▁ index ▁ not ▁ in ▁ range . " ) ; if ( startIndex == endIndex ) return ; short currentFont = NO_FONT ; if ( endIndex != length ( ) ) { currentFont = this . getFontAtIndex ( endIndex ) ; } _string = cloneStringIfRequired ( ) ; Iterator < FormatRun > formatting = _string . formatIterator ( ) ; if ( formatting != null ) { while ( formatting . hasNext ( ) ) { FormatRun r = formatting . next ( ) ; if ( ( r . getCharacterPos ( ) >= startIndex ) && ( r . getCharacterPos ( ) < endIndex ) ) formatting . remove ( ) ; } } _string . addFormatRun ( new FormatRun ( ( short ) startIndex , fontIndex ) ) ; if ( endIndex != length ( ) ) _string . addFormatRun ( new FormatRun ( ( short ) endIndex , currentFont ) ) ; addToSSTIfRequired ( ) ; }
public int readInt ( ) throws IOException { return primitiveTypes . readInt ( ) ; }
public Iterable < RevCommit > call ( ) throws GitAPIException , NoHeadException { checkCallable ( ) ; List < TreeFilter > filters = new ArrayList <> ( ) ; if ( ! pathFilters . isEmpty ( ) ) { filters . add ( AndTreeFilter . create ( PathFilterGroup . create ( pathFilters ) , TreeFilter . ANY_DIFF ) ) ; } if ( ! excludeTreeFilters . isEmpty ( ) ) { for ( TreeFilter f : excludeTreeFilters ) { filters . add ( AndTreeFilter . create ( f , TreeFilter . ANY_DIFF ) ) ; } } if ( ! filters . isEmpty ( ) ) { if ( filters . size ( ) == 1 ) { filters . add ( TreeFilter . ANY_DIFF ) ; } walk . setTreeFilter ( AndTreeFilter . create ( filters ) ) ; } if ( skip > - 1 && maxCount > - 1 ) walk . setRevFilter ( AndRevFilter . create ( SkipRevFilter . create ( skip ) , MaxCountRevFilter . create ( maxCount ) ) ) ; else if ( skip > - 1 ) walk . setRevFilter ( SkipRevFilter . create ( skip ) ) ; else if ( maxCount > - 1 ) walk . setRevFilter ( MaxCountRevFilter . create ( maxCount ) ) ; if ( ! startSpecified ) { try { ObjectId headId = repo . resolve ( Constants . HEAD ) ; if ( headId == null ) throw new NoHeadException ( JGitText . get ( ) . noHEADExistsAndNoExplicitStartingRevisionWasSpecified ) ; add ( headId ) ; } catch ( IOException e ) { throw new JGitInternalException ( JGitText . get ( ) . anExceptionOccurredWhileTryingToAddTheIdOfHEAD , e ) ; } } if ( this . revFilter != null ) { walk . setRevFilter ( this . revFilter ) ; } setCallable ( false ) ; return walk ; }
public HyphenationCompoundWordTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; dictFile = get ( args , " dictionary " ) ; encoding = get ( args , " encoding " ) ; hypFile = require ( args , " hyphenator " ) ; minWordSize = getInt ( args , " minWordSize " , CompoundWordTokenFilterBase . DEFAULT_MIN_WORD_SIZE ) ; minSubwordSize = getInt ( args , " minSubwordSize " , CompoundWordTokenFilterBase . DEFAULT_MIN_SUBWORD_SIZE ) ; maxSubwordSize = getInt ( args , " maxSubwordSize " , CompoundWordTokenFilterBase . DEFAULT_MAX_SUBWORD_SIZE ) ; onlyLongestMatch = getBoolean ( args , " onlyLongestMatch " , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public DeleteTerminologyResult deleteTerminology ( DeleteTerminologyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTerminology ( request ) ; }
public boolean remove ( Object o ) { if ( ! ( o instanceof Entry ) ) return false ; Entry <? , ?> e = ( Entry <? , ?> ) o ; return removeMapping ( e . getKey ( ) , e . getValue ( ) ) ; }
public GetObjectAttributesResult getObjectAttributes ( GetObjectAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetObjectAttributes ( request ) ; }
public RevWalk getRevWalk ( ) { throw new UnsupportedOperationException ( MessageFormat . format ( JGitText . get ( ) . isAStaticFlagAndHasNorevWalkInstance , toString ( ) ) ) ; }
public DescribeKeyPairsResult describeKeyPairs ( DescribeKeyPairsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeKeyPairs ( request ) ; }
public byte [ ] toByteArray ( ) { return build ( ) ; }
public void setIndexVersion ( int version ) { indexVersion = version ; }
public IgnoreNode ( ) { rules = new ArrayList <> ( ) ; }
public TreeFilter negate ( ) { return NotTreeFilter . create ( this ) ; }
public long ramBytesUsed ( ) { return docs . ramBytesUsed ( ) + RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + 2 * Integer . BYTES + 2 + Long . BYTES + RamUsageEstimator . NUM_BYTES_OBJECT_REF ; }
public String toString ( ) { return exists ( ) ? toObject ( ) . toString ( ) : " ( null ) " ; }
public int available ( ) throws IOException { checkReadPrimitiveTypes ( ) ; return primitiveData . available ( ) ; }
public UnicodeMapping ( String pEntityName , String pResolvedValue ) { entityName = " & " + pEntityName + " ; " ; resolvedValue = pResolvedValue ; }
public final void removeBreak ( int main ) { Integer rowKey = Integer . valueOf ( main ) ; Break region = _breakMap . get ( rowKey ) ; _breaks . remove ( region ) ; _breakMap . remove ( rowKey ) ; }
public void sort ( int from , int to ) { checkRange ( from , to ) ; if ( to - from <= 1 ) { return ; } reset ( from , to ) ; do { ensureInvariants ( ) ; pushRunLen ( nextRun ( ) ) ; } while ( runEnd ( 0 ) < to ) ; exhaustStack ( ) ; assert runEnd ( 0 ) == to ; }
public File getDirectory ( ) { return directory ; }
public PositionTrackingVisitor ( RecordVisitor rv , int initialPosition ) { _rv = rv ; _position = initialPosition ; }
public T top ( ) { return top ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( " ▁ [ " ) ; if ( externalWorkbookNumber >= 0 ) { sb . append ( " ▁ [ " ) ; sb . append ( " workbook = " ) . append ( getExternalWorkbookNumber ( ) ) ; sb . append ( " ] ▁ " ) ; } sb . append ( " sheet = " ) . append ( getSheetName ( ) ) ; if ( lastSheetName != null ) { sb . append ( " ▁ : ▁ " ) ; sb . append ( " sheet = " ) . append ( lastSheetName ) ; } sb . append ( " ▁ ! ▁ " ) ; sb . append ( formatReferenceAsString ( ) ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public SubmoduleSyncCommand addPath ( String path ) { paths . add ( path ) ; return this ; }
@ Override public int size ( ) { return map . size ( ) ; }
public DeleteNamespaceRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " DeleteNamespace " , " cr " ) ; setUriPattern ( " / namespace / [ Namespace ] " ) ; setMethod ( MethodType . DELETE ) ; }
public GeoRestriction ( GeoRestrictionType restrictionType ) { setRestrictionType ( restrictionType . toString ( ) ) ; }
public RecognizeEntityRequest ( ) { super ( " visionai - poc " , " 2020 - 04 - 08 " , " RecognizeEntity " ) ; setMethod ( MethodType . POST ) ; }
public final int compareTo ( byte [ ] bs , int p ) { int cmp ; cmp = NB . compareUInt32 ( w1 , NB . decodeInt32 ( bs , p ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w2 , NB . decodeInt32 ( bs , p + 4 ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w3 , NB . decodeInt32 ( bs , p + 8 ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w4 , NB . decodeInt32 ( bs , p + 12 ) ) ; if ( cmp != 0 ) return cmp ; return NB . compareUInt32 ( w5 , NB . decodeInt32 ( bs , p + 16 ) ) ; }
public SendMessageRequest ( ) { super ( " OnsMqtt " , " 2019 - 12 - 11 " , " SendMessage " , " onsmqtt " ) ; setMethod ( MethodType . POST ) ; }
public SelectRequest ( String selectExpression ) { setSelectExpression ( selectExpression ) ; }
public TopMarginRecord clone ( ) { return copy ( ) ; }
public GetStaticIpsResult getStaticIps ( GetStaticIpsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetStaticIps ( request ) ; }
public String toString ( ) { final StringBuilder b = new StringBuilder ( ) ; final int sectionCount = getSectionCount ( ) ; b . append ( getClass ( ) . getName ( ) ) ; b . append ( ' [ ' ) ; b . append ( " byteOrder : ▁ " ) ; b . append ( getByteOrder ( ) ) ; b . append ( " , ▁ classID : ▁ " ) ; b . append ( getClassID ( ) ) ; b . append ( " , ▁ format : ▁ " ) ; b . append ( getFormat ( ) ) ; b . append ( " , ▁ OSVersion : ▁ " ) ; b . append ( getOSVersion ( ) ) ; b . append ( " , ▁ sectionCount : ▁ " ) ; b . append ( sectionCount ) ; b . append ( " , ▁ sections : ▁ [ \ n " ) ; for ( Section section : getSections ( ) ) { b . append ( section . toString ( getPropertySetIDMap ( ) ) ) ; } b . append ( ' ] ' ) ; b . append ( ' ] ' ) ; return b . toString ( ) ; }
public int stem ( char s [ ] , int len ) { if ( len < 4 ) return len ; final int origLen = len ; len = rule0 ( s , len ) ; len = rule1 ( s , len ) ; len = rule2 ( s , len ) ; len = rule3 ( s , len ) ; len = rule4 ( s , len ) ; len = rule5 ( s , len ) ; len = rule6 ( s , len ) ; len = rule7 ( s , len ) ; len = rule8 ( s , len ) ; len = rule9 ( s , len ) ; len = rule10 ( s , len ) ; len = rule11 ( s , len ) ; len = rule12 ( s , len ) ; len = rule13 ( s , len ) ; len = rule14 ( s , len ) ; len = rule15 ( s , len ) ; len = rule16 ( s , len ) ; len = rule17 ( s , len ) ; len = rule18 ( s , len ) ; len = rule19 ( s , len ) ; len = rule20 ( s , len ) ; if ( len == origLen ) len = rule21 ( s , len ) ; return rule22 ( s , len ) ; }
public CreateStreamingURLResult createStreamingURL ( CreateStreamingURLRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateStreamingURL ( request ) ; }
public IBSimilarity ( Distribution distribution , Lambda lambda , Normalization normalization ) { this . distribution = distribution ; this . lambda = lambda ; this . normalization = normalization ; }
public GetBatchPredictionResult getBatchPrediction ( GetBatchPredictionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetBatchPrediction ( request ) ; }
public StartInstancesResult startInstances ( StartInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeStartInstances ( request ) ; }
public DescribeLoadBalancerAttributesResult describeLoadBalancerAttributes ( DescribeLoadBalancerAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLoadBalancerAttributes ( request ) ; }
public Filter ( int type , long size , InputStream in ) { this . type = type ; this . size = size ; this . in = in ; }
public String getBaseForm ( ) { return dictionary . getBaseForm ( wordId , surfaceForm , offset , length ) ; }
public Query makeLuceneQueryNoBoost ( BasicQueryFactory qf ) { if ( fieldNames . size ( ) == 1 ) { return q . makeLuceneQueryFieldNoBoost ( fieldNames . get ( 0 ) , qf ) ; } else { List < SrndQuery > queries = new ArrayList <> ( ) ; Iterator < String > fni = getFieldNames ( ) . listIterator ( ) ; SrndQuery qc ; while ( fni . hasNext ( ) ) { qc = q . clone ( ) ; queries . add ( new FieldsQuery ( qc , fni . next ( ) , fieldOp ) ) ; } OrQuery oq = new OrQuery ( queries , true , OR_OPERATOR_NAME ) ; return oq . makeLuceneQueryField ( null , qf ) ; } }
public SetVisibleToAllUsersResult setVisibleToAllUsers ( SetVisibleToAllUsersRequest request ) { request = beforeClientExecution ( request ) ; return executeSetVisibleToAllUsers ( request ) ; }
public GetBotResult getBot ( GetBotRequest request ) { request = beforeClientExecution ( request ) ; return executeGetBot ( request ) ; }
public UpdateApnsSandboxChannelResult updateApnsSandboxChannel ( UpdateApnsSandboxChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateApnsSandboxChannel ( request ) ; }
public CreateRouteResult createRoute ( CreateRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRoute ( request ) ; }
public FreeRefFunction findFunction ( String name ) { FreeRefFunction func = super . findFunction ( name ) ; if ( func != null ) { int idx = getFunctionIndex ( name ) ; _funcMap . put ( idx , name ) ; } return func ; }
public boolean atMinValue ( ) { return value == minValue ; }
public TerminateInstanceInAutoScalingGroupResult terminateInstanceInAutoScalingGroup ( TerminateInstanceInAutoScalingGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeTerminateInstanceInAutoScalingGroup ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ DVAL ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . options ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getOptions ( ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . horizPos ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getHorizontalPos ( ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . vertPos ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getVerticalPos ( ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . comboObjectID ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getObjectID ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . DVRecordsNumber ▁ = ▁ " ) . append ( Integer . toHexString ( getDVRecNo ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / DVAL ] \ n " ) ; return buffer . toString ( ) ; }
public static Token newToken ( int ofKind , String image ) { switch ( ofKind ) { default : return new Token ( ofKind , image ) ; } }
public ATNConfig ( ATNState state , int alt , PredictionContext context , SemanticContext semanticContext ) { this . state = state ; this . alt = alt ; this . context = context ; this . semanticContext = semanticContext ; }
public DataValidationConstraint createFormulaListConstraint ( String listFormula ) { return DVConstraint . createFormulaListConstraint ( listFormula ) ; }
public GlobalReplicationGroup failoverGlobalReplicationGroup ( FailoverGlobalReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeFailoverGlobalReplicationGroup ( request ) ; }
public BatchPutAttributesResult batchPutAttributes ( BatchPutAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchPutAttributes ( request ) ; }
public long get ( int index ) { final int o = index >>> 1 ; final int b = index & 1 ; final int shift = b << 5 ; return ( blocks [ o ] >>> shift ) & 4294967295L ; }
public int execute ( StringBuilder buf ) { return index ; }
public int remove ( Object key ) { boolean hashedOk ; int index , next , hash ; int result ; Object object ; index = next = findIndex ( key , keys ) ; if ( keys [ index ] != key ) { return - 1 ; } result = values [ index ] ; int length = keys . length ; while ( true ) { next = ( next + 2 ) % length ; object = keys [ next ] ; if ( object == null ) { break ; } hash = getModuloHash ( object , length ) ; hashedOk = hash > index ; if ( next < index ) { hashedOk = hashedOk || ( hash <= next ) ; } else { hashedOk = hashedOk && ( hash <= next ) ; } if ( ! hashedOk ) { keys [ index ] = object ; values [ index ] = values [ next ] ; index = next ; } } size -- ; keys [ index ] = null ; values [ index ] = - 1 ; return result ; }
public synchronized void setMaxMergesAndThreads ( int maxMergeCount , int maxThreadCount ) { if ( maxMergeCount == AUTO_DETECT_MERGES_AND_THREADS && maxThreadCount == AUTO_DETECT_MERGES_AND_THREADS ) { this . maxMergeCount = AUTO_DETECT_MERGES_AND_THREADS ; this . maxThreadCount = AUTO_DETECT_MERGES_AND_THREADS ; } else if ( maxMergeCount == AUTO_DETECT_MERGES_AND_THREADS ) { throw new IllegalArgumentException ( " both ▁ maxMergeCount ▁ and ▁ maxThreadCount ▁ must ▁ be ▁ AUTO □ DETECT □ MERGES □ AND □ THREADS " ) ; } else if ( maxThreadCount == AUTO_DETECT_MERGES_AND_THREADS ) { throw new IllegalArgumentException ( " both ▁ maxMergeCount ▁ and ▁ maxThreadCount ▁ must ▁ be ▁ AUTO □ DETECT □ MERGES □ AND □ THREADS " ) ; } else { if ( maxThreadCount < 1 ) { throw new IllegalArgumentException ( " maxThreadCount ▁ should ▁ be ▁ at ▁ least ▁ 1 " ) ; } if ( maxMergeCount < 1 ) { throw new IllegalArgumentException ( " maxMergeCount ▁ should ▁ be ▁ at ▁ least ▁ 1 " ) ; } if ( maxThreadCount > maxMergeCount ) { throw new IllegalArgumentException ( " maxThreadCount ▁ should ▁ be ▁ <= ▁ maxMergeCount ▁ ( = ▁ " + maxMergeCount + " ) " ) ; } this . maxThreadCount = maxThreadCount ; this . maxMergeCount = maxMergeCount ; } }
public final DoubleBuffer put ( double [ ] src ) { return put ( src , 0 , src . length ) ; }
public final Collection < Ref > getRefs ( ) { return advertisedRefs . values ( ) ; }
public DocFreqValueSource ( String field , String val , String indexedField , BytesRef indexedBytes ) { this . field = field ; this . val = val ; this . indexedField = indexedField ; this . indexedBytes = indexedBytes ; }
public String getSegmentsFileName ( ) { return IndexFileNames . fileNameFromGeneration ( IndexFileNames . SEGMENTS , " " , lastGeneration ) ; }
public Listener ( String protocol , Integer loadBalancerPort , Integer instancePort ) { setProtocol ( protocol ) ; setLoadBalancerPort ( loadBalancerPort ) ; setInstancePort ( instancePort ) ; }
public GetCurrentUserResult getCurrentUser ( GetCurrentUserRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCurrentUser ( request ) ; }
public String toString ( ) { return " ObjectDirectory [ " + getDirectory ( ) + " ] " ; }
public IllegalFormatWidthException ( int w ) { this . w = w ; }
public String toToken ( ) { return this . token ; }
public UpdatePhoneNumberResult updatePhoneNumber ( UpdatePhoneNumberRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdatePhoneNumber ( request ) ; }
public final IndexableField getField ( String name ) { for ( IndexableField field : fields ) { if ( field . name ( ) . equals ( name ) ) { return field ; } } return null ; }
public DisableDomainTransferLockResult disableDomainTransferLock ( DisableDomainTransferLockRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableDomainTransferLock ( request ) ; }
public PrintHeadersRecord clone ( ) { return copy ( ) ; }
public UpdateDataSourceResult updateDataSource ( UpdateDataSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDataSource ( request ) ; }
public int popMode ( ) { if ( _modeStack . isEmpty ( ) ) throw new EmptyStackException ( ) ; if ( LexerATNSimulator . debug ) System . out . println ( " popMode ▁ back ▁ to ▁ " + _modeStack . peek ( ) ) ; mode ( _modeStack . pop ( ) ) ; return _mode ; }
public ExternalSheet getExternalSheet ( int externSheetIndex ) { ExternalSheet sheet = _iBook . getExternalSheet ( externSheetIndex ) ; if ( sheet == null ) { int localSheetIndex = convertFromExternSheetIndex ( externSheetIndex ) ; if ( localSheetIndex == - 1 ) { return null ; } if ( localSheetIndex == - 2 ) { return null ; } String sheetName = getSheetName ( localSheetIndex ) ; int lastLocalSheetIndex = _iBook . getLastSheetIndexFromExternSheetIndex ( externSheetIndex ) ; if ( lastLocalSheetIndex == localSheetIndex ) { sheet = new ExternalSheet ( null , sheetName ) ; } else { String lastSheetName = getSheetName ( lastLocalSheetIndex ) ; sheet = new ExternalSheetRange ( null , sheetName , lastSheetName ) ; } } return sheet ; }
public static NoteMap newEmptyMap ( ) { NoteMap r = new NoteMap ( null ) ; r . root = new LeafBucket ( 0 ) ; return r ; }
@ Override public java . lang . Object [ ] toArray ( ) { synchronized ( mutex ) { return c . toArray ( ) ; } }
public TagCommand setObjectId ( RevObject id ) { this . id = id ; return this ; }
public static void clear ( ) { cache . clearAll ( ) ; }
public final int prefixCompare ( int [ ] bs , int p ) { int cmp ; cmp = NB . compareUInt32 ( w1 , mask ( 1 , bs [ p ] ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w2 , mask ( 2 , bs [ p + 1 ] ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w3 , mask ( 3 , bs [ p + 2 ] ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w4 , mask ( 4 , bs [ p + 3 ] ) ) ; if ( cmp != 0 ) return cmp ; return NB . compareUInt32 ( w5 , mask ( 5 , bs [ p + 4 ] ) ) ; }
public LongBuffer put ( long [ ] src , int srcOffset , int longCount ) { byteBuffer . limit ( limit * SizeOf . LONG ) ; byteBuffer . position ( position * SizeOf . LONG ) ; if ( byteBuffer instanceof ReadWriteDirectByteBuffer ) { ( ( ReadWriteDirectByteBuffer ) byteBuffer ) . put ( src , srcOffset , longCount ) ; } else { ( ( ReadWriteHeapByteBuffer ) byteBuffer ) . put ( src , srcOffset , longCount ) ; } this . position += longCount ; return this ; }
public MoPenDeleteGroupRequest ( ) { super ( " MoPen " , " 2018 - 02 - 11 " , " MoPenDeleteGroup " , " mopen " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public ApplyResult addUpdatedFile ( File f ) { updatedFiles . add ( f ) ; return this ; }
public T insertWithOverflow ( T element ) { if ( size < maxSize ) { add ( element ) ; return null ; } else if ( size > 0 && ! lessThan ( element , heap [ 1 ] ) ) { T ret = heap [ 1 ] ; heap [ 1 ] = element ; updateTop ( ) ; return ret ; } else { return element ; } }
public boolean contains ( Object object ) { Iterator < E > it = iterator ( ) ; if ( object != null ) { while ( it . hasNext ( ) ) { if ( object . equals ( it . next ( ) ) ) { return true ; } } } else { while ( it . hasNext ( ) ) { if ( it . next ( ) == null ) { return true ; } } } return false ; }
public UploadDocumentsResult uploadDocuments ( UploadDocumentsRequest request ) { request = beforeClientExecution ( request ) ; return executeUploadDocuments ( request ) ; }
public String getAccessKeyId ( ) { return legacyCredential . getAccessKeyId ( ) ; }
public static String toHex ( String value ) { return ( value == null || value . length ( ) == 0 ) ? " [ ] " : toHex ( value . getBytes ( LocaleUtil . CHARSET_1252 ) ) ; }
public String getText ( Token start , Token stop ) { if ( start != null && stop != null ) { return getText ( Interval . of ( start . getTokenIndex ( ) , stop . getTokenIndex ( ) ) ) ; } return " " ; }
public static ValueVector createColumnVector ( TwoDEval tableArray , int relativeColumnIndex ) { return new ColumnVector ( tableArray , relativeColumnIndex ) ; }
public AcceptDomainTransferFromAnotherAwsAccountResult acceptDomainTransferFromAnotherAwsAccount ( AcceptDomainTransferFromAnotherAwsAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeAcceptDomainTransferFromAnotherAwsAccount ( request ) ; }
public StartDeviceSyncResult startDeviceSync ( StartDeviceSyncRequest request ) { request = beforeClientExecution ( request ) ; return executeStartDeviceSync ( request ) ; }
@ Override public boolean containsKey ( Object key ) { return isInBounds ( key ) && TreeMap . this . containsKey ( key ) ; }
public static int idealObjectArraySize ( int need ) { return idealByteArraySize ( need * 4 ) / 4 ; }
public DescribeWorkspacesResult describeWorkspaces ( ) { return describeWorkspaces ( new DescribeWorkspacesRequest ( ) ) ; }
@ Override public Iterator < Entry < K , V >> iterator ( ) { return new EntryIterator ( ) ; }
public GlobalCluster removeFromGlobalCluster ( RemoveFromGlobalClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveFromGlobalCluster ( request ) ; }
public Map < String , MergeResult <? extends Sequence >> getMergeResults ( ) { return mergeResults ; }
public static final int parseTimeZoneOffset ( byte [ ] b , int ptr ) { return parseTimeZoneOffset ( b , ptr , null ) ; }
public String toString ( ) { synchronized ( Hashtable . this ) { return super . toString ( ) ; } }
public void reset ( ) throws IOException { in . reset ( ) ; lineNumber = markedLineNumber ; lastChar = markedLastChar ; }
public FS newInstance ( ) { return new FS_Win32 ( this ) ; }
public byte [ ] toByteArray ( ) { if ( buf != null ) { byte [ ] r = new byte [ ptr ] ; System . arraycopy ( buf , 0 , r , 0 , ptr ) ; return r ; } try { return overflowBuffer . toByteArray ( ) ; } catch ( IOException err ) { throw new RuntimeException ( err ) ; } }
public AreaEval offset ( int relFirstRowIx , int relLastRowIx , int relFirstColIx , int relLastColIx ) { AreaI area = new OffsetArea ( getFirstRow ( ) , getFirstColumn ( ) , relFirstRowIx , relLastRowIx , relFirstColIx , relLastColIx ) ; return new LazyAreaEval ( area , _evaluator ) ; }
public TerminateJobFlowsResult terminateJobFlows ( TerminateJobFlowsRequest request ) { request = beforeClientExecution ( request ) ; return executeTerminateJobFlows ( request ) ; }
public CreateTopicRequest ( String name ) { setName ( name ) ; }
public void freeBefore ( int pos ) { final int toFree = count - ( nextPos - pos ) ; assert toFree >= 0 ; assert toFree <= count ; int index = nextWrite - count ; if ( index < 0 ) { index += positions . length ; } for ( int i = 0 ; i < toFree ; i ++ ) { if ( index == positions . length ) { index = 0 ; } positions [ index ] . reset ( ) ; index ++ ; } count -= toFree ; }
public LengthFilter create ( TokenStream input ) { final LengthFilter filter = new LengthFilter ( input , min , max ) ; return filter ; }
public StandardQueryParser ( ) { super ( new StandardQueryConfigHandler ( ) , new StandardSyntaxParser ( ) , new StandardQueryNodeProcessorPipeline ( null ) , new StandardQueryTreeBuilder ( ) ) ; setEnablePositionIncrements ( true ) ; }
public GetUserSourceRepoRefListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetUserSourceRepoRefList " , " cr " ) ; setUriPattern ( " / users / sourceAccount / [ SourceAccountId ] / repos / [ SourceRepoNamespace ] / [ SourceRepoName ] / refs " ) ; setMethod ( MethodType . GET ) ; }
public static LongBuffer wrap ( long [ ] array , int start , int longCount ) { Arrays . checkOffsetAndCount ( array . length , start , longCount ) ; LongBuffer buf = new ReadWriteLongArrayBuffer ( array ) ; buf . position = start ; buf . limit = start + longCount ; return buf ; }
public UpperCaseFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public ListNotesCommand notesList ( ) { return new ListNotesCommand ( repo ) ; }
public boolean isMissingNewlineAtEnd ( ) { final int end = lines . get ( lines . size ( ) - 1 ) ; if ( end == 0 ) return true ; return content [ end - 1 ] != ' \ n ' ; }
public CreateDashboardResult createDashboard ( CreateDashboardRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDashboard ( request ) ; }
public void write ( String str , int offset , int count ) { write ( str . substring ( offset , offset + count ) . toCharArray ( ) ) ; }
public UpdateNamespaceAuthorizationRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " UpdateNamespaceAuthorization " , " cr " ) ; setUriPattern ( " / namespace / [ Namespace ] / authorizations / [ AuthorizeId ] " ) ; setMethod ( MethodType . POST ) ; }
public DescribeStreamResult describeStream ( DescribeStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStream ( request ) ; }
public void mark ( int markLimit ) throws IOException { if ( markLimit < 0 ) { throw new IllegalArgumentException ( ) ; } synchronized ( lock ) { checkNotClosed ( ) ; this . markLimit = markLimit ; mark = pos ; } }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 16 ) | ( byte1 << 8 ) | byte2 ; } }
public String toString ( ) { return String . format ( " channel ( % d ) " , channel ) ; }
public String getName ( ) { int separatorIndex = path . lastIndexOf ( separator ) ; return ( separatorIndex < 0 ) ? path : path . substring ( separatorIndex + 1 , path . length ( ) ) ; }
public TestInvokeMethodResult testInvokeMethod ( TestInvokeMethodRequest request ) { request = beforeClientExecution ( request ) ; return executeTestInvokeMethod ( request ) ; }
public final void clearAttributes ( ) { for ( State state = getCurrentState ( ) ; state != null ; state = state . next ) { state . attribute . clear ( ) ; } }
public ListRecipesResult listRecipes ( ListRecipesRequest request ) { request = beforeClientExecution ( request ) ; return executeListRecipes ( request ) ; }
public void setText ( CharacterIterator newText ) { text = newText ; text . setIndex ( text . getBeginIndex ( ) ) ; currentSentence = 0 ; Span [ ] spans = sentenceOp . splitSentences ( characterIteratorToString ( ) ) ; sentenceStarts = new int [ spans . length ] ; for ( int i = 0 ; i < spans . length ; ++ i ) { sentenceStarts [ i ] = spans [ i ] . getStart ( ) + text . getBeginIndex ( ) ; } }
public String formatWithConflicts ( String message , List < String > conflictingPaths ) { StringBuilder sb = new StringBuilder ( ) ; String [ ] lines = message . split ( " \ n " ) ; int firstFooterLine = ChangeIdUtil . indexOfFirstFooterLine ( lines ) ; for ( int i = 0 ; i < firstFooterLine ; i ++ ) sb . append ( lines [ i ] ) . append ( ' \ n ' ) ; if ( firstFooterLine == lines . length && message . length ( ) != 0 ) sb . append ( ' \ n ' ) ; addConflictsMessage ( conflictingPaths , sb ) ; if ( firstFooterLine < lines . length ) sb . append ( ' \ n ' ) ; for ( int i = firstFooterLine ; i < lines . length ; i ++ ) sb . append ( lines [ i ] ) . append ( ' \ n ' ) ; return sb . toString ( ) ; }
public boolean get ( int index ) { return bits . get ( index ) ; }
public DescribeTaskSetsResult describeTaskSets ( DescribeTaskSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTaskSets ( request ) ; }
public void add ( FormulaRecordAggregate agg ) { if ( _numberOfFormulas == 0 ) { if ( _firstCell . getRow ( ) != agg . getRow ( ) || _firstCell . getCol ( ) != agg . getColumn ( ) ) { throw new IllegalStateException ( " shared ▁ formula ▁ coding ▁ error : ▁ " + _firstCell . getCol ( ) + ' / ' + _firstCell . getRow ( ) + " ▁ != ▁ " + agg . getColumn ( ) + ' / ' + agg . getRow ( ) ) ; } } if ( _numberOfFormulas >= _frAggs . length ) { throw new RuntimeException ( " Too ▁ many ▁ formula ▁ records ▁ for ▁ shared ▁ formula ▁ group " ) ; } _frAggs [ _numberOfFormulas ++ ] = agg ; }
public PacketLineOutRefAdvertiser ( PacketLineOut out ) { pckOut = out ; }
public UpdateDataSetResult updateDataSet ( UpdateDataSetRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDataSet ( request ) ; }
public ListKeyPhrasesDetectionJobsResult listKeyPhrasesDetectionJobs ( ListKeyPhrasesDetectionJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListKeyPhrasesDetectionJobs ( request ) ; }
@ Override public void clear ( ) { Impl . this . clear ( ) ; }
public VaultNotificationConfig ( String sNSTopic , java . util . List < String > events ) { setSNSTopic ( sNSTopic ) ; setEvents ( events ) ; }
public String [ ] lemmatize ( String [ ] words , String [ ] postags ) { String [ ] lemmas = null ; String [ ] maxEntLemmas = null ; if ( dictionaryLemmatizer != null ) { lemmas = dictionaryLemmatizer . lemmatize ( words , postags ) ; for ( int i = 0 ; i < lemmas . length ; ++ i ) { if ( lemmas [ i ] . equals ( " O " ) ) { if ( lemmatizerME != null ) { if ( maxEntLemmas == null ) { maxEntLemmas = lemmatizerME . lemmatize ( words , postags ) ; } if ( " □ " . equals ( maxEntLemmas [ i ] ) ) { lemmas [ i ] = words [ i ] ; } else { lemmas [ i ] = maxEntLemmas [ i ] ; } } else { lemmas [ i ] = words [ i ] ; } } } } else { maxEntLemmas = lemmatizerME . lemmatize ( words , postags ) ; for ( int i = 0 ; i < maxEntLemmas . length ; ++ i ) { if ( " □ " . equals ( maxEntLemmas [ i ] ) ) { maxEntLemmas [ i ] = words [ i ] ; } } lemmas = maxEntLemmas ; } return lemmas ; }
public PaletteRecord ( RecordInputStream in ) { int field_1_numcolors = in . readShort ( ) ; _colors . ensureCapacity ( field_1_numcolors ) ; for ( int k = 0 ; k < field_1_numcolors ; k ++ ) { _colors . add ( new PColor ( in ) ) ; } }
public GetJobOutputRequest ( String accountId , String vaultName , String jobId , String range ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; setJobId ( jobId ) ; setRange ( range ) ; }
public ISigner getSigner ( ) { return null ; }
public static int codePointCount ( BytesRef utf8 ) { int pos = utf8. offset ; final int limit = pos + utf8. length ; final byte [ ] bytes = utf8. bytes ; int codePointCount = 0 ; for ( ; pos < limit ; codePointCount ++ ) { int v = bytes [ pos ] & 0xFF ; if ( v < 0x80 ) { pos += 1 ; continue ; } if ( v >= 0xc0 ) { if ( v < 0xe0 ) { pos += 2 ; continue ; } if ( v < 0xf0 ) { pos += 3 ; continue ; } if ( v < 0xf8 ) { pos += 4 ; continue ; } } throw new IllegalArgumentException ( ) ; } if ( pos > limit ) throw new IllegalArgumentException ( ) ; return codePointCount ; }
public static Class <? extends Record > getRecordClass ( int sid ) { I_RecordCreator rc = _recordCreatorsById . get ( Integer . valueOf ( sid ) ) ; if ( rc == null ) { return null ; } return rc . getRecordClass ( ) ; }
public WriteAccessRecord ( RecordInputStream in ) { if ( in . remaining ( ) > DATA_SIZE ) { throw new RecordFormatException ( " Expected ▁ data ▁ size ▁ ( " + DATA_SIZE + " ) ▁ but ▁ got ▁ ( " + in . remaining ( ) + " ) " ) ; } int nChars = in . readUShort ( ) ; int is16BitFlag = in . readUByte ( ) ; if ( nChars > DATA_SIZE || ( is16BitFlag & 0xFE ) != 0 ) { byte [ ] data = new byte [ 3 + in . remaining ( ) ] ; LittleEndian . putUShort ( data , 0 , nChars ) ; LittleEndian . putByte ( data , 2 , is16BitFlag ) ; in . readFully ( data , 3 , data . length - 3 ) ; String rawValue = new String ( data , StringUtil . UTF8 ) ; setUsername ( rawValue . trim ( ) ) ; return ; } String rawText ; if ( ( is16BitFlag & 0x01 ) == 0x00 ) { rawText = StringUtil . readCompressedUnicode ( in , nChars ) ; } else { rawText = StringUtil . readUnicodeLE ( in , nChars ) ; } field_1_username = rawText . trim ( ) ; int padSize = in . remaining ( ) ; while ( padSize > 0 ) { in . readUByte ( ) ; padSize -- ; } }
public FontBasisRecord ( RecordInputStream in ) { field_1_xBasis = in . readShort ( ) ; field_2_yBasis = in . readShort ( ) ; field_3_heightBasis = in . readShort ( ) ; field_4_scale = in . readShort ( ) ; field_5_indexToFontTable = in . readShort ( ) ; }
public String encodeText ( String originalText ) { return originalText ; }
public PathEdit ( String entryPath ) { path = Constants . encode ( entryPath ) ; }
public boolean add ( char [ ] text ) { return map . put ( text , PLACEHOLDER ) == null ; }
public ResolveAliasResult resolveAlias ( ResolveAliasRequest request ) { request = beforeClientExecution ( request ) ; return executeResolveAlias ( request ) ; }
public TokenStream create ( TokenStream input ) { return new GreekStemFilter ( input ) ; }
public DescribeCacheSecurityGroupsRequest ( String cacheSecurityGroupName ) { setCacheSecurityGroupName ( cacheSecurityGroupName ) ; }
public void readFully ( byte [ ] buf , int off , int len ) { if ( shouldSkipEncryptionOnCurrentRecord ) { readPlain ( buf , off , buf . length ) ; } else { ccis . readFully ( buf , off , len ) ; } }
public static byte [ ] copyOf ( byte [ ] original , int newLength ) { if ( newLength < 0 ) { throw new NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; }
public DeleteDomainNameResult deleteDomainName ( DeleteDomainNameRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDomainName ( request ) ; }
public GlobalReplicationGroup decreaseNodeGroupsInGlobalReplicationGroup ( DecreaseNodeGroupsInGlobalReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDecreaseNodeGroupsInGlobalReplicationGroup ( request ) ; }
public SelectRequest ( String selectExpression , Boolean consistentRead ) { setSelectExpression ( selectExpression ) ; setConsistentRead ( consistentRead ) ; }
public SubmoduleAddCommand setURI ( String uri ) { this . uri = uri ; return this ; }
public PutRestApiResult putRestApi ( PutRestApiRequest request ) { request = beforeClientExecution ( request ) ; return executePutRestApi ( request ) ; }
public Ptg get3DReferencePtg ( AreaReference areaRef , SheetIdentifier sheet ) { int extIx = getSheetExtIx ( sheet ) ; return new Area3DPtg ( areaRef , extIx ) ; }
public CreateRequestValidatorResult createRequestValidator ( CreateRequestValidatorRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRequestValidator ( request ) ; }
public ByteBuffer duplicate ( ) { return copy ( this , mark ) ; }
public void setPackedGitWindowSize ( int newSize ) { packedGitWindowSize = newSize ; }
public DisassociateMembershipResult disassociateMembership ( DisassociateMembershipRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateMembership ( request ) ; }
public void parse ( Reader in ) throws IOException , ParseException { LineNumberReader br = new LineNumberReader ( in ) ; try { String line = null ; String lastSynSetID = " " ; CharsRef synset [ ] = new CharsRef [ 8 ] ; int synsetSize = 0 ; while ( ( line = br . readLine ( ) ) != null ) { String synSetID = line . substring ( 2 , 11 ) ; if ( ! synSetID . equals ( lastSynSetID ) ) { addInternal ( synset , synsetSize ) ; synsetSize = 0 ; } synset = ArrayUtil . grow ( synset , synsetSize + 1 ) ; synset [ synsetSize ] = parseSynonym ( line , new CharsRefBuilder ( ) ) ; synsetSize ++ ; lastSynSetID = synSetID ; } addInternal ( synset , synsetSize ) ; } catch ( IllegalArgumentException e ) { ParseException ex = new ParseException ( " Invalid ▁ synonym ▁ rule ▁ at ▁ line ▁ " + br . getLineNumber ( ) , 0 ) ; ex . initCause ( e ) ; throw ex ; } finally { br . close ( ) ; } }
public String [ ] list ( ) { return listImpl ( path ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ ENDOBJECT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rt ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( rt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbitFrt ▁ ▁ ▁ = " ) . append ( HexDump . shortToHex ( grbitFrt ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . iObjectKind = " ) . append ( HexDump . shortToHex ( iObjectKind ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ . reserved ▁ ▁ ▁ = " ) . append ( HexDump . toHex ( reserved ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / ENDOBJECT ] \ n " ) ; return buffer . toString ( ) ; }
public static final RevFilter after ( Date ts ) { return after ( ts . getTime ( ) ) ; }
public static Element getFirstChildElement ( Element element ) { for ( Node kid = element . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( kid . getNodeType ( ) == Node . ELEMENT_NODE ) { return ( Element ) kid ; } } return null ; }
@ Override public boolean add ( E object ) { synchronized ( mutex ) { return c . add ( object ) ; } }
public LongMap ( ) { table = createArray ( 64 ) ; growAt = ( int ) ( table . length * LOAD_FACTOR ) ; }
public ClaimGameServerResult claimGameServer ( ClaimGameServerRequest request ) { request = beforeClientExecution ( request ) ; return executeClaimGameServer ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval venumerator , ValueEval vedenominator ) { double enumerator = 0 ; try { enumerator = OperandResolver . coerceValueToDouble ( venumerator ) ; } catch ( EvaluationException e ) { return ErrorEval . VALUE_INVALID ; } double denominator = 0 ; try { denominator = OperandResolver . coerceValueToDouble ( vedenominator ) ; } catch ( EvaluationException e ) { return ErrorEval . VALUE_INVALID ; } if ( denominator == 0 ) { return ErrorEval . DIV_ZERO ; } return new NumberEval ( ( int ) ( enumerator / denominator ) ) ; }
public synchronized V put ( K key , V value ) { if ( value == null ) { throw new NullPointerException ( ) ; } int hash = secondaryHash ( key . hashCode ( ) ) ; HashtableEntry < K , V > [ ] tab = table ; int index = hash & ( tab . length - 1 ) ; HashtableEntry < K , V > first = tab [ index ] ; for ( HashtableEntry < K , V > e = first ; e != null ; e = e . next ) { if ( e . hash == hash && key . equals ( e . key ) ) { V oldValue = e . value ; e . value = value ; return oldValue ; } } modCount ++ ; if ( size ++ > threshold ) { rehash ( ) ; tab = doubleCapacity ( ) ; index = hash & ( tab . length - 1 ) ; first = tab [ index ] ; } tab [ index ] = new HashtableEntry < K , V > ( key , value , hash , first ) ; return null ; }
public DescribeAutoScalingNotificationTypesResult describeAutoScalingNotificationTypes ( DescribeAutoScalingNotificationTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAutoScalingNotificationTypes ( request ) ; }
public ScandinavianFoldingFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public ContentHandler getContentHandler ( ) { return ( theContentHandler == this ) ? null : theContentHandler ; }
public String toString ( ) { return " $ " ; }
public ListAssessmentRunsResult listAssessmentRuns ( ListAssessmentRunsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAssessmentRuns ( request ) ; }
public ShortBuffer compact ( ) { throw new ReadOnlyBufferException ( ) ; }
public DeleteAssessmentRunResult deleteAssessmentRun ( DeleteAssessmentRunRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAssessmentRun ( request ) ; }
public GetAppsResult getApps ( GetAppsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApps ( request ) ; }
public String highlightTerm ( String originalText , TokenGroup tokenGroup ) { if ( tokenGroup . getTotalScore ( ) == 0 ) return originalText ; float score = tokenGroup . getTotalScore ( ) ; if ( score == 0 ) { return originalText ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( " < font ▁ " ) ; if ( highlightForeground ) { sb . append ( " color =\ " " ) ; sb . append ( getForegroundColorString ( score ) ) ; sb . append ( " \ " ▁ " ) ; } if ( highlightBackground ) { sb . append ( " bgcolor =\ " " ) ; sb . append ( getBackgroundColorString ( score ) ) ; sb . append ( " \ " ▁ " ) ; } sb . append ( " > " ) ; sb . append ( originalText ) ; sb . append ( " </ font > " ) ; return sb . toString ( ) ; }
public PendingTerm ( BytesRef term , BlockTermState state ) { super ( true ) ; this . termBytes = new byte [ term . length ] ; System . arraycopy ( term . bytes , term . offset , termBytes , 0 , term . length ) ; this . state = state ; }
public IntBuffer asReadOnlyBuffer ( ) { IntToByteBufferAdapter buf = new IntToByteBufferAdapter ( byteBuffer . asReadOnlyBuffer ( ) ) ; buf . limit = limit ; buf . position = position ; buf . mark = mark ; buf . byteBuffer . order = byteBuffer . order ; return buf ; }
public final void addParents ( RevCommit c , RevFlag queueControl ) { final RevCommit [ ] pList = c . parents ; if ( pList == null ) { return ; } for ( int i = 0 ; i < pList . length ; i ++ ) { if ( firstParent && i > 0 ) { break ; } add ( pList [ i ] , queueControl ) ; } }
public IndicNormalizationFilter ( TokenStream input ) { super ( input ) ; }
public ListTasksResult listTasks ( ListTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeListTasks ( request ) ; }
public ListTemplateAliasesResult listTemplateAliases ( ListTemplateAliasesRequest request ) { request = beforeClientExecution ( request ) ; return executeListTemplateAliases ( request ) ; }
public DescribeEventCategoriesResult describeEventCategories ( ) { return describeEventCategories ( new DescribeEventCategoriesRequest ( ) ) ; }
public static File createTempFile ( String prefix , String suffix ) throws IOException { return createTempFile ( prefix , suffix , null ) ; }
public LabelAndValue ( String label , Number value ) { this . label = label ; this . value = value ; }
public String getReading ( int wordId , char surface [ ] , int off , int len ) { return getFeature ( wordId , 0 ) ; }
public CodepointCountFilter create ( TokenStream input ) { return new CodepointCountFilter ( input , min , max ) ; }
public String toString ( ) { StringBuilder res = new StringBuilder ( task . getName ( ) ) ; res . append ( " ▁ " ) ; res . append ( count ) ; res . append ( " ▁ " ) ; res . append ( elapsed ) ; return res . toString ( ) ; }
public void build ( InputIterator iterator ) throws IOException { if ( iterator . hasPayloads ( ) ) { throw new IllegalArgumentException ( " this ▁ suggester ▁ doesn ' t support payloads " ) ; } if ▁ ( iterator . hasContexts ( ) ) ▁ { throw ▁ new ▁ IllegalArgumentException ( " this suggester doesn ' t ▁ support ▁ contexts " ) ; } root = new TernaryTreeNode ( ) ; iterator = new SortedInputIterator ( tempDir , tempFileNamePrefix , iterator , utf8SortedAsUTF16SortOrder ) ; count = 0 ; ArrayList < String > tokens = new ArrayList <> ( ) ; ArrayList < Number > vals = new ArrayList <> ( ) ; BytesRef spare ; CharsRefBuilder charsSpare = new CharsRefBuilder ( ) ; while ( ( spare = iterator . next ( ) ) != null ) { charsSpare . copyUTF8Bytes ( spare ) ; tokens . add ( charsSpare . toString ( ) ) ; vals . add ( Long . valueOf ( iterator . weight ( ) ) ) ; count ++ ; } autocomplete . balancedTree ( tokens . toArray ( ) , vals . toArray ( ) , 0 , tokens . size ( ) - 1 , root ) ; }
public void setAllowThin ( boolean allow ) { allowThin = allow ; }
public PhRun ( int phoneticTextFirstCharacterOffset , int realTextFirstCharacterOffset , int realTextLength ) { this . phoneticTextFirstCharacterOffset = phoneticTextFirstCharacterOffset ; this . realTextFirstCharacterOffset = realTextFirstCharacterOffset ; this . realTextLength = realTextLength ; }
public void append ( String name , RevBlob blob ) { append ( name , REGULAR_FILE , blob ) ; }
public CreateHostedZoneResult createHostedZone ( CreateHostedZoneRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateHostedZone ( request ) ; }
public ListFacetAttributesResult listFacetAttributes ( ListFacetAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeListFacetAttributes ( request ) ; }
public GetTrafficPolicyInstanceCountResult getTrafficPolicyInstanceCount ( GetTrafficPolicyInstanceCountRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTrafficPolicyInstanceCount ( request ) ; }
public ModifyTrafficMirrorSessionResult modifyTrafficMirrorSession ( ModifyTrafficMirrorSessionRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyTrafficMirrorSession ( request ) ; }
public DefaultClusterParameters describeDefaultClusterParameters ( DescribeDefaultClusterParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDefaultClusterParameters ( request ) ; }
public ConsoleWriter ( OutputStream out ) { super ( out , true ) ; lock = CONSOLE_LOCK ; }
public MutableValue duplicate ( ) { MutableValueBool v = new MutableValueBool ( ) ; v . value = this . value ; v . exists = this . exists ; return v ; }
public PatternTokenizerFactory ( Map < String , String > args ) { super ( args ) ; pattern = getPattern ( args , PATTERN ) ; group = getInt ( args , GROUP , - 1 ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public int addConditionalFormatting ( CellRangeAddress [ ] regions , ConditionalFormattingRule rule1 , ConditionalFormattingRule rule2 ) { return addConditionalFormatting ( regions , ( HSSFConditionalFormattingRule ) rule1 , ( HSSFConditionalFormattingRule ) rule2 ) ; }
public Credential ( String keyId , String secret , String securityToken ) { this . accessKeyId = keyId ; this . accessSecret = secret ; this . securityToken = securityToken ; this . refreshDate = new Date ( ) ; }
public void reset ( int point ) { this . point = point ; ends . next = 0 ; starts . next = 0 ; }
public BottomMarginRecord ( RecordInputStream in ) { field_1_margin = in . readDouble ( ) ; }
public final void removeFields ( String name ) { Iterator < IndexableField > it = fields . iterator ( ) ; while ( it . hasNext ( ) ) { IndexableField field = it . next ( ) ; if ( field . name ( ) . equals ( name ) ) { it . remove ( ) ; } } }
public Token LT ( int k ) { lazyInit ( ) ; if ( k == 0 ) return null ; if ( k < 0 ) return LB ( - k ) ; int i = p ; int n = 1 ; while ( n < k ) { if ( sync ( i + 1 ) ) { i = nextTokenOnChannel ( i + 1 , channel ) ; } n ++ ; } return tokens . get ( i ) ; }
public FloatBuffer put ( float c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } byteBuffer . putFloat ( position ++ * SizeOf . FLOAT , c ) ; return this ; }
public ExternalNameEval ( EvaluationName name ) { _name = name ; }
public GetLoadBalancerMetricDataResult getLoadBalancerMetricData ( GetLoadBalancerMetricDataRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLoadBalancerMetricData ( request ) ; }
public String getResultPath ( ) { return resultPath . getPath ( ) ; }
public RefWriter ( RefList < Ref > refs ) { this . refs = refs . asList ( ) ; }
public HSSFWorkbook getStubHSSFWorkbook ( ) { HSSFWorkbook wb = HSSFWorkbook . create ( getStubWorkbook ( ) ) ; for ( BoundSheetRecord bsr : boundSheetRecords ) { wb . createSheet ( bsr . getSheetname ( ) ) ; } return wb ; }
public static SupBookRecord createExternalReferences ( String url , String [ ] sheetNames ) { return new SupBookRecord ( url , sheetNames ) ; }
public int getLevelForDistance ( double dist ) { if ( dist == 0 ) return maxLevels ; final int level = GeohashUtils . lookupHashLenForWidthHeight ( dist , dist ) ; return Math . max ( Math . min ( level , maxLevels ) , 1 ) ; }
public MissingCellDummyRecord ( int row , int column ) { this . row = row ; this . column = column ; }
public static TokenizerFactory forName ( String name , Map < String , String > args ) { return loader . newInstance ( name , args ) ; }
public final ByteBuffer encode ( CharBuffer in ) throws CharacterCodingException { if ( in . remaining ( ) == 0 ) { return ByteBuffer . allocate ( 0 ) ; } reset ( ) ; int length = ( int ) ( in . remaining ( ) * averageBytesPerChar ) ; ByteBuffer output = ByteBuffer . allocate ( length ) ; CoderResult result = null ; while ( true ) { result = encode ( in , output , false ) ; if ( result == CoderResult . UNDERFLOW ) { break ; } else if ( result == CoderResult . OVERFLOW ) { output = allocateMore ( output ) ; continue ; } checkCoderResult ( result ) ; } result = encode ( in , output , true ) ; checkCoderResult ( result ) ; while ( true ) { result = flush ( output ) ; if ( result == CoderResult . UNDERFLOW ) { output . flip ( ) ; break ; } else if ( result == CoderResult . OVERFLOW ) { output = allocateMore ( output ) ; continue ; } checkCoderResult ( result ) ; output . flip ( ) ; if ( result . isMalformed ( ) ) { throw new MalformedInputException ( result . length ( ) ) ; } else if ( result . isUnmappable ( ) ) { throw new UnmappableCharacterException ( result . length ( ) ) ; } break ; } status = READY ; finished = true ; return output ; }
public TextProgressMonitor ( Writer out ) { this . out = out ; this . write = true ; }
public double get ( String name , double dflt ) { double vals [ ] = ( double [ ] ) valByRound . get ( name ) ; if ( vals != null ) { return vals [ roundNumber % vals . length ] ; } String sval = props . getProperty ( name , " " + dflt ) ; if ( sval . indexOf ( " : " ) < 0 ) { return Double . parseDouble ( sval ) ; } int k = sval . indexOf ( " : " ) ; String colName = sval . substring ( 0 , k ) ; sval = sval . substring ( k + 1 ) ; colForValByRound . put ( name , colName ) ; vals = propToDoubleArray ( sval ) ; valByRound . put ( name , vals ) ; return vals [ roundNumber % vals . length ] ; }
public LooseRef peel ( ObjectIdRef newLeaf ) { ObjectId peeledObjectId = newLeaf . getPeeledObjectId ( ) ; ObjectId objectId = getObjectId ( ) ; if ( peeledObjectId != null ) { return new LoosePeeledTag ( snapShot , getName ( ) , objectId , peeledObjectId ) ; } return new LooseNonTag ( snapShot , getName ( ) , objectId ) ; }
public List < Ref > call ( ) throws GitAPIException { checkCallable ( ) ; List < Ref > resultRefs ; try { Collection < Ref > refs = new ArrayList <> ( ) ; Ref head = repo . exactRef ( HEAD ) ; if ( head != null && head . getLeaf ( ) . getName ( ) . equals ( HEAD ) ) { refs . add ( head ) ; } if ( listMode == null ) { refs . addAll ( repo . getRefDatabase ( ) . getRefsByPrefix ( R_HEADS ) ) ; } else if ( listMode == ListMode . REMOTE ) { refs . addAll ( repo . getRefDatabase ( ) . getRefsByPrefix ( R_REMOTES ) ) ; } else { refs . addAll ( repo . getRefDatabase ( ) . getRefsByPrefix ( R_HEADS , R_REMOTES ) ) ; } resultRefs = new ArrayList <> ( filterRefs ( refs ) ) ; } catch ( IOException e ) { throw new JGitInternalException ( e . getMessage ( ) , e ) ; } Collections . sort ( resultRefs , ( Ref o1 , Ref o2 ) -> o1. getName ( ) . compareTo ( o2. getName ( ) ) ) ; setCallable ( false ) ; return resultRefs ; }
public void writeLong ( long v ) { writeContinueIfRequired ( 8 ) ; _ulrOutput . writeLong ( v ) ; }
public UpdateSmsTemplateResult updateSmsTemplate ( UpdateSmsTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateSmsTemplate ( request ) ; }
public DeletePlacementGroupResult deletePlacementGroup ( DeletePlacementGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeletePlacementGroup ( request ) ; }
public StartApplicationResult startApplication ( StartApplicationRequest request ) { request = beforeClientExecution ( request ) ; return executeStartApplication ( request ) ; }
public void mark ( int readlimit ) throws IOException { synchronized ( lock ) { super . mark ( readlimit ) ; markedLineNumber = lineNumber ; markedLastWasCR = lastWasCR ; } }
public int getPort ( ) { return port ; }
public int get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return byteBuffer . getInt ( position ++ * SizeOf . INT ) ; }
public Entry < K , V > pollLastEntry ( ) { Node < K , V > result = endpoint ( false ) ; if ( result != null ) { removeInternal ( result ) ; } return immutableCopy ( result ) ; }
public RebootRelationalDatabaseResult rebootRelationalDatabase ( RebootRelationalDatabaseRequest request ) { request = beforeClientExecution ( request ) ; return executeRebootRelationalDatabase ( request ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + asFormulaString ( ) + " ] " ; }
public BulkPublishResult bulkPublish ( BulkPublishRequest request ) { request = beforeClientExecution ( request ) ; return executeBulkPublish ( request ) ; }
public static String getNewRoleSessionName ( ) { return " aliyun - java - sdk - " + System . currentTimeMillis ( ) ; }
public CompleteLifecycleActionResult completeLifecycleAction ( CompleteLifecycleActionRequest request ) { request = beforeClientExecution ( request ) ; return executeCompleteLifecycleAction ( request ) ; }
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 34 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 25 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } } } } for ( int i = 0 ; i < 34 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; }
public final ObjectToPack getDeltaBase ( ) { if ( deltaBase instanceof ObjectToPack ) return ( ObjectToPack ) deltaBase ; return null ; }
public GetQueryExecutionResult getQueryExecution ( GetQueryExecutionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetQueryExecution ( request ) ; }
public int getFontIndex ( FontRecord font ) { for ( int i = 0 ; i <= numfonts ; i ++ ) { FontRecord thisFont = ( FontRecord ) records . get ( ( records . getFontpos ( ) - ( numfonts - 1 ) ) + i ) ; if ( thisFont == font ) { return ( i > 3 ) ? i + 1 : i ; } } throw new IllegalArgumentException ( " Could ▁ not ▁ find ▁ that ▁ font ! " ) ; }
public FieldInfo add ( FieldInfo fi ) { return add ( fi , - 1 ) ; }
public DescribeDominantLanguageDetectionJobResult describeDominantLanguageDetectionJob ( DescribeDominantLanguageDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDominantLanguageDetectionJob ( request ) ; }
public DescribeReservedInstancesModificationsResult describeReservedInstancesModifications ( ) { return describeReservedInstancesModifications ( new DescribeReservedInstancesModificationsRequest ( ) ) ; }
public DiffCommand setOutputStream ( OutputStream out ) { this . out = out ; return this ; }
public ObjectId toObjectId ( ) { return new ObjectId ( this ) ; }
public static short [ ] getAllKnownRecordSIDs ( ) { if ( _allKnownRecordSIDs == null ) { short [ ] results = new short [ _recordCreatorsById . size ( ) ] ; int i = 0 ; for ( Integer sid : _recordCreatorsById . keySet ( ) ) { results [ i ++ ] = sid . shortValue ( ) ; } Arrays . sort ( results ) ; _allKnownRecordSIDs = results ; } return _allKnownRecordSIDs . clone ( ) ; }
public PredictionContext getCachedContext ( PredictionContext context ) { if ( sharedContextCache == null ) return context ; synchronized ( sharedContextCache ) { IdentityHashMap < PredictionContext , PredictionContext > visited = new IdentityHashMap < PredictionContext , PredictionContext > ( ) ; return PredictionContext . getCachedContext ( context , sharedContextCache , visited ) ; } }
public CreateStageResult createStage ( CreateStageRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateStage ( request ) ; }
public static EditList singleton ( Edit edit ) { EditList res = new EditList ( 1 ) ; res . add ( edit ) ; return res ; }
public ModifySnapshotScheduleResult modifySnapshotSchedule ( ModifySnapshotScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeModifySnapshotSchedule ( request ) ; }
public boolean isEmpty ( ) { return elements . length == 0 ; }
public void copy ( BytesRef bytes , BytesRef out ) { int left = blockSize - upto ; if ( bytes . length > left || currentBlock == null ) { if ( currentBlock != null ) { addBlock ( currentBlock ) ; didSkipBytes = true ; } currentBlock = new byte [ blockSize ] ; upto = 0 ; left = blockSize ; assert bytes . length <= blockSize ; } out . bytes = currentBlock ; out . offset = upto ; out . length = bytes . length ; System . arraycopy ( bytes . bytes , bytes . offset , currentBlock , upto , bytes . length ) ; upto += bytes . length ; }
public void add ( int location , E object ) { listIterator ( location ) . add ( object ) ; }
public CreateKeyPairRequest ( String keyName ) { setKeyName ( keyName ) ; }
public boolean removeLastOccurrence ( Object o ) { Iterator < E > iter = new ReverseLinkIterator < E > ( this ) ; return removeOneOccurrence ( o , iter ) ; }
public int keyAt ( int index ) { return mKeys [ index ] ; }
public synchronized void setHierarchical ( String dimName , boolean v ) { DimConfig ft = fieldTypes . get ( dimName ) ; if ( ft == null ) { ft = new DimConfig ( ) ; fieldTypes . put ( dimName , ft ) ; } ft . hierarchical = v ; }
public ObjectId getOldObjectId ( ) { return oldObjectId ; }
public static String toStringTree ( final Tree t , final List < String > ruleNames ) { String s = Utils . escapeWhitespace ( getNodeText ( t , ruleNames ) , false ) ; if ( t . getChildCount ( ) == 0 ) return s ; StringBuilder buf = new StringBuilder ( ) ; buf . append ( " ( " ) ; s = Utils . escapeWhitespace ( getNodeText ( t , ruleNames ) , false ) ; buf . append ( s ) ; buf . append ( ' ▁ ' ) ; for ( int i = 0 ; i < t . getChildCount ( ) ; i ++ ) { if ( i > 0 ) buf . append ( ' ▁ ' ) ; buf . append ( toStringTree ( t . getChild ( i ) , ruleNames ) ) ; } buf . append ( " ) " ) ; return buf . toString ( ) ; }
public NavigableSet < E > headSet ( E end , boolean endInclusive ) { Comparator <? super E > c = backingMap . comparator ( ) ; if ( c == null ) { ( ( Comparable < E > ) end ) . compareTo ( end ) ; } else { c . compare ( end , end ) ; } return new TreeSet < E > ( backingMap . headMap ( end , endInclusive ) ) ; }
public static ContentSource create ( ObjectReader reader ) { return new ObjectReaderSource ( reader ) ; }
public void setReuseDeltas ( boolean reuseDeltas ) { this . reuseDeltas = reuseDeltas ; }
public ListSkillsStoreSkillsByCategoryResult listSkillsStoreSkillsByCategory ( ListSkillsStoreSkillsByCategoryRequest request ) { request = beforeClientExecution ( request ) ; return executeListSkillsStoreSkillsByCategory ( request ) ; }
public final Ref getRef ( String name ) { return advertisedRefs . get ( name ) ; }
public ModifyInstanceGroupsResult modifyInstanceGroups ( ModifyInstanceGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyInstanceGroups ( request ) ; }
public Object toObject ( ) { return exists ? new Date ( value ) : null ; }
public DescribeDBInstanceAutomatedBackupsResult describeDBInstanceAutomatedBackups ( DescribeDBInstanceAutomatedBackupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBInstanceAutomatedBackups ( request ) ; }
public PreviewAgentsResult previewAgents ( PreviewAgentsRequest request ) { request = beforeClientExecution ( request ) ; return executePreviewAgents ( request ) ; }
public QueryGroupUsersRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " QueryGroupUsers " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public DescribeOptionGroupsResult describeOptionGroups ( DescribeOptionGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeOptionGroups ( request ) ; }
public UpdateGroupResult updateGroup ( UpdateGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateGroup ( request ) ; }
public UpdateSigningCertificateRequest ( String certificateId , StatusType status ) { setCertificateId ( certificateId ) ; setStatus ( status . toString ( ) ) ; }
public CreateInstancesResult createInstances ( CreateInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateInstances ( request ) ; }
public static int getRecordSizeForBlockCount ( int blockCount ) { return 20 + 4 * blockCount ; }
public StopStreamEncryptionResult stopStreamEncryption ( StopStreamEncryptionRequest request ) { request = beforeClientExecution ( request ) ; return executeStopStreamEncryption ( request ) ; }
public GetPredictionResult getPrediction ( GetPredictionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetPrediction ( request ) ; }
public ModifyWorkspacePropertiesResult modifyWorkspaceProperties ( ModifyWorkspacePropertiesRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyWorkspaceProperties ( request ) ; }
public void copyFrom ( TermState _other ) { assert _other instanceof BlockTermState : " can ▁ not ▁ copy ▁ from ▁ " + _other . getClass ( ) . getName ( ) ; BlockTermState other = ( BlockTermState ) _other ; super . copyFrom ( _other ) ; docFreq = other . docFreq ; totalTermFreq = other . totalTermFreq ; termBlockOrd = other . termBlockOrd ; blockFilePointer = other . blockFilePointer ; }
public String getLine ( ) { return command . getLine ( ) ; }
public static void release ( Inflater i ) { if ( i != null ) { i . reset ( ) ; if ( releaseImpl ( i ) ) i . end ( ) ; } }
public EnumSet < RevSort > getRevSort ( ) { return sorting . clone ( ) ; }
public boolean removeFetchRefSpec ( RefSpec s ) { return fetch . remove ( s ) ; }
public CharBuffer put ( char c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } backingArray [ offset + position ++ ] = c ; return this ; }
public int getRate ( ) { return ( perMin ? rate : 60 * rate ) ; }
public DescribeDBParametersRequest ( String dBParameterGroupName ) { setDBParameterGroupName ( dBParameterGroupName ) ; }
public DeleteNodeResult deleteNode ( DeleteNodeRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNode ( request ) ; }
@ Override public List < E > subList ( int from , int to ) { Slice slice = this . slice ; if ( from < 0 || from > to || to > size ( ) ) { throw new IndexOutOfBoundsException ( " from = " + from + " , ▁ to = " + to + " , ▁ list ▁ size = " + size ( ) ) ; } return new CowSubList ( slice . expectedElements , slice . from + from , slice . from + to ) ; }
public CompositeReaderContext build ( ) { return ( CompositeReaderContext ) build ( null , reader , 0 , 0 ) ; }
public Cluster rebootCluster ( RebootClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeRebootCluster ( request ) ; }
public void setBorder ( boolean value ) { field_1_options = border . setShortBoolean ( field_1_options , value ) ; }
public DescribeExportTasksResult describeExportTasks ( DescribeExportTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeExportTasks ( request ) ; }
public SeriesLabelsRecord clone ( ) { return copy ( ) ; }
public final String getShortMessage ( ) { byte [ ] raw = buffer ; int msgB = RawParseUtils . tagMessage ( raw , 0 ) ; if ( msgB < 0 ) { return " " ; } int msgE = RawParseUtils . endOfParagraph ( raw , msgB ) ; String str = RawParseUtils . decode ( guessEncoding ( ) , raw , msgB , msgE ) ; if ( RevCommit . hasLF ( raw , msgB , msgE ) ) { str = StringUtils . replaceLineBreaksWithSpace ( str ) ; } return str ; }
public String toString ( ) { StringBuilder r = new StringBuilder ( ) ; if ( isOperatorInfix ( ) ) { infixToString ( r ) ; } else { prefixToString ( r ) ; } weightToString ( r ) ; return r . toString ( ) ; }
public String getPreferredAuthentications ( ) { return preferredAuthentications ; }
public int size ( ) { return elements . length ; }
public ListPartnerEventSourcesResult listPartnerEventSources ( ListPartnerEventSourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeListPartnerEventSources ( request ) ; }
public void write ( byte [ ] buffer , int offset , int length ) { Arrays . checkOffsetAndCount ( buffer . length , offset , length ) ; synchronized ( this ) { if ( out == null ) { setError ( ) ; return ; } try { out . write ( buffer , offset , length ) ; if ( autoFlush ) { flush ( ) ; } } catch ( IOException e ) { setError ( ) ; } } }
public ListRegisteredTagsRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListRegisteredTags " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DeleteDBSubnetGroupResult deleteDBSubnetGroup ( DeleteDBSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDBSubnetGroup ( request ) ; }
public PacketLineOut ( OutputStream outputStream ) { out = outputStream ; lenbuffer = new byte [ 5 ] ; flushOnEnd = true ; }
public void appendDebugInfo ( StringBuilder sb ) { sb . append ( ' ( ' ) ; sb . append ( " isxvi = " ) . append ( HexDump . shortToHex ( _isxvi ) ) ; sb . append ( " ▁ isxvd = " ) . append ( HexDump . shortToHex ( _isxvd ) ) ; sb . append ( " ▁ idObj = " ) . append ( HexDump . shortToHex ( _idObj ) ) ; sb . append ( ' ) ' ) ; }
public InterfaceHdrRecord ( RecordInputStream in ) { _codepage = in . readShort ( ) ; }
public DescribeVaultRequest ( String accountId , String vaultName ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; }
public void add ( String match , String replacement ) { if ( match . length ( ) == 0 ) { throw new IllegalArgumentException ( " cannot ▁ match ▁ the ▁ empty ▁ string " ) ; } if ( pendingPairs . containsKey ( match ) ) { throw new IllegalArgumentException ( " match ▁ \ " " + match + " \ " ▁ was ▁ already ▁ added " ) ; } pendingPairs . put ( match , replacement ) ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } else if ( ! ( o instanceof ArrayPredictionContext ) ) { return false ; } if ( this . hashCode ( ) != o . hashCode ( ) ) { return false ; } ArrayPredictionContext a = ( ArrayPredictionContext ) o ; return Arrays . equals ( returnStates , a . returnStates ) && Arrays . equals ( parents , a . parents ) ; }
public byte [ ] toArray ( ) { if ( arrays . isEmpty ( ) ) { return null ; } else if ( arrays . size ( ) > 1 ) { int totalLength = 0 ; for ( byte [ ] array : arrays ) { totalLength += array . length ; } byte [ ] concatenated = new byte [ totalLength ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , concatenated , destPos , array . length ) ; destPos += array . length ; } arrays . clear ( ) ; arrays . add ( concatenated ) ; } return arrays . get ( 0 ) ; }
public void serialize ( LittleEndianOutput out ) { int nItems = field_1_seriesNumbers . length ; out . writeShort ( nItems ) ; for ( int i = 0 ; i < nItems ; i ++ ) { out . writeShort ( field_1_seriesNumbers [ i ] ) ; } }
public boolean removePushURI ( URIish toRemove ) { return pushURIs . remove ( toRemove ) ; }
public StringBuilder append ( String str ) { append0 ( str ) ; return this ; }
public synchronized void close ( ) { flush ( ) ; if ( out != null ) { try { out . close ( ) ; out = null ; } catch ( IOException e ) { setError ( ) ; } } }
public final BytesRef [ ] getBinaryValues ( String name ) { final List < BytesRef > result = new ArrayList <> ( ) ; for ( IndexableField field : fields ) { if ( field . name ( ) . equals ( name ) ) { final BytesRef bytes = field . binaryValue ( ) ; if ( bytes != null ) { result . add ( bytes ) ; } } } return result . toArray ( new BytesRef [ result . size ( ) ] ) ; }
public final void backup ( int amount ) { bufferPosition -= amount ; }
public void addChildRecord ( EscherRecord childRecord ) { getChildRecords ( ) . add ( childRecord ) ; }
public DeleteExpressionResult deleteExpression ( DeleteExpressionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteExpression ( request ) ; }
public ReorderReceiptRuleSetResult reorderReceiptRuleSet ( ReorderReceiptRuleSetRequest request ) { request = beforeClientExecution ( request ) ; return executeReorderReceiptRuleSet ( request ) ; }
public FtrHeader ( RecordInputStream in ) { recordType = in . readShort ( ) ; grbitFrt = in . readShort ( ) ; associatedRange = new CellRangeAddress ( in ) ; }
public PutVoiceConnectorProxyResult putVoiceConnectorProxy ( PutVoiceConnectorProxyRequest request ) { request = beforeClientExecution ( request ) ; return executePutVoiceConnectorProxy ( request ) ; }
public DescribeDataSourcePermissionsResult describeDataSourcePermissions ( DescribeDataSourcePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDataSourcePermissions ( request ) ; }
public final char get ( int index ) { checkIndex ( index ) ; return backingArray [ offset + index ] ; }
public final void writeByte ( int val ) throws IOException { out . write ( val ) ; written ++ ; }
public ListTablesResult listTables ( String exclusiveStartTableName ) { return listTables ( new ListTablesRequest ( ) . withExclusiveStartTableName ( exclusiveStartTableName ) ) ; }
public String toString ( ) { return " Cell ( readerIndex = " + readerIndex + " ▁ nodeID = " + index . getNodeID ( ) + " ▁ isLeaf = " + index . isLeafNode ( ) + " ▁ distanceSquared = " + distanceSquared + " ) " ; }
public Result getResult ( ) { return status ; }
public int addConditionalFormatting ( CellRangeAddress [ ] regions , HSSFConditionalFormattingRule rule1 , HSSFConditionalFormattingRule rule2 ) { return addConditionalFormatting ( regions , new HSSFConditionalFormattingRule [ ] { rule1 , rule2 } ) ; }
public DescribeImageBuildersResult describeImageBuilders ( DescribeImageBuildersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeImageBuilders ( request ) ; }
public DescribeMountTargetsResult describeMountTargets ( DescribeMountTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeMountTargets ( request ) ; }
public UpdateClientCertificateResult updateClientCertificate ( UpdateClientCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateClientCertificate ( request ) ; }
public String getFormatString ( CellValueRecordInterface cell ) { int formatIndex = getFormatIndex ( cell ) ; if ( formatIndex == - 1 ) { return null ; } return getFormatString ( formatIndex ) ; }
public void clear ( ) { w1 = 0 ; w2 = 0 ; w3 = 0 ; w4 = 0 ; w5 = 0 ; }
public boolean equals ( Object o ) { return o instanceof TurkishStemmer ; }
public void disableRefLog ( ) { customRefLog = true ; refLogMessage = null ; refLogIncludeResult = false ; }
public ListPublicKeysResult listPublicKeys ( ListPublicKeysRequest request ) { request = beforeClientExecution ( request ) ; return executeListPublicKeys ( request ) ; }
public CreateDhcpOptionsResult createDhcpOptions ( CreateDhcpOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDhcpOptions ( request ) ; }
public TokenStream create ( TokenStream input ) { return new ASCIIFoldingFilter ( input , preserveOriginal ) ; }
public BlockList ( int capacity ) { int dirSize = toDirectoryIndex ( capacity ) ; if ( ( capacity & BLOCK_MASK ) != 0 || dirSize == 0 ) dirSize ++ ; directory = BlockList . < T > newDirectory ( dirSize ) ; directory [ 0 ] = BlockList . < T > newBlock ( ) ; tailBlock = directory [ 0 ] ; }
@ Override public int size ( ) { return Impl . this . size ( ) ; }
public void addCellRangeAddress ( int firstRow , int firstCol , int lastRow , int lastCol ) { CellRangeAddress region = new CellRangeAddress ( firstRow , lastRow , firstCol , lastCol ) ; addCellRangeAddress ( region ) ; }
public DescribeCacheEngineVersionsResult describeCacheEngineVersions ( ) { return describeCacheEngineVersions ( new DescribeCacheEngineVersionsRequest ( ) ) ; }
public DeleteEndpointConfigResult deleteEndpointConfig ( DeleteEndpointConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEndpointConfig ( request ) ; }
public String findSheetFirstNameFromExternSheet ( int externSheetIndex ) { int indexToSheet = linkTable . getFirstInternalSheetIndexForExtIndex ( externSheetIndex ) ; return findSheetNameFromIndex ( indexToSheet ) ; }
public void copy ( MutableValue source ) { MutableValueBool s = ( MutableValueBool ) source ; value = s . value ; exists = s . exists ; }
public void setChild ( QueryNode child ) { List < QueryNode > list = new ArrayList <> ( ) ; list . add ( child ) ; this . set ( list ) ; }
public void setDateResolution ( DateTools . Resolution dateResolution ) { getQueryConfigHandler ( ) . set ( ConfigurationKeys . DATE_RESOLUTION , dateResolution ) ; }
public static < T > boolean contains ( T [ ] array , T value ) { for ( T element : array ) { if ( element == null ) { if ( value == null ) return true ; } else { if ( value != null && element . equals ( value ) ) return true ; } } return false ; }
public ListLogPatternsResult listLogPatterns ( ListLogPatternsRequest request ) { request = beforeClientExecution ( request ) ; return executeListLogPatterns ( request ) ; }
public BatchDeleteImageResult batchDeleteImage ( BatchDeleteImageRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDeleteImage ( request ) ; }
public void seekExact ( long ord ) { throw new UnsupportedOperationException ( ) ; }
public RightMarginRecord ( RecordInputStream in ) { field_1_margin = in . readDouble ( ) ; }
public boolean isAutoDetecting ( ) { return false ; }
public RestorePhoneNumberResult restorePhoneNumber ( RestorePhoneNumberRequest request ) { request = beforeClientExecution ( request ) ; return executeRestorePhoneNumber ( request ) ; }
public TestRenderTemplateResult testRenderTemplate ( TestRenderTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeTestRenderTemplate ( request ) ; }
public RevTag lookupTag ( AnyObjectId id ) { RevTag c = ( RevTag ) objects . get ( id ) ; if ( c == null ) { c = new RevTag ( id ) ; objects . add ( c ) ; } return c ; }
public Query getQuery ( Element e ) throws ParserException { String text = DOMUtils . getText ( e ) ; try { Query q = null ; if ( unSafeParser != null ) { synchronized ( unSafeParser ) { q = unSafeParser . parse ( text ) ; } } else { String fieldName = DOMUtils . getAttribute ( e , " fieldName " , defaultField ) ; QueryParser parser = createQueryParser ( fieldName , analyzer ) ; q = parser . parse ( text ) ; } float boost = DOMUtils . getAttribute ( e , " boost " , 1.0f ) ; return new BoostQuery ( q , boost ) ; } catch ( ParseException e1 ) { throw new ParserException ( e1. getMessage ( ) ) ; } }
public CreateNetworkAclResult createNetworkAcl ( CreateNetworkAclRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNetworkAcl ( request ) ; }
public ThreeWayMerger newMerger ( Repository db , boolean inCore ) { return newMerger ( db ) ; }
public BufferedWriter ( Writer out , int size ) { super ( out ) ; if ( size <= 0 ) { throw new IllegalArgumentException ( " size ▁ <= ▁ 0 " ) ; } this . out = out ; this . buf = new char [ size ] ; }
public ListConfigurationHistoryResult listConfigurationHistory ( ListConfigurationHistoryRequest request ) { request = beforeClientExecution ( request ) ; return executeListConfigurationHistory ( request ) ; }
public Request < GetChangeRequest > marshall ( GetChangeRequest getChangeRequest ) { if ( getChangeRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( ... ) " ) ; } Request < GetChangeRequest > request = new DefaultRequest < GetChangeRequest > ( getChangeRequest , " AmazonRoute53 " ) ; request . setHttpMethod ( HttpMethodName . GET ) ; String uriResourcePath = " / 2013 - 04 - 01 / change / { Id } " ; uriResourcePath = com . amazonaws . transform . PathMarshallers . NON_GREEDY . marshall ( uriResourcePath , " Id " , getChangeRequest . getId ( ) ) ; request . setResourcePath ( uriResourcePath ) ; return request ; }
public byte [ ] getCachedBytes ( ) throws LargeObjectException { throw new LargeObjectException ( id ) ; }
public ModifyInstanceCreditSpecificationResult modifyInstanceCreditSpecification ( ModifyInstanceCreditSpecificationRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyInstanceCreditSpecification ( request ) ; }
public void add ( RevCommit c ) { Block b = head ; if ( b == null || ! b . canUnpop ( ) ) { b = free . newBlock ( ) ; b . resetToEnd ( ) ; b . next = head ; head = b ; } b . unpop ( c ) ; }
public SpanTermQuery newSpanTermQuery ( Term term ) throws TooManyBasicQueries { checkMax ( ) ; return new SpanTermQuery ( term ) ; }
public StringWriter ( int initialSize ) { if ( initialSize < 0 ) { throw new IllegalArgumentException ( ) ; } buf = new StringBuffer ( initialSize ) ; lock = buf ; }
public String toString ( ) { return super . toString ( ) + " ( \ " " + patternText + " \ " ) " ; }
public ATNConfig precedenceTransition ( ATNConfig config , PrecedencePredicateTransition pt , boolean collectPredicates , boolean inContext , boolean fullCtx ) { if ( debug ) { System . out . println ( " PRED ▁ ( collectPredicates = " + collectPredicates + " ) ▁ " + pt . precedence + " >= □ p " + " , ▁ ctx ▁ dependent = true " ) ; if ( parser != null ) { System . out . println ( " context ▁ surrounding ▁ pred ▁ is ▁ " + parser . getRuleInvocationStack ( ) ) ; } } ATNConfig c = null ; if ( collectPredicates && inContext ) { if ( fullCtx ) { int currentPosition = _input . index ( ) ; _input . seek ( _startIndex ) ; boolean predSucceeds = evalSemanticContext ( pt . getPredicate ( ) , _outerContext , config . alt , fullCtx ) ; _input . seek ( currentPosition ) ; if ( predSucceeds ) { c = new ATNConfig ( config , pt . target ) ; } } else { SemanticContext newSemCtx = SemanticContext . and ( config . semanticContext , pt . getPredicate ( ) ) ; c = new ATNConfig ( config , pt . target , newSemCtx ) ; } } else { c = new ATNConfig ( config , pt . target ) ; } if ( debug ) System . out . println ( " config ▁ from ▁ pred ▁ transition = " + c ) ; return c ; }
public GetDomainStatisticsReportResult getDomainStatisticsReport ( GetDomainStatisticsReportRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDomainStatisticsReport ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; TermRangeQuery other = ( TermRangeQuery ) obj ; if ( includeLower != other . includeLower ) return false ; if ( includeUpper != other . includeUpper ) return false ; if ( lowerTerm == null ) { if ( other . lowerTerm != null ) return false ; } else if ( ! lowerTerm . equals ( other . lowerTerm ) ) return false ; if ( upperTerm == null ) { if ( other . upperTerm != null ) return false ; } else if ( ! upperTerm . equals ( other . upperTerm ) ) return false ; return true ; }
public DescribeTransitGatewayRouteTablesResult describeTransitGatewayRouteTables ( DescribeTransitGatewayRouteTablesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTransitGatewayRouteTables ( request ) ; }
public BootstrapActionConfig build ( ) { if ( replace ) { args . add ( " -- replace " ) ; } return new BootstrapActionConfig ( ) . withName ( " Configure ▁ Daemons " ) . withScriptBootstrapAction ( new ScriptBootstrapActionConfig ( ) . withPath ( " s3 : " ) . withArgs ( args ) ) ; }
public boolean isLegalReplacement ( byte [ ] replacement ) { if ( decoder == null ) { decoder = cs . newDecoder ( ) ; decoder . onMalformedInput ( CodingErrorAction . REPORT ) ; decoder . onUnmappableCharacter ( CodingErrorAction . REPORT ) ; } ByteBuffer in = ByteBuffer . wrap ( replacement ) ; CharBuffer out = CharBuffer . allocate ( ( int ) ( replacement . length * decoder . maxCharsPerByte ( ) ) ) ; CoderResult result = decoder . decode ( in , out , true ) ; return ! result . isError ( ) ; }
public UpdatePipelineResult updatePipeline ( UpdatePipelineRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdatePipeline ( request ) ; }
public boolean isAboveMinRep ( ) { int sc = _significand . bitLength ( ) - C_64 ; return _significand . compareTo ( BI_MIN_BASE . shiftLeft ( sc ) ) > 0 ; }
public AssociateContactWithAddressBookResult associateContactWithAddressBook ( AssociateContactWithAddressBookRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateContactWithAddressBook ( request ) ; }
public DeleteFolderResult deleteFolder ( DeleteFolderRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFolder ( request ) ; }
public PhraseWildcardQuery build ( ) { return new PhraseWildcardQuery ( field , phraseTerms , slop , maxMultiTermExpansions , segmentOptimizationEnabled ) ; }
public DescribeJobFlowsResult describeJobFlows ( ) { return describeJobFlows ( new DescribeJobFlowsRequest ( ) ) ; }
public float tf ( float freq ) { return baselineTf ( freq ) ; }
public DescribePublishingDestinationResult describePublishingDestination ( DescribePublishingDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribePublishingDestination ( request ) ; }
public int getLeftId ( int wordId ) { return LEFT_ID ; }
public static NormalisedDecimal create ( BigInteger frac , int binaryExponent ) { int pow10 ; if ( binaryExponent > 49 || binaryExponent < 46 ) { int x = ( 29 << 19 ) - binaryExponent * LOG_BASE_10_OF_2_TIMES_2_POW_20 ; x += C_2_POW_19 ; pow10 = - ( x >> 20 ) ; } else { pow10 = 0 ; } MutableFPNumber cc = new MutableFPNumber ( frac , binaryExponent ) ; if ( pow10 != 0 ) { cc . multiplyByPowerOfTen ( - pow10 ) ; } switch ( cc . get64BitNormalisedExponent ( ) ) { case 46 : if ( cc . isAboveMinRep ( ) ) { break ; } case 44 : case 45 : cc . multiplyByPowerOfTen ( 1 ) ; pow10 -- ; break ; case 47 : case 48 : break ; case 49 : if ( cc . isBelowMaxRep ( ) ) { break ; } case 50 : cc . multiplyByPowerOfTen ( - 1 ) ; pow10 ++ ; break ; default : throw new IllegalStateException ( " Bad ▁ binary ▁ exp ▁ " + cc . get64BitNormalisedExponent ( ) + " . " ) ; } cc . normalise64bit ( ) ; return cc . createNormalisedDecimal ( pow10 ) ; }
public String toString ( ) { return " DoubleRange ( " + label + " : ▁ " + min + " ▁ to ▁ " + max + " ) " ; }
public void setRefLogIdent ( PersonIdent pi ) { destination . setRefLogIdent ( pi ) ; }
public final void yybegin ( int newState ) { zzLexicalState = newState ; }
public Trie ( boolean forward ) { rows . add ( new Row ( ) ) ; root = 0 ; this . forward = forward ; }
public DeleteTagsRequest ( java . util . List < String > resources ) { setResources ( resources ) ; }
public ObjectProtectRecord clone ( ) { return copy ( ) ; }
public static FuncVarPtg create ( String pName , int numArgs ) { return create ( numArgs , lookupIndex ( pName ) ) ; }
public void clear ( ) { this . processors . clear ( ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeDouble ( getValue ( ) ) ; }
public NullReader ( int valueCount ) { this . valueCount = valueCount ; }
public CreateVaultResult createVault ( CreateVaultRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVault ( request ) ; }
@ Override public void add ( int index , E object ) { Object [ ] a = array ; int s = size ; if ( index > s || index < 0 ) { throwIndexOutOfBoundsException ( index , s ) ; } if ( s < a . length ) { System . arraycopy ( a , index , a , index + 1 , s - index ) ; } else { Object [ ] newArray = new Object [ newCapacity ( s ) ] ; System . arraycopy ( a , 0 , newArray , 0 , index ) ; System . arraycopy ( a , index , newArray , index + 1 , s - index ) ; array = a = newArray ; } a [ index ] = object ; size = s + 1 ; modCount ++ ; }
public int read ( char [ ] c , int off , int len ) { if ( left > len ) { s . getChars ( upto , upto + len , c , off ) ; upto += len ; left -= len ; return len ; } else if ( 0 == left ) { return - 1 ; } else { s . getChars ( upto , upto + left , c , off ) ; int r = left ; left = 0 ; upto = s . length ( ) ; return r ; } }
public DeleteDeploymentResult deleteDeployment ( DeleteDeploymentRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDeployment ( request ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ( bitsPerValue = " + bitsPerValue + " , size = " + size ( ) + " , blocks = " + blocks . length + " ) " ; }
public VectorValueSource ( List < ValueSource > sources ) { this . sources = sources ; }
public HSSFShape ( HSSFShape parent , HSSFAnchor anchor ) { this . parent = parent ; this . anchor = anchor ; this . _escherContainer = createSpContainer ( ) ; _optRecord = _escherContainer . getChildById ( EscherOptRecord . RECORD_ID ) ; _objRecord = createObjRecord ( ) ; }
public GalicianMinimalStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public DescribeFpgaImageAttributeResult describeFpgaImageAttribute ( DescribeFpgaImageAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFpgaImageAttribute ( request ) ; }
public ValueFiller getValueFiller ( ) { return new ValueFiller ( ) ; }
public static int update ( int hash , Object value ) { return update ( hash , value != null ? value . hashCode ( ) : 0 ) ; }
public DescribeModelVersionsResult describeModelVersions ( DescribeModelVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeModelVersions ( request ) ; }
public static IndexCommit findIndexCommit ( Directory dir , String userData ) throws IOException { Collection < IndexCommit > commits = DirectoryReader . listCommits ( dir ) ; for ( final IndexCommit ic : commits ) { Map < String , String > map = ic . getUserData ( ) ; String ud = null ; if ( map != null ) { ud = map . get ( USER_DATA ) ; } if ( ud != null && ud . equals ( userData ) ) { return ic ; } } throw new IOException ( " index ▁ does ▁ not ▁ contain ▁ commit ▁ with ▁ userData : ▁ " + userData ) ; }
public IndexEnum ( FST < Long > fst ) { fstEnum = new BytesRefFSTEnum <> ( fst ) ; }
public HSSFEvaluationSheet ( HSSFSheet hs ) { _hs = hs ; }
public void update ( int b ) { if ( upto == buffer . length ) { flush ( ) ; } buffer [ upto ++ ] = ( byte ) b ; }
public PutPartnerEventsResult putPartnerEvents ( PutPartnerEventsRequest request ) { request = beforeClientExecution ( request ) ; return executePutPartnerEvents ( request ) ; }
public boolean isThin ( ) { return thin ; }
public String toStringTree ( ) { return toString ( ) ; }
public PackConfig ( Repository db ) { fromConfig ( db . getConfig ( ) ) ; }
public void setDeltaCompress ( boolean deltaCompress ) { this . deltaCompress = deltaCompress ; }
public ListTrafficPolicyInstancesByHostedZoneResult listTrafficPolicyInstancesByHostedZone ( ListTrafficPolicyInstancesByHostedZoneRequest request ) { request = beforeClientExecution ( request ) ; return executeListTrafficPolicyInstancesByHostedZone ( request ) ; }
public EscherRecord findFirstWithId ( short id ) { return findFirstWithId ( id , getEscherRecords ( ) ) ; }
public byte [ ] getEntryPathBuffer ( ) { return path ; }
public void setFont ( Font f ) { font = f ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final int byte0 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = byte0 >>> 2 ; final int byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte0 & 3 ) << 4 ) | ( byte1 >>> 4 ) ; final int byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 15 ) << 2 ) | ( byte2 >>> 6 ) ; values [ valuesOffset ++ ] = byte2 & 63 ; } }
public boolean hasAnchoringBounds ( ) { return anchoringBounds ; }
public void drawPolygon ( int [ ] xPoints , int [ ] yPoints , int nPoints ) { int right = findBiggest ( xPoints ) ; int bottom = findBiggest ( yPoints ) ; int left = findSmallest ( xPoints ) ; int top = findSmallest ( yPoints ) ; HSSFPolygon shape = escherGroup . createPolygon ( new HSSFChildAnchor ( left , top , right , bottom ) ) ; shape . setPolygonDrawArea ( right - left , bottom - top ) ; shape . setPoints ( addToAll ( xPoints , - left ) , addToAll ( yPoints , - top ) ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; shape . setLineWidth ( 0 ) ; shape . setNoFill ( true ) ; }
public String getAccessKeyId ( ) { return getCredentials ( ) . getAccessKeyId ( ) ; }
public PutDedicatedIpWarmupAttributesResult putDedicatedIpWarmupAttributes ( PutDedicatedIpWarmupAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executePutDedicatedIpWarmupAttributes ( request ) ; }
public void print ( char ch ) { print ( String . valueOf ( ch ) ) ; }
public String buildExtensionField ( String extensionKey ) { return buildExtensionField ( extensionKey , " " ) ; }
public CompareFacesResult compareFaces ( CompareFacesRequest request ) { request = beforeClientExecution ( request ) ; return executeCompareFaces ( request ) ; }
public PatchFormatException ( List < FormatError > errors ) { super ( MessageFormat . format ( JGitText . get ( ) . patchFormatException , errors ) ) ; this . errors = errors ; }
public String finish ( ) { sb . append ( formatTrailer ( ) ) ; return sb . toString ( ) ; }
public int getLevelForDistance ( double dist ) { if ( dist == 0 ) return maxLevels ; for ( int i = 0 ; i < maxLevels - 1 ; i ++ ) { if ( dist > levelW [ i ] && dist > levelH [ i ] ) { return i + 1 ; } } return maxLevels ; }
public int [ ] init ( ) { final int [ ] ord = super . init ( ) ; boost = new float [ ArrayUtil . oversize ( ord . length , Float . BYTES ) ] ; termState = new TermStates [ ArrayUtil . oversize ( ord . length , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ] ; assert termState . length >= ord . length && boost . length >= ord . length ; return ord ; }
public final void yyreset ( java . io . Reader reader ) { zzReader = reader ; zzAtBOL = true ; zzAtEOF = false ; zzEOFDone = false ; zzEndRead = zzStartRead = 0 ; zzCurrentPos = zzMarkedPos = 0 ; zzFinalHighSurrogate = 0 ; yyline = yychar = yycolumn = 0 ; zzLexicalState = YYINITIAL ; if ( zzBuffer . length > ZZ_BUFFERSIZE ) zzBuffer = new char [ ZZ_BUFFERSIZE ] ; }
public void deleteFile ( String name ) { throw new UnsupportedOperationException ( ) ; }
public StopTrainingDocumentClassifierResult stopTrainingDocumentClassifier ( StopTrainingDocumentClassifierRequest request ) { request = beforeClientExecution ( request ) ; return executeStopTrainingDocumentClassifier ( request ) ; }
public TermStats ( int docFreq , long totalTermFreq ) { this . docFreq = docFreq ; this . totalTermFreq = totalTermFreq ; }
public GetAuthorizersResult getAuthorizers ( GetAuthorizersRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAuthorizers ( request ) ; }
public void dispatch ( RepositoryEvent event ) { List < ListenerHandle > list = lists . get ( event . getListenerType ( ) ) ; if ( list != null ) { for ( ListenerHandle handle : list ) event . dispatch ( handle . listener ) ; } }
public String toString ( String field ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " spanNot ( " ) ; buffer . append ( include . toString ( field ) ) ; buffer . append ( " , ▁ " ) ; buffer . append ( exclude . toString ( field ) ) ; buffer . append ( " , ▁ " ) ; buffer . append ( Integer . toString ( pre ) ) ; buffer . append ( " , ▁ " ) ; buffer . append ( Integer . toString ( post ) ) ; buffer . append ( " ) " ) ; return buffer . toString ( ) ; }
public SearchGameSessionsResult searchGameSessions ( SearchGameSessionsRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchGameSessions ( request ) ; }
public int stem ( char s [ ] , int len ) { if ( len < 4 ) return len ; for ( int i = 0 ; i < len ; i ++ ) switch ( s [ i ] ) { case ' ä ' : case ' å ' : s [ i ] = ' a ' ; break ; case ' ö ' : s [ i ] = ' o ' ; break ; } len = step1 ( s , len ) ; len = step2 ( s , len ) ; len = step3 ( s , len ) ; len = norm1 ( s , len ) ; len = norm2 ( s , len ) ; return len ; }
public PutConfigurationSetReputationOptionsResult putConfigurationSetReputationOptions ( PutConfigurationSetReputationOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executePutConfigurationSetReputationOptions ( request ) ; }
public ListAttendeeTagsResult listAttendeeTags ( ListAttendeeTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAttendeeTags ( request ) ; }
public static void validateSheetName ( String sheetName ) { if ( sheetName == null ) { throw new IllegalArgumentException ( " sheetName ▁ must ▁ not ▁ be ▁ null " ) ; } int len = sheetName . length ( ) ; if ( len < 1 || len > 31 ) { throw new IllegalArgumentException ( " sheetName ▁ ' " ▁ + ▁ sheetName + ▁ " ' ▁ is ▁ invalid ▁ - ▁ character ▁ count ▁ MUST ▁ be ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ 1 ▁ and ▁ less ▁ than ▁ or ▁ equal ▁ to ▁ 31 " ) ; } for ( int i = 0 ; i < len ; i ++ ) { char ch = sheetName . charAt ( i ) ; switch ( ch ) { case ' / ' : case ' \\ ' : case ▁ ' ? ' : case ▁ ' * ' : case ▁ ' ] ' : case ▁ ' [ ' : case ▁ ' : ' : break ; default : continue ; } throw ▁ new ▁ IllegalArgumentException ( " Invalid char ( " ▁ + ▁ ch + ▁ " ) found at index ( " ▁ + ▁ i ▁ + ▁ " ) in sheet name ' " + sheetName + " ' " ) ; } if ▁ ( sheetName . charAt ( 0 ) ▁ == ▁ ' \ ' ' ▁ || ▁ sheetName . charAt ( len - 1 ) ▁ == ▁ ' \ ' ' ) ▁ { throw ▁ new ▁ IllegalArgumentException ( " Invalid sheet name ' " + sheetName + " ' . Sheet names must not begin or end with ( ' ) . " ) ; } }
public long getPosition ( ) { return getPointer ( ) ; }
public void reset ( DataOutput out ) { assert out != null ; this . out = out ; off = 0 ; ord = 0L ; finished = false ; }
public String toString ( String field ) { final StringBuilder buffer = new StringBuilder ( ) ; if ( ! term . field ( ) . equals ( field ) ) { buffer . append ( term . field ( ) ) ; buffer . append ( " : " ) ; } buffer . append ( term . text ( ) ) ; buffer . append ( ' ~ ' ) ; buffer . append ( maxEdits ) ; return buffer . toString ( ) ; }
public RevFilter clone ( ) { return new MaxCountRevFilter ( maxCount ) ; }
public DisableUserResult disableUser ( DisableUserRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableUser ( request ) ; }
public void append ( String stringToMatch ) { for ( int i = 0 ; i < stringToMatch . length ( ) ; i ++ ) { final char c = stringToMatch . charAt ( i ) ; if ( ! extendStringToMatchByOneCharacter ( c ) ) break ; } }
public StopTrainingJobResult stopTrainingJob ( StopTrainingJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopTrainingJob ( request ) ; }
public IndexInput openInput ( String name , IOContext context ) throws IOException { ensureOpen ( ) ; final String id = IndexFileNames . stripSegmentName ( name ) ; final FileEntry entry = entries . get ( id ) ; if ( entry == null ) { String datFileName = IndexFileNames . segmentFileName ( segmentName , " " , Lucene50CompoundFormat . DATA_EXTENSION ) ; throw new FileNotFoundException ( " No ▁ sub - file ▁ with ▁ id ▁ " + id + " ▁ found ▁ in ▁ compound ▁ file ▁ \ " " + datFileName + " \ " ▁ ( fileName = " + name + " ▁ files : ▁ " + entries . keySet ( ) + " ) " ) ; } return handle . slice ( name , entry . offset , entry . length ) ; }
public GetSnowballUsageResult getSnowballUsage ( GetSnowballUsageRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSnowballUsage ( request ) ; }
public DeleteUserProfileResult deleteUserProfile ( DeleteUserProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteUserProfile ( request ) ; }
public int compare ( ConfigLine a , ConfigLine b ) { return compare2 ( a . section , a . subsection , a . name , b . section , b . subsection , b . name ) ; }
public LongBuffer asReadOnlyBuffer ( ) { return duplicate ( ) ; }
public HSSFComment createCellComment ( ClientAnchor anchor ) { return createComment ( ( HSSFAnchor ) anchor ) ; }
public CollatedTermAttributeImpl ( Collator collator ) { this . collator = ( Collator ) collator . clone ( ) ; }
public UpdatePipelineStatusResult updatePipelineStatus ( UpdatePipelineStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdatePipelineStatus ( request ) ; }
public void copyTo ( char [ ] tmp , StringBuilder w ) { toHexCharArray ( tmp ) ; w . append ( tmp , 0 , Constants . OBJECT_ID_STRING_LENGTH ) ; }
public BytesReader getBytesReader ( ) { if ( fst == null ) { return null ; } else { return fst . getBytesReader ( ) ; } }
public CreateRouteTableResult createRouteTable ( CreateRouteTableRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRouteTable ( request ) ; }
public String toString ( String field ) { return " ToParentBlockJoinQuery ▁ ( " + childQuery . toString ( ) + " ) " ; }
public DisassociateClientVpnTargetNetworkResult disassociateClientVpnTargetNetwork ( DisassociateClientVpnTargetNetworkRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateClientVpnTargetNetwork ( request ) ; }
public String toString ( ) { return " < slop ▁ value = ' " ▁ + ▁ getValueString ( ) ▁ + ▁ " ' > " + " \ n " + getChild ( ) . toString ( ) + " \ n </ slop > " ; }
public GetExportJobsResult getExportJobs ( GetExportJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetExportJobs ( request ) ; }
public UpdateBaiduChannelResult updateBaiduChannel ( UpdateBaiduChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateBaiduChannel ( request ) ; }
public ImportApiResult importApi ( ImportApiRequest request ) { request = beforeClientExecution ( request ) ; return executeImportApi ( request ) ; }
public synchronized int read ( ) { return pos < count ? buffer . charAt ( pos ++ ) & 0xFF : - 1 ; }
public GetUserResult getUser ( GetUserRequest request ) { request = beforeClientExecution ( request ) ; return executeGetUser ( request ) ; }
public GetHealthCheckLastFailureReasonResult getHealthCheckLastFailureReason ( GetHealthCheckLastFailureReasonRequest request ) { request = beforeClientExecution ( request ) ; return executeGetHealthCheckLastFailureReason ( request ) ; }
public String getRawQuery ( ) { return query ; }
public static void fill ( long [ ] array , int start , int end , long value ) { Arrays . checkStartAndEnd ( array . length , start , end ) ; for ( int i = start ; i < end ; i ++ ) { array [ i ] = value ; } }
public boolean equals ( Object obj ) { if ( obj instanceof StatePair ) { StatePair p = ( StatePair ) obj ; return p . s1 == s1 && p . s2 == s2 ; } else return false ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ OLD ▁ STRING ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . string ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getString ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / OLD ▁ STRING ] \ n " ) ; return buffer . toString ( ) ; }
public ExecutePolicyResult executePolicy ( ExecutePolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeExecutePolicy ( request ) ; }
public UpdateEmailTemplateResult updateEmailTemplate ( UpdateEmailTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateEmailTemplate ( request ) ; }
public boolean equalsContents ( final Object o ) { final CustomProperty c = ( CustomProperty ) o ; final String name1 = c . getName ( ) ; final String name2 = this . getName ( ) ; boolean equalNames = true ; if ( name1 == null ) { equalNames = name2 == null ; } else { equalNames = name1. equals ( name2 ) ; } return equalNames && c . getID ( ) == this . getID ( ) && c . getType ( ) == this . getType ( ) && c . getValue ( ) . equals ( this . getValue ( ) ) ; }
public DuplicateFormatFlagsException ( String f ) { if ( f == null ) { throw new NullPointerException ( ) ; } flags = f ; }
public synchronized void mark ( int readlimit ) { marklimit = readlimit ; markpos = pos ; }
public final int prefixCompare ( AnyObjectId other ) { int cmp ; cmp = NB . compareUInt32 ( w1 , mask ( 1 , other . w1 ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w2 , mask ( 2 , other . w2 ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w3 , mask ( 3 , other . w3 ) ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w4 , mask ( 4 , other . w4 ) ) ; if ( cmp != 0 ) return cmp ; return NB . compareUInt32 ( w5 , mask ( 5 , other . w5 ) ) ; }
public UpdateRequestValidatorResult updateRequestValidator ( UpdateRequestValidatorRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRequestValidator ( request ) ; }
public Extensions ( char extensionFieldDelimiter ) { this . extensionFieldDelimiter = extensionFieldDelimiter ; }
public TokenStream create ( TokenStream input ) { return new EnglishMinimalStemFilter ( input ) ; }
public QueryText getPathElement ( int index ) { return values . get ( index ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _sid ) ; out . writeShort ( _data . length ) ; out . write ( _data ) ; }
public void setQueryConfigHandler ( QueryConfigHandler queryConfigHandler ) { this . queryConfig = queryConfigHandler ; for ( QueryNodeProcessor processor : this . processors ) { processor . setQueryConfigHandler ( this . queryConfig ) ; } }
public DeleteGameSessionQueueResult deleteGameSessionQueue ( DeleteGameSessionQueueRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteGameSessionQueue ( request ) ; }
public List < DFAState > getStates ( ) { List < DFAState > result = new ArrayList < DFAState > ( states . keySet ( ) ) ; Collections . sort ( result , new Comparator < DFAState > ( ) ) ; }
public static CmpOp getOperator ( String value ) { int len = value . length ( ) ; if ( len < 1 ) { return OP_NONE ; } char firstChar = value . charAt ( 0 ) ; switch ( firstChar ) { case ' = ' : return OP_EQ ; case ' > ' : if ( len > 1 ) { switch ( value . charAt ( 1 ) ) { case ' = ' : return OP_GE ; } } return OP_GT ; case ' < ' : if ( len > 1 ) { switch ( value . charAt ( 1 ) ) { case ' = ' : return OP_LE ; case ' > ' : return OP_NE ; } } return OP_LT ; } return OP_NONE ; }
public void addChars ( char [ ] characters , int [ ] widths ) { for ( int i = 0 ; i < characters . length ; i ++ ) { charWidths . put ( Character . valueOf ( characters [ i ] ) , Integer . valueOf ( widths [ i ] ) ) ; } }
public ShortBuffer duplicate ( ) { return copy ( this , mark ) ; }
public void setValidating ( boolean validating ) { features . put ( XmlPullParser . FEATURE_VALIDATION , validating ) ; }
public DedicatedCapacityInner create ( String resourceGroupName , String dedicatedCapacityName , DedicatedCapacityInner capacityParameters ) { return createWithServiceResponseAsync ( resourceGroupName , dedicatedCapacityName , capacityParameters ) . toBlocking ( ) . last ( ) . body ( ) ; }
public CancelIngestionResult cancelIngestion ( CancelIngestionRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelIngestion ( request ) ; }
public void setEncoding ( String encodingName ) { encoding = Charset . forName ( encodingName ) ; }
public DeleteTemplateAliasResult deleteTemplateAlias ( DeleteTemplateAliasRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTemplateAlias ( request ) ; }
public String resolveNameXText ( int refIndex , int definedNameIndex , InternalWorkbook workbook ) { int extBookIndex = _externSheetRecord . getExtbookIndexFromRefIndex ( refIndex ) ; int firstTabIndex = _externSheetRecord . getFirstSheetIndexFromRefIndex ( refIndex ) ; if ( firstTabIndex == - 1 ) { throw new RuntimeException ( " Referenced ▁ sheet ▁ could ▁ not ▁ be ▁ found " ) ; } ExternalBookBlock externalBook = _externalBookBlocks [ extBookIndex ] ; if ( externalBook . _externalNameRecords . length > definedNameIndex ) { return _externalBookBlocks [ extBookIndex ] . getNameText ( definedNameIndex ) ; } else if ( firstTabIndex == - 2 ) { NameRecord nr = getNameRecord ( definedNameIndex ) ; int sheetNumber = nr . getSheetNumber ( ) ; StringBuilder text = new StringBuilder ( 64 ) ; if ( sheetNumber > 0 ) { String sheetName = workbook . getSheetName ( sheetNumber - 1 ) ; SheetNameFormatter . appendFormat ( text , sheetName ) ; text . append ( " ! " ) ; } text . append ( nr . getNameText ( ) ) ; return text . toString ( ) ; } else { throw new ArrayIndexOutOfBoundsException ( " Ext ▁ Book ▁ Index ▁ relative ▁ but ▁ beyond ▁ the ▁ supported ▁ length , ▁ was ▁ " + extBookIndex + " ▁ but ▁ maximum ▁ is ▁ " + _externalBookBlocks . length ) ; } }
public InetAddress getRemoteAddress ( ) { return peer ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof LexerTypeAction ) ) { return false ; } return type == ( ( LexerTypeAction ) obj ) . type ; }
public RefValueArray ( RefEval ref ) { super ( ref . getNumberOfSheets ( ) ) ; _ref = ref ; _width = ref . getNumberOfSheets ( ) ; }
public static Git wrap ( Repository repo ) { return new Git ( repo ) ; }
public int get64BitNormalisedExponent ( ) { return _binaryExponent + _significand . bitLength ( ) - C_64 ; }
public GetRepoWebhookRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoWebhook " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / webhooks " ) ; setMethod ( MethodType . GET ) ; }
public Object merge ( Object first , Object second ) { List < T > outputList = new ArrayList <> ( ) ; if ( ! ( first instanceof List ) ) { outputList . add ( ( T ) first ) ; } else { outputList . addAll ( ( List < T > ) first ) ; } if ( ! ( second instanceof List ) ) { outputList . add ( ( T ) second ) ; } else { outputList . addAll ( ( List < T > ) second ) ; } return outputList ; }
public UpdateThreatIntelSetResult updateThreatIntelSet ( UpdateThreatIntelSetRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateThreatIntelSet ( request ) ; }
public final float getFloat ( int index ) { return Float . intBitsToFloat ( getInt ( index ) ) ; }
public SortingFields ( final Fields in , FieldInfos infos , Sorter . DocMap docMap ) { super ( in ) ; this . docMap = docMap ; this . infos = infos ; }
public static SupBookRecord createAddInFunctions ( ) { return new SupBookRecord ( true , ( short ) 1 ) ; }
public ImportClientVpnClientCertificateRevocationListResult importClientVpnClientCertificateRevocationList ( ImportClientVpnClientCertificateRevocationListRequest request ) { request = beforeClientExecution ( request ) ; return executeImportClientVpnClientCertificateRevocationList ( request ) ; }
public GetVoiceConnectorOriginationResult getVoiceConnectorOrigination ( GetVoiceConnectorOriginationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVoiceConnectorOrigination ( request ) ; }
public GetTypedLinkFacetInformationResult getTypedLinkFacetInformation ( GetTypedLinkFacetInformationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTypedLinkFacetInformation ( request ) ; }
public PhraseSlopQueryNode ( QueryNode query , int value ) { if ( query == null ) { throw new QueryNodeError ( new MessageImpl ( QueryParserMessages . NODE_ACTION_NOT_SUPPORTED , " query " , " null " ) ) ; } this . value = value ; setLeaf ( false ) ; allocate ( ) ; add ( query ) ; }
public UpdateDeploymentGroupResult updateDeploymentGroup ( UpdateDeploymentGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDeploymentGroup ( request ) ; }
public DeleteVaultNotificationsRequest ( String accountId , String vaultName ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; }
@ Override public boolean contains ( Object key ) { return subMap . containsKey ( key ) ; }
public int get ( String name , int dflt ) { int vals [ ] = ( int [ ] ) valByRound . get ( name ) ; if ( vals != null ) { return vals [ roundNumber % vals . length ] ; } String sval = props . getProperty ( name , " " + dflt ) ; if ( sval . indexOf ( " : " ) < 0 ) { return Integer . parseInt ( sval ) ; } int k = sval . indexOf ( " : " ) ; String colName = sval . substring ( 0 , k ) ; sval = sval . substring ( k + 1 ) ; colForValByRound . put ( name , colName ) ; vals = propToIntArray ( sval ) ; valByRound . put ( name , vals ) ; return vals [ roundNumber % vals . length ] ; }
public DeleteGitHubAccountTokenResult deleteGitHubAccountToken ( DeleteGitHubAccountTokenRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteGitHubAccountToken ( request ) ; }
public GetPasswordDataRequest ( String instanceId ) { setInstanceId ( instanceId ) ; }
public GetCloudFrontOriginAccessIdentityConfigRequest ( String id ) { setId ( id ) ; }
public STSAssumeRoleSessionCredentialsProvider withRoleSessionDurationSeconds ( long roleSessionDurationSeconds ) { if ( roleSessionDurationSeconds < 900 || roleSessionDurationSeconds > 3600 ) { throw new IllegalArgumentException ( " Assume ▁ Role ▁ session ▁ duration ▁ should ▁ be ▁ in ▁ the ▁ range ▁ of ▁ 15min ▁ - ▁ 1Hr " ) ; } this . roleSessionDurationSeconds = roleSessionDurationSeconds ; return this ; }
final public QueryNode ModClause ( CharSequence field ) throws ParseException { QueryNode q ; ModifierQueryNode . Modifier mods ; mods = Modifiers ( ) ; q = Clause ( field ) ; if ( mods != ModifierQueryNode . Modifier . MOD_NONE ) { q = new ModifierQueryNode ( q , mods ) ; } { if ( true ) return q ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public AbbreviatedObjectId getOldId ( int nthParent ) { return oldIds [ nthParent ] ; }
public HttpRequest ( String strUrl , Map < String , String > tmpHeaders ) { super ( strUrl ) ; if ( null != tmpHeaders ) { this . headers = tmpHeaders ; } }
public AcceptInvitationResult acceptInvitation ( AcceptInvitationRequest request ) { request = beforeClientExecution ( request ) ; return executeAcceptInvitation ( request ) ; }
public int getFormatIndex ( CellValueRecordInterface cell ) { ExtendedFormatRecord xfr = _xfRecords . get ( cell . getXFIndex ( ) ) ; if ( xfr == null ) { logger . log ( POILogger . ERROR , " Cell ▁ " + cell . getRow ( ) + " , " + cell . getColumn ( ) + " ▁ uses ▁ XF ▁ with ▁ index ▁ " + cell . getXFIndex ( ) + " , ▁ but ▁ we ▁ don ' t have that " ) ; return ▁ - 1 ; } return ▁ xfr . getFormatIndex ( ) ; }
public final File getFile ( ) { return path ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { final byte block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( block >>> 4 ) & 15 ; values [ valuesOffset ++ ] = block & 15 ; } }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( " ▁ [ " ) ; if ( externalWorkbookNumber >= 0 ) { sb . append ( " ▁ [ " ) ; sb . append ( " workbook = " ) . append ( getExternalWorkbookNumber ( ) ) ; sb . append ( " ] ▁ " ) ; } sb . append ( " sheet = " ) . append ( firstSheetName ) ; if ( lastSheetName != null ) { sb . append ( " ▁ : ▁ " ) ; sb . append ( " sheet = " ) . append ( lastSheetName ) ; } sb . append ( " ▁ ! ▁ " ) ; sb . append ( formatReferenceAsString ( ) ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public PushCommand setRefSpecs ( List < RefSpec > specs ) { checkCallable ( ) ; this . refSpecs . clear ( ) ; this . refSpecs . addAll ( specs ) ; return this ; }
public static boolean isBinary ( byte [ ] raw , int length ) { if ( length > FIRST_FEW_BYTES ) length = FIRST_FEW_BYTES ; for ( int ptr = 0 ; ptr < length ; ptr ++ ) if ( raw [ ptr ] == ' \ 0 ' ) return true ; return false ; }
@ Override public void clear ( ) { AbstractBiMap . this . clear ( ) ; }
public PackingPhase getPhase ( ) { return phase ; }
public State clone ( ) { State clone = new State ( ) ; clone . attribute = attribute . clone ( ) ; if ( next != null ) { clone . next = next . clone ( ) ; } return clone ; }
public static double acosh ( double a ) { return Math . log ( Math . sqrt ( a * a - 1.0d ) + a ) ; }
public GetSearchSuggestionsResult getSearchSuggestions ( GetSearchSuggestionsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSearchSuggestions ( request ) ; }
public static Date getJavaDate ( double date , boolean use1904windowing , TimeZone tz ) { return getJavaDate ( date , use1904windowing , tz , false ) ; }
public ListVerifiedEmailAddressesResult listVerifiedEmailAddresses ( ListVerifiedEmailAddressesRequest request ) { request = beforeClientExecution ( request ) ; return executeListVerifiedEmailAddresses ( request ) ; }
public int compareTo ( QualityQuery other ) { try { int n = Integer . parseInt ( queryID ) ; int nOther = Integer . parseInt ( other . queryID ) ; return n - nOther ; } catch ( NumberFormatException e ) { return queryID . compareTo ( other . queryID ) ; } }
public void setExportAll ( boolean export ) { exportAll = export ; }
public LexerATNConfig ( LexerATNConfig c , ATNState state , PredictionContext context ) { super ( c , state , context , c . semanticContext ) ; this . lexerActionExecutor = c . lexerActionExecutor ; this . passedThroughNonGreedyDecision = checkNonGreedyDecision ( c , state ) ; }
public DescribeScheduledActionsResult describeScheduledActions ( DescribeScheduledActionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeScheduledActions ( request ) ; }
public boolean isAdjacentBefore ( ColumnInfoRecord other ) { return _lastCol == other . _firstCol - 1 ; }
public QueryScorer ( Query query , IndexReader reader , String field , String defaultField ) { this . defaultField = defaultField ; init ( query , field , reader , true ) ; }
public CreateConfigurationSetTrackingOptionsResult createConfigurationSetTrackingOptions ( CreateConfigurationSetTrackingOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateConfigurationSetTrackingOptions ( request ) ; }
public synchronized int offsetByCodePoints ( int index , int codePointOffset ) { return super . offsetByCodePoints ( index , codePointOffset ) ; }
public void write ( char [ ] buf ) { write ( buf , 0 , buf . length ) ; }
public GetSdkResult getSdk ( GetSdkRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSdk ( request ) ; }
public PutEmailIdentityDkimAttributesResult putEmailIdentityDkimAttributes ( PutEmailIdentityDkimAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executePutEmailIdentityDkimAttributes ( request ) ; }
public WorkflowExecutionDetail describeWorkflowExecution ( DescribeWorkflowExecutionRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWorkflowExecution ( request ) ; }
public CloudFrontOriginAccessIdentityConfig ( String callerReference ) { setCallerReference ( callerReference ) ; }
public final String validate ( String uri , int start , int end , String name ) throws URISyntaxException { for ( int i = start ; i < end ; ) { char ch = uri . charAt ( i ) ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) || ( ch >= ' 0 ' && ch <= ' 9 ' ) || isRetained ( ch ) ) { i ++ ; } else if ( ch == ' % ' ) { if ( i + 2 >= end ) { throw new URISyntaxException ( uri , " Incomplete ▁ % ▁ sequence ▁ in ▁ " + name , i ) ; } int d1 = hexToInt ( uri . charAt ( i + 1 ) ) ; int d2 = hexToInt ( uri . charAt ( i + 2 ) ) ; if ( d1 == - 1 || d2 == - 1 ) { throw new URISyntaxException ( uri , " Invalid ▁ % ▁ sequence : ▁ " + uri . substring ( i , i + 3 ) + " ▁ in ▁ " + name , i ) ; } i += 3 ; } else { throw new URISyntaxException ( uri , " Illegal ▁ character ▁ in ▁ " + name , i ) ; } } return uri . substring ( start , end ) ; }
public UnbufferedCharStream ( Reader input , int bufferSize ) { this ( bufferSize ) ; this . input = input ; fill ( 1 ) ; }
public ContinuableRecordInput ( RecordInputStream in ) { _in = in ; }
public StoredFieldsReader clone ( ) { if ( in == null ) { throw new AlreadyClosedException ( " this ▁ FieldsReader ▁ is ▁ closed " ) ; } return new SimpleTextStoredFieldsReader ( offsets , in . clone ( ) , fieldInfos ) ; }
public Initial ( LittleEndianInput in ) { _reserved0 = in . readInt ( ) ; _reserved1 = in . readUShort ( ) ; _reserved2 = in . readUByte ( ) ; }
public synchronized int getProgress ( ) { return mIndeterminate ? 0 : mProgress ; }
public CreateNamedQueryResult createNamedQuery ( CreateNamedQueryRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNamedQuery ( request ) ; }
public static DoubleBuffer allocate ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( ) ; } return new ReadWriteDoubleArrayBuffer ( capacity ) ; }
public final String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + _operator . getRepresentation ( ) + getValueText ( ) + " ] " ; }
public LongBuffer asReadOnlyBuffer ( ) { return ReadOnlyLongArrayBuffer . copy ( this , mark ) ; }
public CreateFlowDefinitionResult createFlowDefinition ( CreateFlowDefinitionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFlowDefinition ( request ) ; }
public GetOpenIdTokenResult getOpenIdToken ( GetOpenIdTokenRequest request ) { request = beforeClientExecution ( request ) ; return executeGetOpenIdToken ( request ) ; }
public GetDocumentationPartResult getDocumentationPart ( GetDocumentationPartRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDocumentationPart ( request ) ; }
public ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { int nArgs = args . length ; if ( nArgs < 2 ) { return ErrorEval . VALUE_INVALID ; } try { double rate = NumericFunction . singleOperandEvaluate ( args [ 0 ] , srcRowIndex , srcColumnIndex ) ; ValueEval [ ] vargs = new ValueEval [ args . length - 1 ] ; System . arraycopy ( args , 1 , vargs , 0 , vargs . length ) ; double [ ] values = AggregateFunction . ValueCollector . collectValues ( vargs ) ; double result = FinanceLib . npv ( rate , values ) ; NumericFunction . checkValue ( result ) ; return new NumberEval ( result ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public String suggestFileExtension ( ) { switch ( EscherRecordTypes . forTypeID ( blip . getRecordId ( ) ) ) { case BLIP_WMF : return " wmf " ; case BLIP_EMF : return " emf " ; case BLIP_PICT : return " pict " ; case BLIP_PNG : return " png " ; case BLIP_JPEG : return " jpeg " ; case BLIP_DIB : return " dib " ; default : return " " ; } }
public AsyncResponsePostRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " AsyncResponsePost " ) ; setMethod ( MethodType . POST ) ; }
public static final RevFilter between ( long since , long until ) { return new Between ( since , until ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { double val ; double d1 ; try { val = singleOperandEvaluate ( arg0 , srcRowIndex , srcColumnIndex ) ; d1 = singleOperandEvaluate ( arg1 , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } int nPlaces = ( int ) d1 ; if ( nPlaces > 127 ) { return ErrorEval . VALUE_INVALID ; } return new NumberEval ( val ) ; }
public Iterator < T > iterator ( ) { return new MyIterator ( ) ; }
public void reset ( int [ ] docs , long [ ] offsets ) { this . docs = docs ; this . offsets = offsets ; }
public ObjectId getObjectId ( ) { return object ; }
public String toString ( ) { return " fileName = " + fileName + " ▁ size = " + size ; }
public boolean isSubTotal ( int rowIndex , int columnIndex ) { SheetRefEvaluator _sre = _evaluator . getSheetEvaluator ( _evaluator . getFirstSheetIndex ( ) ) ; return _sre . isSubTotal ( getFirstRow ( ) + rowIndex , getFirstColumn ( ) + columnIndex ) ; }
public DeleteCollectionResult deleteCollection ( DeleteCollectionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCollection ( request ) ; }
public void write ( byte [ ] b ) { writeContinueIfRequired ( b . length ) ; _ulrOutput . write ( b ) ; }
public Drawable getIndeterminateDrawable ( ) { return mIndeterminateDrawable ; }
public void write ( byte [ ] b , int offset , int len ) { checkPosition ( len ) ; System . arraycopy ( b , offset , _buf , _writeIndex , len ) ; _writeIndex += len ; }
public ListWebsiteCertificateAuthoritiesResult listWebsiteCertificateAuthorities ( ListWebsiteCertificateAuthoritiesRequest request ) { request = beforeClientExecution ( request ) ; return executeListWebsiteCertificateAuthorities ( request ) ; }
public RevWalk ( ObjectReader or , int depth ) { super ( or ) ; this . depth = depth ; this . deepenNots = Collections . emptyList ( ) ; this . UNSHALLOW = newFlag ( " UNSHALLOW " ) ; this . REINTERESTING = newFlag ( " REINTERESTING " ) ; this . DEEPEN_NOT = newFlag ( " DEEPEN □ NOT " ) ; }
public DeleteLogStreamRequest ( String logGroupName , String logStreamName ) { setLogGroupName ( logGroupName ) ; setLogStreamName ( logStreamName ) ; }
public PrintWriter append ( CharSequence csq ) { if ( csq == null ) { csq = " null " ; } append ( csq , 0 , csq . length ( ) ) ; return this ; }
public boolean include ( TreeWalk walker ) throws MissingObjectException , IncorrectObjectTypeException , IOException { count ++ ; if ( count % stepSize == 0 ) { if ( count <= total ) monitor . update ( stepSize ) ; if ( monitor . isCancelled ( ) ) throw StopWalkException . INSTANCE ; } return true ; }
public RevObject getObjectId ( ) { return id ; }
public void setFlushOnEnd ( boolean flushOnEnd ) { this . flushOnEnd = flushOnEnd ; }
public ListAutoMLJobsResult listAutoMLJobs ( ListAutoMLJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAutoMLJobs ( request ) ; }
public void addBuilder ( String nodeName , SpanQueryBuilder builder ) { builders . put ( nodeName , builder ) ; }
public DescribeReplicationGroupsResult describeReplicationGroups ( ) { return describeReplicationGroups ( new DescribeReplicationGroupsRequest ( ) ) ; }
public void removeAllCellsValuesForRow ( int rowIndex ) { if ( rowIndex < 0 || rowIndex > MAX_ROW_INDEX ) { throw new IllegalArgumentException ( " Specified ▁ rowIndex ▁ " + rowIndex + " ▁ is ▁ outside ▁ the ▁ allowable ▁ range ▁ ( 0.. " + MAX_ROW_INDEX + " ) " ) ; } if ( rowIndex >= records . length ) { return ; } records [ rowIndex ] = null ; }
public DeleteProxySessionResult deleteProxySession ( DeleteProxySessionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteProxySession ( request ) ; }
public DescribePoliciesResult describePolicies ( ) { return describePolicies ( new DescribePoliciesRequest ( ) ) ; }
public NumberFormatIndexRecord ( RecordInputStream in ) { field_1_formatIndex = in . readShort ( ) ; }
public CreatePrivateVirtualInterfaceResult createPrivateVirtualInterface ( CreatePrivateVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePrivateVirtualInterface ( request ) ; }
@ Override public E get ( int location ) { return list . get ( location ) ; }
public String getPath ( ) { return decode ( path ) ; }
public static String longToHex ( long value ) { StringBuilder sb = new StringBuilder ( 18 ) ; writeHex ( sb , value , 16 , " 0x " ) ; return sb . toString ( ) ; }
public RevFilter clone ( ) { return new Binary ( a . clone ( ) , b . clone ( ) ) ; }
public int compareTo ( Toffs other ) { int diff = getStartOffset ( ) - other . getStartOffset ( ) ; if ( diff != 0 ) { return diff ; } return getEndOffset ( ) - other . getEndOffset ( ) ; }
public UpdateNetworkProfileResult updateNetworkProfile ( UpdateNetworkProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateNetworkProfile ( request ) ; }
public GetRelationalDatabaseParametersResult getRelationalDatabaseParameters ( GetRelationalDatabaseParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabaseParameters ( request ) ; }
public boolean contains ( Object object ) { return indexOf ( object , 0 ) != - 1 ; }
public boolean remove ( Object object ) { return removeFirstOccurrenceImpl ( object ) ; }
public DConRefRecord ( RecordInputStream inStream ) { if ( inStream . getSid ( ) != sid ) { throw new RecordFormatException ( " Wrong ▁ sid : ▁ " + inStream . getSid ( ) ) ; } firstRow = inStream . readUShort ( ) ; lastRow = inStream . readUShort ( ) ; firstCol = inStream . readUByte ( ) ; lastCol = inStream . readUByte ( ) ; charCount = inStream . readUShort ( ) ; charType = inStream . readUByte ( ) & 0x01 ; final int byteLength = charCount * ( charType + 1 ) ; path = IOUtils . safelyAllocate ( byteLength , MAX_RECORD_LENGTH ) ; inStream . readFully ( path ) ; if ( path [ 0 ] == 0x02 ) { _unused = inStream . readRemainder ( ) ; } }
public int getSheetIndex ( EvaluationSheet evalSheet ) { HSSFSheet sheet = ( ( HSSFEvaluationSheet ) evalSheet ) . getHSSFSheet ( ) ; return _uBook . getSheetIndex ( sheet ) ; }
public synchronized int codePointAt ( int index ) { return super . codePointAt ( index ) ; }
public DeleteRepoBuildRuleRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " DeleteRepoBuildRule " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / rules / [ BuildRuleId ] " ) ; setMethod ( MethodType . DELETE ) ; }
public UpdateEmailChannelResult updateEmailChannel ( UpdateEmailChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateEmailChannel ( request ) ; }
public TabIdRecord ( RecordInputStream in ) { int nTabs = in . remaining ( ) / 2 ; _tabids = new short [ nTabs ] ; for ( int i = 0 ; i < _tabids . length ; i ++ ) { _tabids [ i ] = in . readShort ( ) ; } }
public String toFormulaString ( ) { return " , " ; }
public CreateConnectionResult createConnection ( CreateConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateConnection ( request ) ; }
public int calculateWorkdays ( double start , double end , double [ ] holidays ) { int saturdaysPast = this . pastDaysOfWeek ( start , end , Calendar . SATURDAY ) ; int sundaysPast = this . pastDaysOfWeek ( start , end , Calendar . SUNDAY ) ; int nonWeekendHolidays = this . calculateNonWeekendHolidays ( start , end , holidays ) ; return ( int ) ( end - start + 1 ) - saturdaysPast - sundaysPast - nonWeekendHolidays ; }
public IndexFormatTooNewException ( String resourceDescription , int version , int minVersion , int maxVersion ) { super ( " Format ▁ version ▁ is ▁ not ▁ supported ▁ ( resource ▁ " + resourceDescription + " ) : ▁ " + version + " ▁ ( needs ▁ to ▁ be ▁ between ▁ " + minVersion + " ▁ and ▁ " + maxVersion + " ) " ) ; this . resourceDescription = resourceDescription ; this . version = version ; this . minVersion = minVersion ; this . maxVersion = maxVersion ; }
public void apply ( DirCacheEntry ent ) { throw new UnsupportedOperationException ( JGitText . get ( ) . noApplyInDelete ) ; }
public boolean isNewFragment ( ) { position += posIncAtt . getPositionIncrement ( ) ; if ( waitForPos <= position ) { waitForPos = - 1 ; } else if ( waitForPos != - 1 ) { return false ; } WeightedSpanTerm wSpanTerm = queryScorer . getWeightedSpanTerm ( termAtt . toString ( ) ) ; if ( wSpanTerm != null ) { List < PositionSpan > positionSpans = wSpanTerm . getPositionSpans ( ) ; for ( PositionSpan positionSpan : positionSpans ) { if ( positionSpan . start == position ) { waitForPos = positionSpan . end + 1 ; break ; } } } boolean isNewFrag = offsetAtt . endOffset ( ) >= ( fragmentSize * currentNumFrags ) && ( textSize - offsetAtt . endOffset ( ) ) >= ( fragmentSize >>> 1 ) ; if ( isNewFrag ) { currentNumFrags ++ ; } return isNewFrag ; }
public StopMatchmakingResult stopMatchmaking ( StopMatchmakingRequest request ) { request = beforeClientExecution ( request ) ; return executeStopMatchmaking ( request ) ; }
public DescribeClientVpnTargetNetworksResult describeClientVpnTargetNetworks ( DescribeClientVpnTargetNetworksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClientVpnTargetNetworks ( request ) ; }
public FloatBuffer put ( FloatBuffer buf ) { throw new ReadOnlyBufferException ( ) ; }
public final IntBuffer asIntBuffer ( ) { return IntToByteBufferAdapter . asIntBuffer ( this ) ; }
public RemovePermissionResult removePermission ( String queueUrl , String label ) { return removePermission ( new RemovePermissionRequest ( ) . withQueueUrl ( queueUrl ) . withLabel ( label ) ) ; }
public void inform ( ResourceLoader loader ) { if ( encoderClass . equals ( " float " ) ) { encoder = new FloatEncoder ( ) ; } else if ( encoderClass . equals ( " integer " ) ) { encoder = new IntegerEncoder ( ) ; } else if ( encoderClass . equals ( " identity " ) ) { encoder = new IdentityEncoder ( ) ; } else { encoder = loader . newInstance ( encoderClass , PayloadEncoder . class ) ; } }
public GetHealthCheckResult getHealthCheck ( GetHealthCheckRequest request ) { request = beforeClientExecution ( request ) ; return executeGetHealthCheck ( request ) ; }
public ListNotebookInstanceLifecycleConfigsResult listNotebookInstanceLifecycleConfigs ( ListNotebookInstanceLifecycleConfigsRequest request ) { request = beforeClientExecution ( request ) ; return executeListNotebookInstanceLifecycleConfigs ( request ) ; }
public int next ( int n ) { if ( n < 0 ) { for ( int i = 0 ; i < - n ; i ++ ) { previous ( ) ; } } else { for ( int i = 0 ; i < n ; i ++ ) { next ( ) ; } } return current ( ) ; }
public static long calculateMaximumSize ( final HeaderBlock header ) { return calculateMaximumSize ( header . getBigBlockSize ( ) , header . getBATCount ( ) ) ; }
public String toString ( ) { return " character = " + _character + " , fontIndex = " + _fontIndex ; }
public static float [ ] grow ( float [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { float [ ] copy = new float [ oversize ( minSize , Float . BYTES ) ] ; System . arraycopy ( array , 0 , copy , 0 , array . length ) ; return copy ; } else return array ; }
public String getDataFormatString ( ) { if ( getDataFormatStringCache . get ( ) != null ) { if ( lastDateFormat . get ( ) == getDataFormat ( ) && _workbook . getFormats ( ) . equals ( lastFormats . get ( ) ) ) { return getDataFormatStringCache . get ( ) ; } } lastFormats . set ( _workbook . getFormats ( ) ) ; lastDateFormat . set ( getDataFormat ( ) ) ; getDataFormatStringCache . set ( getDataFormatString ( _workbook ) ) ; return getDataFormatStringCache . get ( ) ; }
public UpdateSignalingChannelResult updateSignalingChannel ( UpdateSignalingChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateSignalingChannel ( request ) ; }
public MoPenSendMqttMessageRequest ( ) { super ( " MoPen " , " 2018 - 02 - 11 " , " MoPenSendMqttMessage " , " mopen " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public TreeSet ( SortedSet < E > set ) { this ( set . comparator ( ) ) ; Iterator < E > it = set . iterator ( ) ; while ( it . hasNext ( ) ) { add ( it . next ( ) ) ; } }
public DisassociateMembersResult disassociateMembers ( DisassociateMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateMembers ( request ) ; }
public DeleteVpcLinkResult deleteVpcLink ( DeleteVpcLinkRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVpcLink ( request ) ; }
public DescribeDBSnapshotsResult describeDBSnapshots ( ) { return describeDBSnapshots ( new DescribeDBSnapshotsRequest ( ) ) ; }
public void clear ( ) { if ( _evaluationListener != null ) { _evaluationListener . onClearWholeCache ( ) ; } _plainCellCache . clear ( ) ; _formulaCellCache . clear ( ) ; }
public void setDiffAlgorithm ( DiffAlgorithm alg ) { diffAlgorithm = alg ; }
public DVALRecord ( RecordInputStream in ) { field_1_options = in . readShort ( ) ; field_2_horiz_pos = in . readInt ( ) ; field_3_vert_pos = in . readInt ( ) ; field_cbo_id = in . readInt ( ) ; field_5_dv_no = in . readInt ( ) ; }
public IndexInput clone ( ) { throw new UnsupportedOperationException ( ) ; }
public Appendable append ( CharSequence csq , int start , int end ) { reserve ( end - start ) ; for ( int i = start ; i < end ; i ++ ) { unsafeWrite ( csq . charAt ( i ) ) ; } return this ; }
public DescribeJobFlowsResult describeJobFlows ( DescribeJobFlowsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeJobFlows ( request ) ; }
public LowerCaseFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public int compareTo ( Revision o ) { IndexRevision other = ( IndexRevision ) o ; return commit . compareTo ( other . commit ) ; }
public DisassociateResolverRuleResult disassociateResolverRule ( DisassociateResolverRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateResolverRule ( request ) ; }
public static boolean isUnicodeString ( final String value ) { return ! value . equals ( new String ( value . getBytes ( ISO_8859_1 ) , ISO_8859_1 ) ) ; }
public DeleteApplicationCloudWatchLoggingOptionResult deleteApplicationCloudWatchLoggingOption ( DeleteApplicationCloudWatchLoggingOptionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApplicationCloudWatchLoggingOption ( request ) ; }
public FreqProxPostingsArray ( int size , boolean writeFreqs , boolean writeProx , boolean writeOffsets ) { super ( size ) ; if ( writeFreqs ) { termFreqs = new int [ size ] ; } lastDocIDs = new int [ size ] ; lastDocCodes = new int [ size ] ; if ( writeProx ) { lastPositions = new int [ size ] ; if ( writeOffsets ) { lastOffsets = new int [ size ] ; } } else { assert ! writeOffsets ; } }
public List < String > matchPrefix ( String prefix ) { return matchPrefix ( prefix , defaultNumReturnValues ) ; }
public DescribeScalingPoliciesResult describeScalingPolicies ( DescribeScalingPoliciesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeScalingPolicies ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( field_1_row_offset ) ; for ( short field_2_cell_offset : field_2_cell_offsets ) { out . writeShort ( field_2_cell_offset ) ; } }
public UserSViewBegin ( RecordInputStream in ) { _rawData = in . readRemainder ( ) ; }
public static RevFilter create ( String pattern ) { if ( pattern . length ( ) == 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . cannotMatchOnEmptyString ) ; if ( SubStringRevFilter . safe ( pattern ) ) return new SubStringSearch ( pattern ) ; return new PatternSearch ( pattern ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getFontHeight ( ) ) ; out . writeShort ( getAttributes ( ) ) ; out . writeShort ( getColorPaletteIndex ( ) ) ; out . writeShort ( getBoldWeight ( ) ) ; out . writeShort ( getSuperSubScript ( ) ) ; out . writeByte ( getUnderline ( ) ) ; out . writeByte ( getFamily ( ) ) ; out . writeByte ( getCharset ( ) ) ; out . writeByte ( field_9_zero ) ; int fontNameLen = field_11_font_name . length ( ) ; out . writeByte ( fontNameLen ) ; boolean hasMultibyte = StringUtil . hasMultibyte ( field_11_font_name ) ; out . writeByte ( hasMultibyte ? 0x01 : 0x00 ) ; if ( fontNameLen > 0 ) { if ( hasMultibyte ) { StringUtil . putUnicodeLE ( field_11_font_name , out ) ; } else { StringUtil . putCompressedUnicode ( field_11_font_name , out ) ; } } }
public DescribeLaunchConfigurationsResult describeLaunchConfigurations ( DescribeLaunchConfigurationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLaunchConfigurations ( request ) ; }
public PathEdit ( DirCacheEntry ent ) { path = ent . path ; }
public static int toCodePoints ( char [ ] src , int srcOff , int srcLen , int [ ] dest , int destOff ) { if ( srcLen < 0 ) { throw new IllegalArgumentException ( " srcLen ▁ must ▁ be ▁ >= ▁ 0 " ) ; } int codePointCount = 0 ; for ( int i = 0 ; i < srcLen ; ) { final int cp = Character . codePointAt ( src , srcOff + i , srcOff + srcLen ) ; final int charCount = Character . charCount ( cp ) ; dest [ destOff + codePointCount ++ ] = cp ; i += charCount ; } return codePointCount ; }
public boolean hasNext ( ) { return remaining != 0 ; }
public void consume ( ) { if ( LA ( 1 ) == IntStream . EOF ) { throw new IllegalStateException ( " cannot ▁ consume ▁ EOF " ) ; } lastChar = data [ p ] ; if ( p == n - 1 && numMarkers == 0 ) { n = 0 ; p = - 1 ; lastCharBufferStart = lastChar ; } p ++ ; currentCharIndex ++ ; sync ( 1 ) ; }
public FileOutputStream ( String path ) throws FileNotFoundException { this ( path , false ) ; }
public FieldConfig ( String fieldName ) { if ( fieldName == null ) { throw new IllegalArgumentException ( " field ▁ name ▁ must ▁ not ▁ be ▁ null ! " ) ; } this . fieldName = fieldName ; }
public TokenFilter create ( TokenStream input ) { return new NGramTokenFilter ( input , minGramSize , maxGramSize , preserveOriginal ) ; }
public DescribeCacheParameterGroupsResult describeCacheParameterGroups ( DescribeCacheParameterGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCacheParameterGroups ( request ) ; }
public ApostropheFilter ( TokenStream in ) { super ( in ) ; }
public void writeShort ( int v ) { writeContinueIfRequired ( 2 ) ; _ulrOutput . writeShort ( v ) ; }
public StringBuilder append ( Object obj ) { if ( obj == null ) { appendNull ( ) ; } else { append0 ( obj . toString ( ) ) ; } return this ; }
public ListGatewayGroupsResult listGatewayGroups ( ListGatewayGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListGatewayGroups ( request ) ; }
public AlibabaCloudCredentials getCredentials ( ) throws ClientException { if ( credentials == null || credentials . isExpired ( ) ) { ecsMetadataServiceFetchCount += 1 ; int maxRetryTimes = MAX_ECS_METADATA_FETCH_RETRY_TIMES ; credentials = fetcher . fetch ( maxRetryTimes ) ; } else if ( credentials . willSoonExpire ( ) && credentials . shouldRefresh ( ) ) { try { ecsMetadataServiceFetchCount += 1 ; credentials = fetcher . fetch ( ) ; } catch ( ClientException e ) { credentials . setLastFailedRefreshTime ( ) ; } } return credentials ; }
public DescribeVpnConnectionsResult describeVpnConnections ( DescribeVpnConnectionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpnConnections ( request ) ; }
public ByteBuffer put ( byte [ ] src , int srcOffset , int byteCount ) { checkPutBounds ( 1 , src . length , srcOffset , byteCount ) ; System . arraycopy ( src , srcOffset , backingArray , offset + position , byteCount ) ; position += byteCount ; return this ; }
public ListDistributionsResult listDistributions ( ListDistributionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDistributions ( request ) ; }
public String getName ( ) { if ( params == null ) { return name ; } return new StringBuilder ( name ) . append ( ' ( ' ) . append ( params ) . append ( ' ) ' ) . toString ( ) ; }
public DescribeTasksResult describeTasks ( DescribeTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTasks ( request ) ; }
public DescribeCacheSubnetGroupsResult describeCacheSubnetGroups ( ) { return describeCacheSubnetGroups ( new DescribeCacheSubnetGroupsRequest ( ) ) ; }
public float get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return byteBuffer . getFloat ( position ++ * SizeOf . FLOAT ) ; }
public ShowNoteCommand setNotesRef ( String notesRef ) { checkCallable ( ) ; this . notesRef = notesRef ; return this ; }
public UpdateAuthorizerResult updateAuthorizer ( UpdateAuthorizerRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateAuthorizer ( request ) ; }
public int ordVal ( int doc ) throws IOException { throw new UnsupportedOperationException ( ) ; }
public UnknownRecord ( RecordInputStream in ) { _sid = in . getSid ( ) ; _rawData = in . readRemainder ( ) ; }
public Matcher reset ( ) { return reset ( input , 0 , input . length ( ) ) ; }
public UpdateApnsVoipSandboxChannelResult updateApnsVoipSandboxChannel ( UpdateApnsVoipSandboxChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateApnsVoipSandboxChannel ( request ) ; }
public IntervalSet nextTokens ( ATNState s , RuleContext ctx ) { LL1Analyzer anal = new LL1Analyzer ( this ) ; IntervalSet next = anal . LOOK ( s , ctx ) ; return next ; }
public ListTablesResult listTables ( String exclusiveStartTableName , Integer limit ) { return listTables ( new ListTablesRequest ( ) . withExclusiveStartTableName ( exclusiveStartTableName ) . withLimit ( limit ) ) ; }
public DescribeIdentityResult describeIdentity ( DescribeIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIdentity ( request ) ; }
final public ArrayList < String > OptionalFields ( ) throws ParseException { Token fieldName ; ArrayList < String > fieldNames = null ; label_1 : while ( true ) { if ( jj_2_1 ( 2 ) ) { ; } else { break label_1 ; } fieldName = jj_consume_token ( TERM ) ; jj_consume_token ( COLON ) ; if ( fieldNames == null ) { fieldNames = new ArrayList < String > ( ) ; } fieldNames . add ( fieldName . image ) ; } { if ( true ) return fieldNames ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public SubmoduleAddCommand submoduleAdd ( ) { return new SubmoduleAddCommand ( repo ) ; }
public DescribeTypeResult describeType ( DescribeTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeType ( request ) ; }
public UpdateCompanyNetworkConfigurationResult updateCompanyNetworkConfiguration ( UpdateCompanyNetworkConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateCompanyNetworkConfiguration ( request ) ; }
public final String get ( String name ) { for ( IndexableField field : fields ) { if ( field . name ( ) . equals ( name ) && field . stringValue ( ) != null ) { return field . stringValue ( ) ; } } return null ; }
public boolean equalsSameType ( Object other ) { assert exists || 0 == value . length ( ) ; MutableValueStr b = ( MutableValueStr ) other ; return value . get ( ) . equals ( b . value . get ( ) ) && exists == b . exists ; }
public void read ( RecordStream rs ) { while ( rs . peekNextClass ( ) == MergeCellsRecord . class ) { MergeCellsRecord mcr = ( MergeCellsRecord ) rs . getNext ( ) ; int nRegions = mcr . getNumAreas ( ) ; for ( int i = 0 ; i < nRegions ; i ++ ) { CellRangeAddress cra = mcr . getAreaAt ( i ) ; _mergedRegions . add ( cra ) ; } } }
public int available ( ) throws IOException { return in . available ( ) / 2 + ( lastChar == - 1 ? 0 : 1 ) ; }
public Status getStatus ( ) { return status ; }
public CharSequence [ ] decompose ( CharSequence cmd ) { int parts = 0 ; for ( int i = 0 ; 0 <= i && i < cmd . length ( ) ; ) { int next = dashEven ( cmd , i ) ; if ( i == next ) { parts ++ ; i = next + 2 ; } else { parts ++ ; i = next ; } } CharSequence part [ ] = new CharSequence [ parts ] ; int x = 0 ; for ( int i = 0 ; 0 <= i && i < cmd . length ( ) ; ) { int next = dashEven ( cmd , i ) ; if ( i == next ) { part [ x ++ ] = cmd . subSequence ( i , i + 2 ) ; i = next + 2 ; } else { part [ x ++ ] = ( next < 0 ) ? cmd . subSequence ( i , cmd . length ( ) ) : cmd . subSequence ( i , next ) ; i = next ; } } return part ; }
public RevokeSecurityGroupIngressRequest ( String groupName , java . util . List < IpPermission > ipPermissions ) { setGroupName ( groupName ) ; setIpPermissions ( ipPermissions ) ; }
public Ref remove ( Object key ) { String name = toRefName ( ( String ) key ) ; Ref res = null ; int idx ; if ( 0 <= ( idx = packed . find ( name ) ) ) { res = packed . get ( name ) ; packed = packed . remove ( idx ) ; sizeIsValid = false ; } if ( 0 <= ( idx = loose . find ( name ) ) ) { res = loose . get ( name ) ; loose = loose . remove ( idx ) ; sizeIsValid = false ; } if ( 0 <= ( idx = resolved . find ( name ) ) ) { res = resolved . get ( name ) ; resolved = resolved . remove ( idx ) ; sizeIsValid = false ; } return res ; }
public DescribeMLModelsResult describeMLModels ( DescribeMLModelsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeMLModels ( request ) ; }
public String getInflectionType ( int wordId ) { return null ; }
public CreateVolumeRequest ( String snapshotId , String availabilityZone ) { setSnapshotId ( snapshotId ) ; setAvailabilityZone ( availabilityZone ) ; }
public DataValidationConstraint createDateConstraint ( int operatorType , String formula1 , String formula2 , String dateFormat ) { return DVConstraint . createDateConstraint ( operatorType , formula1 , formula2 , dateFormat ) ; }
public CloneReceiptRuleSetResult cloneReceiptRuleSet ( CloneReceiptRuleSetRequest request ) { request = beforeClientExecution ( request ) ; return executeCloneReceiptRuleSet ( request ) ; }
public int getOffsetGap ( String fieldName ) { return 1 ; }
public long hash1 ( char c ) { final long p = 1099511628211L ; long hash = 0xcbf29ce484222325L ; hash = ( hash ^ ( c & 0x00FF ) ) * p ; hash = ( hash ^ ( c >> 8 ) ) * p ; hash += hash << 13 ; hash ^= hash >> 7 ; hash += hash << 3 ; hash ^= hash >> 17 ; hash += hash << 5 ; return hash ; }
public final ByteBuffer order ( ByteOrder byteOrder ) { orderImpl ( byteOrder ) ; return this ; }
public DescribeAlarmsForMetricResult describeAlarmsForMetric ( DescribeAlarmsForMetricRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAlarmsForMetric ( request ) ; }
public void terminateWorkflowExecution ( TerminateWorkflowExecutionRequest request ) { request = beforeClientExecution ( request ) ; executeTerminateWorkflowExecution ( request ) ; }
public DistanceValueSource ( PointVectorStrategy strategy , Point from , double multiplier ) { this . strategy = strategy ; this . from = from ; this . multiplier = multiplier ; this . nullValue = 180 * multiplier ; }
public RenameBranchCommand branchRename ( ) { return new RenameBranchCommand ( repo ) ; }
public IntBuffer get ( int [ ] dst , int dstOffset , int intCount ) { byteBuffer . limit ( limit * SizeOf . INT ) ; byteBuffer . position ( position * SizeOf . INT ) ; if ( byteBuffer instanceof DirectByteBuffer ) { ( ( DirectByteBuffer ) byteBuffer ) . get ( dst , dstOffset , intCount ) ; } else { ( ( HeapByteBuffer ) byteBuffer ) . get ( dst , dstOffset , intCount ) ; } this . position += intCount ; return this ; }
public DescribeInstanceEventNotificationAttributesResult describeInstanceEventNotificationAttributes ( DescribeInstanceEventNotificationAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInstanceEventNotificationAttributes ( request ) ; }
public void appendUserAgent ( String key , String value ) { this . userAgentConfig . append ( key , value ) ; }
public String getErrorDisplay ( int c ) { String s = String . valueOf ( ( char ) c ) ; switch ( c ) { case Token . EOF : s = " < EOF > " ; break ; case ' \ n ' : s = " \\ n " ; break ; case ' \ t ' : s = " \\ t " ; break ; case ' \ r ' : s = " \\ r " ; break ; } return s ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ CHARTFORMAT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . xPosition ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getXPosition ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . yPosition ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getYPosition ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . width ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getWidth ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . height ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getHeight ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grBit ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . intToHex ( field5_grbit ) ) . append ( " \ n " ) ; buffer . append ( " [ / CHARTFORMAT ] \ n " ) ; return buffer . toString ( ) ; }
public GetQuotaRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetQuota " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DeleteEventStreamResult deleteEventStream ( DeleteEventStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEventStream ( request ) ; }
public GetPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public int getBegin ( ) { return begin ; }
public void decRef ( ) throws IOException { if ( refCount . get ( ) <= 0 ) { throw new IllegalStateException ( " this ▁ revision ▁ is ▁ already ▁ released " ) ; } final int rc = refCount . decrementAndGet ( ) ; if ( rc == 0 ) { boolean success = false ; try { revision . release ( ) ; success = true ; } finally { if ( ! success ) { refCount . incrementAndGet ( ) ; } } } else if ( rc < 0 ) { throw new IllegalStateException ( " too ▁ many ▁ decRef ▁ calls : ▁ refCount ▁ is ▁ " + rc + " ▁ after ▁ decrement " ) ; } }
public DescribeDataSetPermissionsResult describeDataSetPermissions ( DescribeDataSetPermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDataSetPermissions ( request ) ; }
public SaveTaskForUpdatingRegistrantInfoByIdentityCredentialRequest ( ) { super ( " Domain " , " 2018 - 01 - 29 " , " SaveTaskForUpdatingRegistrantInfoByIdentityCredential " ) ; setMethod ( MethodType . POST ) ; }
public TokenStreamToAutomaton ( ) { this . preservePositionIncrements = true ; }
public NameXPtg addNameXPtg ( String name ) { int extBlockIndex = - 1 ; ExternalBookBlock extBlock = null ; for ( int i = 0 ; i < _externalBookBlocks . length ; i ++ ) { SupBookRecord ebr = _externalBookBlocks [ i ] . getExternalBookRecord ( ) ; if ( ebr . isAddInFunctions ( ) ) { extBlock = _externalBookBlocks [ i ] ; extBlockIndex = i ; break ; } } if ( extBlock == null ) { extBlock = new ExternalBookBlock ( ) ; extBlockIndex = extendExternalBookBlocks ( extBlock ) ; int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; _workbookRecordList . add ( idx , extBlock . getExternalBookRecord ( ) ) ; _externSheetRecord . addRef ( _externalBookBlocks . length - 1 , - 2 , - 2 ) ; } ExternalNameRecord extNameRecord = new ExternalNameRecord ( ) ; extNameRecord . setText ( name ) ; extNameRecord . setParsedExpression ( new Ptg [ ] { ErrPtg . REF_INVALID } ) ; int nameIndex = extBlock . addExternalName ( extNameRecord ) ; int supLinkIndex = 0 ; for ( org . apache . poi . hssf . record . Record record : _workbookRecordList . getRecords ( ) ) { if ( record instanceof SupBookRecord && ( ( SupBookRecord ) record ) . isAddInFunctions ( ) ) { break ; } supLinkIndex ++ ; } int numberOfNames = extBlock . getNumberOfNames ( ) ; _workbookRecordList . add ( supLinkIndex + numberOfNames , extNameRecord ) ; int fakeSheetIdx = - 2 ; int ix = _externSheetRecord . getRefIxForSheet ( extBlockIndex , fakeSheetIdx , fakeSheetIdx ) ; return new NameXPtg ( ix , nameIndex ) ; }
public static IndexReaderContext getTopLevelContext ( IndexReaderContext context ) { while ( context . parent != null ) { context = context . parent ; } return context ; }
public final CharBuffer put ( CharBuffer src ) { throw new ReadOnlyBufferException ( ) ; }
public DeleteLabelsResult deleteLabels ( DeleteLabelsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLabels ( request ) ; }
public ListAlgorithmsResult listAlgorithms ( ListAlgorithmsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAlgorithms ( request ) ; }
public DiffCommand setShowNameAndStatusOnly ( boolean showNameAndStatusOnly ) { this . showNameAndStatusOnly = showNameAndStatusOnly ; return this ; }
public boolean isForceUpdate ( ) { return force ; }
public DeleteVpcEndpointServiceConfigurationsResult deleteVpcEndpointServiceConfigurations ( DeleteVpcEndpointServiceConfigurationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVpcEndpointServiceConfigurations ( request ) ; }
public Field ( String name , TokenStream tokenStream , IndexableFieldType type ) { if ( name == null ) { throw new IllegalArgumentException ( " name ▁ must ▁ not ▁ be ▁ null " ) ; } if ( tokenStream == null ) { throw new NullPointerException ( " tokenStream ▁ must ▁ not ▁ be ▁ null " ) ; } if ( type . indexOptions ( ) == IndexOptions . NONE || ! type . tokenized ( ) ) { throw new IllegalArgumentException ( " TokenStream ▁ fields ▁ must ▁ be ▁ indexed ▁ and ▁ tokenized " ) ; } if ( type . stored ( ) ) { throw new IllegalArgumentException ( " TokenStream ▁ fields ▁ cannot ▁ be ▁ stored " ) ; } this . name = name ; this . fieldsData = null ; this . tokenStream = tokenStream ; this . type = type ; }
public ListDeadLetterSourceQueuesResult listDeadLetterSourceQueues ( ListDeadLetterSourceQueuesRequest request ) { request = beforeClientExecution ( request ) ; return executeListDeadLetterSourceQueues ( request ) ; }
public BinaryDocValuesField ( String name , BytesRef value ) { super ( name , TYPE ) ; fieldsData = value ; }
public CreateVpnConnectionRequest ( String type , String customerGatewayId , String vpnGatewayId ) { setType ( type ) ; setCustomerGatewayId ( customerGatewayId ) ; setVpnGatewayId ( vpnGatewayId ) ; }
public OpenInstancePublicPortsResult openInstancePublicPorts ( OpenInstancePublicPortsRequest request ) { request = beforeClientExecution ( request ) ; return executeOpenInstancePublicPorts ( request ) ; }
public Builder ( ) { this . similarity = new BM25Similarity ( ) ; }
public InputIteratorWrapper ( BytesRefIterator wrapped ) { this . wrapped = wrapped ; }
public CreateUserProfileResult createUserProfile ( CreateUserProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateUserProfile ( request ) ; }
public ImportWorkspaceImageResult importWorkspaceImage ( ImportWorkspaceImageRequest request ) { request = beforeClientExecution ( request ) ; return executeImportWorkspaceImage ( request ) ; }
public void finish ( ) { mState = STATE_IDLE ; }
public DescribeFleetHistoryResult describeFleetHistory ( DescribeFleetHistoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFleetHistory ( request ) ; }
public ListGatewaysResult listGateways ( ListGatewaysRequest request ) { request = beforeClientExecution ( request ) ; return executeListGateways ( request ) ; }
public CreateTrafficMirrorFilterResult createTrafficMirrorFilter ( CreateTrafficMirrorFilterRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTrafficMirrorFilter ( request ) ; }
public BytesRef ( byte [ ] bytes , int offset , int length ) { this . bytes = bytes ; this . offset = offset ; this . length = length ; assert isValid ( ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( getSid ( ) ) ; }
public BufferedChecksum ( Checksum in , int bufferSize ) { this . in = in ; this . buffer = new byte [ bufferSize ] ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( ADD ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public TagCommand tag ( ) { return new TagCommand ( repo ) ; }
public DescribeClusterDbRevisionsResult describeClusterDbRevisions ( DescribeClusterDbRevisionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClusterDbRevisions ( request ) ; }
public StartImageScanResult startImageScan ( StartImageScanRequest request ) { request = beforeClientExecution ( request ) ; return executeStartImageScan ( request ) ; }
public final String toFormulaString ( ) { throw new RuntimeException ( " toFormulaString ( String [ ] ▁ operands ) ▁ should ▁ be ▁ used ▁ for ▁ subclasses ▁ of ▁ OperationPtgs " ) ; }
public DBInstance restoreDBInstanceToPointInTime ( RestoreDBInstanceToPointInTimeRequest request ) { request = beforeClientExecution ( request ) ; return executeRestoreDBInstanceToPointInTime ( request ) ; }
public boolean removeShape ( HSSFShape shape ) { boolean isRemoved = _mainSpgrContainer . removeChildRecord ( shape . getEscherContainer ( ) ) ; if ( isRemoved ) { shape . afterRemove ( this ) ; _shapes . remove ( shape ) ; } return isRemoved ; }
public static void fill ( boolean [ ] array , boolean value ) { for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = value ; } }
public DeleteAssessmentTemplateResult deleteAssessmentTemplate ( DeleteAssessmentTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAssessmentTemplate ( request ) ; }
public StartMonitoringScheduleResult startMonitoringSchedule ( StartMonitoringScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeStartMonitoringSchedule ( request ) ; }
public void println ( int i ) { println ( String . valueOf ( i ) ) ; }
public PutRoomSkillParameterResult putRoomSkillParameter ( PutRoomSkillParameterRequest request ) { request = beforeClientExecution ( request ) ; return executePutRoomSkillParameter ( request ) ; }
public DeleteDomainResult deleteDomain ( DeleteDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDomain ( request ) ; }
public ModifyLaunchTemplateResult modifyLaunchTemplate ( ModifyLaunchTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyLaunchTemplate ( request ) ; }
public final float overheadRatio ( int bitsPerValue ) { assert isSupported ( bitsPerValue ) ; return overheadPerValue ( bitsPerValue ) / bitsPerValue ; }
public ObjectId getIndexId ( ) { return indexId ; }
public String toString ( String field ) { return " like : " + likeText ; }
public long ramBytesUsed ( ) { long sizeInBytes = BASE_RAM_BYTES_USED ; sizeInBytes += ( docIDs != null ) ? RamUsageEstimator . sizeOf ( docIDs ) : 0 ; sizeInBytes += ( freqs != null ) ? RamUsageEstimator . sizeOf ( freqs ) : 0 ; if ( positions != null ) { sizeInBytes += RamUsageEstimator . shallowSizeOf ( positions ) ; for ( int [ ] position : positions ) { sizeInBytes += ( position != null ) ? RamUsageEstimator . sizeOf ( position ) : 0 ; } } if ( payloads != null ) { sizeInBytes += RamUsageEstimator . shallowSizeOf ( payloads ) ; for ( byte [ ] [ ] payload : payloads ) { if ( payload != null ) { sizeInBytes += RamUsageEstimator . shallowSizeOf ( payload ) ; for ( byte [ ] pload : payload ) { sizeInBytes += ( pload != null ) ? RamUsageEstimator . sizeOf ( pload ) : 0 ; } } } } return sizeInBytes ; }
public void setNeedBaseObjectIds ( boolean b ) { this . needBaseObjectIds = b ; }
public int getNextOrdinal ( ) { return this . counter ++ ; }
public FloatBuffer compact ( ) { throw new ReadOnlyBufferException ( ) ; }
public final int getLengthA ( ) { return endA - beginA ; }
public SearchDevicesResult searchDevices ( SearchDevicesRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchDevices ( request ) ; }
public String getInflectionForm ( ) { return dictionary . getInflectionForm ( wordId ) ; }
public RevFilter clone ( ) { return this ; }
public ReservedDBInstance purchaseReservedDBInstancesOffering ( PurchaseReservedDBInstancesOfferingRequest request ) { request = beforeClientExecution ( request ) ; return executePurchaseReservedDBInstancesOffering ( request ) ; }
public String getReason ( ) { return super . getMessage ( ) ; }
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 24 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } } } } for ( int i = 0 ; i < 24 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; }
public int [ ] toArray ( ) { int [ ] rval = new int [ _limit ] ; System . arraycopy ( _array , 0 , rval , 0 , _limit ) ; return rval ; }
public ValueEval evaluate ( ValueEval [ ] args , OperationEvaluationContext ec ) { if ( args . length == 1 ) { return evaluate ( ec . getRowIndex ( ) , ec . getColumnIndex ( ) , args [ 0 ] ) ; } if ( args . length == 2 ) { return evaluate ( ec . getRowIndex ( ) , ec . getColumnIndex ( ) , args [ 0 ] , args [ 1 ] ) ; } return ErrorEval . VALUE_INVALID ; }
public DescribeCustomerGatewaysResult describeCustomerGateways ( DescribeCustomerGatewaysRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCustomerGateways ( request ) ; }
public String toString ( ) { return utf8. utf8ToString ( ) + " / " + bucket ; }
public void clipRect ( int x , int y , int width , int height ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , " clipRect ▁ not ▁ supported " ) ; }
public void startFragment ( TextFragment newFragment ) { uniqueTermsInFragment = new HashSet <> ( ) ; currentTextFragment = newFragment ; totalScore = 0 ; }
public void setPolygonDrawArea ( int width , int height ) { setPropertyValue ( new EscherSimpleProperty ( EscherPropertyTypes . GEOMETRY__RIGHT , width ) ) ; setPropertyValue ( new EscherSimpleProperty ( EscherPropertyTypes . GEOMETRY__BOTTOM , height ) ) ; }
public DeleteRouteSettingsResult deleteRouteSettings ( DeleteRouteSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRouteSettings ( request ) ; }
public CherryPickCommand include ( String name , AnyObjectId commit ) { return include ( new ObjectIdRef . Unpeeled ( Storage . LOOSE , name , commit . copy ( ) ) ) ; }
public short getFormat ( String format , boolean createIfNotFound ) { for ( FormatRecord r : formats ) { if ( r . getFormatString ( ) . equals ( format ) ) { return ( short ) r . getIndexCode ( ) ; } } if ( createIfNotFound ) { return ( short ) createFormat ( format ) ; } return - 1 ; }
public SpanNearQuery build ( ) { return new SpanNearQuery ( clauses . toArray ( new SpanQuery [ clauses . size ( ) ] ) , slop , ordered ) ; }
public int getRowCellBlockSize ( int startRow , int endRow ) { int result = 0 ; for ( int rowIx = startRow ; rowIx <= endRow && rowIx < records . length ; rowIx ++ ) { result += getRowSerializedSize ( records [ rowIx ] ) ; } return result ; }
public final boolean incrementToken ( ) { if ( ! it . hasNext ( ) ) { return false ; } AttributeSource . State state = it . next ( ) ; restoreState ( state ) ; return true ; }
public DeleteTemplateResult deleteTemplate ( DeleteTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTemplate ( request ) ; }
public StartFaceSearchResult startFaceSearch ( StartFaceSearchRequest request ) { request = beforeClientExecution ( request ) ; return executeStartFaceSearch ( request ) ; }
public static int formatBase10 ( final byte [ ] b , int o , int value ) { if ( value == 0 ) { b [ -- o ] = ' 0 ' ; return o ; } final boolean isneg = value < 0 ; if ( isneg ) value = - value ; while ( value != 0 ) { b [ -- o ] = base10byte [ value % 10 ] ; value /= 10 ; } if ( isneg ) b [ -- o ] = ' - ' ; return o ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SINDEX ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . index ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getIndex ( ) ) ) . append ( " ▁ ( " ) . append ( getIndex ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " [ / SINDEX ] \ n " ) ; return buffer . toString ( ) ; }
public DescribeDBSecurityGroupsResult describeDBSecurityGroups ( DescribeDBSecurityGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBSecurityGroups ( request ) ; }
public DeleteTrafficMirrorSessionResult deleteTrafficMirrorSession ( DeleteTrafficMirrorSessionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTrafficMirrorSession ( request ) ; }
public void stopWalk ( ) { final int cur = ptr ; final int cnt = cache . getEntryCount ( ) ; if ( cur < cnt ) builder . keep ( cur , cnt - cur ) ; }
public ExpandedDouble normaliseBaseTwo ( ) { MutableFPNumber cc = new MutableFPNumber ( composeFrac ( ) , 39 ) ; cc . multiplyByPowerOfTen ( _relativeDecimalExponent ) ; cc . normalise64bit ( ) ; return cc . createExpandedDouble ( ) ; }
public PutLexiconResult putLexicon ( PutLexiconRequest request ) { request = beforeClientExecution ( request ) ; return executePutLexicon ( request ) ; }
public int [ ] init ( ) { if ( perField . postingsArray == null ) { perField . postingsArray = perField . createPostingsArray ( 2 ) ; perField . newPostingsArray ( ) ; bytesUsed . addAndGet ( perField . postingsArray . size * perField . postingsArray . bytesPerPosting ( ) ) ; } return perField . postingsArray . textStarts ; }
public DirCacheEntry getDirCacheEntry ( ) { return entry ; }
public boolean include ( TreeWalk walker ) { return matchFilter ( walker ) <= 0 ; }
public void open ( String closer ) { if ( closer == null ) { throw new NullPointerException ( " closer ▁ == ▁ null " ) ; } if ( this == NOOP || ! ENABLED ) { return ; } String message = " Explicit ▁ termination ▁ method ▁ ' " ▁ + ▁ closer ▁ + ▁ " ' ▁ not ▁ called " ; allocationSite = new Throwable ( message ) ; }
public List < ParseTreeMatch > findAll ( ParseTree tree , String xpath ) { Collection < ParseTree > subtrees = XPath . findAll ( tree , xpath , matcher . getParser ( ) ) ; List < ParseTreeMatch > matches = new ArrayList < ParseTreeMatch > ( ) ; for ( ParseTree t : subtrees ) { ParseTreeMatch match = match ( t ) ; if ( match . succeeded ( ) ) { matches . add ( match ) ; } } return matches ; }
public static boolean hasSLLConflictTerminatingPrediction ( PredictionMode mode , ATNConfigSet configs ) { if ( allConfigsInRuleStopStates ( configs ) ) { return true ; } if ( mode == PredictionMode . SLL ) { if ( configs . hasSemanticContext ) { ATNConfigSet dup = new ATNConfigSet ( ) ; for ( ATNConfig c : configs ) { c = new ATNConfig ( c , SemanticContext . NONE ) ; dup . add ( c ) ; } configs = dup ; } } Collection < BitSet > altsets = getConflictingAltSubsets ( configs ) ; boolean heuristic = hasConflictingAltSet ( altsets ) && ! hasStateAssociatedWithOneAlt ( configs ) ; return heuristic ; }
public DescribeUpdateActionsResult describeUpdateActions ( DescribeUpdateActionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeUpdateActions ( request ) ; }
public HashMap ( ) { table = ( HashMapEntry < K , V > [ ] ) EMPTY_TABLE ; threshold = - 1 ; }
public Trie optimize ( Trie orig ) { List < CharSequence > cmds = orig . cmds ; List < Row > rows = new ArrayList <> ( ) ; List < Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; Arrays . fill ( remap , - 1 ) ; rows = removeGaps ( orig . root , rows , new ArrayList < Row > ( ) , remap ) ; return new Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
public CreateLifecyclePolicyResult createLifecyclePolicy ( CreateLifecyclePolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLifecyclePolicy ( request ) ; }
public void writeLong ( long v ) { writeInt ( ( int ) ( v ) ) ; writeInt ( ( int ) ( v >> 32 ) ) ; }
public void set ( char [ ] arr , int end ) { this . buf = arr ; this . len = end ; }
public HMMChineseTokenizerFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ▁ field : " + fieldName + " ▁ ctx = " + ctx ; }
public ResendContactReachabilityEmailResult resendContactReachabilityEmail ( ResendContactReachabilityEmailRequest request ) { request = beforeClientExecution ( request ) ; return executeResendContactReachabilityEmail ( request ) ; }
public GetApiKeyResult getApiKey ( GetApiKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApiKey ( request ) ; }
public void advance ( ) { previousValue = value ; if ( value == 1 ) { value = minShingleSize ; } else if ( value == maxShingleSize ) { reset ( ) ; } else { ++ value ; } }
public int addConditionalFormatting ( CellRangeAddress [ ] regions , ConditionalFormattingRule rule1 ) { return addConditionalFormatting ( regions , ( HSSFConditionalFormattingRule ) rule1 ) ; }
public RebaseCommand setUpstream ( RevCommit upstream ) { this . upstreamCommit = upstream ; this . upstreamCommitName = upstream . name ( ) ; return this ; }
public GetDocumentTextDetectionResult getDocumentTextDetection ( GetDocumentTextDetectionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDocumentTextDetection ( request ) ; }
public CreateDBSecurityGroupRequest ( String dBSecurityGroupName , String dBSecurityGroupDescription ) { setDBSecurityGroupName ( dBSecurityGroupName ) ; setDBSecurityGroupDescription ( dBSecurityGroupDescription ) ; }
public Reader create ( Reader input ) { return new ICUNormalizer2CharFilter ( input , normalizer ) ; }
static public double pmt ( double r , int nper , double pv ) { return pmt ( r , nper , pv , 0 ) ; }
public void set ( String name , String value ) throws Exception { if ( valByRound . get ( name ) != null ) { throw new Exception ( " Cannot ▁ modify ▁ a ▁ multi ▁ value ▁ property ! " ) ; } props . setProperty ( name , value ) ; }
public DescribeFastSnapshotRestoresResult describeFastSnapshotRestores ( DescribeFastSnapshotRestoresRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFastSnapshotRestores ( request ) ; }
public DescribeScheduledInstanceAvailabilityResult describeScheduledInstanceAvailability ( DescribeScheduledInstanceAvailabilityRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeScheduledInstanceAvailability ( request ) ; }
public SendBonusResult sendBonus ( SendBonusRequest request ) { request = beforeClientExecution ( request ) ; return executeSendBonus ( request ) ; }
public UnpackException ( Throwable why ) { super ( JGitText . get ( ) . unpackException ) ; initCause ( why ) ; }
public boolean remove ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) return false ; Map . Entry <? , ?> e = ( Map . Entry <? , ?> ) o ; return ConcurrentHashMap . this . remove ( e . getKey ( ) , e . getValue ( ) ) ; }
public Iterator < V > iterator ( ) { return newValueIterator ( ) ; }
public DescribeVpcEndpointServiceConfigurationsResult describeVpcEndpointServiceConfigurations ( DescribeVpcEndpointServiceConfigurationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcEndpointServiceConfigurations ( request ) ; }
public void setDiffComparator ( RawTextComparator cmp ) { comparator = cmp ; }
public FilePassRecord clone ( ) { return copy ( ) ; }
public DeleteServiceResult deleteService ( DeleteServiceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteService ( request ) ; }
public FormulaRecord ( ) { field_8_parsed_expr = Formula . create ( Ptg . EMPTY_PTG_ARRAY ) ; }
public DescribeHsmClientCertificatesResult describeHsmClientCertificates ( DescribeHsmClientCertificatesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeHsmClientCertificates ( request ) ; }
public ICUTokenizerFactory ( Map < String , String > args ) { super ( args ) ; tailored = new HashMap <> ( ) ; String rulefilesArg = get ( args , RULEFILES ) ; if ( rulefilesArg != null ) { List < String > scriptAndResourcePaths = splitFileNames ( rulefilesArg ) ; for ( String scriptAndResourcePath : scriptAndResourcePaths ) { int colonPos = scriptAndResourcePath . indexOf ( " : " ) ; String scriptCode = scriptAndResourcePath . substring ( 0 , colonPos ) . trim ( ) ; String resourcePath = scriptAndResourcePath . substring ( colonPos + 1 ) . trim ( ) ; tailored . put ( UCharacter . getPropertyValueEnum ( UProperty . SCRIPT , scriptCode ) , resourcePath ) ; } } cjkAsWords = getBoolean ( args , " cjkAsWords " , true ) ; myanmarAsWords = getBoolean ( args , " myanmarAsWords " , true ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public SuspendProcessesResult suspendProcesses ( SuspendProcessesRequest request ) { request = beforeClientExecution ( request ) ; return executeSuspendProcesses ( request ) ; }
public DescribeConfigurationRevisionResult describeConfigurationRevision ( DescribeConfigurationRevisionRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeConfigurationRevision ( request ) ; }
public RevFilter clone ( ) { final RevFilter [ ] s = new RevFilter [ subfilters . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) s [ i ] = subfilters [ i ] . clone ( ) ; return new List ( s ) ; }
public TabIdRecord ( ) { _tabids = EMPTY_SHORT_ARRAY ; }
public List < String > getConflictingPaths ( ) { return conflictingPaths ; }
public void reset ( ) { inDegree = 0 ; }
public DescribeJobFlowsRequest ( java . util . List < String > jobFlowIds ) { setJobFlowIds ( jobFlowIds ) ; }
public final void decRef ( ) throws IOException { final int rc = refCount . decrementAndGet ( ) ; if ( rc == 0 ) { boolean success = false ; try { release ( ) ; success = true ; } finally { if ( ! success ) { refCount . incrementAndGet ( ) ; } } } else if ( rc < 0 ) { throw new IllegalStateException ( " too ▁ many ▁ decRef ▁ calls : ▁ refCount ▁ is ▁ " + rc + " ▁ after ▁ decrement " ) ; } }
public DeleteMountTargetResult deleteMountTarget ( DeleteMountTargetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMountTarget ( request ) ; }
public void println ( double d ) { println ( String . valueOf ( d ) ) ; }
public DescribeDBProxyTargetsResult describeDBProxyTargets ( DescribeDBProxyTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBProxyTargets ( request ) ; }
final public SrndQuery PrefixOperatorQuery ( ) throws ParseException { Token oprt ; List < SrndQuery > queries ; switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case OR : oprt = jj_consume_token ( OR ) ; queries = FieldsQueryList ( ) ; { if ( true ) return getOrQuery ( queries , false , oprt ) ; } break ; case AND : oprt = jj_consume_token ( AND ) ; queries = FieldsQueryList ( ) ; { if ( true ) return getAndQuery ( queries , false , oprt ) ; } break ; case N : oprt = jj_consume_token ( N ) ; queries = FieldsQueryList ( ) ; { if ( true ) return getDistanceQuery ( queries , false , oprt , false ) ; } break ; case W : oprt = jj_consume_token ( W ) ; queries = FieldsQueryList ( ) ; { if ( true ) return getDistanceQuery ( queries , false , oprt , true ) ; } break ; default : jj_la1 [ 6 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public DeleteInstanceSnapshotResult deleteInstanceSnapshot ( DeleteInstanceSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteInstanceSnapshot ( request ) ; }
public Entry < K , V > firstEntry ( ) { return immutableCopy ( endpoint ( true ) ) ; }
public DeregisterTransitGatewayMulticastGroupSourcesResult deregisterTransitGatewayMulticastGroupSources ( DeregisterTransitGatewayMulticastGroupSourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterTransitGatewayMulticastGroupSources ( request ) ; }
public ImportTerminologyResult importTerminology ( ImportTerminologyRequest request ) { request = beforeClientExecution ( request ) ; return executeImportTerminology ( request ) ; }
public int serialize ( int offset , byte [ ] data ) { byte [ ] rawData = getRawData ( ) ; if ( getEscherRecords ( ) . size ( ) == 0 && rawData != null ) { return writeData ( offset , data , rawData ) ; } byte [ ] buffer = new byte [ getRawDataSize ( ) ] ; int pos = 0 ; for ( Iterator < EscherRecord > iterator = getEscherRecords ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { EscherRecord r = iterator . next ( ) ; pos += r . serialize ( pos , buffer , new NullEscherSerializationListener ( ) ) ; } return writeData ( offset , data , buffer ) ; }
public DescribeDBParameterGroupsResult describeDBParameterGroups ( DescribeDBParameterGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBParameterGroups ( request ) ; }
public static FuzzySet createSetBasedOnMaxMemory ( int maxNumBytes ) { int setSize = getNearestSetSize ( maxNumBytes ) ; return new FuzzySet ( new FixedBitSet ( setSize + 1 ) , setSize , hashFunctionForVersion ( VERSION_CURRENT ) ) ; }
public BundleWriter ( Repository repo ) { db = repo ; reader = null ; include = new TreeMap <> ( ) ; assume = new HashSet <> ( ) ; tagTargets = new HashSet <> ( ) ; }
public AssociateDomainResult associateDomain ( AssociateDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateDomain ( request ) ; }
public GetInstancePortStatesResult getInstancePortStates ( GetInstancePortStatesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInstancePortStates ( request ) ; }
public SrndTruncQuery ( String truncated , char unlimited , char mask ) { super ( false ) ; this . truncated = truncated ; this . unlimited = unlimited ; this . mask = mask ; truncatedToPrefixAndPattern ( ) ; }
public final Explanation explain ( BasicStats stats ) { return Explanation . match ( lambda ( stats ) , getClass ( ) . getSimpleName ( ) + " , ▁ computed ▁ as ▁ ( n ▁ + ▁ 1 ) ▁ / ▁ ( N ▁ + ▁ 1 ) ▁ from : " , Explanation . match ( stats . getDocFreq ( ) , " n , ▁ number ▁ of ▁ documents ▁ containing ▁ term " ) , Explanation . match ( stats . getNumberOfDocuments ( ) , " N , ▁ total ▁ number ▁ of ▁ documents ▁ with ▁ field " ) ) ; }
public DeleteBaiduChannelResult deleteBaiduChannel ( DeleteBaiduChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteBaiduChannel ( request ) ; }
public UnlinkDeveloperIdentityResult unlinkDeveloperIdentity ( UnlinkDeveloperIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeUnlinkDeveloperIdentity ( request ) ; }
public SimpleBoundaryScanner ( int maxScan , Character [ ] boundaryChars ) { this . maxScan = maxScan ; this . boundaryChars = new HashSet <> ( ) ; this . boundaryChars . addAll ( Arrays . asList ( boundaryChars ) ) ; }
public CreateLogGroupRequest ( String logGroupName ) { setLogGroupName ( logGroupName ) ; }
public static Set < String > getDefaultStopTags ( ) { return DefaultSetHolder . DEFAULT_STOP_TAGS ; }
public ModifyInstanceFleetResult modifyInstanceFleet ( ModifyInstanceFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyInstanceFleet ( request ) ; }
public void addRule ( ConditionalFormattingRule cfRule ) { addRule ( ( HSSFConditionalFormattingRule ) cfRule ) ; }
public void SwitchTo ( int lexState ) { if ( lexState >= 3 || lexState < 0 ) throw new TokenMgrError ( " Error : ▁ Ignoring ▁ invalid ▁ lexical ▁ state ▁ : ▁ " + lexState + " . ▁ State ▁ unchanged . " , TokenMgrError . INVALID_LEXICAL_STATE ) ; elsecurLexState = lexState ; }
public void removeCharCount ( ) { remove1stProperty ( PropertyIDMap . PID_CHARCOUNT ) ; }
public CreateCapacityReservationResult createCapacityReservation ( CreateCapacityReservationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCapacityReservation ( request ) ; }
public StoredField ( String name , long value ) { super ( name , TYPE ) ; fieldsData = value ; }
public void sync ( Parser recognizer ) throws RecognitionException { ATNState s = recognizer . getInterpreter ( ) . atn . states . get ( recognizer . getState ( ) ) ; if ( inErrorRecoveryMode ( recognizer ) ) { return ; } TokenStream tokens = recognizer . getInputStream ( ) ; int la = tokens . LA ( 1 ) ; IntervalSet nextTokens = recognizer . getATN ( ) . nextTokens ( s ) ; if ( nextTokens . contains ( la ) ) { nextTokensContext = null ; nextTokensState = ATNState . INVALID_STATE_NUMBER ; return ; } if ( nextTokens . contains ( Token . EPSILON ) ) { if ( nextTokensContext == null ) { nextTokensContext = recognizer . getContext ( ) ; nextTokensState = recognizer . getState ( ) ; } return ; } switch ( s . getStateType ( ) ) { case ATNState . BLOCK_START : case ATNState . STAR_BLOCK_START : case ATNState . PLUS_BLOCK_START : case ATNState . STAR_LOOP_ENTRY : if ( singleTokenDeletion ( recognizer ) != null ) { return ; } throw new InputMismatchException ( recognizer ) ; case ATNState . PLUS_LOOP_BACK : case ATNState . STAR_LOOP_BACK : reportUnwantedToken ( recognizer ) ; IntervalSet expecting = recognizer . getExpectedTokens ( ) ; IntervalSet whatFollowsLoopIterationOrRule = expecting . or ( getErrorRecoverySet ( recognizer ) ) ; consumeUntil ( recognizer , whatFollowsLoopIterationOrRule ) ; break ; default : break ; } }
public int nextDoc ( ) { if ( ! didNext ) { didNext = true ; return ( doc = 0 ) ; } else { return ( doc = NO_MORE_DOCS ) ; } }
public static Charset parseEncoding ( byte [ ] b ) { String enc = parseEncodingName ( b ) ; if ( enc == null ) { return UTF_8 ; } String name = enc . trim ( ) ; try { return Charset . forName ( name ) ; } catch ( IllegalCharsetNameException | UnsupportedCharsetException badName ) { Charset aliased = charsetForAlias ( name ) ; if ( aliased != null ) { return aliased ; } throw badName ; } }
public FloatBuffer put ( float [ ] src , int srcOffset , int floatCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , floatCount ) ; if ( floatCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + floatCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public BatchGetVariableResult batchGetVariable ( BatchGetVariableRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetVariable ( request ) ; }
public void setRepetitions ( int repetitions ) throws Exception { fixedTime = false ; this . repetitions = repetitions ; if ( repetitions == REPEAT_EXHAUST ) { if ( isParallel ( ) ) { throw new Exception ( " REPEAT □ EXHAUST ▁ is ▁ not ▁ allowed ▁ for ▁ parallel ▁ tasks " ) ; } } setSequenceName ( ) ; }
public synchronized static DefaultProfile getProfile ( ) { if ( null == profile ) { profile = new DefaultProfile ( ) ; } return profile ; }
public String dequote ( byte [ ] in , int inPtr , int inEnd ) { if ( 2 <= inEnd - inPtr && in [ inPtr ] == ' " ' ▁ && ▁ in [ inEnd ▁ - ▁ 1 ] ▁ == ▁ ' " ' ) return dq ( in , inPtr + 1 , inEnd - 1 ) ; return RawParseUtils . decode ( UTF_8 , in , inPtr , inEnd ) ; }
public CacheCluster modifyCacheCluster ( ModifyCacheClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyCacheCluster ( request ) ; }
public TreeFormatter ( int size ) { buf = new byte [ size ] ; }
public void setMaxDeltaDepth ( int maxDeltaDepth ) { this . maxDeltaDepth = maxDeltaDepth ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; int pos = offset ; LittleEndian . putShort ( data , pos , getOptions ( ) ) ; pos += 2 ; LittleEndian . putShort ( data , pos , getRecordId ( ) ) ; pos += 2 ; int remainingBytes = getRecordSize ( ) - 8 ; LittleEndian . putInt ( data , pos , remainingBytes ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_1_shapeIdMax ) ; pos += 4 ; LittleEndian . putInt ( data , pos , getNumIdClusters ( ) ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_3_numShapesSaved ) ; pos += 4 ; LittleEndian . putInt ( data , pos , field_4_drawingsSaved ) ; pos += 4 ; for ( FileIdCluster fic : field_5_fileIdClusters ) { LittleEndian . putInt ( data , pos , fic . getDrawingGroupId ( ) ) ; pos += 4 ; LittleEndian . putInt ( data , pos , fic . getNumShapeIdsUsed ( ) ) ; pos += 4 ; } listener . afterRecordSerialize ( pos , getRecordId ( ) , getRecordSize ( ) , this ) ; return getRecordSize ( ) ; }
public LogDocMergePolicy ( ) { minMergeSize = DEFAULT_MIN_MERGE_DOCS ; maxMergeSize = Long . MAX_VALUE ; maxMergeSizeForForcedMerge = Long . MAX_VALUE ; }
public BM25Similarity ( ) { this ( 1.2f , 0.75f ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeShort ( getExternSheetIndex ( ) ) ; writeCoordinates ( out ) ; }
public String getAccessKeyId ( ) { return accessKeyId ; }
public PutLifecycleHookResult putLifecycleHook ( PutLifecycleHookRequest request ) { request = beforeClientExecution ( request ) ; return executePutLifecycleHook ( request ) ; }
public String toString ( ) { return " [ GRIDSET ] \ n " + " ▁ ▁ ▁ ▁ . gridset ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + getGridset ( ) + " \ n " + " [ / GRIDSET ] \ n " ; }
public static int idealLongArraySize ( int need ) { return idealByteArraySize ( need * 8 ) / 8 ; }
public int size ( ) { return mSize ; }
public String toString ( ) { String biffName = getBiffName ( _sid ) ; if ( biffName == null ) { biffName = " UNKNOWNRECORD " ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( ' [ ' ) . append ( biffName ) . append ( " ] ▁ ( 0x " ) ; sb . append ( Integer . toHexString ( _sid ) . toUpperCase ( Locale . ROOT ) ) . append ( " ) \ n " ) ; if ( _rawData . length > 0 ) { sb . append ( " ▁ ▁ rawData = " ) . append ( HexDump . toHex ( _rawData ) ) . append ( " \ n " ) ; } sb . append ( " [ / " ) . append ( biffName ) . append ( " ] \ n " ) ; return sb . toString ( ) ; }
public int nextPosition ( ) throws IOException { if ( doc != 0 ) { throw new IllegalStateException ( ) ; } else if ( i >= termFreq - 1 ) { throw new IllegalStateException ( " Read ▁ past ▁ last ▁ position " ) ; } ++ i ; if ( payloadIndex != null ) { payload . offset = basePayloadOffset + payloadIndex [ positionIndex + i ] ; payload . length = payloadIndex [ positionIndex + i + 1 ] - payloadIndex [ positionIndex + i ] ; } if ( positions == null ) { return - 1 ; } else { return positions [ positionIndex + i ] ; } }
public MergeDeveloperIdentitiesResult mergeDeveloperIdentities ( MergeDeveloperIdentitiesRequest request ) { request = beforeClientExecution ( request ) ; return executeMergeDeveloperIdentities ( request ) ; }
public CreateUserRequest ( String userName ) { setUserName ( userName ) ; }
public ReplaceNetworkAclEntryResult replaceNetworkAclEntry ( ReplaceNetworkAclEntryRequest request ) { request = beforeClientExecution ( request ) ; return executeReplaceNetworkAclEntry ( request ) ; }
public boolean isFastForward ( ) { return fastForward ; }
public List < Integer > getLLDecisions ( ) { DecisionInfo [ ] decisions = atnSimulator . getDecisionInfo ( ) ; List < Integer > LL = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < decisions . length ; i ++ ) { long fallBack = decisions [ i ] . LL_Fallback ; if ( fallBack > 0 ) LL . add ( i ) ; } return LL ; }
public UpdateModelResult updateModel ( UpdateModelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateModel ( request ) ; }
public int getEndIndex ( ) { return end ; }
public DeleteVPCAssociationAuthorizationResult deleteVPCAssociationAuthorization ( DeleteVPCAssociationAuthorizationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVPCAssociationAuthorization ( request ) ; }
public GetMediaResult getMedia ( GetMediaRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMedia ( request ) ; }
public DeltaRecord clone ( ) { return copy ( ) ; }
public TableRestoreStatus restoreTableFromClusterSnapshot ( RestoreTableFromClusterSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeRestoreTableFromClusterSnapshot ( request ) ; }
public void writeInt ( int v ) { int b3 = ( v >>> 24 ) & 0xFF ; int b2 = ( v >>> 16 ) & 0xFF ; int b1 = ( v >>> 8 ) & 0xFF ; int b0 = ( v ) & 0xFF ; try { out . write ( b0 ) ; out . write ( b1 ) ; out . write ( b2 ) ; out . write ( b3 ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public static Query parse ( String [ ] queries , String [ ] fields , Analyzer analyzer ) throws QueryNodeException { if ( queries . length != fields . length ) throw new IllegalArgumentException ( " queries . length ▁ != ▁ fields . length " ) ; BooleanQuery . Builder bQuery = new BooleanQuery . Builder ( ) ; StandardQueryParser qp = new StandardQueryParser ( ) ; qp . setAnalyzer ( analyzer ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Query q = qp . parse ( queries [ i ] , fields [ i ] ) ; if ( q != null ) { bQuery . add ( q , BooleanClause . Occur . SHOULD ) ; } } return bQuery . build ( ) ; }
public UpdateQualificationTypeResult updateQualificationType ( UpdateQualificationTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateQualificationType ( request ) ; }
public void removeTemplate ( ) { remove1stProperty ( PropertyIDMap . PID_TEMPLATE ) ; }
public ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { int nInnerArgs = args . length - 1 ; if ( nInnerArgs < 1 ) { return ErrorEval . VALUE_INVALID ; } final Function innerFunc ; int functionCode = 0 ; try { ValueEval ve = OperandResolver . getSingleValue ( args [ 0 ] , srcRowIndex , srcColumnIndex ) ; functionCode = OperandResolver . coerceValueToInt ( ve ) ; innerFunc = findFunction ( functionCode ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } final List < ValueEval > list = new ArrayList <> ( Arrays . asList ( args ) . subList ( 1 , args . length ) ) ; Iterator < ValueEval > it = list . iterator ( ) ; while ( it . hasNext ( ) ) { ValueEval eval = it . next ( ) ; if ( eval instanceof LazyRefEval ) { LazyRefEval lazyRefEval = ( LazyRefEval ) eval ; if ( lazyRefEval . isSubTotal ( ) ) { it . remove ( ) ; } if ( functionCode > 100 && lazyRefEval . isRowHidden ( ) ) { it . remove ( ) ; } } } return innerFunc . evaluate ( list . toArray ( new ValueEval [ 0 ] ) , srcRowIndex , srcColumnIndex ) ; }
public InstanceGroupConfig ( InstanceRoleType instanceRole , String instanceType , Integer instanceCount ) { setInstanceRole ( instanceRole . toString ( ) ) ; setInstanceType ( instanceType ) ; setInstanceCount ( instanceCount ) ; }
public LeftMarginRecord ( RecordInputStream in ) { field_1_margin = in . readDouble ( ) ; }
public DescribeTrialComponentResult describeTrialComponent ( DescribeTrialComponentRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTrialComponent ( request ) ; }
public AssociateSubnetCidrBlockResult associateSubnetCidrBlock ( AssociateSubnetCidrBlockRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateSubnetCidrBlock ( request ) ; }
@ Override public Iterator < E > iterator ( ) { return new MapBasedMultisetIterator ( ) ; }
public GetQueueAttributesResult getQueueAttributes ( String queueUrl , java . util . List < String > attributeNames ) { return getQueueAttributes ( new GetQueueAttributesRequest ( ) . withQueueUrl ( queueUrl ) . withAttributeNames ( attributeNames ) ) ; }
public final int getBeginA ( ) { return beginA ; }
public String toString ( ) { return " NoLock " ; }
public boolean contains ( Object object ) { return backingMap . containsKey ( object ) ; }
public String toString ( ) { return " arc = " + fstArc + " ▁ state = " + fsaState ; }
public void clear ( ) { ArrayList < HSSFShape > copy = new ArrayList <> ( shapes ) ; for ( HSSFShape shape : copy ) { removeShape ( shape ) ; } }
public String toString ( ) { return " PerFieldAnalyzerWrapper ( " + fieldAnalyzers + " , ▁ default = " + defaultAnalyzer + " ) " ; }
public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int available = data . length - ( offset + 8 ) ; if ( bytesRemaining > available ) { bytesRemaining = available ; } if ( isContainerRecord ( ) ) { int bytesWritten = 0 ; thedata = new byte [ 0 ] ; offset += 8 ; bytesWritten += 8 ; while ( bytesRemaining > 0 ) { EscherRecord child = recordFactory . createRecord ( data , offset ) ; int childBytesWritten = child . fillFields ( data , offset , recordFactory ) ; bytesWritten += childBytesWritten ; offset += childBytesWritten ; bytesRemaining -= childBytesWritten ; getChildRecords ( ) . add ( child ) ; } return bytesWritten ; } if ( bytesRemaining < 0 ) { bytesRemaining = 0 ; } thedata = IOUtils . safelyAllocate ( bytesRemaining , MAX_RECORD_LENGTH ) ; System . arraycopy ( data , offset + 8 , thedata , 0 , bytesRemaining ) ; return bytesRemaining + 8 ; }
public AssociatePhoneNumberWithUserResult associatePhoneNumberWithUser ( AssociatePhoneNumberWithUserRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociatePhoneNumberWithUser ( request ) ; }
public FieldQuery getFieldQuery ( Query query ) { try { return getFieldQuery ( query , null ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public int getXBATEntriesPerBlock ( ) { return getBATEntriesPerBlock ( ) - 1 ; }
public static CellRangeAddress createEnclosingCellRange ( CellRangeAddress crA , CellRangeAddress crB ) { if ( crB == null ) { return crA . copy ( ) ; } int minRow = lt ( crB . getFirstRow ( ) , crA . getFirstRow ( ) ) ? crB . getFirstRow ( ) : crA . getFirstRow ( ) ; int maxRow = gt ( crB . getLastRow ( ) , crA . getLastRow ( ) ) ? crB . getLastRow ( ) : crA . getLastRow ( ) ; int minCol = lt ( crB . getFirstColumn ( ) , crA . getFirstColumn ( ) ) ? crB . getFirstColumn ( ) : crA . getFirstColumn ( ) ; int maxCol = gt ( crB . getLastColumn ( ) , crA . getLastColumn ( ) ) ? crB . getLastColumn ( ) : crA . getLastColumn ( ) ; return new CellRangeAddress ( minRow , maxRow , minCol , maxCol ) ; }
public static char [ ] grow ( char [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Character . BYTES ) ) ; } else return array ; }
public void setLineStyleColor ( int red , int green , int blue ) { int lineStyleColor = ( ( blue ) << 16 ) | ( ( green ) << 8 ) | red ; setPropertyValue ( new EscherRGBProperty ( EscherPropertyTypes . LINESTYLE__COLOR , lineStyleColor ) ) ; }
public CreateFileSystemResult createFileSystem ( CreateFileSystemRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFileSystem ( request ) ; }
public DeleteVaultRequest ( String accountId , String vaultName ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; }
public ByteBuffer read ( int length , long position ) { if ( position >= size ) { throw new IndexOutOfBoundsException ( " Unable ▁ to ▁ read ▁ " + length + " ▁ bytes ▁ from ▁ " + position + " ▁ in ▁ stream ▁ of ▁ length ▁ " + size ) ; } int toRead = ( int ) Math . min ( length , size - position ) ; return ByteBuffer . wrap ( buffer , ( int ) position , toRead ) ; }
public boolean addPushRefSpec ( RefSpec s ) { if ( push . contains ( s ) ) return false ; return push . add ( s ) ; }
public ViewBillingResult viewBilling ( ViewBillingRequest request ) { request = beforeClientExecution ( request ) ; return executeViewBilling ( request ) ; }
public final char getChar ( ) { int newPosition = position + SizeOf . CHAR ; if ( newPosition > limit ) { throw new BufferUnderflowException ( ) ; } char result = ( char ) Memory . peekShort ( backingArray , offset + position , order ) ; position = newPosition ; return result ; }
public SpanQuery getSpanQuery ( Element e ) throws ParserException { String fieldName = DOMUtils . getAttributeWithInheritanceOrFail ( e , " fieldName " ) ; String value = DOMUtils . getNonBlankTextOrFail ( e ) ; List < SpanQuery > clausesList = new ArrayList <> ( ) ; try ( TokenStream ts = analyzer . tokenStream ( fieldName , value ) ) { TermToBytesRefAttribute termAtt = ts . addAttribute ( TermToBytesRefAttribute . class ) ; ts . reset ( ) ; while ( ts . incrementToken ( ) ) { SpanTermQuery stq = new SpanTermQuery ( new Term ( fieldName , BytesRef . deepCopyOf ( termAtt . getBytesRef ( ) ) ) ) ; clausesList . add ( stq ) ; } ts . end ( ) ; SpanOrQuery soq = new SpanOrQuery ( clausesList . toArray ( new SpanQuery [ clausesList . size ( ) ] ) ) ; float boost = DOMUtils . getAttribute ( e , " boost " , 1.0f ) ; return new SpanBoostQuery ( soq , boost ) ; } catch ( IOException ioe ) { throw new ParserException ( " IOException ▁ parsing ▁ value : " + value ) ; } }
public UpdateGatewayResult updateGateway ( UpdateGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateGateway ( request ) ; }
public boolean getCachedBooleanValue ( ) { return specialCachedValue . getBooleanValue ( ) ; }
public DeleteIdentityPoolResult deleteIdentityPool ( DeleteIdentityPoolRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteIdentityPool ( request ) ; }
public PutSuppressedDestinationResult putSuppressedDestination ( PutSuppressedDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executePutSuppressedDestination ( request ) ; }
public PutEventsResult putEvents ( PutEventsRequest request ) { request = beforeClientExecution ( request ) ; return executePutEvents ( request ) ; }
public GetRecommendationsResult getRecommendations ( GetRecommendationsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRecommendations ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj instanceof SegmentInfo ) { final SegmentInfo other = ( SegmentInfo ) obj ; return other . dir == dir && other . name . equals ( name ) ; } else { return false ; } }
public HSSFDataFormat createDataFormat ( ) { if ( formatter == null ) { formatter = new HSSFDataFormat ( workbook ) ; } return formatter ; }
public UpdateFaceRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " UpdateFace " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeDouble ( getMaxChange ( ) ) ; }
public ModifyVpcEndpointServicePermissionsResult modifyVpcEndpointServicePermissions ( ModifyVpcEndpointServicePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVpcEndpointServicePermissions ( request ) ; }
public IntervalSet nextTokens ( ATNState s ) { if ( s . nextTokenWithinRule != null ) return s . nextTokenWithinRule ; s . nextTokenWithinRule = nextTokens ( s , null ) ; s . nextTokenWithinRule . setReadonly ( true ) ; return s . nextTokenWithinRule ; }
public GetResourceResult getResource ( GetResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeGetResource ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ HYPERLINK ▁ RECORD ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . range ▁ ▁ ▁ = ▁ " ) . append ( _range . formatAsString ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . guid ▁ ▁ ▁ ▁ = ▁ " ) . append ( _guid . toString ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . linkOpts = ▁ " ) . append ( HexDump . intToHex ( _linkOpts ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . label ▁ ▁ ▁ = ▁ " ) . append ( getLabel ( ) ) . append ( " \ n " ) ; if ( ( _linkOpts & HLINK_TARGET_FRAME ) != 0 ) { buffer . append ( " ▁ ▁ ▁ ▁ . targetFrame = ▁ " ) . append ( getTargetFrame ( ) ) . append ( " \ n " ) ; } if ( ( _linkOpts & HLINK_URL ) != 0 && _moniker != null ) { buffer . append ( " ▁ ▁ ▁ ▁ . moniker ▁ ▁ ▁ = ▁ " ) . append ( _moniker . toString ( ) ) . append ( " \ n " ) ; } if ( ( _linkOpts & HLINK_PLACE ) != 0 ) { buffer . append ( " ▁ ▁ ▁ ▁ . textMark = ▁ " ) . append ( getTextMark ( ) ) . append ( " \ n " ) ; } buffer . append ( " ▁ ▁ ▁ ▁ . address ▁ ▁ ▁ = ▁ " ) . append ( getAddress ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / HYPERLINK ▁ RECORD ] \ n " ) ; return buffer . toString ( ) ; }
public CreateFacetResult createFacet ( CreateFacetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFacet ( request ) ; }
@ Override public int indexOf ( Object object ) { final int size ; final Object [ ] array ; synchronized ( mutex ) { size = list . size ( ) ; array = new Object [ size ] ; list . toArray ( array ) ; } if ( object != null ) { for ( int i = 0 ; i < size ; i ++ ) { if ( object . equals ( array [ i ] ) ) { return i ; } } } else { for ( int i = 0 ; i < size ; i ++ ) { if ( array [ i ] == null ) { return i ; } } } return - 1 ; }
public static PrintOrientation valueOf ( int value ) { return _table [ value ] ; }
public DefineExpressionResult defineExpression ( DefineExpressionRequest request ) { request = beforeClientExecution ( request ) ; return executeDefineExpression ( request ) ; }
public long getLastModified ( ) { return attributes . getLastModifiedInstant ( ) . toEpochMilli ( ) ; }
public void close ( ) { buffer = null ; size = - 1 ; }
public StartEntitiesDetectionJobResult startEntitiesDetectionJob ( StartEntitiesDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStartEntitiesDetectionJob ( request ) ; }
public boolean processMatch ( ValueEval eval ) { if ( result == null ) { result = eval ; } else { if ( result instanceof BlankEval ) { result = eval ; } else { if ( ! ( eval instanceof BlankEval ) ) { result = ErrorEval . NUM_ERROR ; return false ; } } } return true ; }
public TokenTagToken ( String tokenName , int type , String label ) { super ( type ) ; this . tokenName = tokenName ; this . label = label ; }
public void reset ( boolean zeroFillBuffers , boolean reuseFirst ) { if ( bufferUpto != - 1 ) { if ( zeroFillBuffers ) { for ( int i = 0 ; i < bufferUpto ; i ++ ) { Arrays . fill ( buffers [ i ] , ( byte ) 0 ) ; } Arrays . fill ( buffers [ bufferUpto ] , 0 , byteUpto , ( byte ) 0 ) ; } if ( bufferUpto > 0 || ! reuseFirst ) { final int offset = reuseFirst ? 1 : 0 ; allocator . recycleByteBlocks ( buffers , offset , 1 + bufferUpto ) ; Arrays . fill ( buffers , offset , 1 + bufferUpto , null ) ; } if ( reuseFirst ) { bufferUpto = 0 ; byteUpto = 0 ; byteOffset = 0 ; buffer = buffers [ 0 ] ; } else { bufferUpto = - 1 ; byteUpto = BYTE_BLOCK_SIZE ; byteOffset = - BYTE_BLOCK_SIZE ; buffer = null ; } } }
public UpdateExpirationForHITResult updateExpirationForHIT ( UpdateExpirationForHITRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateExpirationForHIT ( request ) ; }
public Policy ( String id ) { this . id = id ; }
public UpdateApplicationVersionRequest ( String applicationName , String versionLabel ) { setApplicationName ( applicationName ) ; setVersionLabel ( versionLabel ) ; }
public String getEmailAddress ( ) { final int lt = RawParseUtils . nextLF ( buffer , valStart , ' < ' ) ; if ( valEnd <= lt ) { final int at = RawParseUtils . nextLF ( buffer , valStart , ' @ ' ) ; if ( valStart < at && at < valEnd ) return getValue ( ) ; return null ; } final int gt = RawParseUtils . nextLF ( buffer , lt , ' > ' ) ; if ( valEnd < gt ) return null ; return RawParseUtils . decode ( enc , buffer , lt , gt - 1 ) ; }
public String simpleFormat ( Object value ) { StringBuffer sb = new StringBuffer ( ) ; simpleValue ( sb , value ) ; return sb . toString ( ) ; }
public RevFilter clone ( ) { return new NotRevFilter ( a . clone ( ) ) ; }
public static int finish ( int hash , int numberOfWords ) { hash = hash ^ ( numberOfWords * 4 ) ; hash = hash ^ ( hash >>> 16 ) ; hash = hash * 0x85EBCA6B ; hash = hash ^ ( hash >>> 13 ) ; hash = hash * 0xC2B2AE35 ; hash = hash ^ ( hash >>> 16 ) ; return hash ; }
public StempelFilter ( TokenStream in , StempelStemmer stemmer , int minLength ) { super ( in ) ; this . stemmer = stemmer ; this . minLength = minLength ; }
public GetIntegrationResponseResult getIntegrationResponse ( GetIntegrationResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIntegrationResponse ( request ) ; }
public PostToConnectionResult postToConnection ( PostToConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executePostToConnection ( request ) ; }
public TermRangeQueryNode ( FieldQueryNode lower , FieldQueryNode upper , boolean lowerInclusive , boolean upperInclusive ) { setBounds ( lower , upper , lowerInclusive , upperInclusive ) ; }
public QueryParser ( CharStream stream ) { token_source = new QueryParserTokenManager ( stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) jj_la1 [ i ] = - 1 ; for ( int i = 0 ; i < jj_2_rtns . length ; i ++ ) jj_2_rtns [ i ] = new JJCalls ( ) ; }
public CreateSchemaResult createSchema ( CreateSchemaRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSchema ( request ) ; }
public V get ( char [ ] text , int off , int len ) { if ( text == null ) throw new NullPointerException ( ) ; return null ; }
public List < CharsRef > stem ( String word ) { return stem ( word . toCharArray ( ) , word . length ( ) ) ; }
public DeleteSmsTemplateResult deleteSmsTemplate ( DeleteSmsTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSmsTemplate ( request ) ; }
public void setPassword ( short pw ) { field_1_password = pw ; }
public CharBuffer append ( char c ) { return put ( c ) ; }
public PutVoiceConnectorLoggingConfigurationResult putVoiceConnectorLoggingConfiguration ( PutVoiceConnectorLoggingConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executePutVoiceConnectorLoggingConfiguration ( request ) ; }
public boolean isAbsolute ( ) { return path . length ( ) > 0 && path . charAt ( 0 ) == separatorChar ; }
public CreateSnapshotRequest ( String volumeId , String description ) { setVolumeId ( volumeId ) ; setDescription ( description ) ; }
public static ReaderIterator getReaderIteratorNoHeader ( DataInput in , Format format , int version , int valueCount , int bitsPerValue , int mem ) { checkVersion ( version ) ; return new PackedReaderIterator ( format , version , valueCount , bitsPerValue , in , mem ) ; }
public DoubleBuffer put ( int index , double c ) { throw new ReadOnlyBufferException ( ) ; }
public StashDropCommand stashDrop ( ) { return new StashDropCommand ( repo ) ; }
public boolean isUnmappable ( ) { return this . type == TYPE_UNMAPPABLE_CHAR ; }
public byte readByte ( ) { checkPosition ( 1 ) ; return ( byte ) read ( ) ; }
public void decode ( long [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { if ( bitsPerValue > 32 ) { throw new UnsupportedOperationException ( " Cannot ▁ decode ▁ " + bitsPerValue + " - bits ▁ values ▁ into ▁ an ▁ int [ ] " ) ; } for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; valuesOffset = decode ( block , values , valuesOffset ) ; } }
public CustomAnalyzerConfig build ( ) { return new CustomAnalyzerConfig ( this ) ; }
public UpdateAddressBookResult updateAddressBook ( UpdateAddressBookRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateAddressBook ( request ) ; }
public String toString ( ) { return String . format ( " Point ▁ [ % dx % d ] " , x , y ) ; }
public DescribeAccountAttributesResult describeAccountAttributes ( DescribeAccountAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAccountAttributes ( request ) ; }
public static final RevFilter before ( long ts ) { return new Before ( ts ) ; }
public void seekExact ( BytesRef target , TermState otherState ) { if ( ! target . equals ( term ) ) { state . copyFrom ( otherState ) ; term = BytesRef . deepCopyOf ( target ) ; seekPending = true ; } }
public DescribeClusterParameterGroupsResult describeClusterParameterGroups ( DescribeClusterParameterGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClusterParameterGroups ( request ) ; }
public BatchGetApplicationsResult batchGetApplications ( BatchGetApplicationsRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetApplications ( request ) ; }
public String toString ( ) { return " dels = " + Arrays . toString ( item ) ; }
public FreeRefFunction findFunction ( String name ) { FreeRefFunction evaluatorForFunction ; for ( UDFFinder pack : _usedToolPacks ) { evaluatorForFunction = pack . findFunction ( name ) ; if ( evaluatorForFunction != null ) { return evaluatorForFunction ; } } return null ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ LABEL ] \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . row ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( getRow ( ) ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . column ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( getColumn ( ) ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . xfindex ▁ ▁ ▁ = ▁ " ) . append ( HexDump . shortToHex ( getXFIndex ( ) ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . string □ len = ▁ " ) . append ( HexDump . shortToHex ( field_4_string_len ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . unicode □ flag = ▁ " ) . append ( HexDump . byteToHex ( field_5_unicode_flag ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . value ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getValue ( ) ) . append ( " \ n " ) ; sb . append ( " [ / LABEL ] \ n " ) ; return sb . toString ( ) ; }
public static void verifyLabel ( String label ) { if ( label == null || label . isEmpty ( ) ) { throw new IllegalArgumentException ( " empty ▁ or ▁ null ▁ components ▁ not ▁ allowed ; ▁ got : ▁ " + label ) ; } }
public boolean setReadOnly ( ) { return setWritable ( false , false ) ; }
public CopyImageResult copyImage ( CopyImageRequest request ) { request = beforeClientExecution ( request ) ; return executeCopyImage ( request ) ; }
public CreateTrainingJobResult createTrainingJob ( CreateTrainingJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTrainingJob ( request ) ; }
public DescribeDomainsResult describeDomains ( DescribeDomainsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDomains ( request ) ; }
public String toString ( ) { return " ngram ( " + n + " ) " ; }
public boolean formatMatches ( ColumnInfoRecord other ) { if ( _xfIndex != other . _xfIndex ) { return false ; } if ( _options != other . _options ) { return false ; } if ( _colWidth != other . _colWidth ) { return false ; } return true ; }
public AddCommand add ( ) { return new AddCommand ( repo ) ; }
public final int limit ( ) { return limit ; }
public CharBuffer asReadOnlyBuffer ( ) { return ReadOnlyCharArrayBuffer . copy ( this , mark ) ; }
public synchronized boolean add ( E object ) { if ( elementCount == elementData . length ) { growByOne ( ) ; } elementData [ elementCount ++ ] = object ; modCount ++ ; return true ; }
public TSTNode getNode ( CharSequence key ) { return getNode ( key , rootNode ) ; }
public GetEventStreamResult getEventStream ( GetEventStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeGetEventStream ( request ) ; }
public SendMessageBatchResult sendMessageBatch ( SendMessageBatchRequest request ) { request = beforeClientExecution ( request ) ; return executeSendMessageBatch ( request ) ; }
public DescribeDirectConnectGatewayAttachmentsResult describeDirectConnectGatewayAttachments ( DescribeDirectConnectGatewayAttachmentsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDirectConnectGatewayAttachments ( request ) ; }
public Object add ( Object prefix , Object output ) { assert ! ( prefix instanceof List ) ; if ( ! ( output instanceof List ) ) { return outputs . add ( ( T ) prefix , ( T ) output ) ; } else { List < T > outputList = ( List < T > ) output ; List < T > addedList = new ArrayList <> ( outputList . size ( ) ) ; for ( T _output : outputList ) { addedList . add ( outputs . add ( ( T ) prefix , _output ) ) ; } return addedList ; } }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 , ValueEval arg3 ) { return evaluate ( srcRowIndex , srcColumnIndex , arg0 , arg1 , arg2 , arg3 , DEFAULT_ARG4 ) ; }
public static List < ParseTree > findAllNodes ( ParseTree t , int index , boolean findTokens ) { List < ParseTree > nodes = new ArrayList < ParseTree > ( ) ; _findAllNodes ( t , index , findTokens , nodes ) ; return nodes ; }
public boolean containsChart ( ) { EscherOptRecord optRecord = ( EscherOptRecord ) _boundAggregate . findFirstWithId ( EscherOptRecord . RECORD_ID ) ; if ( optRecord == null ) { return false ; } for ( EscherProperty prop : optRecord . getEscherProperties ( ) ) { if ( prop . getPropertyNumber ( ) == 896 && prop . isComplex ( ) ) { EscherComplexProperty cp = ( EscherComplexProperty ) prop ; String str = StringUtil . getFromUnicodeLE ( cp . getComplexData ( ) ) ; if ( str . equals ( " Chart ▁ 1 \ 0 " ) ) { return true ; } } } return false ; }
public int getWidth ( ) { return w ; }
public StopInstanceResult stopInstance ( StopInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeStopInstance ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ TABLE ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . range ▁ ▁ ▁ ▁ = ▁ " ) . append ( getRange ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . flags ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . byteToHex ( field_5_flags ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . alwaysClc = ▁ " ) . append ( isAlwaysCalc ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . reserved ▁ = ▁ " ) . append ( HexDump . intToHex ( field_6_res ) ) . append ( " \ n " ) ; CellReference crRowInput = cr ( field_7_rowInputRow , field_8_colInputRow ) ; CellReference crColInput = cr ( field_9_rowInputCol , field_10_colInputCol ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rowInput ▁ = ▁ " ) . append ( crRowInput . formatAsString ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . colInput ▁ = ▁ " ) . append ( crColInput . formatAsString ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / TABLE ] \ n " ) ; return buffer . toString ( ) ; }
public RemoveTagsResult removeTags ( RemoveTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveTags ( request ) ; }
public boolean hasNext ( ) { if ( next == null ) next = peek ( ) ; return next != null ; }
public long byteCount ( int packedIntsVersion , int valueCount , int bitsPerValue ) { return ( long ) Math . ceil ( ( double ) valueCount * bitsPerValue / 8 ) ; }
public GetQueueUrlRequest ( String queueName ) { setQueueName ( queueName ) ; }
public void addEscherRecord ( int index , EscherRecord element ) { escherRecords . add ( index , element ) ; }
public ListInstanceGroupsResult listInstanceGroups ( ListInstanceGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListInstanceGroups ( request ) ; }
public TruncateTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; prefixLength = Byte . parseByte ( get ( args , PREFIX_LENGTH_KEY , " 5 " ) ) ; if ( prefixLength < 1 ) throw new IllegalArgumentException ( PREFIX_LENGTH_KEY + " ▁ parameter ▁ must ▁ be ▁ a ▁ positive ▁ number : ▁ " + prefixLength ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameter ( s ) : ▁ " + args ) ; } }
public GetDetectorResult getDetector ( GetDetectorRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDetector ( request ) ; }
public void set ( int index , int n ) { if ( count < index ) throw new ArrayIndexOutOfBoundsException ( index ) ; else if ( count == index ) add ( n ) ; elseentries [ index ] = n ; }
public StatePair ( int s1 , int s2 ) { this . s1 = s1 ; this . s2 = s2 ; this . s = - 1 ; }
public DetachDiskResult detachDisk ( DetachDiskRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachDisk ( request ) ; }
public void clear ( ) { count = 0 ; }
public ListIterator < E > listIterator ( ) { return delegate ( ) . listIterator ( ) ; }
public FieldDoc ( int doc , float score , Object [ ] fields , int shardIndex ) { super ( doc , score , shardIndex ) ; this . fields = fields ; }
public ResourceRecord ( String value ) { setValue ( value ) ; }
public String getAuthority ( ) { return decode ( authority ) ; }
public void flush ( ) throws IOException { drain ( ) ; output . flush ( ) ; }
public ListMultipartUploadsRequest ( String accountId , String vaultName ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; }
public UpdateRouteResponseResult updateRouteResponse ( UpdateRouteResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRouteResponse ( request ) ; }
public boolean containsKey ( Object name ) { return get ( name ) != null ; }
public SimpleRateLimiter ( double mbPerSec ) { setMBPerSec ( mbPerSec ) ; lastNS = System . nanoTime ( ) ; }
public void releaseSession ( RemoteSession session ) { session . disconnect ( ) ; }
public SetQuotaRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " SetQuota " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public ParserATNSimulator ( Parser parser , ATN atn , DFA [ ] decisionToDFA , PredictionContextCache sharedContextCache ) { super ( atn , sharedContextCache ) ; this . parser = parser ; this . decisionToDFA = decisionToDFA ; }
public void remove ( ) { Object [ ] a = array ; int removalIdx = removalIndex ; if ( modCount != expectedModCount ) { throw new ConcurrentModificationException ( ) ; } if ( removalIdx < 0 ) { throw new IllegalStateException ( ) ; } System . arraycopy ( a , removalIdx + 1 , a , removalIdx , remaining ) ; a [ -- size ] = null ; removalIndex = - 1 ; expectedModCount = ++ modCount ; }
public T getPointAt ( int index ) { return elements [ index ] ; }
public StatusCommand setWorkingTreeIt ( WorkingTreeIterator workingTreeIt ) { this . workingTreeIt = workingTreeIt ; return this ; }
public CharBlockArray append ( CharSequence chars ) { return append ( chars , 0 , chars . length ( ) ) ; }
public void clear ( ) { current . clear ( ) ; }
public String toFormulaString ( ) { return FormulaError . forInt ( field_1_error_code ) . getString ( ) ; }
public FtPioGrbitSubRecord clone ( ) { return copy ( ) ; }
public PositionSpan ( int start , int end ) { this . start = start ; this . end = end ; }
public void setParams ( String params ) { super . setParams ( params ) ; StringTokenizer st = new StringTokenizer ( params , " , " ) ; while ( st . hasMoreTokens ( ) ) { String param = st . nextToken ( ) ; StringTokenizer expr = new StringTokenizer ( param , " : " ) ; String key = expr . nextToken ( ) ; String value = expr . nextToken ( ) ; if ( key . equals ( " impl " ) ) { if ( value . equalsIgnoreCase ( " icu " ) ) impl = Implementation . ICU ; else if ( value . equalsIgnoreCase ( " jdk " ) ) impl = Implementation . JDK ; else throw new RuntimeException ( " Unknown ▁ parameter ▁ " + param ) ; } else { throw new RuntimeException ( " Unknown ▁ parameter ▁ " + param ) ; } } }
public DeleteBuildResult deleteBuild ( DeleteBuildRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteBuild ( request ) ; }
public DescribeVolumeStatusResult describeVolumeStatus ( ) { return describeVolumeStatus ( new DescribeVolumeStatusRequest ( ) ) ; }
public String getFlags ( ) { return f ; }
public ShowNoteCommand setObjectId ( RevObject id ) { checkCallable ( ) ; this . id = id ; return this ; }
public PatternReplaceFilter create ( TokenStream input ) { return new PatternReplaceFilter ( input , pattern , replacement , replaceAll ) ; }
public void reset ( ) throws IOException { drain ( ) ; output . writeByte ( TC_RESET ) ; resetState ( ) ; }
public Ptg get3DReferencePtg ( CellReference cr , SheetIdentifier sheet ) { int extIx = getSheetExtIx ( sheet ) ; return new Ref3DPtg ( cr , extIx ) ; }
public static void fill ( boolean [ ] array , int start , int end , boolean value ) { Arrays . checkStartAndEnd ( array . length , start , end ) ; for ( int i = start ; i < end ; i ++ ) { array [ i ] = value ; } }
public TokenStream create ( TokenStream input ) { return new ICUFoldingFilter ( input , normalizer ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escaper ) { return " [ NTF ] " ; }
public StashCreateCommand setWorkingDirectoryMessage ( String message ) { workingDirectoryMessage = message ; return this ; }
public SheetRangeEvaluator ( int onlySheetIndex , SheetRefEvaluator sheetEvaluator ) { this ( onlySheetIndex , onlySheetIndex , new SheetRefEvaluator [ ] { sheetEvaluator } ) ; }
public static long [ ] grow ( long [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Long . BYTES ) ) ; } else return array ; }
public static RevFilter create ( Collection < RevFilter > list ) { if ( list . size ( ) < 2 ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastTwoFiltersNeeded ) ; final RevFilter [ ] subfilters = new RevFilter [ list . size ( ) ] ; list . toArray ( subfilters ) ; if ( subfilters . length == 2 ) return create ( subfilters [ 0 ] , subfilters [ 1 ] ) ; return new List ( subfilters ) ; }
public DeregisterOnPremisesInstanceResult deregisterOnPremisesInstance ( DeregisterOnPremisesInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterOnPremisesInstance ( request ) ; }
public ListDeliverabilityTestReportsResult listDeliverabilityTestReports ( ListDeliverabilityTestReportsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDeliverabilityTestReports ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { double dn ; try { ValueEval ve1 = OperandResolver . getSingleValue ( arg1 , srcRowIndex , srcColumnIndex ) ; dn = OperandResolver . coerceValueToDouble ( ve1 ) ; } catch ( EvaluationException e1 ) { return ErrorEval . VALUE_INVALID ; } if ( dn < 1.0 ) { return ErrorEval . NUM_ERROR ; } int k = ( int ) Math . ceil ( dn ) ; double result ; try { double [ ] ds = ValueCollector . collectValues ( arg0 ) ; if ( k > ds . length ) { return ErrorEval . NUM_ERROR ; } result = _isLarge ? StatsLib . kthLargest ( ds , k ) : StatsLib . kthSmallest ( ds , k ) ; NumericFunction . checkValue ( result ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public ByteArrayDataInput ( ) { reset ( BytesRef . EMPTY_BYTES ) ; }
public ByteBuffer putDouble ( double value ) { throw new ReadOnlyBufferException ( ) ; }
public ChangeMessageVisibilityResult changeMessageVisibility ( ChangeMessageVisibilityRequest request ) { request = beforeClientExecution ( request ) ; return executeChangeMessageVisibility ( request ) ; }
public UpdateWorkGroupResult updateWorkGroup ( UpdateWorkGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateWorkGroup ( request ) ; }
public NavigableMap < K , V > tailMap ( K fromInclusive ) { return subMap ( fromInclusive , INCLUSIVE , null , NO_BOUND ) ; }
public String toString ( ) { return " 2 " ; }
public BlameCommand setStartCommit ( AnyObjectId commit ) { this . startCommit = commit . toObjectId ( ) ; return this ; }
public ModifyEbsDefaultKmsKeyIdResult modifyEbsDefaultKmsKeyId ( ModifyEbsDefaultKmsKeyIdRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyEbsDefaultKmsKeyId ( request ) ; }
public void removeAuthor ( ) { remove1stProperty ( PropertyIDMap . PID_AUTHOR ) ; }
public Ref get ( Object key ) { String name = toRefName ( ( String ) key ) ; Ref ref = resolved . get ( name ) ; if ( ref == null ) ref = loose . get ( name ) ; if ( ref == null ) ref = packed . get ( name ) ; return ref ; }
public int addConditionalFormatting ( HSSFConditionalFormatting cf ) { CFRecordsAggregate cfraClone = cf . getCFRecordsAggregate ( ) . cloneCFAggregate ( ) ; return _conditionalFormattingTable . add ( cfraClone ) ; }
public final String toString ( ) { return getClass ( ) . getName ( ) + " [ " + this . canonicalName + " ] " ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getIterations ( ) ) ; }
public MatchAllDocsQuery build ( QueryNode queryNode ) throws QueryNodeException { if ( ! ( queryNode instanceof MatchAllDocsQueryNode ) ) { throw new QueryNodeException ( new MessageImpl ( QueryParserMessages . LUCENE_QUERY_CONVERSION_ERROR , queryNode . toQueryString ( new EscapeQuerySyntaxImpl ( ) ) , queryNode . getClass ( ) . getName ( ) ) ) ; } return new MatchAllDocsQuery ( ) ; }
public LongBuffer get ( long [ ] dst ) { return get ( dst , 0 , dst . length ) ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " / " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
@ Override public void clear ( ) { countMap . clear ( ) ; }
public SpatialArgs ( SpatialOperation operation , Shape shape ) { if ( operation == null || shape == null ) throw new NullPointerException ( " operation ▁ and ▁ shape ▁ are ▁ required " ) ; this . operation = operation ; this . shape = shape ; }
public int compareTo ( Completion o ) { return this . utf8. compareTo ( o . utf8 ) ; }
public GetInstancesResult getInstances ( GetInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInstances ( request ) ; }
public int next ( ) { if ( text . getIndex ( ) == text . getEndIndex ( ) || 0 == sentenceStarts . length ) { return DONE ; } else if ( currentSentence < sentenceStarts . length - 1 ) { text . setIndex ( sentenceStarts [ ++ currentSentence ] ) ; return current ( ) ; } else { return last ( ) ; } }
public HSSFClientAnchor getPreferredSize ( double scaleX , double scaleY ) { ImageUtils . setPreferredSize ( this , scaleX , scaleY ) ; return getClientAnchor ( ) ; }
public CreateTaskSetResult createTaskSet ( CreateTaskSetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTaskSet ( request ) ; }
public ByteBuffer putFloat ( int index , float value ) { return putInt ( index , Float . floatToRawIntBits ( value ) ) ; }
public static void main ( String [ ] args ) throws Exception { String field = null ; int numTerms = DEFAULT_NUMTERMS ; if ( args . length == 0 || args . length > 4 ) { usage ( ) ; System . exit ( 1 ) ; } Directory dir = FSDirectory . open ( Paths . get ( args [ 0 ] ) ) ; Comparator < TermStats > comparator = new DocFreqComparator ( ) ; for ( int i = 1 ; i < args . length ; i ++ ) { if ( args [ i ] . equals ( " - t " ) ) { comparator = new TotalTermFreqComparator ( ) ; } else { try { numTerms = Integer . parseInt ( args [ i ] ) ; } catch ( NumberFormatException e ) { field = args [ i ] ; } } } IndexReader reader = DirectoryReader . open ( dir ) ; TermStats [ ] terms = getHighFreqTerms ( reader , numTerms , field , comparator ) ; for ( int i = 0 ; i < terms . length ; i ++ ) { System . out . printf ( Locale . ROOT , " % s :% s ▁ \ t ▁ totalTF ▁ = ▁ % , d ▁ \ t ▁ docFreq ▁ = ▁ % , d ▁ \ n " , terms [ i ] . field , terms [ i ] . termtext . utf8ToString ( ) , terms [ i ] . totalTermFreq , terms [ i ] . docFreq ) ; } reader . close ( ) ; }
public static Collection < String > getNotSupportedFunctionNames ( ) { Collection < String > lst = new TreeSet <> ( ) ; lst . addAll ( FunctionEval . getNotSupportedFunctionNames ( ) ) ; lst . addAll ( AnalysisToolPak . getNotSupportedFunctionNames ( ) ) ; return Collections . unmodifiableCollection ( lst ) ; }
public CreateMeetingResult createMeeting ( CreateMeetingRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateMeeting ( request ) ; }
public char get ( int index ) { checkIndex ( index ) ; return byteBuffer . getChar ( index * SizeOf . CHAR ) ; }
public GetInstanceSnapshotResult getInstanceSnapshot ( GetInstanceSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInstanceSnapshot ( request ) ; }
public static Map < String , Integer > toMap ( String [ ] keys ) { Map < String , Integer > m = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < keys . length ; i ++ ) { m . put ( keys [ i ] , i ) ; } return m ; }
public GetHealthCheckStatusResult getHealthCheckStatus ( GetHealthCheckStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeGetHealthCheckStatus ( request ) ; }
public GetReusableDelegationSetResult getReusableDelegationSet ( GetReusableDelegationSetRequest request ) { request = beforeClientExecution ( request ) ; return executeGetReusableDelegationSet ( request ) ; }
public final ValueEval getAbsoluteValue ( int row , int col ) { int rowOffsetIx = row - _firstRow ; int colOffsetIx = col - _firstColumn ; if ( rowOffsetIx < 0 || rowOffsetIx >= _nRows ) { throw new IllegalArgumentException ( " Specified ▁ row ▁ index ▁ ( " + row + " ) ▁ is ▁ outside ▁ the ▁ allowed ▁ range ▁ ( " + _firstRow + " .. " + _lastRow + " ) " ) ; } if ( colOffsetIx < 0 || colOffsetIx >= _nColumns ) { throw new IllegalArgumentException ( " Specified ▁ column ▁ index ▁ ( " + col + " ) ▁ is ▁ outside ▁ the ▁ allowed ▁ range ▁ ( " + _firstColumn + " .. " + col + " ) " ) ; } return getRelativeValue ( rowOffsetIx , colOffsetIx ) ; }
public final LongBuffer put ( long [ ] src , int srcOffset , int longCount ) { throw new ReadOnlyBufferException ( ) ; }
public final String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " Document < " ) ; for ( int i = 0 ; i < fields . size ( ) ; i ++ ) { IndexableField field = fields . get ( i ) ; buffer . append ( field . toString ( ) ) ; if ( i != fields . size ( ) - 1 ) { buffer . append ( " ▁ " ) ; } } buffer . append ( " > " ) ; return buffer . toString ( ) ; }
public StartMatchBackfillResult startMatchBackfill ( StartMatchBackfillRequest request ) { request = beforeClientExecution ( request ) ; return executeStartMatchBackfill ( request ) ; }
public FeatRecord clone ( ) { return copy ( ) ; }
public DeleteEmailTemplateResult deleteEmailTemplate ( DeleteEmailTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEmailTemplate ( request ) ; }
public ListReceiptRuleSetsResult listReceiptRuleSets ( ListReceiptRuleSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListReceiptRuleSets ( request ) ; }
public boolean isRowGroupCollapsed ( int row ) { int collapseRow = findEndOfRowOutlineGroup ( row ) + 1 ; return getRow ( collapseRow ) != null && getRow ( collapseRow ) . getColapsed ( ) ; }
public void setPathFilter ( TreeFilter filter ) { pathFilter = filter != null ? filter : TreeFilter . ALL ; }
public int getReturnState ( int index ) { assert index == 0 ; return returnState ; }
public GroupingSearch setGroupDocsLimit ( int groupDocsLimit ) { this . groupDocsLimit = groupDocsLimit ; return this ; }
public final void removeField ( String name ) { Iterator < IndexableField > it = fields . iterator ( ) ; while ( it . hasNext ( ) ) { IndexableField field = it . next ( ) ; if ( field . name ( ) . equals ( name ) ) { it . remove ( ) ; return ; } } }
public Double doubleValue ( String key ) { String value = responseMap . get ( key ) ; if ( null == value || 0 == value . length ( ) ) { return null ; } return Double . valueOf ( responseMap . get ( key ) ) ; }
public DescribeLoadBalancersResult describeLoadBalancers ( DescribeLoadBalancersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLoadBalancers ( request ) ; }
public SpanQuery [ ] getClauses ( ) { return clauses . toArray ( new SpanQuery [ clauses . size ( ) ] ) ; }
public MulBlankRecord clone ( ) { return copy ( ) ; }
public final PersonIdent getTaggerIdent ( ) { final byte [ ] raw = buffer ; final int nameB = RawParseUtils . tagger ( raw , 0 ) ; if ( nameB < 0 ) return null ; return RawParseUtils . parsePersonIdent ( raw , nameB ) ; }
public NameRecord createName ( ) { return addName ( new NameRecord ( ) ) ; }
public void setCacheMissesUntilFill ( int i ) { ensureOpen ( ) ; cacheMissesUntilFill = i ; }
public final int hash ( BytesRef br ) { return hash32 ( br . bytes , br . offset , br . length ) ; }
public DoubleBuffer get ( double [ ] dst , int dstOffset , int doubleCount ) { byteBuffer . limit ( limit * SizeOf . DOUBLE ) ; byteBuffer . position ( position * SizeOf . DOUBLE ) ; if ( byteBuffer instanceof DirectByteBuffer ) { ( ( DirectByteBuffer ) byteBuffer ) . get ( dst , dstOffset , doubleCount ) ; } else { ( ( HeapByteBuffer ) byteBuffer ) . get ( dst , dstOffset , doubleCount ) ; } this . position += doubleCount ; return this ; }
public void append ( int key , int value ) { if ( mSize != 0 && key <= mKeys [ mSize - 1 ] ) { put ( key , value ) ; return ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = ArrayUtils . idealIntArraySize ( pos + 1 ) ; int [ ] nkeys = new int [ n ] ; int [ ] nvalues = new int [ n ] ; System . arraycopy ( mKeys , 0 , nkeys , 0 , mKeys . length ) ; System . arraycopy ( mValues , 0 , nvalues , 0 , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + 1 ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 ) { try { double d0 = NumericFunction . singleOperandEvaluate ( arg0 , srcRowIndex , srcColumnIndex ) ; double d1 = NumericFunction . singleOperandEvaluate ( arg1 , srcRowIndex , srcColumnIndex ) ; ValueEval ve = OperandResolver . getSingleValue ( arg2 , srcRowIndex , srcColumnIndex ) ; Boolean method = OperandResolver . coerceValueToBoolean ( ve , false ) ; return new NumberEval ( evaluate ( d0 , d1 , method != null && method . booleanValue ( ) ) ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public QueryAllGroupsRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " QueryAllGroups " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public int replace ( char s [ ] , int len ) { if ( replacement . length > 0 ) { System . arraycopy ( replacement , 0 , s , len - suffix . length , replacement . length ) ; } return len - suffix . length + replacement . length ; }
public StandardSyntaxParserTokenManager ( CharStream stream ) { input_stream = stream ; }
public final String getFullMessage ( ) { byte [ ] raw = buffer ; int msgB = RawParseUtils . commitMessage ( raw , 0 ) ; if ( msgB < 0 ) { return " " ; } return RawParseUtils . decode ( guessEncoding ( ) , raw , msgB , raw . length ) ; }
public Request < GetPublicAccessBlockRequest > marshall ( GetPublicAccessBlockRequest getPublicAccessBlockRequest ) { if ( getPublicAccessBlockRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( ... ) " ) ; } Request < GetPublicAccessBlockRequest > request = new DefaultRequest < GetPublicAccessBlockRequest > ( getPublicAccessBlockRequest , " AWSS3Control " ) ; request . setHttpMethod ( HttpMethodName . GET ) ; if ( getPublicAccessBlockRequest . getAccountId ( ) != null ) { request . addHeader ( " x - amz - account - id " , StringUtils . fromString ( getPublicAccessBlockRequest . getAccountId ( ) ) ) ; } String uriResourcePath = " / v20180820 / configuration / publicAccessBlock " ; request . setResourcePath ( uriResourcePath ) ; return request ; }
public ChangeTagsForResourceResult changeTagsForResource ( ChangeTagsForResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeChangeTagsForResource ( request ) ; }
public void println ( char c ) { println ( String . valueOf ( c ) ) ; }
public RefUpdate . Result getResult ( ) { return result ; }
public HSSFRow getRow ( int rowIndex ) { return _rows . get ( Integer . valueOf ( rowIndex ) ) ; }
public LongBuffer slice ( ) { byteBuffer . limit ( limit * SizeOf . LONG ) ; byteBuffer . position ( position * SizeOf . LONG ) ; ByteBuffer bb = byteBuffer . slice ( ) . order ( byteBuffer . order ( ) ) ; LongBuffer result = new LongToByteBufferAdapter ( bb ) ; byteBuffer . clear ( ) ; return result ; }
public void append ( byte [ ] name , FileMode mode , AnyObjectId id ) { append ( name , 0 , name . length , mode , id ) ; }
public String toString ( ) { return String . format ( " mode ( % d ) " , mode ) ; }
public DescribeScriptResult describeScript ( DescribeScriptRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeScript ( request ) ; }
public String toString ( ) { return " NoMergePolicy " ; }
public CacheSecurityGroup revokeCacheSecurityGroupIngress ( RevokeCacheSecurityGroupIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeRevokeCacheSecurityGroupIngress ( request ) ; }
public final double get ( int index ) { checkIndex ( index ) ; return backingArray [ offset + index ] ; }
public DeleteVoiceConnectorTerminationResult deleteVoiceConnectorTermination ( DeleteVoiceConnectorTerminationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVoiceConnectorTermination ( request ) ; }
public FileTreeIterator ( Repository repo ) { this ( repo , repo . getConfig ( ) . get ( WorkingTreeOptions . KEY ) . isDirNoGitLinks ( ) ? NoGitlinksStrategy . INSTANCE : DefaultFileModeStrategy . INSTANCE ) ; }
public ASCIIFoldingFilter ( TokenStream input , boolean preserveOriginal ) { super ( input ) ; this . preserveOriginal = preserveOriginal ; }
public final CharBuffer asCharBuffer ( ) { return CharToByteBufferAdapter . asCharBuffer ( this ) ; }
public EmbeddedObjectRefSubRecord clone ( ) { return copy ( ) ; }
public DescribeLifecycleHookTypesResult describeLifecycleHookTypes ( DescribeLifecycleHookTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLifecycleHookTypes ( request ) ; }
public String getEncoding ( ) { if ( ! isOpen ( ) ) { return null ; } return HistoricalCharsetNames . get ( decoder . charset ( ) ) ; }
public void respondDecisionTaskCompleted ( RespondDecisionTaskCompletedRequest request ) { request = beforeClientExecution ( request ) ; executeRespondDecisionTaskCompleted ( request ) ; }
public void close ( ) { delegate ( ) . close ( ) ; }
public GetStreamingDistributionRequest ( String id ) { setId ( id ) ; }
@ Override public boolean equals ( Object object ) { return object instanceof Name && ( ( Name ) object ) . name . equalsIgnoreCase ( name ) ; }
public String toString ( ) { return snapshot ( ) . toString ( ) ; }
public GetDirectoryResult getDirectory ( GetDirectoryRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDirectory ( request ) ; }
public SoraniNormalizationFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public CreateSolutionVersionResult createSolutionVersion ( CreateSolutionVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSolutionVersion ( request ) ; }
public UpdateWorkteamResult updateWorkteam ( UpdateWorkteamRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateWorkteam ( request ) ; }
public Matcher region ( int start , int end ) { return reset ( input , start , end ) ; }
public boolean containsKey ( Object o ) { if ( o == null ) throw new NullPointerException ( ) ; return false ; }
public UpdateServerCertificateRequest ( String serverCertificateName ) { setServerCertificateName ( serverCertificateName ) ; }
public int valueAt ( int index ) { return mValues [ index ] ; }
public byte getCharacterClass ( char c ) { return characterCategoryMap [ c ] ; }
public int getBinaryExponent ( ) { return _binaryExponent ; }
public long getOffset ( ) { return offset ; }
public DescribeStackSetResult describeStackSet ( DescribeStackSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStackSet ( request ) ; }
public E get ( int location ) { try { return listIterator ( location ) . next ( ) ; } catch ( NoSuchElementException e ) { throw new IndexOutOfBoundsException ( ) ; } }
public static boolean isComponentRecord ( int sid ) { switch ( sid ) { case ProtectRecord . sid : case ObjectProtectRecord . sid : case ScenarioProtectRecord . sid : case PasswordRecord . sid : return true ; } return false ; }
public long getFilePointer ( ) { return main . getFilePointer ( ) ; }
public String toFormulaString ( ) { return " " ; }
public boolean run ( String s ) { int p = 0 ; int l = s . length ( ) ; for ( int i = 0 , cp = 0 ; i < l ; i += Character . charCount ( cp ) ) { p = step ( p , cp = s . codePointAt ( i ) ) ; if ( p == - 1 ) return false ; } return accept . get ( p ) ; }
public GetSchemaAsJsonResult getSchemaAsJson ( GetSchemaAsJsonRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSchemaAsJson ( request ) ; }
public T set ( int index , T element ) { if ( index < 0 || size <= index ) throw new IndexOutOfBoundsException ( String . valueOf ( index ) ) ; T [ ] blockRef = directory [ toDirectoryIndex ( index ) ] ; int blockIdx = toBlockIndex ( index ) ; T old = blockRef [ blockIdx ] ; blockRef [ blockIdx ] = element ; return old ; }
public int get ( int index , long [ ] arr , int off , int len ) { assert len > 0 : " len ▁ must ▁ be ▁ > ▁ 0 ▁ ( got ▁ " + len + " ) " ; assert index >= 0 && index < size ( ) ; assert off + len <= arr . length ; final int gets = Math . min ( size ( ) - index , len ) ; for ( int i = index , o = off , end = index + gets ; i < end ; ++ i , ++ o ) { arr [ o ] = get ( i ) ; } return gets ; }
public void addParseListener ( ParseTreeListener listener ) { if ( listener == null ) { throw new NullPointerException ( " listener " ) ; } if ( _parseListeners == null ) { _parseListeners = new ArrayList < ParseTreeListener > ( ) ; } this . _parseListeners . add ( listener ) ; }
public CreateQueryLoggingConfigResult createQueryLoggingConfig ( CreateQueryLoggingConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateQueryLoggingConfig ( request ) ; }
public SetIdentityFeedbackForwardingEnabledResult setIdentityFeedbackForwardingEnabled ( SetIdentityFeedbackForwardingEnabledRequest request ) { request = beforeClientExecution ( request ) ; return executeSetIdentityFeedbackForwardingEnabled ( request ) ; }
public int getValueAt ( int relativeOffset ) { if ( relativeOffset >= _values . length ) { throw new ArrayIndexOutOfBoundsException ( " Unable ▁ to ▁ fetch ▁ offset ▁ " + relativeOffset + " ▁ as ▁ the ▁ " + " BAT ▁ only ▁ contains ▁ " + _values . length + " ▁ entries " ) ; } return _values [ relativeOffset ] ; }
@ Override public boolean equals ( Object o ) { if ( o == this ) { return true ; } if ( ! ( o instanceof List ) ) { return false ; } List <?> that = ( List <?> ) o ; int s = size ; if ( that . size ( ) != s ) { return false ; } Object [ ] a = array ; if ( that instanceof RandomAccess ) { for ( int i = 0 ; i < s ; i ++ ) { Object eThis = a [ i ] ; Object ethat = that . get ( i ) ; if ( eThis == null ? ethat != null : ! eThis . equals ( ethat ) ) { return false ; } } } else { Iterator <?> it = that . iterator ( ) ; for ( int i = 0 ; i < s ; i ++ ) { Object eThis = a [ i ] ; Object eThat = it . next ( ) ; if ( eThis == null ? eThat != null : ! eThis . equals ( eThat ) ) { return false ; } } } return true ; }
public boolean equals ( Object o ) { if ( o instanceof ATNState ) return stateNumber == ( ( ATNState ) o ) . stateNumber ; return false ; }
public EmptyTreeIterator createEmptyTreeIterator ( ) { final byte [ ] n = new byte [ Math . max ( pathLen + 1 , DEFAULT_PATH_SIZE ) ] ; System . arraycopy ( path , 0 , n , 0 , pathLen ) ; n [ pathLen ] = ' / ' ; return new EmptyTreeIterator ( this , n , pathLen + 1 ) ; }
public boolean isOverflow ( ) { return this . type == TYPE_OVERFLOW ; }
public ListQueueTagsResult listQueueTags ( ListQueueTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeListQueueTags ( request ) ; }
public BuyOriginPicturesRequest ( ) { super ( " lubancloud " , " 2018 - 05 - 09 " , " BuyOriginPictures " , " luban " ) ; setMethod ( MethodType . POST ) ; }
public static String createSafeSheetName ( final String nameProposal , char replaceChar ) { if ( nameProposal == null ) { return " null " ; } if ( nameProposal . length ( ) < 1 ) { return " empty " ; } final int length = Math . min ( 31 , nameProposal . length ( ) ) ; final String shortenname = nameProposal . substring ( 0 , length ) ; final StringBuilder result = new StringBuilder ( shortenname ) ; for ( int i = 0 ; i < length ; i ++ ) { char ch = result . charAt ( i ) ; switch ( ch ) { case ' \ u0000 ' : case ' \ u0003 ' : case ' : ' : case ' / ' : case ' \\ ' : case ▁ ' ? ' : case ▁ ' * ' : case ▁ ' ] ' : case ▁ ' [ ' : result . setCharAt ( i , ▁ replaceChar ) ; break ; case ▁ ' \ ' ' : if ▁ ( i == 0 ▁ || ▁ i == length - 1 ) ▁ { result . setCharAt ( i , ▁ replaceChar ) ; } break ; default : } } return ▁ result . toString ( ) ; }
public String readLine ( ) throws IOException { return primitiveTypes . readLine ( ) ; }
public void setParentIds ( ObjectId ... newParents ) { parentIds = new ObjectId [ newParents . length ] ; for ( int i = 0 ; i < newParents . length ; i ++ ) parentIds [ i ] = newParents [ i ] . copy ( ) ; }
public LexerATNConfig ( LexerATNConfig c , ATNState state , LexerActionExecutor lexerActionExecutor ) { super ( c , state , c . context , c . semanticContext ) ; this . lexerActionExecutor = lexerActionExecutor ; this . passedThroughNonGreedyDecision = checkNonGreedyDecision ( c , state ) ; }
public NormValueSource ( String field ) { this . field = field ; }
public static boolean equalsIgnoreCase ( String a , String b ) { if ( References . isSameObject ( a , b ) ) { return true ; } if ( a . length ( ) != b . length ( ) ) return false ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { if ( toLowerCase ( a . charAt ( i ) ) != toLowerCase ( b . charAt ( i ) ) ) return false ; } return true ; }
public String getName ( ) { return attributes . getName ( ) ; }
public float getDistance ( String s1 , String s2 ) { int [ ] mtp = matches ( s1 , s2 ) ; float m = mtp [ 0 ] ; if ( m == 0 ) { return 0f ; } float j = ( ( m / s1. length ( ) + m / s2. length ( ) + ( m - mtp [ 1 ] ) / m ) ) / 3 ; float jw = j < getThreshold ( ) ? j : j + Math . min ( 0.1f , 1f / mtp [ 3 ] ) * mtp [ 2 ] * ( 1 - j ) ; return jw ; }
public TokenGroup ( TokenStream tokenStream ) { offsetAtt = tokenStream . addAttribute ( OffsetAttribute . class ) ; termAtt = tokenStream . addAttribute ( CharTermAttribute . class ) ; }
public String getString ( int i ) { return getString ( i , i + 1 , true ) ; }
public int getCountRead ( ) { return _countRead ; }
public CreateNetworkAclEntryResult createNetworkAclEntry ( CreateNetworkAclEntryRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNetworkAclEntry ( request ) ; }
public BreakIteratorBoundaryScanner ( BreakIterator bi ) { this . bi = bi ; }
public int getOffsetGap ( String fieldName ) { return getWrappedAnalyzer ( fieldName ) . getOffsetGap ( fieldName ) ; }
public static double [ ] grow ( double [ ] array ) { return grow ( array , 1 + array . length ) ; }
public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( initialise ( currentTokenVal , expectedTokenSequencesVal , tokenImageVal ) ) ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ PLOTAREA ] \ n " ) ; buffer . append ( " [ / PLOTAREA ] \ n " ) ; return buffer . toString ( ) ; }
public DescribeClustersResult describeClusters ( ) { return describeClusters ( new DescribeClustersRequest ( ) ) ; }
public void setDoubleValue ( double value ) { super . setLongValue ( Double . doubleToRawLongBits ( value ) ) ; }
public CreateSolutionResult createSolution ( CreateSolutionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSolution ( request ) ; }
public static Packed64SingleBlock create ( int valueCount , int bitsPerValue ) { switch ( bitsPerValue ) { case 1 : return new Packed64SingleBlock1 ( valueCount ) ; case 2 : return new Packed64SingleBlock2 ( valueCount ) ; case 3 : return new Packed64SingleBlock3 ( valueCount ) ; case 4 : return new Packed64SingleBlock4 ( valueCount ) ; case 5 : return new Packed64SingleBlock5 ( valueCount ) ; case 6 : return new Packed64SingleBlock6 ( valueCount ) ; case 7 : return new Packed64SingleBlock7 ( valueCount ) ; case 8 : return new Packed64SingleBlock8 ( valueCount ) ; case 9 : return new Packed64SingleBlock9 ( valueCount ) ; case 10 : return new Packed64SingleBlock10 ( valueCount ) ; case 12 : return new Packed64SingleBlock12 ( valueCount ) ; case 16 : return new Packed64SingleBlock16 ( valueCount ) ; case 21 : return new Packed64SingleBlock21 ( valueCount ) ; case 32 : return new Packed64SingleBlock32 ( valueCount ) ; default : throw new IllegalArgumentException ( " Unsupported ▁ number ▁ of ▁ bits ▁ per ▁ value : ▁ " + 32 ) ; } }
public FieldAndTerm clone ( ) { return new FieldAndTerm ( this ) ; }
public DescribeAlgorithmResult describeAlgorithm ( DescribeAlgorithmRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAlgorithm ( request ) ; }
public InvalidClassException ( String className , String detailMessage ) { super ( detailMessage ) ; this . classname = className ; }
public ExportTransitGatewayRoutesResult exportTransitGatewayRoutes ( ExportTransitGatewayRoutesRequest request ) { request = beforeClientExecution ( request ) ; return executeExportTransitGatewayRoutes ( request ) ; }
public TokenStream create ( TokenStream input ) { final TokenStream filter = new TypeTokenFilter ( input , stopTypes , useWhitelist ) ; return filter ; }
public final void yyreset ( java . io . Reader reader ) { zzReader = reader ; zzAtBOL = true ; zzAtEOF = false ; zzEOFDone = false ; zzEndRead = zzStartRead = 0 ; zzCurrentPos = zzMarkedPos = 0 ; zzFinalHighSurrogate = 0 ; yyline = yychar = yycolumn = 0 ; zzLexicalState = YYINITIAL ; if ( zzBuffer . length > ZZ_BUFFERSIZE ) zzBuffer = new char [ ZZ_BUFFERSIZE ] ; }
public int compareTo ( SegmentInfoAndLevel other ) { return Float . compare ( other . level , level ) ; }
public FrenchMinimalStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public AreaErrPtg ( LittleEndianInput in ) { unused1 = in . readInt ( ) ; unused2 = in . readInt ( ) ; }
public String getRemoteTrackingBranch ( ) { return remoteTrackingBranch ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; FieldVals other = ( FieldVals ) obj ; if ( fieldName == null ) { if ( other . fieldName != null ) return false ; } else if ( ! fieldName . equals ( other . fieldName ) ) return false ; if ( maxEdits != other . maxEdits ) { return false ; } if ( prefixLength != other . prefixLength ) return false ; if ( queryString == null ) { return other . queryString == null ; } else return queryString . equals ( other . queryString ) ; }
public void setMaxChainLength ( int maxLen ) { maxChainLength = maxLen ; }
public DeleteReusableDelegationSetResult deleteReusableDelegationSet ( DeleteReusableDelegationSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteReusableDelegationSet ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ HEADER ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . header ▁ = ▁ " ) . append ( getText ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / HEADER ] \ n " ) ; return buffer . toString ( ) ; }
public void writeStringData ( String text ) { boolean is16bitEncoded = StringUtil . hasMultibyte ( text ) ; int keepTogetherSize = 1 + 1 ; int optionFlags = 0x00 ; if ( is16bitEncoded ) { optionFlags |= 0x01 ; keepTogetherSize += 1 ; } writeContinueIfRequired ( keepTogetherSize ) ; writeByte ( optionFlags ) ; writeCharacterData ( text , is16bitEncoded ) ; }
public void nextBuffer ( ) { if ( 1 + bufferUpto == buffers . length ) { byte [ ] [ ] newBuffers = new byte [ ArrayUtil . oversize ( buffers . length + 1 , NUM_BYTES_OBJECT_REF ) ] [ ] ; System . arraycopy ( buffers , 0 , newBuffers , 0 , buffers . length ) ; buffers = newBuffers ; } buffer = buffers [ 1 + bufferUpto ] = allocator . getByteBlock ( ) ; bufferUpto ++ ; byteUpto = 0 ; byteOffset += BYTE_BLOCK_SIZE ; }
public LruTaxonomyWriterCache ( int cacheSize , LRUType lruType ) { if ( lruType == LRUType . LRU_HASHED ) { this . cache = new NameHashIntCacheLRU ( cacheSize ) ; } else { this . cache = new NameIntCacheLRU ( cacheSize ) ; } }
public boolean isShowSeriesKey ( ) { return showSeriesKey . isSet ( field_1_options ) ; }
public static String toHex ( final byte [ ] value ) { StringBuilder retVal = new StringBuilder ( ) ; retVal . append ( ' [ ' ) ; if ( value != null && value . length > 0 ) { for ( int x = 0 ; x < value . length ; x ++ ) { if ( x > 0 ) { retVal . append ( " , ▁ " ) ; } retVal . append ( toHex ( value [ x ] ) ) ; } } retVal . append ( ' ] ' ) ; return retVal . toString ( ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeShort ( field_1_index_extern_sheet ) ; writeCoordinates ( out ) ; }
public void flush ( ) { writer . flush ( ) ; }
public UsernamePasswordCredentialsProvider ( String username , char [ ] password ) { this . username = username ; this . password = password ; }
public final List < String > getFooterLines ( FooterKey keyName ) { final List < FooterLine > src = getFooterLines ( ) ; if ( src . isEmpty ( ) ) return Collections . emptyList ( ) ; final ArrayList < String > r = new ArrayList <> ( src . size ( ) ) ; for ( FooterLine f : src ) { if ( f . matches ( keyName ) ) r . add ( f . getValue ( ) ) ; } return r ; }
public ActivityTaskStatus recordActivityTaskHeartbeat ( RecordActivityTaskHeartbeatRequest request ) { request = beforeClientExecution ( request ) ; return executeRecordActivityTaskHeartbeat ( request ) ; }
public DescribeStepResult describeStep ( DescribeStepRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStep ( request ) ; }
public DeleteMessageBatchResult deleteMessageBatch ( String queueUrl , java . util . List < DeleteMessageBatchRequestEntry > entries ) { return deleteMessageBatch ( new DeleteMessageBatchRequest ( ) . withQueueUrl ( queueUrl ) . withEntries ( entries ) ) ; }
public QueryScorer ( Query query , IndexReader reader , String field ) { init ( query , field , reader , true ) ; }
public CreateVpcPeeringAuthorizationResult createVpcPeeringAuthorization ( CreateVpcPeeringAuthorizationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVpcPeeringAuthorization ( request ) ; }
public boolean contains ( Object object ) { if ( object != null ) { for ( E element : a ) { if ( object . equals ( element ) ) { return true ; } } } else { for ( E element : a ) { if ( element == null ) { return true ; } } } return false ; }
public DescribeDBSubnetGroupsResult describeDBSubnetGroups ( DescribeDBSubnetGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBSubnetGroups ( request ) ; }
public JobFlowExecutionStatusDetail ( JobFlowExecutionState state , java . util . Date creationDateTime ) { setState ( state . toString ( ) ) ; setCreationDateTime ( creationDateTime ) ; }
public String toString ( ) { return " more " ; }
public KeyValue ( String key , String value ) { setKey ( key ) ; setValue ( value ) ; }
public void balancedTree ( Object [ ] tokens , Object [ ] vals , int lo , int hi , TernaryTreeNode root ) { if ( lo > hi ) return ; int mid = ( lo + hi ) / 2 ; root = insert ( root , ( String ) tokens [ mid ] , vals [ mid ] , 0 ) ; balancedTree ( tokens , vals , lo , mid - 1 , root ) ; balancedTree ( tokens , vals , mid + 1 , hi , root ) ; }
public PlotAreaRecord clone ( ) { return copy ( ) ; }
public DeleteSecurityConfigurationResult deleteSecurityConfiguration ( DeleteSecurityConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSecurityConfiguration ( request ) ; }
@ Override public String toString ( ) { return mapEntry . toString ( ) ; }
public byte [ ] getCachedBytes ( int sizeLimit ) throws LargeObjectException , MissingObjectException , IOException { if ( ! isLarge ( ) ) return getCachedBytes ( ) ; try ( ObjectStream in = openStream ( ) ) { long sz = in . getSize ( ) ; if ( sizeLimit < sz ) throw new LargeObjectException . ExceedsLimit ( sizeLimit , sz ) ; if ( Integer . MAX_VALUE < sz ) throw new LargeObjectException . ExceedsByteArrayLimit ( ) ; byte [ ] buf ; try { buf = new byte [ ( int ) sz ] ; } catch ( OutOfMemoryError notEnoughHeap ) { throw new LargeObjectException . OutOfMemory ( notEnoughHeap ) ; } IO . readFully ( in , buf , 0 , buf . length ) ; return buf ; } }
public ListJobsByStatusResult listJobsByStatus ( ListJobsByStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeListJobsByStatus ( request ) ; }
public UpdateClusterVersionResult updateClusterVersion ( UpdateClusterVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateClusterVersion ( request ) ; }
public PushCommand setForce ( boolean force ) { checkCallable ( ) ; this . force = force ; return this ; }
public ListStreamsResult listStreams ( ListStreamsRequest request ) { request = beforeClientExecution ( request ) ; return executeListStreams ( request ) ; }
public boolean wasEscaped ( int index ) { return this . wasEscaped [ index ] ; }
public void setNewObjectId ( AnyObjectId id ) { newValue = id . copy ( ) ; }
public BatchRefUpdate newBatchUpdate ( ) { return new BatchRefUpdate ( this ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ( fields = " + fields . size ( ) + " , delegate = " + postingsReader + " ) " ; }
public CreateTrafficMirrorFilterRuleResult createTrafficMirrorFilterRule ( CreateTrafficMirrorFilterRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTrafficMirrorFilterRule ( request ) ; }
public SendEventResult sendEvent ( SendEventRequest request ) { request = beforeClientExecution ( request ) ; return executeSendEvent ( request ) ; }
public MissingRowDummyRecord ( int rowNumber ) { this . rowNumber = rowNumber ; }
public final int getLengthB ( ) { return endB - beginB ; }
public void decode ( long [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; for ( int shift = 63 ; shift >= 0 ; shift -= 1 ) { values [ valuesOffset ++ ] = ( int ) ( ( block >>> shift ) & 1 ) ; } } }
public void writeInt ( int value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeInt ( value ) ; }
public ByteBuffer putInt ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; }
public K next ( ) { return super . nextEntry ( ) . getKey ( ) ; }
public RenameDetectionType getRenameDetectionType ( ) { return renameDetectionType ; }
public ReplaceNetworkAclAssociationResult replaceNetworkAclAssociation ( ReplaceNetworkAclAssociationRequest request ) { request = beforeClientExecution ( request ) ; return executeReplaceNetworkAclAssociation ( request ) ; }
public String getFontName ( ) { return _fontName ; }
public ViewSourceRecord ( RecordInputStream in ) { vs = in . readShort ( ) ; }
public boolean hasTrackingRefUpdate ( ) { return trackingRefUpdate != null ; }
public boolean matches ( int symbol , int minVocabSymbol , int maxVocabSymbol ) { return set . contains ( symbol ) ; }
public ValueEval evaluate ( EvaluationCell srcCell ) { int sheetIndex = getSheetIndex ( srcCell . getSheet ( ) ) ; return evaluateAny ( srcCell , sheetIndex , srcCell . getRowIndex ( ) , srcCell . getColumnIndex ( ) , new EvaluationTracker ( _cache ) ) ; }
public AcceptTransitGatewayVpcAttachmentResult acceptTransitGatewayVpcAttachment ( AcceptTransitGatewayVpcAttachmentRequest request ) { request = beforeClientExecution ( request ) ; return executeAcceptTransitGatewayVpcAttachment ( request ) ; }
public String toString ( ) { return " < opaque ▁ schema = ' " ▁ + ▁ this . schema ▁ + ▁ " ' ▁ value = ' " ▁ + ▁ this . value ▁ + ▁ " ' /> " ; }
public static FuzzySet createSetBasedOnQuality ( int maxNumUniqueValues , float desiredMaxSaturation ) { int setSize = getNearestSetSize ( maxNumUniqueValues , desiredMaxSaturation ) ; return new FuzzySet ( new FixedBitSet ( setSize + 1 ) , setSize , hashFunctionForVersion ( VERSION_CURRENT ) ) ; }
public DeregisterInstancesFromLoadBalancerRequest ( String loadBalancerName , java . util . List < Instance > instances ) { setLoadBalancerName ( loadBalancerName ) ; setInstances ( instances ) ; }
public DeleteIntegrationResult deleteIntegration ( DeleteIntegrationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteIntegration ( request ) ; }
public Ref3DPtg ( LittleEndianInput in ) { field_1_index_extern_sheet = in . readShort ( ) ; readCoordinates ( in ) ; }
public synchronized E peek ( ) { try { return ( E ) elementData [ elementCount - 1 ] ; } catch ( IndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } }
public CheckDomainTransferabilityResult checkDomainTransferability ( CheckDomainTransferabilityRequest request ) { request = beforeClientExecution ( request ) ; return executeCheckDomainTransferability ( request ) ; }
@ Override public Iterator < K > iterator ( ) { return new MultisetKeyIterator ( ) ; }
public InitiateJobResult initiateJob ( InitiateJobRequest request ) { request = beforeClientExecution ( request ) ; return executeInitiateJob ( request ) ; }
public StempelPolishStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void removeLastAuthor ( ) { remove1stProperty ( PropertyIDMap . PID_LASTAUTHOR ) ; }
public void decRef ( ) { final int rc = refCount . decrementAndGet ( ) ; assert rc >= 0 : " seg = " + info ; }
public String toString ( ) { return " < fuzzy ▁ field = ' " ▁ + ▁ this . field ▁ + ▁ " ' ▁ similarity = ' " ▁ + ▁ this . similarity + ▁ " ' ▁ term = ' " ▁ + ▁ this . text ▁ + ▁ " ' /> " ; }
public static void putCompressedUnicode ( String input , LittleEndianOutput out ) { byte [ ] bytes = input . getBytes ( ISO_8859_1 ) ; out . write ( bytes ) ; }
public void append ( final BytesRef bytes ) { int bytesLeft = bytes . length ; int offset = bytes . offset ; while ( bytesLeft > 0 ) { int bufferLeft = BYTE_BLOCK_SIZE - byteUpto ; if ( bytesLeft < bufferLeft ) { System . arraycopy ( bytes . bytes , offset , buffer , byteUpto , bytesLeft ) ; byteUpto += bytesLeft ; break ; } else { if ( bufferLeft > 0 ) { System . arraycopy ( bytes . bytes , offset , buffer , byteUpto , bufferLeft ) ; } nextBuffer ( ) ; bytesLeft -= bufferLeft ; offset += bufferLeft ; } } }
public GetBundlesResult getBundles ( GetBundlesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetBundles ( request ) ; }
public StopAssessmentRunResult stopAssessmentRun ( StopAssessmentRunRequest request ) { request = beforeClientExecution ( request ) ; return executeStopAssessmentRun ( request ) ; }
public CreateFolderResult createFolder ( CreateFolderRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFolder ( request ) ; }
public ChangeResourceRecordSetsRequest ( String hostedZoneId , ChangeBatch changeBatch ) { setHostedZoneId ( hostedZoneId ) ; setChangeBatch ( changeBatch ) ; }
public CreateDeploymentStrategyResult createDeploymentStrategy ( CreateDeploymentStrategyRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDeploymentStrategy ( request ) ; }
public DeleteCacheClusterRequest ( String cacheClusterId ) { setCacheClusterId ( cacheClusterId ) ; }
public final ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { switch ( args . length ) { case 2 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] ) ; case 3 : return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; } return ErrorEval . VALUE_INVALID ; }
public GroupingSearch setAllGroupHeads ( boolean allGroupHeads ) { this . allGroupHeads = allGroupHeads ; return this ; }
public String dequote ( String in ) { final byte [ ] b = Constants . encode ( in ) ; return dequote ( b , 0 , b . length ) ; }
public boolean isEmpty ( ) { return entrySet ( ) . isEmpty ( ) ; }
public Query makeLuceneQueryFieldNoBoost ( String fieldName , BasicQueryFactory qf ) { return SrndBooleanQuery . makeBooleanQuery ( makeLuceneSubQueriesField ( fieldName , qf ) , BooleanClause . Occur . MUST ) ; }
public long getSize ( ) { return data . length ; }
public CreatePhoneNumberOrderResult createPhoneNumberOrder ( CreatePhoneNumberOrderRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePhoneNumberOrder ( request ) ; }
public ShortBuffer get ( short [ ] dst , int dstOffset , int shortCount ) { byteBuffer . limit ( limit * SizeOf . SHORT ) ; byteBuffer . position ( position * SizeOf . SHORT ) ; if ( byteBuffer instanceof DirectByteBuffer ) { ( ( DirectByteBuffer ) byteBuffer ) . get ( dst , dstOffset , shortCount ) ; } else { ( ( HeapByteBuffer ) byteBuffer ) . get ( dst , dstOffset , shortCount ) ; } this . position += shortCount ; return this ; }
public DetectModerationLabelsResult detectModerationLabels ( DetectModerationLabelsRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectModerationLabels ( request ) ; }
public UncalcedRecord ( RecordInputStream in ) { _reserved = in . readShort ( ) ; }
public String handlePart ( Matcher m , String part , CellFormatType type , StringBuffer desc ) { int pos = desc . length ( ) ; char firstCh = part . charAt ( 0 ) ; switch ( firstCh ) { case ' [ ' : if ( part . length ( ) < 3 ) break ; if ( topmost != null ) throw new IllegalArgumentException ( " Duplicate ▁ ' [ ' ▁ times ▁ in ▁ format " ) ; part = part . toLowerCase ( Locale . ROOT ) ; int specLen = part . length ( ) - 2 ; topmost = assignSpec ( part . charAt ( 1 ) , pos , specLen ) ; return part . substring ( 1 , 1 + specLen ) ; case ' h ' : case ' m ' : case ' s ' : case ' 0 ' : part = part . toLowerCase ( Locale . ROOT ) ; assignSpec ( part . charAt ( 0 ) , pos , part . length ( ) ) ; return part ; case ' \ n ' : return " % n " ; case ' \ " ' : part = part . substring ( 1 , part . length ( ) - 1 ) ; break ; case ' \\ ' : part ▁ = ▁ part . substring ( 1 ) ; break ; case ▁ ' * ' : if ▁ ( part . length ( ) ▁ > ▁ 1 ) part ▁ = ▁ CellFormatPart . expandChar ( part ) ; break ; case ▁ ' _ ' : return ▁ null ; } return ▁ PERCENTS . matcher ( part ) . replaceAll ( " %% " ) ; }
public long ramBytesUsed ( ) { long sizeInBytes = ( ( delegateFieldsProducer != null ) ? delegateFieldsProducer . ramBytesUsed ( ) : 0 ) ; for ( Map . Entry < String , FuzzySet > entry : bloomsByFieldName . entrySet ( ) ) { sizeInBytes += entry . getKey ( ) . length ( ) * Character . BYTES ; sizeInBytes += entry . getValue ( ) . ramBytesUsed ( ) ; } return sizeInBytes ; }
public CreateImageRequest ( String instanceId , String name ) { setInstanceId ( instanceId ) ; setName ( name ) ; }
public SendDiagnosticInterruptResult sendDiagnosticInterrupt ( SendDiagnosticInterruptRequest request ) { request = beforeClientExecution ( request ) ; return executeSendDiagnosticInterrupt ( request ) ; }
public int lastIndexOf ( Object object ) { Object [ ] snapshot = elements ; return lastIndexOf ( object , snapshot , 0 , snapshot . length ) ; }
public AbortDocumentVersionUploadResult abortDocumentVersionUpload ( AbortDocumentVersionUploadRequest request ) { request = beforeClientExecution ( request ) ; return executeAbortDocumentVersionUpload ( request ) ; }
public PaneInformation ( short x , short y , short top , short left , byte active , boolean frozen ) { this . x = x ; this . y = y ; this . topRow = top ; this . leftColumn = left ; this . activePane = active ; this . frozen = frozen ; }
public DescribeScalingProcessTypesResult describeScalingProcessTypes ( DescribeScalingProcessTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeScalingProcessTypes ( request ) ; }
public static boolean endsWith ( char s [ ] , int len , char suffix [ ] ) { final int suffixLen = suffix . length ; if ( suffixLen > len ) return false ; for ( int i = suffixLen - 1 ; i >= 0 ; i -- ) if ( s [ len - ( suffixLen - i ) ] != suffix [ i ] ) return false ; return true ; }
public void warnIfOpen ( ) { if ( allocationSite == null || ! ENABLED ) { return ; } String message = ( " A ▁ resource ▁ was ▁ acquired ▁ at ▁ attached ▁ stack ▁ trace ▁ but ▁ never ▁ released . ▁ " + " See ▁ java . io . Closeable ▁ for ▁ information ▁ on ▁ avoiding ▁ resource ▁ leaks . " ) ; REPORTER . report ( message , allocationSite ) ; }
public GetImageScanRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetImageScan " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / tags / [ Tag ] / scan " ) ; setMethod ( MethodType . GET ) ; }
public ListSkillsStoreCategoriesResult listSkillsStoreCategories ( ListSkillsStoreCategoriesRequest request ) { request = beforeClientExecution ( request ) ; return executeListSkillsStoreCategories ( request ) ; }
public int getHeight ( ) { return mImage . getHeight ( ) ; }
public void applyFont ( Font font ) { applyFont ( 0 , _string . getCharCount ( ) , font ) ; }
public DetectEntitiesResult detectEntities ( DetectEntitiesRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectEntities ( request ) ; }
public void copyRawTo ( ByteBuffer w ) { w . putInt ( w1 ) ; w . putInt ( w2 ) ; w . putInt ( w3 ) ; w . putInt ( w4 ) ; w . putInt ( w5 ) ; }
public final char [ ] array ( ) { return protectedArray ( ) ; }
public void seekExact ( long ord ) throws IOException { if ( indexEnum == null ) { throw new IllegalStateException ( " terms ▁ index ▁ was ▁ not ▁ loaded " ) ; } assert ord < numTerms ; in . seek ( indexEnum . seek ( ord ) ) ; boolean result = nextBlock ( ) ; assert result ; indexIsCurrent = true ; didIndexNext = false ; seekPending = false ; state . ord = indexEnum . ord ( ) - 1 ; assert state . ord >= - 1 : " ord = " + state . ord ; term . copyBytes ( indexEnum . term ( ) ) ; int left = ( int ) ( ord - state . ord ) ; while ( left > 0 ) { final BytesRef term = _next ( ) ; assert term != null ; left -- ; assert indexIsCurrent ; } }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ' [ ' ) ; final int end = offset + length ; for ( int i = offset ; i < end ; i ++ ) { if ( i > offset ) { sb . append ( ' ▁ ' ) ; } sb . append ( Integer . toHexString ( bytes [ i ] & 0xff ) ) ; } sb . append ( ' ] ' ) ; return sb . toString ( ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " ▁ [ FEATURE ▁ PROTECTION ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ Self ▁ Relative ▁ = ▁ " + fSD ) ; buffer . append ( " ▁ ▁ ▁ Password ▁ Verifier ▁ = ▁ " + passwordVerifier ) ; buffer . append ( " ▁ ▁ ▁ Title ▁ = ▁ " + title ) ; buffer . append ( " ▁ ▁ ▁ Security ▁ Descriptor ▁ Size ▁ = ▁ " + securityDescriptor . length ) ; buffer . append ( " ▁ [ / FEATURE ▁ PROTECTION ] \ n " ) ; return buffer . toString ( ) ; }
public void setCRC ( int crc32 ) { crc = crc32 ; }
public DoubleRange ( String label , double minIn , boolean minInclusive , double maxIn , boolean maxInclusive ) { super ( label ) ; if ( Double . isNaN ( minIn ) ) { throw new IllegalArgumentException ( " min ▁ cannot ▁ be ▁ NaN " ) ; } if ( ! minInclusive ) { minIn = Math . nextUp ( minIn ) ; } if ( Double . isNaN ( maxIn ) ) { throw new IllegalArgumentException ( " max ▁ cannot ▁ be ▁ NaN " ) ; } if ( ! maxInclusive ) { maxIn = Math . nextAfter ( maxIn , Double . NEGATIVE_INFINITY ) ; } if ( minIn > maxIn ) { failNoMatch ( ) ; } this . min = minIn ; this . max = maxIn ; }
public int getBATEntriesPerBlock ( ) { return bigBlockSize / LittleEndianConsts . INT_SIZE ; }
public CreatePublishingDestinationResult createPublishingDestination ( CreatePublishingDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePublishingDestination ( request ) ; }
public void skipBytes ( long count ) { pos += count ; }
public String toString ( ) { return " jarowinkler ( " + threshold + " ) " ; }
public DeleteInvitationsResult deleteInvitations ( DeleteInvitationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteInvitations ( request ) ; }
public DelimitedPayloadTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; encoderClass = require ( args , ENCODER_ATTR ) ; delimiter = getChar ( args , DELIMITER_ATTR , ' | ' ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public ListSmartHomeAppliancesResult listSmartHomeAppliances ( ListSmartHomeAppliancesRequest request ) { request = beforeClientExecution ( request ) ; return executeListSmartHomeAppliances ( request ) ; }
public void dispatch ( ConfigChangedListener listener ) { listener . onConfigChanged ( this ) ; }
public File [ ] listFiles ( ) { return filenamesToFiles ( list ( ) ) ; }
public DedicatedCapacityInner getByResourceGroup ( String resourceGroupName , String dedicatedCapacityName ) { return getByResourceGroupWithServiceResponseAsync ( resourceGroupName , dedicatedCapacityName ) . toBlocking ( ) . single ( ) . body ( ) ; }
public void seekExact ( long ord ) { assert ord < info . terms . size ( ) ; termUpto = ( int ) ord ; info . terms . get ( info . sortedTerms [ termUpto ] , br ) ; }
public CreateTrialComponentResult createTrialComponent ( CreateTrialComponentRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTrialComponent ( request ) ; }
public UpdateResourceResult updateResource ( UpdateResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateResource ( request ) ; }
public long length ( ) { try { return channel . size ( ) ; } catch ( IOException ioe ) { throw new RuntimeException ( " IOException ▁ during ▁ length ( ) : ▁ " + this , ioe ) ; } }
public char setIndex ( int position ) { if ( position < getBeginIndex ( ) || position > getEndIndex ( ) ) throw new IllegalArgumentException ( " Illegal ▁ Position : ▁ " + position ) ; index = start + position ; return current ( ) ; }
public static boolean isContainer ( short options , short recordId ) { if ( recordId >= EscherContainerRecord . DGG_CONTAINER && recordId <= EscherContainerRecord . SOLVER_CONTAINER ) { return true ; } else { if ( recordId == EscherTextboxRecord . RECORD_ID ) { return false ; } else { return ( options & ( short ) 0x000F ) == ( short ) 0x000F ; } } }
public boolean exists ( String fileName ) { assert locked ( ) ; if ( ! refCounts . containsKey ( fileName ) ) { return false ; } else { return getRefCount ( fileName ) . count > 0 ; } }
public STSAssumeRoleSessionCredentialsProvider withSTSClient ( IAcsClient client ) { this . stsClient = client ; return this ; }
public AcceptMatchResult acceptMatch ( AcceptMatchRequest request ) { request = beforeClientExecution ( request ) ; return executeAcceptMatch ( request ) ; }
public static RevFilter create ( int skip ) { if ( skip < 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . skipMustBeNonNegative ) ; return new SkipRevFilter ( skip ) ; }
public GetHITResult getHIT ( GetHITRequest request ) { request = beforeClientExecution ( request ) ; return executeGetHIT ( request ) ; }
public StopStreamProcessorResult stopStreamProcessor ( StopStreamProcessorRequest request ) { request = beforeClientExecution ( request ) ; return executeStopStreamProcessor ( request ) ; }
public static AttrPtg createIf ( int dist ) { return new AttrPtg ( optiIf . set ( 0 ) , dist , null , - 1 ) ; }
public DeleteIAMPolicyAssignmentResult deleteIAMPolicyAssignment ( DeleteIAMPolicyAssignmentRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteIAMPolicyAssignment ( request ) ; }
public UpdateCampaignResult updateCampaign ( UpdateCampaignRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateCampaign ( request ) ; }
public LexerActionExecutor fixOffsetBeforeMatch ( int offset ) { LexerAction [ ] updatedLexerActions = null ; for ( int i = 0 ; i < lexerActions . length ; i ++ ) { if ( lexerActions [ i ] . isPositionDependent ( ) && ! ( lexerActions [ i ] instanceof LexerIndexedCustomAction ) ) { if ( updatedLexerActions == null ) { updatedLexerActions = lexerActions . clone ( ) ; } updatedLexerActions [ i ] = new LexerIndexedCustomAction ( offset , lexerActions [ i ] ) ; } } if ( updatedLexerActions == null ) { return this ; } return new LexerActionExecutor ( updatedLexerActions ) ; }
public void protectSheet ( String password , boolean shouldProtectObjects , boolean shouldProtectScenarios ) { if ( password == null ) { _passwordRecord = null ; _protectRecord = null ; _objectProtectRecord = null ; _scenarioProtectRecord = null ; return ; } ProtectRecord prec = getProtect ( ) ; PasswordRecord pass = getPassword ( ) ; prec . setProtect ( true ) ; pass . setPassword ( ( short ) CryptoFunctions . createXorVerifier1 ( password ) ) ; if ( _objectProtectRecord == null && shouldProtectObjects ) { ObjectProtectRecord rec = createObjectProtect ( ) ; rec . setProtect ( true ) ; _objectProtectRecord = rec ; } if ( _scenarioProtectRecord == null && shouldProtectScenarios ) { ScenarioProtectRecord srec = createScenarioProtect ( ) ; srec . setProtect ( true ) ; _scenarioProtectRecord = srec ; } }
public PackedDataOutput ( DataOutput out ) { this . out = out ; current = 0 ; remainingBits = 8 ; }
public CFRuleBase getRule ( int idx ) { checkRuleIndex ( idx ) ; return rules . get ( idx ) ; }
public FieldCacheSource ( String field ) { this . field = field ; }
public IndonesianStemFilterFactory ( Map < String , String > args ) { super ( args ) ; stemDerivational = getBoolean ( args , " stemDerivational " , true ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public boolean isOffsetOverlap ( WeightedPhraseInfo other ) { int so = getStartOffset ( ) ; int eo = getEndOffset ( ) ; int oso = other . getStartOffset ( ) ; int oeo = other . getEndOffset ( ) ; if ( so <= oso && oso < eo ) return true ; if ( so < oeo && oeo <= eo ) return true ; if ( oso <= so && so < oeo ) return true ; if ( oso < eo && eo <= oeo ) return true ; return false ; }
public MergeAlgorithm ( DiffAlgorithm diff ) { this . diffAlg = diff ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( field_1_xAxisUpperLeft ) ; out . writeInt ( field_2_yAxisUpperLeft ) ; out . writeInt ( field_3_xSize ) ; out . writeInt ( field_4_ySize ) ; out . writeByte ( field_5_type ) ; out . writeByte ( field_6_spacing ) ; out . writeShort ( field_7_options ) ; }
public long get ( int index ) { final int o = index / 21 ; final int b = index % 21 ; final int shift = b * 3 ; return ( blocks [ o ] >>> shift ) & 7L ; }
public CodingErrorAction unmappableCharacterAction ( ) { return unmappableCharacterAction ; }
public Set < String > getSet ( Map < String , String > args , String name ) { String s = args . remove ( name ) ; if ( s == null ) { return null ; } else { Set < String > set = null ; Matcher matcher = ITEM_PATTERN . matcher ( s ) ; if ( matcher . find ( ) ) { set = new HashSet <> ( ) ; set . add ( matcher . group ( 0 ) ) ; while ( matcher . find ( ) ) { set . add ( matcher . group ( 0 ) ) ; } } return set ; } }
public AbstractTreeIterator createSubtreeIterator ( ObjectReader reader ) throws IncorrectObjectTypeException , IOException { if ( currentSubtree == null ) throw new IncorrectObjectTypeException ( getEntryObjectId ( ) , Constants . TYPE_TREE ) ; return new DirCacheIterator ( this , currentSubtree ) ; }
public Explanation [ ] getDetails ( ) { return details . toArray ( new Explanation [ 0 ] ) ; }
public String toString ( ) { if ( text == null ) { return " < DeleteOp @ " + tokens . get ( index ) + " .. " + tokens . get ( lastIndex ) + " > " ; } return " < ReplaceOp @ " + tokens . get ( index ) + " .. " + tokens . get ( lastIndex ) + " :\ " " + text + " \ " > " ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ TopMargin ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . margin ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " ▁ ( " ) . append ( getMargin ( ) ) . append ( " ▁ ) \ n " ) ; buffer . append ( " [ / TopMargin ] \ n " ) ; return buffer . toString ( ) ; }
static public double fv ( double r , int nper , double c , double pv ) { return fv ( r , nper , c , pv , 0 ) ; }
@ Override public boolean remove ( Object object ) { Object [ ] a = array ; int s = size ; if ( object != null ) { for ( int i = 0 ; i < s ; i ++ ) { if ( object . equals ( a [ i ] ) ) { System . arraycopy ( a , i + 1 , a , i , -- s - i ) ; a [ s ] = null ; size = s ; modCount ++ ; return true ; } } } else { for ( int i = 0 ; i < s ; i ++ ) { if ( a [ i ] == null ) { System . arraycopy ( a , i + 1 , a , i , -- s - i ) ; a [ s ] = null ; size = s ; modCount ++ ; return true ; } } } return false ; }
public MergeCellsRecord ( CellRangeAddress [ ] regions , int startIndex , int numberOfRegions ) { _regions = regions ; _startIndex = startIndex ; _numberOfRegions = numberOfRegions ; }
public Cluster resizeCluster ( ResizeClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeResizeCluster ( request ) ; }
public int getParent ( int ordinal ) throws IOException { ensureOpen ( ) ; Objects . checkIndex ( ordinal , nextID ) ; int [ ] parents = getTaxoArrays ( ) . parents ( ) ; assert ordinal < parents . length : " requested ▁ ordinal ▁ ( " + ordinal + " ) ; ▁ parents . length ▁ ( " + parents . length + " ) ▁ ! " ; return parents [ ordinal ] ; }
@ Override public Iterator < Multiset . Entry < E >> iterator ( ) { final Iterator < Map . Entry < E , AtomicInteger >> backingEntries = backingMap . entrySet ( ) . iterator ( ) ; return new Iterator < Multiset . Entry < E >> ( ) ; }
public int alloc ( int size ) { int index = n ; int len = array . length ; if ( n + size >= len ) { char [ ] aux = new char [ len + blockSize ] ; System . arraycopy ( array , 0 , aux , 0 , len ) ; array = aux ; } n += size ; return index ; }
public static String getInflectionTypeTranslation ( String s ) { return inflTypeTranslations . get ( s ) ; }
public Note call ( ) throws GitAPIException { checkCallable ( ) ; try ( RevWalk walk = new RevWalk ( repo ) ; ObjectInserter inserter = repo . newObjectInserter ( ) ) { NoteMap map = NoteMap . newEmptyMap ( ) ; RevCommit notesCommit = null ; Ref ref = repo . exactRef ( notesRef ) ; if ( ref != null ) { notesCommit = walk . parseCommit ( ref . getObjectId ( ) ) ; map = NoteMap . read ( walk . getObjectReader ( ) , notesCommit ) ; } map . set ( id , null , inserter ) ; AddNoteCommand . commitNoteMap ( repo , notesRef , walk , map , notesCommit , inserter , " Notes ▁ removed ▁ by ▁ ' git notes remove ' " ) ; return map . getNote ( id ) ; } catch ( IOException e ) { throw new JGitInternalException ( e . getMessage ( ) , e ) ; } }
public String getNewPath ( ) { return newPath ; }
public UserSViewBegin ( byte [ ] data ) { _rawData = data ; }
public CreateMountTargetResult createMountTarget ( CreateMountTargetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateMountTarget ( request ) ; }
public DeleteSubnetRequest ( String subnetId ) { setSubnetId ( subnetId ) ; }
public void setTitle ( String title ) { this . title = title ; }
public char current ( ) { if ( offset == end ) { return DONE ; } return string . charAt ( offset ) ; }
public void add ( long n ) { if ( count == entries . length ) grow ( ) ; entries [ count ++ ] = n ; }
public FloatBuffer put ( int index , float c ) { checkIndex ( index ) ; backingArray [ offset + index ] = c ; return this ; }
public ListGroupPoliciesRequest ( String groupName ) { setGroupName ( groupName ) ; }
public void setDeltaSearchWindowSize ( int objectCount ) { if ( objectCount <= 2 ) setDeltaCompress ( false ) ; elsedeltaSearchWindowSize = objectCount ; }
public int nextDoc ( ) { while ( true ) { if ( queue . size ( ) == 0 ) { doc = NO_MORE_DOCS ; break ; } int newDoc = queue . top ( ) . docID ( ) ; if ( newDoc != doc ) { assert newDoc > doc : " doc = " + doc + " ▁ newDoc = " + newDoc ; doc = newDoc ; break ; } if ( queue . top ( ) . nextDoc ( ) == NO_MORE_DOCS ) { queue . pop ( ) ; } else { queue . updateTop ( ) ; } } return doc ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { final byte block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( block >>> 4 ) & 15 ; values [ valuesOffset ++ ] = block & 15 ; } }
public int getNameIndex ( String name ) { for ( int k = 0 ; k < names . size ( ) ; k ++ ) { String nameName = getNameName ( k ) ; if ( nameName . equalsIgnoreCase ( name ) ) { return k ; } } return - 1 ; }
public void seek ( int index ) { if ( index == currentCharIndex ) { return ; } if ( index > currentCharIndex ) { sync ( index - currentCharIndex ) ; index = Math . min ( index , getBufferStartIndex ( ) + n - 1 ) ; } int i = index - getBufferStartIndex ( ) ; if ( i < 0 ) { throw new IllegalArgumentException ( " cannot ▁ seek ▁ to ▁ negative ▁ index ▁ " + index ) ; } else if ( i >= n ) { throw new UnsupportedOperationException ( " seek ▁ to ▁ index ▁ outside ▁ buffer : ▁ " + index + " ▁ not ▁ in ▁ " + getBufferStartIndex ( ) + " .. " + ( getBufferStartIndex ( ) + n ) ) ; } p = i ; currentCharIndex = index ; if ( p == 0 ) { lastChar = lastCharBufferStart ; } else { lastChar = data [ p - 1 ] ; } }
public void readBytes ( byte [ ] b , int offset , int len ) { System . arraycopy ( data , pos , b , offset , len ) ; pos += len ; }
public ListGraphsResult listGraphs ( ListGraphsRequest request ) { request = beforeClientExecution ( request ) ; return executeListGraphs ( request ) ; }
public ATNDeserializer ( ATNDeserializationOptions deserializationOptions ) { if ( deserializationOptions == null ) { deserializationOptions = ATNDeserializationOptions . getDefaultOptions ( ) ; } this . deserializationOptions = deserializationOptions ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { values [ valuesOffset ++ ] = ( ( blocks [ blocksOffset ++ ] & 0xFF ) << 8 ) | ( blocks [ blocksOffset ++ ] & 0xFF ) ; } }
public CanonicalTreeParser getParent ( ) { return ( CanonicalTreeParser ) parent ; }
public DetectDominantLanguageResult detectDominantLanguage ( DetectDominantLanguageRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectDominantLanguage ( request ) ; }
public void removePageCount ( ) { remove1stProperty ( PropertyIDMap . PID_PAGECOUNT ) ; }
public E previous ( ) { if ( expectedModCount == modCount ) { try { E result = get ( pos ) ; lastPosition = pos ; pos -- ; return result ; } catch ( IndexOutOfBoundsException e ) { throw new NoSuchElementException ( ) ; } } throw new ConcurrentModificationException ( ) ; }
public String toString ( ) { final StringBuilder r = new StringBuilder ( ) ; r . append ( " ( " ) ; for ( int i = 0 ; i < subfilters . length ; i ++ ) { if ( i > 0 ) r . append ( " ▁ AND ▁ " ) ; r . append ( subfilters [ i ] . toString ( ) ) ; } r . append ( " ) " ) ; return r . toString ( ) ; }
public FooterRecord clone ( ) { return copy ( ) ; }
public int stem ( final char s [ ] , int len ) { if ( len < 4 ) return len ; if ( len > 5 && endsWith ( s , len , " ища " ) ) return len - 3 ; len = removeArticle ( s , len ) ; len = removePlural ( s , len ) ; if ( len > 3 ) { if ( endsWith ( s , len , " я " ) ) len -- ; if ( endsWith ( s , len , " а " ) || endsWith ( s , len , " о " ) || endsWith ( s , len , " е " ) ) len -- ; } if ( len > 4 && endsWith ( s , len , " ен " ) ) { s [ len - 2 ] = ' н ' ; len -- ; } if ( len > 5 && s [ len - 2 ] == ' ъ ' ) { s [ len - 2 ] = s [ len - 1 ] ; len -- ; } return len ; }
public synchronized CharSequence subSequence ( int start , int end ) { return super . substring ( start , end ) ; }
public DisableVpcClassicLinkDnsSupportResult disableVpcClassicLinkDnsSupport ( DisableVpcClassicLinkDnsSupportRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableVpcClassicLinkDnsSupport ( request ) ; }
public static FormulaError forInt ( byte type ) throws IllegalArgumentException { FormulaError err = bmap . get ( type ) ; if ( err == null ) throw new IllegalArgumentException ( " Unknown ▁ error ▁ type : ▁ " + type ) ; return err ; }
public void remove ( ) { if ( index == 0 ) throw new IllegalStateException ( ) ; BlockList . this . remove ( -- index ) ; dirIdx = toDirectoryIndex ( index ) ; blkIdx = toBlockIndex ( index ) ; block = directory [ dirIdx ] ; }
public String formatNumberDateCell ( CellValueRecordInterface cell ) { double value ; if ( cell instanceof NumberRecord ) { value = ( ( NumberRecord ) cell ) . getValue ( ) ; } else if ( cell instanceof FormulaRecord ) { value = ( ( FormulaRecord ) cell ) . getValue ( ) ; } else { throw new IllegalArgumentException ( " Unsupported ▁ CellValue ▁ Record ▁ passed ▁ in ▁ " + cell ) ; } int formatIndex = getFormatIndex ( cell ) ; String formatString = getFormatString ( cell ) ; if ( formatString == null ) { return _defaultFormat . format ( value ) ; } return _formatter . formatRawCellContents ( value , formatIndex , formatString ) ; }
public synchronized StringBuffer append ( Object obj ) { if ( obj == null ) { appendNull ( ) ; } else { append0 ( obj . toString ( ) ) ; } return this ; }
public String getUser ( ) { return user ; }
public CreateGraphResult createGraph ( CreateGraphRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateGraph ( request ) ; }
public static BytesRef toBytesRef ( IntsRef input , BytesRefBuilder scratch ) { scratch . grow ( input . length ) ; for ( int i = 0 ; i < input . length ; i ++ ) { int value = input . ints [ i + input . offset ] ; assert value >= Byte . MIN_VALUE && value <= 255 : " value ▁ " + value + " ▁ doesn ' t fit into byte " ; scratch . setByteAt ( i , ▁ ( byte ) ▁ value ) ; } scratch . setLength ( input . length ) ; return ▁ scratch . get ( ) ; }
public final DoubleBuffer asDoubleBuffer ( ) { return DoubleToByteBufferAdapter . asDoubleBuffer ( this ) ; }
public static final RevFilter between ( Date since , Date until ) { return between ( since . getTime ( ) , until . getTime ( ) ) ; }
public AreaEval offset ( int relFirstRowIx , int relLastRowIx , int relFirstColIx , int relLastColIx ) { AreaI area = new OffsetArea ( getRow ( ) , getColumn ( ) , relFirstRowIx , relLastRowIx , relFirstColIx , relLastColIx ) ; return new LazyAreaEval ( area , _evaluator ) ; }
public static void registerFunction ( String name , FreeRefFunction func ) { AnalysisToolPak . registerFunction ( name , func ) ; }
public CreateAutoMLJobResult createAutoMLJob ( CreateAutoMLJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAutoMLJob ( request ) ; }
public DefineIndexFieldResult defineIndexField ( DefineIndexFieldRequest request ) { request = beforeClientExecution ( request ) ; return executeDefineIndexField ( request ) ; }
public ListDomainNamesResult listDomainNames ( ListDomainNamesRequest request ) { request = beforeClientExecution ( request ) ; return executeListDomainNames ( request ) ; }
public CharBuffer put ( char c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } byteBuffer . putChar ( position ++ * SizeOf . CHAR , c ) ; return this ; }
public static PathFilter create ( String path ) { while ( path . endsWith ( " / " ) ) path = path . substring ( 0 , path . length ( ) - 1 ) ; if ( path . length ( ) == 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . emptyPathNotPermitted ) ; return new PathFilter ( path ) ; }
public final String toString ( ) { return String . copyValueOf ( backingArray , offset + position , remaining ( ) ) ; }
public char first ( ) { index = start ; return current ( ) ; }
public void growForward ( ) { forwardPos = ArrayUtil . grow ( forwardPos , 1 + forwardCount ) ; forwardID = ArrayUtil . grow ( forwardID , 1 + forwardCount ) ; forwardIndex = ArrayUtil . grow ( forwardIndex , 1 + forwardCount ) ; final Type [ ] newForwardType = new Type [ forwardPos . length ] ; System . arraycopy ( forwardType , 0 , newForwardType , 0 , forwardType . length ) ; forwardType = newForwardType ; }
public DescribeReplicationGroupsResult describeReplicationGroups ( DescribeReplicationGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReplicationGroups ( request ) ; }
public int getIndex ( T o ) { return valueKeyMap . getOrDefault ( o , - 1 ) ; }
public String toString ( ) { return " ( " + pred + " , ▁ " + alt + " ) " ; }
public DescribeRegionsResult describeRegions ( ) { return describeRegions ( new DescribeRegionsRequest ( ) ) ; }
public ModifyVpcEndpointConnectionNotificationResult modifyVpcEndpointConnectionNotification ( ModifyVpcEndpointConnectionNotificationRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVpcEndpointConnectionNotification ( request ) ; }
public QueryPhraseMap ( FieldQuery fieldQuery ) { this . fieldQuery = fieldQuery ; }
public DescribeAssessmentTemplatesResult describeAssessmentTemplates ( DescribeAssessmentTemplatesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAssessmentTemplates ( request ) ; }
public HunspellStemFilter ( TokenStream input , Dictionary dictionary , boolean dedup , boolean longestOnly ) { super ( input ) ; this . dedup = dedup && longestOnly == false ; this . stemmer = new Stemmer ( dictionary ) ; this . longestOnly = longestOnly ; }
public NameCommentRecord getNameCommentRecord ( final NameRecord nameRecord ) { return commentRecords . get ( nameRecord . getNameText ( ) ) ; }
public ScanRequest ( String tableName ) { setTableName ( tableName ) ; }
public AliasTarget ( String hostedZoneId , String dNSName ) { setHostedZoneId ( hostedZoneId ) ; setDNSName ( dNSName ) ; }
public ListOutgoingTypedLinksResult listOutgoingTypedLinks ( ListOutgoingTypedLinksRequest request ) { request = beforeClientExecution ( request ) ; return executeListOutgoingTypedLinks ( request ) ; }
public HsmConfiguration createHsmConfiguration ( CreateHsmConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateHsmConfiguration ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ BEGIN ] \ n " ) ; buffer . append ( " [ / BEGIN ] \ n " ) ; return buffer . toString ( ) ; }
public DisableDomainAutoRenewResult disableDomainAutoRenew ( DisableDomainAutoRenewRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableDomainAutoRenew ( request ) ; }
@ Override public boolean remove ( Object o ) { if ( ! ( o instanceof Entry ) ) { return false ; } Entry <? , ?> e = ( Entry <? , ?> ) o ; Object key = e . getKey ( ) ; return key != null && Impl . this . remove ( key , e . getValue ( ) ) ; }
public UpdateFindingsFeedbackResult updateFindingsFeedback ( UpdateFindingsFeedbackRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFindingsFeedback ( request ) ; }
public void setColorAtIndex ( short index , byte red , byte green , byte blue ) { _palette . setColor ( index , red , green , blue ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( rt ) ; out . writeShort ( grbitFrt ) ; out . writeByte ( verOriginator ) ; out . writeByte ( verWriter ) ; out . writeShort ( rgCFRTID . length ) ; for ( CFRTID cfrtid : rgCFRTID ) { cfrtid . serialize ( out ) ; } }
public RevokeInvitationResult revokeInvitation ( RevokeInvitationRequest request ) { request = beforeClientExecution ( request ) ; return executeRevokeInvitation ( request ) ; }
public GetTextDetectionResult getTextDetection ( GetTextDetectionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTextDetection ( request ) ; }
public void ensureCapacity ( int min ) { if ( min > value . length ) { int ourMin = value . length * 2 + 2 ; enlargeBuffer ( Math . max ( ourMin , min ) ) ; } }
public void write ( byte [ ] buffer , int byteOffset , int byteCount ) throws IOException { IoBridge . write ( fd , buffer , byteOffset , byteCount ) ; }
public DisassociateAddressResult disassociateAddress ( DisassociateAddressRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateAddress ( request ) ; }
public TagCommand setForceUpdate ( boolean forceUpdate ) { this . forceUpdate = forceUpdate ; return this ; }
public PageItemRecord ( RecordInputStream in ) { int dataSize = in . remaining ( ) ; if ( dataSize % FieldInfo . ENCODED_SIZE != 0 ) { throw new RecordFormatException ( " Bad ▁ data ▁ size ▁ " + dataSize ) ; } int nItems = dataSize / FieldInfo . ENCODED_SIZE ; FieldInfo [ ] fis = new FieldInfo [ nItems ] ; for ( int i = 0 ; i < fis . length ; i ++ ) { fis [ i ] = new FieldInfo ( in ) ; } _fieldInfos = fis ; }
public XPathTokenElement ( String tokenName , int tokenType ) { super ( tokenName ) ; this . tokenType = tokenType ; }
@ Override public boolean contains ( Object object ) { return indexOf ( object ) != - 1 ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_x ) ; out . writeShort ( field_2_y ) ; out . writeShort ( field_3_topRow ) ; out . writeShort ( field_4_leftColumn ) ; out . writeShort ( field_5_activePane ) ; }
public StepExecutionStatusDetail ( StepExecutionState state , java . util . Date creationDateTime ) { setState ( state . toString ( ) ) ; setCreationDateTime ( creationDateTime ) ; }
public EditEventRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " EditEvent " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public PurchaseHostReservationResult purchaseHostReservation ( PurchaseHostReservationRequest request ) { request = beforeClientExecution ( request ) ; return executePurchaseHostReservation ( request ) ; }
public ConfirmPrivateVirtualInterfaceResult confirmPrivateVirtualInterface ( ConfirmPrivateVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeConfirmPrivateVirtualInterface ( request ) ; }
public static int getVariantLength ( final long variantType ) { final Integer length = numberToLength . get ( variantType ) ; return ( length != null ) ? length : LENGTH_UNKNOWN ; }
public UnknownFormatFlagsException ( String f ) { if ( f == null ) { throw new NullPointerException ( ) ; } flags = f ; }
public boolean isFreezePane ( ) { return frozen ; }
public PurchaseReservedDBInstancesOfferingRequest ( String reservedDBInstancesOfferingId ) { setReservedDBInstancesOfferingId ( reservedDBInstancesOfferingId ) ; }
public HeaderBlock ( POIFSBigBlockSize bigBlockSize ) { this . bigBlockSize = bigBlockSize ; _data = new byte [ POIFSConstants . SMALLER_BIG_BLOCK_SIZE ] ; Arrays . fill ( _data , _default_value ) ; new LongField ( _signature_offset , _signature , _data ) ; new IntegerField ( 0x08 , 0 , _data ) ; new IntegerField ( 0x0c , 0 , _data ) ; new IntegerField ( 0x10 , 0 , _data ) ; new IntegerField ( 0x14 , 0 , _data ) ; new ShortField ( 0x18 , ( short ) 0x3b , _data ) ; new ShortField ( 0x1a , ( short ) 0x3 , _data ) ; new ShortField ( 0x1c , ( short ) - 2 , _data ) ; new ShortField ( 0x1e , bigBlockSize . getHeaderValue ( ) , _data ) ; new IntegerField ( 0x20 , 0x6 , _data ) ; new IntegerField ( 0x24 , 0 , _data ) ; new IntegerField ( 0x28 , 0 , _data ) ; new IntegerField ( 0x34 , 0 , _data ) ; new IntegerField ( 0x38 , 0x1000 , _data ) ; _bat_count = 0 ; _sbat_count = 0 ; _xbat_count = 0 ; _property_start = POIFSConstants . END_OF_CHAIN ; _sbat_start = POIFSConstants . END_OF_CHAIN ; _xbat_start = POIFSConstants . END_OF_CHAIN ; }
public ListEventSubscriptionsResult listEventSubscriptions ( ListEventSubscriptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListEventSubscriptions ( request ) ; }
public ListProxySessionsResult listProxySessions ( ListProxySessionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListProxySessions ( request ) ; }
public SimpleBoundaryScanner ( int maxScan , Set < Character > boundaryChars ) { this . maxScan = maxScan ; this . boundaryChars = boundaryChars ; }
public ObjectId getObjectId ( ) { return getLeaf ( ) . getObjectId ( ) ; }
public void drawLine ( int x1 , int y1 , int x2 , int y2 , int width ) { HSSFSimpleShape shape = escherGroup . createShape ( new HSSFChildAnchor ( x1 , y1 , x2 , y2 ) ) ; shape . setShapeType ( HSSFSimpleShape . OBJECT_TYPE_LINE ) ; shape . setLineWidth ( width ) ; shape . setLineStyleColor ( foreground . getRed ( ) , foreground . getGreen ( ) , foreground . getBlue ( ) ) ; }
public ReverseBytesReader ( byte [ ] bytes ) { this . bytes = bytes ; }
public GetActiveNamesResult getActiveNames ( GetActiveNamesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetActiveNames ( request ) ; }
public MergeResult getFailingResult ( ) { return failingResult ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ AREA ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . formatFlags ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getFormatFlags ( ) ) ) . append ( " ▁ ( " ) . append ( getFormatFlags ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . stacked ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( isStacked ( ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . displayAsPercentage ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( isDisplayAsPercentage ( ) ) . append ( ' \ n ' ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . shadow ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( isShadow ( ) ) . append ( ' \ n ' ) ; buffer . append ( " [ / AREA ] \ n " ) ; return buffer . toString ( ) ; }
public BatchCreateVariableResult batchCreateVariable ( BatchCreateVariableRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchCreateVariable ( request ) ; }
public final boolean isReuseAsIs ( ) { return ( flags & REUSE_AS_IS ) != 0 ; }
public String toString ( ) { return " [ PRINTGRIDLINES ] \ n " + " ▁ ▁ ▁ ▁ . printgridlines ▁ = ▁ " + getPrintGridlines ( ) + " \ n " + " [ / PRINTGRIDLINES ] \ n " ; }
public ApplySecurityGroupsToClientVpnTargetNetworkResult applySecurityGroupsToClientVpnTargetNetwork ( ApplySecurityGroupsToClientVpnTargetNetworkRequest request ) { request = beforeClientExecution ( request ) ; return executeApplySecurityGroupsToClientVpnTargetNetwork ( request ) ; }
public DetachInternetGatewayResult detachInternetGateway ( DetachInternetGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachInternetGateway ( request ) ; }
public static final RevFilter after ( long ts ) { return new After ( ts ) ; }
public DescribeCampaignResult describeCampaign ( DescribeCampaignRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCampaign ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ INDEX ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . firstrow ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getFirstRow ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . lastrowadd1 ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getLastRowAdd1 ( ) ) ) . append ( " \ n " ) ; for ( int k = 0 ; k < getNumDbcells ( ) ; k ++ ) { buffer . append ( " ▁ ▁ ▁ ▁ . dbcell □ " ) . append ( k ) . append ( " ▁ = ▁ " ) . append ( Integer . toHexString ( getDbcellAt ( k ) ) ) . append ( " \ n " ) ; } buffer . append ( " [ / INDEX ] \ n " ) ; return buffer . toString ( ) ; }
public UserSViewEnd clone ( ) { return copy ( ) ; }
public final float averageCharsPerByte ( ) { return averageCharsPerByte ; }
public ListTimeLinePhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListTimeLinePhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + formatAsString ( ) + " ] " ; }
public RunTaskResult runTask ( RunTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeRunTask ( request ) ; }
public void setCollector ( Collector collector ) { this . collector = collector ; }
public String toString ( ) { return slice . toString ( ) + " : " + postingsEnum ; }
public void addFieldConfigListener ( FieldConfigListener listener ) { this . listeners . add ( listener ) ; }
public Result getResult ( ) { return result ; }
public ListNamedQueriesResult listNamedQueries ( ListNamedQueriesRequest request ) { request = beforeClientExecution ( request ) ; return executeListNamedQueries ( request ) ; }
public URIish setPort ( int n ) { final URIish r = new URIish ( this ) ; r . port = n > 0 ? n : - 1 ; return r ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _flags ) ; }
public byte [ ] getBuffer ( ) { return buf ; }
public String getSignerVersion ( ) { return " 1.0 " ; }
public DBParameterGroup copyDBParameterGroup ( CopyDBParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCopyDBParameterGroup ( request ) ; }
public PackedObjectInfo getObject ( int nth ) { return entries [ nth ] ; }
public CreateUserSourceAccountRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " CreateUserSourceAccount " , " cr " ) ; setUriPattern ( " / users / sourceAccount " ) ; setMethod ( MethodType . PUT ) ; }
public DeleteApplicationVpcConfigurationResult deleteApplicationVpcConfiguration ( DeleteApplicationVpcConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApplicationVpcConfiguration ( request ) ; }
public final short [ ] array ( ) { return protectedArray ( ) ; }
public ByteBuffer putLong ( int index , long value ) { throw new ReadOnlyBufferException ( ) ; }
public void removeSubject ( ) { remove1stProperty ( PropertyIDMap . PID_SUBJECT ) ; }
public BatchGetDeploymentGroupsResult batchGetDeploymentGroups ( BatchGetDeploymentGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetDeploymentGroups ( request ) ; }
public DisassociateRepositoryResult disassociateRepository ( DisassociateRepositoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateRepository ( request ) ; }
public DescribeSpotPriceHistoryResult describeSpotPriceHistory ( ) { return describeSpotPriceHistory ( new DescribeSpotPriceHistoryRequest ( ) ) ; }
public UpdateRepoSourceRepoRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " UpdateRepoSourceRepo " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / sourceRepo " ) ; setMethod ( MethodType . POST ) ; }
public boolean isHidden ( ) { if ( path . isEmpty ( ) ) { return false ; } return getName ( ) . startsWith ( " . " ) ; }
public PaneRecord ( RecordInputStream in ) { field_1_x = in . readShort ( ) ; field_2_y = in . readShort ( ) ; field_3_topRow = in . readShort ( ) ; field_4_leftColumn = in . readShort ( ) ; field_5_activePane = in . readShort ( ) ; }
public StartGameSessionPlacementResult startGameSessionPlacement ( StartGameSessionPlacementRequest request ) { request = beforeClientExecution ( request ) ; return executeStartGameSessionPlacement ( request ) ; }
public int getDFASize ( int decision ) { DFA decisionToDFA = atnSimulator . decisionToDFA [ decision ] ; return decisionToDFA . states . size ( ) ; }
public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; remainingData = ( bytesRemaining == 0 ) ? EMPTY : IOUtils . safelyAllocate ( bytesRemaining , MAX_RECORD_LENGTH ) ; System . arraycopy ( data , pos , remainingData , 0 , bytesRemaining ) ; return 8 + bytesRemaining ; }
public void startFragment ( TextFragment newFragment ) { foundTerms = new HashSet <> ( ) ; totalScore = 0 ; }
public boolean equals ( ATNConfig other ) { if ( this == other ) { return true ; } else if ( ! ( other instanceof LexerATNConfig ) ) { return false ; } LexerATNConfig lexerOther = ( LexerATNConfig ) other ; if ( passedThroughNonGreedyDecision != lexerOther . passedThroughNonGreedyDecision ) { return false ; } if ( ! ObjectEqualityComparator . INSTANCE . equals ( lexerActionExecutor , lexerOther . lexerActionExecutor ) ) { return false ; } return super . equals ( other ) ; }
public DescribeCacheParameterGroupsRequest ( String cacheParameterGroupName ) { setCacheParameterGroupName ( cacheParameterGroupName ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " ▁ ▁ ▁ ▁ [ Pattern ▁ Formatting ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . fillpattern = ▁ " ) . append ( Integer . toHexString ( getFillPattern ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . fgcoloridx = ▁ " ) . append ( Integer . toHexString ( getFillForegroundColor ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . bgcoloridx = ▁ " ) . append ( Integer . toHexString ( getFillBackgroundColor ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ [ / Pattern ▁ Formatting ] \ n " ) ; return buffer . toString ( ) ; }
public boolean equals ( Object o ) { return o instanceof FileKey && path . equals ( ( ( FileKey ) o ) . path ) ; }
public UntagAttendeeResult untagAttendee ( UntagAttendeeRequest request ) { request = beforeClientExecution ( request ) ; return executeUntagAttendee ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ END ] \ n " ) ; buffer . append ( " [ / END ] \ n " ) ; return buffer . toString ( ) ; }
public MultiTerms ( Terms [ ] subs , ReaderSlice [ ] subSlices ) throws IOException { this . subs = subs ; this . subSlices = subSlices ; assert subs . length > 0 : " inefficient : ▁ don ' t use MultiTerms over one sub " ; boolean ▁ □ hasFreqs ▁ = ▁ true ; boolean ▁ □ hasOffsets ▁ = ▁ true ; boolean ▁ □ hasPositions ▁ = ▁ true ; boolean ▁ □ hasPayloads ▁ = ▁ false ; for ( int ▁ i = 0 ; i < subs . length ; i ++ ) ▁ { □ hasFreqs ▁ &= ▁ subs [ i ] . hasFreqs ( ) ; □ hasOffsets ▁ &= ▁ subs [ i ] . hasOffsets ( ) ; □ hasPositions ▁ &= ▁ subs [ i ] . hasPositions ( ) ; □ hasPayloads ▁ |= ▁ subs [ i ] . hasPayloads ( ) ; } hasFreqs ▁ = ▁ □ hasFreqs ; hasOffsets ▁ = ▁ □ hasOffsets ; hasPositions ▁ = ▁ □ hasPositions ; hasPayloads ▁ = ▁ hasPositions ▁ && ▁ □ hasPayloads ; ▁ }
public DescribeGameSessionPlacementResult describeGameSessionPlacement ( DescribeGameSessionPlacementRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeGameSessionPlacement ( request ) ; }
public SynonymMap ( FST < BytesRef > fst , BytesRefHash words , int maxHorizontalContext ) { this . fst = fst ; this . words = words ; this . maxHorizontalContext = maxHorizontalContext ; }
public DeleteTrialComponentResult deleteTrialComponent ( DeleteTrialComponentRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTrialComponent ( request ) ; }
public RevisionSyntaxException ( String revstr ) { this . revstr = revstr ; }
public void startWorker ( ) { startWorkers ( 1 ) ; }
public SubscribeToEventResult subscribeToEvent ( SubscribeToEventRequest request ) { request = beforeClientExecution ( request ) ; return executeSubscribeToEvent ( request ) ; }
public PutScheduledUpdateGroupActionResult putScheduledUpdateGroupAction ( PutScheduledUpdateGroupActionRequest request ) { request = beforeClientExecution ( request ) ; return executePutScheduledUpdateGroupAction ( request ) ; }
public int doLogic ( ) throws Exception { if ( maxNumSegments == - 1 ) { throw new IllegalStateException ( " required ▁ argument ▁ ( maxNumSegments ) ▁ was ▁ not ▁ specified " ) ; } IndexWriter iw = getRunData ( ) . getIndexWriter ( ) ; iw . forceMerge ( maxNumSegments ) ; return 1 ; }
public String getSheetName ( int sheetIndex ) { return _uBook . getSheetName ( sheetIndex ) ; }
public DescribeConnectionLoaResult describeConnectionLoa ( DescribeConnectionLoaRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeConnectionLoa ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ NOTE ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . row ▁ ▁ ▁ ▁ = ▁ " ) . append ( field_1_row ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . col ▁ ▁ ▁ ▁ = ▁ " ) . append ( field_2_col ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . flags ▁ ▁ = ▁ " ) . append ( field_3_flags ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . shapeid = ▁ " ) . append ( field_4_shapeid ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . author ▁ = ▁ " ) . append ( field_6_author ) . append ( " \ n " ) ; buffer . append ( " [ / NOTE ] \ n " ) ; return buffer . toString ( ) ; }
public PipedInputStream ( PipedOutputStream out , int pipeSize ) throws IOException { this ( pipeSize ) ; connect ( out ) ; }
public String toString ( ) { return description ( ) ; }
public synchronized Credential getCredential ( ) { if ( null == credential && null != icredential ) { credential = icredential . fresh ( ) ; } return credential ; }
public OptionGroup copyOptionGroup ( CopyOptionGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCopyOptionGroup ( request ) ; }
public InfoSubRecord ( RecordInputStream in ) { field_1_stream_pos = in . readInt ( ) ; field_2_bucket_sst_offset = in . readShort ( ) ; field_3_zero = in . readShort ( ) ; }
public TreeFilter clone ( ) { final TreeFilter [ ] s = new TreeFilter [ subfilters . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) s [ i ] = subfilters [ i ] . clone ( ) ; return new List ( s ) ; }
public SendAlexaOfferToMasterResult sendAlexaOfferToMaster ( SendAlexaOfferToMasterRequest request ) { request = beforeClientExecution ( request ) ; return executeSendAlexaOfferToMaster ( request ) ; }
public DescribeEndpointConfigResult describeEndpointConfig ( DescribeEndpointConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEndpointConfig ( request ) ; }
public PushCommand setProgressMonitor ( ProgressMonitor monitor ) { checkCallable ( ) ; if ( monitor == null ) { monitor = NullProgressMonitor . INSTANCE ; } this . monitor = monitor ; return this ; }
public FloatBuffer get ( float [ ] dst , int dstOffset , int floatCount ) { byteBuffer . limit ( limit * SizeOf . FLOAT ) ; byteBuffer . position ( position * SizeOf . FLOAT ) ; if ( byteBuffer instanceof DirectByteBuffer ) { ( ( DirectByteBuffer ) byteBuffer ) . get ( dst , dstOffset , floatCount ) ; } else { ( ( HeapByteBuffer ) byteBuffer ) . get ( dst , dstOffset , floatCount ) ; } this . position += floatCount ; return this ; }
public boolean shouldBeRecursive ( ) { for ( TreeFilter f : subfilters ) if ( f . shouldBeRecursive ( ) ) return true ; return false ; }
public static void putUnicodeLE ( String input , LittleEndianOutput out ) { byte [ ] bytes = input . getBytes ( UTF16LE ) ; out . write ( bytes ) ; }
public ReservedNode acceptReservedNodeExchange ( AcceptReservedNodeExchangeRequest request ) { request = beforeClientExecution ( request ) ; return executeAcceptReservedNodeExchange ( request ) ; }
public ClusterSecurityGroup authorizeClusterSecurityGroupIngress ( AuthorizeClusterSecurityGroupIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeAuthorizeClusterSecurityGroupIngress ( request ) ; }
public ListVaultsResult listVaults ( ListVaultsRequest request ) { request = beforeClientExecution ( request ) ; return executeListVaults ( request ) ; }
public void add ( UDFFinder toolPack ) { _usedToolPacks . add ( toolPack ) ; }
public CreateRealtimeEndpointResult createRealtimeEndpoint ( CreateRealtimeEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRealtimeEndpoint ( request ) ; }
public final void recurseClearCachedFormulaResults ( IEvaluationListener listener ) { if ( listener == null ) { recurseClearCachedFormulaResults ( ) ; } else { listener . onClearCachedValue ( this ) ; recurseClearCachedFormulaResults ( listener , 1 ) ; } }
public PageBreakRecord ( RecordInputStream in ) { final int nBreaks = in . readShort ( ) ; _breaks . ensureCapacity ( nBreaks + 2 ) ; for ( int k = 0 ; k < nBreaks ; k ++ ) { _breaks . add ( new Break ( in ) ) ; } initMap ( ) ; }
public String toString ( ) { return attSource . toString ( ) ; }
public void add ( double value ) { ensureCapacity ( _count + 1 ) ; _array [ _count ] = value ; _count ++ ; }
public FileInputStream ( String path ) throws FileNotFoundException { this ( new File ( path ) ) ; }
public SetDataRetrievalPolicyResult setDataRetrievalPolicy ( SetDataRetrievalPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeSetDataRetrievalPolicy ( request ) ; }
public ScoreDoc ( int doc , float score , int shardIndex ) { this . doc = doc ; this . score = score ; this . shardIndex = shardIndex ; }
public SpanNotQuery ( SpanQuery include , SpanQuery exclude , int pre , int post ) { this . include = Objects . requireNonNull ( include ) ; this . exclude = Objects . requireNonNull ( exclude ) ; this . pre = pre ; this . post = post ; if ( include . getField ( ) != null && exclude . getField ( ) != null && ! include . getField ( ) . equals ( exclude . getField ( ) ) ) throw new IllegalArgumentException ( " Clauses ▁ must ▁ have ▁ same ▁ field . " ) ; }
public void visitContainedRecords ( RecordVisitor rv ) { if ( _validationList . isEmpty ( ) ) { return ; } rv . visitRecord ( _headerRec ) ; _validationList . forEach ( rv :: visitRecord ) ; }
public void addArea ( int rowFrom , int colFrom , int rowTo , int colTo ) { _mergedRegions . add ( new CellRangeAddress ( rowFrom , rowTo , colFrom , colTo ) ) ; }
public HungarianLightStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public int readDataSize ( ) { return _lei . readUShort ( ) ; }
public DescribeAdjustmentTypesResult describeAdjustmentTypes ( DescribeAdjustmentTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAdjustmentTypes ( request ) ; }
public DefineSuggesterResult defineSuggester ( DefineSuggesterRequest request ) { request = beforeClientExecution ( request ) ; return executeDefineSuggester ( request ) ; }
public GetJourneyDateRangeKpiResult getJourneyDateRangeKpi ( GetJourneyDateRangeKpiRequest request ) { request = beforeClientExecution ( request ) ; return executeGetJourneyDateRangeKpi ( request ) ; }
public PushCommand add ( String nameOrSpec ) { if ( 0 <= nameOrSpec . indexOf ( ' : ' ) ) { refSpecs . add ( new RefSpec ( nameOrSpec ) ) ; } else { Ref src ; try { src = repo . findRef ( nameOrSpec ) ; } catch ( IOException e ) { throw new JGitInternalException ( JGitText . get ( ) . exceptionCaughtDuringExecutionOfPushCommand , e ) ; } if ( src != null ) add ( src ) ; } return this ; }
public DescribeDataSourceResult describeDataSource ( DescribeDataSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDataSource ( request ) ; }
public AutoCRLFInputStream ( InputStream in , boolean detectBinary ) { this . in = in ; this . detectBinary = detectBinary ; }
public byte [ ] getRawRecord ( ) { return _rawData ; }
public LongBuffer put ( LongBuffer buf ) { throw new ReadOnlyBufferException ( ) ; }
@ Override public E set ( int location , E object ) { synchronized ( mutex ) { return list . set ( location , object ) ; } }
public void jumpDrawablesToCurrentState ( ) { super . jumpDrawablesToCurrentState ( ) ; if ( mProgressDrawable != null ) mProgressDrawable . jumpToCurrentState ( ) ; if ( mIndeterminateDrawable != null ) mIndeterminateDrawable . jumpToCurrentState ( ) ; }
public boolean contains ( Object object ) { Link < E > link = voidLink . next ; if ( object != null ) { while ( link != voidLink ) { if ( object . equals ( link . data ) ) { return true ; } link = link . next ; } } else { while ( link != voidLink ) { if ( link . data == null ) { return true ; } link = link . next ; } } return false ; }
public static double [ ] copyOf ( double [ ] original , int newLength ) { if ( newLength < 0 ) { throw new NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; }
public IndexSearcher acquire ( long version ) { ensureOpen ( ) ; final SearcherTracker tracker = searchers . get ( version ) ; if ( tracker != null && tracker . searcher . getIndexReader ( ) . tryIncRef ( ) ) { return tracker . searcher ; } return null ; }
public void setDateToBeFormatted ( double date ) { this . dateToBeFormatted = date ; }
public CreateIntegrationResponseResult createIntegrationResponse ( CreateIntegrationResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateIntegrationResponse ( request ) ; }
public PhraseWildcardQuery build ( ) { return new PhraseWildcardQuery ( field , phraseTerms , slop , maxMultiTermExpansions , segmentOptimizationEnabled ) ; }
public synchronized void dropChanges ( ) { pendingDeletes . dropChanges ( ) ; dropMergingUpdates ( ) ; }
public static int footerLength ( ) { return 16 ; }
public DeleteDBParameterGroupRequest ( String dBParameterGroupName ) { setDBParameterGroupName ( dBParameterGroupName ) ; }
public GetDedicatedIpsResult getDedicatedIps ( GetDedicatedIpsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDedicatedIps ( request ) ; }
public DeleteArchiveResult deleteArchive ( DeleteArchiveRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteArchive ( request ) ; }
public ResourceRecordSet ( String name , RRType type ) { setName ( name ) ; setType ( type . toString ( ) ) ; }
public ArabicNormalizationFilter ( TokenStream input ) { super ( input ) ; }
public ReceiveMessageResult receiveMessage ( ReceiveMessageRequest request ) { request = beforeClientExecution ( request ) ; return executeReceiveMessage ( request ) ; }
public CharSequence getFully ( CharSequence key ) { Row now = getRow ( root ) ; int w ; Cell c ; int cmd = - 1 ; StrEnum e = new StrEnum ( key , forward ) ; Character ch = null ; Character aux = null ; for ( int i = 0 ; i < key . length ( ) ; ) { ch = e . next ( ) ; i ++ ; c = now . at ( ch ) ; if ( c == null ) { return null ; } cmd = c . cmd ; for ( int skip = c . skip ; skip > 0 ; skip -- ) { if ( i < key . length ( ) ) { aux = e . next ( ) ; } else { return null ; } i ++ ; } w = now . getRef ( ch ) ; if ( w >= 0 ) { now = getRow ( w ) ; } else if ( i < key . length ( ) ) { return null ; } } return ( cmd == - 1 ) ? null : cmds . get ( cmd ) ; }
public Span [ ] getNames ( String [ ] words ) { Span [ ] names = nameFinder . find ( words ) ; return names ; }
public void reset ( ) { used = false ; }
public AnalyticsPrefixPredicate ( String prefix ) { this . prefix = prefix ; }
public byte readByte ( ) { return ( byte ) readUByte ( ) ; }
public CreateImportJobResult createImportJob ( CreateImportJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateImportJob ( request ) ; }
public byte [ ] build ( ) { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; try ( OutputStreamWriter w = new OutputStreamWriter ( os , UTF_8 ) ) { w . write ( " object ▁ " ) ; getObjectId ( ) . copyTo ( w ) ; w . write ( ' \ n ' ) ; w . write ( " type ▁ " ) ; w . write ( Constants . typeString ( getObjectType ( ) ) ) ; w . write ( " \ n " ) ; w . write ( " tag ▁ " ) ; w . write ( getTag ( ) ) ; w . write ( " \ n " ) ; if ( getTagger ( ) != null ) { w . write ( " tagger ▁ " ) ; w . write ( getTagger ( ) . toExternalString ( ) ) ; w . write ( ' \ n ' ) ; } w . write ( ' \ n ' ) ; if ( getMessage ( ) != null ) w . write ( getMessage ( ) ) ; } catch ( IOException err ) { throw new RuntimeException ( err ) ; } return os . toByteArray ( ) ; }
public boolean equals ( ATNConfig a , ATNConfig b ) { if ( a == b ) return true ; if ( a == null || b == null ) return false ; return a . state . stateNumber == b . state . stateNumber && a . alt == b . alt && a . semanticContext . equals ( b . semanticContext ) ; }
public CreateMemberResult createMember ( CreateMemberRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateMember ( request ) ; }
public void removeParCount ( ) { remove1stProperty ( PropertyIDMap . PID_PARCOUNT ) ; }
public DeleteDeliveryStreamResult deleteDeliveryStream ( DeleteDeliveryStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDeliveryStream ( request ) ; }
public static RevFilter create ( int maxCount ) { if ( maxCount < 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . maxCountMustBeNonNegative ) ; return new MaxCountRevFilter ( maxCount ) ; }
public PeerVpcResult peerVpc ( PeerVpcRequest request ) { request = beforeClientExecution ( request ) ; return executePeerVpc ( request ) ; }
public GetResolverRuleResult getResolverRule ( GetResolverRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeGetResolverRule ( request ) ; }
public DeleteScalingPolicyResult deleteScalingPolicy ( DeleteScalingPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteScalingPolicy ( request ) ; }
public TokenStream create ( TokenStream input ) { return new SwedishLightStemFilter ( input ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getRowNumber ( ) ) ; out . writeShort ( getFirstCol ( ) == - 1 ? ( short ) 0 : getFirstCol ( ) ) ; out . writeShort ( getLastCol ( ) == - 1 ? ( short ) 0 : getLastCol ( ) ) ; out . writeShort ( getHeight ( ) ) ; out . writeShort ( getOptimize ( ) ) ; out . writeShort ( field_6_reserved ) ; out . writeShort ( getOptionFlags ( ) ) ; out . writeShort ( getOptionFlags2 ( ) ) ; }
public GetCredentialsForIdentityResult getCredentialsForIdentity ( GetCredentialsForIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCredentialsForIdentity ( request ) ; }
public DeleteFileSystemResult deleteFileSystem ( DeleteFileSystemRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFileSystem ( request ) ; }
public DeleteGameServerGroupResult deleteGameServerGroup ( DeleteGameServerGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteGameServerGroup ( request ) ; }
public AutoCRLFOutputStream ( OutputStream out ) { this ( out , true ) ; }
public DescribeLocationsResult describeLocations ( DescribeLocationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLocations ( request ) ; }
public CopyWorkspaceImageResult copyWorkspaceImage ( CopyWorkspaceImageRequest request ) { request = beforeClientExecution ( request ) ; return executeCopyWorkspaceImage ( request ) ; }
public UpdateAliasResult updateAlias ( UpdateAliasRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateAlias ( request ) ; }
public static final int nextLF ( byte [ ] b , int ptr , char chrA ) { final int sz = b . length ; while ( ptr < sz ) { final byte c = b [ ptr ++ ] ; if ( c == chrA || c == ' \ n ' ) return ptr ; } return ptr ; }
public static long checkFooter ( ChecksumIndexInput in ) throws IOException { validateFooter ( in ) ; long actualChecksum = in . getChecksum ( ) ; long expectedChecksum = readCRC ( in ) ; if ( expectedChecksum != actualChecksum ) { throw new CorruptIndexException ( " checksum ▁ failed ▁ ( hardware ▁ problem ? ) ▁ : ▁ expected = " + Long . toHexString ( expectedChecksum ) + " ▁ actual = " + Long . toHexString ( actualChecksum ) , in ) ; } return actualChecksum ; }
public GetLoadBalancersResult getLoadBalancers ( GetLoadBalancersRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLoadBalancers ( request ) ; }
public GetRepoListByNamespaceRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoListByNamespace " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] " ) ; setMethod ( MethodType . GET ) ; }
public boolean add ( QueryNodeProcessor processor ) { boolean added = this . processors . add ( processor ) ; if ( added ) { processor . setQueryConfigHandler ( this . queryConfig ) ; } return added ; }
public PutEventStreamResult putEventStream ( PutEventStreamRequest request ) { request = beforeClientExecution ( request ) ; return executePutEventStream ( request ) ; }
public int getRenameLimit ( ) { return renameLimit ; }
public char next ( ) { if ( ++ index >= limit ) { index = limit ; return DONE ; } else { return current ( ) ; } }
public final ObjectId getDeltaBaseId ( ) { return deltaBase ; }
public FieldType ( IndexableFieldType ref ) { this . stored = ref . stored ( ) ; this . tokenized = ref . tokenized ( ) ; this . storeTermVectors = ref . storeTermVectors ( ) ; this . storeTermVectorOffsets = ref . storeTermVectorOffsets ( ) ; this . storeTermVectorPositions = ref . storeTermVectorPositions ( ) ; this . storeTermVectorPayloads = ref . storeTermVectorPayloads ( ) ; this . omitNorms = ref . omitNorms ( ) ; this . indexOptions = ref . indexOptions ( ) ; this . docValuesType = ref . docValuesType ( ) ; this . dimensionCount = ref . pointDimensionCount ( ) ; this . indexDimensionCount = ref . pointIndexDimensionCount ( ) ; this . dimensionNumBytes = ref . pointNumBytes ( ) ; if ( ref . getAttributes ( ) != null ) { this . attributes = new HashMap <> ( ref . getAttributes ( ) ) ; } }
public RestoreWorkspaceResult restoreWorkspace ( RestoreWorkspaceRequest request ) { request = beforeClientExecution ( request ) ; return executeRestoreWorkspace ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ CODEPAGE ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . codepage ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getCodepage ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / CODEPAGE ] \ n " ) ; return buffer . toString ( ) ; }
public GetRepoTagsRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoTags " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / tags " ) ; setMethod ( MethodType . GET ) ; }
public ProtectRecord clone ( ) { return copy ( ) ; }
public ModifyDBParameterGroupResult modifyDBParameterGroup ( ModifyDBParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBParameterGroup ( request ) ; }
public QueryParserConfig build ( ) { return new QueryParserConfig ( this ) ; }
public Set < String > getSections ( ) { return getState ( ) . getSections ( ) ; }
public UpdateProxySessionResult updateProxySession ( UpdateProxySessionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateProxySession ( request ) ; }
public double getAvp ( ) { return maxGoodPoints == 0 ? 0 : pReleventSum / maxGoodPoints ; }
public ListCompatibleImagesResult listCompatibleImages ( ListCompatibleImagesRequest request ) { request = beforeClientExecution ( request ) ; return executeListCompatibleImages ( request ) ; }
public int getSourceEnd ( ) { Region r = outRegion ; return r . sourceStart + r . length ; }
public int read ( ) { if ( pos < size ) { return s . charAt ( pos ++ ) ; } else { s = null ; return - 1 ; } }
public GetMediaForFragmentListResult getMediaForFragmentList ( GetMediaForFragmentListRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMediaForFragmentList ( request ) ; }
public BlendedTermQuery build ( ) { return new BlendedTermQuery ( ArrayUtil . copyOfSubArray ( terms , 0 , numTerms ) , ArrayUtil . copyOfSubArray ( boosts , 0 , numTerms ) , ArrayUtil . copyOfSubArray ( contexts , 0 , numTerms ) , rewriteMethod ) ; }
public void write ( byte [ ] buffer , int offset , int length ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . write ( buffer , offset , length ) ; }
public ModifyScheduledActionResult modifyScheduledAction ( ModifyScheduledActionRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyScheduledAction ( request ) ; }
public CreateEventRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " CreateEvent " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DeleteDirectoryResult deleteDirectory ( DeleteDirectoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDirectory ( request ) ; }
public static RevFilter create ( RevFilter a , RevFilter b ) { if ( a == ALL ) return b ; if ( b == ALL ) return a ; return new Binary ( a , b ) ; }
public PasswordRecord ( int password ) { field_1_password = password ; }
public CzechStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public CloseIgnoringInputStream ( InputStream in ) { super ( in ) ; }
public Snapshot modifyClusterSnapshot ( ModifyClusterSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyClusterSnapshot ( request ) ; }
public boolean inErrorRecoveryMode ( Parser recognizer ) { return errorRecoveryMode ; }
public FacetLabel ( String dim , String [ ] path ) { components = new String [ 1 + path . length ] ; components [ 0 ] = dim ; System . arraycopy ( path , 0 , components , 1 , path . length ) ; length = components . length ; checkComponents ( ) ; }
public UntagStreamResult untagStream ( UntagStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeUntagStream ( request ) ; }
public long addAndGet ( long delta ) { return count += delta ; }
public int read ( ) throws IOException { synchronized ( lock ) { if ( ! isOpen ( ) ) { throw new IOException ( " InputStreamReader ▁ is ▁ closed " ) ; } char [ ] buf = new char [ 1 ] ; return read ( buf , 0 , 1 ) != - 1 ? buf [ 0 ] : - 1 ; } }
public static int getEncodedSize ( int numberOfItems ) { return numberOfItems * ENCODED_SIZE ; }
public PrintStream ( File file , String csn ) throws FileNotFoundException , UnsupportedEncodingException { super ( new FileOutputStream ( file ) ) ; if ( csn == null ) { throw new NullPointerException ( ) ; } if ( ! Charset . isSupported ( csn ) ) { throw new UnsupportedEncodingException ( csn ) ; } encoding = csn ; }
public E poll ( ) { return size == 0 ? null : removeFirst ( ) ; }
public void write ( char [ ] cbuf , int offset , int count ) throws IOException { synchronized ( lock ) { checkNotClosed ( ) ; if ( cbuf == null ) { throw new NullPointerException ( " buffer ▁ == ▁ null " ) ; } Arrays . checkOffsetAndCount ( cbuf . length , offset , count ) ; if ( pos == 0 && count >= this . buf . length ) { out . write ( cbuf , offset , count ) ; return ; } int available = this . buf . length - pos ; if ( count < available ) { available = count ; } if ( available > 0 ) { System . arraycopy ( cbuf , offset , this . buf , pos , available ) ; pos += available ; } if ( pos == this . buf . length ) { out . write ( this . buf , 0 , this . buf . length ) ; pos = 0 ; if ( count > available ) { offset += available ; available = count - available ; if ( available >= this . buf . length ) { out . write ( cbuf , offset , available ) ; return ; } System . arraycopy ( cbuf , offset , this . buf , pos , available ) ; pos += available ; } } } }
public String toString ( String enc ) throws UnsupportedEncodingException { return new String ( toByteArray ( ) , enc ) ; }
public CreateRoomMembershipResult createRoomMembership ( CreateRoomMembershipRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRoomMembership ( request ) ; }
public long ramBytesUsed ( ) { long size = 0 ; for ( Map . Entry < String , DocValuesProducer > entry : formats . entrySet ( ) ) { size += ( entry . getKey ( ) . length ( ) * Character . BYTES ) + entry . getValue ( ) . ramBytesUsed ( ) ; } return size ; }
public int getDFASize ( ) { int n = 0 ; DFA [ ] decisionToDFA = atnSimulator . decisionToDFA ; for ( int i = 0 ; i < decisionToDFA . length ; i ++ ) { n += getDFASize ( i ) ; } return n ; }
public static CodePointCharStream fromString ( String s ) { return fromString ( s , IntStream . UNKNOWN_SOURCE_NAME ) ; }
public DeleteUserSourceAccountRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " DeleteUserSourceAccount " , " cr " ) ; setUriPattern ( " / users / sourceAccount / [ SourceAccountId ] " ) ; setMethod ( MethodType . DELETE ) ; }
public static Proxy proxyFor ( ProxySelector proxySelector , URL u ) throws ConnectException { try { URI uri = new URI ( u . getProtocol ( ) , null , u . getHost ( ) , u . getPort ( ) , null , null , null ) ; return proxySelector . select ( uri ) . get ( 0 ) ; } catch ( URISyntaxException e ) { final ConnectException err ; err = new ConnectException ( MessageFormat . format ( JGitText . get ( ) . cannotDetermineProxyFor , u ) ) ; err . initCause ( e ) ; throw err ; } }
public String toString ( ) { String dsc = null ; switch ( this . type ) { case TYPE_UNDERFLOW : dsc = " UNDERFLOW ▁ error " ; break ; case TYPE_OVERFLOW : dsc = " OVERFLOW ▁ error " ; break ; case TYPE_UNMAPPABLE_CHAR : dsc = " Unmappable - character ▁ error ▁ with ▁ erroneous ▁ input ▁ length ▁ " + this . length ; break ; case TYPE_MALFORMED_INPUT : dsc = " Malformed - input ▁ error ▁ with ▁ erroneous ▁ input ▁ length ▁ " + this . length ; break ; default : dsc = " " ; break ; } return getClass ( ) . getName ( ) + " [ " + dsc + " ] " ; }
public PredictResult predict ( PredictRequest request ) { request = beforeClientExecution ( request ) ; return executePredict ( request ) ; }
public Ptg get3DReferencePtg ( AreaReference areaRef , SheetIdentifier sheet ) { int extIx = getSheetExtIx ( sheet ) ; return new Area3DPtg ( areaRef , extIx ) ; }
public DescribeMatchmakingResult describeMatchmaking ( DescribeMatchmakingRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeMatchmaking ( request ) ; }
public DeleteDeviceUsageDataResult deleteDeviceUsageData ( DeleteDeviceUsageDataRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDeviceUsageData ( request ) ; }
public void removeHyperlink ( ) { for ( Iterator < RecordBase > it = _sheet . getSheet ( ) . getRecords ( ) . iterator ( ) ; it . hasNext ( ) ; ) { RecordBase rec = it . next ( ) ; if ( rec instanceof HyperlinkRecord ) { HyperlinkRecord link = ( HyperlinkRecord ) rec ; if ( link . getFirstColumn ( ) == _record . getColumn ( ) && link . getFirstRow ( ) == _record . getRow ( ) ) { it . remove ( ) ; return ; } } } }
public RegisterInstancesWithLoadBalancerRequest ( String loadBalancerName , java . util . List < Instance > instances ) { setLoadBalancerName ( loadBalancerName ) ; setInstances ( instances ) ; }
public AssociateResolverRuleResult associateResolverRule ( AssociateResolverRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateResolverRule ( request ) ; }
@ Override public Set < Entry < K , V >> entrySet ( ) { throw new UnsupportedOperationException ( ) ; }
public TreeFilter negate ( ) { return a ; }
public SearchProfilesResult searchProfiles ( SearchProfilesRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchProfiles ( request ) ; }
public DBSubnetGroup modifyDBSubnetGroup ( ModifyDBSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBSubnetGroup ( request ) ; }
public int compareTo ( String version ) { final String [ ] parts = version . split ( " : " ) ; final long indexGen = Long . parseLong ( parts [ 0 ] , RADIX ) ; final long taxoGen = Long . parseLong ( parts [ 1 ] , RADIX ) ; final long indexCommitGen = indexCommit . getGeneration ( ) ; final long taxoCommitGen = taxoCommit . getGeneration ( ) ; if ( indexCommitGen < indexGen ) { return - 1 ; } else if ( indexCommitGen > indexGen ) { return 1 ; } else { return taxoCommitGen < taxoGen ? - 1 : ( taxoCommitGen > taxoGen ? 1 : 0 ) ; } }
public LiteralValueSource ( String string ) { this . string = string ; this . bytesRef = new BytesRef ( string ) ; }
public int getValue ( final int holder ) { return getRawValue ( holder ) >>> _shift_count ; }
public HSSFShapeGroup ( HSSFShape parent , HSSFAnchor anchor ) { super ( parent , anchor ) ; _spgrRecord = ( ( EscherContainerRecord ) getEscherContainer ( ) . getChild ( 0 ) ) . getChildById ( EscherSpgrRecord . RECORD_ID ) ; }
public String toString ( ) { return " Note [ " + name ( ) + " ▁ -> ▁ " + data . name ( ) + " ] " ; }
public DeleteFpgaImageResult deleteFpgaImage ( DeleteFpgaImageRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFpgaImage ( request ) ; }
public CreateAppCookieStickinessPolicyResult createAppCookieStickinessPolicy ( CreateAppCookieStickinessPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAppCookieStickinessPolicy ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ FNGROUPCOUNT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . count ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getCount ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / FNGROUPCOUNT ] \ n " ) ; return buffer . toString ( ) ; }
public final void sort ( int from , int to ) { checkRange ( from , to ) ; quicksort ( from , to , 2 * MathUtil . log ( to - from , 2 ) ) ; }
public DescribeMonitoringScheduleResult describeMonitoringSchedule ( DescribeMonitoringScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeMonitoringSchedule ( request ) ; }
public HeaderLineParser ( String [ ] header ) { super ( header ) ; posToF = new FieldName [ header . length ] ; for ( int i = 0 ; i < header . length ; i ++ ) { String f = header [ i ] ; if ( DocMaker . NAME_FIELD . equals ( f ) ) { posToF [ i ] = FieldName . NAME ; } else if ( DocMaker . TITLE_FIELD . equals ( f ) ) { posToF [ i ] = FieldName . TITLE ; } else if ( DocMaker . DATE_FIELD . equals ( f ) ) { posToF [ i ] = FieldName . DATE ; } else if ( DocMaker . BODY_FIELD . equals ( f ) ) { posToF [ i ] = FieldName . BODY ; } else { posToF [ i ] = FieldName . PROP ; } } }
public void reset ( ) { if ( useHash ) { map . clear ( ) ; useHash = false ; } count = 0 ; }
public StandardTokenizerFactory ( Map < String , String > args ) { super ( args ) ; maxTokenLength = getInt ( args , " maxTokenLength " , StandardAnalyzer . DEFAULT_MAX_TOKEN_LENGTH ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 6 ) | ( byte1 >>> 2 ) ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte3 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 3 ) << 12 ) | ( byte2 << 4 ) | ( byte3 >>> 4 ) ; final long byte4 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte5 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte3 & 15 ) << 10 ) | ( byte4 << 2 ) | ( byte5 >>> 6 ) ; final long byte6 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte5 & 63 ) << 8 ) | byte6 ; } }
public boolean precpred ( RuleContext localctx , int precedence ) { return true ; }
public int getFSD ( ) { return fSD ; }
public static FunctionMetadata getFunctionByIndex ( int index ) { return getInstance ( ) . getFunctionByIndexInternal ( index ) ; }
public Object toObject ( ) { assert exists || 0 == value . length ( ) ; return exists ? value . get ( ) . utf8ToString ( ) : null ; }
public GetDisksResult getDisks ( GetDisksRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDisks ( request ) ; }
public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ( compressionMode = " + compressionMode + " , ▁ chunkSize = " + chunkSize + " , ▁ maxDocsPerChunk = " + maxDocsPerChunk + " , ▁ blockShift = " + blockShift + " ) " ; }
public DescribeVolumesModificationsResult describeVolumesModifications ( DescribeVolumesModificationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVolumesModifications ( request ) ; }
public float currentScore ( int docId , String field , int start , int end , int numPayloadsSeen , float currentScore , float currentPayloadScore ) { return currentPayloadScore + currentScore ; }
public StartRepoBuildRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " StartRepoBuild " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / build " ) ; setMethod ( MethodType . PUT ) ; }
public Instance ( String instanceId ) { setInstanceId ( instanceId ) ; }
public int getEntryPathHashCode ( ) { int hash = 0 ; for ( int i = Math . max ( 0 , pathLen - 16 ) ; i < pathLen ; i ++ ) { byte c = path [ i ] ; if ( c != ' ▁ ' ) hash = ( hash >>> 2 ) + ( c << 24 ) ; } return hash ; }
public CreateBranchCommand setName ( String name ) { checkCallable ( ) ; this . name = name ; return this ; }
public static Reporter getReporter ( ) { return REPORTER ; }
public void getChars ( int start , int end , char [ ] dst , int dstStart ) { if ( start > count || end > count || start > end ) { throw startEndAndLength ( start , end ) ; } System . arraycopy ( value , start , dst , dstStart , end - start ) ; }
public LongBuffer put ( long [ ] src , int srcOffset , int longCount ) { if ( longCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } System . arraycopy ( src , srcOffset , backingArray , offset + position , longCount ) ; position += longCount ; return this ; }
public long getSourceSize ( ) { return src . length ; }
public void setID ( String id ) { if ( id == null ) { throw new NullPointerException ( ) ; } ID = id ; }
public GetCampaignVersionsResult getCampaignVersions ( GetCampaignVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCampaignVersions ( request ) ; }
public long getTotalSLLLookaheadOps ( ) { DecisionInfo [ ] decisions = atnSimulator . getDecisionInfo ( ) ; long k = 0 ; for ( int i = 0 ; i < decisions . length ; i ++ ) { k += decisions [ i ] . SLL_TotalLook ; } return k ; }
public static Row getRow ( int rowIndex , Sheet sheet ) { Row row = sheet . getRow ( rowIndex ) ; if ( row == null ) { row = sheet . createRow ( rowIndex ) ; } return row ; }
public void clear ( ) { doc = null ; analyzer = null ; }
public KeyPairCredentials ( String publicKeyId , String privateKeySecret ) { if ( publicKeyId == null || privateKeySecret == null ) { throw new IllegalArgumentException ( " You ▁ must ▁ provide ▁ a ▁ valid ▁ pair ▁ of ▁ Public ▁ Key ▁ ID ▁ and ▁ Private ▁ Key ▁ Secret . " ) ; } this . publicKeyId = publicKeyId ; this . privateKeySecret = privateKeySecret ; }
public PredictionContext getParent ( int index ) { return parents [ index ] ; }
public synchronized StringBuffer append ( String string ) { append0 ( string ) ; return this ; }
public void removeBuiltinRecord ( byte name , int sheetIndex ) { NameRecord record = getSpecificBuiltinRecord ( name , sheetIndex ) ; if ( record != null ) { _definedNames . remove ( record ) ; } }
public SharedFormulaGroup ( SharedFormulaRecord sfr , CellReference firstCell ) { if ( ! sfr . isInRange ( firstCell . getRow ( ) , firstCell . getCol ( ) ) ) { throw new IllegalArgumentException ( " First ▁ formula ▁ cell ▁ " + firstCell . formatAsString ( ) + " ▁ is ▁ not ▁ shared ▁ formula ▁ range ▁ " + sfr . getRange ( ) + " . " ) ; } _sfr = sfr ; _firstCell = firstCell ; int width = sfr . getLastColumn ( ) - sfr . getFirstColumn ( ) + 1 ; int height = sfr . getLastRow ( ) - sfr . getFirstRow ( ) + 1 ; _frAggs = new FormulaRecordAggregate [ width * height ] ; _numberOfFormulas = 0 ; }
public void modifyFormatRun ( short oldPos , short newLen ) { int shift = 0 ; for ( int i = 0 ; i < _formats . length ; i ++ ) { CTFormat ctf = _formats [ i ] ; if ( shift != 0 ) { ctf . setOffset ( ctf . getOffset ( ) + shift ) ; } else if ( oldPos == ctf . getOffset ( ) && i < _formats . length - 1 ) { CTFormat nextCTF = _formats [ i + 1 ] ; shift = newLen - ( nextCTF . getOffset ( ) - ctf . getOffset ( ) ) ; } } }
public AddInstanceGroupsResult addInstanceGroups ( AddInstanceGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeAddInstanceGroups ( request ) ; }
public String getText ( ) { if ( getChildCount ( ) == 0 ) { return " " ; } StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < getChildCount ( ) ; i ++ ) { builder . append ( getChild ( i ) . getText ( ) ) ; } return builder . toString ( ) ; }
public ListCodeRepositoriesResult listCodeRepositories ( ListCodeRepositoriesRequest request ) { request = beforeClientExecution ( request ) ; return executeListCodeRepositories ( request ) ; }
public LexerATNConfig ( ATNState state , int alt , PredictionContext context ) { super ( state , alt , context , SemanticContext . NONE ) ; this . passedThroughNonGreedyDecision = false ; this . lexerActionExecutor = null ; }
public int serialize ( int offset , byte [ ] data ) { throw new RecordFormatException ( " Old ▁ Label ▁ Records ▁ are ▁ supported ▁ READ ▁ ONLY " ) ; }
public GetSmsChannelResult getSmsChannel ( GetSmsChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSmsChannel ( request ) ; }
public Placement ( String availabilityZone ) { setAvailabilityZone ( availabilityZone ) ; }
public ListStacksResult listStacks ( ListStacksRequest request ) { request = beforeClientExecution ( request ) ; return executeListStacks ( request ) ; }
public ListFieldLevelEncryptionConfigsResult listFieldLevelEncryptionConfigs ( ListFieldLevelEncryptionConfigsRequest request ) { request = beforeClientExecution ( request ) ; return executeListFieldLevelEncryptionConfigs ( request ) ; }
public CloseInstancePublicPortsResult closeInstancePublicPorts ( CloseInstancePublicPortsRequest request ) { request = beforeClientExecution ( request ) ; return executeCloseInstancePublicPorts ( request ) ; }
public DeleteTransitGatewayRouteTableResult deleteTransitGatewayRouteTable ( DeleteTransitGatewayRouteTableRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTransitGatewayRouteTable ( request ) ; }
public TokenStream create ( TokenStream input ) { return new StempelFilter ( input , new StempelStemmer ( PolishAnalyzer . getDefaultTable ( ) ) ) ; }
public static byte [ ] grow ( byte [ ] array ) { return grow ( array , 1 + array . length ) ; }
public DocFreqSorter ( int maxDoc ) { super ( maxDoc / 64 ) ; this . tmpDocs = new int [ maxDoc / 64 ] ; }
public void add ( int a , int b ) { add ( Interval . of ( a , b ) ) ; }
public void cloneStyleFrom ( HSSFCellStyle source ) { _format . cloneStyleFrom ( source . _format ) ; if ( _workbook != source . _workbook ) { lastDateFormat . set ( Short . MIN_VALUE ) ; lastFormats . remove ( ) ; getDataFormatStringCache . remove ( ) ; short fmt = ( short ) _workbook . createFormat ( source . getDataFormatString ( ) ) ; setDataFormat ( fmt ) ; FontRecord fr = _workbook . createNewFont ( ) ; fr . cloneStyleFrom ( source . _workbook . getFontRecordAt ( source . getFontIndexAsInt ( ) ) ) ; HSSFFont font = new HSSFFont ( ( short ) _workbook . getFontIndex ( fr ) , fr ) ; setFont ( font ) ; } }
public DeleteIdentitiesResult deleteIdentities ( DeleteIdentitiesRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteIdentities ( request ) ; }
public void nextSlice ( ) { final int nextIndex = ( ( buffer [ limit ] & 0xff ) << 24 ) + ( ( buffer [ 1 + limit ] & 0xff ) << 16 ) + ( ( buffer [ 2 + limit ] & 0xff ) << 8 ) + ( buffer [ 3 + limit ] & 0xff ) ; level = ByteBlockPool . NEXT_LEVEL_ARRAY [ level ] ; final int newSize = ByteBlockPool . LEVEL_SIZE_ARRAY [ level ] ; bufferUpto = nextIndex / ByteBlockPool . BYTE_BLOCK_SIZE ; bufferOffset = bufferUpto * ByteBlockPool . BYTE_BLOCK_SIZE ; buffer = pool . buffers [ bufferUpto ] ; upto = nextIndex & ByteBlockPool . BYTE_BLOCK_MASK ; if ( nextIndex + newSize >= endIndex ) { assert endIndex - nextIndex > 0 ; limit = endIndex - bufferOffset ; } else { limit = upto + newSize - 4 ; } }
public DeleteMessageBatchRequest ( String queueUrl , java . util . List < DeleteMessageBatchRequestEntry > entries ) { setQueueUrl ( queueUrl ) ; setEntries ( entries ) ; }
public ReservedCacheNode purchaseReservedCacheNodesOffering ( PurchaseReservedCacheNodesOfferingRequest request ) { request = beforeClientExecution ( request ) ; return executePurchaseReservedCacheNodesOffering ( request ) ; }
public String getLineText ( ) { final int eol = RawParseUtils . nextLF ( buf , offset ) ; return RawParseUtils . decode ( UTF_8 , buf , offset , eol ) ; }
public DescribeNotificationConfigurationsResult describeNotificationConfigurations ( DescribeNotificationConfigurationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNotificationConfigurations ( request ) ; }
@ Override public boolean remove ( Object object ) { if ( ! esDelegate . remove ( object ) ) { return false ; } Entry <? , ?> entry = ( Entry <? , ?> ) object ; inverse . delegate . remove ( entry . getValue ( ) ) ; return true ; }
public static byte [ ] grow ( byte [ ] array ) { return grow ( array , 1 + array . length ) ; }
public IndexAndTaxonomyRevision ( IndexWriter indexWriter , SnapshotDirectoryTaxonomyWriter taxoWriter ) throws IOException { IndexDeletionPolicy delPolicy = indexWriter . getConfig ( ) . getIndexDeletionPolicy ( ) ; if ( ! ( delPolicy instanceof SnapshotDeletionPolicy ) ) { throw new IllegalArgumentException ( " IndexWriter ▁ must ▁ be ▁ created ▁ with ▁ SnapshotDeletionPolicy " ) ; } this . indexWriter = indexWriter ; this . taxoWriter = taxoWriter ; this . indexSDP = ( SnapshotDeletionPolicy ) delPolicy ; this . taxoSDP = taxoWriter . getDeletionPolicy ( ) ; this . indexCommit = indexSDP . snapshot ( ) ; this . taxoCommit = taxoSDP . snapshot ( ) ; this . version = revisionVersion ( indexCommit , taxoCommit ) ; this . sourceFiles = revisionFiles ( indexCommit , taxoCommit ) ; }
public synchronized String toString ( ) { return super . toString ( ) ; }
public static int hashCode ( Object o ) { return ( o == null ) ? 0 : o . hashCode ( ) ; }
public GetModelTemplateResult getModelTemplate ( GetModelTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeGetModelTemplate ( request ) ; }
public XORShift64Random ( long seed ) { x = seed == 0 ? 0xdeadbeef : seed ; }
public HeaderFooterRecord ( RecordInputStream in ) { _rawData = in . readRemainder ( ) ; }
public HSSFPolygon createPolygon ( HSSFClientAnchor anchor ) { HSSFPolygon shape = new HSSFPolygon ( null , anchor ) ; addShape ( shape ) ; onCreate ( shape ) ; return shape ; }
public boolean equals ( Object other ) { if ( other == null ) { return false ; } if ( other instanceof BytesRef ) { return this . bytesEquals ( ( BytesRef ) other ) ; } return false ; }
public void decode ( long [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; for ( int shift = 48 ; shift >= 0 ; shift -= 16 ) { values [ valuesOffset ++ ] = ( block >>> shift ) & 65535 ; } } }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; if ( remainingData == null ) { remainingData = EMPTY ; } LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; LittleEndian . putInt ( data , offset + 4 , remainingData . length ) ; System . arraycopy ( remainingData , 0 , data , offset + 8 , remainingData . length ) ; int pos = offset + 8 + remainingData . length ; listener . afterRecordSerialize ( pos , getRecordId ( ) , pos - offset , this ) ; return pos - offset ; }
public boolean equals ( Object o ) { if ( ! super . equals ( o ) ) { return false ; } SpanPositionRangeQuery other = ( SpanPositionRangeQuery ) o ; return this . end == other . end && this . start == other . start ; }
public CreateSignalingChannelResult createSignalingChannel ( CreateSignalingChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSignalingChannel ( request ) ; }
public IndexDiffFilter ( int dirCacheIndex , int workingTreeIndex , boolean honorIgnores ) { this . dirCache = dirCacheIndex ; this . workingTree = workingTreeIndex ; this . honorIgnores = honorIgnores ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( " [ " + getClass ( ) . getSimpleName ( ) + " : ▁ " ) ; sb . append ( " minMergeSize = " ) . append ( minMergeSize ) . append ( " , ▁ " ) ; sb . append ( " mergeFactor = " ) . append ( mergeFactor ) . append ( " , ▁ " ) ; sb . append ( " maxMergeSize = " ) . append ( maxMergeSize ) . append ( " , ▁ " ) ; sb . append ( " maxMergeSizeForForcedMerge = " ) . append ( maxMergeSizeForForcedMerge ) . append ( " , ▁ " ) ; sb . append ( " calibrateSizeByDeletes = " ) . append ( calibrateSizeByDeletes ) . append ( " , ▁ " ) ; sb . append ( " maxMergeDocs = " ) . append ( maxMergeDocs ) . append ( " , ▁ " ) ; sb . append ( " maxCFSSegmentSizeMB = " ) . append ( getMaxCFSSegmentSizeMB ( ) ) . append ( " , ▁ " ) ; sb . append ( " noCFSRatio = " ) . append ( noCFSRatio ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public static void encode ( StringBuilder urlstr , String key ) { if ( key == null || key . length ( ) == 0 ) return ; try { urlstr . append ( URLEncoder . encode ( key , UTF_8. name ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( JGitText . get ( ) . couldNotURLEncodeToUTF8 , e ) ; } }
public DescribeTemplateResult describeTemplate ( DescribeTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTemplate ( request ) ; }
public boolean mkdirs ( ) { if ( exists ( ) ) { return false ; } if ( mkdir ( ) ) { return true ; } String parentDir = getParent ( ) ; if ( parentDir == null ) { return false ; } return ( new File ( parentDir ) . mkdirs ( ) && mkdir ( ) ) ; }
public HeaderBlock ( InputStream stream ) throws IOException { this ( readFirst512 ( stream ) ) ; if ( bigBlockSize . getBigBlockSize ( ) != 512 ) { int rest = bigBlockSize . getBigBlockSize ( ) - 512 ; byte [ ] tmp = IOUtils . safelyAllocate ( rest , MAX_RECORD_LENGTH ) ; IOUtils . readFully ( stream , tmp ) ; } }
public void recover ( LexerNoViableAltException e ) { if ( _input . LA ( 1 ) != IntStream . EOF ) { getInterpreter ( ) . consume ( _input ) ; } }
public E valueAt ( int index ) { if ( mGarbage ) { gc ( ) ; } return ( E ) mValues [ index ] ; }
public AttachToIndexResult attachToIndex ( AttachToIndexRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachToIndex ( request ) ; }
public CreateMembersResult createMembers ( CreateMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateMembers ( request ) ; }
public double get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return byteBuffer . getDouble ( position ++ * SizeOf . DOUBLE ) ; }
public WorkflowExecutionInfos listOpenWorkflowExecutions ( ListOpenWorkflowExecutionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListOpenWorkflowExecutions ( request ) ; }
public CharSequence getFirstPathElement ( ) { return values . get ( 0 ) . value ; }
public static int toEMU ( double points ) { return ( int ) Math . rint ( EMU_PER_POINT * points ) ; }
public DeleteRequestValidatorResult deleteRequestValidator ( DeleteRequestValidatorRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRequestValidator ( request ) ; }
public Repository open ( boolean mustExist ) throws IOException { if ( mustExist && ! isGitRepository ( path , fs ) ) throw new RepositoryNotFoundException ( path ) ; return new FileRepository ( path ) ; }
public GetOnPremisesInstanceResult getOnPremisesInstance ( GetOnPremisesInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeGetOnPremisesInstance ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ' ( ' ) . append ( startOffset ) . append ( ' , ' ) . append ( endOffset ) . append ( ' ) ' ) ; return sb . toString ( ) ; }
public short getFontAtIndex ( int index ) { int size = _string . getFormatRunCount ( ) ; FormatRun currentRun = null ; for ( int i = 0 ; i < size ; i ++ ) { FormatRun r = _string . getFormatRun ( i ) ; if ( r . getCharacterPos ( ) > index ) { break ; } currentRun = r ; } if ( currentRun == null ) { return NO_FONT ; } return currentRun . getFontIndex ( ) ; }
public StopMonitoringMembersResult stopMonitoringMembers ( StopMonitoringMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeStopMonitoringMembers ( request ) ; }
public DetachLoadBalancerFromSubnetsResult detachLoadBalancerFromSubnets ( DetachLoadBalancerFromSubnetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachLoadBalancerFromSubnets ( request ) ; }
public HSSFCell getCell ( int cellnum , MissingCellPolicy policy ) { HSSFCell cell = retrieveCell ( cellnum ) ; switch ( policy ) { case RETURN_NULL_AND_BLANK : return cell ; case RETURN_BLANK_AS_NULL : boolean isBlank = ( cell != null && cell . getCellType ( ) == CellType . BLANK ) ; return ( isBlank ) ? null : cell ; case CREATE_NULL_AS_BLANK : return ( cell == null ) ? createCell ( cellnum , CellType . BLANK ) : cell ; default : throw new IllegalArgumentException ( " Illegal ▁ policy ▁ " + policy ) ; } }
public SimpleQQParser ( String qqName , String indexField ) { this ( new String [ ] { qqName } , indexField ) ; }
public Query makeQuery ( int size ) throws Exception { throw new Exception ( this + " . makeQuery ( int ▁ size ) ▁ is ▁ not ▁ supported ! " ) ; }
public StringBuilder insert ( int offset , float f ) { insert0 ( offset , Float . toString ( f ) ) ; return this ; }
public Class < ConfigChangedListener > getListenerType ( ) { return ConfigChangedListener . class ; }
public AddPermissionResult addPermission ( AddPermissionRequest request ) { request = beforeClientExecution ( request ) ; return executeAddPermission ( request ) ; }
public double get ( int index ) { checkIndex ( index ) ; return byteBuffer . getDouble ( index * SizeOf . DOUBLE ) ; }
public HSSFDataFormat createDataFormat ( ) { return workbook . createDataFormat ( ) ; }
public TermData add ( TermData t1 , TermData t2 ) { if ( t1 == NO_OUTPUT ) { return t2 ; } else if ( t2 == NO_OUTPUT ) { return t1 ; } TermData ret ; if ( t2. bytes != null || t2. docFreq > 0 ) { ret = new TermData ( t2. bytes , t2. docFreq , t2. totalTermFreq ) ; } else { ret = new TermData ( t1. bytes , t1. docFreq , t1. totalTermFreq ) ; } return ret ; }
public FileSharingRecord ( RecordInputStream in ) { field_1_readonly = in . readShort ( ) ; field_2_password = in . readShort ( ) ; int nameLen = in . readShort ( ) ; if ( nameLen > 0 ) { field_3_username_unicode_options = in . readByte ( ) ; field_3_username_value = in . readCompressedUnicode ( nameLen ) ; } else { field_3_username_value = " " ; } }
public double computeProbability ( BasicStats stats ) { return ( stats . getTotalTermFreq ( ) + 1D ) / ( stats . getNumberOfFieldTokens ( ) + 1D ) ; }
public StringCharacterIterator ( String value ) { string = value ; start = offset = 0 ; end = string . length ( ) ; }
public void start ( String originalText , TokenStream tokenStream ) { position = - 1 ; currentNumFrags = 1 ; textSize = originalText . length ( ) ; termAtt = tokenStream . addAttribute ( CharTermAttribute . class ) ; posIncAtt = tokenStream . addAttribute ( PositionIncrementAttribute . class ) ; offsetAtt = tokenStream . addAttribute ( OffsetAttribute . class ) ; }
public String getSignerVersion ( ) { return null ; }
public String toString ( ) { StringBuilder b = new StringBuilder ( ) ; b . append ( " initial ▁ state : ▁ 0 \ n " ) ; for ( int i = 0 ; i < size ; i ++ ) { b . append ( " state ▁ " ) . append ( i ) ; if ( accept . get ( i ) ) b . append ( " ▁ [ accept ] :\ n " ) ; else b . append ( " ▁ [ reject ] :\ n " ) ; for ( int j = 0 ; j < points . length ; j ++ ) { int k = transitions [ i * points . length + j ] ; if ( k != - 1 ) { int min = points [ j ] ; int max ; if ( j + 1 < points . length ) max = ( points [ j + 1 ] - 1 ) ; else max = alphabetSize ; b . append ( " ▁ " ) ; Automaton . appendCharString ( min , b ) ; if ( min != max ) { b . append ( " - " ) ; Automaton . appendCharString ( max , b ) ; } b . append ( " ▁ -> ▁ " ) . append ( k ) . append ( " \ n " ) ; } } } return b . toString ( ) ; }
public synchronized long skip ( long charCount ) { if ( charCount <= 0 ) { return 0 ; } int numskipped ; if ( this . count - pos < charCount ) { numskipped = this . count - pos ; pos = this . count ; } else { numskipped = ( int ) charCount ; pos += charCount ; } return numskipped ; }
@ Override public ListIterator < E > listIterator ( int location ) { synchronized ( mutex ) { return list . listIterator ( location ) ; } }
public CreateAddressBookResult createAddressBook ( CreateAddressBookRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAddressBook ( request ) ; }
public StreamCopyThread ( InputStream i , OutputStream o ) { setName ( Thread . currentThread ( ) . getName ( ) + " - StreamCopy " ) ; src = i ; dst = o ; writeLock = new Object ( ) ; }
public AxisParentRecord ( RecordInputStream in ) { field_1_axisType = in . readShort ( ) ; field_2_x = in . readInt ( ) ; field_3_y = in . readInt ( ) ; field_4_width = in . readInt ( ) ; field_5_height = in . readInt ( ) ; }
public FieldFragList createFieldFragList ( FieldPhraseList fieldPhraseList , int fragCharSize ) { return createFieldFragList ( fieldPhraseList , new WeightedFieldFragList ( fragCharSize ) , fragCharSize ) ; }
public TrimFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void push ( TermInfo termInfo ) { termList . push ( termInfo ) ; }
public DescribeNotebookInstanceResult describeNotebookInstance ( DescribeNotebookInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNotebookInstance ( request ) ; }
public String toFormulaString ( ) { return " : " ; }
public ApplyCommand setPatch ( InputStream in ) { checkCallable ( ) ; this . in = in ; return this ; }
public void setCreationTime ( long when ) { encodeTS ( P_CTIME , when ) ; }
public static final RevFilter before ( Date ts ) { return before ( ts . getTime ( ) ) ; }
public void advertiseCapability ( String name ) { capablities . add ( name ) ; }
public StopInstancesRequest ( java . util . List < String > instanceIds ) { setInstanceIds ( instanceIds ) ; }
public CreateVpnGatewayResult createVpnGateway ( CreateVpnGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVpnGateway ( request ) ; }
public ResetCacheParameterGroupResult resetCacheParameterGroup ( ResetCacheParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeResetCacheParameterGroup ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { double result ; try { double d0 = singleOperandEvaluate ( arg0 , srcRowIndex , srcColumnIndex ) ; double d1 = singleOperandEvaluate ( arg1 , srcRowIndex , srcColumnIndex ) ; result = evaluate ( d0 , d1 ) ; if ( result == 0.0 ) { if ( ! ( this instanceof SubtractEvalClass ) ) { return NumberEval . ZERO ; } } if ( Double . isNaN ( result ) || Double . isInfinite ( result ) ) { return ErrorEval . NUM_ERROR ; } } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public PutMetricFilterRequest ( String logGroupName , String filterName , String filterPattern , java . util . List < MetricTransformation > metricTransformations ) { setLogGroupName ( logGroupName ) ; setFilterName ( filterName ) ; setFilterPattern ( filterPattern ) ; setMetricTransformations ( metricTransformations ) ; }
@ Override public E get ( int location ) { synchronized ( mutex ) { return list . get ( location ) ; } }
public IntPtg ( int value ) { if ( ! isInRange ( value ) ) { throw new IllegalArgumentException ( " value ▁ is ▁ out ▁ of ▁ range : ▁ " + value ) ; } field_1_value = value ; }
public Builder ( ) { this ( 16 , 16 ) ; }
public long getItemId ( int position ) { return position ; }
public ByteBuffer putDouble ( int index , double value ) { return putLong ( index , Double . doubleToRawLongBits ( value ) ) ; }
public void clear ( ) { value = false ; }
public CharVector ( char [ ] a ) { blockSize = DEFAULT_BLOCK_SIZE ; array = a ; n = a . length ; }
public UAX29URLEmailTokenizerFactory ( Map < String , String > args ) { super ( args ) ; maxTokenLength = getInt ( args , " maxTokenLength " , StandardAnalyzer . DEFAULT_MAX_TOKEN_LENGTH ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public long ramBytesUsed ( ) { long sizeInBytes = 0 ; for ( FieldIndexData entry : fields . values ( ) ) { sizeInBytes += entry . ramBytesUsed ( ) ; } return sizeInBytes ; }
public boolean equals ( Object other ) { if ( ! ( other instanceof CharBuffer ) ) { return false ; } CharBuffer otherBuffer = ( CharBuffer ) other ; if ( remaining ( ) != otherBuffer . remaining ( ) ) { return false ; } int myPosition = position ; int otherPosition = otherBuffer . position ; boolean equalSoFar = true ; while ( equalSoFar && ( myPosition < limit ) ) { equalSoFar = get ( myPosition ++ ) == otherBuffer . get ( otherPosition ++ ) ; } return equalSoFar ; }
public StartDeploymentResult startDeployment ( StartDeploymentRequest request ) { request = beforeClientExecution ( request ) ; return executeStartDeployment ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ 1904 ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . is1904 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getWindowing ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / 1904 ] \ n " ) ; return buffer . toString ( ) ; }
public CreateModelResult createModel ( CreateModelRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateModel ( request ) ; }
public DoubleBuffer put ( double c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } backingArray [ offset + position ++ ] = c ; return this ; }
public SimpleFacetsExample ( ) { config . setHierarchical ( " Publish ▁ Date " , true ) ; }
public DeleteConnectionResult deleteConnection ( DeleteConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteConnection ( request ) ; }
public String getSheetFirstNameByExternSheet ( int externSheetIndex ) { return _iBook . findSheetFirstNameFromExternSheet ( externSheetIndex ) ; }
public void begin ( int timeout ) { if ( timeout <= 0 ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . invalidTimeout , Integer . valueOf ( timeout ) ) ) ; Thread . interrupted ( ) ; state . begin ( timeout ) ; }
public final T updateTop ( ) { downHeap ( 1 ) ; return heap [ 1 ] ; }
public QueryNodeException ( Message message ) { super ( message . getKey ( ) ) ; this . message = message ; }
public static double factorial ( int n ) { double d = 1 ; if ( n >= 0 ) { if ( n <= 170 ) { for ( int i = 1 ; i <= n ; i ++ ) { d *= i ; } } else { d = Double . POSITIVE_INFINITY ; } } else { d = Double . NaN ; } return d ; }
public void sort ( RevSort s ) { assertNotStarted ( ) ; sorting . clear ( ) ; sorting . add ( s ) ; }
public CreateAuthorizerResult createAuthorizer ( CreateAuthorizerRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAuthorizer ( request ) ; }
public boolean isDeltaCompress ( ) { return deltaCompress ; }
public CreateWorkGroupResult createWorkGroup ( CreateWorkGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateWorkGroup ( request ) ; }
public BatchDetectSyntaxResult batchDetectSyntax ( BatchDetectSyntaxRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDetectSyntax ( request ) ; }
public void removeManager ( ) { remove1stProperty ( PropertyIDMap . PID_MANAGER ) ; }
public Set keySet ( ) { return Collections . unmodifiableSet ( dictionary . values ( ) ) ; }
public long hash1 ( char carray [ ] ) { final long p = 1099511628211L ; long hash = 0xcbf29ce484222325L ; for ( int i = 0 ; i < carray . length ; i ++ ) { char d = carray [ i ] ; hash = ( hash ^ ( d & 0x00FF ) ) * p ; hash = ( hash ^ ( d >> 8 ) ) * p ; } return hash ; }
public PutScalingPolicyResult putScalingPolicy ( PutScalingPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executePutScalingPolicy ( request ) ; }
public KeywordRepeatFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void recycleByteBlocks ( List < byte [ ] > blocks ) { final byte [ ] [ ] b = blocks . toArray ( new byte [ blocks . size ( ) ] [ ] ) ; recycleByteBlocks ( b , 0 , b . length ) ; }
public List < Token > get ( int start , int stop ) { if ( start < 0 || stop < 0 ) return null ; lazyInit ( ) ; List < Token > subset = new ArrayList < Token > ( ) ; if ( stop >= tokens . size ( ) ) stop = tokens . size ( ) - 1 ; for ( int i = start ; i <= stop ; i ++ ) { Token t = tokens . get ( i ) ; if ( t . getType ( ) == Token . EOF ) break ; subset . add ( t ) ; } return subset ; }
public String toString ( ) { return tokenName + " : " + type ; }
public static Automaton build ( Collection < BytesRef > input ) { final DaciukMihovAutomatonBuilder builder = new DaciukMihovAutomatonBuilder ( ) ; char [ ] chars = new char [ 0 ] ; CharsRef ref = new CharsRef ( ) ; for ( BytesRef b : input ) { chars = ArrayUtil . grow ( chars , b . length ) ; final int len = UnicodeUtil . UTF8toUTF16 ( b , chars ) ; ref . chars = chars ; ref . length = len ; builder . add ( ref ) ; } Automaton . Builder a = new Automaton . Builder ( ) ; convert ( a , builder . complete ( ) , new IdentityHashMap < State , Integer > ( ) ) ; return a . finish ( ) ; }
public Row merge ( Row master , Row existing ) { Iterator < Character > i = master . cells . keySet ( ) . iterator ( ) ; Row n = new Row ( ) ; for ( ; i . hasNext ( ) ; ) { Character ch = i . next ( ) ; Cell a = master . cells . get ( ch ) ; Cell b = existing . cells . get ( ch ) ; Cell s = ( b == null ) ? new Cell ( a ) : merge ( a , b ) ; if ( s == null ) { return null ; } n . cells . put ( ch , s ) ; } i = existing . cells . keySet ( ) . iterator ( ) ; for ( ; i . hasNext ( ) ; ) { Character ch = i . next ( ) ; if ( master . at ( ch ) != null ) { continue ; } n . cells . put ( ch , existing . at ( ch ) ) ; } return n ; }
public E peekFirst ( ) { return peekFirstImpl ( ) ; }
public static int response ( HttpConnection c ) throws IOException { try { return c . getResponseCode ( ) ; } catch ( ConnectException ce ) { final URL url = c . getURL ( ) ; final String host = ( url == null ) ? " < null > " : url . getHost ( ) ; if ( " Connection ▁ timed ▁ out : ▁ connect " . equals ( ce . getMessage ( ) ) ) throw new ConnectException ( MessageFormat . format ( JGitText . get ( ) . connectionTimeOut , host ) ) ; throw new ConnectException ( ce . getMessage ( ) + " ▁ " + host ) ; } }
public GetConfigurationResult getConfiguration ( GetConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetConfiguration ( request ) ; }
public static Collection < String > getSupportedFunctionNames ( ) { Collection < String > lst = new TreeSet <> ( ) ; lst . addAll ( FunctionEval . getSupportedFunctionNames ( ) ) ; lst . addAll ( AnalysisToolPak . getSupportedFunctionNames ( ) ) ; return Collections . unmodifiableCollection ( lst ) ; }
public PerFieldAnalyzerWrapper ( Analyzer defaultAnalyzer , Map < String , Analyzer > fieldAnalyzers ) { super ( PER_FIELD_REUSE_STRATEGY ) ; this . defaultAnalyzer = defaultAnalyzer ; this . fieldAnalyzers = ( fieldAnalyzers != null ) ? fieldAnalyzers : Collections . < String , Analyzer > emptyMap ( ) ; }
public DeletePublishingDestinationResult deletePublishingDestination ( DeletePublishingDestinationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeletePublishingDestination ( request ) ; }
public GetSendStatisticsResult getSendStatistics ( GetSendStatisticsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSendStatistics ( request ) ; }
public void copyArea ( int x , int y , int width , int height , int dx , int dy ) { if ( logger . check ( POILogger . WARN ) ) logger . log ( POILogger . WARN , " copyArea ▁ not ▁ supported " ) ; }
public AreaErrPtg ( ) { unused1 = 0 ; unused2 = 0 ; }
public GetUserSettingsResult getUserSettings ( GetUserSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetUserSettings ( request ) ; }
public static String toString ( Object obj ) { if ( obj != null ) { return obj . toString ( ) ; } else { return null ; } }
public String getAccessKeySecret ( ) { return accessKeySecret ; }
public Collection < ParseTree > evaluate ( ParseTree t ) { List < ParseTree > nodes = new ArrayList < ParseTree > ( ) ; for ( Tree c : Trees . getChildren ( t ) ) { if ( c instanceof TerminalNode ) { TerminalNode tnode = ( TerminalNode ) c ; if ( ( tnode . getSymbol ( ) . getType ( ) == tokenType && ! invert ) || ( tnode . getSymbol ( ) . getType ( ) != tokenType && invert ) ) { nodes . add ( tnode ) ; } } } return nodes ; }
public IsVpcPeeredResult isVpcPeered ( IsVpcPeeredRequest request ) { request = beforeClientExecution ( request ) ; return executeIsVpcPeered ( request ) ; }
public String toString ( ) { return " ShardRef ( shardIndex = " + shardIndex + " ▁ hitIndex = " + hitIndex + " ) " ; }
public TerminateJobFlowsRequest ( java . util . List < String > jobFlowIds ) { setJobFlowIds ( jobFlowIds ) ; }
public DatRecord ( RecordInputStream in ) { field_1_options = in . readShort ( ) ; }
public void removeExFormatRecord ( int index ) { int xfptr = records . getXfpos ( ) - ( numxfs - 1 ) + index ; records . remove ( xfptr ) ; numxfs -- ; }
public double get ( String name , double dflt ) { double vals [ ] = ( double [ ] ) valByRound . get ( name ) ; if ( vals != null ) { return vals [ roundNumber % vals . length ] ; } String sval = props . getProperty ( name , " " + dflt ) ; if ( sval . indexOf ( " : " ) < 0 ) { return Double . parseDouble ( sval ) ; } int k = sval . indexOf ( " : " ) ; String colName = sval . substring ( 0 , k ) ; sval = sval . substring ( k + 1 ) ; colForValByRound . put ( name , colName ) ; vals = propToDoubleArray ( sval ) ; valByRound . put ( name , vals ) ; return vals [ roundNumber % vals . length ] ; }
public BlockPackedReaderIterator ( DataInput in , int packedIntsVersion , int blockSize , long valueCount ) { checkBlockSize ( blockSize , MIN_BLOCK_SIZE , MAX_BLOCK_SIZE ) ; this . packedIntsVersion = packedIntsVersion ; this . blockSize = blockSize ; this . values = new long [ blockSize ] ; this . valuesRef = new LongsRef ( this . values , 0 , 0 ) ; reset ( in , valueCount ) ; }
public void reset ( ) { if ( ! first ( ) ) { ptr = treeStart ; nextSubtreePos = 0 ; currentEntry = null ; currentSubtree = null ; if ( ! eof ( ) ) parseEntry ( ) ; } }
public BytesRef getPayload ( ) { if ( payloadLength == 0 ) { return null ; } else { return payload ; } }
public synchronized void setIndeterminate ( boolean indeterminate ) { if ( ( ! mOnlyIndeterminate || ! mIndeterminate ) && indeterminate != mIndeterminate ) { mIndeterminate = indeterminate ; if ( indeterminate ) { mCurrentDrawable = mIndeterminateDrawable ; startAnimation ( ) ; } else { mCurrentDrawable = mProgressDrawable ; stopAnimation ( ) ; } } }
public void notifyDeleteCell ( HSSFCell cell ) { _bookEvaluator . notifyDeleteCell ( new HSSFEvaluationCell ( cell ) ) ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof FieldCacheSource ) ) return false ; FieldCacheSource other = ( FieldCacheSource ) o ; return this . field . equals ( other . field ) ; }
public DescribeLoaResult describeLoa ( DescribeLoaRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLoa ( request ) ; }
public final K next ( ) { return nextEntry ( ) . key ; }
public ListFleetsResult listFleets ( ListFleetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListFleets ( request ) ; }
public DelegationSet ( java . util . List < String > nameServers ) { setNameServers ( nameServers ) ; }
public GetKeyPairsResult getKeyPairs ( GetKeyPairsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetKeyPairs ( request ) ; }
public ReservedNode purchaseReservedNodeOffering ( PurchaseReservedNodeOfferingRequest request ) { request = beforeClientExecution ( request ) ; return executePurchaseReservedNodeOffering ( request ) ; }
public String getPassword ( ) { return password ; }
public String getValue ( String name ) { return nameValPairs . get ( name ) ; }
public static String format ( byte [ ] delta ) { return format ( delta , true ) ; }
public Token ( int kind , String image ) { this . kind = kind ; this . image = image ; }
public ArrayRecord ( RecordInputStream in ) { super ( in ) ; _options = in . readUShort ( ) ; _field3notUsed = in . readInt ( ) ; int formulaTokenLen = in . readUShort ( ) ; int totalFormulaLen = in . available ( ) ; _formula = Formula . read ( formulaTokenLen , in , totalFormulaLen ) ; }
public BootstrapActionConfig ( String name , ScriptBootstrapActionConfig scriptBootstrapAction ) { setName ( name ) ; setScriptBootstrapAction ( scriptBootstrapAction ) ; }
public CreateLoadBalancerPolicyResult createLoadBalancerPolicy ( CreateLoadBalancerPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLoadBalancerPolicy ( request ) ; }
public static String toHex ( short value ) { StringBuilder sb = new StringBuilder ( 4 ) ; writeHex ( sb , value & 0xFFFF , 4 , " " ) ; return sb . toString ( ) ; }
public String toString ( ) { return " MultiTermsEnum ( " + Arrays . toString ( subs ) + " ) " ; }
public PayloadSpanUtil ( IndexReaderContext context ) { this . context = context ; }
public List < FormatError > getErrors ( ) { return errors ; }
public NormalisedDecimal createNormalisedDecimal ( int pow10 ) { int missingUnderBits = _binaryExponent - 39 ; int fracPart = ( _significand . intValue ( ) << missingUnderBits ) & 0xFFFF80 ; long wholePart = _significand . shiftRight ( C_64 - _binaryExponent - 1 ) . longValue ( ) ; return new NormalisedDecimal ( wholePart , fracPart , pow10 ) ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( MINUS ) ; buffer . append ( operands [ 0 ] ) ; return buffer . toString ( ) ; }
public ListStackSetOperationResultsResult listStackSetOperationResults ( ListStackSetOperationResultsRequest request ) { request = beforeClientExecution ( request ) ; return executeListStackSetOperationResults ( request ) ; }
public static String getLocalizedMessage ( String key , Object ... args ) { return getLocalizedMessage ( key , Locale . getDefault ( ) , args ) ; }
public final String reflectAsString ( final boolean prependAttClass ) { final StringBuilder buffer = new StringBuilder ( ) ; reflectWith ( new AttributeReflector ( ) ) ; }
public CellRangeAddressBase getValuesCellRange ( ) { return getCellRange ( dataValues ) ; }
public DescribeMatchmakingConfigurationsResult describeMatchmakingConfigurations ( DescribeMatchmakingConfigurationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeMatchmakingConfigurations ( request ) ; }
public char get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return byteBuffer . getChar ( position ++ * SizeOf . CHAR ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ FtCf ▁ ] \ n " ) ; buffer . append ( " ▁ ▁ size ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( length ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ flags ▁ ▁ ▁ ▁ = ▁ " ) . append ( HexDump . toHex ( flags ) ) . append ( " \ n " ) ; buffer . append ( " [ / FtCf ▁ ] \ n " ) ; return buffer . toString ( ) ; }
public PutConfigurationSetSuppressionOptionsResult putConfigurationSetSuppressionOptions ( PutConfigurationSetSuppressionOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executePutConfigurationSetSuppressionOptions ( request ) ; }
public ListProposalVotesResult listProposalVotes ( ListProposalVotesRequest request ) { request = beforeClientExecution ( request ) ; return executeListProposalVotes ( request ) ; }
public SheetRangeEvaluator getRefEvaluatorForCurrentSheet ( ) { SheetRefEvaluator sre = new SheetRefEvaluator ( _bookEvaluator , _tracker , _sheetIndex ) ; return new SheetRangeEvaluator ( _sheetIndex , sre ) ; }
public long ramBytesUsed ( ) { return fst == null ? 0 : fst . ramBytesUsed ( ) ; }
public DataLabelExtensionRecord ( RecordInputStream in ) { rt = in . readShort ( ) ; grbitFrt = in . readShort ( ) ; in . readFully ( unused ) ; }
public ArchiveFindingsResult archiveFindings ( ArchiveFindingsRequest request ) { request = beforeClientExecution ( request ) ; return executeArchiveFindings ( request ) ; }
public ChartSubstreamRecordAggregate ( RecordStream rs ) { _bofRec = ( BOFRecord ) rs . getNext ( ) ; List < RecordBase > temp = new ArrayList <> ( ) ; while ( rs . peekNextClass ( ) != EOFRecord . class ) { if ( PageSettingsBlock . isComponentRecord ( rs . peekNextSid ( ) ) ) { if ( _psBlock != null ) { if ( rs . peekNextSid ( ) == HeaderFooterRecord . sid ) { _psBlock . addLateHeaderFooter ( ( HeaderFooterRecord ) rs . getNext ( ) ) ; continue ; } throw new IllegalStateException ( " Found ▁ more ▁ than ▁ one ▁ PageSettingsBlock ▁ in ▁ chart ▁ sub - stream , ▁ had ▁ sid : ▁ " + rs . peekNextSid ( ) ) ; } _psBlock = new PageSettingsBlock ( rs ) ; temp . add ( _psBlock ) ; continue ; } temp . add ( rs . getNext ( ) ) ; } _recs = temp ; org . apache . poi . hssf . record . Record eof = rs . getNext ( ) ; if ( ! ( eof instanceof EOFRecord ) ) { throw new IllegalStateException ( " Bad ▁ chart ▁ EOF " ) ; } }
public CreateSnapshotsResult createSnapshots ( CreateSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSnapshots ( request ) ; }
public String toFormulaString ( ) { return " ( ) " ; }
@ Override public Iterator < Entry < K , V >> iterator ( ) { final Iterator < Entry < K , V >> iterator = filteredEntrySet . iterator ( ) ; return new UnmodifiableIterator < Entry < K , V >> ( ) ; }
public UnmonitorInstancesRequest ( java . util . List < String > instanceIds ) { setInstanceIds ( instanceIds ) ; }
public static Inflater get ( ) { final Inflater r = getImpl ( ) ; return r != null ? r : new Inflater ( false ) ; }
public long get ( int index ) { checkIndex ( index ) ; return byteBuffer . getLong ( index * SizeOf . LONG ) ; }
public IntervalSet complement ( int minElement , int maxElement ) { return this . complement ( IntervalSet . of ( minElement , maxElement ) ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " < sortedset " + " : ▁ \ " " ) . append ( getField ( ) ) . append ( " \ " > " ) ; if ( getReverse ( ) ) buffer . append ( ' ! ' ) ; if ( missingValue != null ) { buffer . append ( " ▁ missingValue = " ) ; buffer . append ( missingValue ) ; } buffer . append ( " ▁ selector = " ) ; buffer . append ( selector ) ; return buffer . toString ( ) ; }
public DescribeTrafficMirrorSessionsResult describeTrafficMirrorSessions ( DescribeTrafficMirrorSessionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTrafficMirrorSessions ( request ) ; }
public boolean isDirect ( ) { return byteBuffer . isDirect ( ) ; }
public Set < String > getConflicting ( ) { return Collections . unmodifiableSet ( diff . getConflicting ( ) ) ; }
public ListDeviceEventsResult listDeviceEvents ( ListDeviceEventsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDeviceEvents ( request ) ; }
@ Override public boolean isEmpty ( ) { return BoundedMap . this . isEmpty ( ) ; }
public EscherSimpleProperty ( short id , int propertyValue ) { super ( id ) ; this . propertyValue = propertyValue ; }
public PointPrefixTreeFieldCacheProvider ( SpatialPrefixTree grid , String shapeField , int defaultSize ) { super ( shapeField , defaultSize ) ; this . grid = grid ; }
public void writeByte ( byte b ) { assert pos < limit ; bytes [ pos ++ ] = b ; }
public DescribeTransitGatewayPeeringAttachmentsResult describeTransitGatewayPeeringAttachments ( DescribeTransitGatewayPeeringAttachmentsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTransitGatewayPeeringAttachments ( request ) ; }
public Set < Entry < String , Ref >> entrySet ( ) { if ( entrySet == null ) { entrySet = new AbstractSet < Entry < String , Ref >> ( ) ; } }
public final ValueEval evaluate ( ValueEval [ ] args , int srcCellRow , int srcCellCol ) { try { return evaluateFunc ( args , srcCellRow , srcCellCol ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public CreateConfigurationTemplateRequest ( String applicationName , String templateName ) { setApplicationName ( applicationName ) ; setTemplateName ( templateName ) ; }
public GetUsagePlansResult getUsagePlans ( GetUsagePlansRequest request ) { request = beforeClientExecution ( request ) ; return executeGetUsagePlans ( request ) ; }
public static int serializePtgs ( Ptg [ ] ptgs , byte [ ] array , int offset ) { LittleEndianByteArrayOutputStream out = new LittleEndianByteArrayOutputStream ( array , offset ) ; List < Ptg > arrayPtgs = null ; for ( Ptg ptg : ptgs ) { ptg . write ( out ) ; if ( ptg instanceof ArrayPtg ) { if ( arrayPtgs == null ) { arrayPtgs = new ArrayList <> ( 5 ) ; } arrayPtgs . add ( ptg ) ; } } if ( arrayPtgs != null ) { for ( Ptg arrayPtg : arrayPtgs ) { ArrayPtg p = ( ArrayPtg ) arrayPtg ; p . writeTokenValueBytes ( out ) ; } } return out . getWriteIndex ( ) - offset ; }
public int size ( ) { return lines . size ( ) - 2 ; }
public NumberRecord ( RecordInputStream in ) { super ( in ) ; field_4_value = in . readDouble ( ) ; }
public UnpeerVpcResult unpeerVpc ( UnpeerVpcRequest request ) { request = beforeClientExecution ( request ) ; return executeUnpeerVpc ( request ) ; }
public DescribeTransitGatewayMulticastDomainsResult describeTransitGatewayMulticastDomains ( DescribeTransitGatewayMulticastDomainsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTransitGatewayMulticastDomains ( request ) ; }
public final Break getBreak ( int main ) { Integer rowKey = Integer . valueOf ( main ) ; return _breakMap . get ( rowKey ) ; }
public HSSFPatternFormatting getPatternFormatting ( ) { return getPatternFormatting ( false ) ; }
public FileMode getMode ( Side side ) { return side == Side . OLD ? getOldMode ( ) : getNewMode ( ) ; }
public StringBuffer append ( int i ) { IntegralToString . appendInt ( this , i ) ; return this ; }
public boolean requiresCommitBody ( ) { return true ; }
public boolean remove ( Object object ) { Iterator <?> it = iterator ( ) ; if ( object != null ) { while ( it . hasNext ( ) ) { if ( object . equals ( it . next ( ) ) ) { it . remove ( ) ; return true ; } } } else { while ( it . hasNext ( ) ) { if ( it . next ( ) == null ) { it . remove ( ) ; return true ; } } } return false ; }
public Object get ( CharSequence key ) { return trie . get ( key ) ; }
public SubmoduleInitCommand submoduleInit ( ) { return new SubmoduleInitCommand ( repo ) ; }
public GetRepositoryPolicyResult getRepositoryPolicy ( GetRepositoryPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRepositoryPolicy ( request ) ; }
public HSSFPicture createPicture ( ClientAnchor anchor , int pictureIndex ) { return createPicture ( ( HSSFClientAnchor ) anchor , pictureIndex ) ; }
public int fillFields ( byte [ ] data , int pOffset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , pOffset ) ; int bytesWritten = 8 ; int offset = pOffset + 8 ; while ( bytesRemaining > 0 && offset < data . length ) { EscherRecord child = recordFactory . createRecord ( data , offset ) ; int childBytesWritten = child . fillFields ( data , offset , recordFactory ) ; bytesWritten += childBytesWritten ; offset += childBytesWritten ; bytesRemaining -= childBytesWritten ; addChildRecord ( child ) ; if ( offset >= data . length && bytesRemaining > 0 ) { _remainingLength = bytesRemaining ; if ( log . check ( POILogger . WARN ) ) { log . log ( POILogger . WARN , " Not ▁ enough ▁ Escher ▁ data : ▁ " + bytesRemaining + " ▁ bytes ▁ remaining ▁ but ▁ no ▁ space ▁ left " ) ; } } } return bytesWritten ; }
public void startElement ( String namespace , String simple , String qualified , Attributes attributes ) { int elemType = getElementType ( qualified ) ; switch ( elemType ) { case PAGE : title = null ; body = null ; time = null ; id = null ; break ; case BODY : case DATE : case TITLE : case ID : contents . setLength ( 0 ) ; break ; default : } }
public AbbreviatedObjectId abbreviate ( int len ) { final int a = AbbreviatedObjectId . mask ( len , 1 , w1 ) ; final int b = AbbreviatedObjectId . mask ( len , 2 , w2 ) ; final int c = AbbreviatedObjectId . mask ( len , 3 , w3 ) ; final int d = AbbreviatedObjectId . mask ( len , 4 , w4 ) ; final int e = AbbreviatedObjectId . mask ( len , 5 , w5 ) ; return new AbbreviatedObjectId ( len , a , b , c , d , e ) ; }
public String toString ( ) { return " { " + precedence + " >= prec } ? " ; }
public IntBuffer put ( IntBuffer buf ) { throw new ReadOnlyBufferException ( ) ; }
public static PathSuffixFilter create ( String path ) { if ( path . length ( ) == 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . emptyPathNotPermitted ) ; return new PathSuffixFilter ( path ) ; }
public static Cell getCell ( Row row , int columnIndex ) { Cell cell = row . getCell ( columnIndex ) ; if ( cell == null ) { cell = row . createCell ( columnIndex ) ; } return cell ; }
public void write ( ByteBuffer src , long position ) { long endPosition = position + src . capacity ( ) ; if ( endPosition > buffer . length ) { extend ( endPosition ) ; } src . get ( buffer , ( int ) position , src . capacity ( ) ) ; if ( endPosition > size ) { size = endPosition ; } }
public void print ( int i ) { print ( String . valueOf ( i ) ) ; }
public ICUNormalizer2CharFilterFactory ( Map < String , String > args ) { super ( args ) ; String form = get ( args , " form " , " nfkc □ cf " ) ; String mode = get ( args , " mode " , Arrays . asList ( " compose " , " decompose " ) , " compose " ) ; Normalizer2 normalizer = Normalizer2. getInstance ( null , form , " compose " . equals ( mode ) ? Normalizer2. Mode . COMPOSE : Normalizer2. Mode . DECOMPOSE ) ; String filter = get ( args , " filter " ) ; if ( filter != null ) { UnicodeSet set = new UnicodeSet ( filter ) ; if ( ! set . isEmpty ( ) ) { set . freeze ( ) ; normalizer = new FilteredNormalizer2 ( normalizer , set ) ; } } if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } this . normalizer = normalizer ; }
public CreateAdditionalAssignmentsForHITResult createAdditionalAssignmentsForHIT ( CreateAdditionalAssignmentsForHITRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAdditionalAssignmentsForHIT ( request ) ; }
public DeleteEventRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " DeleteEvent " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public long getSize ( ) { return size ; }
public void undeprecateWorkflowType ( UndeprecateWorkflowTypeRequest request ) { request = beforeClientExecution ( request ) ; executeUndeprecateWorkflowType ( request ) ; }
public boolean removeValue ( final int o ) { boolean rval = false ; for ( int j = 0 ; ! rval && ( j < _limit ) ; j ++ ) { if ( o == _array [ j ] ) { if ( j + 1 < _limit ) { System . arraycopy ( _array , j + 1 , _array , j , _limit - j ) ; } _limit -- ; rval = true ; } } return rval ; }
public String toString ( ) { return new String ( buf , 0 , size ( ) ) ; }
public void setDirCacheIterator ( TreeWalk walk , int treeId ) { state . walk = walk ; state . dirCacheTree = treeId ; }
public DescribeOrganizationResult describeOrganization ( DescribeOrganizationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeOrganization ( request ) ; }
public CharsRef ( int capacity ) { chars = new char [ capacity ] ; }
public RebootInstanceResult rebootInstance ( RebootInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeRebootInstance ( request ) ; }
public static TreeFilter create ( Collection < TreeFilter > list ) { if ( list . size ( ) < 2 ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastTwoFiltersNeeded ) ; final TreeFilter [ ] subfilters = new TreeFilter [ list . size ( ) ] ; list . toArray ( subfilters ) ; if ( subfilters . length == 2 ) return create ( subfilters [ 0 ] , subfilters [ 1 ] ) ; return new List ( subfilters ) ; }
public long ramBytesUsed ( ) { long ramBytesUsed = BASE_RAM_BYTES_USED ; ramBytesUsed += fields . size ( ) * 2L * RamUsageEstimator . NUM_BYTES_OBJECT_REF ; ramBytesUsed += formats . size ( ) * 2L * RamUsageEstimator . NUM_BYTES_OBJECT_REF ; for ( Map . Entry < String , FieldsProducer > entry : formats . entrySet ( ) ) { ramBytesUsed += entry . getValue ( ) . ramBytesUsed ( ) ; } return ramBytesUsed ; }
public ExportApiResult exportApi ( ExportApiRequest request ) { request = beforeClientExecution ( request ) ; return executeExportApi ( request ) ; }
public void setExpectedOldObjectId ( AnyObjectId id ) { expValue = id != null ? id . toObjectId ( ) : null ; }
public void skipBytes ( long count ) { pos += count ; }
public String toString ( ) { return String . valueOf ( _value ) ; }
public boolean isPopupShowing ( ) { return mPopup . isShowing ( ) ; }
public DBClusterSnapshot deleteDBClusterSnapshot ( DeleteDBClusterSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDBClusterSnapshot ( request ) ; }
public Filter ( String name , java . util . List < String > values ) { setName ( name ) ; setValues ( values ) ; }
public SearchRoomsResult searchRooms ( SearchRoomsRequest request ) { request = beforeClientExecution ( request ) ; return executeSearchRooms ( request ) ; }
public int read ( byte [ ] buf , int off , int cnt ) throws IOException { try { beginRead ( ) ; return super . read ( buf , off , cnt ) ; } catch ( InterruptedIOException e ) { throw readTimedOut ( e ) ; } finally { endRead ( ) ; } }
public DeleteLoadBalancerTlsCertificateResult deleteLoadBalancerTlsCertificate ( DeleteLoadBalancerTlsCertificateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLoadBalancerTlsCertificate ( request ) ; }
public static MessageDigest newMessageDigest ( ) { try { return MessageDigest . getInstance ( HASH_FUNCTION ) ; } catch ( NoSuchAlgorithmException nsae ) { throw new RuntimeException ( MessageFormat . format ( JGitText . get ( ) . requiredHashFunctionNotAvailable , HASH_FUNCTION ) , nsae ) ; } }
public IfFunction ( ValueSource ifSource , ValueSource trueSource , ValueSource falseSource ) { this . ifSource = ifSource ; this . trueSource = trueSource ; this . falseSource = falseSource ; }
public static double npv ( double r , double [ ] cfs ) { double npv = 0 ; double r1 = r + 1 ; double trate = r1 ; for ( int i = 0 , iSize = cfs . length ; i < iSize ; i ++ ) { npv += cfs [ i ] / trate ; trate *= r1 ; } return npv ; }
public StandardQueryTreeBuilder ( ) { setBuilder ( GroupQueryNode . class , new GroupQueryNodeBuilder ( ) ) ; setBuilder ( FieldQueryNode . class , new FieldQueryNodeBuilder ( ) ) ; setBuilder ( BooleanQueryNode . class , new BooleanQueryNodeBuilder ( ) ) ; setBuilder ( FuzzyQueryNode . class , new FuzzyQueryNodeBuilder ( ) ) ; setBuilder ( PointQueryNode . class , new DummyQueryNodeBuilder ( ) ) ; setBuilder ( PointRangeQueryNode . class , new PointRangeQueryNodeBuilder ( ) ) ; setBuilder ( BoostQueryNode . class , new BoostQueryNodeBuilder ( ) ) ; setBuilder ( ModifierQueryNode . class , new ModifierQueryNodeBuilder ( ) ) ; setBuilder ( WildcardQueryNode . class , new WildcardQueryNodeBuilder ( ) ) ; setBuilder ( TokenizedPhraseQueryNode . class , new PhraseQueryNodeBuilder ( ) ) ; setBuilder ( MatchNoDocsQueryNode . class , new MatchNoDocsQueryNodeBuilder ( ) ) ; setBuilder ( PrefixWildcardQueryNode . class , new PrefixWildcardQueryNodeBuilder ( ) ) ; setBuilder ( TermRangeQueryNode . class , new TermRangeQueryNodeBuilder ( ) ) ; setBuilder ( RegexpQueryNode . class , new RegexpQueryNodeBuilder ( ) ) ; setBuilder ( SlopQueryNode . class , new SlopQueryNodeBuilder ( ) ) ; setBuilder ( SynonymQueryNode . class , new SynonymQueryNodeBuilder ( ) ) ; setBuilder ( MultiPhraseQueryNode . class , new MultiPhraseQueryNodeBuilder ( ) ) ; setBuilder ( MatchAllDocsQueryNode . class , new MatchAllDocsQueryNodeBuilder ( ) ) ; }
public StringBuilder append ( double d ) { RealToString . getInstance ( ) . appendDouble ( this , d ) ; return this ; }
public Tag ( String key , String value ) { setKey ( key ) ; setValue ( value ) ; }
public FederatedUser ( String federatedUserId , String arn ) { setFederatedUserId ( federatedUserId ) ; setArn ( arn ) ; }
public QueryRescorer ( Query query ) { this . query = query ; }
public void setRule ( int idx , HSSFConditionalFormattingRule cfRule ) { cfAggregate . setRule ( idx , cfRule . getCfRuleRecord ( ) ) ; }
public RenameDetector getRenameDetector ( ) { return renameDetector ; }
public UpdateTemplatePermissionsResult updateTemplatePermissions ( UpdateTemplatePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTemplatePermissions ( request ) ; }
public DoubleBuffer put ( int index , double c ) { checkIndex ( index ) ; byteBuffer . putDouble ( index * SizeOf . DOUBLE , c ) ; return this ; }
public ResetInstanceAttributeResult resetInstanceAttribute ( ResetInstanceAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeResetInstanceAttribute ( request ) ; }
public DirectoryEntry getDirectory ( ) throws IOException { EmbeddedObjectRefSubRecord subRecord = findObjectRecord ( ) ; int streamId = subRecord . getStreamId ( ) . intValue ( ) ; String streamName = " MBD " + HexDump . toHex ( streamId ) ; Entry entry = _root . getEntry ( streamName ) ; if ( entry instanceof DirectoryEntry ) { return ( DirectoryEntry ) entry ; } throw new IOException ( " Stream ▁ " + streamName + " ▁ was ▁ not ▁ an ▁ OLE2 ▁ directory " ) ; }
public HashMap ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( " Capacity : ▁ " + capacity ) ; } if ( capacity == 0 ) { @ SuppressWarnings ( " unchecked " ) HashMapEntry < K , V > [ ] tab = ( HashMapEntry < K , V > [ ] ) EMPTY_TABLE ; table = tab ; threshold = - 1 ; return ; } if ( capacity < MINIMUM_CAPACITY ) { capacity = MINIMUM_CAPACITY ; } else if ( capacity > MAXIMUM_CAPACITY ) { capacity = MAXIMUM_CAPACITY ; } else { capacity = roundUpToPowerOfTwo ( capacity ) ; } makeTable ( capacity ) ; }
public int getCachedErrorValue ( ) { return specialCachedValue . getErrorValue ( ) ; }
public void add ( BytesRef utf8 ) throws IOException { if ( writer == null ) { throw new IllegalStateException ( ) ; } writer . write ( utf8 ) ; }
public UpdateHITReviewStatusResult updateHITReviewStatus ( UpdateHITReviewStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateHITReviewStatus ( request ) ; }
public ScandinavianNormalizationFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public DBSnapshotAttributesResult describeDBSnapshotAttributes ( DescribeDBSnapshotAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBSnapshotAttributes ( request ) ; }
public GetNamespaceAuthorizationListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetNamespaceAuthorizationList " , " cr " ) ; setUriPattern ( " / namespace / [ Namespace ] / authorizations " ) ; setMethod ( MethodType . GET ) ; }
public LowFreqTerm ( int [ ] postings , byte [ ] payloads , int docFreq , int totalTermFreq ) { this . postings = postings ; this . payloads = payloads ; this . docFreq = docFreq ; this . totalTermFreq = totalTermFreq ; }
public void reset ( ) { state = null ; consumed = true ; keepOrig = false ; matched = false ; }
public static final boolean isId ( String id ) { if ( id . length ( ) < 2 || Constants . OBJECT_ID_STRING_LENGTH < id . length ( ) ) return false ; try { for ( int i = 0 ; i < id . length ( ) ; i ++ ) RawParseUtils . parseHexInt4 ( ( byte ) id . charAt ( i ) ) ; return true ; } catch ( ArrayIndexOutOfBoundsException e ) { return false ; } }
public static int entrySize ( FileMode mode , int nameLen ) { return mode . copyToLength ( ) + nameLen + OBJECT_ID_LENGTH + 2 ; }
public void exitEveryRule ( ParserRuleContext ctx ) { System . out . println ( " exit ▁ ▁ ▁ ▁ " + getRuleNames ( ) [ ctx . getRuleIndex ( ) ] + " , ▁ LT ( 1 ) = " + _input . LT ( 1 ) . getText ( ) ) ; }
public EventSubscription modifyEventSubscription ( ModifyEventSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyEventSubscription ( request ) ; }
public NormalizeCharMap build ( ) { final FST < CharsRef > map ; try { final Outputs < CharsRef > outputs = CharSequenceOutputs . getSingleton ( ) ; final FSTCompiler < CharsRef > fstCompiler = new FSTCompiler <> ( FST . INPUT_TYPE . BYTE2 , outputs ) ; final IntsRefBuilder scratch = new IntsRefBuilder ( ) ; for ( Map . Entry < String , String > ent : pendingPairs . entrySet ( ) ) { fstCompiler . add ( Util . toUTF16 ( ent . getKey ( ) , scratch ) , new CharsRef ( ent . getValue ( ) ) ) ; } map = fstCompiler . compile ( ) ; pendingPairs . clear ( ) ; } catch ( IOException ioe ) { throw new RuntimeException ( ioe ) ; } return new NormalizeCharMap ( map ) ; }
public BootstrapActions ( String bucket ) { this . bucket = bucket ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { ValueEval ve ; try { ve = OperandResolver . getSingleValue ( arg0 , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { ve = e . getErrorEval ( ) ; } return BoolEval . valueOf ( evaluate ( ve ) ) ; }
public static IndexDeletionPolicy getIndexDeletionPolicy ( Config config ) { String deletionPolicyName = config . get ( " deletion . policy " , " org . apache . lucene . index . KeepOnlyLastCommitDeletionPolicy " ) ; if ( deletionPolicyName . equals ( NoDeletionPolicy . class . getName ( ) ) ) { return NoDeletionPolicy . INSTANCE ; } else { try { return Class . forName ( deletionPolicyName ) . asSubclass ( IndexDeletionPolicy . class ) . getConstructor ( ) . newInstance ( ) ; } catch ( Exception e ) { } } }
public FontRecord ( RecordInputStream in ) { field_1_font_height = in . readShort ( ) ; field_2_attributes = in . readShort ( ) ; field_3_color_palette_index = in . readShort ( ) ; field_4_bold_weight = in . readShort ( ) ; field_5_super_sub_script = in . readShort ( ) ; field_6_underline = in . readByte ( ) ; field_7_family = in . readByte ( ) ; field_8_charset = in . readByte ( ) ; field_9_zero = in . readByte ( ) ; int field_10_font_name_len = in . readUByte ( ) ; int unicodeFlags = in . readUByte ( ) ; if ( field_10_font_name_len > 0 ) { if ( unicodeFlags == 0 ) { field_11_font_name = in . readCompressedUnicode ( field_10_font_name_len ) ; } else { field_11_font_name = in . readUnicodeLEString ( field_10_font_name_len ) ; } } else { field_11_font_name = " " ; } }
public String getRefLogMessage ( ) { return destination . getRefLogMessage ( ) ; }
public String toString ( ) { return subSlice . toString ( ) + " : " + terms ; }
public IntBuffer asReadOnlyBuffer ( ) { return ReadOnlyIntArrayBuffer . copy ( this , mark ) ; }
public void clear ( ) { super . clear ( ) ; }
public static void fill ( double [ ] array , int start , int end , double value ) { Arrays . checkStartAndEnd ( array . length , start , end ) ; for ( int i = start ; i < end ; i ++ ) { array [ i ] = value ; } }
public ByteBuffer next ( ) { if ( nextBlock == POIFSConstants . END_OF_CHAIN ) { throw new IndexOutOfBoundsException ( " Can ' t read past the end of the stream " ) ; } try ▁ { loopDetector . claim ( nextBlock ) ; ByteBuffer ▁ data ▁ = ▁ blockStore . getBlockAt ( nextBlock ) ; nextBlock ▁ = ▁ blockStore . getNextBlock ( nextBlock ) ; return ▁ data ; } ▁ catch ( IOException ▁ e ) ▁ { throw ▁ new ▁ RuntimeException ( e ) ; } }
public DFAState getCurrentState ( ) { return currentState ; }
public E lower ( E e ) { return backingMap . lowerKey ( e ) ; }
public FinnishLightStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public String toString ( ) { StringBuilder retval = new StringBuilder ( ) ; retval . append ( " [ MERGEDCELLS ] " ) . append ( " \ n " ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ . numregions ▁ = " ) . append ( getNumAreas ( ) ) . append ( " \ n " ) ; for ( int k = 0 ; k < _numberOfRegions ; k ++ ) { CellRangeAddress r = _regions [ _startIndex + k ] ; retval . append ( " ▁ ▁ ▁ ▁ ▁ . rowfrom ▁ = " ) . append ( r . getFirstRow ( ) ) . append ( " \ n " ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ . rowto ▁ ▁ ▁ = " ) . append ( r . getLastRow ( ) ) . append ( " \ n " ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ . colfrom ▁ = " ) . append ( r . getFirstColumn ( ) ) . append ( " \ n " ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ . colto ▁ ▁ ▁ = " ) . append ( r . getLastColumn ( ) ) . append ( " \ n " ) ; } retval . append ( " [ MERGEDCELLS ] " ) . append ( " \ n " ) ; return retval . toString ( ) ; }
public String getString ( int begin , int end , boolean dropLF ) { if ( begin == end ) return " " ; int s = getStart ( begin ) ; int e = getEnd ( end - 1 ) ; if ( dropLF && content [ e - 1 ] == ' \ n ' ) e -- ; return decode ( s , e ) ; }
public RevokeDomainAccessResult revokeDomainAccess ( RevokeDomainAccessRequest request ) { request = beforeClientExecution ( request ) ; return executeRevokeDomainAccess ( request ) ; }
public GetPhotoStoreRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetPhotoStore " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DescribeVirtualInterfacesResult describeVirtualInterfaces ( DescribeVirtualInterfacesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVirtualInterfaces ( request ) ; }
public EmptyTreeIterator createEmptyTreeIterator ( ) { return new EmptyTreeIterator ( this ) ; }
public File [ ] listFiles ( FileFilter filter ) { File [ ] files = listFiles ( ) ; if ( filter == null || files == null ) { return files ; } List < File > result = new ArrayList < File > ( files . length ) ; for ( File file : files ) { if ( filter . accept ( file ) ) { result . add ( file ) ; } } return result . toArray ( new File [ result . size ( ) ] ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escaper ) { if ( isDefaultField ( this . field ) ) { return this . text ; } else { return this . field + " : " + this . text ; } }
public WithdrawByoipCidrResult withdrawByoipCidr ( WithdrawByoipCidrRequest request ) { request = beforeClientExecution ( request ) ; return executeWithdrawByoipCidr ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_formatFlags ) ; }
public CharBuffer put ( int index , char c ) { checkIndex ( index ) ; byteBuffer . putChar ( index * SizeOf . CHAR , c ) ; return this ; }
public ICUTransformFilterFactory ( Map < String , String > args ) { super ( args ) ; String id = require ( args , " id " ) ; String direction = get ( args , " direction " , Arrays . asList ( " forward " , " reverse " ) , " forward " , false ) ; int dir = " forward " . equals ( direction ) ? Transliterator . FORWARD : Transliterator . REVERSE ; transliterator = Transliterator . getInstance ( id , dir ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public UpdateFilterResult updateFilter ( UpdateFilterRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFilter ( request ) ; }
public StoredField ( String name , float value ) { super ( name , TYPE ) ; fieldsData = value ; }
public final int compareTo ( Term other ) { if ( field . equals ( other . field ) ) { return bytes . compareTo ( other . bytes ) ; } else { return field . compareTo ( other . field ) ; } }
public ErrorHandler getErrorHandler ( ) { return ( theErrorHandler == this ) ? null : theErrorHandler ; }
public float getSaturation ( ) { int numBitsSet = filter . cardinality ( ) ; return ( float ) numBitsSet / ( float ) bloomSize ; }
public DeleteResolverEndpointResult deleteResolverEndpoint ( DeleteResolverEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteResolverEndpoint ( request ) ; }
public AssociateHostedConnectionResult associateHostedConnection ( AssociateHostedConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateHostedConnection ( request ) ; }
public final String name ( ) { return this . canonicalName ; }
public static void registerFunction ( String name , Function func ) { FunctionEval . registerFunction ( name , func ) ; }
public GetRepoBuildStatusRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoBuildStatus " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / build / [ BuildId ] / status " ) ; setMethod ( MethodType . GET ) ; }
public GetFramedPhotoUrlsRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetFramedPhotoUrls " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public SimpleHTMLFormatter ( String preTag , String postTag ) { this . preTag = preTag ; this . postTag = postTag ; }
public void setData ( byte [ ] b , int start , int length ) { thedata = IOUtils . safelyAllocate ( length , MAX_RECORD_LENGTH ) ; System . arraycopy ( b , start , thedata , 0 , length ) ; }
public String getKey ( ) { return key ; }
public AttachVolumeRequest ( String volumeId , String instanceId , String device ) { setVolumeId ( volumeId ) ; setInstanceId ( instanceId ) ; setDevice ( device ) ; }
public long ramBytesUsed ( ) { long size = BASE_RAM_BYTES_USED + RamUsageEstimator . shallowSizeOf ( blocks ) ; if ( blocks . length > 0 ) { size += ( blocks . length - 1 ) * bytesUsedPerBlock ; size += RamUsageEstimator . sizeOf ( blocks [ blocks . length - 1 ] ) ; } return size ; }
@ Override public Object [ ] toArray ( ) { return Lists . newArrayList ( iterator ( ) ) . toArray ( ) ; }
public RevWalk ( Repository repo , int depth ) { super ( repo ) ; this . depth = depth ; this . deepenNots = Collections . emptyList ( ) ; this . UNSHALLOW = newFlag ( " UNSHALLOW " ) ; this . REINTERESTING = newFlag ( " REINTERESTING " ) ; this . DEEPEN_NOT = newFlag ( " DEEPEN □ NOT " ) ; }
public boolean equals ( Object o ) { return this == o ; }
public ChangeResourceRecordSetsResult changeResourceRecordSets ( ChangeResourceRecordSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeChangeResourceRecordSets ( request ) ; }
public Iterator < K > iterator ( ) { return newKeyIterator ( ) ; }
@ Override public boolean equals ( Object o ) { return o instanceof ReverseComparator2 && ( ( ReverseComparator2 ) o ) . cmp . equals ( cmp ) ; }
public boolean isCheckEofAfterPackFooter ( ) { return checkEofAfterPackFooter ; }
public DescribeDirectConnectGatewayAssociationProposalsResult describeDirectConnectGatewayAssociationProposals ( DescribeDirectConnectGatewayAssociationProposalsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDirectConnectGatewayAssociationProposals ( request ) ; }
public void reset ( byte [ ] bytes , int offset , int len ) { this . bytes = bytes ; pos = offset ; limit = offset + len ; }
public ByteBuffer putFloat ( int index , float value ) { throw new ReadOnlyBufferException ( ) ; }
public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( ! getClass ( ) . equals ( obj . getClass ( ) ) ) return false ; return toString ( ) . equals ( obj . toString ( ) ) ; }
public PutSchemaFromJsonResult putSchemaFromJson ( PutSchemaFromJsonRequest request ) { request = beforeClientExecution ( request ) ; return executePutSchemaFromJson ( request ) ; }
public UnassignPrivateIpAddressesResult unassignPrivateIpAddresses ( UnassignPrivateIpAddressesRequest request ) { request = beforeClientExecution ( request ) ; return executeUnassignPrivateIpAddresses ( request ) ; }
public ArrayPtg finishReading ( LittleEndianInput in ) { int nColumns = in . readUByte ( ) ; short nRows = in . readShort ( ) ; nColumns ++ ; nRows ++ ; int totalCount = nRows * nColumns ; Object [ ] arrayValues = ConstantValueParser . parse ( in , totalCount ) ; ArrayPtg result = new ArrayPtg ( _reserved0 , _reserved1 , _reserved2 , nColumns , nRows , arrayValues ) ; result . setClass ( getPtgClass ( ) ) ; return result ; }
public NativeUnixDirectory ( Path path , Directory delegate ) throws IOException { this ( path , DEFAULT_MERGE_BUFFER_SIZE , DEFAULT_MIN_BYTES_DIRECT , FSLockFactory . getDefault ( ) , delegate ) ; }
public CreateRestApiResult createRestApi ( CreateRestApiRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRestApi ( request ) ; }
public ValueEval getRef3DEval ( Ref3DPtg rptg ) { SheetRangeEvaluator sre = createExternSheetRefEvaluator ( rptg . getExternSheetIndex ( ) ) ; return new LazyRefEval ( rptg . getRow ( ) , rptg . getColumn ( ) , sre ) ; }
public void add ( FieldInfos other ) { assert assertNotFinished ( ) ; for ( FieldInfo fieldInfo : other ) { add ( fieldInfo ) ; } }
public static CloseGuard get ( ) { if ( ! ENABLED ) { return NOOP ; } return new CloseGuard ( ) ; }
public void print ( long lnum ) { print ( String . valueOf ( lnum ) ) ; }
public static String fileNameFromGeneration ( String base , String ext , long gen ) { if ( gen == - 1 ) { return null ; } else if ( gen == 0 ) { return segmentFileName ( base , " " , ext ) ; } else { assert gen > 0 ; StringBuilder res = new StringBuilder ( base . length ( ) + 6 + ext . length ( ) ) . append ( base ) . append ( ' □ ' ) . append ( Long . toString ( gen , Character . MAX_RADIX ) ) ; if ( ext . length ( ) > 0 ) { res . append ( ' . ' ) . append ( ext ) ; } return res . toString ( ) ; } }
public String getText ( ) { return symbol . getText ( ) ; }
public long getSize ( ) { return delegate ( ) . getSize ( ) ; }
public FileMode getNewMode ( ) { return newMode ; }
public boolean isOpaque ( ) { return opaque ; }
public boolean requireEnd ( ) { return requireEndImpl ( address ) ; }
public static InternalWorkbook createStubWorkbook ( ExternSheetRecord [ ] externs , BoundSheetRecord [ ] bounds , SSTRecord sst ) { List < org . apache . poi . hssf . record . Record > wbRecords = new ArrayList <> ( ) ; if ( bounds != null ) { Collections . addAll ( wbRecords , bounds ) ; } if ( sst != null ) { wbRecords . add ( sst ) ; } if ( externs != null ) { wbRecords . add ( SupBookRecord . createInternalReferences ( ( short ) externs . length ) ) ; Collections . addAll ( wbRecords , externs ) ; } wbRecords . add ( EOFRecord . instance ) ; return InternalWorkbook . createWorkbook ( wbRecords ) ; }
public String getName ( ) { return null ; }
public UpdateNotebookInstanceLifecycleConfigResult updateNotebookInstanceLifecycleConfig ( UpdateNotebookInstanceLifecycleConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateNotebookInstanceLifecycleConfig ( request ) ; }
public void visitContainedRecords ( RecordVisitor rv ) { rv . visitRecord ( _pls ) ; for ( ContinueRecord _plsContinue : _plsContinues ) { rv . visitRecord ( _plsContinue ) ; } }
public static BoolEval valueOf ( boolean b ) { return b ? TRUE : FALSE ; }
public EvaluationName getName ( String name , int sheetIndex ) { for ( int i = 0 ; i < _iBook . getNumNames ( ) ; i ++ ) { NameRecord nr = _iBook . getNameRecord ( i ) ; if ( nr . getSheetNumber ( ) == sheetIndex + 1 && name . equalsIgnoreCase ( nr . getNameText ( ) ) ) { return new Name ( nr , i ) ; } } return sheetIndex == - 1 ? null : getName ( name , - 1 ) ; }
public String getPIDString ( final long pid ) { Map < Long , String > dic = getDictionary ( ) ; if ( dic == null || ! dic . containsKey ( pid ) ) { ClassID fmt = getFormatID ( ) ; if ( SummaryInformation . FORMAT_ID . equals ( fmt ) ) { dic = PropertyIDMap . getSummaryInformationProperties ( ) ; } else if ( DocumentSummaryInformation . FORMAT_ID [ 0 ] . equals ( fmt ) ) { dic = PropertyIDMap . getDocumentSummaryInformationProperties ( ) ; } } return ( dic != null && dic . containsKey ( pid ) ) ? dic . get ( pid ) : PropertyIDMap . UNDEFINED ; }
public BatchCreateRoomMembershipResult batchCreateRoomMembership ( BatchCreateRoomMembershipRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchCreateRoomMembership ( request ) ; }
public V getValue ( ) { return value ; }
public DeleteQueueResult deleteQueue ( DeleteQueueRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteQueue ( request ) ; }
public Builder ( ) { this . field = null ; this . termArrays = new ArrayList <> ( ) ; this . positions = new ArrayList <> ( ) ; this . slop = 0 ; }
public BatchRefUpdate addCommand ( ReceiveCommand cmd ) { commands . add ( cmd ) ; return this ; }
public DetachLoadBalancerTargetGroupsResult detachLoadBalancerTargetGroups ( DetachLoadBalancerTargetGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachLoadBalancerTargetGroups ( request ) ; }
public FrameRecord ( RecordInputStream in ) { field_1_borderType = in . readShort ( ) ; field_2_options = in . readShort ( ) ; }
public final Explanation explain ( BasicStats stats ) { return Explanation . match ( lambda ( stats ) , getClass ( ) . getSimpleName ( ) + " , ▁ computed ▁ as ▁ ( F ▁ + ▁ 1 ) ▁ / ▁ ( N ▁ + ▁ 1 ) ▁ from : " , Explanation . match ( stats . getTotalTermFreq ( ) , " F , ▁ total ▁ number ▁ of ▁ occurrences ▁ of ▁ term ▁ across ▁ all ▁ documents " ) , Explanation . match ( stats . getNumberOfDocuments ( ) , " N , ▁ total ▁ number ▁ of ▁ documents ▁ with ▁ field " ) ) ; }
public boolean matches ( ValueEval x ) { if ( x instanceof ErrorEval ) { int testValue = ( ( ErrorEval ) x ) . getErrorCode ( ) ; return evaluate ( testValue - _value ) ; } return false ; }
public S3Signer ( ) { this . httpVerb = null ; this . resourcePath = null ; this . additionalQueryParamsToSign = null ; }
public RejectDomainTransferFromAnotherAwsAccountResult rejectDomainTransferFromAnotherAwsAccount ( RejectDomainTransferFromAnotherAwsAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeRejectDomainTransferFromAnotherAwsAccount ( request ) ; }
public String toString ( ) { return " [ STRING ] \ n " + " ▁ ▁ ▁ ▁ . string ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + _text + " \ n " + " [ / STRING ] \ n " ; }
public GetIdentityNotificationAttributesResult getIdentityNotificationAttributes ( GetIdentityNotificationAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIdentityNotificationAttributes ( request ) ; }
public DoubleBuffer slice ( ) { return new ReadOnlyDoubleArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public void append ( int key , E value ) { if ( mSize != 0 && key <= mKeys [ mSize - 1 ] ) { put ( key , value ) ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = ArrayUtils . idealIntArraySize ( pos + 1 ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , 0 , nkeys , 0 , mKeys . length ) ; System . arraycopy ( mValues , 0 , nvalues , 0 , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + 1 ; }
public String toString ( ) { return " INDEX □ DIFF □ FILTER " ; }
public long ramBytesUsed ( ) { return docs . ramBytesUsed ( ) + RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + 2 * Integer . BYTES + 2 + Long . BYTES + RamUsageEstimator . NUM_BYTES_OBJECT_REF ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ LeftMargin ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . margin ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " ▁ ( " ) . append ( getMargin ( ) ) . append ( " ▁ ) \ n " ) ; buffer . append ( " [ / LeftMargin ] \ n " ) ; return buffer . toString ( ) ; }
public FreeTextSuggester ( Analyzer indexAnalyzer , Analyzer queryAnalyzer , int grams , byte separator ) { this . grams = grams ; this . indexAnalyzer = addShingles ( indexAnalyzer ) ; this . queryAnalyzer = addShingles ( queryAnalyzer ) ; if ( grams < 1 ) { throw new IllegalArgumentException ( " grams ▁ must ▁ be ▁ >= ▁ 1 " ) ; } if ( ( separator & 0x80 ) != 0 ) { throw new IllegalArgumentException ( " separator ▁ must ▁ be ▁ simple ▁ ascii ▁ character " ) ; } this . separator = separator ; }
public CJKWidthFilter ( TokenStream input ) { super ( input ) ; }
public ModifyVpnTunnelOptionsResult modifyVpnTunnelOptions ( ModifyVpnTunnelOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVpnTunnelOptions ( request ) ; }
public int nextDoc ( ) { while ( true ) { if ( queue . size ( ) == 0 ) { doc = NO_MORE_DOCS ; break ; } int newDoc = queue . top ( ) . docID ( ) ; if ( newDoc != doc ) { assert newDoc > doc : " doc = " + doc + " ▁ newDoc = " + newDoc ; doc = newDoc ; break ; } if ( queue . top ( ) . nextDoc ( ) == NO_MORE_DOCS ) { queue . pop ( ) ; } else { queue . updateTop ( ) ; } } return doc ; }
public GetTransitGatewayRouteTableAssociationsResult getTransitGatewayRouteTableAssociations ( GetTransitGatewayRouteTableAssociationsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTransitGatewayRouteTableAssociations ( request ) ; }
public DescribeLoggingStatusResult describeLoggingStatus ( DescribeLoggingStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLoggingStatus ( request ) ; }
public PorterStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public Storage getStorage ( ) { return storage ; }
public static CharBuffer wrap ( char [ ] array ) { return wrap ( array , 0 , array . length ) ; }
public CreateVoiceConnectorResult createVoiceConnector ( CreateVoiceConnectorRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVoiceConnector ( request ) ; }
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 24 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } } } } for ( int i = 0 ; i < 24 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } jj_endpos = 0 ; jj_rescan_token ( ) ; jj_add_error_token ( 0 , 0 ) ; int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; }
public void setSheetOrder ( String sheetname , int pos ) { int sheetNumber = getSheetIndex ( sheetname ) ; boundsheets . add ( pos , boundsheets . remove ( sheetNumber ) ) ; int initialBspos = records . getBspos ( ) ; int pos0 = initialBspos - ( boundsheets . size ( ) - 1 ) ; org . apache . poi . hssf . record . Record removed = records . get ( pos0 + sheetNumber ) ; records . remove ( pos0 + sheetNumber ) ; records . add ( pos0 + pos , removed ) ; records . setBspos ( initialBspos ) ; }
public UpdateRepoBuildRuleRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " UpdateRepoBuildRule " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / rules / [ BuildRuleId ] " ) ; setMethod ( MethodType . POST ) ; }
public boolean contains ( Object o ) { return map . containsKey ( o ) ; }
public DescribeAutoScalingInstancesResult describeAutoScalingInstances ( ) { return describeAutoScalingInstances ( new DescribeAutoScalingInstancesRequest ( ) ) ; }
public NLPTokenizerOp ( ) { tokenizer = null ; }
public int size ( ) { synchronized ( mutex ) { return delegate ( ) . size ( ) ; } }
public boolean retainAll ( final IntList c ) { boolean rval = false ; for ( int j = 0 ; j < _limit ; ) { if ( ! c . contains ( _array [ j ] ) ) { remove ( j ) ; rval = true ; } else { j ++ ; } } return rval ; }
public String getPath ( ) { return path . getPath ( ) ; }
public UpdateSecurityGroupRuleDescriptionsEgressResult updateSecurityGroupRuleDescriptionsEgress ( UpdateSecurityGroupRuleDescriptionsEgressRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateSecurityGroupRuleDescriptionsEgress ( request ) ; }
public SetVaultAccessPolicyResult setVaultAccessPolicy ( SetVaultAccessPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeSetVaultAccessPolicy ( request ) ; }
public PutAutoScalingPolicyResult putAutoScalingPolicy ( PutAutoScalingPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executePutAutoScalingPolicy ( request ) ; }
public CancelReservedInstancesListingResult cancelReservedInstancesListing ( CancelReservedInstancesListingRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelReservedInstancesListing ( request ) ; }
public String getSignerName ( ) { return null ; }
public ListTagsForDeliveryStreamResult listTagsForDeliveryStream ( ListTagsForDeliveryStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeListTagsForDeliveryStream ( request ) ; }
public RegisterDomainResult registerDomain ( RegisterDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterDomain ( request ) ; }
public ListEntityRecognizersResult listEntityRecognizers ( ListEntityRecognizersRequest request ) { request = beforeClientExecution ( request ) ; return executeListEntityRecognizers ( request ) ; }
public void setTimeout ( int millis ) { if ( millis < 0 ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . invalidTimeout , Integer . valueOf ( millis ) ) ) ; timeout = millis ; }
public GetRepoSourceRepoRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoSourceRepo " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / sourceRepo " ) ; setMethod ( MethodType . GET ) ; }
public DescribeBatchInferenceJobResult describeBatchInferenceJob ( DescribeBatchInferenceJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeBatchInferenceJob ( request ) ; }
public CreateSecurityGroupRequest ( String groupName , String description ) { setGroupName ( groupName ) ; setDescription ( description ) ; }
public final int serialize ( int offset , byte [ ] data ) { SerializingRecordVisitor srv = new SerializingRecordVisitor ( data , offset ) ; visitContainedRecords ( srv ) ; return srv . countBytesWritten ( ) ; }
public BatchGetImageResult batchGetImage ( BatchGetImageRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchGetImage ( request ) ; }
public int read ( ) throws IOException { try { beginRead ( ) ; return super . read ( ) ; } catch ( InterruptedIOException e ) { throw readTimedOut ( e ) ; } finally { endRead ( ) ; } }
public ActivityTask pollForActivityTask ( PollForActivityTaskRequest request ) { request = beforeClientExecution ( request ) ; return executePollForActivityTask ( request ) ; }
public int execute ( StringBuilder buf ) { if ( text != null ) { buf . append ( text ) ; } return lastIndex + 1 ; }
public float overheadPerValue ( int bitsPerValue ) { assert isSupported ( bitsPerValue ) ; return 0f ; }
public String toString ( ) { return buf . toString ( ) ; }
public PrecedenceQueryParser ( Analyzer analyer ) { super ( analyer ) ; setQueryNodeProcessor ( new PrecedenceQueryNodeProcessorPipeline ( getQueryConfigHandler ( ) ) ) ; }
public final int position ( ) { return position ; }
public boolean equals ( Object o ) { return this . getClass ( ) == o . getClass ( ) ; }
public IntBuffer compact ( ) { throw new ReadOnlyBufferException ( ) ; }
public void writeByte ( int v ) { writeContinueIfRequired ( 1 ) ; _ulrOutput . writeByte ( v ) ; }
public ExpireSessionResult expireSession ( ExpireSessionRequest request ) { request = beforeClientExecution ( request ) ; return executeExpireSession ( request ) ; }
public GetSubscriptionAttributesRequest ( String subscriptionArn ) { setSubscriptionArn ( subscriptionArn ) ; }
public GetMetricDataResult getMetricData ( GetMetricDataRequest request ) { request = beforeClientExecution ( request ) ; return executeGetMetricData ( request ) ; }
public DescribeDhcpOptionsResult describeDhcpOptions ( DescribeDhcpOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDhcpOptions ( request ) ; }
public NavigableSet < E > subSet ( E start , boolean startInclusive , E end , boolean endInclusive ) { Comparator <? super E > c = backingMap . comparator ( ) ; int compare = ( c == null ) ? ( ( Comparable < E > ) start ) . compareTo ( end ) : c . compare ( start , end ) ; if ( compare <= 0 ) { return new TreeSet < E > ( backingMap . subMap ( start , startInclusive , end , endInclusive ) ) ; } throw new IllegalArgumentException ( ) ; }
public SendEmailResult sendEmail ( SendEmailRequest request ) { request = beforeClientExecution ( request ) ; return executeSendEmail ( request ) ; }
public String toString ( ) { return String . valueOf ( _value ) ; }
public static double getExcelDate ( LocalDate date ) { return getExcelDate ( date , false ) ; }
public boolean equals ( Object o ) { return o instanceof ItalianStemmer ; }
public ListenerHandle addIndexChangedListener ( IndexChangedListener listener ) { return addListener ( IndexChangedListener . class , listener ) ; }
public SynthesizeSpeechResult synthesizeSpeech ( SynthesizeSpeechRequest request ) { request = beforeClientExecution ( request ) ; return executeSynthesizeSpeech ( request ) ; }
public void merge ( TextFragment frag2 ) { textEndPos = frag2. textEndPos ; score = Math . max ( score , frag2. score ) ; }
public CreateLedgerResult createLedger ( CreateLedgerRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateLedger ( request ) ; }
public DescribeFleetPortSettingsResult describeFleetPortSettings ( DescribeFleetPortSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFleetPortSettings ( request ) ; }
public String getHost ( ) { return host ; }
public short get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return byteBuffer . getShort ( position ++ * SizeOf . SHORT ) ; }
public void ReInit ( CharStream stream ) { jjmatchedPos = jjnewStateCnt = 0 ; curLexState = defaultLexState ; input_stream = stream ; ReInitRounds ( ) ; }
public void set ( int index , long value ) { final int o = index / 12 ; final int b = index % 12 ; final int shift = b * 5 ; blocks [ o ] = ( blocks [ o ] & ~ ( 31L << shift ) ) | ( value << shift ) ; }
public ByteSequencesWriter ( IndexOutput out ) { this . out = out ; }
public MultiTermsEnum ( ReaderSlice [ ] slices ) { queue = new TermMergeQueue ( slices . length ) ; top = new TermsEnumWithSlice [ slices . length ] ; subs = new TermsEnumWithSlice [ slices . length ] ; subDocs = new MultiPostingsEnum . EnumWithSlice [ slices . length ] ; for ( int i = 0 ; i < slices . length ; i ++ ) { subs [ i ] = new TermsEnumWithSlice ( i , slices [ i ] ) ; subDocs [ i ] = new MultiPostingsEnum . EnumWithSlice ( ) ; subDocs [ i ] . slice = slices [ i ] ; } currentSubs = new TermsEnumWithSlice [ slices . length ] ; }
public char last ( ) { if ( start == end ) { return DONE ; } offset = end - 1 ; return string . charAt ( offset ) ; }
public AttributeSource ( AttributeFactory factory ) { this . attributes = new LinkedHashMap <> ( ) ; this . attributeImpls = new LinkedHashMap <> ( ) ; this . currentState = new State [ 1 ] ; this . factory = Objects . requireNonNull ( factory , " AttributeFactory ▁ must ▁ not ▁ be ▁ null " ) ; }
public Matcher reset ( CharSequence input ) { return reset ( input , 0 , input . length ( ) ) ; }
public GetConfigurationProfileResult getConfigurationProfile ( GetConfigurationProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeGetConfigurationProfile ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex ) { return new NumberEval ( srcColumnIndex + 1 ) ; }
public static double [ ] grow ( double [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Double . BYTES ) ) ; } else return array ; }
public DescribeVpcPeeringConnectionsResult describeVpcPeeringConnections ( DescribeVpcPeeringConnectionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcPeeringConnections ( request ) ; }
public FloatBuffer put ( float c ) { throw new ReadOnlyBufferException ( ) ; }
public int sumTokenSizes ( int fromIx , int toIx ) { int result = 0 ; for ( int i = fromIx ; i < toIx ; i ++ ) { result += _ptgs [ i ] . getSize ( ) ; } return result ; }
public DirectBytesStartArray ( int initSize , Counter counter ) { this . bytesUsed = counter ; this . initSize = initSize ; }
public void clear ( ) { for ( T [ ] block : directory ) { if ( block != null ) Arrays . fill ( block , null ) ; } size = 0 ; tailDirIdx = 0 ; tailBlkIdx = 0 ; tailBlock = directory [ 0 ] ; }
public UploadMultipartPartResult uploadMultipartPart ( UploadMultipartPartRequest request ) { request = beforeClientExecution ( request ) ; return executeUploadMultipartPart ( request ) ; }
public HCenterRecord ( RecordInputStream in ) { field_1_hcenter = in . readShort ( ) ; }
public CreateDBClusterEndpointResult createDBClusterEndpoint ( CreateDBClusterEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBClusterEndpoint ( request ) ; }
public boolean hasNext ( ) { return iterator . nextIndex ( ) < end ; }
public CredentialItem ( String promptText , boolean maskValue ) { this . promptText = promptText ; this . valueSecure = maskValue ; }
public DescribeCustomAvailabilityZonesResult describeCustomAvailabilityZones ( DescribeCustomAvailabilityZonesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCustomAvailabilityZones ( request ) ; }
public DescribeClusterParameterGroupsResult describeClusterParameterGroups ( ) { return describeClusterParameterGroups ( new DescribeClusterParameterGroupsRequest ( ) ) ; }
public Item ( char p , char c ) { parent = p ; child = c ; }
public void reset ( int [ ] docs , int [ ] freqs ) { this . docs = docs ; this . freqs = freqs ; if ( freqs != null && tmpFreqs == null ) { tmpFreqs = new int [ tmpDocs . length ] ; } }
public ChangeMessageVisibilityResult changeMessageVisibility ( String queueUrl , String receiptHandle , Integer visibilityTimeout ) { return changeMessageVisibility ( new ChangeMessageVisibilityRequest ( ) . withQueueUrl ( queueUrl ) . withReceiptHandle ( receiptHandle ) . withVisibilityTimeout ( visibilityTimeout ) ) ; }
public boolean contains ( Object o ) { return this . processors . contains ( o ) ; }
public int getReturnState ( int index ) { return returnState ; }
public ModifyVolumeAttributeResult modifyVolumeAttribute ( ModifyVolumeAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVolumeAttribute ( request ) ; }
public DeleteVolumeResult deleteVolume ( DeleteVolumeRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVolume ( request ) ; }
public ByteBuffer putLong ( int index , long value ) { checkIndex ( index , SizeOf . LONG ) ; Memory . pokeLong ( backingArray , offset + index , value , order ) ; return this ; }
public boolean hasMetaDataChanges ( ) { return changeType != ChangeType . MODIFY || newMode != oldMode ; }
public void newField ( FieldInfo fieldInfo ) { count = interval ; }
public TokenStream create ( TokenStream input ) { return new JapaneseReadingFormFilter ( input , useRomaji ) ; }
public static CellRangeAddress valueOf ( String ref ) { int sep = ref . indexOf ( " : " ) ; CellReference a ; CellReference b ; if ( sep == - 1 ) { a = new CellReference ( ref ) ; b = a ; } else { a = new CellReference ( ref . substring ( 0 , sep ) ) ; b = new CellReference ( ref . substring ( sep + 1 ) ) ; } return new CellRangeAddress ( a . getRow ( ) , b . getRow ( ) , a . getCol ( ) , b . getCol ( ) ) ; }
public ModifySelfservicePermissionsResult modifySelfservicePermissions ( ModifySelfservicePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeModifySelfservicePermissions ( request ) ; }
public int getTokenType ( String tokenName ) { Integer ttype = getTokenTypeMap ( ) . get ( tokenName ) ; if ( ttype != null ) return ttype ; return Token . INVALID_TYPE ; }
public int compareTo ( LongBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; long thisLong , otherLong ; while ( compareRemaining > 0 ) { thisLong = get ( thisPos ) ; otherLong = otherBuffer . get ( otherPos ) ; if ( thisLong != otherLong ) { return thisLong < otherLong ? - 1 : 1 ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; }
public ApproveSkillResult approveSkill ( ApproveSkillRequest request ) { request = beforeClientExecution ( request ) ; return executeApproveSkill ( request ) ; }
public void writeContinueIfRequired ( int requiredContinuousSize ) { if ( _ulrOutput . getAvailableSpace ( ) < requiredContinuousSize ) { writeContinue ( ) ; } }
public GetApiKeysResult getApiKeys ( GetApiKeysRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApiKeys ( request ) ; }
public Iterator < Entry < K , V >> iterator ( ) { return newEntryIterator ( ) ; }
public int compareTo ( RowColKey o ) { int cmp = _rowIndex - o . _rowIndex ; if ( cmp != 0 ) { return cmp ; } return _columnIndex - o . _columnIndex ; }
public ATNConfig ( ATNConfig c , ATNState state , PredictionContext context , SemanticContext semanticContext ) { this . state = state ; this . alt = c . alt ; this . context = context ; this . semanticContext = semanticContext ; this . reachesIntoOuterContext = c . reachesIntoOuterContext ; }
public void updateNamesAfterCellShift ( FormulaShifter shifter ) { for ( int i = 0 ; i < getNumNames ( ) ; ++ i ) { NameRecord nr = getNameRecord ( i ) ; Ptg [ ] ptgs = nr . getNameDefinition ( ) ; if ( shifter . adjustFormula ( ptgs , nr . getSheetNumber ( ) ) ) { nr . setNameDefinition ( ptgs ) ; } } }
public ListReviewPolicyResultsForHITResult listReviewPolicyResultsForHIT ( ListReviewPolicyResultsForHITRequest request ) { request = beforeClientExecution ( request ) ; return executeListReviewPolicyResultsForHIT ( request ) ; }
public GetExportResult getExport ( GetExportRequest request ) { request = beforeClientExecution ( request ) ; return executeGetExport ( request ) ; }
public void setHyperbolicTfFactors ( float min , float max , double base , float xoffset ) { tf_hyper_min = min ; tf_hyper_max = max ; tf_hyper_base = base ; tf_hyper_xoffset = xoffset ; }
public CharBuffer slice ( ) { return new ReadWriteCharArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public LexerNoViableAltException ( Lexer lexer , CharStream input , int startIndex , ATNConfigSet deadEndConfigs ) { super ( lexer , input , null ) ; this . startIndex = startIndex ; this . deadEndConfigs = deadEndConfigs ; }
public CreateCompilationJobResult createCompilationJob ( CreateCompilationJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCompilationJob ( request ) ; }
public int getPosition ( ) { return position ; }
public boolean canEncode ( CharSequence sequence ) { CharBuffer cb ; if ( sequence instanceof CharBuffer ) { cb = ( ( CharBuffer ) sequence ) . duplicate ( ) ; } else { cb = CharBuffer . wrap ( sequence ) ; } return implCanEncode ( cb ) ; }
public synchronized void add ( int index , E e ) { Object [ ] newElements = new Object [ elements . length + 1 ] ; System . arraycopy ( elements , 0 , newElements , 0 , index ) ; newElements [ index ] = e ; System . arraycopy ( elements , index , newElements , index + 1 , elements . length - index ) ; elements = newElements ; }
public StopMonitoringScheduleResult stopMonitoringSchedule ( StopMonitoringScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeStopMonitoringSchedule ( request ) ; }
public int getDbcellAt ( int cellnum ) { return field_5_dbcells . get ( cellnum ) ; }
public final int read ( byte [ ] buffer , int offset , int length ) throws IOException { return in . read ( buffer , offset , length ) ; }
public synchronized String [ ] getChunks ( String [ ] words , String [ ] tags , double [ ] probs ) { String [ ] chunks = chunker . chunk ( words , tags ) ; if ( probs != null ) chunker . probs ( probs ) ; return chunks ; }
public Ref getTarget ( ) { return this ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ DEFAULTROWHEIGHT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . optionflags ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getOptionFlags ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rowheight ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getRowHeight ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / DEFAULTROWHEIGHT ] \ n " ) ; return buffer . toString ( ) ; }
public AlibabaCloudCredentials getCredentials ( ) { return this . credentials ; }
public SeekStatus seekCeil ( BytesRef term ) { throw new UnsupportedOperationException ( ) ; }
public NavigableSet < K > navigableKeySet ( ) { BoundedKeySet result = keySet ; return result != null ? result : ( keySet = new BoundedKeySet ( ) ) ; }
public ListEventsRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListEvents " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ LbsDropData ] \ n " ) ; sb . append ( " ▁ ▁ . □ wStyle : ▁ ▁ " ) . append ( _wStyle ) . append ( ' \ n ' ) ; sb . append ( " ▁ ▁ . □ cLine : ▁ ▁ " ) . append ( _cLine ) . append ( ' \ n ' ) ; sb . append ( " ▁ ▁ . □ dxMin : ▁ ▁ " ) . append ( _dxMin ) . append ( ' \ n ' ) ; sb . append ( " ▁ ▁ . □ str : ▁ ▁ " ) . append ( _str ) . append ( ' \ n ' ) ; if ( _unused != null ) { sb . append ( " ▁ ▁ . □ unused : ▁ ▁ " ) . append ( _unused ) . append ( ' \ n ' ) ; } sb . append ( " [ / LbsDropData ] \ n " ) ; return sb . toString ( ) ; }
public String toString ( ) { return " PackWriter . State [ " + phase + " , ▁ memory = " + bytesUsed + " ] " ; }
public RemoteRefUpdate getRemoteUpdate ( String refName ) { return remoteUpdates . get ( refName ) ; }
@ Override public Iterator < E > iterator ( ) { return listIterator ( 0 ) ; }
public TerminateInstancesRequest ( java . util . List < String > instanceIds ) { setInstanceIds ( instanceIds ) ; }
public CreateDataRepositoryTaskResult createDataRepositoryTask ( CreateDataRepositoryTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDataRepositoryTask ( request ) ; }
public void undeprecateActivityType ( UndeprecateActivityTypeRequest request ) { request = beforeClientExecution ( request ) ; executeUndeprecateActivityType ( request ) ; }
public EndRecord clone ( ) { return copy ( ) ; }
public ListLabelingJobsResult listLabelingJobs ( ListLabelingJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListLabelingJobs ( request ) ; }
public void setTag ( String shortName ) { this . tag = shortName ; }
public String getNameText ( NamePtg namePtg ) { return _iBook . getNameRecord ( namePtg . getIndex ( ) ) . getNameText ( ) ; }
public Builder ( ) { slop = 0 ; terms = new ArrayList <> ( ) ; positions = new ArrayList <> ( ) ; }
public SpanPositionRangeQuery ( SpanQuery match , int start , int end ) { super ( match ) ; this . start = start ; this . end = end ; }
public CreateDBProxyResult createDBProxy ( CreateDBProxyRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBProxy ( request ) ; }
public boolean equals ( Object o ) { return o instanceof LovinsStemmer ; }
public ReplicationGroup modifyReplicationGroupShardConfiguration ( ModifyReplicationGroupShardConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyReplicationGroupShardConfiguration ( request ) ; }
public DeleteFacesResult deleteFaces ( DeleteFacesRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFaces ( request ) ; }
public SSTSerializer ( IntMapper < UnicodeString > strings , int numStrings , int numUniqueStrings ) { this . strings = strings ; _numStrings = numStrings ; _numUniqueStrings = numUniqueStrings ; int infoRecs = ExtSSTRecord . getNumberOfInfoRecsForStrings ( strings . size ( ) ) ; this . bucketAbsoluteOffsets = new int [ infoRecs ] ; this . bucketRelativeOffsets = new int [ infoRecs ] ; }
public URISyntaxException ( String input , String reason , int index ) { super ( reason ) ; if ( input == null || reason == null ) { throw new NullPointerException ( ) ; } if ( index < - 1 ) { throw new IllegalArgumentException ( ) ; } this . input = input ; this . index = index ; }
public String toString ( ) { return " AssociationFacetField ( dim = " + dim + " ▁ path = " + Arrays . toString ( path ) + " ▁ bytes = " + assoc + " ) " ; }
public boolean requiresCommitBody ( ) { return false ; }
public static AttrPtg getSumSingle ( ) { return new AttrPtg ( optiSum . set ( 0 ) , 0 , null , - 1 ) ; }
public GetModelsResult getModels ( GetModelsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetModels ( request ) ; }
public Storage getStorage ( ) { return Storage . LOOSE ; }
public ForwardBytesReader ( byte [ ] bytes ) { this . bytes = bytes ; }
public long ramBytesUsed ( ) { return fst == null ? 0 : fst . ramBytesUsed ( ) ; }
public ShortBuffer asReadOnlyBuffer ( ) { return ReadOnlyShortArrayBuffer . copy ( this , mark ) ; }
public ListFiltersResult listFilters ( ListFiltersRequest request ) { request = beforeClientExecution ( request ) ; return executeListFilters ( request ) ; }
public HSSFRichTextString ( String string ) { if ( string == null ) { _string = new UnicodeString ( " " ) ; } else { _string = new UnicodeString ( string ) ; } }
public void readBytes ( byte [ ] b , int offset , int len ) { System . arraycopy ( bytes , pos , b , offset , len ) ; pos += len ; }
public UpdateDomainNameserversResult updateDomainNameservers ( UpdateDomainNameserversRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDomainNameservers ( request ) ; }
public ListWorkersWithQualificationTypeResult listWorkersWithQualificationType ( ListWorkersWithQualificationTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeListWorkersWithQualificationType ( request ) ; }
public ResetCacheParameterGroupRequest ( String cacheParameterGroupName , java . util . List < ParameterNameValue > parameterNameValues ) { setCacheParameterGroupName ( cacheParameterGroupName ) ; setParameterNameValues ( parameterNameValues ) ; }
public EscherPropertyMetaData ( String description ) { this . description = description ; }
public UserInputQueryBuilder ( String defaultField , Analyzer analyzer ) { this . analyzer = analyzer ; this . defaultField = defaultField ; }
public final CharsetDecoder replaceWith ( String replacement ) { if ( replacement == null ) { throw new IllegalArgumentException ( " replacement ▁ == ▁ null " ) ; } if ( replacement . isEmpty ( ) ) { throw new IllegalArgumentException ( " replacement . isEmpty ( ) " ) ; } if ( replacement . length ( ) > maxCharsPerByte ( ) ) { throw new IllegalArgumentException ( " replacement ▁ length ▁ > ▁ maxCharsPerByte : ▁ " + replacement . length ( ) + " ▁ > ▁ " + maxCharsPerByte ( ) ) ; } replacementChars = replacement ; implReplaceWith ( replacement ) ; return this ; }
public void reset ( ) throws IOException { throw new IOException ( ) ; }
public UpdateFileSystemResult updateFileSystem ( UpdateFileSystemRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFileSystem ( request ) ; }
public int readUByte ( ) { return _in . readUByte ( ) ; }
public String toString ( ) { return " [ WSBOOL ] \ n " + " ▁ ▁ ▁ ▁ . wsbool1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + Integer . toHexString ( getWSBool1 ( ) ) + " \ n " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . autobreaks ▁ = ▁ " + getAutobreaks ( ) + " \ n " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . dialog ▁ ▁ ▁ ▁ ▁ = ▁ " + getDialog ( ) + " \ n " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . rowsumsbelw = ▁ " + getRowSumsBelow ( ) + " \ n " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . rowsumsrigt = ▁ " + getRowSumsRight ( ) + " \ n " + " ▁ ▁ ▁ ▁ . wsbool2 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + Integer . toHexString ( getWSBool2 ( ) ) + " \ n " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . fittopage ▁ ▁ = ▁ " + getFitToPage ( ) + " \ n " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . displayguts = ▁ " + getDisplayGuts ( ) + " \ n " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . alternateex = ▁ " + getAlternateExpression ( ) + " \ n " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . alternatefo = ▁ " + getAlternateFormula ( ) + " \ n " + " [ / WSBOOL ] \ n " ; }
public PutGatewayResponseResult putGatewayResponse ( PutGatewayResponseRequest request ) { request = beforeClientExecution ( request ) ; return executePutGatewayResponse ( request ) ; }
public Term [ ] getStopWords ( ) { List < Term > allStopWords = new ArrayList <> ( ) ; for ( Map . Entry < String , Set < String >> entry : stopWordsPerField . entrySet ( ) ) { String field = entry . getKey ( ) ; Set < String > stopWords = entry . getValue ( ) ; for ( String text : stopWords ) { allStopWords . add ( new Term ( field , text ) ) ; } } return allStopWords . toArray ( new Term [ allStopWords . size ( ) ] ) ; }
public boolean isUpdate ( ) { return update ; }
public static InternalSheet createSheet ( RecordStream rs ) { return new InternalSheet ( rs ) ; }
public final IntBuffer get ( int [ ] dst , int dstOffset , int intCount ) { if ( intCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } System . arraycopy ( backingArray , offset + position , dst , dstOffset , intCount ) ; position += intCount ; return this ; }
public DisassociateVpcCidrBlockResult disassociateVpcCidrBlock ( DisassociateVpcCidrBlockRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateVpcCidrBlock ( request ) ; }
public void add ( TaskStats stat2 ) { numRuns += stat2. getNumRuns ( ) ; elapsed += stat2. getElapsed ( ) ; maxTotMem += stat2. getMaxTotMem ( ) ; maxUsedMem += stat2. getMaxUsedMem ( ) ; count += stat2. getCount ( ) ; if ( round != stat2. round ) { round = - 1 ; } if ( countsByTime != null && stat2. countsByTime != null ) { if ( countsByTimeStepMSec != stat2. countsByTimeStepMSec ) { throw new IllegalStateException ( " different ▁ by - time ▁ msec ▁ step " ) ; } if ( countsByTime . length != stat2. countsByTime . length ) { throw new IllegalStateException ( " different ▁ by - time ▁ msec ▁ count " ) ; } for ( int i = 0 ; i < stat2. countsByTime . length ; i ++ ) { countsByTime [ i ] += stat2. countsByTime [ i ] ; } } }
public StartStreamProcessorResult startStreamProcessor ( StartStreamProcessorRequest request ) { request = beforeClientExecution ( request ) ; return executeStartStreamProcessor ( request ) ; }
public void print ( char c ) { print ( String . valueOf ( c ) ) ; }
public StepConfig ( String name , HadoopJarStepConfig hadoopJarStep ) { setName ( name ) ; setHadoopJarStep ( hadoopJarStep ) ; }
public GetIdentityPoliciesResult getIdentityPolicies ( GetIdentityPoliciesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIdentityPolicies ( request ) ; }
public ListAccountsResult listAccounts ( ListAccountsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAccounts ( request ) ; }
public int getCompressionLevel ( ) { return compressionLevel ; }
public synchronized StringBuffer append ( CharSequence s ) { if ( s == null ) { appendNull ( ) ; } else { append0 ( s , 0 , s . length ( ) ) ; } return this ; }
@ Override public String toString ( ) { return key + " = " + value ; }
public long skip ( long byteCount ) throws IOException { if ( byteCount < 0 ) { throw new IllegalArgumentException ( " byteCount ▁ < ▁ 0 : ▁ " + byteCount ) ; } synchronized ( lock ) { checkNotClosed ( ) ; if ( byteCount < 1 ) { return 0 ; } if ( end - pos >= byteCount ) { pos += byteCount ; return byteCount ; } long read = end - pos ; pos = end ; while ( read < byteCount ) { if ( fillBuf ( ) == - 1 ) { return read ; } if ( end - pos >= byteCount - read ) { pos += byteCount - read ; return byteCount ; } read += ( end - pos ) ; pos = end ; } return byteCount ; } }
public void updateFormulasAfterRowShift ( FormulaShifter formulaShifter , int currentExternSheetIndex ) { _valuesAgg . updateFormulasAfterRowShift ( formulaShifter , currentExternSheetIndex ) ; }
public void close ( ) { synchronized ( lock ) { if ( isOpen ( ) ) { buf = null ; } } }
public void seek ( long pos ) { this . pos = ( int ) ( pos - pointer ) ; }
public String toFormulaString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; boolean needsExclamation = false ; if ( externalWorkbookNumber >= 0 ) { sb . append ( ' [ ' ) ; sb . append ( externalWorkbookNumber ) ; sb . append ( ' ] ' ) ; needsExclamation = true ; } if ( sheetName != null ) { SheetNameFormatter . appendFormat ( sb , sheetName ) ; needsExclamation = true ; } if ( needsExclamation ) { sb . append ( ' ! ' ) ; } sb . append ( nameName ) ; return sb . toString ( ) ; }
public boolean isFinished ( ) { return mState == STATE_IDLE ; }
public static Transport open ( Repository local , URIish uri , String remoteName ) throws NotSupportedException , TransportException { for ( WeakReference < TransportProtocol > ref : protocols ) { TransportProtocol proto = ref . get ( ) ; if ( proto == null ) { protocols . remove ( ref ) ; continue ; } if ( proto . canHandle ( uri , local , remoteName ) ) { Transport tn = proto . open ( uri , local , remoteName ) ; tn . prePush = Hooks . prePush ( local , tn . hookOutRedirect ) ; tn . prePush . setRemoteLocation ( uri . toString ( ) ) ; tn . prePush . setRemoteName ( remoteName ) ; return tn ; } } throw new NotSupportedException ( MessageFormat . format ( JGitText . get ( ) . URINotSupported , uri ) ) ; }
public void setColor ( Color color ) { foreground = color ; }
public DeleteAliasResult deleteAlias ( DeleteAliasRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAlias ( request ) ; }
public SeekStatus seekCeil ( BytesRef text ) { termUpto = binarySearch ( text , br , 0 , info . terms . size ( ) - 1 , info . terms , info . sortedTerms ) ; if ( termUpto < 0 ) { termUpto = - termUpto - 1 ; if ( termUpto >= info . terms . size ( ) ) { return SeekStatus . END ; } else { info . terms . get ( info . sortedTerms [ termUpto ] , br ) ; return SeekStatus . NOT_FOUND ; } } else { return SeekStatus . FOUND ; } }
public CreateApplicationVersionRequest ( String applicationName , String versionLabel ) { setApplicationName ( applicationName ) ; setVersionLabel ( versionLabel ) ; }
public String toString ( ) { return ruleName + " : " + bypassTokenType ; }
public int indexOf ( Object object ) { Object [ ] snapshot = elements ; return indexOf ( object , snapshot , 0 , snapshot . length ) ; }
public int compareTo ( ShortBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; short thisByte , otherByte ; while ( compareRemaining > 0 ) { thisByte = get ( thisPos ) ; otherByte = otherBuffer . get ( otherPos ) ; if ( thisByte != otherByte ) { return thisByte < otherByte ? - 1 : 1 ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; }
public DescribeSecurityConfigurationResult describeSecurityConfiguration ( DescribeSecurityConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSecurityConfiguration ( request ) ; }
public void add ( int location , E object ) { insertElementAt ( object , location ) ; }
public GetDownloadUrlForLayerResult getDownloadUrlForLayer ( GetDownloadUrlForLayerRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDownloadUrlForLayer ( request ) ; }
public StringWriter append ( CharSequence csq ) { if ( csq == null ) { csq = " null " ; } write ( csq . toString ( ) ) ; return this ; }
public RevWalk getRevWalk ( ) { return walker ; }
@ Override public int lastIndexOf ( Object object ) { Slice slice = this . slice ; Object [ ] snapshot = elements ; slice . checkConcurrentModification ( snapshot ) ; int result = CopyOnWriteArrayList . lastIndexOf ( object , snapshot , slice . from , slice . to ) ; return ( result != - 1 ) ? ( result - slice . from ) : - 1 ; }
public IntBuffer put ( int index , int c ) { checkIndex ( index ) ; backingArray [ offset + index ] = c ; return this ; }
public HSSFTextbox ( HSSFShape parent , HSSFAnchor anchor ) { super ( parent , anchor ) ; setHorizontalAlignment ( HORIZONTAL_ALIGNMENT_LEFT ) ; setVerticalAlignment ( VERTICAL_ALIGNMENT_TOP ) ; setString ( new HSSFRichTextString ( " " ) ) ; }
public GetRegionRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRegion " , " cr " ) ; setUriPattern ( " / regions " ) ; setMethod ( MethodType . GET ) ; }
public ListObjectChildrenResult listObjectChildren ( ListObjectChildrenRequest request ) { request = beforeClientExecution ( request ) ; return executeListObjectChildren ( request ) ; }
public GetIdResult getId ( GetIdRequest request ) { request = beforeClientExecution ( request ) ; return executeGetId ( request ) ; }
public String getPassphrase ( ) { return passphrase ; }
public Map < String , Ref > getAllRefs ( ) { try { return getRefDatabase ( ) . getRefs ( RefDatabase . ALL ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } }
public boolean hasMoreElements ( ) { return hasNext ( ) ; }
public int numDataNodes ( ) { return numDataNodes ( rootNode ) ; }
public HadoopJarStepConfig toHadoopJarStepConfig ( ) { List < String > args = new ArrayList < String > ( ) ; if ( reducer == null ) { hadoopConfig . put ( " mapred . reduce . tasks " , " 0 " ) ; } for ( Map . Entry < String , String > entry : hadoopConfig . entrySet ( ) ) { args . add ( " - D " ) ; args . add ( entry . getKey ( ) + " = " + entry . getValue ( ) ) ; } for ( String input : inputs ) { args . add ( " - input " ) ; args . add ( input ) ; } if ( output != null ) { args . add ( " - output " ) ; args . add ( output ) ; } if ( mapper != null ) { args . add ( " - mapper " ) ; args . add ( mapper ) ; } if ( reducer != null ) { args . add ( " - reducer " ) ; args . add ( reducer ) ; } return new HadoopJarStepConfig ( ) . withJar ( " / home / hadoop / contrib / streaming / hadoop - streaming . jar " ) . withArgs ( args ) ; }
public GetRelationalDatabaseEventsResult getRelationalDatabaseEvents ( GetRelationalDatabaseEventsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRelationalDatabaseEvents ( request ) ; }
public void drawLine ( int x1 , int y1 , int x2 , int y2 ) { drawLine ( x1 , y1 , x2 , y2 , 0 ) ; }
public UpdateUserSecurityProfilesResult updateUserSecurityProfiles ( UpdateUserSecurityProfilesRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateUserSecurityProfiles ( request ) ; }
public String toString ( ) { return " Action : ▁ " + this . action ; }
public CreateVolumeRequest ( Integer size , String availabilityZone ) { setSize ( size ) ; setAvailabilityZone ( availabilityZone ) ; }
public final void setPrecedenceStartState ( int precedence , DFAState startState ) { if ( ! isPrecedenceDfa ( ) ) { throw new IllegalStateException ( " Only ▁ precedence ▁ DFAs ▁ may ▁ contain ▁ a ▁ precedence ▁ start ▁ state . " ) ; } if ( precedence < 0 ) { return ; } synchronized ( s0 ) { if ( precedence >= s0. edges . length ) { s0. edges = Arrays . copyOf ( s0. edges , precedence + 1 ) ; } s0. edges [ precedence ] = startState ; } }
public EditPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " EditPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public Builder ( ) { PositiveIntOutputs outputs = PositiveIntOutputs . getSingleton ( ) ; fstCompiler = new FSTCompiler <> ( FST . INPUT_TYPE . BYTE1 , outputs ) ; scratchInts = new IntsRefBuilder ( ) ; }
public DeleteFlowDefinitionResult deleteFlowDefinition ( DeleteFlowDefinitionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteFlowDefinition ( request ) ; }
public void setLastFailedRefreshTime ( ) { lastFailedRefreshTime = System . currentTimeMillis ( ) ; }
public ModifyDBInstanceRequest ( String dBInstanceIdentifier ) { setDBInstanceIdentifier ( dBInstanceIdentifier ) ; }
public GetTemplateSummaryResult getTemplateSummary ( GetTemplateSummaryRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTemplateSummary ( request ) ; }
public Snapshot revokeSnapshotAccess ( RevokeSnapshotAccessRequest request ) { request = beforeClientExecution ( request ) ; return executeRevokeSnapshotAccess ( request ) ; }
public void serialize ( final LittleEndianOutput out ) { final int field_4_name_length = field_6_name_text . length ( ) ; final int field_5_comment_length = field_7_comment_text . length ( ) ; out . writeShort ( field_1_record_type ) ; out . writeShort ( field_2_frt_cell_ref_flag ) ; out . writeLong ( field_3_reserved ) ; out . writeShort ( field_4_name_length ) ; out . writeShort ( field_5_comment_length ) ; boolean isNameMultiByte = StringUtil . hasMultibyte ( field_6_name_text ) ; out . writeByte ( isNameMultiByte ? 1 : 0 ) ; if ( isNameMultiByte ) { StringUtil . putUnicodeLE ( field_6_name_text , out ) ; } else { StringUtil . putCompressedUnicode ( field_6_name_text , out ) ; } boolean isCommentMultiByte = StringUtil . hasMultibyte ( field_7_comment_text ) ; out . writeByte ( isCommentMultiByte ? 1 : 0 ) ; if ( isCommentMultiByte ) { StringUtil . putUnicodeLE ( field_7_comment_text , out ) ; } else { StringUtil . putCompressedUnicode ( field_7_comment_text , out ) ; } }
public StartProjectVersionResult startProjectVersion ( StartProjectVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeStartProjectVersion ( request ) ; }
public MoPenDeleteGroupMemberRequest ( ) { super ( " MoPen " , " 2018 - 02 - 11 " , " MoPenDeleteGroupMember " , " mopen " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public synchronized int getMax ( ) { return mMax ; }
public DiffCommand setSourcePrefix ( String sourcePrefix ) { this . sourcePrefix = sourcePrefix ; return this ; }
public CreateFlowLogsResult createFlowLogs ( CreateFlowLogsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFlowLogs ( request ) ; }
public void writeString ( String text , int numberOfRichTextRuns , int extendedDataSize ) { boolean is16bitEncoded = StringUtil . hasMultibyte ( text ) ; int keepTogetherSize = 2 + 1 + 1 ; int optionFlags = 0x00 ; if ( is16bitEncoded ) { optionFlags |= 0x01 ; keepTogetherSize += 1 ; } if ( numberOfRichTextRuns > 0 ) { optionFlags |= 0x08 ; keepTogetherSize += 2 ; } if ( extendedDataSize > 0 ) { optionFlags |= 0x04 ; keepTogetherSize += 4 ; } writeContinueIfRequired ( keepTogetherSize ) ; writeShort ( text . length ( ) ) ; writeByte ( optionFlags ) ; if ( numberOfRichTextRuns > 0 ) { writeShort ( numberOfRichTextRuns ) ; } if ( extendedDataSize > 0 ) { writeInt ( extendedDataSize ) ; } writeCharacterData ( text , is16bitEncoded ) ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buf = new StringBuilder ( ) ; if ( isExternalFunction ( ) ) { buf . append ( operands [ 0 ] ) ; appendArgs ( buf , 1 , operands ) ; } else { buf . append ( getName ( ) ) ; appendArgs ( buf , 0 , operands ) ; } return buf . toString ( ) ; }
public DetectStackDriftResult detectStackDrift ( DetectStackDriftRequest request ) { request = beforeClientExecution ( request ) ; return executeDetectStackDrift ( request ) ; }
public ObjectId idFor ( TreeFormatter formatter ) { return delegate ( ) . idFor ( formatter ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escaper ) { if ( isDefaultField ( this . field ) ) { return getTermEscaped ( escaper ) ; } else { return this . field + " : " + getTermEscaped ( escaper ) ; } }
public RenderUiTemplateResult renderUiTemplate ( RenderUiTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeRenderUiTemplate ( request ) ; }
public final LongBuffer asLongBuffer ( ) { return LongToByteBufferAdapter . asLongBuffer ( this ) ; }
public DescribeLimitsResult describeLimits ( DescribeLimitsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLimits ( request ) ; }
public DescribeAssessmentTargetsResult describeAssessmentTargets ( DescribeAssessmentTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAssessmentTargets ( request ) ; }
public DeleteClientVpnRouteResult deleteClientVpnRoute ( DeleteClientVpnRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteClientVpnRoute ( request ) ; }
public RebaseCommand setUpstream ( AnyObjectId upstream ) { try { this . upstreamCommit = walk . parseCommit ( upstream ) ; this . upstreamCommitName = upstream . name ( ) ; } catch ( IOException e ) { throw new JGitInternalException ( MessageFormat . format ( JGitText . get ( ) . couldNotReadObjectWhileParsingCommit , upstream . name ( ) ) , e ) ; } return this ; }
public Collection < ChildScorable > getChildren ( ) { return Collections . singleton ( new ChildScorable ( in , " CACHED " ) ) ; }
public synchronized String substring ( int start ) { return super . substring ( start ) ; }
public static double sum ( double [ ] values ) { double sum = 0 ; for ( double value : values ) { sum += value ; } return sum ; }
public static BlankRecord [ ] convertBlankRecords ( MulBlankRecord mbk ) { BlankRecord [ ] mulRecs = new BlankRecord [ mbk . getNumColumns ( ) ] ; for ( int k = 0 ; k < mbk . getNumColumns ( ) ; k ++ ) { BlankRecord br = new BlankRecord ( ) ; br . setColumn ( ( short ) ( k + mbk . getFirstColumn ( ) ) ) ; br . setRow ( mbk . getRow ( ) ) ; br . setXFIndex ( mbk . getXFAt ( k ) ) ; mulRecs [ k ] = br ; } return mulRecs ; }
public DeregisterDBProxyTargetsResult deregisterDBProxyTargets ( DeregisterDBProxyTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterDBProxyTargets ( request ) ; }
public SummaryInformation ( final PropertySet ps ) throws UnexpectedPropertySetTypeException { super ( ps ) ; if ( ! isSummaryInformation ( ) ) { throw new UnexpectedPropertySetTypeException ( " Not ▁ a ▁ " + getClass ( ) . getName ( ) ) ; } }
public void setCredentialsProvider ( AlibabaCloudCredentialsProvider credentialsProvider ) { if ( credential != null ) { return ; } credential = new CredentialsBackupCompatibilityAdaptor ( credentialsProvider ) ; }
public CharArrayReader ( char [ ] buf , int offset , int length ) { if ( offset < 0 || offset > buf . length || length < 0 || offset + length < 0 ) { throw new IllegalArgumentException ( ) ; } this . buf = buf ; this . pos = offset ; this . markedPos = offset ; int bufferLength = buf . length ; this . count = offset + length < bufferLength ? length : bufferLength ; }
public Object getProperty ( final long id ) { wasNull = ! properties . containsKey ( id ) ; return ( wasNull ) ? null : properties . get ( id ) . getValue ( ) ; }
public BufferedOutputStream ( OutputStream out , int size ) { super ( out ) ; if ( size <= 0 ) { throw new IllegalArgumentException ( " size ▁ <= ▁ 0 " ) ; } buf = new byte [ size ] ; }
public AuthorizeDBSecurityGroupIngressRequest ( String dBSecurityGroupName ) { setDBSecurityGroupName ( dBSecurityGroupName ) ; }
public ArrayDataSource ( T [ ] elements ) { this . elements = elements . clone ( ) ; }
public CreateDeploymentResult createDeployment ( CreateDeploymentRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDeployment ( request ) ; }
public final int getInt ( ) { int newPosition = position + SizeOf . INT ; if ( newPosition > limit ) { throw new BufferUnderflowException ( ) ; } int result = Memory . peekInt ( backingArray , offset + position , order ) ; position = newPosition ; return result ; }
public DeleteTransitGatewayRouteResult deleteTransitGatewayRoute ( DeleteTransitGatewayRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTransitGatewayRoute ( request ) ; }
public ListMultipartUploadsRequest ( String bucketName ) { this . bucketName = bucketName ; }
public float score ( float freq , long norm ) { return ( float ) SimilarityBase . this . score ( stats , freq , getLengthValue ( norm ) ) ; }
public char next ( ) { if ( offset >= ( end - 1 ) ) { offset = end ; return DONE ; } return string . charAt ( ++ offset ) ; }
public CherryPickResult ( RevCommit newHead , List < Ref > cherryPickedRefs ) { this . status = CherryPickStatus . OK ; this . newHead = newHead ; this . cherryPickedRefs = cherryPickedRefs ; this . failingPaths = null ; }
public static Token newToken ( int ofKind ) { return newToken ( ofKind , null ) ; }
public HSSFClientAnchor getPreferredSize ( double scale ) { return getPreferredSize ( scale , scale ) ; }
public UpdateInstanceRequest ( ) { super ( " Ots " , " 2016 - 06 - 20 " , " UpdateInstance " , " ots " ) ; setMethod ( MethodType . POST ) ; }
public ByteBuffer putInt ( int index , int value ) { checkIndex ( index , SizeOf . INT ) ; Memory . pokeInt ( backingArray , offset + index , value , order ) ; return this ; }
public byte [ ] serialize ( ) { int size = getDataSize ( ) + 4 ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( size ) ; serialize ( new LittleEndianOutputStream ( baos ) ) ; if ( baos . size ( ) != size ) { throw new RuntimeException ( " write ▁ size ▁ mismatch " ) ; } return baos . toByteArray ( ) ; }
public GetFieldLevelEncryptionProfileResult getFieldLevelEncryptionProfile ( GetFieldLevelEncryptionProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFieldLevelEncryptionProfile ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_number_of_sheets ) ; if ( isExternalReferences ( ) ) { StringUtil . writeUnicodeString ( out , field_2_encoded_url ) ; for ( String field_3_sheet_name : field_3_sheet_names ) { StringUtil . writeUnicodeString ( out , field_3_sheet_name ) ; } } else { int field2val = _isAddInFunctions ? TAG_ADD_IN_FUNCTIONS : TAG_INTERNAL_REFERENCES ; out . writeShort ( field2val ) ; } }
public BitsSlice ( Bits parent , ReaderSlice slice ) { this . parent = parent ; this . start = slice . start ; this . length = slice . length ; assert length >= 0 : " length = " + length ; }
public void removeName ( Name name ) { int index = getNameIndex ( ( HSSFName ) name ) ; removeName ( index ) ; }
public ListConfigurationRevisionsResult listConfigurationRevisions ( ListConfigurationRevisionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListConfigurationRevisions ( request ) ; }
public ObjectStream openStream ( ) { return new ObjectStream . SmallStream ( this ) ; }
public boolean delete ( ) { return directory . delete ( ) ; }
public void clear ( ) { _limit = 0 ; }
public void setMaxObjectSizeLimit ( long limit ) { maxObjectSizeLimit = limit ; }
public DescribeEventSubscriptionsResult describeEventSubscriptions ( DescribeEventSubscriptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEventSubscriptions ( request ) ; }
public boolean startEvaluate ( FormulaCellCacheEntry cce ) { if ( cce == null ) { throw new IllegalArgumentException ( " cellLoc ▁ must ▁ not ▁ be ▁ null " ) ; } if ( _currentlyEvaluatingCells . contains ( cce ) ) { return false ; } _currentlyEvaluatingCells . add ( cce ) ; _evaluationFrames . add ( new CellEvaluationFrame ( cce ) ) ; return true ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( sid ) ; out . writeShort ( _cbFContinued ) ; if ( _linkPtg == null ) { out . writeShort ( 0 ) ; } else { int formulaSize = _linkPtg . getSize ( ) ; int linkSize = formulaSize + 6 ; if ( _unknownPostFormulaByte != null ) { linkSize ++ ; } out . writeShort ( linkSize ) ; out . writeShort ( formulaSize ) ; out . writeInt ( _unknownPreFormulaInt ) ; _linkPtg . write ( out ) ; if ( _unknownPostFormulaByte != null ) { out . writeByte ( _unknownPostFormulaByte . intValue ( ) ) ; } } out . writeShort ( _cLines ) ; out . writeShort ( _iSel ) ; out . writeShort ( _flags ) ; out . writeShort ( _idEdit ) ; if ( _dropData != null ) { _dropData . serialize ( out ) ; } if ( _rgLines != null ) { for ( String str : _rgLines ) { StringUtil . writeUnicodeString ( out , str ) ; } } if ( _bsels != null ) { for ( boolean val : _bsels ) { out . writeByte ( val ? 1 : 0 ) ; } } }
public void remove ( int el ) { if ( readonly ) throw new IllegalStateException ( " can ' t alter readonly IntervalSet " ) ; int ▁ n ▁ = ▁ intervals . size ( ) ; for ▁ ( int ▁ i ▁ = ▁ 0 ; ▁ i ▁ < ▁ n ; ▁ i ++ ) ▁ { Interval ▁ I ▁ = ▁ intervals . get ( i ) ; int ▁ a ▁ = ▁ I . a ; int ▁ b ▁ = ▁ I . b ; if ▁ ( ▁ el < a ▁ ) ▁ { break ; ▁ } if ▁ ( ▁ el == a ▁ && ▁ el == b ▁ ) ▁ { intervals . remove ( i ) ; break ; } if ▁ ( ▁ el == a ▁ ) ▁ { I . a ++ ; break ; } if ▁ ( ▁ el == b ▁ ) ▁ { I . b -- ; break ; } if ▁ ( ▁ el > a ▁ && ▁ el < b ▁ ) ▁ { ▁ int ▁ oldb ▁ = ▁ I . b ; I . b ▁ = ▁ el - 1 ; ▁ ▁ ▁ ▁ ▁ ▁ add ( el + 1 , ▁ oldb ) ; ▁ } } }
public IntegerList toIntegerList ( ) { IntegerList values = new IntegerList ( size ( ) ) ; int n = intervals . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Interval I = intervals . get ( i ) ; int a = I . a ; int b = I . b ; for ( int v = a ; v <= b ; v ++ ) { values . add ( v ) ; } } return values ; }
@ Override public void clear ( ) { AbstractMultimap . this . clear ( ) ; }
public CharsRef pullNext ( ) { assert upto < count ; lastEndOffset = endOffsets [ upto ] ; lastPosLength = posLengths [ upto ] ; final CharsRefBuilder result = outputs [ upto ++ ] ; posIncr = 0 ; if ( upto == count ) { reset ( ) ; } return result . get ( ) ; }
public FSTTermsWriter ( SegmentWriteState state , PostingsWriterBase postingsWriter ) throws IOException { final String termsFileName = IndexFileNames . segmentFileName ( state . segmentInfo . name , state . segmentSuffix , TERMS_EXTENSION ) ; this . postingsWriter = postingsWriter ; this . fieldInfos = state . fieldInfos ; this . out = state . directory . createOutput ( termsFileName , state . context ) ; this . maxDoc = state . segmentInfo . maxDoc ( ) ; boolean success = false ; try { CodecUtil . writeIndexHeader ( out , TERMS_CODEC_NAME , TERMS_VERSION_CURRENT , state . segmentInfo . getId ( ) , state . segmentSuffix ) ; this . postingsWriter . init ( out , state ) ; success = true ; } finally { if ( ! success ) { IOUtils . closeWhileHandlingException ( out ) ; } } }
public int compareTo ( Cell other ) { return Double . compare ( distanceSortKey , other . distanceSortKey ) ; }
public ListAccountSettingsResult listAccountSettings ( ListAccountSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAccountSettings ( request ) ; }
public boolean find ( ) { matchFound = findNextImpl ( address , input , matchOffsets ) ; if ( matchFound ) { findPos = matchOffsets [ 1 ] ; } return matchFound ; }
public V next ( ) { return super . nextEntry ( ) . value ; }
public DescribeLocalGatewaysResult describeLocalGateways ( DescribeLocalGatewaysRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLocalGateways ( request ) ; }
public ByteArrayDataInput ( byte [ ] bytes , int offset , int len ) { reset ( bytes , offset , len ) ; }
public String toString ( ) { return super . toString ( ) + " : " + revstr ; }
public RegisterCrossAccountAccessRoleResult registerCrossAccountAccessRole ( RegisterCrossAccountAccessRoleRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterCrossAccountAccessRole ( request ) ; }
public void clear ( ) { ConcurrentHashMap . this . clear ( ) ; }
public DescribeFileSystemsResult describeFileSystems ( DescribeFileSystemsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFileSystems ( request ) ; }
public ReverseStringFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public Builder ( ) { this ( true ) ; }
public TokenStream create ( TokenStream input ) { return new IrishLowerCaseFilter ( input ) ; }
public GetQualificationTypeResult getQualificationType ( GetQualificationTypeRequest request ) { request = beforeClientExecution ( request ) ; return executeGetQualificationType ( request ) ; }
public ThreeWayMerger newMerger ( Repository db , boolean inCore ) { return new ResolveMerger ( db , inCore ) ; }
public String getNameText ( int definedNameIndex ) { return _externalNameRecords [ definedNameIndex ] . getText ( ) ; }
public PlotWalk ( Repository repo ) { super ( repo ) ; super . sort ( RevSort . TOPO , true ) ; additionalRefMap = new HashMap <> ( ) ; repository = repo ; }
public SubscribeToDatasetResult subscribeToDataset ( SubscribeToDatasetRequest request ) { request = beforeClientExecution ( request ) ; return executeSubscribeToDataset ( request ) ; }
public StringBuilder append ( char [ ] str , int offset , int len ) { append0 ( str , offset , len ) ; return this ; }
public synchronized int indexOf ( String subString , int start ) { return super . indexOf ( subString , start ) ; }
public List < E > subList ( int from , int to ) { Object [ ] snapshot = elements ; if ( from < 0 || from > to || to > snapshot . length ) { throw new IndexOutOfBoundsException ( " from = " + from + " , ▁ to = " + to + " , ▁ list ▁ size = " + snapshot . length ) ; } return new CowSubList ( snapshot , from , to ) ; }
public Severity getSeverity ( ) { return severity ; }
public DescribeBundleTasksResult describeBundleTasks ( ) { return describeBundleTasks ( new DescribeBundleTasksRequest ( ) ) ; }
public BooleanQuery build ( ) { return new BooleanQuery ( minimumNumberShouldMatch , clauses . toArray ( new BooleanClause [ 0 ] ) ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ HIDEOBJ ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . hideobj ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getHideObj ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / HIDEOBJ ] \ n " ) ; return buffer . toString ( ) ; }
public UseSelFSRecord ( boolean b ) { this ( 0 ) ; _options = useNaturalLanguageFormulasFlag . setBoolean ( _options , b ) ; }
public boolean equals ( Object o ) { return o instanceof RomanianStemmer ; }
public AbortMultipartUploadResult abortMultipartUpload ( AbortMultipartUploadRequest request ) { request = beforeClientExecution ( request ) ; return executeAbortMultipartUpload ( request ) ; }
public void reportMatch ( Parser recognizer ) { endErrorCondition ( recognizer ) ; }
public ModifyVpnConnectionResult modifyVpnConnection ( ModifyVpnConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVpnConnection ( request ) ; }
public GetSendStatisticsResult getSendStatistics ( ) { return getSendStatistics ( new GetSendStatisticsRequest ( ) ) ; }
public CreateVoiceConnectorGroupResult createVoiceConnectorGroup ( CreateVoiceConnectorGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVoiceConnectorGroup ( request ) ; }
public InitiateJobRequest ( String vaultName , JobParameters jobParameters ) { setVaultName ( vaultName ) ; setJobParameters ( jobParameters ) ; }
public MatchResult toMatchResult ( ) { ensureMatch ( ) ; return new MatchResultImpl ( input , matchOffsets ) ; }
public static String getInflectedFormTranslation ( String s ) { return inflFormTranslations . get ( s ) ; }
public static ErrPtg valueOf ( int code ) { switch ( FormulaError . forInt ( code ) ) { case DIV0 : return DIV_ZERO ; case NA : return N_A ; case NAME : return NAME_INVALID ; case NULL : return NULL_INTERSECTION ; case NUM : return NUM_ERROR ; case REF : return REF_INVALID ; case VALUE : return VALUE_INVALID ; default : throw new RuntimeException ( " Unexpected ▁ error ▁ code ▁ ( " + code + " ) " ) ; } }
public GetBasePathMappingResult getBasePathMapping ( GetBasePathMappingRequest request ) { request = beforeClientExecution ( request ) ; return executeGetBasePathMapping ( request ) ; }
public void fromObjectId ( AnyObjectId src ) { this . w1 = src . w1 ; this . w2 = src . w2 ; this . w3 = src . w3 ; this . w4 = src . w4 ; this . w5 = src . w5 ; }
public static List <? extends Tree > getAncestors ( Tree t ) { if ( t . getParent ( ) == null ) return Collections . emptyList ( ) ; List < Tree > ancestors = new ArrayList < Tree > ( ) ; t = t . getParent ( ) ; while ( t != null ) { ancestors . add ( 0 , t ) ; t = t . getParent ( ) ; } return ancestors ; }
public GetUsagePlanResult getUsagePlan ( GetUsagePlanRequest request ) { request = beforeClientExecution ( request ) ; return executeGetUsagePlan ( request ) ; }
public UpdateLoadBalancerAttributeResult updateLoadBalancerAttribute ( UpdateLoadBalancerAttributeRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateLoadBalancerAttribute ( request ) ; }
public void addResult ( int n , boolean isRelevant , long docNameExtractTime ) { if ( Math . abs ( numPoints + 1 - n ) > 1E - 6 ) { throw new IllegalArgumentException ( " point ▁ " + n + " ▁ illegal ▁ after ▁ " + numPoints + " ▁ points ! " ) ; } if ( isRelevant ) { numGoodPoints += 1 ; recallPoints . add ( new RecallPoint ( n , numGoodPoints ) ) ; if ( recallPoints . size ( ) == 1 && n <= 5 ) { mrr = 1.0 / n ; } } numPoints = n ; double p = numGoodPoints / numPoints ; if ( isRelevant ) { pReleventSum += p ; } if ( n < pAt . length ) { pAt [ n ] = p ; } recall = maxGoodPoints <= 0 ? p : numGoodPoints / maxGoodPoints ; docNamesExtractTime += docNameExtractTime ; }
public UpdateExperimentResult updateExperiment ( UpdateExperimentRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateExperiment ( request ) ; }
public String toString ( ) { return " ( " + a . toString ( ) + " ▁ AND ▁ " + b . toString ( ) + " ) " ; }
public String getAccessKeyId ( ) { return accessKeyId ; }
public GetBulkPublishDetailsResult getBulkPublishDetails ( GetBulkPublishDetailsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetBulkPublishDetails ( request ) ; }
public static byte [ ] grow ( byte [ ] array ) { return grow ( array , 1 + array . length ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 , ValueEval arg2 ) { double result ; try { result = evaluate ( evalArg ( arg0 , srcRowIndex , srcColumnIndex ) , evalArg ( arg1 , srcRowIndex , srcColumnIndex ) , evalArg ( arg2 , srcRowIndex , srcColumnIndex ) ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public static final int hash32 ( final byte [ ] data , int offset , int len ) { return MurmurHash2. hash ( data , 0x9747b28c , offset , len ) ; }
public static Formula create ( Ptg [ ] ptgs ) { if ( ptgs == null || ptgs . length < 1 ) { return EMPTY ; } int totalSize = Ptg . getEncodedSize ( ptgs ) ; byte [ ] encodedData = new byte [ totalSize ] ; Ptg . serializePtgs ( ptgs , encodedData , 0 ) ; int encodedTokenLen = Ptg . getEncodedSizeWithoutArrayData ( ptgs ) ; return new Formula ( encodedData , encodedTokenLen ) ; }
public String toString ( String field ) { return null ; }
public static int deleteN ( char s [ ] , int pos , int len , int nChars ) { assert pos + nChars <= len ; if ( pos + nChars < len ) { System . arraycopy ( s , pos + nChars , s , pos , len - pos - nChars ) ; } return len - nChars ; }
public ThreadSafeProgressMonitor ( ProgressMonitor pm ) { this . pm = pm ; this . lock = new ReentrantLock ( ) ; this . mainThread = Thread . currentThread ( ) ; this . workers = new AtomicInteger ( 0 ) ; this . pendingUpdates = new AtomicInteger ( 0 ) ; this . process = new Semaphore ( 0 ) ; }
public SendMessageBatchRequestEntry ( String id , String messageBody ) { setId ( id ) ; setMessageBody ( messageBody ) ; }
public DescribeAddressResult describeAddress ( DescribeAddressRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAddress ( request ) ; }
public GetEventRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetEvent " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DescribeRuleResult describeRule ( DescribeRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeRule ( request ) ; }
public final RevObject getObject ( ) { return object ; }
public JapaneseIterationMarkCharFilterFactory ( Map < String , String > args ) { super ( args ) ; normalizeKanji = getBoolean ( args , NORMALIZE_KANJI_PARAM , JapaneseIterationMarkCharFilter . NORMALIZE_KANJI_DEFAULT ) ; normalizeKana = getBoolean ( args , NORMALIZE_KANA_PARAM , JapaneseIterationMarkCharFilter . NORMALIZE_KANA_DEFAULT ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public char previous ( ) { if ( -- index < start ) { index = start ; return DONE ; } else { return current ( ) ; } }
public LoggingConfig ( String bucket , String prefix ) { setBucket ( bucket ) ; setPrefix ( prefix ) ; }
public static String createSafeSheetName ( final String nameProposal ) { return createSafeSheetName ( nameProposal , ' ▁ ' ) ; }
public PutMetricAlarmResult putMetricAlarm ( PutMetricAlarmRequest request ) { request = beforeClientExecution ( request ) ; return executePutMetricAlarm ( request ) ; }
public CreateExclusionsPreviewResult createExclusionsPreview ( CreateExclusionsPreviewRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateExclusionsPreview ( request ) ; }
public OutputStream getRawStream ( ) { return buf ; }
public int getThreads ( ) { return threads ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final int byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final int byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 6 ) | ( byte1 >>> 2 ) ; final int byte2 = blocks [ blocksOffset ++ ] & 0xFF ; final int byte3 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 3 ) << 12 ) | ( byte2 << 4 ) | ( byte3 >>> 4 ) ; final int byte4 = blocks [ blocksOffset ++ ] & 0xFF ; final int byte5 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte3 & 15 ) << 10 ) | ( byte4 << 2 ) | ( byte5 >>> 6 ) ; final int byte6 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte5 & 63 ) << 8 ) | byte6 ; } }
public boolean eof ( ) { assert upto + bufferOffset <= endIndex ; return upto + bufferOffset == endIndex ; }
public ClientException ( String message ) { super ( message ) ; this . setErrorType ( ErrorType . Client ) ; }
public static NumberRecord [ ] convertRKRecords ( MulRKRecord mrk ) { NumberRecord [ ] mulRecs = new NumberRecord [ mrk . getNumColumns ( ) ] ; for ( int k = 0 ; k < mrk . getNumColumns ( ) ; k ++ ) { NumberRecord nr = new NumberRecord ( ) ; nr . setColumn ( ( short ) ( k + mrk . getFirstColumn ( ) ) ) ; nr . setRow ( mrk . getRow ( ) ) ; nr . setXFIndex ( mrk . getXFAt ( k ) ) ; nr . setValue ( mrk . getRKNumberAt ( k ) ) ; mulRecs [ k ] = nr ; } return mulRecs ; }
public List < ReceiveCommand > getCommands ( ) { return Collections . unmodifiableList ( commands ) ; }
public UpdateVoiceConnectorResult updateVoiceConnector ( UpdateVoiceConnectorRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateVoiceConnector ( request ) ; }
public static String getText ( int errorCode ) { if ( FormulaError . isValidCode ( errorCode ) ) { return FormulaError . forInt ( errorCode ) . getString ( ) ; } return " ~ non ~ std ~ err ( " + errorCode + " ) ~ " ; }
public long nextOrd ( ) { long v = ord ; ord = NO_MORE_ORDS ; return v ; }
public EntityResolver getEntityResolver ( ) { return ( theEntityResolver == this ) ? null : theEntityResolver ; }
public SheetRefEvaluator ( WorkbookEvaluator bookEvaluator , EvaluationTracker tracker , int sheetIndex ) { if ( sheetIndex < 0 ) { throw new IllegalArgumentException ( " Invalid ▁ sheetIndex : ▁ " + sheetIndex + " . " ) ; } _bookEvaluator = bookEvaluator ; _tracker = tracker ; _sheetIndex = sheetIndex ; }
public DBSecurityGroup authorizeDBSecurityGroupIngress ( AuthorizeDBSecurityGroupIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeAuthorizeDBSecurityGroupIngress ( request ) ; }
@ Override public V put ( K key , V value ) { if ( key == null ) { return putValueForNullKey ( value ) ; } int hash = secondaryHash ( key . hashCode ( ) ) ; HashMapEntry < K , V > [ ] tab = table ; int index = hash & ( tab . length - 1 ) ; for ( HashMapEntry < K , V > e = tab [ index ] ; e != null ; e = e . next ) { if ( e . hash == hash && key . equals ( e . key ) ) { preModify ( e ) ; V oldValue = e . value ; e . value = value ; return oldValue ; } } modCount ++ ; if ( size ++ > threshold ) { tab = doubleCapacity ( ) ; index = hash & ( tab . length - 1 ) ; } addNewEntry ( key , value , hash , index ) ; return null ; }
public GetTrafficPolicyInstanceResult getTrafficPolicyInstance ( GetTrafficPolicyInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTrafficPolicyInstance ( request ) ; }
public Message ( Content subject , Body body ) { setSubject ( subject ) ; setBody ( body ) ; }
public LbsDropData ( ) { _str = " " ; _unused = 0 ; }
public Deleted3DPxg ( String sheetName ) { this ( - 1 , sheetName ) ; }
public String getName ( ) { return " simple - two - way - in - core " ; }
public RevTree parseTree ( AnyObjectId id ) throws MissingObjectException , IncorrectObjectTypeException , IOException { RevObject c = peel ( parseAny ( id ) ) ; final RevTree t ; if ( c instanceof RevCommit ) t = ( ( RevCommit ) c ) . getTree ( ) ; else if ( ! ( c instanceof RevTree ) ) throw new IncorrectObjectTypeException ( id . toObjectId ( ) , Constants . TYPE_TREE ) ; elset = ( RevTree ) c ; parseHeaders ( t ) ; return t ; }
public DisableFastSnapshotRestoresResult disableFastSnapshotRestores ( DisableFastSnapshotRestoresRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableFastSnapshotRestores ( request ) ; }
public int size ( ) { return size ; }
public CreateStreamResult createStream ( CreateStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateStream ( request ) ; }
public String replaceAll ( String replacement ) { reset ( ) ; StringBuffer buffer = new StringBuffer ( input . length ( ) ) ; while ( find ( ) ) { appendReplacement ( buffer , replacement ) ; } return appendTail ( buffer ) . toString ( ) ; }
public DeregisterInstanceEventNotificationAttributesResult deregisterInstanceEventNotificationAttributes ( DeregisterInstanceEventNotificationAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterInstanceEventNotificationAttributes ( request ) ; }
public int getDepth ( ) { return depth ; }
public long get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return byteBuffer . getLong ( position ++ * SizeOf . LONG ) ; }
public boolean isEmpty ( ) { return ConcurrentHashMap . this . isEmpty ( ) ; }
public void addName ( NameRecord name ) { _definedNames . add ( name ) ; int idx = findFirstRecordLocBySid ( ExternSheetRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( SupBookRecord . sid ) ; if ( idx == - 1 ) idx = findFirstRecordLocBySid ( CountryRecord . sid ) ; int countNames = _definedNames . size ( ) ; _workbookRecordList . add ( idx + countNames , name ) ; }
public void sort ( RevSort s , boolean use ) { assertNotStarted ( ) ; if ( use ) sorting . add ( s ) ; elsesorting . remove ( s ) ; if ( sorting . size ( ) > 1 ) sorting . remove ( RevSort . NONE ) ; else if ( sorting . isEmpty ( ) ) sorting . add ( RevSort . NONE ) ; }
public String toString ( ) { return " D " ; }
public DisassociateSkillGroupFromRoomResult disassociateSkillGroupFromRoom ( DisassociateSkillGroupFromRoomRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateSkillGroupFromRoom ( request ) ; }
public static byte [ ] encodeASCII ( long s ) { return encodeASCII ( Long . toString ( s ) ) ; }
public void setData ( byte [ ] b ) { setData ( b , 0 , b . length ) ; }
public void removeLinksDirty ( ) { remove1stProperty ( PropertyIDMap . PID_LINKSDIRTY ) ; }
final public void OptionalWeights ( SrndQuery q ) throws ParseException { Token weight = null ; label_8 : while ( true ) { switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case CARAT : ; break ; default : jj_la1 [ 9 ] = jj_gen ; break label_8 ; } jj_consume_token ( CARAT ) ; weight = jj_consume_token ( NUMBER ) ; float f ; try { f = Float . parseFloat ( weight . image ) ; } catch ( Exception floatExc ) { { if ( true ) throw new ParseException ( BOOST_ERROR_MESSAGE + weight . image + " ▁ ( " + floatExc + " ) " ) ; } } if ( f <= 0.0 ) { { if ( true ) throw new ParseException ( BOOST_ERROR_MESSAGE + weight . image ) ; } } q . setWeight ( f * q . getWeight ( ) ) ; } }
public ListLogPatternSetsResult listLogPatternSets ( ListLogPatternSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListLogPatternSets ( request ) ; }
public String toString ( ) { return " < field ▁ start = ' " ▁ + ▁ this . begin ▁ + ▁ " ' ▁ end = ' " ▁ + ▁ this . end ▁ + ▁ " ' ▁ field = ' " + ▁ this . field ▁ + ▁ " ' ▁ text = ' " ▁ + ▁ this . text ▁ + ▁ " ' /> " ; }
public ListAssessmentTargetsResult listAssessmentTargets ( ListAssessmentTargetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAssessmentTargets ( request ) ; }
public HSSFFontFormatting getFontFormatting ( ) { return getFontFormatting ( false ) ; }
public UpdateRoomResult updateRoom ( UpdateRoomRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRoom ( request ) ; }
public ListLexiconsResult listLexicons ( ListLexiconsRequest request ) { request = beforeClientExecution ( request ) ; return executeListLexicons ( request ) ; }
public boolean equals ( Object o ) { return o instanceof KpStemmer ; }
public void write ( String str , int offset , int count ) { String sub = str . substring ( offset , offset + count ) ; buf . append ( sub ) ; }
public PackLock ( File packFile , FS fs ) { final File p = packFile . getParentFile ( ) ; final String n = packFile . getName ( ) ; keepFile = new File ( p , n . substring ( 0 , n . length ( ) - 5 ) + " . keep " ) ; }
public CreatePublicKeyResult createPublicKey ( CreatePublicKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePublicKey ( request ) ; }
public PersonIdent getRefLogIdent ( ) { return refLogIdent ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof EscherComplexProperty ) ) { return false ; } EscherComplexProperty escherComplexProperty = ( EscherComplexProperty ) o ; return Arrays . equals ( complexData , escherComplexProperty . complexData ) ; }
public void unread ( int oneByte ) throws IOException { if ( buf == null ) { throw new IOException ( ) ; } if ( pos == 0 ) { throw new IOException ( " Pushback ▁ buffer ▁ full " ) ; } buf [ -- pos ] = ( byte ) oneByte ; }
public GetSegmentImportJobsResult getSegmentImportJobs ( GetSegmentImportJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetSegmentImportJobs ( request ) ; }
public VerifyEmailAddressResult verifyEmailAddress ( VerifyEmailAddressRequest request ) { request = beforeClientExecution ( request ) ; return executeVerifyEmailAddress ( request ) ; }
public GetTagsResult getTags ( GetTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetTags ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( text ) . append ( ' ( ' ) ; for ( Toffs to : termsOffsets ) sb . append ( to . toString ( ) ) ; sb . append ( ' ) ' ) ; return sb . toString ( ) ; }
public RevFilter clone ( ) { return new Binary ( a . clone ( ) , b . clone ( ) ) ; }
public StandardTokenizerImpl ( java . io . Reader in ) { this . zzReader = in ; }
public MoPenFindGroupRequest ( ) { super ( " MoPen " , " 2018 - 02 - 11 " , " MoPenFindGroup " , " mopen " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public static BreakIterator getLineInstance ( ) { return getLineInstance ( Locale . getDefault ( ) ) ; }
public boolean exists ( ) { return true ; }
public LongBuffer asReadOnlyBuffer ( ) { LongToByteBufferAdapter buf = new LongToByteBufferAdapter ( byteBuffer . asReadOnlyBuffer ( ) ) ; buf . limit = limit ; buf . position = position ; buf . mark = mark ; buf . byteBuffer . order = byteBuffer . order ; return buf ; }
public void writeBytes ( byte [ ] b , int offset , int length ) { assert b . length >= offset + length ; if ( length == 0 ) { return ; } if ( upto == blockSize ) { if ( currentBlock != null ) { addBlock ( currentBlock ) ; } currentBlock = new byte [ blockSize ] ; upto = 0 ; } final int offsetEnd = offset + length ; while ( true ) { final int left = offsetEnd - offset ; final int blockLeft = blockSize - upto ; if ( blockLeft < left ) { System . arraycopy ( b , offset , currentBlock , upto , blockLeft ) ; addBlock ( currentBlock ) ; currentBlock = new byte [ blockSize ] ; upto = 0 ; offset += blockLeft ; } else { System . arraycopy ( b , offset , currentBlock , upto , left ) ; upto += left ; break ; } } }
public ByteBuffer putFloat ( float value ) { throw new ReadOnlyBufferException ( ) ; }
public Class <?> getArgumentClass ( ) { return arg ; }
public GetVaultAccessPolicyResult getVaultAccessPolicy ( GetVaultAccessPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVaultAccessPolicy ( request ) ; }
public GetReusableDelegationSetLimitResult getReusableDelegationSetLimit ( GetReusableDelegationSetLimitRequest request ) { request = beforeClientExecution ( request ) ; return executeGetReusableDelegationSetLimit ( request ) ; }
public int compareTo ( WeightedPhraseInfo other ) { int diff = getStartOffset ( ) - other . getStartOffset ( ) ; if ( diff != 0 ) { return diff ; } diff = getEndOffset ( ) - other . getEndOffset ( ) ; if ( diff != 0 ) { return diff ; } return ( int ) Math . signum ( getBoost ( ) - other . getBoost ( ) ) ; }
public StopRelationalDatabaseResult stopRelationalDatabase ( StopRelationalDatabaseRequest request ) { request = beforeClientExecution ( request ) ; return executeStopRelationalDatabase ( request ) ; }
public void clear ( ) { Arrays . fill ( blocks , 0L ) ; }
public UpdateScriptResult updateScript ( UpdateScriptRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateScript ( request ) ; }
public InterpreterRuleContext ( ParserRuleContext parent , int invokingStateNumber , int ruleIndex ) { super ( parent , invokingStateNumber ) ; this . ruleIndex = ruleIndex ; }
public CreateFileSystemFromBackupResult createFileSystemFromBackup ( CreateFileSystemFromBackupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateFileSystemFromBackup ( request ) ; }
public int getLevelForDistance ( double dist ) { if ( dist == 0 ) { return maxLevels ; } int level = S2Projections . MAX_WIDTH . getMinLevel ( dist * DistanceUtils . DEGREES_TO_RADIANS ) ; int roundLevel = level % arity != 0 ? 1 : 0 ; level = level / arity + roundLevel ; return Math . min ( maxLevels , level + 1 ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { ValueEval ve0 ; ValueEval ve1 ; try { ve0 = OperandResolver . getSingleValue ( arg0 , srcRowIndex , srcColumnIndex ) ; ve1 = OperandResolver . getSingleValue ( arg1 , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( getText ( ve0 ) ) ; sb . append ( getText ( ve1 ) ) ; return new StringEval ( sb . toString ( ) ) ; }
public static ChartDataSource < Number > fromNumericCellRange ( Sheet sheet , CellRangeAddress cellRangeAddress ) { return new AbstractCellRangeDataSource < Number > ( sheet , cellRangeAddress ) ; }
public static FuncPtg create ( LittleEndianInput in ) { return create ( in . readUShort ( ) ) ; }
public InitiateVaultLockResult initiateVaultLock ( InitiateVaultLockRequest request ) { request = beforeClientExecution ( request ) ; return executeInitiateVaultLock ( request ) ; }
public final K getKey ( ) { return key ; }
public boolean isSet ( final int holder ) { return ( holder & _mask ) != 0 ; }
public DoubleMetaphoneFilter ( TokenStream input , int maxCodeLength , boolean inject ) { super ( input ) ; this . encoder . setMaxCodeLen ( maxCodeLength ) ; this . inject = inject ; }
public boolean changeExternalReference ( String oldUrl , String newUrl ) { return workbook . changeExternalReference ( oldUrl , newUrl ) ; }
public DescribeEngineDefaultParametersRequest ( String cacheParameterGroupFamily ) { setCacheParameterGroupFamily ( cacheParameterGroupFamily ) ; }
public void extendB ( ) { endB ++ ; }
public JapaneseReadingFormFilter ( TokenStream input , boolean useRomaji ) { super ( input ) ; this . useRomaji = useRomaji ; }
public DeleteContactResult deleteContact ( DeleteContactRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteContact ( request ) ; }
public static final int next ( byte [ ] b , int ptr , char chrA ) { final int sz = b . length ; while ( ptr < sz ) { if ( b [ ptr ++ ] == chrA ) return ptr ; } return ptr ; }
public InvokeEndpointResult invokeEndpoint ( InvokeEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeInvokeEndpoint ( request ) ; }
public PutAccountSettingDefaultResult putAccountSettingDefault ( PutAccountSettingDefaultRequest request ) { request = beforeClientExecution ( request ) ; return executePutAccountSettingDefault ( request ) ; }
public static Path categoriesLineFile ( Path f ) { Path dir = f . toAbsolutePath ( ) . getParent ( ) ; String categoriesName = " categories - " + f . getFileName ( ) ; return dir . resolve ( categoriesName ) ; }
public String toJson ( ) { return new JsonPolicyWriter ( ) . writePolicyToString ( this ) ; }
public String getFunctionName ( int idx ) { return _funcMap . get ( idx ) ; }
public RecordHandlerProgressResult recordHandlerProgress ( RecordHandlerProgressRequest request ) { request = beforeClientExecution ( request ) ; return executeRecordHandlerProgress ( request ) ; }
public synchronized StringBuffer insert ( int index , char [ ] chars , int start , int length ) { insert0 ( index , chars , start , length ) ; return this ; }
public RevObject lookupAny ( AnyObjectId id , int type ) { RevObject r = objects . get ( id ) ; if ( r == null ) { switch ( type ) { case Constants . OBJ_COMMIT : r = createCommit ( id ) ; break ; case Constants . OBJ_TREE : r = new RevTree ( id ) ; break ; case Constants . OBJ_BLOB : r = new RevBlob ( id ) ; break ; case Constants . OBJ_TAG : r = new RevTag ( id ) ; break ; default : throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . invalidGitType , Integer . valueOf ( type ) ) ) ; } objects . add ( r ) ; } return r ; }
public BytesRef encode ( char [ ] buffer ) { return encode ( buffer , 0 , buffer . length ) ; }
public StringBuilder append ( int i ) { IntegralToString . appendInt ( this , i ) ; return this ; }
public void removeName ( Name name ) { int index = getNameIndex ( ( HSSFName ) name ) ; removeName ( index ) ; }
public WrappedPositionArray ( ) { for ( int i = 0 ; i < positions . length ; i ++ ) { positions [ i ] = new Position ( ) ; } }
public PasswordRev4Record ( int pw ) { field_1_password = pw ; }
public static String intToHex ( int value ) { StringBuilder sb = new StringBuilder ( 10 ) ; writeHex ( sb , value & 0xFFFFFFFFL , 8 , " 0x " ) ; return sb . toString ( ) ; }
public RemovePermissionRequest ( String topicArn , String label ) { setTopicArn ( topicArn ) ; setLabel ( label ) ; }
public UpdateOrganizationConfigurationResult updateOrganizationConfiguration ( UpdateOrganizationConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateOrganizationConfiguration ( request ) ; }
public void seekExact ( BytesRef target , TermState otherState ) { assert otherState != null && otherState instanceof BlockTermState ; assert ! doOrd || ( ( BlockTermState ) otherState ) . ord < numTerms ; state . copyFrom ( otherState ) ; seekPending = true ; indexIsCurrent = false ; term . copyBytes ( target ) ; }
public void println ( ) { newline ( ) ; }
public String toString ( ) { return " NRTCachingDirectory ( " + in + " ; ▁ maxCacheMB = " + ( maxCachedBytes / 1024 / 1024. ) + " ▁ maxMergeSizeMB = " + ( maxMergeSizeBytes / 1024 / 1024. ) + " ) " ; }
public DescribeWorkforceResult describeWorkforce ( DescribeWorkforceRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeWorkforce ( request ) ; }
public ToggleFeaturesRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ToggleFeatures " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public synchronized StringBuffer append ( char [ ] chars , int start , int length ) { append0 ( chars , start , length ) ; return this ; }
public ShortBuffer put ( short c ) { if ( position == limit ) { throw new BufferOverflowException ( ) ; } byteBuffer . putShort ( position ++ * SizeOf . SHORT , c ) ; return this ; }
public char last ( ) { index = ( limit == start ) ? limit : limit - 1 ; return current ( ) ; }
public WeightedSpanTermExtractor ( String defaultField ) { this . defaultField = defaultField ; }
public StringReader ( String str ) { this . str = str ; this . count = str . length ( ) ; }
public GetThumbnailsRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetThumbnails " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public TagCommand setName ( String name ) { checkCallable ( ) ; this . name = name ; return this ; }
@ Override public String toString ( ) { synchronized ( mutex ) { return c . toString ( ) ; } }
public String toString ( ) { return toString ( ( List < String > ) null , ( RuleContext ) null ) ; }
public String toString ( ) { return " StandardDirectoryReader . ReaderCommit ( " + segmentsFileName + " ▁ files = " + files + " ) " ; }
public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesAfterHeader = readHeader ( data , offset ) ; int pos = offset + HEADER_SIZE ; field_pictureData = IOUtils . safelyAllocate ( bytesAfterHeader , MAX_RECORD_LENGTH ) ; System . arraycopy ( data , pos , field_pictureData , 0 , bytesAfterHeader ) ; return bytesAfterHeader + 8 ; }
public static int [ ] copyOf ( int [ ] original , int newLength ) { if ( newLength < 0 ) { throw new NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; }
public void serialize ( LittleEndianOutput out ) { out . write ( data ) ; }
public E get ( int location ) { if ( location >= 0 && location < size ) { Link < E > link = voidLink ; if ( location < ( size / 2 ) ) { for ( int i = 0 ; i <= location ; i ++ ) { link = link . next ; } } else { for ( int i = size ; i > location ; i -- ) { link = link . previous ; } } return link . data ; } throw new IndexOutOfBoundsException ( ) ; }
public static boolean hasExactSharedBorder ( CellRangeAddress crA , CellRangeAddress crB ) { int oFirstRow = crB . getFirstRow ( ) ; int oLastRow = crB . getLastRow ( ) ; int oFirstCol = crB . getFirstColumn ( ) ; int oLastCol = crB . getLastColumn ( ) ; if ( crA . getFirstRow ( ) > 0 && crA . getFirstRow ( ) - 1 == oLastRow || oFirstRow > 0 && oFirstRow - 1 == crA . getLastRow ( ) ) { return crA . getFirstColumn ( ) == oFirstCol && crA . getLastColumn ( ) == oLastCol ; } if ( crA . getFirstColumn ( ) > 0 && crA . getFirstColumn ( ) - 1 == oLastCol || oFirstCol > 0 && crA . getLastColumn ( ) == oFirstCol - 1 ) { return crA . getFirstRow ( ) == oFirstRow && crA . getLastRow ( ) == oLastRow ; } return false ; }
public void visitCellsForRow ( int rowIndex , RecordVisitor rv ) { CellValueRecordInterface [ ] rowCells = records [ rowIndex ] ; if ( rowCells == null ) { throw new IllegalArgumentException ( " Row ▁ [ " + rowIndex + " ] ▁ is ▁ empty " ) ; } for ( int i = 0 ; i < rowCells . length ; i ++ ) { RecordBase cvr = ( RecordBase ) rowCells [ i ] ; if ( cvr == null ) { continue ; } int nBlank = countBlanks ( rowCells , i ) ; if ( nBlank > 1 ) { rv . visitRecord ( createMBR ( rowCells , i , nBlank ) ) ; i += nBlank - 1 ; } else if ( cvr instanceof RecordAggregate ) { RecordAggregate agg = ( RecordAggregate ) cvr ; agg . visitContainedRecords ( rv ) ; } else { rv . visitRecord ( ( org . apache . poi . hssf . record . Record ) cvr ) ; } } }
public DeleteVpnConnectionResult deleteVpnConnection ( DeleteVpnConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVpnConnection ( request ) ; }
public void clear ( ) { username = null ; if ( password != null ) { Arrays . fill ( password , ( char ) 0 ) ; password = null ; } }
public String toString ( ) { return String . format ( Locale . ROOT , " time =% .2f ▁ sec . ▁ total ▁ ( % .2f ▁ reading , ▁ % .2f ▁ sorting , ▁ % .2f ▁ merging ) , ▁ lines =% d , ▁ temp ▁ files =% d , ▁ merges =% d , ▁ soft ▁ ram ▁ limit =% .2f ▁ MB " , totalTimeMS / 1000.0d , readTimeMS / 1000.0d , sortTimeMS . get ( ) / 1000.0d , mergeTimeMS . get ( ) / 1000.0d , lineCount , tempMergeFiles , mergeRounds , ( double ) bufferSize / MB ) ; }
public DetachLoadBalancersResult detachLoadBalancers ( DetachLoadBalancersRequest request ) { request = beforeClientExecution ( request ) ; return executeDetachLoadBalancers ( request ) ; }
public synchronized Span [ ] splitSentences ( String line ) { if ( sentenceSplitter != null ) { return sentenceSplitter . sentPosDetect ( line ) ; } else { Span [ ] shorty = new Span [ 1 ] ; shorty [ 0 ] = new Span ( 0 , line . length ( ) ) ; return shorty ; } }
public boolean isRemote ( ) { return getHost ( ) != null ; }
public void setBuiltinStyle ( int builtinStyleId ) { field_1_xf_index = isBuiltinFlag . set ( field_1_xf_index ) ; field_2_builtin_style = builtinStyleId ; }
public ObjectReader getObjectReader ( ) { return reader ; }
public void addEscherProperty ( EscherProperty prop ) { properties . add ( prop ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ " ) . append ( " USERSVIEWBEGIN " ) . append ( " ] ▁ ( 0x " ) ; sb . append ( Integer . toHexString ( sid ) . toUpperCase ( Locale . ROOT ) ) . append ( " ) \ n " ) ; sb . append ( " ▁ ▁ rawData = " ) . append ( HexDump . toHex ( _rawData ) ) . append ( " \ n " ) ; sb . append ( " [ / " ) . append ( " USERSVIEWBEGIN " ) . append ( " ] \ n " ) ; return sb . toString ( ) ; }
public String group ( int group ) { ensureMatch ( ) ; int from = matchOffsets [ group * 2 ] ; int to = matchOffsets [ ( group * 2 ) + 1 ] ; if ( from == - 1 || to == - 1 ) { return null ; } else { return input . substring ( from , to ) ; } }
public void removeCompany ( ) { remove1stProperty ( PropertyIDMap . PID_COMPANY ) ; }
public RevFilter clone ( ) { final RevFilter [ ] s = new RevFilter [ subfilters . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) s [ i ] = subfilters [ i ] . clone ( ) ; return new List ( s ) ; }
public static Charset defaultCharset ( ) { return DEFAULT_CHARSET ; }
public void removeName ( Name name ) { int index = getNameIndex ( ( HSSFName ) name ) ; removeName ( index ) ; }
public AttributeValueUpdate ( AttributeValue value , AttributeAction action ) { setValue ( value ) ; setAction ( action . toString ( ) ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ FOOTER ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . footer ▁ = ▁ " ) . append ( getText ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / FOOTER ] \ n " ) ; return buffer . toString ( ) ; }
public DisassociateSkillFromSkillGroupResult disassociateSkillFromSkillGroup ( DisassociateSkillFromSkillGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateSkillFromSkillGroup ( request ) ; }
public String toString ( String field ) { StringBuilder buffer = new StringBuilder ( ) ; if ( ! getField ( ) . equals ( field ) ) { buffer . append ( getField ( ) ) ; buffer . append ( ' : ' ) ; } buffer . append ( term . text ( ) ) ; buffer . append ( ' * ' ) ; return buffer . toString ( ) ; }
public NameRecord getNameRecord ( int index ) { return _definedNames . get ( index ) ; }
public BottomMarginRecord clone ( ) { return copy ( ) ; }
@ Override public V setValue ( V object ) { throw new UnsupportedOperationException ( ) ; }
public QuadPrefixTree ( SpatialContext ctx , Rectangle bounds , int maxLevels ) { super ( ctx , maxLevels ) ; this . xmin = bounds . getMinX ( ) ; this . xmax = bounds . getMaxX ( ) ; this . ymin = bounds . getMinY ( ) ; this . ymax = bounds . getMaxY ( ) ; levelW = new double [ maxLevels + 1 ] ; levelH = new double [ maxLevels + 1 ] ; gridW = xmax - xmin ; gridH = ymax - ymin ; this . xmid = xmin + gridW / 2.0 ; this . ymid = ymin + gridH / 2.0 ; levelW [ 0 ] = gridW / 2.0 ; levelH [ 0 ] = gridH / 2.0 ; for ( int i = 1 ; i < levelW . length ; i ++ ) { levelW [ i ] = levelW [ i - 1 ] / 2.0 ; levelH [ i ] = levelH [ i - 1 ] / 2.0 ; } }
public static HSSFAnchor createAnchorFromEscher ( EscherContainerRecord container ) { if ( null != container . getChildById ( EscherChildAnchorRecord . RECORD_ID ) ) { return new HSSFChildAnchor ( container . getChildById ( EscherChildAnchorRecord . RECORD_ID ) ) ; } else { if ( null != container . getChildById ( EscherClientAnchorRecord . RECORD_ID ) ) { return new HSSFClientAnchor ( container . getChildById ( EscherClientAnchorRecord . RECORD_ID ) ) ; } return null ; } }
public void reset ( ) { if ( _input != null ) { _input . seek ( 0 ) ; } _token = null ; _type = Token . INVALID_TYPE ; _channel = Token . DEFAULT_CHANNEL ; _tokenStartCharIndex = - 1 ; _tokenStartCharPositionInLine = - 1 ; _tokenStartLine = - 1 ; _text = null ; _hitEOF = false ; _mode = Lexer . DEFAULT_MODE ; _modeStack . clear ( ) ; getInterpreter ( ) . reset ( ) ; }
public ShortBuffer slice ( ) { byteBuffer . limit ( limit * SizeOf . SHORT ) ; byteBuffer . position ( position * SizeOf . SHORT ) ; ByteBuffer bb = byteBuffer . slice ( ) . order ( byteBuffer . order ( ) ) ; ShortBuffer result = new ShortToByteBufferAdapter ( bb ) ; byteBuffer . clear ( ) ; return result ; }
public boolean isPackedGitMMAP ( ) { return packedGitMMAP ; }
public boolean equalsSameType ( Object other ) { assert exists || 0.0D == value ; MutableValueDouble b = ( MutableValueDouble ) other ; return value == b . value && exists == b . exists ; }
public PurchaseReservedInstancesOfferingResult purchaseReservedInstancesOffering ( PurchaseReservedInstancesOfferingRequest request ) { request = beforeClientExecution ( request ) ; return executePurchaseReservedInstancesOffering ( request ) ; }
public final char readChar ( ) throws IOException { return ( char ) readShort ( ) ; }
public AssociateRepositoryResult associateRepository ( AssociateRepositoryRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateRepository ( request ) ; }
public ImportApiKeysResult importApiKeys ( ImportApiKeysRequest request ) { request = beforeClientExecution ( request ) ; return executeImportApiKeys ( request ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeShort ( field_1_index_extern_sheet ) ; out . writeInt ( unused1 ) ; out . writeInt ( unused2 ) ; }
public Type getType ( ) { return type ; }
public static Calendar getJavaCalendar ( double date , boolean use1904windowing ) { return getJavaCalendar ( date , use1904windowing , null , false ) ; }
public DeleteSnapshotScheduleResult deleteSnapshotSchedule ( DeleteSnapshotScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSnapshotSchedule ( request ) ; }
public void writeProtectWorkbook ( String password , String username ) { this . workbook . writeProtectWorkbook ( password , username ) ; }
public CreateCloudFormationStackResult createCloudFormationStack ( CreateCloudFormationStackRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCloudFormationStack ( request ) ; }
public void writeByte ( byte b ) throws IOException { assert bufferPos == buffer . position ( ) : " bufferPos = " + bufferPos + " ▁ vs ▁ buffer . position ( ) = " + buffer . position ( ) ; buffer . put ( b ) ; if ( ++ bufferPos == bufferSize ) { dump ( ) ; } }
public ExtendedFormatRecord ( RecordInputStream in ) { field_1_font_index = in . readShort ( ) ; field_2_format_index = in . readShort ( ) ; field_3_cell_options = in . readShort ( ) ; field_4_alignment_options = in . readShort ( ) ; field_5_indention_options = in . readShort ( ) ; field_6_border_options = in . readShort ( ) ; field_7_palette_options = in . readShort ( ) ; field_8_adtl_palette_options = in . readInt ( ) ; field_9_fill_palette_options = in . readShort ( ) ; }
public int getExternalSheetIndex ( String workbookName , String sheetName ) { return _iBook . getExternalSheetIndex ( workbookName , sheetName ) ; }
public HSSFObjectData ( EscherContainerRecord spContainer , ObjRecord objRecord , DirectoryEntry _root ) { super ( spContainer , objRecord ) ; this . _root = _root ; }
public long ramBytesUsed ( ) { return super . ramBytesUsed ( ) + offsets . ramBytesUsed ( ) + lengths . ramBytesUsed ( ) + RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + 2 * Integer . BYTES + 3 * RamUsageEstimator . NUM_BYTES_OBJECT_REF + values . bytes ( ) . length ; }
public UpdateApnsVoipChannelResult updateApnsVoipChannel ( UpdateApnsVoipChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateApnsVoipChannel ( request ) ; }
public String [ ] getNames ( ) { return nameValPairs . keySet ( ) . toArray ( new String [ 0 ] ) ; }
public DeleteAutoSnapshotResult deleteAutoSnapshot ( DeleteAutoSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAutoSnapshot ( request ) ; }
public int getLowIx ( ) { return _lowIx ; }
public DescribeSubscribedWorkteamResult describeSubscribedWorkteam ( DescribeSubscribedWorkteamRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSubscribedWorkteam ( request ) ; }
public DeleteVpnGatewayResult deleteVpnGateway ( DeleteVpnGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVpnGateway ( request ) ; }
public boolean get ( int index ) { return intSet . exists ( index ) ; }
public String constantName ( ) { return constantName ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_formatIndex ) ; }
public boolean isEmpty ( ) { return size ( ) == 0 ; }
public DescribeCacheParametersResult describeCacheParameters ( DescribeCacheParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCacheParameters ( request ) ; }
public SimpleFraction ( int numerator , int denominator ) { this . numerator = numerator ; this . denominator = denominator ; }
public static int idealBooleanArraySize ( int need ) { return idealByteArraySize ( need ) ; }
public SubmoduleStatusCommand submoduleStatus ( ) { return new SubmoduleStatusCommand ( repo ) ; }
public PutRecordBatchResult putRecordBatch ( PutRecordBatchRequest request ) { request = beforeClientExecution ( request ) ; return executePutRecordBatch ( request ) ; }
public QueryTermScorer ( WeightedTerm [ ] weightedTerms ) { termsToFind = new HashMap <> ( ) ; for ( int i = 0 ; i < weightedTerms . length ; i ++ ) { WeightedTerm existingTerm = termsToFind . get ( weightedTerms [ i ] . term ) ; if ( ( existingTerm == null ) || ( existingTerm . weight < weightedTerms [ i ] . weight ) ) { termsToFind . put ( weightedTerms [ i ] . term , weightedTerms [ i ] ) ; maxTermWeight = Math . max ( maxTermWeight , weightedTerms [ i ] . getWeight ( ) ) ; } } }
public static boolean allSubsetsConflict ( Collection < BitSet > altsets ) { return ! hasNonConflictingAltSet ( altsets ) ; }
public DescribeRuntimeConfigurationResult describeRuntimeConfiguration ( DescribeRuntimeConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeRuntimeConfiguration ( request ) ; }
public RevCommit parseCommit ( AnyObjectId id ) throws MissingObjectException , IncorrectObjectTypeException , IOException { RevObject c = peel ( parseAny ( id ) ) ; if ( ! ( c instanceof RevCommit ) ) throw new IncorrectObjectTypeException ( id . toObjectId ( ) , Constants . TYPE_COMMIT ) ; return ( RevCommit ) c ; }
public short readShort ( ) { return ( short ) readUShort ( ) ; }
public final void clear ( ) { for ( int i = 0 ; i <= size ; i ++ ) { heap [ i ] = null ; } size = 0 ; }
public CreateVPCAssociationAuthorizationResult createVPCAssociationAuthorization ( CreateVPCAssociationAuthorizationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVPCAssociationAuthorization ( request ) ; }
public ModifyCacheParameterGroupRequest ( String cacheParameterGroupName , java . util . List < ParameterNameValue > parameterNameValues ) { setCacheParameterGroupName ( cacheParameterGroupName ) ; setParameterNameValues ( parameterNameValues ) ; }
public boolean equals ( Object o ) { return o instanceof CatalanStemmer ; }
public AutomatonQuery ( final Term term , Automaton automaton ) { this ( term , automaton , Operations . DEFAULT_MAX_DETERMINIZED_STATES ) ; }
public String getPattern ( ) { return pattern ; }
public int compareTo ( IntBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; int thisInt , otherInt ; while ( compareRemaining > 0 ) { thisInt = get ( thisPos ) ; otherInt = otherBuffer . get ( otherPos ) ; if ( thisInt != otherInt ) { return thisInt < otherInt ? - 1 : 1 ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; }
public final boolean hasNext ( ) { return next != header ; }
public Class < IndexChangedListener > getListenerType ( ) { return IndexChangedListener . class ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ OBJECTLINK ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . anchorId ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getAnchorId ( ) ) ) . append ( " ▁ ( " ) . append ( getAnchorId ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " ▁ ▁ ▁ ▁ . link1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getLink1 ( ) ) ) . append ( " ▁ ( " ) . append ( getLink1 ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " ▁ ▁ ▁ ▁ . link2 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " 0x " ) . append ( HexDump . toHex ( getLink2 ( ) ) ) . append ( " ▁ ( " ) . append ( getLink2 ( ) ) . append ( " ▁ ) " ) ; buffer . append ( System . getProperty ( " line . separator " ) ) ; buffer . append ( " [ / OBJECTLINK ] \ n " ) ; return buffer . toString ( ) ; }
public void setDetectRenames ( boolean on ) { if ( on && renameDetector == null ) { assertHaveReader ( ) ; renameDetector = new RenameDetector ( reader , diffCfg ) ; } else if ( ! on ) renameDetector = null ; }
public boolean isSupported ( int bitsPerValue ) { return Packed64SingleBlock . isSupported ( bitsPerValue ) ; }
public void setOutputUnigrams ( boolean outputUnigrams ) { this . outputUnigrams = outputUnigrams ; gramSize = new CircularSequence ( ) ; }
public TypeAsPayloadTokenFilter create ( TokenStream input ) { return new TypeAsPayloadTokenFilter ( input ) ; }
public CreateIndexResult createIndex ( CreateIndexRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateIndex ( request ) ; }
public QualityQuery ( String queryID , Map < String , String > nameValPairs ) { this . queryID = queryID ; this . nameValPairs = nameValPairs ; }
public void addFirst ( E object ) { addFirstImpl ( object ) ; }
public ValidateConfigurationSettingsRequest ( String applicationName , java . util . List < ConfigurationOptionSetting > optionSettings ) { setApplicationName ( applicationName ) ; setOptionSettings ( optionSettings ) ; }
public static FileKey exact ( File directory , FS fs ) { return new FileKey ( directory , fs ) ; }
public void removeScale ( ) { remove1stProperty ( PropertyIDMap . PID_SCALE ) ; }
public DocumentDictionary ( IndexReader reader , String field , String weightField , String payloadField , String contextsField ) { this . reader = reader ; this . field = field ; this . weightField = weightField ; this . payloadField = payloadField ; this . contextsField = contextsField ; }
public long get ( int index ) { final int o = index / 5 ; final int b = index % 5 ; final int shift = b * 12 ; return ( blocks [ o ] >>> shift ) & 4095L ; }
@ Override public void clear ( ) { synchronized ( mutex ) { c . clear ( ) ; } }
public boolean hasNext ( ) { return _nextIndex < _endIx ; }
public AssociateVirtualInterfaceResult associateVirtualInterface ( AssociateVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateVirtualInterface ( request ) ; }
public DoubleValuesSource makeDistanceValueSource ( Point queryPoint ) { return makeDistanceValueSource ( queryPoint , 1.0 ) ; }
public float getTokenScore ( ) { position += posIncAtt . getPositionIncrement ( ) ; String termText = termAtt . toString ( ) ; WeightedSpanTerm weightedSpanTerm ; if ( ( weightedSpanTerm = fieldWeightedSpanTerms . get ( termText ) ) == null ) { return 0 ; } if ( weightedSpanTerm . positionSensitive &&! weightedSpanTerm . checkPosition ( position ) ) { return 0 ; } float score = weightedSpanTerm . getWeight ( ) ; if ( ! foundTerms . contains ( termText ) ) { totalScore += score ; foundTerms . add ( termText ) ; } return score ; }
public E pollFirst ( ) { Map . Entry < E , Object > entry = backingMap . pollFirstEntry ( ) ; return ( entry == null ) ? null : entry . getKey ( ) ; }
public void enterEveryRule ( ParserRuleContext ctx ) { System . out . println ( " enter ▁ ▁ ▁ " + getRuleNames ( ) [ ctx . getRuleIndex ( ) ] + " , ▁ LT ( 1 ) = " + _input . LT ( 1 ) . getText ( ) ) ; }
public ShortBuffer put ( int index , short c ) { checkIndex ( index ) ; byteBuffer . putShort ( index * SizeOf . SHORT , c ) ; return this ; }
public void notifyUpdateCell ( Cell cell ) { _bookEvaluator . notifyUpdateCell ( new HSSFEvaluationCell ( ( HSSFCell ) cell ) ) ; }
public void moveCell ( HSSFCell cell , short newColumn ) { if ( cells . length > newColumn && cells [ newColumn ] != null ) { throw new IllegalArgumentException ( " Asked ▁ to ▁ move ▁ cell ▁ to ▁ column ▁ " + newColumn + " ▁ but ▁ there ' s already a cell there " ) ; } if ( ! ▁ cells [ cell . getColumnIndex ( ) ] . equals ( cell ) ) ▁ { throw ▁ new ▁ IllegalArgumentException ( " Asked to move a cell , but it didn ' t ▁ belong ▁ to ▁ our ▁ row " ) ; } removeCell ( cell , false ) ; cell . updateCellNum ( newColumn ) ; addCell ( cell ) ; }
public void connect ( PipedWriter src ) throws IOException { src . connect ( this ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getFirstColumn ( ) ) ; out . writeShort ( getLastColumn ( ) ) ; out . writeShort ( getColumnWidth ( ) ) ; out . writeShort ( getXFIndex ( ) ) ; out . writeShort ( _options ) ; out . writeShort ( field_6_reserved ) ; }
public ModifyWorkspaceCreationPropertiesResult modifyWorkspaceCreationProperties ( ModifyWorkspaceCreationPropertiesRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyWorkspaceCreationProperties ( request ) ; }
public BoolDocValues ( ValueSource vs ) { this . vs = vs ; }
public void reset ( ) { nextWrite -- ; while ( count > 0 ) { if ( nextWrite == - 1 ) { nextWrite = positions . length - 1 ; } positions [ nextWrite -- ] . reset ( ) ; count -- ; } nextWrite = 0 ; nextPos = 0 ; count = 0 ; }
public UpdateDirectConnectGatewayAssociationResult updateDirectConnectGatewayAssociation ( UpdateDirectConnectGatewayAssociationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDirectConnectGatewayAssociation ( request ) ; }
public EditPhotoStoreRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " EditPhotoStore " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public String toString ( ) { return " < matchNoDocsQueryNode /> " ; }
public AddCommand addFilepattern ( String filepattern ) { checkCallable ( ) ; filepatterns . add ( filepattern ) ; return this ; }
public String toString ( ) { return ' [ ' + " HEADERFOOTER " + " ] ▁ ( 0x " + Integer . toHexString ( sid ) . toUpperCase ( Locale . ROOT ) + " ) \ n " + " ▁ ▁ rawData = " + HexDump . toHex ( _rawData ) + " \ n " + " [ / " + " HEADERFOOTER " + " ] \ n " ; }
public UpdateBrokerResult updateBroker ( UpdateBrokerRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateBroker ( request ) ; }
public FormatRecord clone ( ) { return copy ( ) ; }
public AssociateS3ResourcesResult associateS3Resources ( AssociateS3ResourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateS3Resources ( request ) ; }
public UnknownRecord ( int id , byte [ ] data ) { _sid = id & 0xFFFF ; _rawData = data ; }
public TreeFilter clone ( ) { return new Binary ( a . clone ( ) , b . clone ( ) ) ; }
public int getRawValue ( final int holder ) { return ( holder & _mask ) ; }
public CancelResizeResult cancelResize ( CancelResizeRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelResize ( request ) ; }
public CreateTransitGatewayRouteResult createTransitGatewayRoute ( CreateTransitGatewayRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTransitGatewayRoute ( request ) ; }
public FastVectorHighlighter ( boolean phraseHighlight , boolean fieldMatch , FragListBuilder fragListBuilder , FragmentsBuilder fragmentsBuilder ) { this . phraseHighlight = phraseHighlight ; this . fieldMatch = fieldMatch ; this . fragListBuilder = fragListBuilder ; this . fragmentsBuilder = fragmentsBuilder ; }
public SetTypeDefaultVersionResult setTypeDefaultVersion ( SetTypeDefaultVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeSetTypeDefaultVersion ( request ) ; }
public final long computeNorm ( FieldInvertState state ) { return get ( state . getName ( ) ) . computeNorm ( state ) ; }
public CreateCustomVerificationEmailTemplateResult createCustomVerificationEmailTemplate ( CreateCustomVerificationEmailTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCustomVerificationEmailTemplate ( request ) ; }
public static double median ( double [ ] v ) { double r = Double . NaN ; if ( v != null && v . length >= 1 ) { int n = v . length ; Arrays . sort ( v ) ; r = ( n % 2 == 0 ) ? ( v [ n / 2 ] + v [ n / 2 - 1 ] ) / 2 : v [ n / 2 ] ; } return r ; }
public void walk ( ParseTreeListener listener , ParseTree t ) { if ( t instanceof ErrorNode ) { listener . visitErrorNode ( ( ErrorNode ) t ) ; return ; } else if ( t instanceof TerminalNode ) { listener . visitTerminal ( ( TerminalNode ) t ) ; return ; } RuleNode r = ( RuleNode ) t ; enterRule ( listener , r ) ; int n = r . getChildCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { walk ( listener , r . getChild ( i ) ) ; } exitRule ( listener , r ) ; }
public SCLRecord ( RecordInputStream in ) { field_1_numerator = in . readShort ( ) ; field_2_denominator = in . readShort ( ) ; }
public boolean add ( final T value ) { int index = elements . size ( ) ; elements . add ( value ) ; valueKeyMap . put ( value , index ) ; return true ; }
public RawText ( byte [ ] input ) { this ( input , RawParseUtils . lineMap ( input , 0 , input . length ) ) ; }
public void writeInt ( int v ) { checkPosition ( 4 ) ; int i = _writeIndex ; _buf [ i ++ ] = ( byte ) ( ( v >>> 0 ) & 0xFF ) ; _buf [ i ++ ] = ( byte ) ( ( v >>> 8 ) & 0xFF ) ; _buf [ i ++ ] = ( byte ) ( ( v >>> 16 ) & 0xFF ) ; _buf [ i ++ ] = ( byte ) ( ( v >>> 24 ) & 0xFF ) ; _writeIndex = i ; }
public GetRepoBatchRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoBatch " , " cr " ) ; setUriPattern ( " / batchsearch " ) ; setMethod ( MethodType . GET ) ; }
public MoPenDoRecognizeRequest ( ) { super ( " MoPen " , " 2018 - 02 - 11 " , " MoPenDoRecognize " , " mopen " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public Iterator < Map . Entry < K , V >> iterator ( ) { return new EntryIterator ( ) ; }
public DeleteApnsSandboxChannelResult deleteApnsSandboxChannel ( DeleteApnsSandboxChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApnsSandboxChannel ( request ) ; }
public short readShort ( ) { if ( shouldSkipEncryptionOnCurrentRecord ) { readPlain ( buffer , 0 , LittleEndianConsts . SHORT_SIZE ) ; return LittleEndian . getShort ( buffer ) ; } else { return ccis . readShort ( ) ; } }
public DeleteEndpointResult deleteEndpoint ( DeleteEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteEndpoint ( request ) ; }
@ Override public int lastIndexOf ( Object object ) { return list . lastIndexOf ( object ) ; }
public void SwitchTo ( int lexState ) { if ( lexState >= 3 || lexState < 0 ) throw new TokenMgrError ( " Error : ▁ Ignoring ▁ invalid ▁ lexical ▁ state ▁ : ▁ " + lexState + " . ▁ State ▁ unchanged . " , TokenMgrError . INVALID_LEXICAL_STATE ) ; elsecurLexState = lexState ; }
public GetIndustryInfoChildrenListRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " GetIndustryInfoChildrenList " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public Credential ( String keyId , String secret , int expiredHours ) { this . accessKeyId = keyId ; this . accessSecret = secret ; this . refreshDate = new Date ( ) ; setExpiredDate ( expiredHours ) ; }
public KeywordMarkerFilterFactory ( Map < String , String > args ) { super ( args ) ; wordFiles = get ( args , PROTECTED_TOKENS ) ; stringPattern = get ( args , PATTERN ) ; ignoreCase = getBoolean ( args , " ignoreCase " , false ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public CellRangeAddress getAreaAt ( int index ) { return _regions [ _startIndex + index ] ; }
public PutEmailIdentityDkimSigningAttributesResult putEmailIdentityDkimSigningAttributes ( PutEmailIdentityDkimSigningAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executePutEmailIdentityDkimSigningAttributes ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " ▁ [ FEATURE ▁ SMART ▁ TAGS ] \ n " ) ; buffer . append ( " ▁ [ / FEATURE ▁ SMART ▁ TAGS ] \ n " ) ; return buffer . toString ( ) ; }
public static void checkStartAndEnd ( int len , int start , int end ) { if ( start < 0 || end > len ) { throw new ArrayIndexOutOfBoundsException ( " start ▁ < ▁ 0 ▁ || ▁ end ▁ > ▁ len . " + " ▁ start = " + start + " , ▁ end = " + end + " , ▁ len = " + len ) ; } if ( start > end ) { throw new IllegalArgumentException ( " start ▁ > ▁ end : ▁ " + start + " ▁ > ▁ " + end ) ; } }
public Loc ( int bookIndex , int sheetIndex , int rowIndex , int columnIndex ) { _bookSheetColumn = toBookSheetColumn ( bookIndex , sheetIndex , columnIndex ) ; _rowIndex = rowIndex ; }
public BoolErrRecord ( RecordInputStream in ) { super ( in ) ; switch ( in . remaining ( ) ) { case 2 : _value = in . readByte ( ) ; break ; case 3 : _value = in . readUShort ( ) ; break ; default : throw new RecordFormatException ( " Unexpected ▁ size ▁ ( " + in . remaining ( ) + " ) ▁ for ▁ BOOLERR ▁ record . " ) ; } int flag = in . readUByte ( ) ; switch ( flag ) { case 0 : _isError = false ; break ; case 1 : _isError = true ; break ; default : throw new RecordFormatException ( " Unexpected ▁ isError ▁ flag ▁ ( " + flag + " ) ▁ for ▁ BOOLERR ▁ record . " ) ; } }
public String toString ( ) { return " OrdTermState ▁ ord = " + ord ; }
public Note ( AnyObjectId noteOn , ObjectId noteData ) { super ( noteOn ) ; data = noteData ; }
public GetModelVersionResult getModelVersion ( GetModelVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetModelVersion ( request ) ; }
public void addBreak ( int main , int subFrom , int subTo ) { Integer key = Integer . valueOf ( main ) ; Break region = _breakMap . get ( key ) ; if ( region == null ) { region = new Break ( main , subFrom , subTo ) ; _breakMap . put ( key , region ) ; _breaks . add ( region ) ; } else { region . main = main ; region . subFrom = subFrom ; region . subTo = subTo ; } }
public DescribeUsageReportSubscriptionsResult describeUsageReportSubscriptions ( DescribeUsageReportSubscriptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeUsageReportSubscriptions ( request ) ; }
public boolean offerLast ( E e ) { return addLastImpl ( e ) ; }
public RegistrantProfileRealNameVerificationRequest ( ) { super ( " Domain " , " 2018 - 01 - 29 " , " RegistrantProfileRealNameVerification " ) ; setMethod ( MethodType . POST ) ; }
public RowColKey ( int rowIndex , int columnIndex ) { _rowIndex = rowIndex ; _columnIndex = columnIndex ; }
public DisassociateTransitGatewayMulticastDomainResult disassociateTransitGatewayMulticastDomain ( DisassociateTransitGatewayMulticastDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateTransitGatewayMulticastDomain ( request ) ; }
public Charset detectedCharset ( ) { throw new UnsupportedOperationException ( ) ; }
public RightMarginRecord clone ( ) { return copy ( ) ; }
public ListTrafficPoliciesResult listTrafficPolicies ( ListTrafficPoliciesRequest request ) { request = beforeClientExecution ( request ) ; return executeListTrafficPolicies ( request ) ; }
public DeleteKeyPairRequest ( String keyName ) { setKeyName ( keyName ) ; }
public void setElement ( int index , byte [ ] element ) { if ( emptyComplexPart ) { return ; } int actualSize = getActualSizeOfElements ( getSizeOfElements ( ) ) ; System . arraycopy ( element , 0 , getComplexData ( ) , FIXED_SIZE + index * actualSize , actualSize ) ; }
public FieldDoc ( int doc , float score , Object [ ] fields ) { super ( doc , score ) ; this . fields = fields ; }
public TreeFilter clone ( ) { return new Binary ( a . clone ( ) , b . clone ( ) ) ; }
public void fillTo ( int toIndex , long val ) { while ( count < toIndex ) add ( val ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = byte0 >>> 5 ; values [ valuesOffset ++ ] = ( byte0 >>> 2 ) & 7 ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte0 & 3 ) << 1 ) | ( byte1 >>> 7 ) ; values [ valuesOffset ++ ] = ( byte1 >>> 4 ) & 7 ; values [ valuesOffset ++ ] = ( byte1 >>> 1 ) & 7 ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 1 ) << 2 ) | ( byte2 >>> 6 ) ; values [ valuesOffset ++ ] = ( byte2 >>> 3 ) & 7 ; values [ valuesOffset ++ ] = byte2 & 7 ; } }
public RawText getResultContents ( ) { return resultContents ; }
public void setMaxShingleSize ( int maxShingleSize ) { if ( maxShingleSize < 2 ) { throw new IllegalArgumentException ( " Max ▁ shingle ▁ size ▁ must ▁ be ▁ >= ▁ 2 " ) ; } this . maxShingleSize = maxShingleSize ; }
public FieldInfo ( RecordInputStream in ) { _isxvi = in . readShort ( ) ; _isxvd = in . readShort ( ) ; _idObj = in . readShort ( ) ; }
public DescribeDBEngineVersionsResult describeDBEngineVersions ( DescribeDBEngineVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBEngineVersions ( request ) ; }
public DBSnapshot copyDBSnapshot ( CopyDBSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCopyDBSnapshot ( request ) ; }
public DFA ( DecisionState atnStartState , int decision ) { this . atnStartState = atnStartState ; this . decision = decision ; boolean precedenceDfa = false ; if ( atnStartState instanceof StarLoopEntryState ) { if ( ( ( StarLoopEntryState ) atnStartState ) . isPrecedenceDecision ) { precedenceDfa = true ; DFAState precedenceState = new DFAState ( new ATNConfigSet ( ) ) ; precedenceState . edges = new DFAState [ 0 ] ; precedenceState . isAcceptState = false ; precedenceState . requiresFullContext = false ; this . s0 = precedenceState ; } } this . precedenceDfa = precedenceDfa ; }
public QueryParserTokenManager ( CharStream stream ) { input_stream = stream ; }
public String toString ( ) { return " < group > " + " \ n " + getChild ( ) . toString ( ) + " \ n </ group > " ; }
public UpdateResolverRuleResult updateResolverRule ( UpdateResolverRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateResolverRule ( request ) ; }
public int compareTo ( BytesRef other ) { return Arrays . compareUnsigned ( this . bytes , this . offset , this . offset + this . length , other . bytes , other . offset , other . offset + other . length ) ; }
public void rewind ( ) { ns . removeAllElements ( ) ; ks . setLength ( 0 ) ; cur = root ; run ( ) ; }
public ModifyWorkspaceAccessPropertiesResult modifyWorkspaceAccessProperties ( ModifyWorkspaceAccessPropertiesRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyWorkspaceAccessProperties ( request ) ; }
public DescribeFleetAttributesResult describeFleetAttributes ( DescribeFleetAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeFleetAttributes ( request ) ; }
public CreateBuildResult createBuild ( CreateBuildRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateBuild ( request ) ; }
public static FloatBuffer wrap ( float [ ] array , int start , int floatCount ) { Arrays . checkOffsetAndCount ( array . length , start , floatCount ) ; FloatBuffer buf = new ReadWriteFloatArrayBuffer ( array ) ; buf . position = start ; buf . limit = start + floatCount ; return buf ; }
public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; DateFormatTokenizer tokenizer = new DateFormatTokenizer ( format ) ; String token ; while ( ( token = tokenizer . getNextToken ( ) ) != null ) { if ( result . length ( ) > 0 ) { result . append ( " , ▁ " ) ; } result . append ( " [ " ) . append ( token ) . append ( " ] " ) ; } return result . toString ( ) ; }
public byte readByte ( ) { return data [ pos ++ ] ; }
public CreateDatasetResult createDataset ( CreateDatasetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDataset ( request ) ; }
public BytesRef next ( ) { termOrd ++ ; if ( termOrd < terms . length ) { return setTerm ( ) ; } else { return null ; } }
public static FontCharset valueOf ( int value ) { return ( value < 0 || value >= _table . length ) ? null : _table [ value ] ; }
public static String escape ( String s ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == ' \\ ' ▁ || ▁ c ▁ == ▁ ' + ' ▁ || ▁ c ▁ == ▁ ' - ' ▁ || ▁ c ▁ == ▁ ' ! ' ▁ || ▁ c ▁ == ▁ ' ( ' ▁ || ▁ c ▁ == ▁ ' ) ' || ▁ c ▁ == ▁ ' : ' ▁ || ▁ c ▁ == ▁ ' ^ ' ▁ || ▁ c ▁ == ▁ ' [ ' ▁ || ▁ c ▁ == ▁ ' ] ' ▁ || ▁ c ▁ == ▁ ' \ " ' || ▁ c ▁ == ▁ ' { ' ▁ || ▁ c ▁ == ▁ ' } ' ▁ || ▁ c ▁ == ▁ ' ~ ' ▁ || ▁ c ▁ == ▁ ' * ' ▁ || ▁ c ▁ == ▁ ' ? ' || ▁ c ▁ == ▁ ' | ' ▁ || ▁ c ▁ == ▁ ' & ' ▁ || ▁ c ▁ == ▁ ' / ' ) ▁ { sb . append ( ' \\ ' ) ; } sb . append ( c ) ; } return sb . toString ( ) ; }
public RejectVpcEndpointConnectionsResult rejectVpcEndpointConnections ( RejectVpcEndpointConnectionsRequest request ) { request = beforeClientExecution ( request ) ; return executeRejectVpcEndpointConnections ( request ) ; }
public V next ( ) { return nextEntry ( ) . value ; }
public ShingleAnalyzerWrapper ( Analyzer delegate , int minShingleSize , int maxShingleSize , String tokenSeparator , boolean outputUnigrams , boolean outputUnigramsIfNoShingles , String fillerToken ) { super ( delegate . getReuseStrategy ( ) ) ; this . delegate = delegate ; if ( maxShingleSize < 2 ) { throw new IllegalArgumentException ( " Max ▁ shingle ▁ size ▁ must ▁ be ▁ >= ▁ 2 " ) ; } this . maxShingleSize = maxShingleSize ; if ( minShingleSize < 2 ) { throw new IllegalArgumentException ( " Min ▁ shingle ▁ size ▁ must ▁ be ▁ >= ▁ 2 " ) ; } if ( minShingleSize > maxShingleSize ) { throw new IllegalArgumentException ( " Min ▁ shingle ▁ size ▁ must ▁ be ▁ <= ▁ max ▁ shingle ▁ size " ) ; } this . minShingleSize = minShingleSize ; this . tokenSeparator = ( tokenSeparator == null ? " " : tokenSeparator ) ; this . outputUnigrams = outputUnigrams ; this . outputUnigramsIfNoShingles = outputUnigramsIfNoShingles ; this . fillerToken = fillerToken ; }
public CreateInterconnectResult createInterconnect ( CreateInterconnectRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateInterconnect ( request ) ; }
public DeleteTrafficMirrorTargetResult deleteTrafficMirrorTarget ( DeleteTrafficMirrorTargetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTrafficMirrorTarget ( request ) ; }
public UpdateMonitoringScheduleResult updateMonitoringSchedule ( UpdateMonitoringScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateMonitoringSchedule ( request ) ; }
public DeleteGatewayGroupResult deleteGatewayGroup ( DeleteGatewayGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteGatewayGroup ( request ) ; }
public ListStackSetOperationsResult listStackSetOperations ( ListStackSetOperationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListStackSetOperations ( request ) ; }
public ListOfOutputs ( Outputs < T > outputs ) { this . outputs = outputs ; }
public ExceedsLimit ( long limit , long size ) { this . limit = limit ; this . size = size ; }
public GetIndustryInfoRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " GetIndustryInfo " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public CreateVpnGatewayRequest ( String type ) { setType ( type ) ; }
public int compareTo ( PointTransitions other ) { return point - other . point ; }
public DeleteQueuedReservedInstancesResult deleteQueuedReservedInstances ( DeleteQueuedReservedInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteQueuedReservedInstances ( request ) ; }
public static final AbbreviatedObjectId fromString ( String str ) { if ( str . length ( ) > Constants . OBJECT_ID_STRING_LENGTH ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . invalidId , str ) ) ; final byte [ ] b = Constants . encodeASCII ( str ) ; return fromHexString ( b , 0 , b . length ) ; }
public final int getByte ( int index ) { int w ; switch ( index >> 2 ) { case 0 : w = w1 ; break ; case 1 : w = w2 ; break ; case 2 : w = w3 ; break ; case 3 : w = w4 ; break ; case 4 : w = w5 ; break ; default : throw new ArrayIndexOutOfBoundsException ( index ) ; } return ( w >>> ( 8 * ( 3 - ( index & 3 ) ) ) ) & 0xff ; }
public SpanFirstBuilder ( SpanQueryBuilder factory ) { this . factory = factory ; }
public DescribeInstancesResult describeInstances ( DescribeInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeInstances ( request ) ; }
public DescribeProjectsResult describeProjects ( DescribeProjectsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeProjects ( request ) ; }
public static String toHexString ( String s ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( i > 0 ) { sb . append ( ' ▁ ' ) ; } if ( ch < 128 ) { sb . append ( ch ) ; } else { if ( ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END ) { sb . append ( " H : " ) ; } else if ( ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END ) { sb . append ( " L : " ) ; } else if ( ch > UNI_SUR_LOW_END ) { if ( ch == 0xffff ) { sb . append ( " F : " ) ; } else { sb . append ( " E : " ) ; } } sb . append ( " 0x " ) . append ( Integer . toHexString ( ch ) ) ; } } return sb . toString ( ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { double result ; try { double d0 = NumericFunction . singleOperandEvaluate ( arg0 , srcRowIndex , srcColumnIndex ) ; result = Math . log ( d0 ) / LOG_10_TO_BASE_e ; NumericFunction . checkValue ( result ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return new NumberEval ( result ) ; }
public long byteCount ( int packedIntsVersion , int valueCount , int bitsPerValue ) { assert bitsPerValue >= 0 && bitsPerValue <= 64 : bitsPerValue ; return 8L * longCount ( packedIntsVersion , valueCount , bitsPerValue ) ; }
public Policy ( String id , Collection < Statement > statements ) { this ( id ) ; setStatements ( statements ) ; }
public FunctionQuery ( ValueSource func ) { this . func = func ; }
public UpdateGameServerResult updateGameServer ( UpdateGameServerRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateGameServer ( request ) ; }
public GetDetectorVersionResult getDetectorVersion ( GetDetectorVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDetectorVersion ( request ) ; }
public void addField ( String fieldName , String text , Analyzer analyzer ) { if ( fieldName == null ) throw new IllegalArgumentException ( " fieldName ▁ must ▁ not ▁ be ▁ null " ) ; if ( text == null ) throw new IllegalArgumentException ( " text ▁ must ▁ not ▁ be ▁ null " ) ; if ( analyzer == null ) throw new IllegalArgumentException ( " analyzer ▁ must ▁ not ▁ be ▁ null " ) ; TokenStream stream = analyzer . tokenStream ( fieldName , text ) ; storeTerms ( getInfo ( fieldName , defaultFieldType ) , stream , analyzer . getPositionIncrementGap ( fieldName ) , analyzer . getOffsetGap ( fieldName ) ) ; }
public boolean isEnabled ( String component ) { return false ; }
public long next ( ) { final long idx = 1 + ( ord / indexInterval ) ; if ( idx >= fieldIndex . numIndexTerms ) { return - 1 ; } ord += indexInterval ; final long offset = fieldIndex . termOffsets . get ( idx ) ; final int length = ( int ) ( fieldIndex . termOffsets . get ( 1 + idx ) - offset ) ; termBytesReader . fillSlice ( term , fieldIndex . termBytesStart + offset , length ) ; return fieldIndex . termsStart + fieldIndex . termsDictOffsets . get ( idx ) ; }
public DisassociateMemberFromGroupResult disassociateMemberFromGroup ( DisassociateMemberFromGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateMemberFromGroup ( request ) ; }
public UnmergedPathException ( DirCacheEntry dce ) { super ( MessageFormat . format ( JGitText . get ( ) . unmergedPath , dce . getPathString ( ) ) ) ; entry = dce ; }
public Name ( NameRecord nameRecord , int index ) { _nameRecord = nameRecord ; _index = index ; }
public void add ( ET object ) { if ( expectedModCount == list . modCount ) { Link < ET > next = link . next ; Link < ET > newLink = new Link < ET > ( object , link , next ) ; link . next = newLink ; next . previous = newLink ; link = newLink ; lastLink = null ; pos ++ ; expectedModCount ++ ; list . size ++ ; list . modCount ++ ; } else { throw new ConcurrentModificationException ( ) ; } }
public final ByteOrder order ( ) { return order ; }
public ValueFiller getValueFiller ( ) { return new ValueFiller ( ) ; }
public SubmoduleInitCommand addPath ( String path ) { paths . add ( path ) ; return this ; }
public DeleteInterconnectResult deleteInterconnect ( DeleteInterconnectRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteInterconnect ( request ) ; }
public Credential ( String keyId , String secret ) { this . accessKeyId = keyId ; this . accessSecret = secret ; this . refreshDate = new Date ( ) ; }
public DeleteRepoWebhookRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " DeleteRepoWebhook " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / webhooks / [ WebhookId ] " ) ; setMethod ( MethodType . DELETE ) ; }
public DeleteDeviceResult deleteDevice ( DeleteDeviceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDevice ( request ) ; }
public CreateEventBusResult createEventBus ( CreateEventBusRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateEventBus ( request ) ; }
public boolean isEnabled ( ) { return enabled ; }
public boolean isSigned ( ) { return signed ; }
public DeleteRuleVersionResult deleteRuleVersion ( DeleteRuleVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRuleVersion ( request ) ; }
public long seek ( long ord ) { throw new UnsupportedOperationException ( ) ; }
public CreateAppCookieStickinessPolicyRequest ( String loadBalancerName , String policyName , String cookieName ) { setLoadBalancerName ( loadBalancerName ) ; setPolicyName ( policyName ) ; setCookieName ( cookieName ) ; }
public BlameCommand setDiffAlgorithm ( DiffAlgorithm diffAlgorithm ) { this . diffAlgorithm = diffAlgorithm ; return this ; }
public DisassociateSkillFromUsersResult disassociateSkillFromUsers ( DisassociateSkillFromUsersRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateSkillFromUsers ( request ) ; }
public PatchIdDiffFormatter ( ) { super ( new DigestOutputStream ( NullOutputStream . INSTANCE , Constants . newMessageDigest ( ) ) ) ; digest = ( ( DigestOutputStream ) getOutputStream ( ) ) . getMessageDigest ( ) ; }
public SendMessageResult sendMessage ( SendMessageRequest request ) { request = beforeClientExecution ( request ) ; return executeSendMessage ( request ) ; }
public static ParsePathType pathType ( Path f ) { int pathLength = 0 ; while ( f != null && f . getFileName ( ) != null && ++ pathLength < MAX_PATH_LENGTH ) { ParsePathType ppt = pathName2Type . get ( f . getFileName ( ) . toString ( ) . toUpperCase ( Locale . ROOT ) ) ; if ( ppt != null ) { return ppt ; } f = f . getParent ( ) ; } return DEFAULT_PATH_TYPE ; }
public static long estimateIndexSize ( int sourceLength ) { return sourceLength + ( sourceLength * 3 / 4 ) ; }
public UpdateDashboardPermissionsResult updateDashboardPermissions ( UpdateDashboardPermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDashboardPermissions ( request ) ; }
public String formatAsString ( ) { switch ( _cellType ) { case NUMERIC : return String . valueOf ( _numberValue ) ; case STRING : return ' " ' ▁ + ▁ □ textValue ▁ + ▁ ' " ' ; case BOOLEAN : return _booleanValue ? " TRUE " : " FALSE " ; case ERROR : return ErrorEval . getText ( _errorCode ) ; default : return " < error ▁ unexpected ▁ cell ▁ type ▁ " + _cellType + " > " ; } }
public final void add ( RevFlagSet set ) { flags |= set . mask ; }
public URIish setHost ( String n ) { final URIish r = new URIish ( this ) ; r . host = n ; return r ; }
public void clearFormulaEntry ( ) { CellCacheEntry [ ] usedCells = _sensitiveInputCells ; if ( usedCells != null ) { for ( int i = usedCells . length - 1 ; i >= 0 ; i -- ) { usedCells [ i ] . clearConsumingCell ( this ) ; } } _sensitiveInputCells = null ; clearValue ( ) ; }
public GetDiskSnapshotResult getDiskSnapshot ( GetDiskSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDiskSnapshot ( request ) ; }
public DescribeIpv6PoolsResult describeIpv6Pools ( DescribeIpv6PoolsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeIpv6Pools ( request ) ; }
public UpdateDetectorResult updateDetector ( UpdateDetectorRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDetector ( request ) ; }
public DeleteInstanceResult deleteInstance ( DeleteInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteInstance ( request ) ; }
public ListThreatIntelSetsResult listThreatIntelSets ( ListThreatIntelSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListThreatIntelSets ( request ) ; }
public ExportClientVpnClientConfigurationResult exportClientVpnClientConfiguration ( ExportClientVpnClientConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeExportClientVpnClientConfiguration ( request ) ; }
public float currentScore ( int docId , String field , int start , int end , int numPayloadsSeen , float currentScore , float currentPayloadScore ) { if ( numPayloadsSeen == 0 ) { return currentPayloadScore ; } else { return Math . max ( currentPayloadScore , currentScore ) ; } }
public CreateDBParameterGroupRequest ( String dBParameterGroupName , String dBParameterGroupFamily , String description ) { setDBParameterGroupName ( dBParameterGroupName ) ; setDBParameterGroupFamily ( dBParameterGroupFamily ) ; setDescription ( description ) ; }
public void add ( int forwardId , int backwardId , int cost ) { int offset = ( backwardId * forwardSize + forwardId ) * 2 ; costs . putShort ( offset , ( short ) cost ) ; }
public boolean isPeeled ( ) { return true ; }
public CreateTransitVirtualInterfaceResult createTransitVirtualInterface ( CreateTransitVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTransitVirtualInterface ( request ) ; }
public BatchDetectSentimentResult batchDetectSentiment ( BatchDetectSentimentRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDetectSentiment ( request ) ; }
public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof Interval ) ) { return false ; } Interval other = ( Interval ) o ; return this . a == other . a && this . b == other . b ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ USESELFS ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . options ▁ = ▁ " ) . append ( HexDump . shortToHex ( _options ) ) . append ( " \ n " ) ; buffer . append ( " [ / USESELFS ] \ n " ) ; return buffer . toString ( ) ; }
public SmallDocSet union ( SmallDocSet other ) { SmallDocSet bigger ; SmallDocSet smaller ; if ( other . intSet . size ( ) > this . intSet . size ( ) ) { bigger = other ; smaller = this ; } else { bigger = this ; smaller = other ; } for ( int v : smaller . intSet . keys ) { if ( v == smaller . intSet . emptyVal ) continue ; bigger . set ( v ) ; } return bigger ; }
public boolean equals ( Object o ) { if ( o instanceof Edit ) { final Edit e = ( Edit ) o ; return this . beginA == e . beginA && this . endA == e . endA && this . beginB == e . beginB && this . endB == e . endB ; } return false ; }
public int getBigFileThreshold ( ) { return bigFileThreshold ; }
public String toString ( ) { final StringBuilder r = new StringBuilder ( ) ; r . append ( getSeverity ( ) . name ( ) . toLowerCase ( Locale . ROOT ) ) ; r . append ( " : ▁ at ▁ offset ▁ " ) ; r . append ( getOffset ( ) ) ; r . append ( " : ▁ " ) ; r . append ( getMessage ( ) ) ; r . append ( " \ n " ) ; r . append ( " ▁ ▁ in ▁ " ) ; r . append ( getLineText ( ) ) ; return r . toString ( ) ; }
public IntBuffer slice ( ) { return new ReadWriteIntArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public DeleteApplicationResult deleteApplication ( DeleteApplicationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApplication ( request ) ; }
public TokenOffsetPayloadTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public boolean equals ( Object o ) { if ( this . getClass ( ) != o . getClass ( ) ) return false ; MultiFunction other = ( MultiFunction ) o ; return this . sources . equals ( other . sources ) ; }
public SpanQuery getSpanQuery ( Element e ) throws ParserException { SpanQueryBuilder builder = builders . get ( e . getNodeName ( ) ) ; if ( builder == null ) { throw new ParserException ( " No ▁ SpanQueryObjectBuilder ▁ defined ▁ for ▁ node ▁ " + e . getNodeName ( ) ) ; } return builder . getSpanQuery ( e ) ; }
public void incRef ( ) { final int rc = refCount . incrementAndGet ( ) ; assert rc > 1 : " seg = " + info ; }
public String formula ( ) { return _formula ; }
public T removeTop ( ) { T currentTop = top ; if ( iter . hasNext ( ) ) { top = iter . next ( ) ; } else { top = null ; } return currentTop ; }
public ObjectId getExpectedOldObjectId ( ) { return expValue ; }
public DefaultPassageFormatter ( String preTag , String postTag , String ellipsis , boolean escape ) { if ( preTag == null || postTag == null || ellipsis == null ) { throw new NullPointerException ( ) ; } this . preTag = preTag ; this . postTag = postTag ; this . ellipsis = ellipsis ; this . escape = escape ; }
public UpdateImagePermissionsResult updateImagePermissions ( UpdateImagePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateImagePermissions ( request ) ; }
public ListCustomVerificationEmailTemplatesResult listCustomVerificationEmailTemplates ( ListCustomVerificationEmailTemplatesRequest request ) { request = beforeClientExecution ( request ) ; return executeListCustomVerificationEmailTemplates ( request ) ; }
public int read ( byte [ ] buffer , int byteOffset , int byteCount ) throws IOException { return IoBridge . read ( fd , buffer , byteOffset , byteCount ) ; }
public StringCharacterIterator ( String value , int location ) { string = value ; start = 0 ; end = string . length ( ) ; if ( location < 0 || location > end ) { throw new IllegalArgumentException ( ) ; } offset = location ; }
public DeleteQueryLoggingConfigResult deleteQueryLoggingConfig ( DeleteQueryLoggingConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteQueryLoggingConfig ( request ) ; }
public InvalidPatternException ( String message , String pattern ) { super ( message ) ; this . pattern = pattern ; }
public int resolveNameXIx ( int refIndex , int definedNameIndex ) { int extBookIndex = _externSheetRecord . getExtbookIndexFromRefIndex ( refIndex ) ; return _externalBookBlocks [ extBookIndex ] . getNameIx ( definedNameIndex ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; FuzzyQuery other = ( FuzzyQuery ) obj ; if ( maxEdits != other . maxEdits ) return false ; if ( prefixLength != other . prefixLength ) return false ; if ( maxExpansions != other . maxExpansions ) return false ; if ( transpositions != other . transpositions ) return false ; if ( term == null ) { if ( other . term != null ) return false ; } else if ( ! term . equals ( other . term ) ) return false ; return true ; }
public Term getLuceneTerm ( String fieldName ) { return new Term ( fieldName , getTermText ( ) ) ; }
public static MessageDigest newMessageDigest ( ) { try { return MessageDigest . getInstance ( LONG_HASH_FUNCTION ) ; } catch ( NoSuchAlgorithmException nsae ) { throw new RuntimeException ( MessageFormat . format ( LfsText . get ( ) . requiredHashFunctionNotAvailable , LONG_HASH_FUNCTION ) , nsae ) ; } }
public void reset ( ) { synchronized ( lock ) { count = 0 ; } }
public HyphenationTree ( ) { stoplist = new HashMap <> ( 23 ) ; classmap = new TernaryTree ( ) ; vspace = new ByteVector ( ) ; vspace . alloc ( 1 ) ; }
public DescribeCollectionResult describeCollection ( DescribeCollectionRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCollection ( request ) ; }
public synchronized StringBuffer insert ( int index , char [ ] chars ) { insert0 ( index , chars ) ; return this ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 2 ) | ( byte1 >>> 6 ) ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 63 ) << 4 ) | ( byte2 >>> 4 ) ; final long byte3 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte2 & 15 ) << 6 ) | ( byte3 >>> 2 ) ; final long byte4 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte3 & 3 ) << 8 ) | byte4 ; } }
public GetSearchRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetSearch " , " cr " ) ; setUriPattern ( " / search - delete " ) ; setMethod ( MethodType . GET ) ; }
public void consume ( ) { boolean skipEofCheck ; if ( p >= 0 ) { if ( fetchedEOF ) { skipEofCheck = p < tokens . size ( ) - 1 ; } else { skipEofCheck = p < tokens . size ( ) ; } } else { skipEofCheck = false ; } if ( ! skipEofCheck && LA ( 1 ) == EOF ) { throw new IllegalStateException ( " cannot ▁ consume ▁ EOF " ) ; } if ( sync ( p + 1 ) ) { p = adjustSeekIndex ( p + 1 ) ; } }
public CharBlockArray append ( String s ) { int remain = s . length ( ) ; int offset = 0 ; while ( remain > 0 ) { if ( this . current . length == this . blockSize ) { addBlock ( ) ; } int toCopy = remain ; int remainingInBlock = this . blockSize - this . current . length ; if ( remainingInBlock < toCopy ) { toCopy = remainingInBlock ; } s . getChars ( offset , offset + toCopy , this . current . chars , this . current . length ) ; offset += toCopy ; remain -= toCopy ; this . current . length += toCopy ; } this . length += s . length ( ) ; return this ; }
public ConfigureHealthCheckResult configureHealthCheck ( ConfigureHealthCheckRequest request ) { request = beforeClientExecution ( request ) ; return executeConfigureHealthCheck ( request ) ; }
public CommonRoaRequest ( String product ) { super ( product ) ; setSysAcceptFormat ( FormatType . JSON ) ; }
public static int strlen ( char [ ] a ) { return strlen ( a , 0 ) ; }
public void setReaderValue ( Reader value ) { if ( ! ( fieldsData instanceof Reader ) ) { throw new IllegalArgumentException ( " cannot ▁ change ▁ value ▁ type ▁ from ▁ " + fieldsData . getClass ( ) . getSimpleName ( ) + " ▁ to ▁ Reader " ) ; } fieldsData = value ; }
public DeleteUsagePlanResult deleteUsagePlan ( DeleteUsagePlanRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteUsagePlan ( request ) ; }
public DeleteThreatIntelSetResult deleteThreatIntelSet ( DeleteThreatIntelSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteThreatIntelSet ( request ) ; }
public DescribePlacementGroupsResult describePlacementGroups ( DescribePlacementGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribePlacementGroups ( request ) ; }
public EnableAddOnResult enableAddOn ( EnableAddOnRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableAddOn ( request ) ; }
public TreeFilter clone ( ) { final TreeFilter [ ] s = new TreeFilter [ subfilters . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) s [ i ] = subfilters [ i ] . clone ( ) ; return new List ( s ) ; }
public ListTagsForResourceOutput listTagsForResource ( ListTagsForResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeListTagsForResource ( request ) ; }
public WeightedSpanTerm getWeightedSpanTerm ( String token ) { return fieldWeightedSpanTerms . get ( token ) ; }
public Slope ( ) { func = new LinearRegressionFunction ( FUNCTION . SLOPE ) ; }
public String toStringUnquoted ( ) { return getTruncated ( ) ; }
public UpdateSubnetGroupResult updateSubnetGroup ( UpdateSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateSubnetGroup ( request ) ; }
public void remove ( int index ) { checkIndex ( index ) ; _cfHeaders . remove ( index ) ; }
public static long pop_intersect ( long [ ] arr1 , long [ ] arr2 , int wordOffset , int numWords ) { long popCount = 0 ; for ( int i = wordOffset , end = wordOffset + numWords ; i < end ; ++ i ) { popCount += Long . bitCount ( arr1 [ i ] & arr2 [ i ] ) ; } return popCount ; }
public boolean shouldBeRecursive ( ) { return true ; }
public JapaneseBaseFormFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public void visitContainedRecords ( RecordVisitor rv ) { rv . visitRecord ( header ) ; for ( CFRuleBase rule : rules ) { rv . visitRecord ( rule ) ; } }
public void dumpDrawingGroupRecords ( boolean fat ) { DrawingGroupRecord r = ( DrawingGroupRecord ) workbook . findFirstRecordBySid ( DrawingGroupRecord . sid ) ; if ( r == null ) { return ; } r . decode ( ) ; List < EscherRecord > escherRecords = r . getEscherRecords ( ) ; PrintWriter w = new PrintWriter ( new OutputStreamWriter ( System . out , Charset . defaultCharset ( ) ) ) ; for ( EscherRecord escherRecord : escherRecords ) { if ( fat ) { System . out . println ( escherRecord ) ; } else { escherRecord . display ( w , 0 ) ; } } w . flush ( ) ; }
public int getLinesDeleted ( ) { return nDeleted ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . append ( getClass ( ) . getName ( ) ) . append ( " ▁ [ " ) ; sb . append ( _offset ) . append ( " ... " ) . append ( getLastIndex ( ) ) ; sb . append ( " ] " ) ; return sb . toString ( ) ; }
public int [ ] compact ( ) { assert bytesStart != null : " bytesStart ▁ is ▁ null ▁ - ▁ not ▁ initialized " ; int upto = 0 ; for ( int i = 0 ; i < hashSize ; i ++ ) { if ( ids [ i ] != - 1 ) { if ( upto < i ) { ids [ upto ] = ids [ i ] ; ids [ i ] = - 1 ; } upto ++ ; } } assert upto == count ; lastCount = count ; return ids ; }
public AccessKey ( String userName , String accessKeyId , StatusType status , String secretAccessKey ) { setUserName ( userName ) ; setAccessKeyId ( accessKeyId ) ; setStatus ( status . toString ( ) ) ; setSecretAccessKey ( secretAccessKey ) ; }
public GetDomainResult getDomain ( GetDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDomain ( request ) ; }
public ListTypeRegistrationsResult listTypeRegistrations ( ListTypeRegistrationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTypeRegistrations ( request ) ; }
public boolean isSymbolic ( ) { return false ; }
public DeleteTableRequest ( String tableName ) { setTableName ( tableName ) ; }
public UpdateAccountSettingsResult updateAccountSettings ( UpdateAccountSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateAccountSettings ( request ) ; }
public SearcherTracker ( IndexSearcher searcher ) { this . searcher = searcher ; version = ( ( DirectoryReader ) searcher . getIndexReader ( ) ) . getVersion ( ) ; searcher . getIndexReader ( ) . incRef ( ) ; recordTimeSec = System . nanoTime ( ) / NANOS_PER_SEC ; }
public Principal ( String accountId ) { this ( " AWS " , accountId ) ; if ( accountId == null ) { throw new IllegalArgumentException ( " Null ▁ AWS ▁ account ▁ ID ▁ specified " ) ; } }
public V setValue ( V object ) { V result = value ; value = object ; return result ; }
public ListMomentPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListMomentPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public boolean contains ( Object o ) { return map . containsKey ( o ) ; }
public LinearOffsetRange ( int offset , int length ) { if ( length == 0 ) { throw new RuntimeException ( " length ▁ may ▁ not ▁ be ▁ zero " ) ; } _offset = offset ; _length = length ; }
public ListPipelinesResult listPipelines ( ) { return listPipelines ( new ListPipelinesRequest ( ) ) ; }
public static boolean indexExists ( Directory directory ) throws IOException { String [ ] files = directory . listAll ( ) ; String prefix = IndexFileNames . SEGMENTS + " □ " ; for ( String file : files ) { if ( file . startsWith ( prefix ) ) { return true ; } } return false ; }
public DisassociateFromMasterAccountResult disassociateFromMasterAccount ( DisassociateFromMasterAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateFromMasterAccount ( request ) ; }
public GetVoiceTemplateResult getVoiceTemplate ( GetVoiceTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVoiceTemplate ( request ) ; }
public long ramBytesUsed ( ) { return RamUsageEstimator . sizeOf ( filter . getBits ( ) ) ; }
public RejectInvitationResult rejectInvitation ( RejectInvitationRequest request ) { request = beforeClientExecution ( request ) ; return executeRejectInvitation ( request ) ; }
public RejectQualificationRequestResult rejectQualificationRequest ( RejectQualificationRequestRequest request ) { request = beforeClientExecution ( request ) ; return executeRejectQualificationRequest ( request ) ; }
public final long [ ] array ( ) { return protectedArray ( ) ; }
public void writeChars ( String value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeChars ( value ) ; }
public void finish ( FieldInfos fis , int numDocs ) throws IOException { if ( numDocsWritten != numDocs ) { throw new RuntimeException ( " mergeVectors ▁ produced ▁ an ▁ invalid ▁ result : ▁ mergedDocs ▁ is ▁ " + numDocs + " ▁ but ▁ vec ▁ numDocs ▁ is ▁ " + numDocsWritten + " ▁ file = " + out . toString ( ) + " ; ▁ now ▁ aborting ▁ this ▁ merge ▁ to ▁ prevent ▁ index ▁ corruption " ) ; } write ( END ) ; newLine ( ) ; SimpleTextUtil . writeChecksum ( out , scratch ) ; }
public void readBytes ( byte [ ] b , int offset , int len ) throws IOException { while ( len > 0 ) { final int cnt = is . read ( b , offset , len ) ; if ( cnt < 0 ) { throw new EOFException ( ) ; } len -= cnt ; offset += cnt ; } }
public long ramBytesUsed ( ) { long ramBytesUsed = BASE_RAM_BYTES_USED ; ramBytesUsed += fields . size ( ) * 2L * RamUsageEstimator . NUM_BYTES_OBJECT_REF ; ramBytesUsed += formats . size ( ) * 2L * RamUsageEstimator . NUM_BYTES_OBJECT_REF ; for ( Map . Entry < String , FieldsProducer > entry : formats . entrySet ( ) ) { ramBytesUsed += entry . getValue ( ) . ramBytesUsed ( ) ; } return ramBytesUsed ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( null == obj || getClass ( ) != obj . getClass ( ) ) return false ; JaroWinklerDistance o = ( JaroWinklerDistance ) obj ; return ( Float . floatToIntBits ( o . threshold ) == Float . floatToIntBits ( this . threshold ) ) ; }
public BatchRefUpdate addCommand ( ReceiveCommand ... cmd ) { return addCommand ( Arrays . asList ( cmd ) ) ; }
public void write ( byte [ ] buf , int off , int len ) throws IOException { try { beginWrite ( ) ; dst . write ( buf , off , len ) ; } catch ( InterruptedIOException e ) { throw writeTimedOut ( e ) ; } finally { endWrite ( ) ; } }
public DeregisterGameServerResult deregisterGameServer ( DeregisterGameServerRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterGameServer ( request ) ; }
public void write ( byte [ ] b ) { try { super . write ( b ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public boolean matches ( int symbol , int minVocabSymbol , int maxVocabSymbol ) { return symbol >= from && symbol <= to ; }
public void finish ( FieldInfos fis , int numDocs ) throws IOException { if ( numBufferedDocs > 0 ) { flush ( ) ; numDirtyChunks ++ ; } else { assert bufferedDocs . size ( ) == 0 ; } if ( docBase != numDocs ) { throw new RuntimeException ( " Wrote ▁ " + docBase + " ▁ docs , ▁ finish ▁ called ▁ with ▁ numDocs = " + numDocs ) ; } indexWriter . finish ( numDocs , fieldsStream . getFilePointer ( ) ) ; fieldsStream . writeVLong ( numChunks ) ; fieldsStream . writeVLong ( numDirtyChunks ) ; CodecUtil . writeFooter ( fieldsStream ) ; assert bufferedDocs . size ( ) == 0 ; }
public Iterator < String > iterator ( ) { final Iterator < String > i = names . values ( ) . iterator ( ) ; return new Iterator < String > ( ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ DEFAULTCOLWIDTH ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . colwidth ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getColWidth ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / DEFAULTCOLWIDTH ] \ n " ) ; return buffer . toString ( ) ; }
public DataValidityTable ( RecordStream rs ) { _headerRec = ( DVALRecord ) rs . getNext ( ) ; List < DVRecord > temp = new ArrayList <> ( ) ; while ( rs . peekNextClass ( ) == DVRecord . class ) { temp . add ( ( DVRecord ) rs . getNext ( ) ) ; } _validationList = temp ; }
public DeleteRoomMembershipResult deleteRoomMembership ( DeleteRoomMembershipRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRoomMembership ( request ) ; }
public QueryParserTokenManager ( CharStream stream , int lexState ) { this ( stream ) ; SwitchTo ( lexState ) ; }
public RebootDBInstanceRequest ( String dBInstanceIdentifier ) { setDBInstanceIdentifier ( dBInstanceIdentifier ) ; }
public CreateAutoScalingGroupResult createAutoScalingGroup ( CreateAutoScalingGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAutoScalingGroup ( request ) ; }
public K floorKey ( K key ) { Entry < K , V > entry = findBounded ( key , FLOOR ) ; return entry != null ? entry . getKey ( ) : null ; }
public boolean include ( RevWalk walker , RevCommit c ) { return true ; }
public boolean isValidating ( ) { return getFeature ( XmlPullParser . FEATURE_VALIDATION ) ; }
public synchronized void write ( int oneByte ) { if ( out == null ) { setError ( ) ; return ; } try { out . write ( oneByte ) ; int b = oneByte & 0xFF ; boolean isNewline = b == 0x0A || b == 0x15 ; if ( autoFlush && isNewline ) { flush ( ) ; } } catch ( IOException e ) { setError ( ) ; } }
public UpdateScalingParametersResult updateScalingParameters ( UpdateScalingParametersRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateScalingParameters ( request ) ; }
public ModifyDBClusterParameterGroupResult modifyDBClusterParameterGroup ( ModifyDBClusterParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBClusterParameterGroup ( request ) ; }
public GetOperationsForResourceResult getOperationsForResource ( GetOperationsForResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeGetOperationsForResource ( request ) ; }
public NLPTokenizerOp ( TokenizerModel model ) { tokenizer = new TokenizerME ( model ) ; }
public StartImageScanRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " StartImageScan " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / tags / [ Tag ] / scan " ) ; setMethod ( MethodType . PUT ) ; }
public UpdateFleetResult updateFleet ( UpdateFleetRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateFleet ( request ) ; }
public Editable newEditable ( CharSequence source ) { return new CalculatorEditable ( source , mLogic ) ; }
public static TreeFilter createFromStrings ( String ... paths ) { if ( paths . length == 0 ) throw new IllegalArgumentException ( JGitText . get ( ) . atLeastOnePathIsRequired ) ; final int length = paths . length ; final PathFilter [ ] p = new PathFilter [ length ] ; for ( int i = 0 ; i < length ; i ++ ) p [ i ] = PathFilter . create ( paths [ i ] ) ; return create ( p ) ; }
public DescribeHostedConnectionsResult describeHostedConnections ( DescribeHostedConnectionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeHostedConnections ( request ) ; }
public RejectTransitGatewayPeeringAttachmentResult rejectTransitGatewayPeeringAttachment ( RejectTransitGatewayPeeringAttachmentRequest request ) { request = beforeClientExecution ( request ) ; return executeRejectTransitGatewayPeeringAttachment ( request ) ; }
public static double toPoints ( long emu ) { return ( double ) emu / EMU_PER_POINT ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { return arg1 ; }
public final BytesRef getBinaryValue ( String name ) { for ( IndexableField field : fields ) { if ( field . name ( ) . equals ( name ) ) { final BytesRef bytes = field . binaryValue ( ) ; if ( bytes != null ) { return bytes ; } } } return null ; }
public CRNBlock ( RecordStream rs ) { _countRecord = ( CRNCountRecord ) rs . getNext ( ) ; int nCRNs = _countRecord . getNumberOfCRNs ( ) ; CRNRecord [ ] crns = new CRNRecord [ nCRNs ] ; for ( int i = 0 ; i < crns . length ; i ++ ) { crns [ i ] = ( CRNRecord ) rs . getNext ( ) ; } _crns = crns ; }
public int get ( int index , long [ ] arr , int off , int len ) { return current . get ( index , arr , off , len ) ; }
public LooseRef peel ( ObjectIdRef newLeaf ) { return this ; }
public UpdateModelVersionResult updateModelVersion ( UpdateModelVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateModelVersion ( request ) ; }
public Builder ( ) { PositiveIntOutputs outputs = PositiveIntOutputs . getSingleton ( ) ; fstCompiler = new FSTCompiler <> ( FST . INPUT_TYPE . BYTE1 , outputs ) ; scratchInts = new IntsRefBuilder ( ) ; }
public boolean stem ( ) { int v_1 = cursor ; r_mark_regions ( ) ; cursor = v_1 ; limit_backward = cursor ; cursor = limit ; int v_2 = limit - cursor ; r_main_suffix ( ) ; cursor = limit - v_2 ; int v_3 = limit - cursor ; r_consonant_pair ( ) ; cursor = limit - v_3 ; int v_4 = limit - cursor ; r_other_suffix ( ) ; cursor = limit - v_4 ; cursor = limit_backward ; return true ; }
public int describeContents ( ) { return 0 ; }
public FetchConnection openFetch ( ) throws TransportException { if ( src == null ) throw new TransportException ( uri , JGitText . get ( ) . onlyOneFetchSupported ) ; try { return new BundleFetchConnection ( this , src ) ; } finally { src = null ; } }
public DeleteWorkGroupResult deleteWorkGroup ( DeleteWorkGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteWorkGroup ( request ) ; }
public GetApiResult getApi ( GetApiRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApi ( request ) ; }
public LongBuffer slice ( ) { return new ReadOnlyLongArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public String toString ( ) { String opName = getClass ( ) . getName ( ) ; int index = opName . indexOf ( ' $ ' ) ; opName = opName . substring ( index + 1 , opName . length ( ) ) ; return " < " + opName + " @ " + tokens . get ( index ) + " :\ " " + text + " \ " > " ; }
public String toString ( ) { return " Action [ " + token + " ] " ; }
public static EvaluationException invalidRef ( ) { return new EvaluationException ( ErrorEval . REF_INVALID ) ; }
public Iterator < Entry > getEntries ( ) { return new FilteringIterator ( ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " ▁ [ FUTURE ▁ HEADER ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ Type ▁ " + recordType ) ; buffer . append ( " ▁ ▁ ▁ Flags ▁ " + grbitFrt ) ; buffer . append ( " ▁ [ / FUTURE ▁ HEADER ] \ n " ) ; return buffer . toString ( ) ; }
public void copy ( MutableValue source ) { MutableValueStr s = ( MutableValueStr ) source ; exists = s . exists ; value . copyBytes ( s . value ) ; }
public ReaderSlice ( int start , int length , int readerIndex ) { this . start = start ; this . length = length ; this . readerIndex = readerIndex ; }
public AddTagsResult addTags ( AddTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeAddTags ( request ) ; }
public static URI create ( String uri ) { try { return new URI ( uri ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( e . getMessage ( ) ) ; } }
public UpdateConfigurationSetTrackingOptionsResult updateConfigurationSetTrackingOptions ( UpdateConfigurationSetTrackingOptionsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateConfigurationSetTrackingOptions ( request ) ; }
public void recycleByteBlocks ( byte [ ] [ ] blocks , int start , int end ) { bytesUsed . addAndGet ( - ( ( end - start ) * blockSize ) ) ; for ( int i = start ; i < end ; i ++ ) { blocks [ i ] = null ; } }
public DoubleBuffer compact ( ) { throw new ReadOnlyBufferException ( ) ; }
public GetVoiceConnectorStreamingConfigurationResult getVoiceConnectorStreamingConfiguration ( GetVoiceConnectorStreamingConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVoiceConnectorStreamingConfiguration ( request ) ; }
public boolean hasNext ( ) { return pos + 1 < size ( ) ; }
public double getRKNumberAt ( int coffset ) { return RKUtil . decodeNumber ( field_3_rks [ coffset ] . rk ) ; }
public ReimportApiResult reimportApi ( ReimportApiRequest request ) { request = beforeClientExecution ( request ) ; return executeReimportApi ( request ) ; }
public boolean hasNext ( ) { return link . previous != list . voidLink ; }
public void fill ( BytesRef b , long start ) { final int index = ( int ) ( start >> blockBits ) ; final int offset = ( int ) ( start & blockMask ) ; final byte [ ] block = b . bytes = blocks [ index ] ; if ( ( block [ offset ] & 128 ) == 0 ) { b . length = block [ offset ] ; b . offset = offset + 1 ; } else { b . length = ( ( block [ offset ] & 0x7f ) << 8 ) | ( block [ 1 + offset ] & 0xff ) ; b . offset = offset + 2 ; assert b . length > 0 ; } }
public void trimToSize ( ) { if ( n < array . length ) { byte [ ] aux = new byte [ n ] ; System . arraycopy ( array , 0 , aux , 0 , n ) ; array = aux ; } }
public SubmoduleUpdateCommand submoduleUpdate ( ) { return new SubmoduleUpdateCommand ( repo ) ; }
public static ShortBuffer wrap ( short [ ] array , int start , int shortCount ) { Arrays . checkOffsetAndCount ( array . length , start , shortCount ) ; ShortBuffer buf = new ReadWriteShortArrayBuffer ( array ) ; buf . position = start ; buf . limit = start + shortCount ; return buf ; }
public GetVpcLinksResult getVpcLinks ( GetVpcLinksRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVpcLinks ( request ) ; }
public RemoveResourcePermissionResult removeResourcePermission ( RemoveResourcePermissionRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveResourcePermission ( request ) ; }
public ListIndexResult listIndex ( ListIndexRequest request ) { request = beforeClientExecution ( request ) ; return executeListIndex ( request ) ; }
public List < Integer > toList ( ) { List < Integer > values = new ArrayList < Integer > ( ) ; int n = intervals . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Interval I = intervals . get ( i ) ; int a = I . a ; int b = I . b ; for ( int v = a ; v <= b ; v ++ ) { values . add ( v ) ; } } return values ; }
public CreateCustomerGatewayRequest ( GatewayType type , String publicIp , Integer bgpAsn ) { setType ( type . toString ( ) ) ; setPublicIp ( publicIp ) ; setBgpAsn ( bgpAsn ) ; }
public int getWeekNo ( Calendar cal , int weekStartOn ) { if ( weekStartOn == 1 ) { cal . setFirstDayOfWeek ( Calendar . SUNDAY ) ; } else { cal . setFirstDayOfWeek ( Calendar . MONDAY ) ; } return cal . get ( Calendar . WEEK_OF_YEAR ) ; }
public String toString ( ) { String s = " o : " + offset + " ▁ p : " + position + " ▁ c : " + count ; if ( rptGroup >= 0 ) { s += " ▁ rpt : " + rptGroup + " , i " + rptInd ; } return s ; }
@ Override public ListIterator < E > listIterator ( ) { return listIterator ( 0 ) ; }
public GetUserEndpointsResult getUserEndpoints ( GetUserEndpointsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetUserEndpoints ( request ) ; }
public UAX29URLEmailTokenizerImpl ( java . io . Reader in ) { this . zzReader = in ; }
public ResetCommand addPath ( String path ) { if ( mode != null ) throw new JGitInternalException ( MessageFormat . format ( JGitText . get ( ) . illegalCombinationOfArguments , " < paths > ... " , " [ -- mixed ▁ | ▁ -- soft ▁ | ▁ -- hard ] " ) ) ; filepaths . add ( path ) ; return this ; }
public org . apache . poi . hssf . record . Record findNextRecordBySid ( short sid , int pos ) { int matches = 0 ; for ( org . apache . poi . hssf . record . Record record : records . getRecords ( ) ) { if ( record . getSid ( ) == sid && matches ++ == pos ) { return record ; } } return null ; }
public int [ ] toArray ( ) { return toIntegerList ( ) . toArray ( ) ; }
public GetDomainNamesResult getDomainNames ( GetDomainNamesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDomainNames ( request ) ; }
public UpdateTemplateAliasResult updateTemplateAlias ( UpdateTemplateAliasRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateTemplateAlias ( request ) ; }
public String getReceivePack ( ) { return receivePack ; }
public synchronized Set < K > keySet ( ) { Set < K > ks = keySet ; return ( ks != null ) ? ks : ( keySet = new KeySet ( ) ) ; }
public AssociateAddressRequest ( String instanceId , String publicIp ) { setInstanceId ( instanceId ) ; setPublicIp ( publicIp ) ; }
public static CharBuffer wrap ( CharSequence chseq ) { return new CharSequenceAdapter ( chseq ) ; }
public void reset ( ) { reset ( true , true ) ; }
public static double nChooseK ( int n , int k ) { double d = 1 ; if ( n < 0 || k < 0 || n < k ) { d = Double . NaN ; } else { int minnk = Math . min ( n - k , k ) ; int maxnk = Math . max ( n - k , k ) ; for ( int i = maxnk ; i < n ; i ++ ) { d *= i + 1 ; } d /= factorial ( minnk ) ; } return d ; }
public static String toHex ( String value ) { return ( value == null || value . length ( ) == 0 ) ? " [ ] " : toHex ( value . getBytes ( LocaleUtil . CHARSET_1252 ) ) ; }
public String getAccessSecret ( ) { return getCredentials ( ) . getAccessKeySecret ( ) ; }
public static BoundSheetRecord [ ] orderByBofPosition ( List < BoundSheetRecord > boundSheetRecords ) { BoundSheetRecord [ ] bsrs = new BoundSheetRecord [ boundSheetRecords . size ( ) ] ; boundSheetRecords . toArray ( bsrs ) ; Arrays . sort ( bsrs , BoundSheetRecord :: compareRecords ) ; return bsrs ; }
public DeleteNotebookInstanceResult deleteNotebookInstance ( DeleteNotebookInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNotebookInstance ( request ) ; }
public DTDHandler getDTDHandler ( ) { return ( theDTDHandler == this ) ? null : theDTDHandler ; }
public static File resolve ( File directory , FS fs ) { if ( isGitRepository ( directory , fs ) ) return directory ; if ( isGitRepository ( new File ( directory , Constants . DOT_GIT ) , fs ) ) return new File ( directory , Constants . DOT_GIT ) ; final String name = directory . getName ( ) ; final File parent = directory . getParentFile ( ) ; if ( isGitRepository ( new File ( parent , name + Constants . DOT_GIT_EXT ) , fs ) ) return new File ( parent , name + Constants . DOT_GIT_EXT ) ; return null ; }
public WorkflowTypeInfos listWorkflowTypes ( ListWorkflowTypesRequest request ) { request = beforeClientExecution ( request ) ; return executeListWorkflowTypes ( request ) ; }
public Snapshot copyClusterSnapshot ( CopyClusterSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCopyClusterSnapshot ( request ) ; }
public Ptg [ ] getFormulaTokens ( EvaluationCell evalCell ) { HSSFCell cell = ( ( HSSFEvaluationCell ) evalCell ) . getHSSFCell ( ) ; FormulaRecordAggregate fra = ( FormulaRecordAggregate ) cell . getCellValueRecord ( ) ; return fra . getFormulaTokens ( ) ; }
public DisassociateVPCFromHostedZoneResult disassociateVPCFromHostedZone ( DisassociateVPCFromHostedZoneRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateVPCFromHostedZone ( request ) ; }
public StringBuffer insert ( int index , int i ) { return insert ( index , Integer . toString ( i ) ) ; }
public void setBytesValue ( BytesRef value ) { if ( ! ( fieldsData instanceof BytesRef ) ) { throw new IllegalArgumentException ( " cannot ▁ change ▁ value ▁ type ▁ from ▁ " + fieldsData . getClass ( ) . getSimpleName ( ) + " ▁ to ▁ BytesRef " ) ; } if ( type . indexOptions ( ) != IndexOptions . NONE ) { throw new IllegalArgumentException ( " cannot ▁ set ▁ a ▁ BytesRef ▁ value ▁ on ▁ an ▁ indexed ▁ field " ) ; } if ( value == null ) { throw new IllegalArgumentException ( " value ▁ must ▁ not ▁ be ▁ null " ) ; } fieldsData = value ; }
public boolean equals ( Object o ) { return o instanceof GermanStemmer ; }
public UntagMeetingResult untagMeeting ( UntagMeetingRequest request ) { request = beforeClientExecution ( request ) ; return executeUntagMeeting ( request ) ; }
public String toString ( ) { return " [ PRECISION ] \ n " + " ▁ ▁ ▁ ▁ . precision ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + getFullPrecision ( ) + " \ n " + " [ / PRECISION ] \ n " ; }
static public double pmt ( double r , int nper , double pv , double fv ) { return pmt ( r , nper , pv , fv , 0 ) ; }
public ValueEval getArea3DEval ( Area3DPxg aptg ) { SheetRangeEvaluator sre = createExternSheetRefEvaluator ( aptg . getSheetName ( ) , aptg . getLastSheetName ( ) , aptg . getExternalWorkbookNumber ( ) ) ; return new LazyAreaEval ( aptg . getFirstRow ( ) , aptg . getFirstColumn ( ) , aptg . getLastRow ( ) , aptg . getLastColumn ( ) , sre ) ; }
public boolean equals ( Object obj ) { if ( obj instanceof Rect ) { Rect rhs = ( Rect ) obj ; if ( isValid ( ) != rhs . isValid ( ) ) { return false ; } if ( ! isValid ( ) && ! rhs . isValid ( ) ) { return true ; } return this . x == rhs . x && this . y == rhs . y && this . w == rhs . w && this . h == rhs . h ; } return false ; }
public final boolean containsColumn ( int col ) { return _firstColumn <= col && _lastColumn >= col ; }
public RunJobFlowRequest ( String name , JobFlowInstancesConfig instances ) { setName ( name ) ; setInstances ( instances ) ; }
public String toString ( ) { if ( noBreak == null && postBreak == null && preBreak != null && preBreak . equals ( " - " ) ) { return " - " ; } StringBuilder res = new StringBuilder ( " { " ) ; res . append ( preBreak ) ; res . append ( " } { " ) ; res . append ( postBreak ) ; res . append ( " } { " ) ; res . append ( noBreak ) ; res . append ( ' } ' ) ; return res . toString ( ) ; }
public ListPublishedSchemaArnsResult listPublishedSchemaArns ( ListPublishedSchemaArnsRequest request ) { request = beforeClientExecution ( request ) ; return executeListPublishedSchemaArns ( request ) ; }
public StoredField ( String name , double value ) { super ( name , TYPE ) ; fieldsData = value ; }
public DescribeNetworkAclsResult describeNetworkAcls ( ) { return describeNetworkAcls ( new DescribeNetworkAclsRequest ( ) ) ; }
public PushCommand add ( Ref ref ) { refSpecs . add ( new RefSpec ( ref . getLeaf ( ) . getName ( ) ) ) ; return this ; }
public DeleteVoiceConnectorGroupResult deleteVoiceConnectorGroup ( DeleteVoiceConnectorGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVoiceConnectorGroup ( request ) ; }
public IntervalSet ( List < Interval > intervals ) { this . intervals = intervals ; }
public IteratorQueue ( Iterator < T > iter ) { this . iter = iter ; T removeTop = removeTop ( ) ; assert removeTop == null ; }
public static long [ ] grow ( long [ ] array ) { return grow ( array , 1 + array . length ) ; }
public StemmerOverrideMap ( FST < BytesRef > fst , boolean ignoreCase ) { this . fst = fst ; this . ignoreCase = ignoreCase ; }
public DeleteAdmChannelResult deleteAdmChannel ( DeleteAdmChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAdmChannel ( request ) ; }
public SetSubscriptionAttributesRequest ( String subscriptionArn , String attributeName , String attributeValue ) { setSubscriptionArn ( subscriptionArn ) ; setAttributeName ( attributeName ) ; setAttributeValue ( attributeValue ) ; }
public void unsafeWrite ( char b ) { buf [ len ++ ] = b ; }
@ Override public boolean remove ( Object key ) { int count = 0 ; Collection < V > collection = subMap . remove ( key ) ; if ( collection != null ) { count = collection . size ( ) ; collection . clear ( ) ; totalSize -= count ; } return count > 0 ; }
public boolean markSupported ( ) { return false ; }
public List < Pair < String , Double >> customerInRegionOrdersTotalAverage ( String region ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalAverage = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalAverage ; }
public List < Triplet < String , Integer , Integer >> customerSelectManyCustomerOrderDateYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Integer >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderDate ( ) . getYear ( ) , o . getOrderDate ( ) . getMonthValue ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , Product >> productLeftOuterJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Product >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBoolOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Pair < Boolean , List < Double >>> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ) ) . toList ( ) ; return numbersGroups ; }
public List < Pair < String , List < Customer >>> customerEachCountryOrdersMinCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersMin ; }
public Map < String , List < Product >> productEachGroupTakeWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ) ) ; return after3EachGroups ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDictOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Map < Boolean , List < Double >> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( ) . toList ( ) ) ) ; return numbersGroups ; }
public List < Double > bigDoubleOrderbyFractionDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public double [ ] doublesConvertToDescendingArray ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . mapToDouble ( d -> d ) . toArray ( ) ; return doublesArray ; }
public double [ ] convertSelectedDoubleItemToArrayAndPrint ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; double [ ] doubles = Arrays . stream ( numbers ) . filter ( o -> o instanceof Double ) . mapToDouble ( d -> ( double ) d ) . toArray ( ) ; for ( int i = 0 ; i < doubles . length ; i ++ ) System . out . println ( doubles [ i ] ) ; return doubles ; }
public Map < String , Integer > customerDistinctOrdersCountDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > orderCounts = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> ( int ) c . getOrders ( ) . stream ( ) . distinct ( ) . count ( ) ) ) ; return orderCounts ; }
public List < Customer > repeatedCustomers ( ) { List < Customer > customers = Collections . nCopies ( 5 , Customer . DEFAULT ) ; return customers ; }
public int [ ] bigIntAddIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] bigNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . toArray ( ) ; int [ ] numSelected = IntStream . range ( 0 , bigNumbers . length ) . map ( i -> bigNumbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public List < Product > expensiveProductSkipWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public int numbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . sum ( ) ; return numbersSum ; }
public int intDotProduct ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int dotProduct = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] * numbersB [ i ] ) . sum ( ) ; return dotProduct ; }
public boolean customerOrdersNestedAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean anyMatch = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . anyMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return anyMatch ; }
public List < String > indexedSelectManyString ( ) { List < Customer > customers = getCustomerList ( ) ; List < String > customerOrders = IntStream . range ( 0 , customers . size ( ) ) . boxed ( ) . flatMap ( i -> customers . get ( i ) . getOrders ( ) . stream ( ) . map ( o -> " Customer ▁ # " + ( i + 1 ) + " ▁ has ▁ an ▁ order ▁ with ▁ OrderID ▁ " + o . getOrderId ( ) ) ) . collect ( Collectors . toList ( ) ) ; return customerOrders ; }
public double [ ] doubleUnion ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] uniqueNumbers = DoubleStream . concat ( Arrays . stream ( numbersA ) , Arrays . stream ( numbersB ) ) . distinct ( ) . toArray ( ) ; return uniqueNumbers ; }
public Map < Pair < String , Integer > , List < Customer >> customerGroupJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Pair < String , Integer > , List < Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Integer > intTake ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . limit ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Pair < String , Order >> customerIdAndFirstOrDefaultOrder ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . findFirst ( ) . orElse ( Order . DEFAULT ) ) ) . toList ( ) ; return customerProperties ; }
public int [ ] intUnion ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; int [ ] uniqueNumbers = IntStream . concat ( Arrays . stream ( numbersA ) , Arrays . stream ( numbersB ) ) . distinct ( ) . toArray ( ) ; return uniqueNumbers ; }
public List < Pair < String , List < Product >>> productEachCategoryMaxUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public List < Integer > shortStringLengthOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < Integer > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . map ( w -> w . length ( ) ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public List < String > stringTakeCount ( int n ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNWords = Arrays . stream ( words ) . limit ( 3 ) . toList ( ) ; return afterNWords ; }
public boolean oddIntAnyMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean anyMatch = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . anyMatch ( n -> n > 3 ) ; return anyMatch ; }
public boolean unequalInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 6 , 10 } ; boolean equal = Arrays . equals ( numbersA , numbersB ) ; return equal ; }
public List < String > stringOrderbyCustomThenbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w , new CaseInsensitiveComparer ( ) ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyDescendingLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedWords ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderby ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Pair < String , List < Product >>> expensiveProductEachCategoryMaxUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public List < Double > bigDoubleOrderbyModDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Integer > repeatedIntsWithValue ( int value ) { List < Integer > numbers = Collections . nCopies ( 10 , value ) ; return numbers ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBoolOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Pair < Boolean , List < Double >>> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) . toList ( ) ; return numbersGroups ; }
public List < String > stringOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < Product > productSkipWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public List < Pair < String , LocalDate >> waCustomerOrdersEachNestedSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachWAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . dropWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachWAOrders ; }
public Map < String , Map < String , Map < String , Customer >>> customerNestedGroupByRegionAndCountryAndName ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , Map < String , Customer >>> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g1 -> g1. getKey ( ) , g1 -> g1. getValue ( ) . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c ) ) ) ) ) ) ; return customerGroups ; }
public List < String > intersectOfName ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) ; var customerNames = customers . stream ( ) . map ( c -> c . getCompanyName ( ) ) ; List < String > sharedNames = productNames . distinct ( ) . filter ( a -> customerNames . anyMatch ( b -> b . equals ( a ) ) ) . toList ( ) ; return sharedNames ; }
public void shortStringLengthEager ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . map ( w -> w . length ( ) ) . map ( n -> i . addAndGet ( n ) ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public boolean productAllMatch ( ) { List < Product > products = getProductList ( ) ; boolean allMatch = products . stream ( ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return allMatch ; }
public double numbersAggregateFindMax ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( ( a , b ) -> Math . max ( a , b ) ) . getAsDouble ( ) ; return aggregateSum ; }
public int bigNumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . sum ( ) ; return numbersSum ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public double bigDoubleNumbersMax ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double maxNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . max ( ) . getAsDouble ( ) ; return maxNum ; }
public Map < Boolean , Integer > countExpensiveProductByInStockDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , Integer > inStockCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) == 0 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . count ( ) ) ) ; return inStockCounts ; }
public List < Integer > repeatedInts ( ) { List < Integer > numbers = Collections . nCopies ( 50 , 0 ) ; return numbers ; }
public Map < String , Map < String , Map < String , Customer >>> customerNestedGroupByRegionAndCountryAndNamePrint ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , Map < String , Customer >>> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g1 -> g1. getKey ( ) , g1 -> g1. getValue ( ) . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c ) ) ) ) ) ) ; for ( var e1 : customerGroups . entrySet ( ) ) { System . out . println ( e1. getKey ( ) + " : " ) ; for ( var e2 : e1. getValue ( ) . entrySet ( ) ) { System . out . println ( " \ t " + e2. getKey ( ) + " : " ) ; for ( var e3 : e2. getValue ( ) . entrySet ( ) ) System . out . println ( " \ t \ t " + e3. getKey ( ) + " : " + e3. getValue ( ) ) ; } } return customerGroups ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . dropWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3WAOrders ; }
public double bigDoubleNumbersElementAt ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numAt = Arrays . stream ( numbers ) . filter ( d -> d > 5 ) . skip ( 1 ) . findFirst ( ) . getAsDouble ( ) ; return numAt ; }
public Map < String , Integer > productEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ) ) ; return categories ; }
public void bigDoubleNumbersEager ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; AtomicReference < Double > d = new AtomicReference <> ( 0.0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> d . accumulateAndGet ( n , Double :: sum ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + d ) ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public Map < String , Double > customerExpensiveOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < String > shortStringReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public int customerInRegionCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . count ( ) ; return count ; }
public List < Character > unionOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > uniqueFirstChars = Stream . concat ( productFirstChars , customerFirstChars ) . distinct ( ) . toList ( ) ; return uniqueFirstChars ; }
public List < Pair < String , Product >> productCrossGroupJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Product >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . takeWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3WAOrders ; }
public List < String > stringSkipWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNNumbers = Arrays . stream ( words ) . dropWhile ( w -> w . charAt ( 0 ) > ' b ' ) . toList ( ) ; return afterNNumbers ; }
public Map < String , Integer > customerEachCountryOrdersMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) ; return ordersMin ; }
public double stringAverageLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; double averageLength = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . average ( ) . getAsDouble ( ) ; return averageLength ; }
public List < Pair < String , Integer >> productEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ) ) . toList ( ) ; return categories ; }
public Map < Integer , List < Customer >> customerGroupJoinRegionsWithCode ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Integer , List < Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Pair < Boolean , List < Integer >>> productGroupByInStockWithId ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Integer >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) . toList ( ) ; return productGroup ; }
public int productLongNameLengthSum ( ) { List < Product > products = getProductList ( ) ; int totalSum = products . stream ( ) . map ( p -> p . getProductName ( ) ) . filter ( name -> name . length ( ) > 7 ) . mapToInt ( name -> name . length ( ) ) . sum ( ) ; return totalSum ; }
public void bigNumbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public List < String > stringOrderbyLengthThenbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) ) . thenComparing ( new CaseInsensitiveComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < String > outOfStockProductName ( ) { List < Product > products = getProductList ( ) ; List < String > productNames = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) == 0 ) . map ( p -> p . getProductName ( ) ) . toList ( ) ; return productNames ; }
public int stringSumLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int totalChars = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . sum ( ) ; return totalChars ; }
public boolean expensiveProductAnyMatch ( ) { List < Product > products = getProductList ( ) ; boolean anyMatch = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return anyMatch ; }
public List < String > longStringOrginalIndexedWhere ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > q = IntStream . range ( 0 , words . length ) . filter ( i -> words [ i ] . length ( ) < i * 3 && words [ i ] . length ( ) > 5 ) . mapToObj ( i -> words [ i ] ) . toList ( ) ; return q ; }
public Map < String , List < String >> customerGroupJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; Map < String , List < String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> c . getPhone ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Pair < String , Double >> customerExpensiveOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public int numbersMax ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public int [ ] intAddIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = IntStream . range ( 0 , numbers . length ) . map ( i -> numbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public boolean stringAnyMatchCount ( String [ ] strings , char c ) { boolean anyMatch = Arrays . stream ( strings ) . anyMatch ( w -> w . charAt ( 0 ) > c ) ; return anyMatch ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMin ; }
public double numbersDoubledAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public String [ ] transformIndexHashToString ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String [ ] textNums = ( String [ ] ) Arrays . stream ( numbers ) . mapToObj ( n -> numbers [ n * 97 % 10 ] ) . toArray ( ) ; return textNums ; }
public Map < String , List < Product >> expensiveProductEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public List < Pair < Boolean , Integer >> countExpensiveProductByInStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , Integer >> inStockCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) == 0 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . count ( ) ) ) . toList ( ) ; return inStockCounts ; }
public int distinctOrdersCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . distinct ( ) . count ( ) ; return count ; }
public boolean customerOrdersAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean anyMatch = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . anyMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return anyMatch ; }
public List < Integer > intSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . dropWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Pair < String , String >> customerCrossGroupJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public List < String > stringOrderbyReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public List < Pair < String , String >> customerRegionAndCountry ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getRegion ( ) , c . getCountry ( ) ) ) . toList ( ) ; return customerProperties ; }
public boolean categoryProductAllMatch ( ) { List < Product > products = getProductList ( ) ; boolean allMatch = products . stream ( ) . filter ( p -> p . getCategory ( ) == " Beverages " ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return allMatch ; }
public List < Integer > stringLengthSkip ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < Integer > after3Words = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . skip ( 3 ) . toList ( ) ; return after3Words ; }
public List < Pair < Boolean , List < String >>> stringGroupByLengthOrderbyDescendingLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public double numbersAverage ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public List < Order > customerOrdersSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . dropWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public List < Pair < String , List < Customer >>> customerEachRegionOrdersMinCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersMin ; }
public List < Pair < String , List < Product >>> productEachCategoryMinUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public double expensiveProductStockAverage ( ) { List < Product > products = getProductList ( ) ; double averageUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ; return averageUnitPrice ; }
public double oddNumbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . map ( n -> n * 2 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public List < String > productNameOrderbyDescending ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . map ( p -> p . getProductName ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedProducts ; }
public int [ ] oddIntAddOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] % 2 == 1 ) . map ( i -> numbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public List < Integer > oddIntIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] oddNumbers = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . toArray ( ) ; List < Integer > q = IntStream . range ( 0 , oddNumbers . length ) . filter ( i -> oddNumbers [ i ] < i ) . map ( i -> oddNumbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public List < Integer > oddIntSkip ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . skip ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Order > waCustomerIndexedSelectManyOrdersTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = IntStream . range ( 0 , customers . size ( ) ) . boxed ( ) . filter ( i -> customers . get ( i ) . getRegion ( ) . equals ( " WA " ) ) . flatMap ( i -> customers . get ( i ) . getOrders ( ) . stream ( ) . limit ( i < 10 ? 5 : 1 ) ) . toList ( ) ; return customerProperties ; }
public List < Double > doubleFractionOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public void numbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public List < Triplet < String , Integer , Integer >> customerSelectManyCustomerNewOrderDateYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Integer >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderDate ( ) . getYear ( ) , o . getOrderDate ( ) . getMonthValue ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Product > productsConvertToDescendingListAndPrintForeach ( ) { List < Product > products = getProductList ( ) ; List < Product > productsList = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; for ( Product p : productsList ) System . out . println ( p ) ; return productsList ; }
public List < Integer > oddIntTake ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . limit ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Pair < String , Order >> customerSelectManyCustomerNewOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o ) ) ) . toList ( ) ; return customerProperties ; }
public List < Integer > stringLengthOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < String , List < Customer >>> customerEachCountryOrdersFirstOrDefaultCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersFirstOrDefault = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Customer . DEFAULT ) . getOrders ( ) . size ( ) ) . toList ( ) ) ) . toList ( ) ; return customerOrdersFirstOrDefault ; }
public List < Integer > intSkipWhileIndexedCount ( int [ ] numbers , int n ) { List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Integer > stringLengthOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . sorted ( new CustomNumberComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < String , Double >> customerExpensiveOrdersTotalMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMin = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMin ; }
public double productUnitPriceMax ( ) { List < Product > products = getProductList ( ) ; double maxUnitPrice = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . max ( ) . getAsDouble ( ) ; return maxUnitPrice ; }
public String [ ] stringZipAdd ( ) { String [ ] wordsA = { " Alpha " , " Beta " , " Gamma " } ; String [ ] wordsB = { " red " , " green " , " blue " } ; int length = wordsA . length ; String [ ] results = ( String [ ] ) IntStream . range ( 0 , length ) . mapToObj ( i -> wordsA [ i ] + wordsB [ i ] ) . toArray ( ) ; return results ; }
public List < Product > productOrderbyCategoryThenbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) ) ) . toList ( ) ; return sortedProducts ; }
public int newOrdersCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . count ( ) ; return count ; }
public int bigNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . findFirst ( ) . orElse ( 0 ) ; return firstNum ; }
public List < Pair < String , Double >> customerExpensiveOrdersTotalAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalAverage = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalAverage ; }
public Map < String , List < Order >> customerEachRegionOrdersTotalMinCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Order >> customerOrdersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersTotalMin ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderby ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public Map < String , Double > customerEachRegionOrdersAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersAverage ; }
public Map < Boolean , List < Integer >> intGroupByBoolDict ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Map < Boolean , List < Integer >> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 4 ) ) ; return numberGroups ; }
public Map < String , Map < Integer , Map < Integer , List < Order >>>> customerNestedGroupByNameAndOrderYearAndMonthPrint ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < Integer , Map < Integer , List < Order >>>> customerOrderGroups = customers . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c . getOrders ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ) ) ; for ( var e1 : customerOrderGroups . entrySet ( ) ) { System . out . println ( e1. getKey ( ) + " : " ) ; for ( var e2 : e1. getValue ( ) . entrySet ( ) ) { System . out . println ( " \ t " + e2. getKey ( ) + " : " ) ; for ( var e3 : e2. getValue ( ) . entrySet ( ) ) { System . out . println ( " \ t \ t " + e3. getKey ( ) + " : " ) ; e3. getValue ( ) . forEach ( o -> System . out . println ( " \ t \ t \ t " + o ) ) ; } } } return customerOrderGroups ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBool ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; List < Pair < Boolean , List < Double >>> numberGroups = numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 3 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public List < Triplet < String , Integer , Integer >> waCustomerSelectManyCustomerNewOrderDateYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Integer >> customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderDate ( ) . getYear ( ) , o . getOrderDate ( ) . getMonthValue ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < Integer , String >> customerLeftOuterJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , String >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getCompanyName ( ) : " No ▁ Customer " ) ) ) . toList ( ) ; return q ; }
public boolean waCustomerOrdersNestedAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean allMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . allMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return allMatch ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBoolOrderbyDescendingFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Pair < Boolean , List < Double >>> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) . toList ( ) ; return numbersGroups ; }
public Map < String , Double > customerInRegionOrdersTotalMaxDict ( String region ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public int oddNumbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public List < String > stringOrderbyLengthCustomThenbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) , new CustomNumberComparer ( ) ) . thenComparing ( new CaseInsensitiveComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public Map < String , Integer > convertSelectedTupleToDictionary ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; Map < String , Integer > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . collect ( toMap ( p -> p . getValue0 ( ) , p -> p . getValue1 ( ) ) ) ; return strings ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . limit ( 3 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public List < String > concatOfCategory ( ) { String [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = getProductList ( ) ; var productCategories = products . stream ( ) . map ( p -> p . getCategory ( ) ) ; List < String > allCategories = Stream . concat ( productCategories , Arrays . stream ( categories ) ) . toList ( ) ; return allCategories ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyName ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public List < Integer > rangeOfSquareIntsStartFrom ( int start , int count ) { List < Integer > numbers = IntStream . range ( start , start + count ) . map ( n -> n * n ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Triplet < String , String , String >> customerCityAndAddressAndPostal ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , String , String >> customerProperties = customers . stream ( ) . map ( c -> Triplet . with ( c . getCity ( ) , c . getAddress ( ) , c . getPostalCode ( ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , Map < String , List < Customer >>> customerNestedGroupByRegionAndCountry ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , List < Customer >>> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) ) ) ; return customerGroups ; }
public Map < String , List < Product >> productGroupByCategoryDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> category = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) ; return category ; }
public List < Pair < String , Double >> customerOrdersTotalMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public void doubleDeferred ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; AtomicReference < Double > d = new AtomicReference <> ( 0.0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> d . accumulateAndGet ( n , Double :: sum ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + d ) ) ; }
public Map < String , Integer > expensiveProductEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ) ) ; return categories ; }
public Map < String , Double > customerEachRegionOrdersTotalAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersTotalAverage ; }
public List < Product > inStockProductTake ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . limit ( 3 ) . toList ( ) ; return after3Products ; }
public List < Pair < String , Integer >> customerEachCountryOrdersMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . max ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMax ; }
public List < Integer > repeatedIntsWithValueAndCount ( int value , int count ) { List < Integer > numbers = Collections . nCopies ( count , value ) ; return numbers ; }
public List < Integer > intsConvertToListAndPrintForeach ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < Integer > intsList = Arrays . stream ( ints ) . boxed ( ) . sorted ( ) . toList ( ) ; for ( int i : intsList ) System . out . println ( i ) ; return intsList ; }
public int projectedBigNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . map ( i -> ( int ) Math . pow ( 2 , i ) ) . filter ( n -> n > 100 ) . findFirst ( ) . orElse ( 100 ) ; return firstNum ; }
public List < Integer > stringLengthOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public List < Product > productOrderbyCategoryThenbyIdCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedProducts ; }
public double bigDoubleNumbersAverage ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public void bigNumbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public List < Integer > intSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] * numbers [ i ] < i ) . map ( i -> numbers [ i ] * numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public int numbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public int stringMaxLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int maxLength = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . max ( ) . getAsInt ( ) ; return maxLength ; }
public List < String > concatOfName ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) ; var customerNames = customers . stream ( ) . map ( c -> c . getCompanyName ( ) ) ; List < String > allNames = Stream . concat ( productNames , customerNames ) . toList ( ) ; return allNames ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Pair < String , LocalDate >> customerOrdersNestedSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . dropWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public int [ ] oddIntTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n * 2 ) . toArray ( ) ; return numSelected ; }
public List < String > convertSelectedStringItemToList ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; List < String > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof String ) . map ( s -> ( String ) s ) . toList ( ) ; return strings ; }
public Map < String , List < Customer >> customerGroupByRegionDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> catagory = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) ; return catagory ; }
public List < Product > expensiveProductTake ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . limit ( 3 ) . toList ( ) ; return after3Products ; }
public Map < Double , List < Double >> doubleGroupByModDict ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; Map < Double , List < Double >> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 1.5 ) ) ; return numberGroups ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . skip ( 3 ) . toList ( ) ; return after3WAOrders ; }
public boolean stringAllMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean allMatch = Arrays . stream ( words ) . allMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return allMatch ; }
public List < Double > doubleOrderbyFractionThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyDescendingLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public Map < String , Double > customerEachRegionOrdersTotalMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public Map < Integer , List < Integer >> intGroupByModDict ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Map < Integer , List < Integer >> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 5 ) ) ; return numberGroups ; }
public List < Pair < String , List < Order >>> customerEachRegionOrdersTotalMinCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Order >>> customerOrdersTotalMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersTotalMin ; }
public Map < String , List < Product >> productGroupTakeWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . takeWhile ( g -> g . getKey ( ) . length ( ) > 6 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public List < Product > productOrderbyCategoryThenbyDescendingIdCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < String > stringOrderbyDescendingLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Integer > intSquareTakeWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . takeWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < String > stringSkipCount ( int n ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNWords = Arrays . stream ( words ) . skip ( 3 ) . toList ( ) ; return afterNWords ; }
public List < Pair < String , LocalDate >> waCustomerOrdersNestedTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3WAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . limit ( 3 ) . toList ( ) ; return after3WAOrders ; }
public List < String > longStringTake ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . limit ( 3 ) . toList ( ) ; return after3Words ; }
public List < Pair < String , Integer >> customerNewOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public double doubleAverage ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double averageNum = Arrays . stream ( numbers ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public List < String > stringOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ; return sortedWords ; }
public List < Double > bigDoubleOrderbyFractionDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Product > expensiveProductOrderbyName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Character > exceptOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > differemtFirstChars = productFirstChars . distinct ( ) . filter ( a -> customerFirstChars . allMatch ( b -> b != a ) ) . toList ( ) ; return differemtFirstChars ; }
public List < Double > doubleReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public List < Pair < String , Order >> customerIdAndFirstOrder ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . findFirst ( ) . get ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , List < Customer >>> customerEachCountryOrdersMaxCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersMax ; }
public List < Character > intersectOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > sharedFirstChars = productFirstChars . distinct ( ) . filter ( a -> customerFirstChars . anyMatch ( b -> b == a ) ) . toList ( ) ; return sharedFirstChars ; }
public double doubleMax ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double maxNum = Arrays . stream ( numbers ) . max ( ) . getAsDouble ( ) ; return maxNum ; }
public List < Pair < String , Integer >> customerIdAndOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . size ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Order > repeatedOrders ( ) { List < Order > orders = Collections . nCopies ( 10 , Order . DEFAULT ) ; return orders ; }
public boolean intAnyMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean anyMatch = Arrays . stream ( numbers ) . anyMatch ( n -> n > 3 ) ; return anyMatch ; }
public Product expensiveProductElementAt ( ) { List < Product > products = getProductList ( ) ; Product expensiveProduct = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . skip ( 2 ) . findFirst ( ) . get ( ) ; return expensiveProduct ; }
public List < Pair < String , Integer >> countDistinctProductByCategory ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categoryCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return categoryCounts ; }
public List < Pair < String , Integer >> expensiveProductEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ) ) . toList ( ) ; return categories ; }
public List < Integer > rangeOfIntsWithStartAndCount ( int start , int count ) { List < Integer > numbers = IntStream . range ( start , start + count ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < String > shortStringOrderbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Double > doublesConvertToDescendingList ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; List < Double > doublesList = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return doublesList ; }
public List < Pair < Character , List < String >>> stringGroupByFirstChar ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return wordsGroups ; }
public double numbersAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = Arrays . stream ( numbers ) . reduce ( seed , ( a , b ) -> a * b ) ; return product ; }
public List < Integer > stringLengthTakeWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < Integer > after3Words = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . takeWhile ( n -> n > 5 ) . toList ( ) ; return after3Words ; }
public String stringFirstStartWith ( char c ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithChar = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == c ) . findFirst ( ) . get ( ) ; return startWithChar ; }
public List < Pair < String , List < Order >>> customerEachRegionOrdersTotalMaxCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Order >>> customerOrdersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersTotalMax ; }
public Map < String , Integer > customerEachRegionOrdersMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . max ( ) . getAsInt ( ) ) ) ; return ordersMax ; }
public int [ ] stringProjectionZipAddInt ( ) { String [ ] wordsA = { " Alpha " , " Beta " , " Gamma " } ; String [ ] wordsB = { " red " , " green " , " blue " } ; int length = wordsA . length ; int [ ] results = IntStream . range ( 0 , length ) . map ( i -> wordsA [ i ] . length ( ) + wordsB [ i ] . length ( ) ) . toArray ( ) ; return results ; }
public double bigDoubleNumbersMin ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double minNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . min ( ) . getAsDouble ( ) ; return minNum ; }
public void doubleEager ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; AtomicReference < Double > d = new AtomicReference <> ( 0.0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> d . accumulateAndGet ( n , Double :: sum ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + d ) ; }
public List < Double > intSqrtSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Double > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> Math . sqrt ( numbers [ i ] ) > i ) . mapToDouble ( i -> Math . sqrt ( numbers [ i ] ) ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Pair < String , String >> customerCrossJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> Pair . with ( r , c . getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public boolean intAllMatchInput ( int i ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean allMatch = Arrays . stream ( numbers ) . allMatch ( n -> n > i ) ; return allMatch ; }
public List < String > convertSelectedStringItemToListAndPrintForeach ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; List < String > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof String ) . map ( s -> ( String ) s ) . toList ( ) ; for ( String s : strings ) System . out . println ( s ) ; return strings ; }
public List < String > expensiveProductName ( ) { List < Product > products = getProductList ( ) ; List < String > productNames = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getProductName ( ) ) . toList ( ) ; return productNames ; }
public List < Pair < String , Double >> customerEachRegionOrdersAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersAverage ; }
public List < Pair < Integer , Integer >> uniqueFactorOf300CountByOddEven ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; List < Pair < Integer , Integer >> uniqueFactorsCount = Arrays . stream ( factorsOf300 ) . boxed ( ) . collect ( groupingBy ( n -> n % 2 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return uniqueFactorsCount ; }
public List < Product > expensiveProductOrderbyCategoryThenbyIdCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Order > customerOrdersSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . skip ( 3 ) . toList ( ) ; return after3Orders ; }
public boolean intAllMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean allMatch = Arrays . stream ( numbers ) . allMatch ( n -> n > 3 ) ; return allMatch ; }
public List < String > stringOrderbyThenbyLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w ) . thenComparing ( w -> w . length ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Order > customerIndexedSelectManyOrdersTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = IntStream . range ( 0 , customers . size ( ) ) . boxed ( ) . flatMap ( i -> customers . get ( i ) . getOrders ( ) . stream ( ) . limit ( i < 10 ? 5 : 1 ) ) . toList ( ) ; return customerProperties ; }
public int [ ] oddNumbersCount ( int [ ] [ ] numbers ) { int [ ] oddNumbersCount = Arrays . stream ( numbers ) . mapToInt ( a -> ( int ) Arrays . stream ( a ) . filter ( n -> n % 2 == 1 ) . count ( ) ) . toArray ( ) ; return oddNumbersCount ; }
public int productNameWithFirstLetterCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . map ( p -> p . getProductName ( ) ) . filter ( c -> c . startsWith ( " c " ) ) . count ( ) ; return count ; }
public List < String > shortStringOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < String > stringOrderbyLengthThenby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedWords ; }
public double [ ] productsConvertToUnitPriceArray ( ) { List < Product > products = getProductList ( ) ; double [ ] pricesArray = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . sorted ( ) . toArray ( ) ; return pricesArray ; }
public boolean intSquareAnyMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean anyMatch = Arrays . stream ( numbers ) . map ( i -> i * i ) . anyMatch ( n -> n > 3 ) ; return anyMatch ; }
public Pair < Integer , Integer > [ ] selectManyJoin ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public boolean equalStringsLengths ( ) { List < String > wordsA = Arrays . asList ( " Alpha " , " Beta " , " Gamma " ) ; List < String > wordsB = Arrays . asList ( " Gamma " , " Beta " , " Alpha " ) ; boolean equal = wordsA . stream ( ) . map ( w -> w . length ( ) ) . toList ( ) . equals ( wordsB ) ; return equal ; }
public String [ ] stringZipAddInt ( ) { String [ ] words = { " Alpha " , " Beta " , " Gamma " } ; int [ ] numbers = { 1 , 2 , 3 } ; int length = words . length ; String [ ] results = ( String [ ] ) IntStream . range ( 0 , length ) . mapToObj ( i -> words [ i ] + numbers [ i ] ) . toArray ( ) ; return results ; }
public List < Pair < String , Integer >> customerEachRegionOrdersSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersSum ; }
public Map < String , Double > customerOrdersTotalAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalAverage = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersTotalAverage ; }
public List < Pair < Boolean , List < String >>> stringGroupByLengthOrderbyLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public int productLongCategoryCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . map ( p -> p . getCategory ( ) ) . filter ( c -> c . length ( ) > 8 ) . count ( ) ; return count ; }
public double productUnitPriceAverage ( ) { List < Product > products = getProductList ( ) ; double averageUnitPrice = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . average ( ) . getAsDouble ( ) ; return averageUnitPrice ; }
public int expensiveProductStockSum ( ) { List < Product > products = getProductList ( ) ; int totalSum = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . sum ( ) ; return totalSum ; }
public int [ ] intIntersect ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; int [ ] sharedNumbers = Arrays . stream ( numbersA ) . distinct ( ) . filter ( a -> Arrays . stream ( numbersB ) . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedNumbers ; }
public List < String > stringSkipWhileCount ( char c ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNWords = Arrays . stream ( words ) . dropWhile ( w -> w . charAt ( 0 ) > c ) . toList ( ) ; return afterNWords ; }
public boolean stringAllMatchCount ( String [ ] strings , char c ) { boolean allMatch = Arrays . stream ( strings ) . allMatch ( w -> w . charAt ( 0 ) > c ) ; return allMatch ; }
public Pair < Integer , Integer > [ ] selectManyJoinOdd ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . filter ( b -> b % 2 == 1 ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public List < Double > doubleOrderbyModDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Integer > intSkipCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . skip ( n ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public Map < String , List < Customer >> customerGroupJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Pair < String , List < Double >>> productGroupUnitPrice ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Double >>> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ) ) . toList ( ) ; return productNames ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyId ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public Map < String , Order > customerEachRegionFirstOrDefaultOrderDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Order > ordersFirstOrDefault = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . findFirst ( ) . orElse ( Order . DEFAULT ) ) ) ; return ordersFirstOrDefault ; }
public List < Double > bigDoubleOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public void bigNumbersDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public List < Pair < String , Double >> productEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Double >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , Integer > productEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ) ) ; return categories ; }
public List < Integer > intTakeWhileCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . takeWhile ( i -> i > n ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Pair < Boolean , List < String >>> stringGroupByLengthOrderbyDescendingLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public List < Pair < String , List < Product >>> productGroupByCategoryOrderbyName ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) ) ) . toList ( ) ) ) . toList ( ) ; return productsGroups ; }
public List < Pair < String , List < Customer >>> customerEachRegionOrdersMaxCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return customerOrdersMax ; }
public List < Product > productOrderbyCategoryThenbyNameCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) , new CaseInsensitiveComparer ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalAverage ; }
public List < Pair < String , List < Product >>> productGroupByCategory ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> category = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return category ; }
public List < Integer > shortStringLengthOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . map ( w -> w . length ( ) ) . sorted ( new CustomNumberComparer ( ) ) . toList ( ) ; return sortedWords ; }
public List < String > shortStringOrderbyLengthReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public double productLongNameLengthAverage ( ) { List < Product > products = getProductList ( ) ; double averageUnitPrice = products . stream ( ) . map ( p -> p . getProductName ( ) ) . filter ( name -> name . length ( ) > 7 ) . mapToInt ( name -> name . length ( ) ) . average ( ) . getAsDouble ( ) ; return averageUnitPrice ; }
public List < Double > doubleOrderbyReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . sorted ( ) . boxed ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public List < Pair < Boolean , List < Product >>> productGroupByPrice ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Product >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return productGroup ; }
public int distinctProductLongCategoryCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . map ( p -> p . getCategory ( ) ) . distinct ( ) . filter ( c -> c . length ( ) > 8 ) . count ( ) ; return count ; }
public List < Integer > rangeOfSquareIntsStartFrom ( ) { List < Integer > numbers = IntStream . range ( 100 , 120 ) . map ( n -> n * n ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Boolean > waCustomerOrdersEachNestedAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; List < Boolean > anyMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . map ( c -> c . getOrders ( ) . stream ( ) . anyMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ) . toList ( ) ; return anyMatch ; }
public Map < String , Integer > countRegionExpensiveOrdersDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > regionCounts = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ) ) ; return regionCounts ; }
public int expensiveProductCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . count ( ) ; return count ; }
public int expensiveProductStockMax ( ) { List < Product > products = getProductList ( ) ; int maxUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ; return maxUnitPrice ; }
public List < String > shortStringOrderbyDescendingLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < String , List < Product >>> productGroupByCategoryOrderbyDescendingId ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) . toList ( ) ; return productsGroups ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDict ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; Map < Boolean , List < Double >> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 3 ) ) ; return numberGroups ; }
public List < Pair < String , String >> customerLeftOuterJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getPhone ( ) : " No ▁ phone " ) ) ) . toList ( ) ; return q ; }
public void shortStringLengthDeferred ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . map ( w -> w . length ( ) ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public List < String > unionOfRegion ( ) { String [ ] regions = { " WA " , " AF " , " RO " } ; List < Customer > customers = getCustomerList ( ) ; var customerRegions = customers . stream ( ) . map ( c -> c . getRegion ( ) ) ; List < String > uniqueRegions = Stream . concat ( customerRegions , Arrays . stream ( regions ) ) . distinct ( ) . toList ( ) ; return uniqueRegions ; }
public int [ ] intConcat ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; int [ ] allNumbers = IntStream . concat ( Arrays . stream ( numbersA ) , Arrays . stream ( numbersB ) ) . toArray ( ) ; return allNumbers ; }
public List < Pair < String , Integer >> expensiveProductEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . sum ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , Double > productEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Double > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return categories ; }
public List < Pair < Integer , List < Integer >>> intGroupByMod ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Pair < Integer , List < Integer >>> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public Map < String , Double > customerInRegionOrdersTotalMinDict ( String region ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public double productUnitPriceAggregateAverage ( ) { List < Product > products = getProductList ( ) ; double aggregateSum = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . reduce ( ( a , b ) -> ( a + b ) / 2 ) . get ( ) ; return aggregateSum ; }
public List < String > exceptOfRegion ( ) { String [ ] regions = { " WA " , " AF " , " RO " } ; List < Customer > customers = getCustomerList ( ) ; var customerRegions = customers . stream ( ) . map ( c -> c . getRegion ( ) ) ; List < String > differemtRegions = customerRegions . distinct ( ) . filter ( a -> Arrays . stream ( regions ) . allMatch ( b -> ! b . equals ( a ) ) ) . toList ( ) ; return differemtRegions ; }
public List < String > exceptOfName ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) ; var customerNames = customers . stream ( ) . map ( c -> c . getCompanyName ( ) ) ; List < String > differemtNames = productNames . distinct ( ) . filter ( a -> customerNames . allMatch ( b -> ! b . equals ( a ) ) ) . toList ( ) ; return differemtNames ; }
public List < String > stringTakeWhileCount ( char c ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNWords = Arrays . stream ( words ) . takeWhile ( w -> w . charAt ( 0 ) > c ) . toList ( ) ; return afterNWords ; }
public double [ ] projectionDoubleUnion ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] uniqueNumbers = DoubleStream . concat ( first , second ) . distinct ( ) . toArray ( ) ; return uniqueNumbers ; }
public Map < Double , Double > convertArrayToDictionaryAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; Map < Double , Double > doublesDict = Arrays . stream ( doubles ) . boxed ( ) . collect ( toMap ( sr -> sr , sr -> sr * 2 ) ) ; for ( var pair : doublesDict . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return doublesDict ; }
public List < String > stringSkip ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNNumbers = Arrays . stream ( words ) . skip ( 3 ) . toList ( ) ; return afterNNumbers ; }
public double numbersAggregateSqrt ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( ( a , b ) -> Math . sqrt ( a * b ) ) . getAsDouble ( ) ; return aggregateSum ; }
public int productLongNameLengthMin ( ) { List < Product > products = getProductList ( ) ; int minUnitPrice = products . stream ( ) . map ( p -> p . getProductName ( ) ) . filter ( name -> name . length ( ) > 7 ) . mapToInt ( name -> name . length ( ) ) . min ( ) . getAsInt ( ) ; return minUnitPrice ; }
public void oddNumbersDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public List < String > stringOrderbyLengthCustomThenbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) , new CustomNumberComparer ( ) ) . thenComparing ( new CaseInsensitiveComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public int intAddMultiply ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int product = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] + numbersB [ i ] ) . reduce ( ( a , b ) -> a * b ) . getAsInt ( ) ; return product ; }
public double oddNumbersAverage ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public List < Integer > oddIntSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . dropWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Pair < String , Double >> productLeftOuterJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Double >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getUnitPrice ( ) : 0 ) ) ) . toList ( ) ; return q ; }
public List < String > stringOrderbyCustomThenbyLength ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w , new CaseInsensitiveComparer ( ) ) . thenComparing ( w -> w . length ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Product > productOrderbyCategoryThenbyDescendingNameCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) , new CaseInsensitiveComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Triplet < String , String , String >> customerRegionAndCountryAndCity ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , String , String >> customerProperties = customers . stream ( ) . map ( c -> Triplet . with ( c . getRegion ( ) , c . getCountry ( ) , c . getCity ( ) ) ) . toList ( ) ; return customerProperties ; }
public Character [ ] projectionStringIntersect ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = Arrays . stream ( wordsA ) . map ( n -> n . charAt ( 0 ) ) ; var second = Arrays . stream ( wordsB ) . map ( n -> n . charAt ( 0 ) ) ; Character [ ] sharedWords = ( Character [ ] ) first . distinct ( ) . filter ( a -> second . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedWords ; }
public int [ ] indexedSelectManyBig ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; int [ ] pairs = IntStream . range ( 0 , numbersA . length ) . flatMap ( i -> Arrays . stream ( numbersB ) . filter ( b -> b < numbersA [ i ] + i ) ) . toArray ( ) ; return pairs ; }
public Map < Boolean , List < String >> stringGroupByLengthDictOrderbyDescendingLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ) ) ; return wordsGroups ; }
public Map < Integer , Integer > uniqueFactorOf300CountByOddEvenDict ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; Map < Integer , Integer > uniqueFactorsCount = Arrays . stream ( factorsOf300 ) . boxed ( ) . collect ( groupingBy ( n -> n % 2 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) ; return uniqueFactorsCount ; }
public List < Double > doubleOrderbyFractionReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public List < Triplet < String , Integer , Double >> waCustomerSelectManyCustomerNewOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Product > productTake ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . limit ( 3 ) . toList ( ) ; return after3Products ; }
public Map < String , Double > productsConvertFieldsToDictionary ( ) { List < Product > products = getProductList ( ) ; Map < String , Double > productsUnitPrice = products . stream ( ) . collect ( toMap ( p -> p . getProductName ( ) , p -> p . getUnitPrice ( ) ) ) ; return productsUnitPrice ; }
public void numbersDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public void numbersTwiceDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public List < Integer > oddIntTakeWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . takeWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public int [ ] projectionIntExcept ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] differemtNumbers = first . distinct ( ) . filter ( a -> second . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtNumbers ; }
public List < Double > doubleOrderbyModDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Product > productsConvertToDescendingListAndPrint ( ) { List < Product > products = getProductList ( ) ; List < Product > productsList = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; for ( int i = 0 ; i < productsList . size ( ) ; i ++ ) System . out . println ( productsList . get ( i ) ) ; return productsList ; }
public int bigNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public List < Integer > rangeOfInts ( ) { List < Integer > numbers = IntStream . range ( 0 , 50 ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Pair < Boolean , List < String >>> stringGroupByLength ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return wordsGroups ; }
public String stringFirstLong ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startsWithO = Arrays . stream ( strings ) . filter ( s -> s . length ( ) > 4 ) . findFirst ( ) . get ( ) ; return startsWithO ; }
public int numbersElementAt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numAt = Arrays . stream ( numbers ) . skip ( 1 ) . findFirst ( ) . getAsInt ( ) ; return numAt ; }
public int [ ] projectionIntIntersect ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] sharedNumbers = first . distinct ( ) . filter ( a -> second . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedNumbers ; }
public List < Product > inStockProductSkip ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . skip ( 3 ) . toList ( ) ; return after3Products ; }
public Pair < String , String > [ ] selectByCase ( ) { String [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; Pair < String , String > [ ] upperLowerWords = ( Pair < String , String > [ ] ) Arrays . stream ( words ) . map ( w -> Pair . with ( w . toUpperCase ( ) , w . toLowerCase ( ) ) ) . toArray ( ) ; return upperLowerWords ; }
public Map < Boolean , List < Integer >> productGroupByPriceWithIdDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Integer >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; return productGroup ; }
public List < Pair < String , LocalDate >> customerOrdersNestedTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . limit ( 3 ) . toList ( ) ; return after3Orders ; }
public List < Pair < String , LocalDate >> waCustomerOrdersEachNestedTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachWAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . limit ( 3 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachWAOrders ; }
public List < Integer > rangeOfIntsStartFrom ( ) { List < Integer > numbers = IntStream . range ( 100 , 150 ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Double > doublesConvertToListAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; List < Double > doublesList = Arrays . stream ( doubles ) . boxed ( ) . sorted ( ) . toList ( ) ; for ( int i = 0 ; i < doublesList . size ( ) ; i ++ ) System . out . println ( doublesList . get ( i ) ) ; return doublesList ; }
public Boolean [ ] oddIntWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] oddNumbers = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . toArray ( ) ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , oddNumbers . length ) . mapToObj ( i -> oddNumbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public List < Integer > intSkipWhileCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . dropWhile ( i -> i > n ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Integer > stringLengthSkipWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < Integer > after3Words = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . dropWhile ( n -> n > 5 ) . toList ( ) ; return after3Words ; }
public double numbersAggregateFindMinWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 3 ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> Math . min ( a , b ) ) ; return aggregateSum ; }
public boolean oddIntAllMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean allMatch = Arrays . stream ( numbers ) . filter ( i -> i % 2 == 1 ) . allMatch ( n -> n > 3 ) ; return allMatch ; }
public int [ ] indexedSelectMany ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; int [ ] pairs = IntStream . range ( 0 , numbersA . length ) . flatMap ( i -> Arrays . stream ( numbersB ) . map ( b -> i % 2 == 0 ? numbersA [ i ] : b ) ) . toArray ( ) ; return pairs ; }
public List < String > intersectOfRegion ( ) { String [ ] regions = { " WA " , " AF " , " RO " } ; List < Customer > customers = getCustomerList ( ) ; var customerRegions = customers . stream ( ) . map ( c -> c . getRegion ( ) ) ; List < String > sharedRegions = customerRegions . distinct ( ) . filter ( a -> Arrays . stream ( regions ) . anyMatch ( b -> b . equals ( a ) ) ) . toList ( ) ; return sharedRegions ; }
public String [ ] selectByEvenOddConcat ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String [ ] evenOddWords = ( String [ ] ) Arrays . stream ( numbers ) . mapToObj ( n -> strings [ n ] + ( n % 2 == 0 ? " ▁ even " : " ▁ odd " ) ) . toArray ( ) ; return evenOddWords ; }
public Map < Double , Double > convertArrayToDictionaryWithDistinct ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 1.7 , 2.9 } ; Map < Double , Double > doublesDict = Arrays . stream ( doubles ) . distinct ( ) . boxed ( ) . collect ( toMap ( sr -> sr , sr -> sr * 2 ) ) ; return doublesDict ; }
public Map < Double , Double > convertArrayToDictionary ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; Map < Double , Double > doublesDict = Arrays . stream ( doubles ) . boxed ( ) . collect ( toMap ( sr -> sr , sr -> sr * 2 ) ) ; return doublesDict ; }
public List < Double > bigDoubleOrderbyFractionThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public Map < String , Double > expensiveProductEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Double > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return categories ; }
public List < Integer > intTakeWhileCount ( int [ ] numbers , int n ) { List < Integer > afterNNumbers = Arrays . stream ( numbers ) . takeWhile ( i -> i > n ) . boxed ( ) . toList ( ) ; return afterNNumbers ; }
public Character [ ] projectionStringUnion ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = Arrays . stream ( wordsA ) . map ( n -> n . charAt ( 0 ) ) ; var second = Arrays . stream ( wordsB ) . map ( n -> n . charAt ( 0 ) ) ; Character [ ] uniqueWords = ( Character [ ] ) Stream . concat ( first , second ) . distinct ( ) . toArray ( ) ; return uniqueWords ; }
public List < Pair < String , LocalDate >> waCustomerSelectManyCustomerNewOrderDates ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public double [ ] doublesConvertToArrayAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = Arrays . stream ( doubles ) . sorted ( ) . toArray ( ) ; for ( int i = 0 ; i < doublesArray . length ; i ++ ) System . out . println ( doublesArray [ i ] ) ; return doublesArray ; }
public List < Integer > intSquareTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> numbers [ i ] * numbers [ i ] > i ) . map ( i -> numbers [ i ] * numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public String [ ] stringUnion ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; String [ ] uniqueWords = ( String [ ] ) Stream . concat ( Arrays . stream ( wordsA ) , Arrays . stream ( wordsB ) ) . distinct ( ) . toArray ( ) ; return uniqueWords ; }
public Pair < Integer , Integer > [ ] selectManyJoinBig ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . filter ( b -> b > 5 ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public List < Pair < String , List < Product >>> productEachCategoryFirstUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) . getUnitPrice ( ) ) . toList ( ) ) ) . toList ( ) ; return categories ; }
public List < Double > doublesConvertToDescendingListAndPrintForeach ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; List < Double > doublesList = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; for ( double d : doublesList ) System . out . println ( d ) ; return doublesList ; }
public boolean intAllMatchInput ( int [ ] numbers , int i ) { boolean allMatch = Arrays . stream ( numbers ) . allMatch ( n -> n > i ) ; return allMatch ; }
public Map < String , List < Product >> productGroupJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; Map < String , List < Product >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public int customerDistinctRegionsCount ( ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . map ( c -> c . getRegion ( ) ) . distinct ( ) . count ( ) ; return count ; }
public List < Pair < String , Integer >> customerEachCountryOrdersSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersSum ; }
public List < Boolean > customerOrdersEachNestedAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; List < Boolean > allMatch = customers . stream ( ) . map ( c -> c . getOrders ( ) . stream ( ) . allMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ) . toList ( ) ; return allMatch ; }
public Map < Integer , List < String >> customerGroupJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Integer , List < String >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> c . getCompanyName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < String > productNameOrderby ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . map ( p -> p . getProductName ( ) ) . sorted ( ) . toList ( ) ; return sortedProducts ; }
public List < Integer > repeatedIntsWithCount ( int count ) { List < Integer > numbers = Collections . nCopies ( count , 0 ) ; return numbers ; }
public boolean customerOrdersAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean allMatch = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . allMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return allMatch ; }
public double [ ] convertSelectedDoubleItemToArray ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; double [ ] doubles = Arrays . stream ( numbers ) . filter ( o -> o instanceof Double ) . mapToDouble ( d -> ( double ) d ) . toArray ( ) ; return doubles ; }
public Map < String , List < Integer >> productGroupByCategoryWithIdDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Integer >> category = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; return category ; }
public List < Pair < String , String >> customerCityAndAddress ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCity ( ) , c . getAddress ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Double > doubleFractionReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . map ( n -> n - ( int ) n ) . boxed ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public List < Integer > intSkipCount ( int [ ] numbers , int n ) { List < Integer > afterNNumbers = Arrays . stream ( numbers ) . skip ( n ) . boxed ( ) . toList ( ) ; return afterNNumbers ; }
public Map < String , Double > customerEachRegionOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public double numbersAggregateFindMaxWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 5 ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> Math . max ( a , b ) ) ; return aggregateSum ; }
public List < Double > doubleFractionOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public List < String > productName ( ) { List < Product > products = getProductList ( ) ; List < String > productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) . toList ( ) ; return productNames ; }
public Product productFirst ( ) { List < Product > products = getProductList ( ) ; Product product12 = products . stream ( ) . filter ( p -> p . getProductId ( ) == 12 ) . findFirst ( ) . get ( ) ; return product12 ; }
public boolean intAnyMatchInput ( int [ ] numbers , int i ) { boolean anyMatch = Arrays . stream ( numbers ) . anyMatch ( n -> n > i ) ; return anyMatch ; }
public List < Order > customerOrdersTake ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . limit ( 3 ) . toList ( ) ; return after3Orders ; }
public int stringMinLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int minLength = Arrays . stream ( words ) . mapToInt ( w -> w . length ( ) ) . min ( ) . getAsInt ( ) ; return minLength ; }
public int oddNumbersElementAt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numAt = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . skip ( 3 ) . findFirst ( ) . getAsInt ( ) ; return numAt ; }
public List < Double > productUnitPrice ( ) { List < Product > products = getProductList ( ) ; List < Double > productNames = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ; return productNames ; }
public int uniqueOddFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int uniqueFactorsCount = ( int ) Arrays . stream ( factorsOf300 ) . distinct ( ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return uniqueFactorsCount ; }
public List < Integer > intTakeCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . limit ( n ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public boolean unequalDoubles ( ) { double [ ] numbersA = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; double [ ] numbersB = { 6.5 , 1.3 , 8.7 , 2.4 , 4.8 } ; boolean equal = Arrays . equals ( numbersA , numbersB ) ; return equal ; }
public List < Product > expensiveProductIndexedWhere ( ) { List < Product > products = getProductList ( ) ; List < Product > q = IntStream . range ( 0 , products . size ( ) ) . filter ( i -> products . get ( i ) . getUnitPrice ( ) > 100 && i % 2 == 1 ) . mapToObj ( i -> products . get ( i ) ) . toList ( ) ; return q ; }
public List < Pair < String , Order >> customerEachRegionFirstOrDefaultOrder ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> ordersFirstOrDefault = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . findFirst ( ) . orElse ( Order . DEFAULT ) ) ) . toList ( ) ; return ordersFirstOrDefault ; }
public String stringFirstOrDefaultStartWithO ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithO = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == ' o ' ) . findFirst ( ) . orElse ( " none " ) ; return startWithO ; }
public List < Double > productsConvertToUnitPriceList ( ) { List < Product > products = getProductList ( ) ; List < Double > pricesList = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . sorted ( ) . toList ( ) ; return pricesList ; }
public List < Pair < Pair < String , Integer > , Customer >> customerCrossGroupJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Pair < String , Integer > , Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1 ) ) ) . toList ( ) ; return q ; }
public boolean stringLengthAllMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean allMatch = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . allMatch ( n -> n > 5 ) ; return allMatch ; }
public List < Pair < String , List < Product >>> productGroupByCategoryOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) . toList ( ) ; return productsGroups ; }
public List < Pair < String , Product >> productEachCategoryFirstOrDefault ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Product . DEFAULT ) ) ) . toList ( ) ; return categories ; }
public List < Pair < String , LocalDate >> waCustomerOrdersEachNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachWAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . skip ( 3 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachWAOrders ; }
public Map < String , List < Product >> productGroupTake ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . limit ( 3 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public Map < String , Product > productEachCategoryFirstOrDefaultDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Product > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Product . DEFAULT ) ) ) ; return categories ; }
public List < Double > bigDoubleOrderbyFractionThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Triplet < String , Integer , Integer >> customerSelectManyCustomerBigOrderDateYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Integer >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderDate ( ) . getYear ( ) , o . getOrderDate ( ) . getMonthValue ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < String > convertSelectedStringItemToListAndPrint ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; List < String > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof String ) . map ( s -> ( String ) s ) . toList ( ) ; for ( int i = 0 ; i < strings . size ( ) ; i ++ ) System . out . println ( strings . get ( i ) ) ; return strings ; }
public Map < String , Double > customerInRegionOrdersTotalAverageDict ( String region ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalAverage = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersTotalAverage ; }
public int numbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDictOrderbyDescendingFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Map < Boolean , List < Double >> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return numbersGroups ; }
public Map < String , List < Product >> productEachGroupSkipWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ) ) ; return after3EachGroups ; }
public int productLongNameLengthMax ( ) { List < Product > products = getProductList ( ) ; int maxUnitPrice = products . stream ( ) . map ( p -> p . getProductName ( ) ) . filter ( name -> name . length ( ) > 7 ) . mapToInt ( name -> name . length ( ) ) . max ( ) . getAsInt ( ) ; return maxUnitPrice ; }
public String [ ] stringIntersect ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; String [ ] sharedWords = ( String [ ] ) Arrays . stream ( wordsA ) . distinct ( ) . filter ( a -> Arrays . stream ( wordsB ) . anyMatch ( b -> b . equals ( a ) ) ) . toArray ( ) ; return sharedWords ; }
public Pair < String , Integer > [ ] selectByStringAndLength ( ) { String [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; Pair < String , Integer > [ ] upperLowerWords = ( Pair < String , Integer > [ ] ) Arrays . stream ( words ) . map ( w -> Pair . with ( w , w . length ( ) ) ) . toArray ( ) ; return upperLowerWords ; }
public List < Pair < String , Integer >> countRegionExpensiveOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> regionCounts = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ) ) . toList ( ) ; return regionCounts ; }
public String [ ] transformIndexToString ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String [ ] textNums = ( String [ ] ) Arrays . stream ( numbers ) . mapToObj ( n -> strings [ n ] ) . toArray ( ) ; return textNums ; }
public int [ ] oddIntAddIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] oddNumbers = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . toArray ( ) ; int [ ] numSelected = IntStream . range ( 0 , oddNumbers . length ) . map ( i -> oddNumbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public List < String > stringTakeWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNNumbers = Arrays . stream ( words ) . takeWhile ( w -> w . charAt ( 0 ) > ' b ' ) . toList ( ) ; return afterNNumbers ; }
public double numbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public List < Pair < String , Integer >> customerEachRegionOrdersMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . max ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMax ; }
public List < Boolean > customerOrdersEachNestedAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; List < Boolean > anyMatch = customers . stream ( ) . map ( c -> c . getOrders ( ) . stream ( ) . anyMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ) . toList ( ) ; return anyMatch ; }
public List < Integer > intSquareTake ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . limit ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public int [ ] uniqueFactorOf300And900Count ( ) { int [ ] [ ] factorsOf300And900 = { { 2 , 2 , 3 , 5 , 5 } , { 2 , 2 , 3 , 3 , 5 , 5 } } ; int [ ] uniqueFactorsCount = Arrays . stream ( factorsOf300And900 ) . mapToInt ( a -> ( int ) Arrays . stream ( a ) . distinct ( ) . count ( ) ) . toArray ( ) ; return uniqueFactorsCount ; }
public String stringFirstStartWithO ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithO = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == ' o ' ) . findFirst ( ) . get ( ) ; return startWithO ; }
public int shortStringSumLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int totalChars = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . sum ( ) ; return totalChars ; }
public List < Double > bigDoubleOrderbyDescendingFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public int bigNumbersMax ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public double numbersAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = Arrays . stream ( numbers ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public int productOutOfStock ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . filter ( c -> c . getUnitsInStock ( ) == 0 ) . count ( ) ; return count ; }
public Map < String , Map < Integer , Map < Integer , List < Order >>>> customerNestedGroupByNameAndOrderYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < Integer , Map < Integer , List < Order >>>> customerOrderGroups = customers . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c . getOrders ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ) ) ; return customerOrderGroups ; }
public boolean equalStrings ( ) { List < String > wordsA = Arrays . asList ( " Alpha " , " Beta " , " Gamma " ) ; List < String > wordsB = Arrays . asList ( " Alpha " , " Beta " , " Gamma " ) ; boolean equal = wordsA . equals ( wordsB ) ; return equal ; }
public double inputNumbersAggregateWithSeed ( double [ ] numbers , double seed ) { double product = Arrays . stream ( numbers ) . reduce ( seed , ( a , b ) -> a * b ) ; return product ; }
public List < Pair < String , Integer >> productEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return categories ; }
public List < Integer > rangeOfEvenInts ( ) { List < Integer > numbers = IntStream . range ( 0 , 50 ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public Map < String , Boolean > productEachGroupAnyMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > anyMatch = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return anyMatch ; }
public List < Integer > shortStringLengthOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . map ( w -> w . length ( ) ) . sorted ( new CustomNumberComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public int [ ] intZipMultiply ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int [ ] multiplyNumbers = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] * numbersB [ i ] ) . toArray ( ) ; return multiplyNumbers ; }
public Map < String , Integer > customerExpensiveOrdersCountDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > orderCounts = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ) ) ; return orderCounts ; }
public Map < String , Product > productEachCategoryFirstDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Product > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) ) ) ; return categories ; }
public boolean stringAllMatch ( char c ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean allMatch = Arrays . stream ( words ) . allMatch ( w -> w . charAt ( 0 ) > c ) ; return allMatch ; }
public List < Pair < Integer , Customer >> customerLeftOuterJoinRegionsWithCode ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public int oddNumbersCount ( int [ ] numbers ) { int oddNumbersCount = ( int ) Arrays . stream ( numbers ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return oddNumbersCount ; }
public List < Pair < String , LocalDate >> customerOrdersNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . skip ( 3 ) . toList ( ) ; return after3Orders ; }
public int customerWithManyOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) > 5 ) . count ( ) ; return count ; }
public Map < String , Double > customerEachCountryOrdersAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersAverage ; }
public List < Pair < Pair < String , Integer > , String >> customerCrossGroupJoinRegionsWithCodeNameRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Pair < String , Integer > , String >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public Map < String , List < Product >> expensiveProductEachCategoryMaxUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public Map < Integer , Map < Integer , List < Order >>> customerNestedGroupByOrderYearAndMonthPrint ( ) { List < Customer > customers = getCustomerList ( ) ; Map < Integer , Map < Integer , List < Order >>> customerOrderGroups = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ; for ( var e1 : customerOrderGroups . entrySet ( ) ) { System . out . println ( e1. getKey ( ) + " : " ) ; for ( var e2 : e1. getValue ( ) . entrySet ( ) ) { System . out . println ( " \ t " + e2. getKey ( ) + " : " ) ; e2. getValue ( ) . stream ( ) . forEach ( o -> System . out . println ( " \ t \ t " + o ) ) ; } } return customerOrderGroups ; }
public double expensiveProductUnitPriceMax ( ) { List < Product > products = getProductList ( ) ; double maxUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . max ( ) . getAsDouble ( ) ; return maxUnitPrice ; }
public double doubleMin ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double minNum = Arrays . stream ( numbers ) . min ( ) . getAsDouble ( ) ; return minNum ; }
public Boolean [ ] oddIntWithOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] % 2 == 1 ) . mapToObj ( i -> numbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public List < Pair < String , Double >> customerOrdersTotalMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMin = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMin ; }
public List < Pair < String , String >> productCrossJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , String >> q = Arrays . stream ( categories ) . flatMap ( c -> products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p -> Pair . with ( c , p . getProductName ( ) ) ) ) . toList ( ) ; return q ; }
public List < String > shortStringOrderbyLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < String , LocalDate >> customerSelectManyCustomerBigOrderDates ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public void stringLengthDeferred ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public boolean equalDoubles ( ) { double [ ] numbersA = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; double [ ] numbersB = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; boolean equal = Arrays . equals ( numbersA , numbersB ) ; return equal ; }
public List < String > stringTake ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > afterNNumbers = Arrays . stream ( words ) . limit ( 3 ) . toList ( ) ; return afterNNumbers ; }
public int [ ] uniqueFactorsCount ( int [ ] [ ] factors ) { int [ ] factorsCount = Arrays . stream ( factors ) . mapToInt ( a -> ( int ) Arrays . stream ( a ) . distinct ( ) . count ( ) ) . toArray ( ) ; return factorsCount ; }
public List < Pair < Integer , Customer >> customerCrossGroupJoinRegionsWithCode ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1 ) ) ) . toList ( ) ; return q ; }
public Pair < Integer , Integer > [ ] selectManyJoinSmaller ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . filter ( b -> a < b ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public Map < String , Double > productsConvertFieldsToDictionaryAndPrint ( ) { List < Product > products = getProductList ( ) ; Map < String , Double > productsUnitPrice = products . stream ( ) . collect ( toMap ( p -> p . getProductName ( ) , p -> p . getUnitPrice ( ) ) ) ; for ( var pair : productsUnitPrice . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return productsUnitPrice ; }
public List < Pair < String , Order >> customerSelectManyCustomerBigOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , Map < Integer , List < Order >>> customerNestedGroupByNameAndOrderYear ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < Integer , List < Order >>> customerOrderGroups = customers . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c . getOrders ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) ) ) ; return customerOrderGroups ; }
public int oddNumbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . map ( n -> n * 2 ) . sum ( ) ; return numbersSum ; }
public List < Pair < String , Double >> customerInRegionOrdersTotalMax ( String region ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public List < Integer > intSkip ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . skip ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Product > expensiveProductOrderbyCategoryThenbyNameCustom ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) , new CaseInsensitiveComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Triplet < String , Integer , Double >> customerSelectManyCustomerBigOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < String > stringOrderbyLengthThenbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) ) . thenComparing ( new CaseInsensitiveComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDictOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Map < Boolean , List < Double >> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) ; return numbersGroups ; }
public List < Product > expensiveProductOrderbyCategoryThenbyName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) ) ) . toList ( ) ; return sortedProducts ; }
public int [ ] intsConvertToArray ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; int [ ] intsArray = Arrays . stream ( ints ) . sorted ( ) . toArray ( ) ; return intsArray ; }
public int numbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public int aggregateWithdrawMoneyWithSeed ( ) { int startBalance = 100 ; int [ ] attemptedWithdrawals = { 20 , 10 , 40 , 50 , 10 , 70 , 30 } ; int endBalance = Arrays . stream ( attemptedWithdrawals ) . reduce ( startBalance , ( balance , nextWithdrawal ) -> nextWithdrawal <= balance ? balance - nextWithdrawal : balance ) ; return 0 ; }
public int [ ] intZipAddReverse ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int [ ] addNumbers = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] + numbersB [ length - 1 - i ] ) . toArray ( ) ; return addNumbers ; }
public List < String > stringOrderbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < Integer , Customer >> customerCrossJoinRegionsWithCode ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , Customer >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Pair . with ( r . getValue1 ( ) , c ) ) ) . toList ( ) ; return q ; }
public Map < String , Integer > countRegionDistinctCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > regionCounts = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) ; return regionCounts ; }
public Map < String , List < Customer >> customerEachCountryOrdersMinCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersMin ; }
public Map < String , Double > customerExpensiveOrdersTotalAverageDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalAverage = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) ; return ordersTotalAverage ; }
public List < Integer > intSkipWhileCount ( int [ ] numbers , int n ) { List < Integer > afterNNumbers = Arrays . stream ( numbers ) . dropWhile ( i -> i > n ) . boxed ( ) . toList ( ) ; return afterNNumbers ; }
public int [ ] intExcept ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; int [ ] differemtNumbers = Arrays . stream ( numbersA ) . distinct ( ) . filter ( a -> Arrays . stream ( numbersB ) . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtNumbers ; }
public List < String > exceptOfCategory ( ) { String [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = getProductList ( ) ; var productCategories = products . stream ( ) . map ( p -> p . getCategory ( ) ) ; List < String > differemtCategories = productCategories . distinct ( ) . filter ( a -> Arrays . stream ( categories ) . allMatch ( b -> ! b . equals ( a ) ) ) . toList ( ) ; return differemtCategories ; }
public List < Pair < String , Order >> customerEachRegionFirstOrder ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> ordersFirst = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . findFirst ( ) . get ( ) ) ) . toList ( ) ; return ordersFirst ; }
public Map < String , List < Customer >> customerEachRegionOrdersMinCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersMin ; }
public List < Pair < String , Integer >> expensiveProductEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return categories ; }
public int [ ] intsConvertToDescendingArrayAndPrint ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; int [ ] intsArray = Arrays . stream ( ints ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . mapToInt ( d -> d ) . toArray ( ) ; for ( int i = 0 ; i < intsArray . length ; i ++ ) System . out . println ( intsArray [ i ] ) ; return intsArray ; }
public Map < String , Product > productEachCategoryElementAtDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Product > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . skip ( 1 ) . findFirst ( ) . get ( ) ) ) ; return categories ; }
public Map < String , List < Product >> productEachCategoryFirstOrDefaultUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Product . DEFAULT ) . getUnitPrice ( ) ) . toList ( ) ) ) ; return categories ; }
public List < String > unionOfName ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productNames = products . stream ( ) . map ( p -> p . getProductName ( ) ) ; var customerNames = customers . stream ( ) . map ( c -> c . getCompanyName ( ) ) ; List < String > uniqueNames = Stream . concat ( productNames , customerNames ) . distinct ( ) . toList ( ) ; return uniqueNames ; }
public Map < String , List < Customer >> customerEachCountryOrdersFirstOrDefaultCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersFirstOrDefault = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Customer . DEFAULT ) . getOrders ( ) . size ( ) ) . toList ( ) ) ) ; return customerOrdersFirstOrDefault ; }
public List < Pair < String , Double >> customerIdAndBiggestTotal ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , Boolean > expensiveProductEachGroupAnyMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > anyMatch = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return anyMatch ; }
public List < Pair < String , List < Integer >>> productGroupByCategoryWithId ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Integer >>> category = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) . toList ( ) ; return category ; }
public List < Integer > stringLengthOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Integer > sortedWords = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . sorted ( new CustomNumberComparer ( ) ) . toList ( ) ; return sortedWords ; }
public List < Double > bigDoubleOrderbyModDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Pair < Boolean , List < Double >>> doubleGroupByBoolOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Pair < Boolean , List < Double >>> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( ) . toList ( ) ) ) . toList ( ) ; return numbersGroups ; }
public Character [ ] stringFirstChar ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Character [ ] selected = ( Character [ ] ) Arrays . stream ( strings ) . map ( w -> w . charAt ( 0 ) ) . toArray ( ) ; return selected ; }
public List < Product > expensiveProductOrderbyDescendingId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Pair < String , Double >> customerInRegionOrdersTotalSum ( String region ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public int [ ] bigIntAddOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] > 5 ) . filter ( i -> numbers [ i ] % 2 == 1 ) . map ( i -> numbers [ i ] + i ) . toArray ( ) ; return numSelected ; }
public boolean customerOrdersNestedAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean allMatch = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . allMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return allMatch ; }
public Map < String , Integer > productEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . sum ( ) ) ) ; return categories ; }
public void bigNumbersTwiceDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public Map < Boolean , List < Integer >> productGroupByInStockWithIdDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Integer >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; return productGroup ; }
public int distinctOddNumbersCount ( int [ ] numbers ) { int oddNumbersCount = ( int ) Arrays . stream ( numbers ) . distinct ( ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return oddNumbersCount ; }
public double [ ] doubleExcept ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] differemtNumbers = Arrays . stream ( numbersA ) . distinct ( ) . filter ( a -> Arrays . stream ( numbersB ) . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtNumbers ; }
public List < Product > expensiveProductOrderbyCategoryThenbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Order > customerSelectManyOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . toList ( ) ; return customerProperties ; }
public double expensiveProductUnitPriceAggregateAverage ( ) { List < Product > products = getProductList ( ) ; double aggregateSum = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . filter ( d -> d > 100 ) . reduce ( ( a , b ) -> ( a + b ) / 2 ) . get ( ) ; return aggregateSum ; }
public int cheapProductCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . filter ( p -> p . getUnitPrice ( ) < 100 ) . count ( ) ; return count ; }
public int [ ] bigIntPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n + 1 ) . toArray ( ) ; return numSelected ; }
public List < Product > expensiveProductSkip ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . skip ( 3 ) . toList ( ) ; return after3Products ; }
public double [ ] convertSelectedDoubleItemToArrayAndPrintForeach ( ) { Object [ ] numbers = { null , 1.0 , " two " , 3 , " four " , 5 , " six " , 7.0 } ; double [ ] doubles = Arrays . stream ( numbers ) . filter ( o -> o instanceof Double ) . mapToDouble ( d -> ( double ) d ) . toArray ( ) ; for ( double d : doubles ) System . out . println ( d ) ; return doubles ; }
public List < Integer > oddIntOriginalIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] < i && numbers [ i ] % 2 == 1 ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public double projectedDoubleElementAt ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numAt = Arrays . stream ( numbers ) . map ( i -> Math . log ( i ) ) . filter ( n -> n > 3 ) . skip ( 2 ) . findFirst ( ) . getAsDouble ( ) ; return numAt ; }
public List < Integer > intSquareSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> numbers [ i ] * numbers [ i ] > i ) . map ( i -> numbers [ i ] * numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Pair < String , Integer >> productEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Integer >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . sum ( ) ) ) . toList ( ) ; return categories ; }
public int expensiveProductStockMin ( ) { List < Product > products = getProductList ( ) ; int minUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . min ( ) . getAsInt ( ) ; return minUnitPrice ; }
public Map < String , List < Double >> productGroupJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; Map < String , List < Double >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p1 -> p1. getUnitPrice ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
int countWords ( String str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ; else count *= 2 ; return count ; }
int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
int findSum ( int [ ] arr , int n , int k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
void decodeStr ( String str , int len ) { char [ ] c = new char [ len ] ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str . charAt ( 0 ) ; if ( len % 2 == 0 ) c [ med + 1 ] = str . charAt ( 1 ) ; if ( len % 2 == 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str . charAt ( i ) ; if ( len % 2 == 1 ) c [ med + pos ] = str . charAt ( i + 1 ) ; else c [ med + pos + 1 ] = str . charAt ( i + 1 ) ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) System . out . print ( c [ i ] ) ; }
int countSubArrayWithOddProduct ( int A [ ] , int N ) { int count = 0 ; int last = - 1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
int nthTerm ( int N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
int smallestNum ( int N ) { float x = ( float ) ( Math . pow ( 10 , ( N - 1 ) / 2.0 ) ) ; return ( int ) ( Math . ceil ( x ) ) ; }
long multiplyFactors ( int n ) { long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
int deleteElement ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
int findNumberOfTriangles ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; }
int cntPairs ( int a [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
boolean isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( float ) ( ( 3.14f * r * r ) / 4 ) ; return a ; }
void findSetBits ( int n ) { int [ ] dp = new int [ n + 1 ] ; System . out . print ( dp [ 0 ] + " ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i / 2 ] ; } else { dp [ i ] = dp [ i / 2 ] + 1 ; } System . out . print ( dp [ i ] + " ▁ " ) ; } }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
int check ( int n , List < Integer > marks ) { Integer x = Collections . max ( marks ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks . get ( i ) + bonus >= 50 ) c += 1 ; } return c ; }
double octaside ( double a ) { if ( a < 0 ) return - 1 ; double s = a / ( Math . sqrt ( 2 ) + 1 ) ; return s ; }
int countTriplets ( int [ ] A ) { int cnt = 0 ; HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ; for ( int a : A ) for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; } for ( int a : A ) for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) ) if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ; return cnt ; }
int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
boolean isSubseqPossible ( int [ ] arr , int N , int K ) { int i ; int odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
int count_min_length ( String s ) { int [ ] hash = new int [ 26 ] ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( hash [ s . charAt ( i ) - ' a ' ] == - 1 ) hash [ s . charAt ( i ) - ' a ' ] = i ; else { if ( hash [ s . charAt ( i ) - ' a ' ] == i - 1 || hash [ s . charAt ( i ) - ' a ' ] == i - 2 ) return 0 ; ans = Math . min ( ans , i - hash [ s . charAt ( i ) - ' a ' ] - 1 ) ; hash [ s . charAt ( i ) - ' a ' ] = i ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; }
int calculateSum ( int n ) { return ( n * ( ( int ) Math . pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ; }
int calculateSum ( int n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; }
int results ( int n , int k ) { return ( int ) Math . round ( Math . pow ( n , ( 1.0 / Math . pow ( 2.0 , k ) ) ) ) ; }
BigInteger findCycles ( int N ) { BigInteger res , finalResult ; long val = 2 * N - 1 ; String st = String . valueOf ( val ) ; BigInteger str = new BigInteger ( st ) ; String n1 = String . valueOf ( ( N - 1 ) ) ; String n2 = String . valueOf ( ( N - 2 ) ) ; BigInteger a = new BigInteger ( n1 ) ; BigInteger b = new BigInteger ( n2 ) ; res = a . multiply ( b ) ; finalResult = res . add ( str ) ; return finalResult ; }
Boolean isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; }
int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; Arrays . sort ( arr ) ; int left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = ( float ) Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = ( float ) Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = ( float ) 3.14159 ; float A = ( 180 / pi ) * ( float ) ( Math . acos ( d ) ) ; System . out . println ( " Angle ▁ is ▁ " + A + " ▁ degree " ) ; }
double get_concentration ( double mass , double volume ) { if ( volume == 0 ) return - 1 ; else return ( mass / volume ) * 1000 ; }
int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
void find ( int n ) { System . out . println ( n / 2 ) ; }
int CntcontSubs ( int a [ ] , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; }
void zigzag ( String s , int rows ) { int interval = 2 * rows - 2 ; for ( int i = 0 ; i < rows ; i ++ ) { int step = interval - 2 * i ; for ( int j = i ; j < s . length ( ) ; j = j + interval ) { System . out . print ( s . charAt ( j ) ) ; if ( step > 0 && step < interval && step + j < s . length ( ) ) { for ( int k = 0 ; k < ( interval - rows - i ) ; k ++ ) System . out . print ( " ▁ " ) ; System . out . print ( s . charAt ( j + step ) ) ; for ( int k = 0 ; k < i - 1 ; k ++ ) System . out . print ( " ▁ " ) ; } else { for ( int k = 0 ; k < ( interval - rows ) ; k ++ ) System . out . print ( " ▁ " ) ; } } System . out . println ( ) ; } }
int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
int bitPos ( int n1 , int n2 ) { if ( n1 == n2 ) return 0 ; int bitCount1 = ( int ) Math . floor ( Math . log ( n1 ) / Math . log ( 2 ) ) + 1 ; int bitCount2 = ( int ) Math . floor ( Math . log ( n2 ) / Math . log ( 2 ) ) + 1 ; int bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = ( int ) Math . floor ( Math . log ( xorValue ) / Math . log ( 2 ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
int perfectPowerOf2 ( int n ) { int per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
int longestCommonSum ( int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { System . out . println ( " NO " ) ; return ; } double a = ( N + Math . sqrt ( val ) ) / 2.0 ; double b = ( N - Math . sqrt ( val ) ) / 2.0 ; System . out . println ( " a ▁ = ▁ " + a ) ; System . out . println ( " b ▁ = ▁ " + b ) ; }
int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
int minSum ( Integer arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
void charactersCount ( String str , int n ) { int count = 0 ; while ( n > 0 ) { char cur = str . charAt ( 0 ) ; int ind = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( str . charAt ( j ) < cur ) { cur = str . charAt ( j ) ; ind = j ; } } str = str . substring ( 0 , ind ) + str . substring ( ind + 1 ) ; n -- ; count += ind + 1 ; } System . out . print ( count + "NEW_LINE"); }
int pairORSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
String NimGame ( int N , int A , int B ) { int sum = A + B ; if ( N % sum <= A - 1 ) return " Bob " ; else return " Alice " ; }
void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { System . out . println ( " Overflow " ) ; } else { System . out . println ( " Not ▁ in ▁ overflow ▁ state " ) ; } }
int maxDiffSubsets ( int [ ] arr ) { int totalSum = 0 ; boolean pos = false , neg = false ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr . length ; i ++ ) { totalSum += Math . abs ( arr [ i ] ) ; if ( arr [ i ] > 0 ) pos = true ; if ( arr [ i ] < 0 ) neg = true ; if ( arr [ i ] < min ) min = arr [ i ] ; } if ( pos && neg ) return totalSum ; else return totalSum - 2 * min ; }
int minCost ( int arr [ ] , int n , int circumference ) { Arrays . sort ( arr ) ; int [ ] arr2 = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; arr2 [ i + n ] = arr [ i ] + circumference ; } int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) res = Math . min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; return res ; }
int findCost ( int [ ] A , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
int fib ( long n ) { int f0 = 0 ; int f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { int rem = ( int ) ( n % 60 ) ; if ( rem == 0 ) return 0 ; for ( int i = 2 ; i < rem + 3 ; i ++ ) { int f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } int s = f1 - 1 ; return s ; } }
int countMaxChoco ( int money , int price , int wrap ) { if ( money < price ) return 0 ; int choc = money / price ; choc = choc + ( choc - 1 ) / ( wrap - 1 ) ; return choc ; }
int substrDeletion ( String str , int len ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count0 ++ ; else count1 ++ ; } return Math . min ( count0 , count1 ) ; }
int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
void findpair ( int l , int r ) { int ans1 = l ; int ans2 = 2 * l ; System . out . println ( ans1 + " , ▁ " + ans2 ) ; }
boolean isPossible ( char [ ] str ) { Map < Character , Integer > freq = new HashMap < > ( ) ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . containsKey ( str [ j ] ) ) { freq . put ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . put ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } } if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; }
void printMiddleCharacter ( String str ) { int len = str . length ( ) ; int middle = len / 2 ; System . out . println ( str . charAt ( middle ) ) ; }
int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }
int findLength ( String s , int k ) { int ans = INT_MAX ; int l = 0 ; int r = 0 ; int cnt_zero = 0 , cnt_one = 0 ; while ( l < s . length ( ) && r <= s . length ( ) ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = Math . min ( ans , r - l ) ; l ++ ; if ( s . charAt ( l - 1 ) == '0' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . length ( ) ) break ; if ( s . charAt ( r ) == '0' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == INT_MAX ) return - 1 ; return ans ; }
void printMatrix ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) System . out . print ( k + " ▁ " ) ; else System . out . print ( "0 ▁ " ) ; } System . out . print ( "NEW_LINE"); } }
int remainingArea ( int N , int M , int K ) { while ( K -- > 0 && N > 0 && M > 0 ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
int countPairs ( int [ ] arr , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } int ans = ( N - odd + odd / 2 - 1 ) + odd / 2 ; return ans ; }
int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ ] = new int [ rhs + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
int find_longest_subarray ( int [ ] A , int N , int K ) { int MaxLen = 0 ; int Len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = Math . max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
double polite ( double n ) { n += 1 ; double base = 2 ; return n + ( Math . log ( ( n + ( Math . log ( n ) / Math . log ( base ) ) ) ) ) / Math . log ( base ) ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
int maxBalancedStr ( String s ) { int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { switch ( s . charAt ( i ) ) { case ' ( ' : open1 ++ ; break ; case ' ) ' : close1 ++ ; break ; case ' { ' : open2 ++ ; break ; case ' } ' : close2 ++ ; break ; case ' [ ' : open3 ++ ; break ; case ' ] ' : close3 ++ ; break ; } } int maxLen = 2 * Math . min ( open1 , close1 ) + 2 * Math . min ( open2 , close2 ) + 2 * Math . min ( open3 , close3 ) ; return maxLen ; }
double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; }
void findNums ( int arr [ ] , int n ) { int S = 0 , X = 0 ; for ( int i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } System . out . println ( X + " ▁ " + ( X + S ) ) ; }
int maxSubsequences ( int arr [ ] , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { count = map . get ( arr [ i ] ) ; if ( count > 1 ) { map . put ( arr [ i ] , count - 1 ) ; } else map . remove ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) map . put ( arr [ i ] - 1 , map . getOrDefault ( arr [ i ] - 1 , 0 ) + 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) map . put ( arr [ i ] - 1 , map . getOrDefault ( arr [ i ] - 1 , 0 ) + 1 ) ; } } return maxCount ; }
void minumumOperation ( int N , int arr [ ] ) { int sum_arr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum_arr += arr [ i ] ; } if ( sum_arr >= N ) System . out . println ( sum_arr - N ) ; else System . out . println ( "1" ) ; }
void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
void printOtherSides ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) System . out . println ( " - 1" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } else { if ( n == 2 ) System . out . println ( " - 1" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } }
int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
int xorK ( int n , int k ) { int res = n ; for ( int i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return n ; }
double CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( ( double ) Math . log ( i ) / ( double ) Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; }
int minOperation ( int N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } int k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
int ksmallest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
int findM ( String s , int x ) { int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) - '0' != x ) cnt ++ ; } return cnt ; }
void specialSieve ( int n ) { int cnt = 0 ; int prime [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! ( prime [ i ] > 0 ) ) { cnt ++ ; for ( int j = i ; j <= n ; j += i ) prime [ j ] = cnt ; } } for ( int i = 2 ; i <= n ; i ++ ) System . out . print ( prime [ i ] + " ▁ " ) ; }
String nambiarNumber ( String str , int i ) { if ( i >= str . length ( ) ) return " " ; int firstDigit = ( str . charAt ( i ) - '0' ) ; int digitParity = firstDigit % 2 ; int sumDigits = 0 ; while ( i < str . length ( ) ) { sumDigits += ( str . charAt ( i ) - '0' ) ; int sumParity = sumDigits % 2 ; if ( digitParity != sumParity ) { break ; } i ++ ; } return ( " " + sumDigits + nambiarNumber ( str , i + 1 ) ) ; }
String unique ( String s ) { String str = new String ( ) ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( str . indexOf ( c ) < 0 ) { str += c ; } } return str ; }
int countWays ( int n ) { int [ ] res = new int [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
int totEdge ( int n ) { int result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
int minInsertion ( String str ) { int n = str . length ( ) ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
int numberOfArithmeticSequences ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
int maxRightmostElement ( int N , int k , int p , int arr [ ] ) { while ( k > 0 ) { for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= p ) { arr [ i ] = arr [ i ] - p ; arr [ i + 1 ] = arr [ i + 1 ] + p ; break ; } } k -- ; } return arr [ N - 1 ] ; }
int xor_operations ( int N , int arr [ ] , int M , int K ) { if ( M < 0 M >= N ) return - 1 ; if ( K < 0 K >= N - M ) return - 1 ; for ( int p = 0 ; p < M ; p ++ ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . add ( value ) ; arr [ i ] = temp . get ( i ) ; } } int ans = arr [ K ] ; return ans ; }
int findSingle ( int ar [ ] , int ar_size ) { int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
void divide ( int a , int b ) { for ( int i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } System . out . println ( " A ▁ = ▁ " + a + " , ▁ B ▁ = ▁ " + b ) ; }
int solve ( int n , int m , int x , int y , int d ) { int top = Math . min ( d , x - 1 ) ; int down = Math . min ( d , n - x ) ; int left = Math . min ( d , y - 1 ) ; int right = Math . min ( d , m - y ) ; int quad1 = top * left ; int quad2 = left * down ; int quad3 = down * right ; int quad4 = right * top ; int totalsq = quad1 + quad2 + quad3 + quad4 ; int singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }
int countSubStrings ( String s , int n ) { int count = 0 , sum = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; mp . put ( 0 , 1 ) ; for ( int i = 0 ; i < n ; ++ i ) { sum += ( s . charAt ( i ) - '0' ) ; count += mp . containsKey ( sum - ( i + 1 ) ) == true ? mp . get ( sum - ( i + 1 ) ) : 0 ; if ( ! mp . containsKey ( sum - ( i + 1 ) ) ) mp . put ( sum - ( i + 1 ) , 1 ) ; else mp . put ( sum - ( i + 1 ) , mp . get ( sum - ( i + 1 ) ) + 1 ) ; } return count ; }
boolean canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . max ( max_length , count ) ; }
int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; Arrays . sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = Integer . MAX_VALUE ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
int findNumber ( int N ) { return N & ( N + 1 ) ; }
boolean isPossible ( int n , int k , int arr [ ] ) { int sum = arr [ 0 ] ; int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; }
int count ( int arr [ ] , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }
int minimumflip ( int mat [ ] [ ] , int n ) { int transpose [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }
int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }
float Length_Diagonal ( int a , int b , int d ) { float diagonal = ( float ) Math . sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; }
void printExpansion ( String str ) { String suff = " " ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { suff = suff + str . charAt ( i ) ; System . out . print ( suff ) ; } }
int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return ( int ) ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( int ) ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ; else return ( ( n + 1 ) / 2 ) * n ; }
int countElements ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; float mean = ( float ) sum / n ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float newMean = ( float ) ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }
int findMinDiff ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
void getElements ( int a , int arr [ ] , int n ) { int elements [ ] = new int [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) System . out . print ( elements [ i ] + " ▁ " ) ; }
void printThreeParts ( int N ) { if ( N % 3 == 0 ) System . out . println ( " x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " + ( N - 2 ) ) ; else System . out . println ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " + ( N - 3 ) ) ; }
int cntElements ( int arr [ ] , int n ) { int copy_arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }
int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }
void meanOfRemainingElements ( int [ ] arr , int N , int K ) { Arrays . sort ( arr ) ; int kthPercent = ( N * K ) / 100 ; float sum = 0f ; for ( int i = 0 ; i < N ; i ++ ) if ( i >= kthPercent && i < ( N - kthPercent ) ) sum += arr [ i ] ; float mean = ( sum / ( N - 2 * kthPercent ) ) ; System . out . format ( " % .5f " , mean ) ; }
double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }
void PossibleValues ( int b , int x , int n ) { int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { System . out . print ( leastdivisible - b + " ▁ " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) System . out . println ( - 1 ) ; }
int countXorPair ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
int findMinDel ( int [ ] arr , int n ) { int min_num = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }
int countPalindromic ( int n ) { int count ; if ( n % 2 == 1 ) { count = ( int ) Math . pow ( 9 , ( n - 1 ) / 2 ) ; } else { count = ( int ) Math . pow ( 9 , ( n - 2 ) / 2 ) ; } return count ; }
void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * ( int ) Math . pow ( r , i ) ; System . out . print ( curr_term + " ▁ " ) ; } }
int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }
int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; }
boolean checkPowerof8 ( int n ) { double i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; }
int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
boolean isValidISBN ( String isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn . charAt ( 9 ) ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
long NumberofWays ( int n ) { long x = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; long y = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) ; return ( 1l * x * y ) ; }
void productPuzzle ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ( int ) ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) + " ▁ " ) ; }
int maxCost ( int a [ ] , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = Math . max ( mx , a [ i ] ) ; int [ ] count = new int [ mx + 1 ] ; for ( int i = 0 ; i < count . length ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
void compute ( int a [ ] , int N , int K ) { Map < Long , Long > eqVal = new HashMap < Long , Long > ( ) ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . containsKey ( val ) ) { long numVal = eqVal . get ( val ) ; maxX = Math . max ( maxX , val + ( K * numVal ) ) ; eqVal . put ( val , eqVal . getOrDefault ( val , 0l ) + 1l ) ; } else { eqVal . put ( val , 1l ) ; maxX = Math . max ( maxX , val ) ; } } System . out . println ( maxX == 0 ? 0 : maxX + 1 ) ; }
int subsetSum ( int arr [ ] , int n , int sum , int s , int count ) { if ( n == 0 ) { if ( sum == s ) { count ++ ; } return count ; } count = subsetSum ( arr , n - 1 , sum , s , count ) ; count = subsetSum ( arr , n - 1 , sum , s + arr [ n - 1 ] , count ) ; return count ; }
int SquareRoot ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; }
int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }
void printOrder ( Integer [ ] arr , int k ) { int n = arr . length ; Arrays . sort ( arr , 0 , k ) ; Arrays . sort ( arr , k , n , Collections . reverseOrder ( ) ) ; }
int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
int count ( String s ) { int N , i , cnt = 0 , ans = 0 ; N = s . length ( ) ; for ( i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == ' R ' ) cnt ++ ; if ( s . charAt ( i ) == ' L ' ) ans += cnt ; } return ans ; }
void check ( long m , long n ) { double RHS = m * ( double ) Math . log ( n ) ; double LHS = n * ( double ) Math . log ( m ) ; if ( LHS > RHS ) System . out . print ( " m ^ n ▁ > ▁ n ^ m " ) ; else if ( LHS < RHS ) System . out . print ( " m ^ n ▁ < ▁ n ^ m " ) ; else System . out . print ( " m ^ n ▁ = ▁ n ^ m " ) ; }
void find_composite_nos ( int n ) { System . out . println ( 9 * n + " ▁ " + 8 * n ) ; }
int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
void findMinAvgSubarray ( int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } System . out . println ( " Subarray ▁ between ▁ [ " + res_index + " , ▁ " + ( res_index + k - 1 ) + " ] ▁ has ▁ minimum ▁ average " ) ; }
long findDigits ( int n , int b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double M_PI = 3.141592 ; double M_E = 2.7182 ; double x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . log10 ( b ) ) ; return ( long ) ( Math . floor ( x ) + 1 ) ; }
int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
int kthdigit ( int a , int b , int k ) { int p = ( int ) Math . pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; int index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = true ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; }
boolean difSquare ( int n ) { if ( n % 4 != 2 ) { return true ; } return false ; }
int minOR ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; int [ ] pre = new int [ n ] ; int [ ] suf = new int [ n ] ; pre [ 0 ] = arr [ 0 ] ; suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = Math . min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = Math . min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
boolean check ( int arr [ ] , int n ) { int i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }
int kthOdd ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; }
void sortDiff ( Vector < Integer > arr , int n ) { Collections . sort ( arr ) ; Vector < Integer > out = new Vector < Integer > ( ) ; while ( n > 0 ) { out . add ( arr . get ( n / 2 ) ) ; arr . remove ( n / 2 ) ; n = n - 1 ; } for ( int i : out ) System . out . print ( i + " ▁ " ) ; }
void swapTwoHalves ( String a , String b ) { int la = a . length ( ) ; int lb = b . length ( ) ; String c = a . substring ( 0 , la / 2 ) + b . substring ( lb / 2 , lb ) ; String d = b . substring ( 0 , lb / 2 ) + a . substring ( la / 2 , la ) ; System . out . println ( c + "NEW_LINE" + d); }
boolean isRotation ( long x , long y ) { long x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; }
int minimumcoins ( int arr [ ] , int N ) { int coins = 0 ; int j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } int x = ( j - i ) ; coins += x / 3 ; i = j - 1 ; } return coins ; }
boolean isnonagonal ( int N ) { double n = ( 5 + Math . sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
int cntKnightsAttackPawn ( int knights [ ] [ ] , int pawn [ ] , int M ) { int cntKnights = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int X = Math . abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; int Y = Math . abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }
int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
int sum ( int n ) { n = ( n + 1 ) / 2 ; return ( n * n ) ; }
int countMinSteps ( int arr [ ] , int target , int n ) { Arrays . sort ( arr ) ; int minimumSteps = 0 ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i += 1 ; j -= 1 ; } else { j -= 1 ; } minimumSteps += 1 ; } return minimumSteps ; }
void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
int LongestOddEvenSubarray ( int A [ ] , int N ) { int dp ; dp = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp = dp + 1 ; ans = Math . max ( ans , dp ) ; } else dp = 1 ; } return ans ; }
void findArea ( double a , double b , double c ) { double area = 4 * 3.141592653 * Math . pow ( ( Math . pow ( a * b , 1.6 ) + Math . pow ( a * c , 1.6 ) + Math . pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; System . out . print ( String . format ( " % .2f " , area ) ) ; }
long findMinCost ( int [ ] a , int k , int n ) { int max_ele = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; long [ ] dp = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) dp [ i ] = Integer . MAX_VALUE ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int [ ] freq = new int [ max_ele + 1 ] ; for ( int j = i ; j < n ; ++ j ) { freq [ a [ j ] ] ++ ; int cost = 0 ; for ( int x = 0 ; x <= max_ele ; ++ x ) { cost += ( freq [ x ] == 1 ) ? 0 : freq [ x ] ; } dp [ j + 1 ] = Math . min ( dp [ i ] + cost + k , dp [ j + 1 ] ) ; } } return dp [ n ] ; }
int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
void angleextcycquad ( int z ) { System . out . print ( " The ▁ exterior ▁ angle ▁ of ▁ the " + " ▁ cyclic ▁ quadrilateral ▁ is ▁ " + z + " ▁ degrees " ) ; }
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { System . out . print ( ( 3 * i * ( i - 1 ) + 1 ) + " ▁ " ) ; i ++ ; } }
int findMinDeletions ( int [ ] [ ] v , int n ) { int minDel = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int L = v [ i ] [ 0 ] ; int R = v [ i ] [ 1 ] ; int Count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j ] [ 0 ] >= L && v [ j ] [ 1 ] <= R ) { Count += 1 ; } } minDel = Math . min ( minDel , n - Count ) ; } return minDel ; }
void makearrayequal ( int arr [ ] , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += ( arr [ i ] & 1 ) ; } System . out . println ( Math . min ( x , n - x ) ) ; }
int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; }
long fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
void canBeEmptied ( int A , int B ) { if ( Math . max ( A , B ) > 2 * Math . min ( A , B ) ) { System . out . println ( " No " ) ; return ; } if ( ( A + B ) % 3 == 0 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
void perfectCube ( int N ) { int cube_root ; cube_root = ( int ) Math . round ( Math . cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { System . out . println ( " Yes " ) ; return ; } else { System . out . println ( " NO " ) ; return ; } }
int minimumLectures ( int m , int n ) { int ans = 0 ; if ( n < ( int ) Math . ceil ( 0.75 * m ) ) ans = ( int ) Math . ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; }
int countNonDecreasing ( int n ) { int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
int octahedral_num ( int n ) { return n * ( 2 * n * n + 1 ) / 3 ; }
void checkDistribution ( int R , int B , int D ) { if ( Math . max ( R , B ) <= Math . min ( R , B ) * ( D + 1 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
int lenOfLongestReqSubstr ( String s , int N ) { HashMap < Integer , Integer > ind = new HashMap < > ( ) ; int mask = 0 ; ind . put ( 0 , - 1 ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = s . charAt ( i ) - '0' ; mask ^= ( 1 << val ) ; if ( ind . containsKey ( mask ) ) { ans = Math . max ( ans , i - ind . get ( mask ) ) ; } else ind . put ( mask , i ) ; } return ans ; }
int summingSeries ( long n ) { return ( int ) Math . pow ( n , 2 ) ; }
int getMaxLength ( int arr [ ] , int N ) { int res = 2 ; int dist = 2 ; int curradj = ( arr [ 1 ] - arr [ 0 ] ) ; int prevadj = ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < N ; i ++ ) { curradj = arr [ i ] - arr [ i - 1 ] ; if ( curradj == prevadj ) { dist ++ ; } else { prevadj = curradj ; res = Math . max ( res , dist ) ; dist = 2 ; } } res = Math . max ( res , dist ) ; return res ; }
int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
void sameChar ( String S , int N ) { char temp [ ] = S . toCharArray ( ) ; Arrays . sort ( temp ) ; String s = new String ( temp ) ; int mid = s . charAt ( N / 2 ) ; int total_operations = 0 ; for ( int i = 0 ; i < N ; i ++ ) { total_operations += Math . abs ( ( ( s . charAt ( i ) - 0 ) - mid ) ) ; } System . out . print ( total_operations ) ; }
int oddbitsetnumber ( int n ) { int count = 0 ; int res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
boolean isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; }
float strikerate ( float bowls , float runs ) { float z ; z = ( runs / bowls ) * 100 ; return z ; }
void countOperations ( String X , String Y , int K ) { char ch1 [ ] = X . toCharArray ( ) ; char ch2 [ ] = Y . toCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < X . length ( ) ; i ++ ) { int c = 0 ; if ( ch1 [ i ] == ch2 [ i ] ) continue ; else if ( ch1 [ i ] < ch2 [ i ] ) { if ( ( ( int ) ch2 [ i ] - ( int ) ch1 [ i ] ) >= K ) { c = ( ( int ) ch2 [ i ] - ( int ) ch1 [ i ] ) / K ; } c += ( ( int ) ch2 [ i ] - ( int ) ch1 [ i ] ) % K ; } else { int t = 90 - ( int ) ch1 [ i ] ; t += ( int ) ch2 [ i ] - 65 + 1 ; if ( t >= K ) c = t / K ; c += ( t % K ) ; } count += c ; } System . out . print ( count ) ; }
int maxMinDifference ( int arr [ ] , int n , int k ) { if ( k >= n - 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; for ( int i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = Math . min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }
int numberOfTiles ( int n , int m ) { if ( n % 2 == 1 ) { return - 1 ; } return ( m * n ) / 2 ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; }
int FindColumn ( int mat [ ] [ ] ) { int row = 0 , col = M - 1 ; int flag = 0 ; while ( row < N && col >= 0 ) { if ( mat [ row ] [ col ] == 1 ) { col -- ; flag = 1 ; } else { row ++ ; } } col ++ ; if ( flag != 0 ) return col + 1 ; else return - 1 ; }
void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( " n ▁ Found ▁ at ▁ " + i + " ▁ " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( " n ▁ Element ▁ not ▁ found " ) ; return ; }
void findPermutation ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( i + " ▁ " ) ; }
int max_xor ( int arr [ ] , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxXor = Math . max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }
int countSubStr ( String str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str . charAt ( j ) - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
int countOccurrences ( String str , String word ) { String a [ ] = str . split ( " ▁ " ) ; int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( word . equals ( a [ i ] ) ) count ++ ; } return count ; }
int findXOR ( int Set [ ] , int n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
float Area ( int d , int h1 , int h2 ) { float area ; area = ( float ) 0.5 * d * ( h1 + h2 ) ; return area ; }
boolean findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( ( y & 1 ) > 0 ) return true ; return false ; }
int MinimumValue ( int a [ ] , int n ) { int answer = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = Math . min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; System . out . println ( edges_max_secondary + 3 ) ; } else System . out . println ( " Not ▁ Possible " ) ; }
void countOccurrences ( String S , String X , String Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substring ( i , Math . min ( N , i + B ) ) . equals ( Y ) ) count ++ ; if ( S . substring ( i , Math . min ( N , i + A ) ) . equals ( X ) ) System . out . print ( count + " ▁ " ) ; } }
int countEqual ( int n ) { return ( n + 1 ) / 2 ; }
void findMaxValue ( int N , int K ) { int packages ; int maxi = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = Math . max ( maxi , i ) ; } packages = N / maxi ; System . out . println ( packages ) ; }
void lastDigit ( String a , String b ) { int lastDig = ( a . charAt ( a . length ( ) - 1 ) - '0' ) * ( b . charAt ( b . length ( ) - 1 ) - '0' ) ; System . out . println ( lastDig % 10 ) ; }
int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
int solve ( int [ ] A , int [ ] B , int [ ] C ) { int i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; int min_diff , current_diff , max_term ; min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
void MaximumSum ( int a [ ] , int b [ ] , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } System . out . println ( sum1 + sum2 ) ; }
int minAdjustmentCost ( int A [ ] , int n , int target ) { int [ ] [ ] dp = new int [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
void checkSamePosition ( int [ ] arr , int n ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . get ( temp ) == null ) { System . out . println ( " Yes " ) ; return ; } mp . get ( temp + 1 ) ; } System . out . println ( " No " ) ; }
long firstkdigits ( int n , int k ) { long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / Math . pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; }
int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
int minswaps ( int arr [ ] , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; }
void maximum_pallindromic ( int arr [ ] ) { int res = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res += arr [ i ] / 3 ; arr [ i ] = arr [ i ] % 3 ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += Math . min ( c1 , c2 ) ; int t = Math . min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * ( c2 / 3 ) ; c2 %= 3 ; res += c2 / 2 ; System . out . print ( res ) ; }
void ASCIISentence ( String str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str . charAt ( i ) ; System . out . print ( convert ) ; } }
int minDifference ( int x , int y , int k , int b [ ] [ ] , int c [ ] [ ] ) { if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { int diff = b [ x ] [ y ] - c [ x ] [ y ] ; return Math . min ( Math . abs ( k - diff ) , Math . abs ( k + diff ) ) ; } int ans = dp [ x ] [ y ] [ k ] ; if ( ans != - 1 ) return ans ; ans = INT_MAX ; int diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k - diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k - diff ) , b , c ) ) ; return ans ; }
int sumMax ( int i , int arr [ ] , int n ) { if ( i >= n - 1 ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) ; return dp [ i ] ; }
int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }
boolean Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; }
double findAverageOfCube ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; }
int numPrimeArrangements ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( int factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } int primeIndices = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; int mod = ( int ) ( 1e9 + 7 ) , res = 1 ; for ( int i = 1 ; i <= primeIndices ; i ++ ) res = ( int ) ( ( 1L * res * i ) % mod ) ; for ( int i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( int ) ( ( 1L * res * i ) % mod ) ; return res ; }
int deleteElement ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; int prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { int curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
int countSequences ( int arr [ ] , int n ) { int count = 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }
int series ( int n ) { return ( 8 * n * n ) + 1 ; }
void maxSum ( int [ ] a , int n ) { Vector < Integer > l = new Vector < Integer > ( ) ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . add ( i + 1 ) ; else { l . add ( i + 1 ) ; l . add ( i ) ; } } System . out . println ( s ) ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) System . out . print ( l . get ( i ) + " ▁ " ) ; }
void smallerNumbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count ++ ; } } System . out . print ( count + " ▁ " ) ; } }
void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " ▁ " ) ; }
int findMinDif ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }
int minimumcntOperationReq ( int arr [ ] , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }
boolean isSumCube ( int N ) { int a = ( int ) Math . cbrt ( N ) ; int b = a - 1 ; return ( ( a * a * a + b * b * b ) == N ) ; }
int countPairs ( String s1 , int n1 , String s2 , int n2 ) { int [ ] freq1 = new int [ 26 ] ; int [ ] freq2 = new int [ 26 ] ; Arrays . fill ( freq1 , 0 ) ; Arrays . fill ( freq2 , 0 ) ; int i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 . charAt ( i ) - ' a ' ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 . charAt ( i ) - ' a ' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( Math . min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }
int computeLastDigit ( long A , long B ) { int variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long i = A + 1 ; i <= B ; i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
int nextGreater ( int N ) { int power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
int sumOfProd ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }
void minimumOperations ( String S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S . charAt ( i ) == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } System . out . println ( ans ) ; }
int minFlips ( int mat [ ] [ ] , String s ) { int N = mat . length ; int M = mat [ 0 ] . length ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != s . charAt ( i + j ) - '0' ) { count ++ ; } } } return count ; }
int usingBinarySearch ( int start , int end , int N , int S ) { if ( start >= end ) return start ; int mid = start + ( end - start ) / 2 ; int totalSum = ( N * ( N + 1 ) ) / 2 ; int midSum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( totalSum - midSum ) <= S ) { return usingBinarySearch ( start , mid , N , S ) ; } return usingBinarySearch ( mid + 1 , end , N , S ) ; }
int find_index ( int [ ] arr , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }
void checkTriangle ( int x , int y , int z ) { if ( x == y && y == z ) System . out . println ( " Equilateral ▁ Triangle " ) ; else if ( x == y y == z z == x ) System . out . println ( " Isosceles ▁ Triangle " ) ; else System . out . println ( " Scalene ▁ Triangle " ) ; }
void printpairs ( int arr [ ] , int sum ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; ++ i ) { int temp = sum - arr [ i ] ; if ( s . contains ( temp ) ) { System . out . println ( " Pair ▁ with ▁ given ▁ sum ▁ " + sum + " ▁ is ▁ ( " + arr [ i ] + " , ▁ " + temp + " ) " ) ; } s . add ( arr [ i ] ) ; } }
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return - 1 ; Arrays . sort ( arr ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . max ( x , Math . max ( y , z ) ) ; }
int CountSubSet ( int arr [ ] , int n , int X ) { int N = ( int ) Math . pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }
void findNumbers ( int n ) { int i = 0 ; while ( i <= n ) { System . out . print ( 2 * i * i + 4 * i + 1 + i % 2 + " ▁ " ) ; i ++ ; } }
void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
void findMinSum ( int A [ ] , int K ) { int n = A . length ; int minimum_sum = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int min = Integer . MAX_VALUE ; for ( int j = i + K ; j < n ; j ++ ) min = Math . min ( min , A [ j ] ) ; if ( min == Integer . MAX_VALUE ) continue ; minimum_sum = Math . min ( minimum_sum , A [ i ] + min ) ; } System . out . println ( minimum_sum ) ; }
void redistribute ( Integer arr [ ] , int n , int x ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum / ( i + 1 ) < x ) { System . out . print ( i + "NEW_LINE"); break ; } } if ( i == n ) System . out . print ( n + "NEW_LINE"); }
int NumberOfSolutions ( int x , int y , int z , int n ) { int ans = 0 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { int temp = n - i - j ; if ( temp >= 0 ) { temp = Math . min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
long getSum ( int n , int d ) { long sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
float trianglearea ( float r ) { if ( r < 0 ) return - 1 ; return r * r ; }
long boost_hyperfactorial ( long num ) { long val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * ( long ) Math . pow ( i , i ) ; } return val ; }
void evenSubMatrix ( int N ) { int even = 1 ; int odd = 2 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( i + j ) % 2 == 0 ) { System . out . print ( even + " ▁ " ) ; even += 2 ; } else { System . out . print ( odd + " ▁ " ) ; odd += 2 ; } } System . out . println ( ) ; } }
void findRange ( int arr [ ] , int N , int K ) { int L = Integer . MIN_VALUE ; int R = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int l = ( int ) Math . ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; int r = ( int ) Math . ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = Math . max ( L , l ) ; R = Math . min ( R , r ) ; } System . out . println ( L + " ▁ " + R ) ; }
int findNthOccur ( String str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; }
int lastElement ( int arr [ ] , int n ) { int sum = 0 ; int multiplier = n % 2 == 0 ? - 1 : 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * multiplier ; multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( - 1 ) ; } return sum ; }
int findMinMoves ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return - 1 ; int avg = sum / N ; int total = 0 ; int needCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = Math . max ( Math . max ( Math . abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }
> getLudic ( int n ) { List < Integer > ludics = new ArrayList < Integer > ( n ) ; for ( int i = 1 ; i <= n ; i ++ ) ludics . add ( i ) ; for ( int index = 1 ; index < ludics . size ( ) ; index ++ ) { int first_ludic = ludics . get ( index ) ; int remove_index = index + first_ludic ; while ( remove_index < ludics . size ( ) ) { ludics . remove ( remove_index ) ; remove_index = remove_index + first_ludic - 1 ; } } return ludics ; }
int sumPairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
int min_elimination ( int n , int [ ] arr ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; }
int cntSplits ( String s ) { if ( s . charAt ( s . length ( ) - 1 ) == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) c_zero += ( s . charAt ( i ) == '0' ) ? 1 : 0 ; return ( int ) Math . pow ( 2 , c_zero - 1 ) ; }
int maxXorSum ( int n , int k ) { if ( k == 1 ) return n ; int res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
void findMidAlphabet ( String s1 , String s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int mid = ( s1 . charAt ( i ) + s2 . charAt ( i ) ) / 2 ; System . out . print ( ( char ) mid ) ; } }
void findTriangle ( long S ) { long X1 = 0 , Y1 = 0 ; long X2 = MAX , Y2 = 1 ; long X3 = ( MAX - S % MAX ) % MAX ; long Y3 = ( S + X3 ) / MAX ; System . out . println ( " ( " + X1 + " , ▁ " + Y1 + " ) " ) ; System . out . println ( " ( " + X2 + " , ▁ " + Y2 + " ) " ) ; System . out . println ( " ( " + X3 + " , ▁ " + Y3 + " ) " ) ; }
int countRhombi ( int h , int w ) { int ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
void pen_hex ( long n ) { long pn = 1 ; for ( long i = 1 ; i < n ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; double seqNum = ( 1 + Math . sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == ( long ) seqNum ) System . out . print ( pn + " , ▁ " ) ; } }
int totalCountDifference ( int n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( n / 2 ) ; }
int Solve ( int arr [ ] , int n ) { int temp = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; }
void findMaxNumbers ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int opr = ( int ) Math . ceil ( ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } System . out . println ( cnt ) ; }
int getPairs ( int a [ ] ) { int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a . length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; }
String checkPattern ( int arr [ ] , int m , int k , int n ) { int count = 1 , t = 0 ; for ( int i = 0 ; i < n - m ; i ++ ) { if ( arr [ i ] == arr [ i + m ] ) { t ++ ; if ( t == m ) { t = 0 ; count ++ ; if ( count == k ) { return " Yes " ; } } } else { t = 0 ; count = 1 ; } } return " No " ; }
void areSame ( int a , int b ) { if ( ( a - b ) == 0 ) System . out . println ( " Same " ) ; else System . out . println ( " Not ▁ Same " ) ; }
void catalan ( int n ) { int cat_ = 1 ; System . out . print ( cat_ + " ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; System . out . print ( cat_ + " ▁ " ) ; } }
void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } System . out . println ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + max_guests + " ▁ at ▁ time ▁ " + time ) ; }
void findWinner ( int X , int Y ) { int first = ( X ^ Y ) ; int second = ( X + Y ) ; if ( first == second ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } }
int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }
boolean pronic_check ( int n ) { int x = ( int ) ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
int minLength ( int A [ ] , int N ) { int elem = A [ 0 ] , count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; }
double findPCSlope ( double m ) { return - 1.0 / m ; }
int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }
int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; }
double cyl ( double r , double h ) { if ( r < 0 && h < 0 ) return - 1 ; double R = ( 2 * r ) / 3 ; double H = ( 2 * h ) / 3 ; double V = 3.14 * Math . pow ( R , 2 ) * H ; return V ; }
int minCost ( int coin [ ] , int n , int k ) { Arrays . sort ( coin ) ; int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . length ; int [ ] b = solve ( arr , n ) ; System . out . println ( Arrays . toString ( b ) ) ; } }
int countValues ( int n ) { int unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
int count ( int a [ ] , int M , int N ) { int cnt = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; }
void removeElements ( int [ ] arr , int n ) { int [ ] brr = new int [ n ] ; int l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) System . out . print ( brr [ i ] + " ▁ " ) ; }
int countZeroes ( int mat [ ] [ ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }
int length_substring ( String S , char K ) { int curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == K ) { curr_cnt += 1 ; } else { prev_cnt = Math . max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = Math . max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; }
int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
int icosikaipentagonNum ( int N ) { return ( 23 * N * N - 21 * N ) / 2 ; }
int countTrailingZero ( int x ) { int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; }
void findkth ( int n , int k ) { Vector < Integer > v1 = new Vector < Integer > ( ) ; Vector < Integer > v2 = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . add ( i ) ; if ( i != Math . sqrt ( n ) ) v2 . add ( n / i ) ; } } Collections . reverse ( v2 ) ; if ( k > ( v1 . size ( ) + v2 . size ( ) ) ) System . out . print ( " Doesn ' t ▁ Exist " ) ; else { if ( k <= v1 . size ( ) ) System . out . print ( v1 . get ( k - 1 ) ) ; else System . out . print ( v2 . get ( k - v1 . size ( ) - 1 ) ) ; } }
double heptdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.802 * a ; return d ; }
boolean asPowerSum ( int w , int m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
boolean CheckBinaryEquivalent ( int N ) { return ( N - 1 ) % 8 == 0 ; }
int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
long SmallestPerfectSquare ( long N ) { long X = ( long ) 1e9 ; long ans ; for ( int i = 1 ; i < Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { long a = i ; long b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = Math . min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = - 1 ; return ans ; }
int speedOfTrain ( float X , float Y ) { float Speed ; Speed = 1188 * ( ( X - Y ) / Y ) ; return ( int ) Speed ; }
void findNthNumber ( int N ) { int [ ] arr = new int [ N + 1 ] ; Queue < Integer > q = new LinkedList < > ( ) ; for ( int i = 1 ; i <= 9 ; i ++ ) q . add ( i ) ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i ] = q . peek ( ) ; q . remove ( ) ; if ( arr [ i ] % 10 != 0 ) q . add ( arr [ i ] * 10 + arr [ i ] % 10 - 1 ) ; q . add ( arr [ i ] * 10 + arr [ i ] % 10 ) ; if ( arr [ i ] % 10 != 9 ) q . add ( arr [ i ] * 10 + arr [ i ] % 10 + 1 ) ; } System . out . println ( arr [ N ] ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
void minimumCost ( int arr [ ] , int cost [ ] , int N ) { int [ ] [ ] dp = new int [ N ] [ 3 ] ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = cost [ 0 ] ; dp [ 0 ] [ 2 ] = cost [ 0 ] * 2 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int minimum = ( int ) 1e6 ; if ( j + arr [ i ] != arr [ i - 1 ] ) minimum = Math . min ( minimum , dp [ i - 1 ] [ 0 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 1 ) minimum = Math . min ( minimum , dp [ i - 1 ] [ 1 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 2 ) minimum = Math . min ( minimum , dp [ i - 1 ] [ 2 ] ) ; dp [ i ] [ j ] = j * cost [ i ] + minimum ; } } int ans = ( int ) 1e6 ; for ( int i = 0 ; i < 3 ; i ++ ) ans = Math . min ( ans , dp [ N - 1 ] [ i ] ) ; System . out . print ( ans + "NEW_LINE"); }
int minNum ( int n , int k ) { int x = ( int ) ( Math . log ( n ) / Math . log ( k ) ) + 1 ; int mn = ( int ) ( Math . pow ( k , x ) - n ) ; return mn ; }
int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }
int smallestNum ( int n ) { return ( int ) ( ( n * n % 9 + 1 ) * Math . pow ( 10 , n * n / 9 ) - 1 ) ; }
int no_of_ways ( int a [ ] , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
int getCount ( char [ ] str , int n ) { int cnt = 0 ; int i = 0 ; while ( i < n - 2 ) { if ( str [ i ] == str [ i + 1 ] && str [ i ] == str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else { i ++ ; } } return cnt ; }
int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int nthEnneadecagonal ( int n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
long countStr ( int N ) { long dp [ ] [ ] = new long [ N + 1 ] [ 3 ] ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } long ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
int FindIndexKthBit ( int n , int k ) { int cnt = 0 ; int ind = 0 ; while ( n > 0 ) { if ( ( n & 1 ) != 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; }
int minDistance ( int n1 , int n2 ) { int bitCount1 = ( int ) Math . floor ( ( Math . log ( n1 ) / Math . log ( 2 ) ) ) + 1 ; int bitCount2 = ( int ) Math . floor ( ( Math . log ( n2 ) / Math . log ( 2 ) ) ) + 1 ; int bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = ( int ) Math . floor ( ( Math . log ( xorValue ) / Math . log ( 2 ) ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
void minCost ( char arr [ ] [ ] , int A , int B ) { int n = arr . length ; int m = arr [ 0 ] . length ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == ' * ' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i ] [ j + 1 ] == ' . ' ) { ans += Math . min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } System . out . println ( ans ) ; }
int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
void sumOfSquaredDifferences ( int arr [ ] , int N ) { int ans = 0 ; int sumA = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; System . out . println ( ans ) ; }
int maxSum ( int [ ] a , int n ) { int ans = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int [ ] [ ] dp = new int [ n + 1 ] [ 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
void smallestNumber ( int N ) { int L = ( int ) ( Math . pow ( 10 , N ) - 1 ) ; int S = ( int ) Math . pow ( 10 , N - 1 ) ; for ( int i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { System . out . print ( i ) ; return ; } } }
void findPairs ( int [ ] x , int [ ] y , int K ) { int n = x . length ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( K * Math . abs ( x [ i ] - x [ j ] ) >= Math . abs ( y [ i ] - y [ j ] ) ) { ++ ans ; } } } System . out . print ( ans ) ; }
int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
int Circumference ( int a ) { return 4 * a ; }
boolean solve ( int n , int k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; }
int pad ( int n ) { padv [ 0 ] = padv [ 1 ] = padv [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { padv [ i ] = padv [ i - 2 ] + padv [ i - 3 ] ; } return padv [ n - 1 ] ; }
int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
int findLength ( String str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
void countWaysToTileBoard ( int N ) { int dp [ ] = new int [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } System . out . print ( dp [ N ] ) ; }
void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } System . out . println ( " Minimal ▁ Value ▁ = ▁ " + smallest ) ; System . out . println ( " Total ▁ Pairs ▁ = ▁ " + count ) ; }
char ShortestPalindrome ( String s ) { int n = s . length ( ) ; char ans = s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( char ) Math . min ( ans , s . charAt ( i ) ) ; } return ans ; }
int findLeastDist ( int A [ ] , int N ) { Arrays . sort ( A ) ; if ( N % 2 == 0 ) { return A [ ( N - 1 ) / 2 ] ; } else { return A [ N / 2 ] ; } }
int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
int maxDP ( int n ) { int res [ ] = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }
long LastTwoDigit ( long num ) { long one = num % 10 ; num /= 10 ; long tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
float trapezoidarea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 3 * ( float ) Math . sqrt ( 3 ) * ( float ) Math . pow ( r , 2 ) ) / 4 ; return a ; }
long sum ( long n ) { long root = ( long ) Math . sqrt ( n ) ; long ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }
int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; }
long F ( long A , long B ) { if ( A == 1 ) return ( 4 % B ) ; else { long temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
float productOfGP ( float a , float r , int n ) { return ( float ) Math . pow ( a , n ) * ( float ) Math . pow ( r , n * ( n - 1 ) / 2 ) ; }
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { System . out . print ( ( ( 2 * i ) - 1 ) + " ▁ " ) ; i ++ ; } }
boolean checkStar ( int mat [ ] [ ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] == 1 ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
boolean isDiagonalMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
int minSteps ( int N ) { int res = ( ( int ) Math . sqrt ( 1 + 8 * N ) - 1 ) / 2 ; return res ; }
long noOfTriples ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; long count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + Math . min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; }
void checkIfCurzonNumber ( long N ) { double powerTerm , productTerm ; powerTerm = Math . pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }
void performQuery ( int arr [ ] , int Q [ ] [ ] ) { for ( int i = 0 ; i < Q . length ; i ++ ) { int or = 0 ; int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( int j = 0 ; j < arr . length ; j ++ ) { or = or | arr [ j ] ; } System . out . print ( or + " ▁ " ) ; } }
int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }
void mirror_point ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; System . out . print ( " x3 ▁ = ▁ " + x3 + " ▁ " ) ; System . out . print ( " y3 ▁ = ▁ " + y3 + " ▁ " ) ; System . out . print ( " z3 ▁ = ▁ " + z3 + " ▁ " ) ; }
int maxLen ( int arr [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; Integer prev_i = hM . get ( sum ) ; if ( prev_i != null ) max_len = Math . max ( max_len , i - prev_i ) ; else hM . put ( sum , i ) ; } return max_len ; }
int countXORSetBitsAdjElemRange1_N ( int N ) { int total_set_bits = 0 ; int bit_Position = 1 ; while ( N != 0 ) { total_set_bits += ( ( N + 1 ) / 2 * bit_Position ) ; N -= ( N + 1 ) / 2 ; bit_Position ++ ; } return total_set_bits ; }
void printArray ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; flag = 1 ; l = i ; } { for ( i = r ; i > r - k && i >= l ; i -- ) System . out . print ( arr [ i ] + " ▁ " ) ; flag = 0 ; r = i ; } k ++ ; } }
void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int [ ] [ ] countDP = new int [ R ] [ C ] ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } System . out . print ( ans + "NEW_LINE"); } }
float hexagonArea ( float d ) { return ( float ) ( ( 3 * Math . sqrt ( 3 ) * d * d ) / 8 ) ; }
void tripletAndSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } System . out . println ( ans ) ; }
int smallestIndex ( int [ ] a , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; }
boolean isMultipleof5 ( int n ) { char str [ ] = new char [ MAX ] ; int len = str . length ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; }
void triangleArea ( float a , float b ) { if ( a < 0 b < 0 ) { System . out . println ( - 1 ) ; return ; } float area = ( 3 * ( float ) Math . sqrt ( 3 ) * a * b ) / ( 4 ) ; System . out . println ( area ) ; }
void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & N ) > 0 ) { result ++ ; } } System . out . println ( result ) ; }
void precomputation ( int arr [ ] , int n ) { for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( sum3 [ arr [ i ] ] + " ▁ " ) ; }
int findMinSoln ( int n , int k ) { int minSoln = Integer . MAX_VALUE ; for ( int i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = Math . min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; }
int countPairs ( int a [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) us . add ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . contains ( x - arr2 [ j ] ) ) count ++ ; return count ; }
void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) Math . pow ( ( X2 - X1 ) , 2 ) + ( int ) Math . pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) Math . pow ( ( X3 - X2 ) , 2 ) + ( int ) Math . pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) Math . pow ( ( X3 - X1 ) , 2 ) + ( int ) Math . pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 && B > 0 && C > 0 ) && ( A == ( B + C ) || B == ( A + C ) || C == ( A + B ) ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
int solve ( int [ ] A , int n , int Q [ ] , int q ) { int one = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; int glows = 0 , count = 0 ; if ( one >= ( int ) Math . ceil ( n / 2 ) ) glows = 1 ; for ( int i = 0 ; i < q ; i ++ ) { int prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= ( int ) Math . ceil ( n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; }
int numberOfPairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; }
void ans ( int n ) { if ( n == 1 ) System . out . println ( "1" ) ; else System . out . println ( "0" ) ; }
int solve ( int [ ] a , int n ) { int max1 = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }
long countPairsBruteForce ( long X [ ] , long Y [ ] , int m , int n ) { long ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( Math . pow ( X [ i ] , Y [ j ] ) > Math . pow ( Y [ j ] , X [ i ] ) ) ans ++ ; return ans ; }
void numberOfPermWithKInversion ( int N , int K ) { int [ ] [ ] dp = new int [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else { int maxm = Math . max ( j - ( i - 1 ) ) ; dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( Math . max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ maxm , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } } System . out . println ( dp [ N % 2 ] [ K ] ) ; }
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int findMinDenomin ( int n ) { return ( ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ) ; }
int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
int breakSum ( int n ) { if ( n == 0 n == 1 ) return n ; return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }
void mul_table ( int N , int i ) { if ( i > 10 ) return ; System . out . println ( N + " ▁ * ▁ " + i + " ▁ = ▁ " + N * i ) ; mul_table ( N , i + 1 ) ; }
int No_of_Triangle ( int N , int K ) { if ( N < K ) return - 1 ; else { int Tri_up = 0 ; Tri_up = ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ; int Tri_down = 0 ; Tri_down = ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ; return Tri_up + Tri_down ; } }
int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; }
int minimum ( int n ) { int product = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
int findValue ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; }
int MaxXOR ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; }
int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( Math . max ( X , Y ) / Math . min ( X , Y ) ) ; else return ( Math . max ( 2 * X , Y ) / Math . min ( 2 * X , Y ) ) ; }
int maxLength ( int a [ ] , int n ) { int maxLen = 0 ; int prev_cnt = 0 , curr_cnt = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = Math . max ( maxLen , Math . min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; }
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; }
int firstDigit ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; }
int Nth_of_AP ( int a , int d , int N ) { return ( a + ( N - 1 ) * d ) ; }
int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
void count_unique ( HashSet < Integer > s , int n ) { if ( s . contains ( n ) ) return ; s . add ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = n / 10 ; } count_unique ( s , n ) ; }
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
int minChanges ( int [ ] A , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * ( int ) ( Math . pow ( 2 , ( r - 2 ) ) ) ; int d = ( int ) ( Math . pow ( 2 , ( r - 1 ) ) ) ; c = c - r ; int element = a + d * c ; return element ; }
int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
double calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; double sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
void PrintMinNumberForPattern ( String seq ) { String result = " " ; Stack < Integer > stk = new Stack < Integer > ( ) ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) || seq . charAt ( i ) == ' I ' ) { while ( ! stk . empty ( ) ) { result += String . valueOf ( stk . peek ( ) ) ; result += " ▁ " ; stk . pop ( ) ; } } } System . out . println ( result ) ; }
void checkPalindrome ( int num ) { String str = Integer . toString ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { System . out . print ( " No " ) ; return ; } l ++ ; r -- ; } System . out . print ( " Yes " ) ; return ; }
void countSubarrays ( int A [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } System . out . print ( ans + "NEW_LINE"); }
void findNthNum ( int N ) { int bit_L = 1 , last_num = 0 ; while ( bit_L * ( bit_L + 1 ) / 2 < N ) { last_num = last_num + bit_L ; bit_L ++ ; } int bit_R = N - last_num - 1 ; System . out . print ( ( 1 << bit_L ) + ( 1 << bit_R ) + "NEW_LINE"); }
int countUnsetBits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp > 0 ) { if ( temp % 2 == 0 ) { cnt = cnt + 1 ; } temp = temp / 2 ; } } return cnt ; }
int count_elements ( int arr [ ] , int n ) { int count = 1 ; int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; }
int rotate ( int arr [ ] , int N , int X ) { long nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return ( int ) nextPower - N ; long prevPower = nextPower / 2 ; return 2 * ( N - ( int ) prevPower ) + 1 ; }
int countX ( int n ) { String binary = Integer . toBinaryString ( n ) ; int count = 0 ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { if ( binary . charAt ( i ) == '1' ) count ++ ; } int answer = ( int ) Math . pow ( 2 , count ) ; return answer ; }
void odd_even ( int arr [ ] , int n ) { Vector < Integer > odd_indexes = new Vector < Integer > ( ) ; Vector < Integer > even_indexes = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . add ( arr [ i ] ) ; else even_indexes . add ( arr [ i ] ) ; } Collections . sort ( odd_indexes ) ; Collections . sort ( even_indexes ) ; for ( int i = 0 ; i < odd_indexes . size ( ) ; i ++ ) System . out . print ( odd_indexes . get ( i ) + " ▁ " ) ; for ( int i = 0 ; i < even_indexes . size ( ) ; i ++ ) System . out . print ( even_indexes . get ( i ) + " ▁ " ) ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
void pendulumArrangement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int op [ ] = new int [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; System . out . println ( " Pendulum ▁ arrangement : " ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( op [ i ] + " ▁ " ) ; System . out . println ( ) ; }
void findEquation ( int A , int B , int C , int K ) { System . out . print ( A + " ▁ " + K * B + " ▁ " + K * K * C ) ; }
float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
int get_subset_count ( int arr [ ] , int K , int N ) { Arrays . sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; }
void gouldSequence ( int n ) { for ( int row_num = 1 ; row_num <= n ; row_num ++ ) { int count = 1 ; int c = 1 ; for ( int i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } System . out . print ( count + " ▁ " ) ; } }
void printPairs ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) System . out . println ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " ) ; }
void generateString ( int K ) { String s = " " ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + ( char ) ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += ( char ) ( i ) ; s += ( char ) ( j ) ; } } s += ( char ) ( 97 ) ; System . out . println ( s ) ; }
double ReuleauxArea ( double a ) { if ( a < 0 ) return - 1 ; double A = 0.70477 * Math . pow ( a , 2 ) ; return A ; }
int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
void printMaxNumber ( int n ) { if ( n % 2 != 0 ) { System . out . print ( "7" ) ; for ( int i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) System . out . print ( "1" ) ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) System . out . print ( "1" ) ; } }
int evenSum ( int n ) { int curr = 2 , sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
void profitLoss ( int N , int M ) { if ( N == M ) System . out . print ( " No ▁ Profit ▁ nor ▁ Loss " ) ; else { float result = 0 ; result = ( float ) ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) System . out . print ( " Loss ▁ = ▁ - " + result * 100 + " % " ) ; else System . out . print ( " Profit ▁ = ▁ " + result * 100 + " % " ) ; } }
int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != - 1 ) return dp [ k ] [ col ] ; int sum = 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; }
int breakSum ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
int countChar ( String str ) { int n = str . length ( ) ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( i + 1 ) ) count ++ ; return count ; }
int firstFactorialDivisibleNumber ( int x ) { int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
int maxSum ( int arr [ ] , int n , int K ) { int maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ; for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . max ( maximum , sumk ) ; } return maximum ; }
void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) % 2 > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } System . out . print ( " The ▁ number ▁ after ▁ unsetting ▁ the " ) ; System . out . print ( " ▁ rightmost ▁ set ▁ bit ▁ " + n ) ; }
void minBox ( int arr [ ] , int n ) { int box = n ; Arrays . sort ( arr ) ; int curr_box = 0 , next_box = 1 ; while ( curr_box < n && next_box < n ) { if ( arr [ curr_box ] < arr [ next_box ] ) { box -- ; curr_box ++ ; next_box ++ ; } else if ( arr [ curr_box ] == arr [ next_box ] ) next_box ++ ; } System . out . println ( box ) ; }
String multiply ( String num1 , String num2 ) { int n1 = num1 . length ( ) ; int n2 = num2 . length ( ) ; if ( n1 == 0 n2 == 0 ) return "0" ; int [ ] result = new int [ n1 + n2 ] ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n_1 = num1 . charAt ( i ) - '0' ; i_n2 = 0 ; for ( int j = n2 - 1 ; j >= 0 ; j -- ) { int n_2 = num2 . charAt ( j ) - '0' ; int sum = n_1 * n_2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = " " ; while ( i >= 0 ) s += Integer . toString ( result [ i -- ] ) ; return s ; }
int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
void findpair ( int l , int r ) { int c = 0 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { System . out . println ( i + " , ▁ " + j ) ; c = 1 ; break ; } } if ( c == 1 ) break ; } }
void ConstArrayAdjacentCoprime ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( i + " ▁ " ) ; } }
void uniqueElement ( int arr [ ] ) { int x = arr [ 0 ] ; int flag = 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] != x ) { flag = 0 ; break ; } } if ( flag == 1 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
int maxSumLCM ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
void printTetra ( int n ) { int [ ] dp = new int [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; System . out . print ( dp [ n ] ) ; }
void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; System . out . println ( remainder ) ; }
int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
int countTriangles ( int a [ ] , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; }
int firstRepeating ( String str ) { boolean [ ] visited = new boolean [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) visited [ i ] = false ; int res = - 1 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( visited [ str . charAt ( i ) ] == false ) visited [ str . charAt ( i ) ] = true ; else res = i ; } return res ; }
int countReduce ( String str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += Math . abs ( str . charAt ( i ) - str . charAt ( n - i - 1 ) ) ; return res ; }
int minCost ( int arr [ ] , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . min ( count_even , count_odd ) ; }
int swapBitsInPair ( int x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
double calculateProbability ( int N ) { double probability = ( double ) N / ( N + 1 ) ; return probability ; }
void printAlter ( int [ ] arr , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { System . out . print ( arr [ currIndex ] + " ▁ " ) ; } } }
int reversDigits ( int num ) { if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
int findMinSum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int minsum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; }
boolean isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
int countStrings ( int n ) { int a [ ] = new int [ n ] , b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
float find ( int N , int sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( float ) ( 1.0 / 6 ) ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; }
int remainder ( String str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str . charAt ( i ) - '0' ) ; rem = num % 11 ; } return rem ; }
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
int minCoins ( int coins [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == Integer . MAX_VALUE ) return - 1 ; return table [ V ] ; }
int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
int maxDiffSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int maxVal = arr [ i ] , minVal = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { minVal = Math . min ( minVal , arr [ j ] ) ; maxVal = Math . max ( maxVal , arr [ j ] ) ; if ( j - 1 >= 0 ) dp [ i ] = Math . max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , maxVal - minVal ) ; } } return dp [ n - 1 ] ; }
void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; System . out . print ( " Following ▁ activities ▁ are ▁ selected ▁ : ▁ n " ) ; i = 0 ; System . out . print ( i + " ▁ " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { System . out . print ( j + " ▁ " ) ; i = j ; } } }
int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; }
void findVolume ( double u , double v , double w , double U , double V , double W , double b ) { double uPow = Math . pow ( u , 2 ) ; double vPow = Math . pow ( v , 2 ) ; double wPow = Math . pow ( w , 2 ) ; double UPow = Math . pow ( U , 2 ) ; double VPow = Math . pow ( V , 2 ) ; double WPow = Math . pow ( W , 2 ) ; double a = 4 * ( uPow * vPow * wPow ) - uPow * Math . pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * Math . pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * Math . pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; double vol = Math . sqrt ( a ) ; vol /= b ; System . out . printf ( " % .4f " , vol ) ; }
int lenOfLongZigZagArr ( int a [ ] , int n ) { int max = 1 , len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && ( a [ i ] < a [ i + 1 ] ) ) len ++ ; else if ( i % 2 == 1 && ( a [ i ] > a [ i + 1 ] ) ) len ++ ; else { if ( max < len ) max = len ; len = 1 ; } } if ( max < len ) max = len ; return max ; }
void lengtang ( double r1 , double r2 ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ " + " direct ▁ common ▁ tangent ▁ is ▁ " + ( 2 * Math . sqrt ( r1 * r2 ) ) ) ; }
void printMinDiffPairs ( int arr [ ] , int n ) { if ( n <= 1 ) return ; Arrays . sort ( arr ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { System . out . print ( " ( " + arr [ i - 1 ] + " , ▁ " + arr [ i ] + " ) , " ) ; } } }
int solve ( int A [ ] , int N ) { int i = 0 ; int k = 0 ; for ( int j = 1 ; j < N ; j ++ ) { int tempK = Math . min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
int lds ( Integer arr [ ] , int n ) { Integer lds [ ] = new Integer [ n ] ; lds [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lds [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( lds [ j ] != 0 && arr [ i ] % arr [ j ] == 0 ) lds [ i ] = Math . max ( lds [ i ] , lds [ j ] + 1 ) ; } int max = ( int ) Collections . max ( Arrays . asList ( lds ) ) ; return max ; }
int findCount ( int arr [ ] , int n ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { count ++ ; } else { ans = ans + count ; } } return ans ; }
int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }
double octadiagonal ( double a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; }
int minOperations ( int N ) { double x = Math . log ( N ) / Math . log ( 2 ) ; int ans = ( int ) ( Math . ceil ( x ) ) ; return ans ; }
boolean checkPalindrome ( String str ) { int n = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str . charAt ( i ) != str . charAt ( n - i - 1 ) ) ++ count ; return ( count <= 1 ) ; }
int catalanDP ( int n ) { int catalan [ ] = new int [ n + 2 ] ; catalan [ 0 ] = 1 ; catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } return catalan [ n ] ; }
void printsubset ( int n , int k ) { int count = 0 , x = 0 ; ArrayList < Integer > vec = new ArrayList < > ( ) ; while ( n != 0 ) { x = n & 1 ; if ( x != 0 ) { vec . add ( ( int ) Math . pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) System . out . print ( vec . get ( i ) + " ▁ " ) ; }
void calcSum ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i <= n - k ; i ++ ) { int sum = 0 ; for ( int j = i ; j < k + i ; j ++ ) sum += arr [ j ] ; System . out . print ( sum + " ▁ " ) ; } }
int splitArray ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int result = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
boolean validate ( long n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long temp = n ; int count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
boolean isCenteredheptagonal ( int N ) { double n = ( 7 + Math . sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
int minOperations ( String s , String t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == t . charAt ( i ) ) continue ; if ( s . charAt ( i ) == '0' ) ct0 ++ ; else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; }
void countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } System . out . println ( even_sum ) ; }
boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
void reverse ( String str , int x ) { int n = ( str . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x - 1 ; i >= n ; i -- ) System . out . print ( str . charAt ( i ) ) ; for ( int i = n + x ; i < str . length ( ) ; i ++ ) System . out . print ( str . charAt ( i ) ) ; }
void findNthTerm ( int n ) { System . out . println ( n * ( 4 * n + 3 ) ) ; }
void maxPairs ( int [ ] nums , int k ) { Arrays . sort ( nums ) ; int result = 0 ; int start = 0 , end = nums . length - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } System . out . println ( result ) ; }
int sumOfProductOfDigits ( int n1 , int n2 ) { int sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 /= 10 ; n2 /= 10 ; } return sum ; }
boolean check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; }
double Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 ; double p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
int minOperations ( int n , int m ) { int a = 0 , k = 1 ; int p = Math . max ( n , m ) ; while ( n != m ) { float s = ( float ) ( p - n + p - m ) ; float q = ( float ) ( ( - 1 + Math . sqrt ( 8 * s + 1 ) ) / 2 ) ; if ( q - Math . floor ( q ) == 0 ) { a = ( int ) q ; n = m ; } p = p + 1 ; } return a ; }
int find_distance ( int n ) { return n * ( 3 * n + 7 ) ; }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
void countNum ( int N ) { int ans = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; System . out . println ( ans ) ; }
int modInverse ( int a , int m ) { for ( int x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; return 1 ; }
int countIntervals ( int [ ] [ ] arr , int V , int N ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; int li , ri ; int [ ] freq = new int [ MAX_VAL ] ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
int numberOf2sinRange ( int n ) { String s = " " ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += String . valueOf ( i ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '2' ) { count ++ ; } } return count ; }
void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int min_changes ( int a [ ] , int n ) { int ans_a = 0 , ans_b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] == 0 ) ans_a ++ ; else ans_b ++ ; } else { if ( a [ i ] == 0 ) ans_b ++ ; else ans_a ++ ; } } return Math . min ( ans_a , ans_b ) ; }
int Preprocess ( String A , String B ) { int n = A . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { HashMap < Character , Integer > mp = new HashMap < > ( ) ; if ( mp . containsKey ( A . charAt ( i ) ) ) mp . put ( A . charAt ( i ) , mp . get ( A . charAt ( i ) ) + 1 ) ; else mp . put ( A . charAt ( i ) , 1 ) ; if ( mp . containsKey ( A . charAt ( n - i - 1 ) ) ) mp . put ( A . charAt ( n - i - 1 ) , mp . get ( A . charAt ( n - i - 1 ) ) + 1 ) ; else mp . put ( A . charAt ( n - i - 1 ) , 1 ) ; if ( mp . containsKey ( B . charAt ( i ) ) ) mp . put ( B . charAt ( i ) , mp . get ( B . charAt ( i ) ) + 1 ) ; else mp . put ( B . charAt ( i ) , 1 ) ; if ( mp . containsKey ( B . charAt ( n - i - 1 ) ) ) mp . put ( B . charAt ( n - i - 1 ) , mp . get ( B . charAt ( n - i - 1 ) ) + 1 ) ; else mp . put ( B . charAt ( n - i - 1 ) , 1 ) ; int sz = mp . size ( ) ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A . charAt ( i ) == A . charAt ( n - i - 1 ) ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp . get ( A . charAt ( i ) ) != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A . charAt ( n / 2 ) != B . charAt ( n / 2 ) ) ans ++ ; return ans ; }
void pattern ( String str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { int j = len - 1 - i ; for ( int k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) System . out . print ( str . charAt ( k ) ) ; else System . out . print ( " ▁ " ) ; } System . out . println ( " " ) ; } }
boolean isValid ( String str , int n ) { if ( ! ( ( str . charAt ( 0 ) >= ' a ' && str . charAt ( 0 ) <= ' z ' ) || ( str . charAt ( 0 ) >= ' A ' && str . charAt ( 0 ) <= ' Z ' ) || str . charAt ( 0 ) == ' _ ' ) ) return false ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( ! ( ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) || ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) || ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) || str . charAt ( i ) == ' _ ' ) ) return false ; } return true ; }
void findMinXORSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } System . out . println ( min_xor ) ; }
int maximumCount ( int arr [ ] , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd > 0 && even > 0 ) return N - 2 ; else return N - 1 ; }
int minOp ( int num ) { int rem ; int count = 0 ; while ( num > 0 ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; }
int min_index ( int p [ ] , int n ) { int ans = 0 ; int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }
float area ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float A = a * b ; return A ; }
double countdigits ( int n , int k ) { if ( n == 0 ) return 0 ; int digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }
int checkpoint ( int h , int k , int x , int y , int a ) { int p = ( int ) Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
int countPair ( int a , int b ) { String s = String . valueOf ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + ( int ) Math . pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; }
int countRotation ( int n ) { int count = 0 ; do { int digit = n % 10 ; if ( digit == 0 ) count ++ ; n = n / 10 ; } while ( n != 0 ) ; return count ; }
int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ( int ) Math . ceil ( Math . log ( N ) / Math . log ( 2 ) ) ; }
void lengequichord ( int z ) { System . out . println ( " The ▁ distance ▁ between ▁ the ▁ " + " chord ▁ and ▁ the ▁ center ▁ is ▁ " + z ) ; }
void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } }
int minCount ( int n ) { int [ ] hasharr = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }
void diameter ( double r ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " + " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " + 2 * r ) ; }
int maxAlternatingSum ( int [ ] arr , int n ) { int max_sum = 0 ; int i = 0 ; while ( i < n ) { int current_max = arr [ i ] ; int k = i ; while ( k < n && ( ( arr [ i ] > 0 && arr [ k ] > 0 ) || ( arr [ i ] < 0 && arr [ k ] < 0 ) ) ) { current_max = Math . max ( current_max , arr [ k ] ) ; k += 1 ; } max_sum += current_max ; i = k ; } return max_sum ; }
void countSubstrings ( String s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; for ( char i : s . toCharArray ( ) ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } System . out . println ( ans ) ; }
void findMinimum ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 1 ; i < 2 * ( N / K ) ; i += 2 ) { ans += arr [ i ] ; } System . out . println ( ans ) ; }
int TotalAndPair ( int arr [ ] , int N ) { int totalAND = ( 1 << 30 ) - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }
String get_last_two_digit ( int N ) { if ( N % 4 == 0 ) return "01" ; else if ( N % 4 == 1 ) return "07" ; else if ( N % 4 == 2 ) return "49" ; return "43" ; }
void find_sum_of_two_squares ( int a , int b ) { int ab = a * b ; for ( int i = 0 ; i * i <= ab ; i ++ ) { for ( int j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) System . out . println ( i + " ^ 2 ▁ + ▁ " + j + " ^ 2 ▁ = ▁ " + ab ) ; } } }
int recLen ( String str ) { if ( str . equals ( " " ) ) return 0 ; else return recLen ( str . substring ( 1 ) ) + 1 ; }
int maxValue ( int a [ ] , int n , int pos , int moves , int left , int dp [ ] [ ] ) { if ( moves == 0 || ( pos > n - 1 pos < 0 ) ) return 0 ; if ( dp [ pos ] [ left ] != - 1 ) return dp [ pos ] [ left ] ; int value = 0 ; if ( left > 0 && pos >= 1 ) value = Math . max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) ; if ( pos <= n - 1 ) value = Math . max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) ; return dp [ pos ] [ left ] = value ; }
int cal ( int n ) { double res = Math . pow ( Math . ceil ( ( Math . pow ( Math . pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return ( int ) res ; }
long findSum ( int n ) { long sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }
void checkTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) System . out . println ( " No " ) ; else System . out . println ( " Yes " ) ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
int count ( int n ) { return ( int ) ( 15 * Math . pow ( 16 , n - 1 ) ) ; }
void anglechordtang ( int z ) { System . out . print ( " The ▁ angle ▁ between ▁ tangent " + " ▁ and ▁ the ▁ chord ▁ is ▁ " + z + " ▁ degrees " ) ; }
int minNum ( int arr [ ] , int n ) { Boolean odd = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
int findEle ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; }
boolean isDivisible ( int arr [ ] , int n ) { int lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; }
void minAND ( int [ ] arr , int n ) { int s = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } System . out . println ( s ) ; }
int findLastIndex ( String str , Character x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; }
int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= ( int ) ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; }
int getMinOps ( int [ ] arr ) { int res = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { res += Math . max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; }
int longestGP ( int A [ ] , int N ) { if ( N < 2 ) return N ; int length = 1 , common_ratio = 1 ; int maxlength = 1 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = Math . max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = Math . max ( maxlength , length ) ; length = 1 ; } } maxlength = Math . max ( maxlength , length ) ; return maxlength ; }
void countSubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } System . out . println ( count ) ; }
String isTriangleExists ( int a , int b , int c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " YES " ; else return " NO " ; else return " NO " ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
boolean isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }
void findNthTerm ( int n ) { System . out . print ( n * ( 3 * n + 1 ) / 2 + "NEW_LINE"); }
int MinRemove ( int [ ] a , int n , int k ) { int [ ] cnt = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }
int decideWinner ( int [ ] a , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
void findDistinctOddSum ( int n , int k ) { if ( ( k * k ) <= n && ( n + k ) % 2 == 0 ) { int val = 1 ; int sum = 0 ; for ( int i = 1 ; i < k ; i ++ ) { System . out . print ( val + " ▁ " ) ; sum += val ; val += 2 ; } System . out . print ( n - sum + "NEW_LINE"); } else System . out . print ( "NO NEW_LINE"); }
int minElements ( int arr [ ] , int N , int K ) { int count = 0 ; long requiredNum = 1 ; int i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }
int factorialWithoutMul ( int N ) { int ans = N ; for ( int i = N - 1 ; i > 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; System . out . print ( num + " ▁ " ) ; } }
int sumofsquare ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
String findString ( int n , int k ) { String res = " " ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' a ' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
int minimumIncrease ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; Arrays . sort ( arr ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
boolean sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }
void quadrant ( int x , int y ) { if ( x > 0 && y > 0 ) System . out . println ( " lies ▁ in ▁ First ▁ quadrant " ) ; else if ( x < 0 && y > 0 ) System . out . println ( " lies ▁ in ▁ Second ▁ quadrant " ) ; else if ( x < 0 && y < 0 ) System . out . println ( " lies ▁ in ▁ Third ▁ quadrant " ) ; else if ( x > 0 && y < 0 ) System . out . println ( " lies ▁ in ▁ Fourth ▁ quadrant " ) ; else if ( x == 0 && y > 0 ) System . out . println ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) ; else if ( x == 0 && y < 0 ) System . out . println ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) ; else if ( y == 0 && x < 0 ) System . out . println ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) ; else if ( y == 0 && x > 0 ) System . out . println ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) ; else System . out . println ( " lies ▁ at ▁ origin " ) ; }
int findMax ( int num ) { byte size_of_int = 4 ; int num_copy = num ; int j = size_of_int * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
int toggleBits ( int n1 , int n2 ) { return ( n1 ^ n2 ) ; }
boolean check ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i + 1 ) ) return true ; } return false ; }
int findMaxSoln ( int n , int x , int y ) { int ans = Integer . MIN_VALUE ; for ( int k = 0 ; k <= n ; k ++ ) { if ( k % x == y ) { ans = Math . max ( ans , k ) ; } } return ( ( ans >= 0 && ans <= n ) ? ans : - 1 ) ; }
int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
boolean isFactorion ( int n ) { int fact [ ] = new int [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; }
int getHeight ( int X ) { return ( 2 * X ) ; }
int countTriplets ( int n , int sum ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; }
int findNumberOfStrings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }
int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }
void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; System . out . print ( a + " ▁ " + b + " ▁ " + c ) ; }
int minimumValue ( int N , int K ) { return ( int ) Math . ceil ( ( double ) K / ( double ) N ) ; }
int countNumbers ( int l , int r ) { return ( ( r / 2 ) - ( l - 1 ) / 2 ) ; }
int countPaths ( int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
int MinimumString ( int x ) { int b = 1 ; double left_lim = Math . sqrt ( x ) + 1.0 ; double right_lim = Math . sqrt ( x ) + 2.0 ; int r = 0 ; for ( int i = ( int ) left_lim ; i <= right_lim ; i ++ ) { if ( i > left_lim && i < right_lim ) { r = i ; break ; } } return b + r ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
void compareVal ( int x , int y ) { double a = y * Math . log ( x ) ; double b = x * Math . log ( y ) ; if ( a > b ) System . out . print ( x + " ^ " + y + " ▁ > ▁ " + y + " ^ " + x ) ; else if ( a < b ) System . out . print ( x + " ^ " + y + " ▁ < ▁ " + y + " ^ " + x ) ; else if ( a == b ) System . out . print ( x + " ^ " + y + " ▁ = ▁ " + y + " ^ " + x ) ; }
int minOperations ( int a [ ] , int b [ ] , int n ) { int minA = Arrays . stream ( a ) . min ( ) . getAsInt ( ) ; for ( int x = minA ; x >= 0 ; x -- ) { boolean check = true ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; }
boolean isComposite ( int n ) { if ( n <= 1 ) System . out . println ( " False " ) ; if ( n <= 3 ) System . out . println ( " False " ) ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
void MinimumMaximumPairs ( int n , int m ) { int max_pairs = ( ( n - m + 1 ) * ( n - m ) ) / 2 ; int min_pairs = m * ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 + ( int ) Math . ceil ( ( double ) ( ( n - m ) / ( double ) ( m ) ) ) * ( ( n - m ) % m ) ; System . out . println ( " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " + min_pairs ) ; System . out . println ( " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " + max_pairs ) ; }
int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; }
void noOfArraysPossible ( int N , int M ) { int ans = 1 ; for ( int i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } System . out . print ( ans ) ; }
int numPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; }
int minLength ( String str , int N , String K , int M ) { Stack < Character > stackOfChar = new Stack < Character > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { stackOfChar . add ( str . charAt ( i ) ) ; if ( stackOfChar . size ( ) >= M ) { String l = " " ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( K . charAt ( j ) != stackOfChar . peek ( ) ) { int f = 0 ; while ( f != l . length ( ) ) { stackOfChar . add ( l . charAt ( f ) ) ; f ++ ; } break ; } else { l = stackOfChar . peek ( ) + l ; stackOfChar . pop ( ) ; } } } } return stackOfChar . size ( ) ; }
void compareValues ( int a , int b , int c , int d ) { double log1 = Math . log10 ( a ) ; double num1 = log1 * b ; double log2 = Math . log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) System . out . println ( a + " ^ " + b ) ; else System . out . println ( c + " ^ " + d ) ; }
int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
int countIslands ( int mat [ ] [ ] , int m , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' O ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; }
void solve ( int a [ ] , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; boolean evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
void countDecrements ( long arr [ ] [ ] ) { int n = arr . length ; int m = arr [ 0 ] . length ; int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_2 ++ ; } } System . out . println ( Math . min ( count_1 , count_2 ) ) ; }
int count_numbers ( int k , int n , boolean flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , false ) + count_numbers ( k , n - 1 , true ) ) ; else return count_numbers ( k , n - 1 , true ) ; }
int countSubset ( int [ ] arr , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int t [ ] [ ] = new int [ n + 1 ] [ sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; }
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
void findMinXORSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } System . out . print ( min_xor + "NEW_LINE"); }
int countStrings ( int N ) { if ( N == 1 ) return 0 ; if ( dp . containsKey ( N ) ) return dp . get ( N ) ; int ret = 0 ; for ( int div = 1 ; div <= Math . sqrt ( N ) ; div ++ ) { if ( N % div == 0 ) { ret += ( 1 << div ) - countStrings ( div ) ; int div2 = N / div ; if ( div2 != div && div != 1 ) ret += ( 1 << div2 ) - countStrings ( div2 ) ; } } dp . put ( N , ret ) ; return ret ; }
int countDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }
int countSubsequences ( int arr [ ] ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
int lastRemaining ( int n , HashMap < Integer , Integer > dp ) { if ( dp . containsKey ( n ) ) return dp . get ( n ) ; if ( n == 1 ) return 1 ; else dp . put ( n , 2 * ( 1 + n / 2 - lastRemaining ( n / 2 , dp ) ) ) ; return dp . get ( n ) ; }
boolean isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; }
String check ( int arr [ ] , int n ) { Map < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm . put ( arr [ i ] , 1 ) ; for ( int j = i + 1 ; j < n ; j ++ ) { hm . put ( arr [ j ] , hm . getOrDefault ( arr [ j ] , 0 ) + 1 ) ; boolean flag = false ; for ( Integer k : hm . values ( ) ) { if ( k == 1 ) { flag = true ; break ; } } if ( ! flag ) return " No " ; } hm . clear ( ) ; } return " Yes " ; }
int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
boolean isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int minNumber ( int a [ ] , int n , int x ) { Arrays . sort ( a ) ; int k ; for ( k = 0 ; a [ ( n ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; Arrays . sort ( a ) ; } return k ; }
int solution ( int A , int B , int C ) { int arr [ ] = new int [ 3 ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; Arrays . sort ( arr ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }
void findXandYwithminABSX_Y ( int N ) { if ( N % 2 == 1 ) { System . out . print ( ( N / 2 ) + " ▁ " + ( N / 2 + 1 ) ) ; } else { System . out . print ( ( N / 2 - 1 ) + " ▁ " + ( N / 2 + 1 ) ) ; } }
> solve ( int n , int arr [ ] ) { String s = " aaa " ; Vector < String > ans = new Vector < String > ( ) ; ans . add ( s ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . length ( ) - 1 >= arr [ i ] ) { char ch = s . charAt ( arr [ i ] ) ; if ( ch == ' b ' ) ch = ' a ' ; else ch = ' b ' ; char [ ] myNameChars = s . toCharArray ( ) ; myNameChars [ arr [ i ] ] = ch ; s = String . valueOf ( myNameChars ) ; } ans . add ( s ) ; } return ans ; }
void sumFib ( int N ) { long num = ( long ) Math . round ( Math . pow ( ( Math . sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / Math . sqrt ( 5 ) ) ; System . out . println ( num - 1 ) ; }
String sort ( String s ) { char [ ] c = new char [ s . length ( ) + 1 ] ; c = s . toCharArray ( ) ; Arrays . sort ( c ) ; int al_c = 0 , nu_c = 0 ; while ( c [ al_c ] < 97 ) al_c ++ ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < 97 ) s = s . substring ( 0 , i ) + c [ nu_c ++ ] + s . substring ( i + 1 ) ; else s = s . substring ( 0 , i ) + c [ al_c ++ ] + s . substring ( i + 1 ) ; } return s ; }
void findPair ( int [ ] arr , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { System . out . println ( arr [ i ] + " ▁ " + arr [ j ] ) ; found = true ; } } } } if ( found == false ) System . out . println ( " Not ▁ exist " ) ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; int sqr ; for ( int i = 4 ; i <= n ; i ++ ) { sqr = ( int ) Math . sqrt ( i ) ; int best = Integer . MAX_VALUE ; while ( sqr > 1 ) { if ( i % sqr == 0 ) { best = Math . min ( best , 1 + dp [ sqr ] ) ; } sqr -- ; } best = Math . min ( best , 1 + dp [ i - 1 ] ) ; dp [ i ] = best ; } return dp [ n ] ; }
int printMaxAfterRemoval ( String s ) { boolean flag = false ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' && flag == false ) { flag = true ; continue ; } else System . out . print ( s . charAt ( i ) ) ; } return 0 ; }
int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; }
void maxFrequency ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int start = 0 , end = 0 ; int sum = 0 , res = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum += arr [ end ] ; while ( ( end - start + 1 ) * arr [ end ] - sum > K ) { sum -= arr [ start ] ; start ++ ; } res = Math . max ( res , end - start + 1 ) ; } System . out . println ( res ) ; }
long getcount ( long n , int k ) { long res = ( n >> ( k + 1 ) ) << k ; if ( ( ( n >> k ) & 1 ) != 0 ) res += n & ( ( 1 << k ) - 1 ) ; return res ; }
void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { System . out . println ( " - 1" ) ; return ; } System . out . println ( ( ( a - b ) / 2 ) + " ▁ " + ( ( a + b ) / 2 ) ) ; }
void totalInversions ( int arr [ ] , int K , int N ) { int inv = 0 ; int X = 0 ; int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] && i < j ) inv ++ ; if ( arr [ i ] > arr [ j ] ) X ++ ; } } int totalInv = X * K * ( K - 1 ) / 2 + inv * K ; System . out . println ( totalInv ) ; }
void EvenLIS ( int arr [ ] ) { int n = arr . length ; int lis [ ] = new int [ n ] ; Arrays . fill ( lis , 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( Math . abs ( arr [ i ] ) > Math . abs ( arr [ j ] ) && Math . abs ( arr [ i ] ) % 2 == 0 && Math . abs ( arr [ j ] ) % 2 == 0 && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxlen = Math . max ( maxlen , lis [ i ] ) ; System . out . println ( maxlen ) ; }
int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
int noOfWays ( int N , int K ) { String S = String . valueOf ( N ) ; int ans = 1 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { int count = 1 ; while ( i < S . length ( ) && ( int ) S . charAt ( i ) - 48 + ( int ) S . charAt ( i - 1 ) - 48 == K ) { count ++ ; i ++ ; } if ( count % 2 == 1 ) ans *= ( count + 1 ) / 2 ; } return ans ; }
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
double find_area ( int r , int d ) { double R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; double area = PI * Math . pow ( R , 2 ) ; return area ; }
int GetMinSubarrayLength ( int a [ ] , int n ) { int ans = Math . max ( a [ 0 ] , a [ n - 1 ] ) ; int lo = 0 , hi = n - 1 ; while ( lo < n && a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo && a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }
int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }
int bitwiseAndOdd ( int n ) { return 1 ; }
boolean isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; } return true ; else return false ; }
void getSum ( int n ) { boolean isOdd = ( n % 2 == 1 ) ? true : false ; int sumOdd = 0 , sumEven = 0 ; while ( n != 0 ) { if ( isOdd ) sumOdd += n % 10 ; else sumEven += n % 10 ; isOdd = ! isOdd ; n /= 10 ; } System . out . println ( " Sum ▁ odd ▁ = ▁ " + sumOdd ) ; System . out . println ( " Sum ▁ even ▁ = ▁ " + sumEven ) ; }
void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { System . out . println ( arr [ 0 ] ) ; return ; } int dp [ ] = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; System . out . println ( dp [ n - 1 ] ) ; }
int maxSum ( int arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
int getMaxDifference ( int N ) { int M = - 1 ; int maxDiff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }
void maxDivisions ( Integer arr [ ] , int N , int X ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } System . out . print ( maxSub + "NEW_LINE"); }
long findNewString ( String s ) { long ans = 0 ; int [ ] freq = new int [ 26 ] ; int n = s . length ( ) ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < ( int ) s . length ( ) ; ++ i ) { ans += freq [ s . charAt ( i ) - ' a ' ] ; freq [ s . charAt ( i ) - ' a ' ] ++ ; } return ans ; }
int maxLines ( int n , int x1 [ ] , int y1 [ ] , int x2 [ ] , int y2 [ ] ) { Set < Double > s = new HashSet < Double > ( ) ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = Integer . MAX_VALUE ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . add ( slope ) ; } return s . size ( ) ; }
int sumOddFibonacci ( int n ) { int Sum [ ] = new int [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }
int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
void maxNumTrailNine ( int n , int d ) { int res = n ; int cntDigits = ( int ) Math . log10 ( n ) + 1 ; int p10 = 10 ; for ( int i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } System . out . println ( res ) ; }
int longestsubarray ( int arr [ ] , int n , int k ) { int current_count = 0 ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . max ( current_count , max_count ) ; } return max_count ; }
int maxSubArraySum ( int a [ ] ) { int size = a . length ; int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int subtractOne ( int x ) { int m = 1 ; while ( ! ( ( x & m ) > 0 ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
void findWinner ( int n , int m ) { int X = 0 ; int Y = 0 ; if ( n >= m ) { X = n - 1 ; Y = m ; } else { X = m - 1 ; Y = n ; } if ( X > Y ) System . out . print ( " X " ) ; else if ( Y > X ) System . out . print ( " Y " ) ; else System . out . print ( " - 1" ) ; }
boolean isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; }
int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }
void printKPFNums ( int A , int B , int K ) { int p_factors [ ] = new int [ B + 1 ] ; Arrays . fill ( p_factors , 0 ) ; for ( int p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( int i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( int i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) System . out . print ( i + " ▁ " ) ; }
boolean isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
long count_Strings ( long n ) { int x = 1 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( 1 << x ) ; } return x - 1 ; }
int solve ( int x ) { int ans = 0 , first = 0 , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x != 0 ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; }
float findProb ( int l , int r ) { float countOfPS = ( float ) ( Math . floor ( Math . sqrt ( r ) ) - Math . ceil ( Math . sqrt ( l ) ) + 1 ) ; float total = r - l + 1 ; float prob = ( float ) countOfPS / ( float ) total ; return prob ; }
void countNums ( int N ) { int l = ( int ) Math . pow ( 10 , N - 1 ) , r = ( int ) Math . pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int xor = 0 , temp = i ; while ( temp > 0 ) { xor = xor ^ ( temp % 10 ) ; temp /= 10 ; } if ( xor <= 9 ) count ++ ; } System . out . println ( count ) ; }
boolean check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { return true ; } } return false ; }
int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! s . contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
int countStrings ( int n , int m , String s [ ] ) { HashSet < Integer > ind = new HashSet < Integer > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , ( int ) ( s [ i ] . charAt ( j ) - '0' ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] . charAt ( j ) - '0' == mx ) ind . add ( i ) ; } return ind . size ( ) ; }
void sumFib ( int N ) { double num = ( 1 - Math . sqrt ( 5 ) ) / 2 ; long val = Math . round ( Math . abs ( 1 / ( Math . pow ( num , N + 2 ) + Math . pow ( num , N + 1 ) + Math . pow ( num , N ) + Math . pow ( num , N - 1 ) ) ) - 1 ) ; System . out . println ( val ) ; }
void sortarray ( int arr [ ] , int N ) { if ( N == 3 ) System . out . println ( " NO " ) ; else if ( N % 4 == 0 N % 4 == 1 ) { System . out . println ( " YES " ) ; System . out . println ( N / 2 ) ; int k = 1 , l ; for ( l = 0 ; l < ( N / 4 ) ; l ++ ) { System . out . println ( k + " ▁ " + ( k + 1 ) + " ▁ " + N ) ; System . out . println ( k + 1 + " ▁ " + N + " ▁ " + ( N - 1 ) ) ; k = k + 2 ; N = N - 2 ; } } else System . out . println ( " NO " ) ; }
int minimumSets ( int arr [ ] , int n , int key ) { int i , j ; Arrays . sort ( arr ) ; for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; }
int countNum ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < > ( ) ; int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( ! s . contains ( i ) ) count ++ ; return count ; }
int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
int minSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
int isSubstring ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) break ; if ( j == M ) return i ; } return - 1 ; }
boolean canConvert ( String str1 , String str2 ) { int i = 0 , j = 0 ; while ( i < str1 . length ( ) && j < str2 . length ( ) ) { if ( str1 . charAt ( i ) != str2 . charAt ( j ) ) { if ( str1 . charAt ( i ) == '0' && str2 . charAt ( j ) == '1' && i + 1 < str1 . length ( ) && str1 . charAt ( i + 1 ) == '0' ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i == str1 . length ( ) && j == str2 . length ( ) ) return true ; return false ; }
void missing4 ( int [ ] arr ) { int [ ] helper = new int [ 4 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { int temp = Math . abs ( arr [ i ] ) ; if ( temp <= arr . length ) arr [ temp - 1 ] *= ( - 1 ) ; else if ( temp > arr . length ) { if ( temp % arr . length != 0 ) helper [ temp % arr . length - 1 ] = - 1 ; else helper [ ( temp % arr . length ) + arr . length - 1 ] = - 1 ; } } for ( int i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] > 0 ) System . out . print ( i + 1 + " ▁ " ) ; for ( int i = 0 ; i < helper . length ; i ++ ) if ( helper [ i ] >= 0 ) System . out . print ( arr . length + i + 1 + " ▁ " ) ; return ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 4 * n - 2 ; }
long removeElements ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; arr = reverse ( arr ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += arr [ i ] * Math . pow ( 2 , i ) ; } return ans ; }
int smallestNth ( int A , int B , int N ) { int res = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { int D = ( B - A ) / ( j - i ) ; int FirstTerm = A - ( i - 1 ) * D ; int NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = Math . min ( res , NthTerm ) ; } } } return res ; }
void farthestCellDistance ( int N , int M , int R , int C ) { int d1 = N + M - R - C ; int d2 = R + C - 2 ; int d3 = N - R + C - 1 ; int d4 = M - C + R - 1 ; int maxDistance = Math . max ( d1 , Math . max ( d2 , Math . max ( d3 , d4 ) ) ) ; System . out . println ( maxDistance ) ; }
int ConcatenateArr ( int [ ] arr , int N ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { int l = ( int ) Math . floor ( Math . log10 ( arr [ i ] ) + 1 ) ; ans = ans * ( int ) Math . pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }
void findMajority ( int arr [ ] , int n ) { int len = 32 ; int number = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) count ++ ; } if ( count > ( n / 2 ) ) number += ( 1 << i ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > ( n / 2 ) ) System . out . println ( number ) ; else System . out . println ( " Majority ▁ Element ▁ Not ▁ Present " ) ; }
boolean checkExists ( int arr [ ] , int N , int M , int K ) { int count = 0 ; for ( int i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; }
void AlternateRearrange ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . add ( arr [ i ] ) ; else v2 . add ( arr [ i ] ) ; int index = 0 , i = 0 , j = 0 ; boolean flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ] = ( int ) v1 . get ( i ) ; i += 1 ; index += 1 ; flag = ! flag ; } else { arr [ index ] = ( int ) v2 . get ( j ) ; j += 1 ; index += 1 ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
void findSubarrays ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int i = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; }
double calculateSum ( double n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }
int count_minimum_operations ( long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
void sameProductQuadruples ( int [ ] nums , int N ) { int [ ] umap = new int [ 10000 ] ; int res = 0 ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = i + 1 ; j < N ; ++ j ) { int prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } System . out . println ( res ) ; }
int countTriplets ( int A [ ] , int N ) { int ans = 0 ; HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int j = N - 2 ; j >= 1 ; j -- ) { if ( map . containsKey ( A [ j + 1 ] ) ) map . put ( A [ j + 1 ] , map . get ( A [ j + 1 ] ) + 1 ) ; else map . put ( A [ j + 1 ] , 1 ) ; for ( int i = 0 ; i < j ; i ++ ) { int target = A [ i ] * A [ j ] ; if ( map . containsKey ( target ) ) ans += map . get ( target ) ; } } return ans ; }
int findIndex ( int a [ ] , int n ) { int res = 0 ; long min_diff = Long . MAX_VALUE ; long prod [ ] = new long [ n ] ; prod [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long curr_diff = Math . abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
boolean check ( String str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ; else evenDigSum += ( str . charAt ( i ) - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
int avg_of_even_num ( int n ) { return n + 1 ; }
int evenbitsetnumber ( int n ) { int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
int totalCircles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; }
int repeatingElement ( int arr [ ] , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = Math . max ( M , arr [ i ] ) ; } int sum1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum1 ) / ( N - M ) ; return ans ; }
void RearrangePosNeg ( int arr [ ] ) { int i = 0 ; int j = arr . length - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < arr . length ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } }
int sum_of_4_squares ( int n ) { int i , odd = 0 , even = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }
int Total_Ways ( int n ) { int fac = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) { fac = fac * i ; } return ( fac * 2 ) ; }
void check ( int n ) { if ( ( n & n - 1 ) != 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
int countSubsets ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int bitwiseAND = - 1 ; int bitwiseOR = 0 ; int bitwiseXOR = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) == 0 ) { if ( bitwiseAND == - 1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }
void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
void countTotalFrequencies ( String S1 , String S2 ) { HashSet < Character > bset = new HashSet < Character > ( ) ; char [ ] S1arr = S1 . toCharArray ( ) ; char [ ] S2arr = S2 . toCharArray ( ) ; for ( char x : S1arr ) bset . add ( x ) ; int count = 0 ; for ( char x : S2arr ) { if ( bset . contains ( x ) ) count += 1 ; } System . out . print ( count ) ; }
int sum ( int k , int n ) { int sum = ( int ) ( Math . pow ( k , n + 1 ) - Math . pow ( k - 1 , n + 1 ) ) ; return sum ; }
int minSumPath ( ) { int [ ] memo = new int [ A . length ] ; int n = A . length - 1 ; for ( int i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . length - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
float cyl ( float R ) { if ( R < 0 ) return - 1 ; float V = ( float ) ( ( 2 * 3.14 * Math . pow ( R , 3 ) ) / ( 3 * Math . sqrt ( 3 ) ) ) ; return V ; }
void differentStrings ( String s ) { int n = s . length ( ) ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) && ( s . charAt ( i ) == '1' || s . charAt ( i ) == '2' ) ) dp [ i + 1 ] = dp [ i ] + dp [ i - 1 ] ; else dp [ i + 1 ] = dp [ i ] ; } System . out . println ( dp [ n ] ) ; }
String removeRecurringDigits ( char num [ ] ) { int len = num . length ; String s = " " ; for ( int i = 0 ; i < len ; i ++ ) { s += String . valueOf ( num [ i ] ) ; while ( i + 1 < len && num [ i ] == num [ i + 1 ] ) { i ++ ; } } return s ; }
int countSubSeq ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { count ++ ; } } return ( int ) ( Math . pow ( 2 , count ) - 1 ) ; }
void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } System . out . println ( total - oddArray ) ; }
int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }
int maxModulosum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; }
void findAllTriplets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { System . out . println ( arr [ j ] + " ▁ " + arr [ i ] + " ▁ " + arr [ k ] ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }
int countSubArrays ( int arr [ ] , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
void countNums ( int N ) { int dp [ ] [ ] = new int [ N ] [ 16 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 16 ; k ++ ) { int xor = j ^ k ; dp [ i ] [ xor ] += dp [ i - 1 ] [ k ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 ] [ i ] ; System . out . println ( count ) ; }
int maximumAND ( int L , int R ) { return R ; }
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
int countOccurrences ( int N , int X ) { int count = 0 ; for ( int i = 1 ; i < Math . sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { int a = i ; int b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; }
int maxValue ( int n ) { return n ; }
void printChar ( String str , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 0 ) { System . out . print ( str . charAt ( i ) ) ; } } }
boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return 1 ; }
void PrintIndexes ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int currSubSum = 0 ; for ( int j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; int sq = ( int ) Math . sqrt ( currSubSum ) ; if ( sq * sq == currSubSum ) { System . out . print ( " ( " + i + " , " + j + " ) " + " ▁ " ) ; } } } }
double calculateSide ( double n , double r ) { double theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * Math . sin ( theta_in_radians / 2 ) ; }
long calculate ( long p , long q ) { long mod = 998244353 , expo ; expo = mod - 2 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { p = ( p * q ) % mod ; } q = ( q * q ) % mod ; expo >>= 1 ; } return p ; }
int countCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
void find_numbers ( int N ) { if ( N == 1 ) { System . out . print ( - 1 ) ; } else { System . out . print ( N + " ▁ " + ( N + 1 ) + " ▁ " + ( N * ( N + 1 ) ) ) ; } }
int countWays ( int A , int B , int C ) { int minAddA = Math . max ( 0 , ( C + B - A + 2 ) / 2 ) ; int count_ways = Math . max ( C - minAddA + 1 , 0 ) ; return count_ways ; }
char getChar ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { sum += ( str . charAt ( i ) - ' a ' + 1 ) ; } if ( sum % 26 == 0 ) return ' z ' ; else { sum = sum % 26 ; return ( char ) ( ' a ' + sum - 1 ) ; } }
void countFreq ( int a [ ] , int n ) { int hm [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { System . out . println ( a [ i ] + " - > " + cumul ) ; } hm [ a [ i ] ] = 0 ; } }
int KvisibleFromLeft ( int N , int K ) { if ( dp [ N ] [ K ] != - 1 ) return dp [ N ] [ K ] ; if ( N == K ) return dp [ N ] [ K ] = 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return dp [ N ] [ K ] = ans ; } return dp [ N ] [ K ] = KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
char findProffesion ( int level , int pos ) { if ( level == 1 ) return ' e ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' d ' ) return ( pos % 2 > 0 ) ? ' d ' : ' e ' ; return ( pos % 2 > 0 ) ? ' e ' : ' d ' ; }
void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; System . out . println ( " x2 ▁ = ▁ " + x2 + " , ▁ " + " y2 ▁ = ▁ " + y2 ) ; }
void sub_segments ( String str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { String newlist = str . substring ( x , x + n ) ; List < Character > arr = new ArrayList < Character > ( ) ; for ( char y : newlist . toCharArray ( ) ) { if ( ! arr . contains ( y ) ) arr . add ( y ) ; } for ( char y : arr ) System . out . print ( y ) ; System . out . println ( ) ; } }
float rmsValue ( int arr [ ] , int n ) { int square = 0 ; float mean = 0 ; float root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = ( float ) Math . sqrt ( mean ) ; return root ; }
int LongestOddEvenSubarray ( int A [ ] , int N ) { int dp [ ] = new int [ N ] ; dp [ 0 ] = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) ans = Math . max ( ans , dp [ i ] ) ; return ans ; }
double increaseInVol ( double l , double b , double h ) { double percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; }
void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
void countXorPartition ( int N ) { double a = Math . pow ( 2 , ( int ) ( N - Math . log ( N + 1 ) / Math . log ( 2 ) ) ) ; System . out . print ( a ) ; }
void angleequichord ( int z ) { System . out . println ( " The ▁ angle ▁ subtended ▁ at ▁ the ▁ center ▁ is ▁ " + z + " ▁ degrees " ) ; }
void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } System . out . print ( ans + "NEW_LINE"); } }
int count ( int S [ ] , int m , int n ) { int table [ ] = new int [ n + 1 ] ; table [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }
int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * ( int ) Math . pow ( 10 , n / 2 - 1 ) ) ; }
int prefixOccurrences ( String str ) { char c = str . charAt ( 0 ) ; int countc = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == c ) countc ++ ; } return countc ; }
void printTrib ( int n ) { int dp [ ] = new int [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " ▁ " ) ; }
void countSubarrays ( int a [ ] , int n , int k ) { int ans = 0 ; ArrayList < Integer > pref = new ArrayList < > ( ) ; pref . add ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . add ( ( a [ i ] + pref . get ( i ) ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref . get ( j ) - pref . get ( i - 1 ) + k ) % k == j - i + 1 ) { ans ++ ; } } } System . out . println ( ans ) ; }
int SquareCube ( long N ) { int cnt = 0 , i = 1 ; while ( ( int ) ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
void prevGreater ( int arr [ ] , int n ) { System . out . print ( " - 1 , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { System . out . print ( arr [ j ] + " , ▁ " ) ; break ; } } if ( j == - 1 ) System . out . print ( " - 1 , ▁ " ) ; } }
int count ( int n ) { return ( int ) Math . pow ( 2 , n - 1 ) ; }
void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= Math . pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= Math . pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; System . out . println ( count + " ▁ " + i ) ; } i ++ ; } }
int evenSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
String reversingString ( char [ ] str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return String . valueOf ( str ) ; }
double hexagonArea ( double s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
void findMinimumCost ( String s , int N ) { int count_1 = 0 , count_0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == '1' ) count_1 ++ ; else count_0 ++ ; } int k = Math . abs ( count_0 - count_1 ) ; if ( count_1 == N count_0 == N ) System . out . println ( - 1 ) ; else System . out . println ( k / 2 ) ; }
int xorPairCount ( int arr [ ] , int n , int x ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . containsKey ( curr_xor ) ) result += m . get ( curr_xor ) ; if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } return result ; }
boolean isReversible ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }
int CountCharacters ( String str , int k ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( ( int ) str . charAt ( i ) ) < k ) cnt ++ ; } return cnt ; }
int xorOfArray ( int arr [ ] , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }
void lengthOfTangent ( double r1 , double r2 , double d ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ transverse " + " ▁ common ▁ tangent ▁ is ▁ " + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 + r2 ) , 2 ) ) ) ; }
int findNthNumber ( int A , int B , int N ) { int sum = 0 ; for ( int i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }
void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . floor ( a [ i ] / mul ) ; System . out . print ( x + " ▁ " ) ; } }
int maxScore ( String s , int [ ] a ) { if ( dp . containsKey ( s ) ) return dp . get ( s ) ; int n = s . length ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int head = 0 ; int mx = - 1 ; while ( head < n ) { int tail = head ; while ( tail < n ) { if ( s . charAt ( tail ) != s . charAt ( head ) ) { head = tail ; break ; } String sub = s . substring ( head , tail + 1 ) ; mx = Math . max ( mx , a [ sub . length ( ) - 1 ] + maxScore ( s . substring ( 0 , head ) + s . substring ( tail + 1 , s . length ( ) ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp . put ( s , mx ) ; return mx ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ; Arrays . sort ( X , Collections . reverseOrder ( ) ) ; Arrays . sort ( Y , Collections . reverseOrder ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
boolean isUndulating ( String n ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n . charAt ( i - 2 ) != n . charAt ( i ) ) return false ; return true ; }
void selectionSort ( node head ) { node temp = head ; while ( temp ) { node min = temp ; node r = temp . next ; while ( r ) { if ( min . data > r . data ) min = r ; r = r . next ; } int x = temp . data ; temp . data = min . data ; min . data = x ; temp = temp . next ; } }
int NumberOfways ( int N , int K ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int row = 1 ; row < K + 1 ; row ++ ) { for ( int col = 1 ; col < N + 1 ; col ++ ) { if ( col >= row ) dp [ col ] = dp [ col ] + dp [ col - row ] ; } } return ( dp [ N ] ) ; }
int minCapacity ( int enter [ ] , int exit [ ] , int n ) { int minCap = 0 ; int currCap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = Math . max ( minCap , currCap ) ; } return minCap ; }
int FirstRepeated ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; }
void anglequichord ( int z ) { System . out . println ( " The ▁ angle ▁ is ▁ " + z + " ▁ degrees " ) ; }
void findNumbers ( int N ) { for ( int i = 1 ; i <= N / 2 ; i ++ ) { System . out . print ( i + " , ▁ " + - i + " , ▁ " ) ; } if ( N % 2 == 1 ) System . out . print ( 0 ) ; }
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }
int minimumCost ( int cost [ ] , int n ) { int dp [ ] = new int [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
void FirstAndLast ( String str ) { int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == 0 ) System . out . print ( str . charAt ( i ) ) ; if ( i == str . length ( ) - 1 ) System . out . print ( str . charAt ( i ) ) ; if ( str . charAt ( i ) == ' ▁ ' ) { System . out . print ( str . charAt ( i - 1 ) + " ▁ " + str . charAt ( i + 1 ) ) ; } } }
int findMin ( int N ) { int digit = N % 10 ; switch ( digit ) { case 0 : if ( N >= 90 ) return 10 ; break ; case 1 : if ( N >= 81 ) return 9 ; break ; case 2 : if ( N >= 72 ) return 8 ; break ; case 3 : if ( N >= 63 ) return 7 ; break ; case 4 : if ( N >= 54 ) return 6 ; break ; case 5 : if ( N >= 45 ) return 5 ; break ; case 6 : if ( N >= 36 ) return 4 ; break ; case 7 : if ( N >= 27 ) return 3 ; break ; case 8 : if ( N >= 18 ) return 2 ; break ; case 9 : if ( N >= 9 ) return 1 ; break ; } return - 1 ; }
String nthprimedigitsnumber ( int number ) { int rem ; String num = " " ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += '2' ; break ; case 2 : num += '3' ; break ; case 3 : num += '5' ; break ; case 0 : num += '7' ; break ; } if ( number % 4 == 0 ) number -- ; number = number / 4 ; } return new StringBuilder ( num ) . reverse ( ) . toString ( ) ; }
int maxiConsecutiveSubarray ( int arr [ ] , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . max ( maxi , cnt ) ; i = j ; } return maxi ; }
void factors ( int n ) { int i , j ; System . out . print ( "1 -->1NEW_LINE"); for ( i = 2 ; i <= n ; i ++ ) { System . out . print ( i + " ▁ - - > " ) ; for ( j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { System . out . print ( j + " , ▁ " ) ; if ( i / j != j ) System . out . print ( i / j + " , ▁ " ) ; } } System . out . print ( "NEW_LINE"); } }
int countOnes ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; }
void findPhoneNumber ( int n ) { int temp = n ; int sum = 0 ; while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; } if ( sum < 10 ) System . out . print ( n + "0" + sum ) ; else System . out . print ( n + " " + sum ) ; }
int complement ( int num ) { int i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = num / 10 ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . pow ( 10 , len ) - num ; return comp ; }
int minLength ( String s ) { int i = 0 , j = s . length ( ) - 1 ; for ( ; i < j && s . charAt ( i ) == s . charAt ( j ) ; ) { char d = s . charAt ( i ) ; while ( i <= j && s . charAt ( i ) == d ) i ++ ; while ( i <= j && s . charAt ( j ) == d ) j -- ; } return j - i + 1 ; }
int findXORS ( int arr1 [ ] , int arr2 [ ] , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int temp = arr1 [ i ] & arr2 [ j ] ; res ^= temp ; } } return res ; }
int findSmallest ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; }
void BalanceArray ( int [ ] A , int [ ] [ ] Q ) { int [ ] ANS = new int [ A . length ] ; int i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS [ i ] = sum ; } for ( i = 0 ; i < ANS . length ; i ++ ) System . out . print ( ANS [ i ] + " ▁ " ) ; }
void findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; Arrays . sort ( arr ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = ( num / d ) + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } System . out . println ( sum - max ) ; }
int findLargestd ( int [ ] S , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; }
int MinDistK ( int arr [ ] , int N , int K ) { int res = Integer . MAX_VALUE ; int dist = 0 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = Math . max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = Math . abs ( arr [ i ] ) + Math . abs ( arr [ i + K - 1 ] ) + Math . min ( Math . abs ( arr [ i ] ) , Math . abs ( arr [ i + K - 1 ] ) ) ; } res = Math . min ( res , dist ) ; } return res ; }
String repeat ( String s , int n ) { String s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }
int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
int LCSubStr ( String s , String t , int n , int m ) { int dp [ ] [ ] = new int [ 2 ] [ m + 1 ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 ) ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; }
boolean checkIfDivisible ( String str , long num ) { long powerOf2 = ( int ) ( Math . log ( num ) / Math . log ( 2 ) ) ; if ( str . length ( ) < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; long i , number = 0 ; int len = str . length ( ) ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str . charAt ( ( int ) i ) - '0' ) * Math . pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num != 0 ) return false ; else return true ; }
boolean isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( Math . abs ( Sx - Dx ) % x == 0 && Math . abs ( Sy - Dy ) % y == 0 && ( Math . abs ( Sx - Dx ) / x ) % 2 == ( Math . abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
void checkSumOfNatural ( int n ) { int i = 1 ; boolean flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = ( int ) Math . sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
void maximumSubsequenceSum ( int A [ ] , int N ) { int ans = 0 ; HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { mp . put ( A [ i ] - i , mp . getOrDefault ( A [ i ] - i , 0 ) + A [ i ] ) ; ans = Math . max ( ans , mp . get ( A [ i ] - i ) ) ; } System . out . println ( ans ) ; }
void solve ( int N ) { if ( N % 2 == 0 ) { System . out . print ( N / 2 + " ▁ " + N + "NEW_LINE"); } else { System . out . print ( ( N - 1 ) / 2 + " ▁ " + ( N - 1 ) + "NEW_LINE"); } }
int find ( int start , String adj , int n , int dp [ ] ) { if ( start == n ) return 0 ; if ( dp [ start ] != - 1 ) return dp [ start ] ; dp [ start ] = 0 ; int one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj . charAt ( k ) == '1' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; }
int countSubStr ( String str , int n ) { int len = str . length ( ) ; return ( len - n + 1 ) ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; return dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; }
int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { int x = Math . abs ( i - A ) ; int y = Math . abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
double kthRoot ( double n , int k ) { return Math . pow ( k , ( ( 1.0 / k ) * ( Math . log ( n ) / Math . log ( k ) ) ) ) ; }
int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
void IsEvenPath ( int Source [ ] , int Destination [ ] ) { int x_dif = Math . abs ( Source [ 0 ] - Destination [ 0 ] ) ; int y_dif = Math . abs ( Source [ 1 ] - Destination [ 1 ] ) ; int minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
int minimumX ( int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
int printMinimumProduct ( int arr [ ] , int n ) { int first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
boolean isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return true ; return false ; }
void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } System . out . print ( Math . min ( s , x ) ) ; }
void findSum ( int N , int K ) { int ans = 0 ; int i = 1 ; while ( i <= N ) { ans += N / i ; i = i * K ; } System . out . println ( ans ) ; }
float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int countPairs ( int A [ ] , int n , int k ) { int ans = 0 ; Arrays . sort ( A ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * Math . pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
int find_max ( int n , int k ) { int [ ] X = new int [ 32 ] ; int cnt = 0 ; for ( int i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { X [ i ] = 1 ; cnt ++ ; } } String s = " " ; for ( int i = 31 ; i >= 0 ; i -- ) s += X [ i ] == 0 ? '0' : '1' ; return Integer . parseInt ( s , 2 ) ; }
void mergeTwoHalf ( int [ ] A , int n ) { Arrays . sort ( A ) ; }
boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
int countNum ( int n ) { if ( n == 1 ) return 1 ; int count = ( int ) Math . pow ( 2 , n - 2 ) ; return count ; }
int MinimumValue ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int minXor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }
int find_consecutive_steps ( int arr [ ] , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; }
int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }
void countPairs ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int xo = ( A [ i ] ^ A [ j ] ) ; int mx = Math . max ( A [ i ] , A [ j ] ) ; if ( xo > mx ) { count ++ ; } } } System . out . println ( count ) ; }
float ellipse ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float x = ( float ) ( 3.14 * l * b ) / 4 ; return x ; }
int divCount ( int n ) { boolean hash [ ] = new boolean [ n + 1 ] ; Arrays . fill ( hash , true ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( float ) ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
int findCount ( int n ) { return ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; }
float circlearea ( double a , double b ) { if ( a < 0 b < 0 ) return - 1 ; float A = ( float ) ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; }
int noOfTriangles ( int n ) { int y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }
int countDer ( int n ) { int der [ ] = new int [ n + 1 ] ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
void numbersWith3Divisors ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } System . out . println ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : ▁ " ) ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) System . out . print ( i * i + " ▁ " ) ; }
float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = 4 * ( float ) ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; }
float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; float x = r ; float V = ( float ) ( 4 * 3.14f * Math . pow ( r , 3 ) ) / 3 ; return V ; }
double mixtureConcentration ( int n , int [ ] p ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
void radius ( int n , int d ) { System . out . print ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " + d / ( n - 1 ) ) ; }
boolean func ( int a [ ] , int k ) { for ( int i = 0 ; i < a . length ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }
void find_rectangle ( int area ) { for ( int i = ( int ) Math . ceil ( Math . sqrt ( area ) ) ; i <= area ; i ++ ) { if ( area / i * i == area ) { System . out . println ( i + " ▁ " + ( int ) ( area / i ) ) ; return ; } } }
boolean isDivisibleBy25 ( String str ) { int n = str . length ( ) ; if ( n == 1 ) return false ; return ( ( str . charAt ( n - 1 ) - '0' == 0 && str . charAt ( n - 2 ) - '0' == 0 ) || ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 25 == 0 ) ; }
boolean checkPalindromeB ( int N , int B ) { int rev = 0 ; int N1 = N ; while ( N1 > 0 ) { rev = rev * B + N1 % B ; N1 = N1 / B ; } return N == rev ; }
int smallest ( String s ) { int [ ] a = new int [ s . length ( ) ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) a [ i ] = s . charAt ( i ) - '0' ; Vector < Integer > b = new Vector < Integer > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] % 2 != 0 ) b . add ( a [ i ] ) ; } Collections . sort ( b ) ; if ( b . size ( ) > 1 ) return ( b . get ( 0 ) ) * 10 + ( b . get ( 1 ) ) ; return - 1 ; }
void findSet ( int N , int K ) { ArrayList < Integer > a = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . add ( i ) ; } int MaxDistinct = ( N - K ) + ( K / 2 ) ; Collections . reverse ( a ) ; for ( int i = 0 ; i < MaxDistinct ; i ++ ) System . out . print ( a . get ( i ) + " ▁ " ) ; }
String canMake ( String s ) { int o = 0 , z = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) - '0' == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return " NO " ; else return " YES " ; }
int minStartValue ( int [ ] nums ) { int minValue = 0 ; int sum = 0 ; for ( int n : nums ) { sum += n ; minValue = Math . min ( minValue , sum ) ; } int startValue = 1 - minValue ; return startValue ; }
int getPairsCount ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && ( arr [ i ] * arr [ j ] ) == Math . abs ( i - j ) ) { count ++ ; } } } return count ; }
int countPairs ( int A , int B ) { int countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; }
int matrixSum ( int arr [ ] [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } } return sum ; }
int countPairsWithProdK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }
int minimumProduct ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int product = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }
int calculateProduct ( int [ ] A , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans = 1 ; for ( int i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; }
void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . println ( " Fits " ) ; else System . out . println ( " Doesn ' t ▁ Fit " ) ; }
int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
void fibonacci ( double n ) { double fib ; for ( double i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; System . out . print ( ( int ) fib + " ▁ " ) ; } }
int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; }
int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; }
void minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; System . out . println ( cnt ) ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
int minTotalDistance ( int grid [ ] [ ] ) { if ( ROW == 0 COL == 0 ) return 0 ; Vector < Integer > vertical = new Vector < Integer > ( ) ; Vector < Integer > horizontal = new Vector < Integer > ( ) ; for ( int i = 0 ; i < ROW ; i ++ ) { for ( int j = 0 ; j < COL ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { vertical . add ( i ) ; horizontal . add ( j ) ; } } } Collections . sort ( vertical ) ; Collections . sort ( horizontal ) ; int size = vertical . size ( ) / 2 ; int x = vertical . get ( size ) ; int y = horizontal . get ( size ) ; int distance = 0 ; for ( int i = 0 ; i < ROW ; i ++ ) for ( int j = 0 ; j < COL ; j ++ ) if ( grid [ i ] [ j ] == 1 ) distance += Math . abs ( x - i ) + Math . abs ( y - j ) ; return distance ; }
int icosikaienneagonalNum ( int n ) { return ( 27 * n * n - 25 * n ) / 2 ; }
void newvol ( double x ) { System . out . print ( " percentage ▁ increase ▁ in ▁ the " + " ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + " % " ) ; }
int longestSubarray ( int arr [ ] , int n ) { int maxMean = 0 ; for ( int i = 1 ; i < n ; i ++ ) maxMean = Math . max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int subarrayLength = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = Math . max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; }
int findKthGoodNo ( int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } System . out . print ( A + " ▁ " + B ) ; }
int countAnomalies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
int findMaxPairs ( int a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; boolean [ ] flag = new boolean [ n ] ; Arrays . fill ( flag , false ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - b [ j ] ) <= k && flag [ j ] == false ) { result ++ ; flag [ j ] = true ; break ; } } } return result ; }
void MinDiff ( int n ) { int val = ( int ) Math . pow ( 2 , n ) ; int sep = n / 2 ; int grp1 = 0 ; int grp2 = 0 ; grp1 = grp1 + val ; for ( int i = 1 ; i < sep ; i ++ ) grp1 = grp1 + ( int ) Math . pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) grp2 = grp2 + ( int ) Math . pow ( 2 , i ) ; System . out . println ( Math . abs ( grp1 - grp2 ) ) ; }
int XorSum ( int A [ ] , int B [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; }
void additiveCongruentialMethod ( int Xo , int m , int c , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m ; } }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
int minSteps ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) - 2 ; i ++ ) { if ( ( ( int ) str . charAt ( i ) ) == '0' ) { if ( str . charAt ( i + 1 ) == '1' ) { if ( str . charAt ( i + 2 ) == '0' ) { count ++ ; i += 2 ; } } } } return count ; }
int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; }
int titleToNumber ( String s ) { int result = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { result *= 26 ; result += s . charAt ( i ) - ' A ' + 1 ; } return result ; }
int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
long answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
void quadrant ( String s ) { int l = s . length ( ) ; int i ; if ( s . contains ( " + " ) ) { i = s . indexOf ( ' + ' ) ; } else { i = s . indexOf ( ' - ' ) ; } String real = s . substring ( 0 , i ) ; String imaginary = s . substring ( i + 1 , l - 1 ) ; int x = Integer . valueOf ( real ) ; int y = Integer . valueOf ( imaginary ) ; if ( x > 0 && y > 0 ) System . out . print ( " Quadrant ▁ 1" ) ; else if ( x < 0 && y > 0 ) System . out . print ( " Quadrant ▁ 2" ) ; else if ( x < 0 && y < 0 ) System . out . print ( " Quadrant ▁ 3" ) ; else if ( x > 0 && y < 0 ) System . out . print ( " Quadrant ▁ 4" ) ; else if ( x == 0 && y > 0 ) System . out . print ( " Lies ▁ on ▁ positive " + " ▁ Imaginary ▁ axis " ) ; else if ( x == 0 && y < 0 ) System . out . print ( " Lies ▁ on ▁ negative " + " ▁ Imaginary ▁ axis " ) ; else if ( y == 0 && x < 0 ) System . out . print ( " Lies ▁ on ▁ negative " + " ▁ X - axis " ) ; else if ( y == 0 && x > 0 ) System . out . print ( " Lies ▁ on ▁ positive " + " ▁ X - axis " ) ; else System . out . print ( " Lies ▁ on ▁ the ▁ Origin " ) ; }
int find_greatest_divisor ( int l , int r ) { if ( l == r ) { return l ; } return 1 ; }
void CalculatePairs ( int a [ ] , int n ) { int cnt_zero = 0 ; int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } int total_XOR_pairs = cnt_zero * cnt_one ; int total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; int total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; System . out . println ( " cntXOR ▁ = ▁ " + total_XOR_pairs ) ; System . out . println ( " cntAND ▁ = ▁ " + total_AND_pairs ) ; System . out . println ( " cntOR ▁ = ▁ " + total_OR_pairs ) ; }
int findWinner ( int N ) { return N & 1 ; }
boolean search ( int [ ] arr , int n , int x ) { int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
int SmallestDiv ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }
long getNthTerm ( long N ) { return 4 * ( long ) Math . pow ( N , 2 ) - 3 * N + 2 ; }
int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }
boolean isMajority ( int arr [ ] , int n , int x ) { int i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; }
int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }
int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; }
void alternateSubarray ( boolean arr [ ] , int n ) { int len [ ] = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) System . out . print ( len [ i ] + " ▁ " ) ; }
void printPair ( int g , int l ) { System . out . print ( g + " ▁ " + l ) ; }
void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) { System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
boolean uniqueCharacters ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) return false ; return true ; }
int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
int contiguousPerfectSquare ( int [ ] arr , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = ( float ) Math . sqrt ( arr [ i ] ) ; a = ( int ) b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
int oddEquivalent ( String s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) count ++ ; } return count ; }
void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( n != 0 ) { int r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = n / 10 ; } System . out . println ( largest + " ▁ " + smallest ) ; }
boolean check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) return true ; return false ; }
void maxksum ( int L , int R , int K ) { int N = ( R / 10 - L / 10 ) + 1 ; if ( K > N ) { System . out . print ( " - 1" ) ; return ; } R = R / 10 ; int X = R - K ; int sum = 10 * ( ( R * ( R + 1 ) ) / 2 - ( X * ( X + 1 ) ) / 2 ) ; System . out . print ( sum ) ; }
boolean istriacontagonal ( int N ) { float n = ( float ) ( ( 26 + Math . sqrt ( 224 * N + 676 ) ) / 56 ) ; return ( n - ( int ) n ) == 0 ; }
int totalArrays ( int N , int M ) { int [ ] end_with_one = new int [ N + 1 ] ; int [ ] end_not_with_one = new int [ N + 1 ] ; end_with_one [ 0 ] = 1 ; end_not_with_one [ 0 ] = 0 ; end_with_one [ 1 ] = 0 ; end_not_with_one [ 1 ] = M - 1 ; for ( int i = 2 ; i < N ; i ++ ) { end_with_one [ i ] = end_not_with_one [ i - 1 ] ; end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; } return end_with_one [ N - 1 ] ; }
int findPosition ( int n , int f , int b ) { return n - Math . max ( f + 1 , n - b ) + 1 ; }
int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
int findgroups ( int arr [ ] , int n ) { int c [ ] = new int [ ] { 0 , 0 , 0 } ; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
int countKCountdown ( int arr [ ] , int N , int K ) { int flag = - 1 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) flag = K ; if ( arr [ i ] == flag ) flag -- ; else flag = - 1 ; if ( flag == 0 ) count ++ ; } return count ; }
int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; }
int findLargestDivisor ( int n ) { for ( int i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || Math . abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = Math . min ( a , b ) ; int j = Math . max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } System . out . print ( ans ) ; }
String replacingConsonants ( String s ) { String str = " aaaeeeeiiiiioooooouuuuuuuu " ; char [ ] st = s . toCharArray ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int index = st [ i ] - ' a ' ; st [ i ] = str . charAt ( index ) ; } String str1 = new String ( st ) ; return str1 ; }
boolean check ( String s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
int countOddSquares ( int n , int m ) { return ( int ) Math . pow ( m , 0.5 ) - ( int ) Math . pow ( n - 1 , 0.5 ) ; }
int countDistinct ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; }
long sumOfSumSeries ( int N ) { long sum = 0L ; for ( int i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }
int count ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; }
String lexicographicSubConcat ( String s ) { int n = s . length ( ) ; int sub_count = n * ( n + 1 ) / 2 ; String [ ] arr = new String [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) { arr [ index ++ ] = s . substring ( i , i + len ) ; } Arrays . sort ( arr ) ; String res = " " ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
long calculate ( long a [ ] , int n ) { Arrays . sort ( a ) ; int i , j ; Vector < Long > s = new Vector < > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . add ( ( a [ i ] + a [ j ] ) ) ; long mini = Collections . min ( s ) ; long maxi = Collections . max ( s ) ; return Math . abs ( maxi - mini ) ; }
long sumOfSubstrings ( String num ) { long sum = 0 ; long mf = 1 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { sum += ( num . charAt ( i ) - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
void isPossible ( int W , int B , int D ) { if ( W > B ) { int temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; }
boolean isPowerOfFour ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAAAAAA ) == 0 ; }
Boolean divisibleBy20 ( String num ) { int lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 , num . length ( ) ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
int MinimumX ( int a , int b , int c , int k ) { int x = Integer . MAX_VALUE ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
int minIncr ( int [ ] arr , int n ) { int forEven = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 1 ) { if ( ( arr [ i ] % 2 ) == 0 ) forEven += 1 ; } else { if ( arr [ i ] % 2 == 1 ) forEven += 1 ; } } return Math . min ( forEven , n - forEven ) ; }
void checkHex ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s . charAt ( i ) ; if ( ( ch < '0' ch > '9' ) && ( ch < ' A ' ch > ' F ' ) ) { System . out . println ( " No " ) ; return ; } } System . out . println ( " Yes " ) ; }
int formQuadruplets ( Integer arr [ ] , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; }
void smallestGreater ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int diff = Integer . MAX_VALUE ; int closest = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) System . out . print ( " _ ▁ " ) ; else System . out . print ( arr [ closest ] + " ▁ " ) ; } }
void maximumTiles ( int n , int m ) { System . out . println ( ( m * n ) / 2 ) ; }
void checksum ( int n ) { if ( n % 5 == 0 ) System . out . println ( ( n / 5 - 2 ) + " ▁ " + ( n / 5 - 1 ) + " ▁ " + ( n / 5 ) + " ▁ " + ( n / 5 + 1 ) + " ▁ " + ( n / 5 + 2 ) ) ; else System . out . println ( " - 1" ) ; }
void findAandB ( int N ) { int K = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) ; int B = ( 1 << K ) ; int A = B ^ N ; System . out . println ( A + " ▁ " + B ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int maxWater ( int height [ ] , int n ) { int max = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int current = ( Math . min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; max = Math . max ( max , current ) ; } } return max ; }
int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; int sum = 5 ; while ( n > 2 ) { int d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
int make_permutation ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += Math . abs ( i + 1 - arr [ i ] ) ; return ans ; }
int findMax ( int arr [ ] , int n ) { int res = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = Math . max ( count , res ) ; } return res ; }
void countOfPairs ( int x , int y ) { int count = 0 ; for ( int k = 1 ; k * k <= x ; ++ k ) { count += Math . max ( 0 , Math . min ( y , x / k - 1 ) - k ) ; } System . out . print ( count ) ; }
void find3largest ( int [ ] arr ) { Arrays . sort ( arr ) ; int n = arr . length ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { System . out . print ( arr [ n - i ] + " ▁ " ) ; check = arr [ n - i ] ; count ++ ; } } else break ; } }
int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
void printElements ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
double largestSumOfAverages ( int [ ] A , int K ) { int n = A . length ; double [ ] pre_sum = new double [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double [ ] dp = new double [ n ] ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
int cntEdges ( int n ) { int edges = ( int ) Math . pow ( 2 , n ) - 2 ; return edges ; }
int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }
boolean arePermutation ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 != n2 ) return false ; char ch1 [ ] = str1 . toCharArray ( ) ; char ch2 [ ] = str2 . toCharArray ( ) ; Arrays . sort ( ch1 ) ; Arrays . sort ( ch2 ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( ch1 [ i ] != ch2 [ i ] ) return false ; return true ; }
int pay ( int n ) { int cuts = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return cuts ; }
void getOrgString ( String s ) { System . out . print ( s . charAt ( 0 ) ) ; int i = 1 ; while ( i < s . length ( ) ) { if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' Z ' ) System . out . print ( " ▁ " + Character . toLowerCase ( s . charAt ( i ) ) ) ; else System . out . print ( s . charAt ( i ) ) ; i ++ ; } }
int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
void myCopy ( char s1 [ ] , char s2 [ ] ) { int i = 0 ; for ( i = 0 ; i < s1 . length ; i ++ ) s2 [ i ] = s1 [ i ] ; }
boolean isequal ( String str ) { int n = str . length ( ) ; int num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( '0' <= str . charAt ( i ) && str . charAt ( i ) <= '9' ) { num = ( str . charAt ( i ) - '0' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; }
int minOperations ( int [ ] A , int n ) { if ( ( n & 1 ) > 0 ) return - 1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }
String minLexRotation ( String str ) { int n = str . length ( ) ; String arr [ ] = new String [ n ] ; String concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = concat . substring ( i , i + n ) ; } Arrays . sort ( arr ) ; return arr [ 0 ] ; }
int sumOfFactors ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int first = i ; int last = ( N / i ) * i ; int factors = ( last - first ) / i + 1 ; int totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
boolean arekAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
double possiblePositions ( double n ) { double term1 = Math . pow ( n , 4 ) ; double term2 = Math . pow ( n , 3 ) ; double term3 = Math . pow ( n , 2 ) ; double term4 = n / 3 ; double ans = ( Math . ceil ( term1 / 2 ) ) - ( Math . ceil ( 5 * term2 ) / 3 ) + ( Math . ceil ( 3 * term3 ) / 2 ) - term4 ; return ( long ) ans ; }
int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; }
void findNumbers ( int n , int b ) { double largest = Math . pow ( b , n ) - 1 ; System . out . println ( largest ) ; }
void numberOfDigits ( int N ) { int nod = ( int ) Math . floor ( Math . log10 ( N ) + 1 ) ; int toDecrease = ( int ) ( Math . pow ( 10 , nod ) - 1 ) / 9 ; System . out . print ( ( N + 1 ) * nod - toDecrease ) ; }
boolean transformString ( StringBuilder s ) { char ch = ' a ' ; if ( s . length ( ) < 26 ) return false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( int ) ch > ( int ) ' z ' ) break ; if ( s . charAt ( i ) <= ch ) { s . setCharAt ( i , ch ) ; ch = ( char ) ( ( int ) ch + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; }
boolean isPossible ( int l , int m , int x , int y ) { if ( l * m == x + y ) return true ; return false ; }
boolean sumOfTwoCubes ( int n ) { int lo = 1 , hi = ( int ) Math . cbrt ( n ) ; while ( lo <= hi ) { int curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; }
int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = ( int ) Math . log10 ( n ) ; int [ ] a = new int [ d + 2 ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ( int ) Math . ceil ( Math . pow ( 10 , i - 1 ) ) ; int p = ( int ) Math . ceil ( Math . pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
void minLength ( String S , String T , int N , int M ) { String temp = " " ; int subtract = 0 ; for ( int i = 0 ; i < N ; ++ i ) { temp += S . charAt ( i ) ; if ( temp . length ( ) >= M ) { if ( T . equals ( temp . substring ( temp . length ( ) - M , temp . length ( ) ) ) ) { subtract += M ; int cnt = 0 ; while ( cnt != M ) { temp = temp . substring ( 0 , temp . length ( ) - 1 ) ; ++ cnt ; } } } } System . out . println ( ( N - subtract ) ) ; }
boolean isWordPresent ( String sentence , String word ) { String [ ] s = sentence . split ( " ▁ " ) ; for ( String temp : s ) { if ( temp . compareTo ( word ) == 0 ) { return true ; } } return false ; }
int CountMaximum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
String isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int k = ( int ) n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; }
int maxLevel ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
boolean isCenteredtridecagonal ( int N ) { float n = ( float ) ( ( 13 + Math . sqrt ( 104 * N + 65 ) ) / 26 ) ; return ( n - ( int ) n ) == 0 ; }
int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }
int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
float find_prob ( int N , float P ) { double dp [ ] = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; }
int get_unit_digit ( int N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
int xorZero ( String s ) { int one_count = 0 , zero_count = 0 ; char [ ] str = s . toCharArray ( ) ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
float findVolume ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; float h = a ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
void lengperpbisect ( double r1 , double r2 ) { double z = 2 * Math . sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ " + " perpendicular ▁ bisector ▁ is ▁ " + z ) ; }
int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
float Area ( float a ) { if ( a < 0 ) return - 1 ; float x = 0.464f * a ; float A = 0.70477f * ( float ) Math . pow ( x , 2 ) ; return A ; }
int countAnomalies ( int arr [ ] , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
boolean check ( int X , int K ) { int prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = ( int ) Math . sqrt ( X ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = temp / i ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; }
int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
int minOperations ( int A [ ] , int B [ ] , int N ) { int cnt = 0 ; int i = 0 ; while ( i < N ) { int j = 0 ; while ( j < N && i < N ) { if ( B [ i ] == A [ j ] ) { i ++ ; } j ++ ; } cnt ++ ; } return cnt ; }
int calculate ( String s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s . charAt ( 0 ) - '0' ) c ++ ; if ( j != s . charAt ( 1 ) - '0' ) c ++ ; if ( k != s . charAt ( 2 ) - '0' ) c ++ ; if ( l != s . charAt ( 3 ) - '0' ) c ++ ; if ( m != s . charAt ( 4 ) - '0' ) c ++ ; if ( n != s . charAt ( 5 ) - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }
void checksum ( int n ) { if ( n % 3 == 0 ) System . out . println ( n / 3 - 1 + " ▁ " + n / 3 + " ▁ " + ( n / 3 + 1 ) ) ; else System . out . println ( " - 1" ) ; }
float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
int minCut ( String a ) { int [ ] cut = new int [ a . length ( ) ] ; boolean [ ] [ ] palindrome = new boolean [ a . length ( ) ] [ a . length ( ) ] ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { int minCut = i ; for ( int j = 0 ; j <= i ; j ++ ) { if ( a . charAt ( i ) == a . charAt ( j ) && ( i - j < 2 palindrome [ j + 1 ] [ i - 1 ] ) ) { palindrome [ j ] [ i ] = true ; minCut = Math . min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . length ( ) - 1 ] ; }
int findOptimalSolution ( int [ ] a , int N ) { Arrays . sort ( a ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( int ) ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int minimunMoves ( String arr [ ] , int n ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_count = 0 ; String tmp = " " ; for ( int j = 0 ; j < n ; j ++ ) { tmp = arr [ j ] + arr [ j ] ; int index = tmp . indexOf ( arr [ i ] ) ; if ( index == arr [ i ] . length ( ) ) return - 1 ; curr_count += index ; } ans = Math . min ( curr_count , ans ) ; } return ans ; }
int count ( String a , String b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
long nthTermOfTheSeries ( int n ) { long nthTerm ; if ( n % 2 == 0 ) nthTerm = ( long ) Math . pow ( n - 1 , 2 ) + n ; else nthTerm = ( long ) Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; }
boolean isPal ( int a [ ] [ ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; }
int seriesSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; }
int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; }
int Solution ( int [ ] A ) { int ans = 2 ; int n = A . length ; if ( n <= 2 ) return n ; int [ ] llap = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) llap [ i ] = 2 ; Arrays . sort ( A ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( i >= 0 && k < n ) { if ( A [ i ] + A [ k ] == 2 * A [ j ] ) { llap [ j ] = Math . max ( llap [ k ] + 1 , llap [ j ] ) ; ans = Math . max ( ans , llap [ j ] ) ; i -= 1 ; k += 1 ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k += 1 ; else i -= 1 ; } } return ans ; }
void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { System . out . println ( i + " ▁ " + j + " ▁ " + k ) ; return ; } } } } } } }
int findSDSFunc ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
void getParity ( int n , int [ ] A ) { for ( int x : A ) { if ( ( x & 1 ) == 1 ) { System . out . println ( " Even " ) ; return ; } } System . out . println ( " Odd " ) ; }
int FindNoOfFullVessels ( int n , int t ) { double Matrix [ ] [ ] = new double [ n ] [ n ] ; Matrix [ 0 ] [ 0 ] = t * 1.0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { double exceededwater = Matrix [ i ] [ j ] - 1.0 ; if ( exceededwater < 0 ) continue ; ans ++ ; if ( i + 1 < n ) Matrix [ i + 1 ] [ j ] += exceededwater / 2 ; if ( i + 1 < n && j + 1 < n ) Matrix [ i + 1 ] [ j + 1 ] += exceededwater / 2 ; } } return ans ; }
void segregate0and1 ( int arr [ ] , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } }
int lbs ( int arr [ ] , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
void rearrange ( int A [ ] , int B [ ] , int N , int X ) { boolean flag = true ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
void checkSolveable ( int n , int m ) { if ( n == 1 m == 1 ) System . out . print ( " YES " ) ; else if ( m == 2 && n == 2 ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; }
void generateNumbers ( int m ) { ArrayList < Integer > numbers = new ArrayList < > ( ) ; int k_max , x ; for ( int y = 0 ; y < 10 ; y ++ ) { k_max = ( int ) ( Math . pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / ( int ) ( Math . pow ( 10 , m - 1 ) + y ) ; for ( int k = 1 ; k <= k_max ; k ++ ) { x = ( int ) ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ; if ( ( int ) ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) numbers . add ( 10 * x + y ) ; } } Collections . sort ( numbers ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) System . out . println ( numbers . get ( i ) ) ; }
int sumofproduct ( int n ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int y = n / x ; ans += ( y * x ) ; } return ans ; }
int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }
void countFreq ( int arr [ ] , int n , int limit ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( i + " ▁ " + count [ i ] ) ; }
int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( ( K - P ) * N ) ; }
int findMaxK ( int N ) { int K = N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }
void isSequenceValid ( int [ ] B , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { System . out . print ( " No " ) ; return ; } } System . out . print ( " Yes " ) ; }
int log_a_to_base_b ( int a , int b ) { int rslt = ( a > b - 1 ) ? 1 + log_a_to_base_b ( a / b , b ) : 0 ; return rslt ; }
boolean CheckForSequence ( int arr [ ] , int n , int k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; }
double angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; double den = Math . sqrt ( Math . pow ( ( x2 - x1 ) , 2 ) + Math . pow ( ( y2 - y1 ) , 2 ) + Math . pow ( ( z2 - z1 ) , 2 ) ) * Math . sqrt ( Math . pow ( ( x3 - x1 ) , 2 ) + Math . pow ( ( y3 - y1 ) , 2 ) + Math . pow ( ( z3 - z1 ) , 2 ) ) ; double angle = Math . acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
int findMinDifference ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; }
void leftRotate ( int arr [ ] , int n , int k ) { int mod = k % n ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ ( i + mod ) % n ] + " ▁ " ) ; System . out . println ( ) ; }
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
int findLCM ( int a , int b ) { int lar = Math . max ( a , b ) ; int small = Math . min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
int solve ( int i , int X , int Y , int a [ ] , int b [ ] , int n ) { if ( i == n ) return 0 ; if ( X <= 0 ) return b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ; if ( Y <= 0 ) return a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) ; else return Math . max ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) , b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
boolean isPerfectSquare ( int x ) { if ( x >= 0 ) { int sr = ( int ) Math . sqrt ( x ) ; return ( ( sr * sr ) == x ) ; } return false ; }
int countWays ( String s ) { int count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) count [ s . charAt ( i ) - ' a ' ] ++ ; count [ s . charAt ( 0 ) - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
int EqualNumbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n != 0 ) return n - 1 ; return n ; }
void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . pow ( 10 , temp ) ; palindrome += n - 1 ; System . out . print ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { System . out . print ( palindrome % 10 ) ; palindrome /= 10 ; } System . out . println ( " " ) ; }
void maximumSum ( int a [ ] , int b [ ] , int k , int n ) { int i , j ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( i = 0 , j = n - 1 ; i < k ; i ++ , j -- ) { if ( a [ i ] < b [ j ] ) { int temp = a [ i ] ; a [ i ] = b [ j ] ; b [ j ] = temp ; } else break ; } int sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; System . out . print ( sum + "NEW_LINE"); }
int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
void solve ( char [ ] a , char [ ] b ) { int l = a . length ; int min = 0 , max = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == ' + ' b [ i ] == ' + ' a [ i ] != b [ i ] ) max ++ ; if ( a [ i ] != ' + ' && b [ i ] != ' + ' && a [ i ] != b [ i ] ) min ++ ; } System . out . print ( min + max + "NEW_LINE"); }
int maxSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
boolean isRepunitNum ( int n , int b ) { int length = 0 ; int countOne = 0 ; while ( n != 0 ) { int r = n % b ; length ++ ; if ( r == 1 ) countOne ++ ; n = n / b ; } return countOne >= 3 && countOne == length ; }
void moveAtEnd ( String s , int i , int l ) { if ( i >= l ) return ; char curr = s . charAt ( i ) ; if ( curr != ' x ' ) System . out . print ( curr ) ; moveAtEnd ( s , i + 1 , l ) ; if ( curr == ' x ' ) System . out . print ( curr ) ; return ; }
void findDay ( int Y , int B ) { int lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Y / 4 ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) System . out . println ( " Monday " ) ; else if ( day == 1 ) System . out . println ( " Tuesday " ) ; else if ( day == 2 ) System . out . println ( " Wednesday " ) ; else if ( day == 3 ) System . out . println ( " Thursday " ) ; else if ( day == 4 ) System . out . println ( " Friday " ) ; else if ( day == 5 ) System . out . println ( " Saturday " ) ; else if ( day == 6 ) System . out . println ( " Sunday " ) ; else System . out . println ( " INPUT ▁ YEAR ▁ IS ▁ WRONG ! " ) ; }
void shuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }
long evenPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
int maxConsecutiveRope ( int ropes [ ] , int N ) { int curSize = 0 ; Arrays . sort ( ropes ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ropes [ i ] <= curSize + 1 ) { curSize = curSize + ropes [ i ] ; } else break ; } return curSize ; }
int countConsecutive ( int N ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; }
int count ( String s , int k ) { int n = s . length ( ) ; int d = 0 , i ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s . charAt ( i ) ; if ( d % k == 0 ) count += 1 ; for ( i = k ; i < n ; i ++ ) { int prev = s . charAt ( i - k ) ; d -= prev ; d += s . charAt ( i ) ; if ( d % k == 0 ) count += 1 ; } return count ; }
void find_Solution ( double x , int n ) { double sum = x , e = 2 , o = 1 , p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( double ) ( o / e ) * ( double ) ( Math . pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } System . out . println ( sum ) ; }
int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; }
int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
int min_remove ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = Math . min ( ans , n - j + i - 1 ) ; } } } return ans ; }
String removeSpace ( String str ) { str = str . replaceAll ( " \\ s " , " " ) ; return str ; }
int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }
boolean getBit ( int num , int i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }
int setBitNumber ( int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return 1 << k ; }
int findXor ( int arr [ ] , int n ) { int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
int minStepK ( int arr [ ] , int N , int K ) { int E = 0 ; int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 == 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return - 1 ; else return K - S ; }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { String str = String . valueOf ( i ) ; countr += str . split ( "1" , - 1 ) . length - 1 ; } return countr ; }
void computeTotient ( int n ) { long phi [ ] = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( " Totient ▁ of ▁ " + i + " ▁ is ▁ " + phi [ i ] ) ; }
int hammingDist ( String str1 , String str2 ) { int i = 0 , count = 0 ; while ( i < str1 . length ( ) ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) count ++ ; i ++ ; } return count ; }
int countGreater ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + " ▁ " ) ; else System . out . print ( 0 + " ▁ " ) ; } System . out . println ( ) ; } return 0 ; }
boolean areEqual ( int arr1 [ ] , int arr2 [ ] ) { int n = arr1 . length ; int m = arr2 . length ; if ( n != m ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
int findCnt ( String s , int i , int r ) { if ( i == s . length ( ) ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ r ] == 1 ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( s . charAt ( i ) - '0' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i ] [ r ] ; }
int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
int maxORminusXOR ( int N ) { int MSB = ( int ) Math . ceil ( Math . log ( N ) ) ; int M = 0 ; for ( int i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; }
double averageSetBits ( int N , int K , int arr [ ] ) { double p = N ; double q = 0 ; for ( int i = 0 ; i < K ; i ++ ) { double _p = p , _q = q ; p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N ; q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N ; } return p ; }
int removals ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ n ] ; Arrays . fill ( dp , - 1 ) ; int ans = n - 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; int j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = Integer . min ( dp [ i ] , j ) ; ans = Integer . min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }
float productOfGP ( float a , float r , int n ) { int an = ( int ) ( a * ( int ) ( Math . pow ( r , n - 1 ) ) ) ; return ( int ) Math . sqrt ( ( int ) Math . pow ( a * an , n ) ) ; }
int Largestpower ( int n , int p ) { int ans = 0 ; while ( n > 0 ) { n /= p ; ans += n ; } return ans ; }
void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) System . out . println ( " Not ▁ possible " ) ; else { int result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } System . out . println ( result ) ; } }
boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }
int maximumSum ( int [ ] a , int [ ] b , int n , int index , int lastpicked ) { if ( index == n ) return 0 ; int option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return Math . max ( option1 , option2 ) ; }
int minimumNumbers ( int n , int s ) { if ( ( s % n ) > 0 ) return s / n + 1 ; else return s / n ; }
int GIF ( double n ) { return ( int ) Math . floor ( n ) ; }
void cal_IST ( int h , double r ) { double IST = ( h * r * 1.0 ) / 360 ; int int_IST = ( int ) IST ; int float_IST = ( int ) Math . ceil ( ( int ) ( ( IST - int_IST ) * 60 ) ) ; System . out . println ( int_IST + " : " + float_IST ) ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 3 ) + ( int ) Math . pow ( n , 2 ) ; }
void maxSum ( int [ ] a , int n ) { int maxAnd = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } System . out . println ( ( maxAnd + maxOR ) ) ; }
int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 1st ▁ octant " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 2nd ▁ octant " ) ; else if ( x < 0 && y < 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 3rd ▁ octant " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 4th ▁ octant " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 5th ▁ octant " ) ; else if ( x < 0 && y >= 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 6th ▁ octant " ) ; else if ( x < 0 && y < 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 7th ▁ octant " ) ; else if ( x >= 0 && y < 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 8th ▁ octant " ) ; }
void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { System . out . print ( "2 ▁ " ) ; } System . out . println ( check ) ; } else { System . out . println ( " - 1" ) ; } }
int toggle ( int n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
float Area ( float a ) { if ( a < 0 ) return - 1 ; float h = ( float ) 1.268 * a ; float A = ( float ) ( 0.70477 * Math . pow ( h , 2 ) ) ; return A ; }
boolean check ( String str ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int ascii = ( int ) str . charAt ( i ) ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }
int avg_of_odd_num ( int n ) { return n ; }
void calculateAngle ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int ABx = x1 - x2 ; int ABy = y1 - y2 ; int ABz = z1 - z2 ; int BCx = x3 - x2 ; int BCy = y3 - y2 ; int BCz = z3 - z2 ; double dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; double magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; double magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; double angle = dotProduct ; angle /= Math . sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / 3.14 ; System . out . printf ( " % .4f " , Math . abs ( angle ) ) ; }
int addOne ( int x ) { return ( - ( ~ x ) ) ; }
int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
int totalNumber ( int n ) { return 8 * ( int ) Math . pow ( 9 , n - 1 ) ; }
int totalMoney ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans += i / 7 ; ans += ( i % 7 + 1 ) ; } return ans ; }
long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
int maxSumWO3Consec ( int A [ ] , int N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; int third = A [ 0 ] ; int second = third + A [ 1 ] ; int first = Math . max ( second , A [ 1 ] + A [ 2 ] ) ; int sum = Math . max ( Math . max ( third , second ) , first ) ; for ( int i = 3 ; i < N ; i ++ ) { sum = Math . max ( Math . max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }
void last_digit ( int X , int Y ) { System . out . print ( X % Y ) ; }
void countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } System . out . println ( numbers_rightmost_setbit_K ) ; }
void printPair ( int n ) { System . out . print ( 1 + " ▁ " + ( n - 1 ) ) ; }
int CountCharacters ( String str , int l , int r ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( l <= str . charAt ( i ) && str . charAt ( i ) <= r ) { cnt ++ ; System . out . print ( str . charAt ( i ) + " ▁ " ) ; } } return cnt ; }
int splitArray ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int result = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
void print_primes_till_N ( int N ) { int i , j , flag ; System . out . println ( " Prime ▁ numbers ▁ between ▁ 1 ▁ and ▁ " + N + " ▁ are : " ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) System . out . print ( i + " ▁ " ) ; } }
int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; }
int oddLengthPalindrome ( int k ) { int palin = k ; k = k / 10 ; while ( k > 0 ) { int rev = k % 10 ; palin = ( palin * 10 ) + rev ; k = k / 10 ; } return palin ; }
boolean canMadeEqual ( int [ ] A , int [ ] B , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != B [ i ] ) { return false ; } } return true ; }
void product_subarrays ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product = product * arr [ j ] ; res *= product ; } } System . out . println ( res + "NEW_LINE"); }
boolean function ( String str ) { int l = str . length ( ) ; int counter [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) counter [ i ] = 0 ; for ( int i = 0 ; i < l / 2 ; i ++ ) counter [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter [ str . charAt ( i ) - ' a ' ] -- ; for ( int i = 0 ; i < MAX ; i ++ ) if ( counter [ i ] != 0 ) return true ; return false ; }
int smallestSumSubarr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = Math . max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; }
void swapThree ( ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }
int count ( int N , int B ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( B - 1 ) * Math . pow ( B , i - 1 ) ; } return sum ; }
void sumArray ( int arr [ ] , int n ) { int leftSum [ ] = new int [ n ] ; int rightSum [ ] = new int [ n ] ; int Sum [ ] = new int [ n ] ; int i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( Sum [ i ] + " ▁ " ) ; }
int maxPrimes ( int n ) { return n / 2 ; }
int find_Area ( int r ) { return ( 2 * r * r ) ; }
void removeSpecialCharacter ( String str ) { char [ ] s = str . toCharArray ( ) ; int j = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } System . out . println ( String . valueOf ( s ) . substring ( 0 , j ) ) ; }
int minimizeCost ( int A , int B , int C ) { int ans = A + B + C ; for ( int i = 1 ; i <= 2 * C ; i ++ ) { int j = 0 ; while ( i * j <= 2 * C ) { ans = Math . min ( ans , Math . abs ( A - i ) + Math . abs ( B - j ) + Math . abs ( i * j - C ) ) ; j ++ ; } } return ans ; }
void evenproduct ( int arr [ ] , int length ) { int total_subarray = length * ( length + 1 ) / 2 ; int total_odd = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < arr . length ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } System . out . println ( total_subarray - total_odd ) ; }
int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; }
int minimumSets ( String s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . length ( ) ; boolean f = false ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s . charAt ( i ) - '0' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s . charAt ( i ) - '0' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; }
int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ; }
String removeChars ( String s ) { String modifiedStr = " " ; modifiedStr += s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( Character . isUpperCase ( s . charAt ( i ) ) && Character . isLowerCase ( s . charAt ( i - 1 ) ) || Character . isLowerCase ( s . charAt ( i ) ) && Character . isUpperCase ( s . charAt ( i - 1 ) ) ) modifiedStr += s . charAt ( i ) ; } return modifiedStr ; }
int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; }
int get_palindrome_time ( String str ) { int hh , mm ; hh = ( str . charAt ( 0 ) - 48 ) * 10 + ( str . charAt ( 1 ) - 48 ) ; mm = ( str . charAt ( 3 ) - 48 ) * 10 + ( str . charAt ( 4 ) - 48 ) ; int requiredTime = 0 ; while ( hh % 10 != mm / 10 hh / 10 != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }
void printExpansion ( String str ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { String subStr = str . substring ( i ) ; System . out . print ( subStr ) ; } }
void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } System . out . print ( " Sum ▁ = ▁ " + sum ) ; System . out . print ( " Product = " + product); }
String fibWord ( int n ) { String Sn_1 = "0" ; String Sn = "01" ; String tmp ; for ( int i = 2 ; i <= n ; i ++ ) { tmp = Sn ; Sn += Sn_1 ; Sn_1 = tmp ; } return Sn ; }
int countPairs ( int arr [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; }
void printLargest ( int a [ ] , int n ) { int max = - 1 ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num > 0 ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( int i = ind ; i < n ; i ++ ) System . out . print ( a [ i ] ) ; for ( int i = 0 ; i < ind ; i ++ ) System . out . print ( a [ i ] ) ; }
void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { System . out . print ( " A ▁ = ▁ " + A / 3 + " , ▁ B ▁ = ▁ " + B + " , ▁ C ▁ = ▁ " + C ) ; return ; } } } System . out . println ( - 1 ) ; }
String tidyNum ( String str1 , int len ) { char [ ] str = str1 . toCharArray ( ) ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( int j = i + 1 ; j < len ; j ++ ) str [ j ] = '9' ; } } return String . valueOf ( str ) ; }
int findCost ( int cost_mat [ ] [ ] , int N , int M ) { int dp [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < M ; i ++ ) dp [ 0 ] [ i ] = cost_mat [ 0 ] [ i ] ; for ( int row = 1 ; row < N ; row ++ ) { for ( int curr_col = 0 ; curr_col < M ; curr_col ++ ) { int val = 999999999 ; for ( int prev_col = 0 ; prev_col < M ; prev_col ++ ) { if ( curr_col != prev_col ) val = Math . min ( val , dp [ row - 1 ] [ prev_col ] ) ; } dp [ row ] [ curr_col ] = val + cost_mat [ row ] [ curr_col ] ; } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < M ; i ++ ) ans = Math . min ( ans , dp [ N - 1 ] [ i ] ) ; return ans ; }
int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; }
int minReplacement ( String s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) == '1' ) ans ++ ; if ( i % 2 == 1 && s . charAt ( i ) == '0' ) ans ++ ; } return Math . min ( ans , len - ans ) ; }
void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( curr_term + " ▁ " ) ; curr_term = curr_term + d ; } }
int minCost ( int A [ ] , int n ) { int cost = 0 ; Arrays . sort ( A ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; }
int calculate ( int ar [ ] , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }
void lengchord ( int z ) { System . out . println ( " The ▁ length ▁ is ▁ " + z ) ; }
void checkSuffix ( int A , int B ) { String s1 = String . valueOf ( A ) ; String s2 = String . valueOf ( B ) ; boolean result ; result = s1 . endsWith ( s2 ) ; if ( result ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } }
double cubeRoot ( double n ) { double ans = Math . pow ( 3 , ( ( 1.0 / 3 ) * ( Math . log ( n ) / Math . log ( 3 ) ) ) ) ; return ans ; }
int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }
void Selection_Sort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { int min_index = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( arr [ j ] < arr [ min_index ] ) min_index = j ; } int temp = arr [ i ] ; arr [ i ] = arr [ min_index ] ; arr [ min_index ] = temp ; } }
int evenSum ( int n ) { return ( n * ( n + 1 ) ) ; }
void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + " ▁ " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
int distIntegers ( int L , int R ) { return 2 * R - 2 * L + 1 ; }
int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }
int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }
void constructArray ( int N , int K , int X ) { int [ ] ans = new int [ K ] ; ans [ 0 ] = X ; for ( int i = 0 ; i < N ; ++ i ) { System . out . print ( ans [ i % K ] + " ▁ " ) ; } }
void printMedian ( int arr [ ] , int n , int K ) { Arrays . sort ( arr ) ; System . out . print ( arr [ ( n + K ) / 2 ] ) ; }
int getMissingNo ( int a [ ] , int n ) { int n_elements_sum = n * ( n + 1 ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; }
int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
int solve ( int n , int m ) { int ans = n * ( m / 2 ) ; if ( m % 2 == 1 ) { ans += ( n + 1 ) / 2 ; } return ans ; }
int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; c = a + b ; a = b ; b = c ; } return sum ; }
void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { System . out . print ( " x2 ▁ = ▁ " + ( 2 * c1 - x1 ) + " ▁ " ) ; System . out . print ( " y2 ▁ = ▁ " + ( 2 * c2 - y1 ) ) ; }
int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; }
int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
int totalPay ( int totalItems , int priceOfOneItem , int N , int M ) { int freeItems = 0 , actual = 0 ; freeItems = totalItems / ( N + M ) ; actual = totalItems - freeItems ; int amount = actual * priceOfOneItem ; return amount ; }
int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = Math . floorDiv ( base , 2 ) ; return base * ( base + 1 ) / 2 ; }
int countOfBase ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; ++ i ) { int highestPower = ( int ) ( Math . log ( N ) / Math . log ( i ) ) ; int firstDigit = N / ( int ) Math . pow ( i , highestPower ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
String getResult ( int n ) { String st = String . valueOf ( n ) ; int sum = 0 ; for ( char i : st . toCharArray ( ) ) { sum = sum + ( int ) i ; } if ( n % sum == 0 ) return " Yes " ; else return " No " ; }
int largestAnagramSet ( String arr [ ] , int n ) { int maxSize = 0 ; HashMap < String , Integer > count = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { char temp [ ] = arr [ i ] . toCharArray ( ) ; Arrays . sort ( temp ) ; arr [ i ] = new String ( temp ) ; if ( count . containsKey ( arr [ i ] ) ) { count . put ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; } else { count . put ( arr [ i ] , 1 ) ; } maxSize = Math . max ( maxSize , count . get ( arr [ i ] ) ) ; } return maxSize ; }
void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; System . out . println ( res ) ; }
Boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
boolean isDivisible ( int N ) { return ( N - 1 ) % 3 != 0 ; }
int findCnt ( int [ ] arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; int x = Math . max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }
int countPieces ( int N ) { return 2 * N ; }
int extrema ( int a [ ] , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; }
int findPairCount ( int N , int K ) { int count = 0 ; int rem [ ] = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
int gonNum65537 ( int n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; }
int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = ( int ) Math . pow ( ( PX - X ) , 2 ) + ( int ) Math . pow ( ( PY - Y ) , 2 ) ; if ( val > Math . pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; return 0 ; }
void findNthTerm ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { ans = ans + 6 ; } else { ans = ans + 2 ; } } System . out . print ( ans + "NEW_LINE"); }
void parallel ( int a [ ] [ ] ) { boolean x = true , y = true ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } if ( x ) System . out . println ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; else if ( y ) System . out . println ( " Parallel ▁ to ▁ X ▁ Axis " ) ; else System . out . println ( " Not ▁ parallel ▁ to ▁ X " + " ▁ and ▁ Y ▁ axis " ) ; }
int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }
int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
void printKthBit ( long n , long k ) { System . out . println ( ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ) ; }
int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; }
int getMaxSum ( int a [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 0 ] ; int max_sum = Math . max ( dp [ 0 ] [ 0 ] , dp [ 0 ] [ 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( a [ i ] , dp [ i - 1 ] [ 0 ] + a [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] + a [ i ] , a [ i ] * a [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] + a [ i ] * a [ i ] ) ; max_sum = Math . max ( max_sum , dp [ i ] [ 1 ] ) ; max_sum = Math . max ( max_sum , dp [ i ] [ 0 ] ) ; } return max_sum ; }
int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) System . out . print ( a + " ▁ " ) ; if ( n >= 1 ) System . out . print ( b + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; System . out . print ( c + " ▁ " ) ; a = b ; b = c ; } }
boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { int last_digit = ( int ) n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
long getNthTerm ( long N ) { return ( ( int ) Math . pow ( N , 2 ) + N + 1 ) ; }
int oddSum ( int n ) { return ( n * n ) ; }
int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
void findOptimalPairs ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) System . out . print ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " ▁ " ) ; }
void findPosition ( int n ) { int i = 0 ; int pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + ( int ) Math . pow ( 2 , i + 1 ) ; } else { pos = pos + ( int ) Math . pow ( 2 , i ) ; } i ++ ; n = n / 10 ; } System . out . print ( pos ) ; }
void evenproduct ( int arr [ ] , int length ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int product = 1 ; for ( int j = i ; j < arr . length ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } System . out . println ( count ) ; }
int cntSquares ( int n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }
int averageValue ( String s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum_char += ( int ) s . charAt ( i ) ; } return sum_char / s . length ( ) ; }
int numberOfObjects ( int N , int M ) { int initial = Math . min ( N , M ) ; int last = ( N + M ) / 3 ; return Math . min ( initial , last ) ; }
int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; }
int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
int maxOfSegmentMins ( int [ ] a , int n , int k ) { if ( k == 1 ) { Arrays . sort ( a ) ; return a [ 0 ] ; } if ( k == 2 ) return Math . max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; }
void TwentyoneMatchstick ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i += 1 ) { System . out . print ( 5 - arr [ i ] + " ▁ " ) ; } System . out . println ( ) ; }
long getBoundarySum ( int a [ ] [ ] , int m , int n ) { long sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }
boolean orthogonality ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; if ( dsquare == r1 * r1 + r2 * r2 ) return true ; else return false ; }
int getHCF ( int x , int y ) { int minimum = Math . min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
String evenlength ( String n ) { String res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n . charAt ( j ) ; return res ; }
boolean is_linear ( String s ) { int tmp = 0 ; char first = s . charAt ( 0 ) ; for ( int pos = 0 ; pos < s . length ( ) ; pos += tmp ) { if ( s . charAt ( pos ) != first ) { return false ; } tmp ++ ; } return true ; }
void countSubsequences ( int [ ] A ) { int odd = 0 ; int even = 0 ; for ( int el : A ) { if ( el % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) System . out . println ( 0 ) ; else System . out . println ( 1 << ( A . length - 1 ) ) ; }
int myXOR ( int x , int y ) { int res = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { int b1 = ( ( x & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int b2 = ( ( y & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int xoredBit = ( ( b1 & b2 ) != 0 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }
int divisorGame ( int N , int A , int dp [ ] [ ] ) { if ( N == 1 N == 3 ) return 0 ; if ( N == 2 ) return 1 ; if ( dp [ N ] [ A ] != - 1 ) return dp [ N ] [ A ] ; int ans = ( A == 1 ) ? 0 : 1 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A == 1 ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N ] [ A ] = ans ; }
long spellsCount ( String num ) { int n = num . length ( ) ; long result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num . charAt ( i + 1 ) == num . charAt ( i ) ) { count ++ ; i ++ ; } result = result * ( long ) Math . pow ( 2 , count - 1 ) ; } return result ; }
boolean checkMarkov ( double m [ ] [ ] ) { for ( int i = 0 ; i < m . length ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m [ i ] . length ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
int countDigitsToBeRemoved ( int N , int K ) { String s = Integer . toString ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s . charAt ( i ) == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K == 0 ) return res ; else if ( f_zero == 1 ) return s . length ( ) - 1 ; return - 1 ; }
int numBoxes ( int A [ ] , int n , int K ) { Arrays . sort ( A ) ; int i = 0 , j = n - 1 ; int ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; }
int sumOfDivisors ( int N ) { return N ; }
void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( ( A + i * d ) + " ▁ " ) ; }
void findLargestIndex ( int arr [ ] , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == i ) { System . out . println ( i ) ; return ; } } System . out . println ( - 1 ) ; }
int PentacontahenagonNum ( int N ) { return ( 49 * N * N - 47 * N ) / 2 ; }
int findMaximumScore ( int [ ] a , int n ) { @ SuppressWarnings ( " unchecked " ) HashMap < Integer , Integer > freq = new HashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( a [ i ] ) ) { freq . put ( a [ i ] , freq . get ( a [ i ] ) + 1 ) ; } else { freq . put ( a [ i ] , 1 ) ; } } int [ ] dp = new int [ Arrays . stream ( a ) . max ( ) . getAsInt ( ) + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = freq . get ( 1 ) ; for ( int i = 2 ; i < dp . length ; i ++ ) dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ i - 2 ] + freq . get ( i ) * i ) ; return dp [ dp . length - 1 ] ; }
double AreaofRectangle ( int L , int W ) { double area = ( W + L ) * ( W + L ) / 2 ; return area ; }
String possibleToSort ( int arr [ ] , int n , String str ) { int max_element = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str . charAt ( i ) == '0' ) { if ( max_element > i + 1 ) return " No " ; } } return " Yes " ; }
int minFlips ( String target ) { char curr = '1' ; int count = 0 ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { if ( target . charAt ( i ) == curr ) { count ++ ; curr = ( char ) ( 48 + ( curr + 1 ) % 2 ) ; } } return count ; }
long SubArraySum ( int arr [ ] , int n ) { long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
int minDistance ( int start [ ] , int end [ ] , int n , int d ) { int left = Integer . MIN_VALUE ; int right = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { left = Math . max ( left , start [ i ] ) ; right = Math . min ( right , end [ i ] ) ; } if ( left > right ) return - 1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return ( left - d ) ; if ( d > right ) return ( d - right ) ; return - 1 ; }
boolean isInteger ( double N ) { int X = ( int ) N ; double temp2 = N - X ; if ( temp2 > 0 ) { return false ; } return true ; }
int distinctSubString ( String P , int N ) { HashSet < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { boolean [ ] freq = new boolean [ 26 ] ; String s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P . charAt ( j ) - ' a ' ; if ( freq [ pos ] == true ) break ; freq [ pos ] = true ; s += P . charAt ( j ) ; S . add ( s ) ; } } return S . size ( ) ; }
boolean findPartition ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; boolean part [ ] [ ] = new boolean [ sum / 2 + 1 ] [ n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ; for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i ] [ 0 ] = false ; for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } } return part [ sum / 2 ] [ n ] ; }
> getArray ( int n ) { Vector < Long > ans = new Vector < Long > ( ) ; long p2 = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) ans . add ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }
int divisible ( String num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; }
boolean pointsAreOnSameSideOfLine ( int a , int b , int c , int x1 , int y1 , int x2 , int y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }
void printmaxSubseq ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( i + 1 < n && arr [ i ] < arr [ i + 1 ] ) System . out . print ( arr [ i ] + " ▁ " ) ; else System . out . print ( arr [ i ] + "NEW_LINE"); } }
int equalXORandOR ( int n ) { int m = 0 ; int MSB = ( int ) Math . log ( n ) ; for ( int i = 0 ; i <= MSB ; i ++ ) { if ( ( n & ( 1 << i ) ) <= 0 ) { m += ( 1 << i ) ; } } return m ; }
boolean search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
int FindSum ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ; int LesserValue = ( int ) Math . pow ( 2 , power ) ; int LargerValue = ( int ) Math . pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; }
int calcScore ( String str ) { int score = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; ) { int chunkSize = 1 ; char currentChar = str . charAt ( i ++ ) ; while ( i < len && str . charAt ( i ) == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == '1' ) score += Math . pow ( chunkSize , 2 ) ; else score -= Math . pow ( chunkSize , 2 ) ; } return score ; }
void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; System . out . print ( first + " ▁ " ) ; if ( n > 1 ) System . out . print ( second + " ▁ " ) ; if ( n > 2 ) System . out . print ( second + " ▁ " ) ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; System . out . print ( curr + " ▁ " ) ; } }
int countPairs ( int arr [ ] , int k ) { Arrays . sort ( arr ) ; int pair = 0 ; int index = 0 ; while ( index < arr . length - 1 ) { if ( arr [ index + 1 ] - arr [ index ] <= k ) { pair += 1 ; index += 2 ; } else { index += 1 ; } } return pair ; }
void printPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " , ▁ " ) ; } } }
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
void generate_derangement ( int N ) { int S [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( D [ i ] + " ▁ " ) ; System . out . println ( ) ; }
String maxInt ( char str [ ] ) { for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] < '5' ) { str [ i ] = ( char ) ( ( '9' - str [ i ] ) + '0' ) ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '9' ; String str2 = new String ( str ) ; return str2 ; }
void longestSubsequence ( int arr [ ] , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } System . out . println ( count ) ; }
long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
void printSubstrings ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) { System . out . print ( str . charAt ( k ) ) ; } System . out . println ( ) ; } } }
int maxProd ( int n ) { if ( n == 2 n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
int floorMax ( int A , int B , int N ) { int x = Math . min ( B - 1 , N ) ; return ( A * x ) / B ; }
void PrintReverseOrder ( int N ) { for ( int i = N ; i > 0 ; i -- ) System . out . print ( + i + " ▁ " ) ; }
void nDigitPerfectSquares ( int n ) { int smallest = ( int ) Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) ; System . out . print ( smallest + " ▁ " ) ; int largest = ( int ) Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ; System . out . print ( largest ) ; }
void AreaFactor ( int n ) { double pi = 3.14159265 ; double areaf = 1 / ( Math . cos ( pi / n ) * Math . cos ( pi / n ) ) ; System . out . format ( " % .6f " , areaf ) ; }
void countPairs ( int [ ] arr , int N ) { int count = 0 ; Map < Double , Integer > mp = new HashMap < Double , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Double val = 1.0 * arr [ i ] ; Double idx = 1.0 * ( i + 1 ) ; if ( mp . containsKey ( val / idx ) ) count += mp . get ( val / idx ) ; if ( mp . containsKey ( val / idx ) ) mp . put ( val / idx , mp . getOrDefault ( val / idx , 0 ) + 1 ) ; else mp . put ( val / idx , 1 ) ; } System . out . print ( count ) ; }
boolean isEven ( int n ) { if ( ( n ^ 1 ) == n + 1 ) return true ; else return false ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
void print_result ( int a [ ] , int n , int k , int m ) { Vector < Vector < Integer > > v = new Vector < Vector < Integer > > ( m ) ; for ( int i = 0 ; i < m ; i ++ ) v . add ( new Vector < Integer > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v . get ( rem ) . add ( a [ i ] ) ; if ( v . get ( rem ) . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) System . out . print ( v . get ( rem ) . get ( j ) + " ▁ " ) ; return ; } } System . out . print ( " - 1" ) ; }
void minCost ( String str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( Math . abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += Math . min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; System . out . print ( result + "NEW_LINE"); }
void rangeSum ( int arr [ ] , int N , int L , int R ) { int prefix [ ] = new int [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; System . out . print ( rightsum - leftsum ) ; }
int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . cbrt ( n ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
int countofPermutations ( int N ) { return ( int ) ( 3 * Math . pow ( 2 , N - 1 ) ) ; }
int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; }
int strScore ( String str [ ] , String s , int n ) { HashMap < String , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m . put ( str [ i ] , i + 1 ) ; if ( ! m . containsKey ( s ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) score += s . charAt ( i ) - ' a ' + 1 ; score = score * m . get ( s ) ; return score ; }
int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
long findWays ( int m , int n , int x ) { long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { for ( int k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; }
int countTriplets ( int N , int K ) { if ( K % 2 == 0 ) { int x = N / K ; int y = ( N + ( K / 2 ) ) / K ; return x * x * x + y * y * y ; } else { int x = N / K ; return x * x * x ; } }
int countTriplets ( int a [ ] , int n , int x ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { Vector < Integer > temp = new Vector < > ( ) ; temp . add ( a [ i ] ) ; temp . add ( a [ j ] ) ; temp . add ( a [ k ] ) ; Collections . sort ( temp ) ; if ( temp . get ( 0 ) < temp . get ( 1 ) && temp . get ( 1 ) < temp . get ( 2 ) && temp . get ( 0 ) * temp . get ( 1 ) * temp . get ( 2 ) <= x ) answer ++ ; } } } return answer ; }
boolean istetradecagonal ( int N ) { double n = ( 10 + Math . sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - ( int ) n ) == 0 ; }
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
int singleNumber ( int [ ] nums , int n ) { HashMap < Integer , Integer > m = new HashMap < > ( ) ; long sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m . containsKey ( nums [ i ] ) ) { sum1 += nums [ i ] ; m . put ( nums [ i ] , 1 ) ; } sum2 += nums [ i ] ; } return ( int ) ( 2 * ( sum1 ) - sum2 ) ; }
double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }
int minPushes ( int N , int K , int [ ] arr ) { int [ ] dp = new int [ 100000 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; dp [ N ] = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int xx = 0 ; xx < 100000 ; xx ++ ) { int x = xx ; if ( dp [ x ] == - 1 ) continue ; int next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == - 1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }
boolean check ( String s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return true ; return false ; }
boolean isDivBy2PowerM ( int n , int m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
String even_or_odd ( String N ) { int len = N . length ( ) ; if ( N . charAt ( len - 1 ) == '0' || N . charAt ( len - 1 ) == '2' || N . charAt ( len - 1 ) == '4' || N . charAt ( len - 1 ) == '6' ) return ( " Even " ) ; else return ( " Odd " ) ; }
String decryptString ( String str , int n ) { int i = 0 , jump = 1 ; String decryptedStr = " " ; while ( i < n ) { decryptedStr += str . charAt ( i ) ; i += jump ; jump ++ ; } return decryptedStr ; }
void findEquation ( int a , int b , int c ) { int X = ( a + b + c ) ; int Y = ( a * b ) + ( b * c ) + ( c * a ) ; int Z = a * b * c ; System . out . print ( " x ^ 3 ▁ - ▁ " + X + " x ^ 2 ▁ + ▁ " + Y + " x ▁ - ▁ " + Z + " ▁ = ▁ 0" ) ; }
boolean isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; }
void printString ( char [ ] str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; boolean used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) System . out . print ( "1" ) ; } if ( str [ i ] != '1' ) System . out . print ( str [ i ] ) ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) System . out . print ( "1" ) ; }
void kthpair ( int n , int k , int arr [ ] ) { int i , t = 0 ; Arrays . sort ( arr ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } System . out . print ( arr [ i ] + " ▁ " + arr [ k / t ] ) ; }
void findGreater ( int a , int b , int n ) { if ( ! ( ( n & 1 ) > 0 ) ) { a = Math . abs ( a ) ; b = Math . abs ( b ) ; } if ( a == b ) System . out . println ( " a ^ n ▁ is ▁ " + " equal ▁ to ▁ b ^ n " ) ; else if ( a > b ) System . out . println ( " a ^ n ▁ is ▁ greater ▁ " + " than ▁ b ^ n " ) ; else System . out . println ( " b ^ n ▁ is ▁ greater ▁ " + " than ▁ a ^ n " ) ; }
boolean isPowerofTwo ( int n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }
int nobleInteger ( int arr [ ] ) { Arrays . sort ( arr ) ; int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
void numberofBoxes ( int W , int B , int O ) { int low = 0 , high = Math . min ( W , B ) ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( ( ( W >= mid ) && ( B >= mid ) ) && ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } System . out . println ( ans ) ; }
void push ( int new_data ) { Node new_node = new Node ( new_data ) ; new_node . next = head ; head = new_node ; }
boolean isDudeney ( int n ) { int cube_rt = ( int ) ( Math . round ( ( Math . pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; int dig_sum = 0 ; int temp = n ; while ( temp > 0 ) { int rem = temp % 10 ; dig_sum += rem ; temp /= 10 ; } if ( cube_rt != dig_sum ) return false ; return true ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
double findEdges ( double s1 , double s2 , double s3 ) { double a = Math . sqrt ( s1 * s2 / s3 ) ; double b = Math . sqrt ( s3 * s1 / s2 ) ; double c = Math . sqrt ( s3 * s2 / s1 ) ; double sum = a + b + c ; return 4 * sum ; }
int TrialDivision ( int N ) { int i = 2 ; int k = ( int ) Math . ceil ( Math . sqrt ( N ) ) ; while ( i <= k ) { if ( N % i == 0 ) return 0 ; i += 1 ; } return 1 ; }
int findMinimumCost ( int n , int x , int y ) { int dp [ ] = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; }
int minimumPossibleProduct ( int K ) { int res = 1 ; int range = ( 1 << K ) - 1 ; for ( int i = 0 ; i < K ; i ++ ) { res *= ( range - 1 ) ; } res *= range ; return res ; }
int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 1 - j ) ) ; int dis_18 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 8 - j ) ) ; int dis_81 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 1 - j ) ) ; int dis_88 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
long countStrings ( long A , long B , long K ) { long X = ( A + B ) / ( K + 1 ) ; return ( Math . min ( A , Math . min ( B , X ) ) * ( K + 1 ) ) ; }
int maxGCD ( int N , int K ) { int minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return - 1 ; int i = ( int ) Math . sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = Math . max ( res , N / i ) ; if ( N / i >= minSum ) res = Math . max ( res , i ) ; } i -- ; } return res ; }
void findSum ( int A [ ] , int N , int K ) { Arrays . sort ( A ) ; int sum = 0 ; for ( int i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } System . out . print ( sum ) ; }
int maxPlanes ( int [ ] A , int [ ] B ) { Set < Integer > St = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { int t = ( A [ i ] % B [ i ] > 0 ) ? 1 : 0 ; t += ( A [ i ] / B [ i ] ) + t ; St . add ( t ) ; } return St . size ( ) ; }
float area ( float r ) { if ( r < 0 ) return - 1 ; float area = ( float ) ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }
void printPFsInPairs ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) System . out . println ( i + " * " + n / i ) ; }
void printSinX ( int N ) { int Xi = 0 ; int num = 1 ; while ( N -- > 0 ) { System . out . print ( " X " + num + " ▁ = ▁ " + Xi ) ; System . out . print ( " ▁ sin ( X " + num + " ) ▁ = ▁ " ) ; System . out . printf ( " % .6f " , Math . sin ( Xi ) ) ; System . out . println ( ) ; num += 1 ; Xi += 710 ; } }
String check ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) count ++ ; } if ( ( count & 1 ) != 0 ) return " Odd " ; else return " Even " ; }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; System . out . print ( num + " ▁ " ) ; } }
void findEquation ( int a , int b ) { int sum = ( a + b ) ; int product = ( a * b ) ; System . out . println ( " x ^ 2 ▁ - ▁ ( " + sum + " x ) ▁ + ▁ ( " + product + " ) ▁ = ▁ 0" ) ; }
boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }
void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = new int [ n ] ; Arrays . fill ( count_jump , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count_jump [ i ] + " ▁ " ) ; }
void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
int motzkin ( int n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; }
float diagonal_length ( float a ) { float L ; L = a * ( float ) Math . sqrt ( 3 ) ; return L ; }
void printNumHavingAltBitPatrn ( int n ) { int curr_num = 1 , i = 1 ; System . out . print ( curr_num + " ▁ " ) ; while ( i != 0 ) { i ++ ; curr_num <<= 1 ; if ( n < curr_num ) break ; System . out . print ( curr_num + " ▁ " ) ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; System . out . print ( curr_num + " ▁ " ) ; } }
void makeArray ( int a [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( i * n + " ▁ " ) ; }
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
void bestApproximate ( int x [ ] , int y [ ] ) { int n = x . length ; double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; System . out . println ( " m ▁ = ▁ " + m ) ; System . out . println ( " c ▁ = ▁ " + c ) ; }
int minValue ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int minimum = arr [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }
void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
int placeValue ( int N , int num ) { int total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = N / 10 ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }
int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
int countNumbers ( int n ) { return ( n / 2520 ) ; }
int sumOfSeries ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { boolean [ ] visited = new boolean [ N + 1 ] ; int minimumSwaps = 0 ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }
float hexagonside ( float a ) { if ( a < 0 ) return - 1 ; float x = a / 3 ; return x ; }
int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ 2 * n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
void findScoreSum ( int n ) { int F = n / 7 ; int D = n % 7 ; int fullWeekScore = ( 49 + 7 * F ) * F / 2 ; int lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; System . out . println ( fullWeekScore + lastNonFullWeekScore ) ; }
void findSquareSum ( int Coordinates [ ] [ ] , int N ) { long xq = 0 , yq = 0 ; long xs = 0 , ys = 0 ; long res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int a , b ; a = Coordinates [ i ] [ 0 ] ; b = Coordinates [ i ] [ 1 ] ; res += xq ; res -= 2 * xs * a ; res += i * ( long ) ( a * a ) ; xq += a * a ; xs += a ; res += yq ; res -= 2 * ys * b ; res += i * ( long ) b * b ; yq += b * b ; ys += b ; } System . out . println ( res ) ; }
int getMaximum ( int N , int M , int [ ] [ ] mat ) { int global_max = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int row_min = Integer . MAX_VALUE ; for ( int k = 0 ; k < M ; k ++ ) { int m = Math . max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) ; row_min = Math . min ( row_min , m ) ; } global_max = Math . max ( global_max , row_min ) ; } } return global_max ; }
void digitsNum ( int N ) { if ( N == 0 ) System . out . println ( "0" ) ; if ( N % 9 != 0 ) System . out . print ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) System . out . print ( "9" ) ; for ( int i = 1 ; i <= N ; ++ i ) System . out . print ( "0" ) ; System . out . print ( " " ) ; }
double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
boolean checkDivisbility ( int num ) { int digit ; int N = num ; while ( num != 0 ) { digit = num % 10 ; num = num / 10 ; if ( digit == 0 N % digit != 0 ) return false ; } return true ; }
void max_element ( int a [ ] , int n ) { int [ ] pre = new int [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = Math . max ( pre [ i - 1 ] , a [ i ] ) ; int [ ] suf = new int [ n ] ; suf [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = Math . max ( suf [ i + 1 ] , a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) System . out . print ( suf [ i + 1 ] + " ▁ " ) ; else if ( i == n - 1 ) System . out . print ( pre [ i - 1 ] + " ▁ " ) ; else System . out . print ( Math . max ( pre [ i - 1 ] , suf [ i + 1 ] ) + " ▁ " ) ; } }
void series ( int A , int X , int n ) { int term = ( int ) Math . pow ( A , n ) ; System . out . print ( term + " ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; System . out . print ( term + " ▁ " ) ; } }
double sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; }
int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }
void constructArray ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( i + " ▁ " ) ; } }
void findPairs ( int A , int B ) { for ( int i = 1 ; i <= B ; i ++ ) { int y = A ^ i ; if ( y > 0 && ( i y ) == B ) { System . out . println ( i + " ▁ " + y ) ; } } }
int Pentatope_number ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }
int countOnes ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int countNumbers ( int N ) { return ( int ) Math . sqrt ( N ) - 1 ; }
void printCombination ( int n ) { System . out . print ( 1 + " ▁ " ) ; if ( ( n - 2 ) % 3 == 0 ) System . out . print ( 2 + " ▁ " + ( n - 3 ) ) ; else System . out . print ( 1 + " ▁ " + ( n - 2 ) ) ; }
void countNumbers ( int n , int d ) { int total = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } System . out . println ( total ) ; }
int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = ( int ) Math . sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
int Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; }
int minimumChar ( String S1 , String S2 ) { int n = S1 . length ( ) ; int m = S2 . length ( ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 . charAt ( j ) != S2 . charAt ( i + j ) ) { minRemovedChar ++ ; } } ans = Math . min ( minRemovedChar , ans ) ; } return ans ; }
int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }
int xorK ( int n , int k ) { if ( k % 2 == 1 ) return n ; return 0 ; }
int seriesSum ( int n ) { int sum = 0 ; int currProd = 1 ; int currSum = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; }
void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } System . out . print ( N - Count ) ; }
int countTripletsLessThanL ( int n , int L , int [ ] arr ) { Arrays . sort ( arr ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
long maximumNum ( long X , long Y , long N ) { long num = 0 ; if ( N - N % X + Y <= N ) { num = N - N % X + Y ; } else { num = N - N % X - ( X - Y ) ; } return num ; }
void findNumbers ( int aXORb , int aANDb , int aXORc , int aANDc , int bXORc , int bANDc ) { int a , b , c ; int aSUMb ; int aSUMc ; int bSUMc ; aSUMb = aXORb + aANDb * 2 ; aSUMc = aXORc + aANDc * 2 ; bSUMc = bXORc + bANDc * 2 ; a = ( aSUMb - bSUMc + aSUMc ) / 2 ; b = aSUMb - a ; c = aSUMc - a ; System . out . print ( " a ▁ = ▁ " + a ) ; System . out . print ( " , ▁ b ▁ = ▁ " + b ) ; System . out . print ( " , ▁ c ▁ = ▁ " + c ) ; }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; }
int maxCountAB ( String s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String S = s [ i ] ; int L = S . length ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . charAt ( j ) == ' A ' && S . charAt ( j + 1 ) == ' B ' ) { ans ++ ; } } if ( S . charAt ( 0 ) == ' B ' && S . charAt ( L - 1 ) == ' A ' ) BA ++ ; else if ( S . charAt ( 0 ) == ' B ' ) B ++ ; else if ( S . charAt ( L - 1 ) == ' A ' ) A ++ ; } if ( BA == 0 ) ans += Math . min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . min ( B , A ) ; return ans ; }
double hexagonside ( double a ) { if ( a < 0 ) return - 1 ; double x = ( 0.5176 * a ) ; return x ; }
int min_steps_required ( int n , int m , int r , int c ) { int i , j ; int corner_steps_req = Integer . MAX_VALUE ; i = 1 ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; int minimum_steps = Math . min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }
void removeRepeating ( String s1 , String s2 ) { String s3 = s1 + " ▁ " + s2 + " ▁ " ; String words = " " ; int i = 0 ; for ( char x : s3 . toCharArray ( ) ) { if ( x == ' ▁ ' ) { if ( ! s1 . contains ( words ) || ! s2 . contains ( words ) ) System . out . print ( words ) ; words = " ▁ " ; } else { words = words + x ; } } }
void countOccurrences ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } System . out . print ( count ) ; }
int minSteps ( String str , int n , int k ) { if ( str . charAt ( n - 1 ) == '0' ) return - 1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; int dp [ ] = new int [ n ] ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( int i = n - 4 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '0' ) continue ; int steps = INT_MAX ; if ( i + k < n && str . charAt ( i + k ) == '1' ) steps = Math . min ( steps , dp [ i + k ] ) ; if ( str . charAt ( i + 1 ) == '1' ) steps = Math . min ( steps , dp [ i + 1 ] ) ; if ( str . charAt ( i + 2 ) == '1' ) steps = Math . min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == INT_MAX ) ? steps : 1 + steps ; } if ( dp [ 0 ] == INT_MAX ) return - 1 ; return dp [ 0 ] ; }
void printRepeating ( int arr [ ] , int size ) { int i ; System . out . println ( " The ▁ repeating ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else System . out . print ( Math . abs ( arr [ i ] ) + " ▁ " ) ; } }
int longestUniqueSubsttr ( String str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { boolean [ ] visited = new boolean [ 256 ] ; for ( int j = i ; j < n ; j ++ ) { if ( visited [ str . charAt ( j ) ] == true ) break ; else { res = Math . max ( res , j - i + 1 ) ; visited [ str . charAt ( j ) ] = true ; } } visited [ str . charAt ( i ) ] = false ; } return res ; }
boolean checkZeroArray ( int [ ] arr , int n ) { int sum = 0 , maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] ; maximum = Math . max ( maximum , arr [ i ] ) ; } if ( sum % 2 == 0 && maximum <= sum / 2 ) return true ; return false ; }
int maxProfit ( int price [ ] , int n ) { int buy1 , profit1 , buy2 , profit2 ; buy1 = buy2 = Integer . MAX_VALUE ; profit1 = profit2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { buy1 = Math . min ( buy1 , price [ i ] ) ; profit1 = Math . max ( profit1 , price [ i ] - buy1 ) ; buy2 = Math . min ( buy2 , price [ i ] - profit1 ) ; profit2 = Math . max ( profit2 , price [ i ] - buy2 ) ; } return profit2 ; }
int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
void maximumSum ( int [ ] arr , int N ) { int sum ; Arrays . sort ( arr ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; System . out . println ( sum ) ; }
int Pentadecagonal_num ( int n ) { return ( 13 * n * n - 11 * n ) / 2 ; }
int cntOnesArrWithGivenOp ( int arr [ ] , int N ) { int cntOnes = 0 ; cntOnes = ( int ) Math . sqrt ( N ) ; return cntOnes ; }
int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
void productOfTwoPerfectCubes ( double N ) { double cube_root ; cube_root = Math . round ( Math . cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { System . out . println ( " Yes " ) ; return ; } else { System . out . println ( " No " ) ; return ; } }
int minimumLength ( String s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }
> ConstructList ( int [ ] [ ] Q ) { int xor = 0 ; List < Integer > ans = new ArrayList < > ( ) ; for ( int i = Q . length - 1 ; i >= 0 ; i -- ) { if ( Q [ i ] [ 0 ] == 0 ) ans . add ( Q [ i ] [ 1 ] ^ xor ) ; else xor ^= Q [ i ] [ 1 ] ; } ans . add ( xor ) ; Collections . sort ( ans ) ; return ans ; }
void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( ( 10 * rem ) / n ) ; rem = ( 10 * rem ) % n ; } }
int product ( int a [ ] , int n ) { int ans = 1 ; int val = ( int ) Math . pow ( 2 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans *= ( int ) Math . pow ( a [ i ] , val ) ; } return ans ; }
int numberofterm ( int n , int number ) { int firstnum = ( int ) Math . pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
int minimumSteps ( int a , int b ) { int cnt = 0 ; a = Math . abs ( a - b ) ; cnt = ( a / 5 ) + ( a % 5 ) / 2 + ( a % 5 ) % 2 ; return cnt ; }
void merge_and_sort ( int output [ ] , int arr [ ] [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i ] [ j ] ; } } Arrays . sort ( output ) ; }
int findSum ( int n ) { return ( int ) Math . pow ( n , 3 ) ; }
void String_palindrome ( int N , int K ) { for ( int i = 0 ; i < K ; i ++ ) System . out . print ( " a " ) ; String s = " bcd " ; for ( int i = 0 ; i < N - K ; i ++ ) System . out . print ( s . charAt ( i % 3 ) ) ; }
float maxVol ( float P , float A ) { float l = ( float ) ( P - Math . sqrt ( P * P - 24 * A ) ) / 12 ; float V = ( float ) ( l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ) ; return V ; }
int maxPeople ( int p ) { int tmp = 0 , count = 0 ; for ( int i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
void moveSpaceInFront ( char str [ ] ) { int i = str . length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ▁ ' ; }
String make_String_S_to_T ( String S , String T ) { boolean possible = false ; int M = T . length ( ) ; int N = S . length ( ) ; for ( int i = 0 ; i <= M ; i ++ ) { int prefix_length = i ; int suffix_length = M - i ; String prefix = S . substring ( 0 , prefix_length ) ; String suffix = S . substring ( N - suffix_length , N ) ; if ( ( prefix + suffix ) . equals ( T ) ) { possible = true ; break ; } } if ( possible ) return " YES " ; else return " NO " ; }
long findNum ( long x ) { for ( int i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } return Long . MIN_VALUE ; }
int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
void removeSpecialCharacter ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < ' A ' || s . charAt ( i ) > ' Z ' && s . charAt ( i ) < ' a ' || s . charAt ( i ) > ' z ' ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; i -- ; } } System . out . print ( s ) ; }
int floorDifference ( int A [ ] , int N , int X ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += A [ i ] / X ; } int totalFloorSum = totalSum / X ; return Math . abs ( totalFloorSum - perElementSum ) ; }
int lastDigitFactorial ( int n ) { if ( n == 0 ) return 1 ; else if ( n <= 2 ) return n ; else if ( n == 3 ) return 6 ; else if ( n == 4 ) return 4 ; else return 0 ; }
boolean isScalarMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
void findMaxDifference ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int Leftsum = 0 ; int Totalsum = 0 ; int Min = Integer . MAX_VALUE , Max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int leftNumbers = i ; int rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; int sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Min = Math . min ( Min , sum ) ; Max = Math . max ( Max , sum ) ; Leftsum += arr [ i ] ; } System . out . print ( Max - Min ) ; }
void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) System . out . println ( " y ▁ = ▁ " + dif + " x " + ( x * dif + y ) ) ; else if ( dif > 0 ) System . out . println ( " y ▁ = ▁ " + dif + " x + " + - x * dif + y ) ; else System . out . println ( " Not ▁ possible " ) ; } }
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
boolean isPower ( int N , int K ) { int res1 = ( int ) ( Math . log ( N ) / Math . log ( K ) ) ; double res2 = Math . log ( N ) / Math . log ( K ) ; return ( res1 == res2 ) ; }
float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return - 1 ; float A = ( a * a * n ) / ( float ) ( 4 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
void closestsAngle ( int N , int A ) { double mi = Integer . MAX_VALUE ; int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { double angle = 180.0 * i / N ; if ( Math . abs ( angle - A ) < Math . abs ( mi - A ) ) { mi = angle ; ans = i ; } } System . out . print ( 2 + " ▁ " + 1 + " ▁ " + ( 2 + ans ) ) ; }
int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { long prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return String . valueOf ( arr ) ; }
Boolean function ( char str [ ] ) { int l = str . length ; Arrays . sort ( str , 0 , ( l / 2 ) ) ; Arrays . sort ( str , ( l / 2 ) , l ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) if ( str [ i ] != str [ l / 2 + i ] ) return true ; return false ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }
int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = - 1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }
int nthTerm ( int N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
int countIncreasing ( int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; }
boolean isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; }
void printSubsequences ( String s ) { char [ ] str = s . toCharArray ( ) ; int n = str . length ; int opsize = ( int ) ( Math . pow ( 2 , n - 1 ) ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } }
int centeredoctagonalNumber ( int n ) { return 4 * n * ( n - 1 ) + 1 ; }
int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
boolean isPossible ( int elements [ ] , int sum ) { int dp [ ] = new int [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < elements . length ; i ++ ) { for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; }
int findNumber ( int n ) { int num = n - 1 ; num = 2 * ( int ) Math . pow ( 4 , num ) ; num = ( int ) Math . floor ( num / 3.0 ) ; return num ; }
int numberofpairs ( int [ ] arr , int N ) { int answer = 0 ; Arrays . sort ( arr ) ; int minDiff = 10000000 ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }
void minimumTime ( int [ ] arr , int n ) { int sum = 0 ; int T = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } System . out . println ( Math . max ( 2 * T , sum ) ) ; }
boolean is_possible ( String s ) { int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . abs ( one - zero ) == 1 ) ; }
double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; }
int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; }
int naive_find_x ( int N ) { int c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; }
int findNature ( int a , int b , int n ) { int [ ] seq = new int [ 100 ] ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; if ( ( seq [ n ] & 1 ) != 0 ) return 1 ; else return 0 ; }
int center_nonadecagon_num ( int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
void print ( int n ) { System . out . println ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 1 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 2 ; i <= n ; i += 2 ) System . out . print ( i + " ▁ " ) ; }
boolean canBeBalanced ( String s , int n ) { int count = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) count ++ ; else count -- ; count_1 = Math . min ( count_1 , count ) ; } if ( count_1 >= - 1 && count == 0 ) return true ; return false ; }
int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; }
boolean isSumSquare ( int N ) { double n = ( 2 + Math . sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - ( int ) n ) == 0 ; }
String removeOuterParentheses ( String S ) { String res = " " ; int count = 0 ; for ( int c = 0 ; c < S . length ( ) ; c ++ ) { if ( S . charAt ( c ) == ' ( ' && count ++ > 0 ) res += S . charAt ( c ) ; if ( S . charAt ( c ) == ' ) ' && count -- > 1 ) res += S . charAt ( c ) ; } return res ; }
int minSum ( int ar [ ] , int n ) { if ( n <= 4 ) return Arrays . stream ( ar ) . min ( ) . getAsInt ( ) ; int [ ] sum = new int [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copyOfRange ( sum , i - 4 , i ) ) . min ( ) . getAsInt ( ) ; return Arrays . stream ( Arrays . copyOfRange ( sum , n - 4 , n ) ) . min ( ) . getAsInt ( ) ; }
boolean isenneadecagonal ( int N ) { float n = ( float ) ( 15 + Math . sqrt ( 136 * N + 225 ) ) / 34 ; return ( n - ( int ) n ) == 0 ; }
int StepstoReachTarget ( int target ) { target = Math . abs ( target ) ; int n = ( int ) Math . ceil ( ( - 1.0 + ( int ) Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
double minAnglRot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; }
void flip ( String s ) { StringBuilder sb = new StringBuilder ( s ) ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) { if ( sb . charAt ( i ) == '0' ) { while ( sb . charAt ( i ) == '0' ) { sb . setCharAt ( i , '1' ) ; i ++ ; } break ; } } System . out . println ( sb . toString ( ) ) ; }
void max_valid_triplet ( int A [ ] , int n ) { int ans = - 1 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { int value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } System . out . println ( ans ) ; }
void countFreq ( String str ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( ( char ) i + " ▁ " + count [ i ] ) ; }
int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( " No ▁ such ▁ subarray " ) ; else System . out . println ( startindex + " ▁ to ▁ " + endindex ) ; return maxsize ; }
int countKAverageSubarrays ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int L = 0 ; L < n ; L ++ ) { int sum = 0 ; for ( int R = L ; R < n ; R ++ ) { sum += arr [ R ] ; int len = ( R - L + 1 ) ; if ( sum % len == 0 ) { int avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }
int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
void record_sum ( int record [ ] , int l , int r , int n , int adder ) { for ( int i = l ; i <= r ; i ++ ) { record [ i ] += adder ; } }
int totalFlips ( String A , String B , String C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A . charAt ( i ) == B . charAt ( i ) && C . charAt ( i ) == '1' ) ++ count ; else if ( A . charAt ( i ) != B . charAt ( i ) && C . charAt ( i ) == '0' ) ++ count ; } return count ; }
double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
int swapBits ( int num , int p1 , int p2 , int n ) { int shift1 , shift2 , value1 , value2 ; while ( n -- > 0 ) { shift1 = 1 << p1 ; shift2 = 1 << p2 ; value1 = ( ( num & shift1 ) ) ; value2 = ( ( num & shift2 ) ) ; if ( ( value1 == 0 && value2 != 0 ) || ( value2 == 0 && value1 != 0 ) ) { if ( value1 != 0 ) { num = num & ( ~ shift1 ) ; num = num | shift2 ; } else { num = num & ( ~ shift2 ) ; num = num | shift1 ; } } p1 ++ ; p2 ++ ; } return num ; }
double Nth_Term ( int n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; }
int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; }
void solve ( int n ) { for ( int x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { int small = x ; int big = n / x ; if ( small % 2 == big % 2 ) { int a = ( small + big ) / 2 ; int b = ( big - small ) / 2 ; System . out . print ( a + " ▁ " + b ) ; return ; } } } System . out . print ( - 1 ) ; }
int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . length ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }
int solve ( int p [ ] , int n ) { int G = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; G ^= ( p [ i ] - 1 ) ; } return G ; }
void insertNames ( String arr [ ] , int n ) { HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! set . contains ( arr [ i ] ) ) { System . out . print ( "NoNEW_LINE"); set . add ( arr [ i ] ) ; } else { System . out . print ( "YesNEW_LINE"); } } }
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Integer . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
void removeDuplicate ( char str [ ] , int n ) { HashSet < Character > s = new LinkedHashSet < > ( n - 1 ) ; for ( char x : str ) s . add ( x ) ; for ( char x : s ) System . out . print ( x ) ; }
void getResult ( int n ) { int proOdd = 1 ; int proEven = 1 ; String num = String . valueOf ( n ) ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) if ( i % 2 == 0 ) proOdd = proOdd * ( num . charAt ( i ) - '0' ) ; else proEven = proEven * ( num . charAt ( i ) - '0' ) ; if ( proOdd == proEven ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
int areaSquare ( int L , int B ) { int large = Math . max ( L , B ) ; int small = Math . min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } }
int countXor ( int N ) { int cnt = ( int ) N / 2 + 1 ; return cnt ; }
double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
void shortdis ( double r , double d ) { System . out . println ( " The ▁ shortest ▁ distance ▁ " + " from ▁ the ▁ chord ▁ to ▁ centre ▁ " + ( Math . sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) ) ) ; }
int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
void findRealAndImag ( String s ) { int l = s . length ( ) ; int i ; if ( s . indexOf ( ' + ' ) != - 1 ) { i = s . indexOf ( ' + ' ) ; } else { i = s . indexOf ( ' - ' ) ; } String real = s . substring ( 0 , i ) ; String imaginary = s . substring ( i + 1 , l - 1 ) ; System . out . println ( " Real ▁ part : ▁ " + real ) ; System . out . println ( " Imaginary ▁ part : ▁ " + imaginary ) ; }
void getSum ( int n ) { int sumOdd = 0 ; int sumEven = 0 ; String num = String . valueOf ( n ) ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) if ( i % 2 == 0 ) sumOdd = sumOdd + ( num . charAt ( i ) - '0' ) ; else sumEven = sumEven + ( num . charAt ( i ) - '0' ) ; System . out . println ( " Sum ▁ odd ▁ = ▁ " + sumOdd ) ; System . out . println ( " Sum ▁ even ▁ = ▁ " + sumEven ) ; }
void maximumValue ( int arr [ ] , int n ) { int maxvalue = arr [ 0 ] ; int result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { result = Math . max ( result , maxvalue + arr [ i ] - i ) ; maxvalue = Math . max ( maxvalue , arr [ i ] + i ) ; } System . out . println ( result ) ; }
boolean isPanalphabeticWindow ( String s , int n ) { char ch = ' a ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ch ) ch ++ ; if ( ch == ' z ' + 1 ) return true ; } return false ; }
void findSum ( int a [ ] ) { int ans = 0 ; for ( int low = 0 ; low < a . length ; low ++ ) { for ( int high = low ; high < a . length ; high ++ ) { int count = 0 ; int maxNumber = 0 ; for ( int i = low ; i <= high ; i ++ ) { if ( a [ i ] == maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( ( count % 2 == 0 ) ? 2 : 1 ) ; } } System . out . println ( ans ) ; }
String check ( int [ ] Arr , int n , int M , int K ) { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Arr [ i ] == 0 ) flag = 1 ; } if ( K % 2 != 0 && flag == 0 ) return " No " ; else return " Yes " ; }
void minModulo ( int L , int R , int N ) { if ( R - L < N ) { int ans = Integer . MAX_VALUE ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( i != j ) ans = Math . min ( ans , ( i * j ) % N ) ; System . out . println ( ans ) ; } else { System . out . println ( 0 ) ; } }
int findMinSwaps ( String s , int k ) { int ans = 0 ; int c_one = 0 , c_zero = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) c_one ++ ; if ( s . charAt ( i ) == '0' ) { c_zero ++ ; ans += c_one ; } if ( c_zero == k ) break ; } if ( c_zero < k ) return - 1 ; return ans ; }
void swap ( int a , int b , int c , int d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; System . out . println ( " values ▁ after ▁ " + " swapping ▁ are ▁ : ▁ " ) ; System . out . println ( " a ▁ = ▁ " + a ) ; System . out . println ( " b ▁ = ▁ " + b ) ; System . out . println ( " c ▁ = ▁ " + c ) ; System . out . println ( " d ▁ = ▁ " + d ) ; }
boolean isSubsetSum ( int arr [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
int maxXOR ( int arr [ ] , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }
void isKthBitSet ( int n , int k ) { if ( ( ( n >> ( k - 1 ) ) & 1 ) > 0 ) System . out . println ( " SET " ) ; else System . out . println ( " NOT ▁ SET " ) ; }
void countNumEnds ( int A , int L , int R ) { int temp , count = 0 , digits ; int cycle ; digits = ( int ) ( Math . log10 ( A ) + 1 ) ; temp = ( int ) Math . pow ( 10 , digits ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } System . out . print ( count ) ; }
float cone ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a * Math . sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
int findDistinctSums ( int n ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . add ( i + j ) ; } } return s . size ( ) ; }
int greatestOddFactor ( int n ) { int pow_2 = ( int ) ( Math . log ( n ) ) ; int i = 1 ; while ( i <= pow_2 ) { int fac_2 = ( 2 * i ) ; if ( n % fac_2 == 0 ) { if ( ( n / fac_2 ) % 2 == 1 ) { return ( n / fac_2 ) ; } } i += 1 ; } return 0 ; }
int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * ( int ) Math . pow ( m - 2 , n - 2 ) ; }
int totalDigits ( int n ) { int number_of_digits = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i ] [ curr ] ; }
void count_minimum ( String s ) { int n = s . length ( ) ; int ans = 0 ; int i = 0 ; while ( i < n ) { int j = i ; while ( j < n && s . charAt ( j ) == s . charAt ( i ) ) { j ++ ; } int diff = j - i ; ans += diff / 2 ; i = j ; } System . out . println ( ans ) ; }
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + " ▁ " ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } }
long ispowerof2 ( long num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }
boolean isPossible ( int A , int B , int N , int K , int L ) { int needa , needb ; if ( A % K == 0 ) needa = A / K ; else needa = A / K + 1 ; if ( B % L == 0 ) needb = B / L ; else needb = B / L + 1 ; int total = needa + needb ; if ( total > N ) return false ; else return true ; }
void maxAverage ( int A [ ] , int N , int X , int Y ) { Arrays . sort ( A ) ; int sum = 0 ; double res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; int cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += ( double ) sum / ( double ) ( X ) ; break ; } res += ( double ) sum / ( double ) ( X ) ; sum = 0 ; count = 0 ; } } System . out . println ( res ) ; }
void PrintReverseOrder ( int N ) { if ( N <= 0 ) { return ; } else { System . out . print ( N + " ▁ " ) ; PrintReverseOrder ( N - 1 ) ; } }
void printRepeating ( Integer [ ] arr , int size ) { SortedSet < Integer > s = new TreeSet < > ( ) ; Collections . addAll ( s , arr ) ; System . out . print ( s ) ; }
boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = Integer . parseInt ( num ) ; return ( number % 12 == 0 ) ; } }
void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = Math . abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = ( float ) Math . sqrt ( a * a + b * b + c * c ) ; System . out . println ( " Perpendicular ▁ distance ▁ " + " is ▁ " + d / e ) ; }
void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + " TABSYMBOL " ) ; else System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + " TABSYMBOL " ) ; } System . out . println ( ) ; } }
int MaxRearrngeSum ( Integer A [ ] , Integer B [ ] , int N ) { Arrays . sort ( A ) ; Arrays . sort ( B , Collections . reverseOrder ( ) ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxSum += Math . abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
int countBits ( int a , int b ) { int count = 0 ; while ( a > 0 b > 0 ) { int last_bit_a = a & 1 ; int last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; }
String findStr ( String S ) { StringBuilder sb = new StringBuilder ( S ) ; int n = sb . length ( ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( sb . charAt ( i ) != ' a ' ) { sb . setCharAt ( i , ' a ' ) ; return sb . toString ( ) ; } } sb . setCharAt ( n - 1 , ' b ' ) ; return n < 2 ? " ▁ - 1 ▁ " : sb . toString ( ) ; }
boolean checkDuplicatesWithinK ( int arr [ ] , int k ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( set . contains ( arr [ i ] ) ) return true ; set . add ( arr [ i ] ) ; if ( i >= k ) set . remove ( arr [ i - k ] ) ; } return false ; }
int minimumAdditionOperation ( int N ) { int count = 0 ; while ( N > 0 ) { if ( N % 2 == 1 ) { count ++ ; } N = N >> 1 ; } return count ; }
boolean findWinner ( int x , int y , int n ) { boolean [ ] dp = new boolean [ n + 1 ] ; Arrays . fill ( dp , false ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
int CtSubarr ( int [ ] arr , int N , int K ) { Set < Integer > st = new HashSet < Integer > ( ) ; int prefixSum = 0 ; st . add ( prefixSum ) ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefixSum += arr [ i ] ; if ( st . contains ( prefixSum - K ) ) { res += 1 ; prefixSum = 0 ; st . clear ( ) ; st . add ( 0 ) ; } st . add ( prefixSum ) ; } return res ; }
int count_numbers ( int k , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
int maximumSum ( int arr [ ] , int N ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & ( 1 << bit ) ) == 1 ) { sum += arr [ i ] ; } } ans = Math . max ( ans , sum ) ; } return ans ; }
int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
boolean isIdoneal ( int n ) { for ( int a = 1 ; a <= n ; a ++ ) { for ( int b = a + 1 ; b <= n ; b ++ ) { for ( int c = b + 1 ; c <= n ; c ++ ) { if ( a * b + b * c + c * a == n ) return false ; } } } return true ; }
void findLastElement ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { System . out . println ( " - 1" ) ; return ; } } System . out . println ( arr [ N - 1 ] ) ; }
int countSymmetric ( int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
int findkey ( int A , int B , int C ) { int ans = 0 ; int cur = 1 ; while ( A > 0 ) { int a = A % 10 ; int b = B % 10 ; int c = C % 10 ; A = A / 10 ; B = B / 10 ; C = C / 10 ; int m = Math . max ( a , Math . max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
int getCount ( int l , int r , int p ) { int cnt = 0 ; int val = p ; while ( true ) { int a = r / val ; int b = ( l - 1 ) / val ; val *= p ; if ( ( a - b ) > 0 ) { cnt += ( a - b ) ; } else break ; } return cnt ; }
void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; System . out . println ( r ) ; }
void minCost ( int arr [ ] , int N , int X ) { Arrays . sort ( arr ) ; int sum = 0 ; int cost = 0 ; int INT_MAX = Integer . MAX_VALUE ; int min_cost = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { cost = Math . abs ( arr [ i ] ) * X + ( sum - Math . abs ( arr [ i ] ) * i ) ; sum += Math . abs ( arr [ i ] ) ; min_cost = Math . min ( min_cost , cost ) ; } } System . out . print ( min_cost ) ; }
void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . println ( removeDuplicatesFromString ( str ) ) ; } }
void operations ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 , sum = 0 ; while ( k -- > 0 ) { while ( i < n && arr [ i ] - sum == 0 ) i ++ ; if ( i < n && arr [ i ] - sum > 0 ) { System . out . print ( arr [ i ] - sum + " ▁ " ) ; sum = arr [ i ] ; } else System . out . println ( "0" ) ; } }
int maxProfit ( int [ ] prices , int n ) { int profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { int day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; }
int countFriendsPairings ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
int maxCount ( int arr [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = - 1 ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ j ] <= i ) { int sub_res = table [ i - arr [ j ] ] ; if ( sub_res != - 1 && sub_res + 1 > table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + ( int ) Math . floor ( ans ) ; }
int calculateEnergy ( int mat [ ] [ ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; }
int maximumK ( String S ) { int N = S . length ( ) ; int ans = N ; int flag = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i + 1 ) ) { flag = 1 ; ans = Math . min ( ans , Math . max ( i + 1 , N - i - 1 ) ) ; } } if ( flag == 0 ) return 0 ; return ans ; }
int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
void possibleNumbers ( Set < Integer > numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . add ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; }
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } System . out . print ( " The ▁ closest ▁ pair ▁ is ▁ [ " + ar1 [ res_l ] + " , ▁ " + ar2 [ res_r ] + " ] " ) ; }
int TetracontadigonalNum ( int n ) { return ( 40 * n * n - 38 * n ) / 2 ; }
void possibleAcyclicGraph ( int N ) { System . out . print ( ( int ) Math . pow ( 2 , N - 1 ) ) ; return ; }
int countOfSubstringWithOnlyOnes ( String s ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count = s . charAt ( i ) == '1' ? count + 1 : 0 ; res = ( res + count ) ; } return res ; }
int nthElement ( int a , int b , int n ) { ArrayList < Integer > seq = new ArrayList < Integer > ( n * n + 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) seq . add ( a * i ) ; Collections . sort ( seq ) ; for ( int i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( seq . indexOf ( b * i ) == - 1 ) { seq . add ( b * i ) ; Collections . sort ( seq ) ; k -- ; } } return seq . get ( n - 1 ) ; }
long getSum ( long n , int d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; long k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }
int findCount ( int arr [ ] , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( ( int ) Math . pow ( ( x - h ) , 2 ) / ( int ) Math . pow ( a , 2 ) ) + ( ( int ) Math . pow ( ( y - k ) , 2 ) / ( int ) Math . pow ( b , 2 ) ) ; return p ; }
int get_last_two_digit ( long N ) { if ( N <= 10 ) { long ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ( int ) ans % 100 ; } return 13 ; }
int findMean ( int arr [ ] , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = ( int ) Math . floor ( sum / count ) ; return mean ; }
int Moves_Calculator ( int x , int y , int row , int col ) { int total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += Math . min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += Math . min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += Math . min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += Math . min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; int king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; }
int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; double c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
int kthgroupsum ( int k ) { return k * k * k ; }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
double calcDeterminant ( int arr [ ] ) { double determinant = 0 ; for ( int i = 0 ; i < N ; i ++ ) { determinant += Math . pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; }
void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { double a = x2 - x1 ; double b = y2 - y1 ; double c = z2 - z1 ; int A = ( int ) ( b * f - c * e ) ; int B = ( int ) ( a * f - c * d ) ; int C = ( int ) ( a * e - b * d ) ; int D = - ( int ) ( A * d - B * e + C * f ) ; System . out . println ( A + " x ▁ + ▁ " + B + " y ▁ + ▁ " + C + " z ▁ + ▁ " + D + " = ▁ 0 ▁ " ) ; }
int Min_Replace ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; Integer [ ] freq = new Integer [ MAX ] ; Arrays . fill ( freq , 0 ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } Arrays . sort ( freq , Collections . reverseOrder ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }
long squareDigitSum ( String s ) { long lengthN = s . length ( ) ; long result = ( lengthN / 9 ) * 81 + ( long ) Math . pow ( ( lengthN % 9 ) , 2 ) ; return result ; }
int counLastDigitK ( int low , int high , int k ) { int mlow = 10 * ( int ) Math . ceil ( low / 10.0 ) ; int mhigh = 10 * ( int ) Math . floor ( high / 10.0 ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; }
int No_of_rectangles ( int L , int B , int l , int b ) { if ( ( l > L ) || ( b > B ) ) { return - 1 ; } else { return ( L - l + 1 ) * ( B - b + 1 ) ; } }
int getGreatestSum ( int a [ ] [ ] ) { int prev_max = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ; int sum = prev_max ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int curr_max = - 2147483648 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ; if ( curr_max == - 2147483648 ) return - 1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; }
int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
int countBits ( int number ) { return ( int ) ( Math . log ( number ) / Math . log ( 2 ) + 1 ) ; }
void findSymPairs ( int arr [ ] [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; Integer val = hM . get ( sec ) ; if ( val != null && val == first ) System . out . println ( " ( " + sec + " , ▁ " + first + " ) " ) ; else hM . put ( first , sec ) ; } }
void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( int i = 1 ; i <= a ; i ++ ) System . out . print ( " ( ( " ) ; for ( int i = 1 ; i <= c ; i ++ ) System . out . print ( " ) ( " ) ; for ( int i = 1 ; i <= d ; i ++ ) System . out . print ( " ) ) " ) ; for ( int i = 1 ; i <= b ; i ++ ) System . out . print ( " ( ) " ) ; } else System . out . print ( - 1 ) ; }
boolean findNoIsDivisibleOrNot ( int a [ ] , int n ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
int Next_greater ( int a [ ] , int n , int x ) { Arrays . sort ( a ) ; int low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
void findShifts ( int [ ] A , int N ) { int [ ] shift = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( shift [ i ] + " ▁ " ) ; }
double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; }
boolean isicositrigonal ( int N ) { float n = ( float ) ( 19 + Math . sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - ( int ) n ) == 0 ; }
int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return - 1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; }
void sentinelSearch ( int arr [ ] , int n , int key ) { int last = arr [ n - 1 ] ; arr [ n - 1 ] = key ; int i = 0 ; while ( arr [ i ] != key ) i ++ ; arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) System . out . println ( key + " ▁ is ▁ present ▁ at ▁ index ▁ " + i ) ; else System . out . println ( " Element ▁ Not ▁ found " ) ; }
int minOperation ( String s , int i , int j , int count ) { if ( ( i >= s . length ( ) && j < 0 ) || ( i == j ) ) return MAX ; if ( s . charAt ( i ) == s . charAt ( j ) ) return count ; if ( i >= s . length ( ) ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return Math . min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; }
boolean isLowerTriangularMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
boolean isInGivenBase ( String str , int base ) { if ( base > 16 ) return false ; else if ( base <= 10 ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( str . charAt ( i ) >= '0' && str . charAt ( i ) < ( '0' + base ) ) ) return false ; } else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( ( str . charAt ( i ) >= '0' && str . charAt ( i ) < ( '0' + base ) ) || ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) < ( ' A ' + base - 10 ) ) ) ) return false ; } return true ; }
int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
int getInvCount ( int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }
int cntSubSets ( int arr [ ] , int n ) { int maxVal = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( int ) ( Math . pow ( 2 , cnt ) - 1 ) ; }
double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
Fraction maxFraction ( Fraction first , Fraction sec ) { int a = first . num ; int b = first . den ; int c = sec . num ; int d = sec . den ; int Y = a * d - b * c ; return ( Y > 0 ) ? first : sec ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; }
long countMaxIntersect ( long n ) { return ( n ) * ( n - 1 ) / 2 ; }
void lexNumbers ( int n ) { Vector < String > s = new Vector < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . add ( String . valueOf ( i ) ) ; } Collections . sort ( s ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . add ( Integer . valueOf ( s . get ( i ) ) ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; }
String check ( int k , int d0 , int d1 ) { int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x = 0 ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } int sum = d0 + d1 + ( ( ( k - 3 ) / 4 ) * s + x ) ; if ( sum % 3 == 0 ) return " YES " ; return " NO " ; }
float maxDivision ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; float mxdiv = arr [ 1 ] ; for ( int i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }
void incrementCount ( int arr [ ] , int N ) { int mini = arr [ 0 ] - arr [ 1 ] ; for ( int i = 2 ; i < N ; i ++ ) { mini = Math . min ( mini , arr [ i - 1 ] - arr [ i ] ) ; } System . out . println ( mini ) ; }
String largestPalinSub ( String s ) { String res = " " ; char mx = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = ( char ) Math . max ( ( int ) mx , ( int ) s . charAt ( i ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == mx ) res += s . charAt ( i ) ; return res ; }
int countKeyPressed ( String str , int len ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) count = count + arr [ str . charAt ( i ) - ' a ' ] ; return count ; }
char increment ( char i ) { int i1 = - ( ~ ( int ) ( i ) ) ; return ( char ) ( i1 ) ; }
int gonNum360 ( int n ) { return ( 358 * n * n - 356 * n ) / 2 ; }
boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }
int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 4 * n ; }
String convert ( String str ) { String w = " " , z = " " ; str = str . toUpperCase ( ) + " ▁ " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch != ' ▁ ' ) w = w + ch ; else { z = z + ( Character . toLowerCase ( w . charAt ( 0 ) ) ) + w . substring ( 1 ) + " ▁ " ; w = " " ; } } return z ; }
boolean isCheck ( String str ) { int len = str . length ( ) ; String lowerStr = " " , upperStr = " " ; char [ ] str1 = str . toCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( int ) ( str1 [ i ] ) >= 65 && ( int ) str1 [ i ] <= 91 ) upperStr = upperStr + str1 [ i ] ; else lowerStr = lowerStr + str1 [ i ] ; } String transformStr = lowerStr . toUpperCase ( ) ; return ( transformStr . equals ( upperStr ) ) ; }
void printCharWithFreq ( String str ) { int n = str . length ( ) ; int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] != 0 ) { System . out . print ( str . charAt ( i ) ) ; System . out . print ( freq [ str . charAt ( i ) - ' a ' ] + " ▁ " ) ; freq [ str . charAt ( i ) - ' a ' ] = 0 ; } } }
boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
int findMaxNum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int num = arr [ 0 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { num = num * 10 + arr [ i ] ; } return num ; }
void bin ( Integer n ) { if ( n > 1 ) bin ( n >> 1 ) ; System . out . printf ( " % d " , n & 1 ) ; }
int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
int percent ( int a , int b ) { float result = 0 ; result = ( ( b - a ) * 100 ) / a ; return ( int ) result ; }
int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . sqrt ( a ) / 6 ; return area ; }
long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
int maxLength ( String s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = Integer . MIN_VALUE ; s = s + '1' ; for ( int i = 0 ; i <= n ; i ++ ) { if ( s . charAt ( i ) == ' o ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s . charAt ( i ) == ' x ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s . charAt ( i - coun - 1 ) == ' x ' ) ) left = 1 ; coun = ( int ) Math . ceil ( ( double ) coun / ( right + left ) ) ; max_length = Math . max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; }
int k_sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; }
int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ; if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return - 1 ; }
> FractionSplit ( long n , long d ) { Vector < String > UnitFactions = new Vector < > ( ) ; while ( n > 0 ) { long x = ( d + n - 1 ) / n ; String s = "1 / " + String . valueOf ( x ) ; UnitFactions . add ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }
int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }
boolean sumSquare ( int n ) { for ( long i = 1 ; i * i <= n ; i ++ ) for ( long j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { System . out . println ( i + " ^ 2 ▁ + ▁ " + j + " ^ 2" ) ; return true ; } return false ; }
int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( true ) { flag = 1 ; x = ( int ) ( Math . pow ( 2 , i ) ) ; p1 = x * p0 + ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; System . out . print ( " ▁ " + p1 ) ; i ++ ; } }
String getString ( int N ) { String ans = " " ; while ( N >= 26 ) { ans += ' z ' ; N -= 26 ; } ans += ( char ) ( N + ' a ' - 1 ) ; return ans ; }
double areaOftriangle ( int side ) { double a = Math . sqrt ( Math . pow ( side / 2 , 2 ) + Math . pow ( side / 2 , 2 ) ) ; double b = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; double c = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; double s = ( a + b + c ) / 2 ; double area = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area ; }
int lcs ( String X , String Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ ] [ ] = new int [ 2 ] [ n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
int stringToInt ( String str ) { if ( str . length ( ) == 1 ) return ( str . charAt ( 0 ) - '0' ) ; double y = stringToInt ( str . substring ( 1 ) ) ; double x = str . charAt ( 0 ) - '0' ; x = x * Math . pow ( 10 , str . length ( ) - 1 ) + y ; return ( int ) ( x ) ; }
int nthSquareCube ( int n ) { return n * n * n * n * n * n ; }
int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
int findMissing ( int arr [ ] , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; }
void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ ] ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } System . out . print ( count + " ▁ " ) ; } }
void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { System . out . print ( ( i * i * i ) + " ▁ " ) ; i ++ ; } }
boolean checkEquall ( int arr [ ] , int N ) { int sumEven = 0 , sumOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }
void findNumbers ( int N , int M ) { int m = M ; Map < Integer , Integer > remLen = new HashMap < > ( ) ; int len , remainder = 0 ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( ! remLen . containsKey ( remainder ) ) { remLen . put ( remainder , len ) ; } else { break ; } M = M * 10 + m ; M = M % N ; } int LenA = len ; int LenB = remLen . getOrDefault ( remainder , 0 ) ; for ( int i = 0 ; i < LenB ; ++ i ) System . out . print ( m ) ; System . out . print ( " ▁ " ) ; for ( int i = 0 ; i < LenA ; ++ i ) System . out . print ( m ) ; }
int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; }
void canSplit ( String S ) { int frequency [ ] = new int [ 26 ] ; int cnt_singles = 0 ; int k = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) frequency [ S . charAt ( i ) - ' a ' ] ++ ; int odd = 0 , eve = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] != 0 ) { odd += ( frequency [ i ] & 1 ) ; eve += frequency [ i ] / 2 ; } } if ( eve >= odd ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
int minOperations ( String S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . length ( ) ; j += K ) { if ( S . charAt ( j ) == '0' ) zero ++ ; else one ++ ; } ans += Math . min ( zero , one ) ; } return ans ; }
int maxSumSubarray ( int [ ] arr ) { int i = 0 , j = 1 ; HashSet < Integer > set = new HashSet < Integer > ( ) ; set . add ( arr [ 0 ] ) ; int sum = arr [ 0 ] ; int maxsum = sum ; while ( i < arr . length - 1 && j < arr . length ) { if ( ! set . contains ( arr [ j ] ) ) { sum = sum + arr [ j ] ; maxsum = Math . max ( sum , maxsum ) ; set . add ( arr [ j ++ ] ) ; } else { sum -= arr [ i ] ; set . remove ( arr [ i ++ ] ) ; } } return maxsum ; }
int squaresum ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = i + 1 ; j < arr . length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; System . out . printf ( " Count ▁ of ▁ pairs ▁ is ▁ % d " , count ) ; }
boolean isCenteredpentagonal ( int N ) { float n = ( float ) ( ( 5 + Math . sqrt ( 40 * N - 15 ) ) / 10 ) ; return ( n - ( int ) n ) == 0 ; }
void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) System . out . println ( " No " ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( " Yes ▁ " + days ) ; } }
char findExtraCharcter ( char [ ] strA , char [ ] strB ) { int [ ] m1 = new int [ 256 ] ; for ( int i = 0 ; i < strB . length ; i ++ ) m1 [ strB [ i ] ] ++ ; for ( int i = 0 ; i < strA . length ; i ++ ) m1 [ strA [ i ] ] -- ; for ( int i = 0 ; i < m1 . length ; i ++ ) { if ( m1 [ i ] == 1 ) return ( char ) i ; } return Character . MIN_VALUE ; }
float areacircumscribed ( float a ) { float PI = 3.14159265f ; return ( a * a * ( PI / 2 ) ) ; }
int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
double Probability ( double p [ ] , int n ) { double [ ] [ ] dp = new double [ n + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 1.0 ; for ( int i = 1 ; i <= n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ; } } double ans = 0.0 ; for ( int i = ( n + 1 ) / 2 ; i <= n ; i += 1 ) ans += dp [ n ] [ i ] ; return ans ; }
int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }
int powerOfJump ( String s ) { int count = 1 ; int max_so_far = Integer . MIN_VALUE ; char ch = s . charAt ( s . length ( ) - 1 ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
void replaceOriginal ( String s , int n ) { char r [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != ' a ' && s . charAt ( i ) != ' e ' && s . charAt ( i ) != ' i ' && s . charAt ( i ) != ' o ' && s . charAt ( i ) != ' u ' ) { System . out . print ( r [ i ] ) ; } } System . out . println ( " " ) ; }
void findScoreSum ( int n ) { int total = 0 ; int prev_monday = 0 , curr_day = 0 ; for ( int day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } System . out . println ( total ) ; }
long countWays ( int n ) { long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
void printDiagonalSums ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } System . out . println ( " Principal ▁ Diagonal : " + principal ) ; System . out . println ( " Secondary ▁ Diagonal : " + secondary ) ; }
void section ( double x1 , double x2 , double y1 , double y2 , double z1 , double z2 , double m , double n ) { double x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; double y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; double z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; System . out . print ( " ( " + x + " , ▁ " ) ; System . out . print ( y + " , ▁ " ) ; System . out . println ( z + " ) " ) ; }
int maxArea ( float perimeter ) { int length = ( int ) Math . ceil ( perimeter / 4 ) ; int breadth = ( int ) Math . floor ( perimeter / 4 ) ; return length * breadth ; }
int numberOfPairs ( int n ) { int count = 0 ; int i = 1 , j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; }
void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
int sum ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; }
int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
int minimumLength ( int x , int y , int z ) { return 1 + Math . abs ( x - y ) + Math . abs ( y - z ) ; }
void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " ▁ - - ▁ " + next ) ; } }
void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + " ▁ " ) ; }
int KvisibleFromLeft ( int N , int K ) { if ( N == K ) return 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
int maxSubarray ( int [ ] a , int k ) { int n = a . length ; int answer = 0 ; int start = 0 ; long s = 0 ; Deque < Integer > dq = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; while ( ! dq . isEmpty ( ) && a [ dq . peek ( ) ] <= x ) dq . poll ( ) ; dq . add ( i ) ; s += x ; long cost = ( long ) a [ dq . peekFirst ( ) ] * ( answer + 1 ) - s ; if ( cost <= ( long ) k ) answer ++ ; else { if ( dq . peekFirst ( ) == start ) dq . pollFirst ( ) ; s -= a [ start ++ ] ; } } return answer ; }
int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( int ) ( ( ( S - S1 ) / Math . floor ( S ) ) * 60 ) ; return Min ; }
Boolean isOverflow ( long a , long b ) { if ( a == 0 b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }
int countIncreasing ( int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
void segregate0and1 ( int arr [ ] ) { int type0 = 0 ; int type1 = arr . length - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else { type0 ++ ; } } }
void check_string_exist ( String S ) { int size = S . length ( ) ; boolean check = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( ( i + 2 ) % size ) ) { check = false ; break ; } } if ( check ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = ( a > b ) ? ( ( a > c ) ? a : c ) : ( ( b > c ) ? b : c ) ; int smallest = ( a < b ) ? ( ( a < c ) ? a : c ) : ( ( b < c ) ? b : c ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } return - 1 ; }
int countkDist ( String str , int k ) { int res = 0 ; int n = str . length ( ) ; int cnt [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; Arrays . fill ( cnt , 0 ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) - ' a ' ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) - ' a ' ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }
int posOfRightMostDiffBit ( int m , int n ) { return ( int ) Math . floor ( Math . log10 ( Math . pow ( m ^ n , 2 ) ) ) + 2 ; }
void NthTerm ( int n ) { int numerator = ( ( int ) Math . pow ( n , 2 ) ) - 1 ; int denomeanator = 2 * n - 3 ; System . out . println ( numerator + " / " + denomeanator ) ; }
int minIndex ( int arr [ ] , int n , int pos ) { int num = arr [ pos ] ; int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
int countAPs ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= Math . sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }
int slopeOfNum ( String num , int n ) { int slope = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( num . charAt ( i ) > num . charAt ( i - 1 ) && num . charAt ( i ) > num . charAt ( i + 1 ) ) slope ++ ; else if ( num . charAt ( i ) < num . charAt ( i - 1 ) && num . charAt ( i ) < num . charAt ( i + 1 ) ) slope ++ ; } return slope ; }
void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { System . out . print ( " A " ) ; } else { System . out . print ( " B " ) ; } }
boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
int search ( int [ ] [ ] mat , int n , int x ) { if ( n == 0 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( mat [ i ] [ j ] == x ) { System . out . print ( " Element ▁ found ▁ at ▁ ( " + i + " , ▁ " + j + ")NEW_LINE"); return 1 ; } } System . out . print ( " ▁ Element ▁ not ▁ found " ) ; return 0 ; }
void findMax ( int [ ] a , int n ) { int dp [ ] [ ] = new int [ n ] [ 2 ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; for ( i = 1 ; i <= n - 2 ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } System . out . println ( Math . max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) ) ; }
int sortExceptK ( int arr [ ] , int k , int n ) { int temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; Arrays . sort ( arr , 0 , n - 1 ) ; int last = arr [ n - 1 ] ; for ( int i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; return 0 ; }
int findMissing ( int arr [ ] , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return - 1 ; return ( int ) ( num / den ) ; }
void solve ( int n ) { int upper_limit = ( int ) ( Math . ceil ( Math . pow ( n , 1.0 / 4 ) ) ) ; for ( int x = 0 ; x <= upper_limit ; x ++ ) { for ( int y = 0 ; y <= upper_limit ; y ++ ) { int num1 = x * x * x * x ; int num2 = y * y * y * y ; if ( num1 - num2 == n ) { System . out . print ( " x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; return ; } } } System . out . print ( - 1 ) ; }
int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c ; for ( int i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
void bcdToHexaDecimal ( char [ ] s ) { int len = s . length , check = 0 ; int num = 0 , sum = 0 , mul = 1 ; Vector < Character > ans = new Vector < Character > ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { sum += ( s [ i ] - '0' ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum <= 9 ) ans . add ( ( char ) ( sum + '0' ) ) ; else ans . add ( ( char ) ( sum + 55 ) ) ; check = 0 ; sum = 0 ; mul = 1 ; } } len = ans . size ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) System . out . print ( ans . get ( i ) ) ; }
int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
void findNumberOfDigits ( long n , int base ) { int dig = ( int ) ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; System . out . println ( " The ▁ Number ▁ of ▁ digits ▁ of ▁ Number ▁ " + n + " ▁ in ▁ base ▁ " + base + " ▁ is ▁ " + dig ) ; }
String checkSameDigits ( int N ) { int length = ( ( int ) Math . log10 ( N ) ) + 1 ; int M = ( ( int ) Math . pow ( 10 , length ) - 1 ) / ( 10 - 1 ) ; M *= N % 10 ; if ( M == N ) return " Yes " ; return " No " ; }
void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = Math . max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; System . out . println ( ans ) ; } else { System . out . println ( ( budget / plastic ) ) ; } }
boolean isSubSequence ( String str1 , String str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
int longestEvenOddSubarray ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = Math . max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return Math . max ( cnt , longest ) ; }
int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
int CountMaximum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
int cntSubXor ( int arr [ ] , int N ) { int prefixXor = 0 ; int [ ] Even = new int [ M ] ; int [ ] Odd = new int [ M ] ; int cntSub = 0 ; Odd [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { prefixXor ^= arr [ i ] ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }
boolean containsElement ( int [ ] arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; ++ i ) xorArr ^= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { int x = xorArr ^ arr [ i ] ; if ( arr [ i ] == x ) return true ; } return false ; }
int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( int ) ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }
int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
int getMinCost ( Integer arr [ ] , int n ) { int min_ele = Collections . min ( Arrays . asList ( arr ) ) ; return min_ele * ( n - 1 ) ; }
String getResult ( String st ) { int sum = 0 ; int length = st . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + ( int ) Math . pow ( st . charAt ( i ) - '0' , length ) ; } int number = Integer . parseInt ( st ) ; if ( number == sum ) return " yes " ; else return " no " ; }
boolean isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
void printSeries ( int n ) { int k = 2 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( k * ( 2 * k - 1 ) + " ▁ " ) ; k += 2 ; } System . out . println ( ) ; }
void findCommon ( int ar1 [ ] , int ar2 [ ] , int ar3 [ ] ) { int i = 0 , j = 0 , k = 0 ; while ( i < ar1 . length && j < ar2 . length && k < ar3 . length ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { System . out . print ( ar1 [ i ] + " ▁ " ) ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } }
boolean isEditDistanceOne ( String s1 , String s2 ) { int m = s1 . length ( ) , n = s2 . length ( ) ; if ( Math . abs ( m - n ) > 1 ) return false ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 . charAt ( i ) != s2 . charAt ( j ) ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; { i ++ ; j ++ ; } count ++ ; } { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; }
int maxSubStrings ( String s , int k ) { int maxSubStr = 0 , n = s . length ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ( char ) ( ( int ) ' a ' + c ) ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s . charAt ( i ) != ch ) continue ; int cnt = 0 ; while ( i < n && s . charAt ( i ) == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; }
int largestSubset ( int [ ] a , int n ) { int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; }
boolean checking ( String s ) { int c = 0 ; int n = s . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '0' ) c ++ ; if ( c >= 6 && s . charAt ( i ) == '1' ) return true ; } return false ; }
int mininsert ( int arr [ ] , int K , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = Math . min ( arr [ i ] , arr [ i + 1 ] ) ; int b = Math . max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }
int findMaxValByRearrArr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; }
int nthTerm ( int n ) { return 4 * ( int ) Math . pow ( n , 2 ) - 7 * n + 3 ; }
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
double find_Variance ( int n ) { long numerator = n * n - 1 ; double ans = ( numerator * 1.0 ) / 12 ; return ans ; }
int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; }
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( true ) { flag = 1 ; x = ( int ) ( Math . pow ( 2 , i ) ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; System . out . print ( p1 + " ▁ " ) ; i ++ ; } }
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }
void makePolygon ( double a ) { double n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
int minOperations ( int arr [ ] , int n ) { int oddcount = 0 , evencount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return Math . min ( oddcount , evencount ) ; }
int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
void count ( String str1 , String str2 ) { int c = 0 , j = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str2 . indexOf ( str1 . charAt ( i ) ) >= 0 ) { c += 1 ; } } System . out . println ( " No . ▁ of ▁ matching ▁ characters ▁ are : ▁ " + c ) ; }
int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
void printSeriesSum ( int N ) { double sum = 0 ; int a = 1 ; int cnt = 0 ; boolean flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag == true ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } System . out . println ( sum ) ; }
void printAllSubStrings ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { char [ ] temp = new char [ n - i + 1 ] ; int tempindex = 0 ; for ( int j = i ; j < n ; j ++ ) { temp [ tempindex ++ ] = s . charAt ( j ) ; temp [ tempindex ] = ' \0' ; System . out . println ( temp ) ; } } }
int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
void printSubsequences ( int n ) { int opsize = ( int ) Math . pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( BigInteger . valueOf ( counter ) . testBit ( j ) ) System . out . print ( arr [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
void printLastChar ( String str ) { str = str + " ▁ " ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) System . out . print ( str . charAt ( i - 1 ) + " ▁ " ) ; } }
void rad ( double d , double h ) { System . out . println ( " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; }
int maxDiff ( int arr [ ] , int n ) { int maxDiff = - 1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
int countDivisibleSubseq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
void printDivisors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . print ( " ▁ " + i ) ; System . out . print ( i + " ▁ " + n / i + " ▁ " ) ; } } }
int countDecreasing ( int A [ ] , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; System . out . print ( count ) ; }
int minSteps ( int N ) { int count = 1 , res = 0 ; for ( int i = 1 ; i <= N ; i += count ) { res = Math . max ( res , count ) ; count ++ ; } return res ; }
int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) { int [ ] maxRev = new int [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
int countSticks ( String str ) { int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch >= ' A ' && ch <= ' Z ' ) { cnt += sticks [ ch - ' A ' ] ; } else { cnt += number [ ch - '0' ] ; } } return cnt ; }
long product ( int [ ] [ ] mat , int n ) { long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1L * d1 * d2 ; }
boolean isPerfectSquareString ( String str ) { int sum = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str . charAt ( i ) ; long squareRoot = ( long ) Math . sqrt ( sum ) ; return ( ( squareRoot - Math . floor ( squareRoot ) ) == 0 ) ; }
int countTrailingZeroes ( int N ) { int res = N ^ ( N - 1 ) ; return ( int ) ( Math . log ( temp ) / Math . log ( 2 ) ) ; }
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + i + " ▁ and ▁ " + p ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } System . out . println ( " No ▁ subarray ▁ found " ) ; return 0 ; }
void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) System . out . print ( y + " ▁ " + x + " ▁ " ) ; else System . out . print ( x + " ▁ " + y + " ▁ " ) ; } }
void findX ( int targetValue ) { int start = 0 , end = targetValue ; int mid = 0 , result = 0 ; while ( start <= end ) { mid = start + ( end - start ) / 2 ; if ( mid * mid <= targetValue ) { result = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } System . out . print ( result + "NEW_LINE"); }
double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; }
int maximum_toys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ; Arrays . sort ( cost ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
void minCost ( int [ ] arr ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } System . out . print ( Math . min ( even , odd ) ) ; }
double trianglearea ( double a ) { if ( a < 0 ) return - 1 ; double area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / 4 ; return area ; }
int maxEvenIntegers ( int arr [ ] , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . max ( ans , cnt ) ; } return ans ; }
int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; }
int lengthOfLastWord ( final String a ) { int len = 0 ; String x = a . trim ( ) ; for ( int i = 0 ; i < x . length ( ) ; i ++ ) { if ( x . charAt ( i ) == ' ▁ ' ) len = 0 ; else len ++ ; } return len ; }
int repUnitValue ( int n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return ( sum / n ) ; }
int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
int maxSum ( int a [ ] , int n , int k ) { if ( n <= 0 ) return 0 ; int option = maxSum ( a , n - 1 , k ) ; if ( k >= a [ n - 1 ] ) option = Math . max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) ; return option ; }
new StringBuilder ( ) ; public static String processWords ( String input ) { String s [ ] = input . split ( " ( \\ s ) + " ) ; for ( String values : s ) { charBuffer . append ( values . charAt ( 0 ) ) ; } return charBuffer . toString ( ) ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
int get_max_splits ( String num_String ) { int count = 0 , current_num ; int running_sum = 0 ; for ( int i = 0 ; i < num_String . length ( ) ; i ++ ) { current_num = num_String . charAt ( i ) - '0' ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; }
boolean isicosihenagonal ( int N ) { float n = ( float ) ( ( 17 + Math . sqrt ( 152 * N + 289 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; }
int calculateTriangles ( int sides [ ] ) { double count = Math . pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= Math . pow ( sides [ 0 ] , 2 ) ; count -= Math . pow ( sides [ 2 ] , 2 ) ; count -= Math . pow ( sides [ 4 ] , 2 ) ; return ( int ) ( count ) ; }
int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . pow ( i , i ) ; int numerator = ( int ) Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * ( int ) Math . pow ( 2 , occ ) ; occ -- ; } return sum ; }
int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }
int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
long minOperations ( long n ) { long count = 0 ; long d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = Math . max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = Math . max ( d , n - 1 ) ; count += Math . abs ( d ) ; return count - 1 ; }
void findNumbers ( int n ) { int odd = ( int ) Math . pow ( 10 , n ) - 1 ; int even = odd - 1 ; System . out . println ( " Even ▁ = ▁ " + even ) ; System . out . print ( " Odd ▁ = ▁ " + odd ) ; }
void RemoveHTMLTags ( String str ) { str = str . replaceAll ( " \\ < . * ? \\ > " , " " ) ; System . out . println ( str ) ; }
Node deleteAlt ( Node head ) { if ( head == null ) return ; Node node = head . next ; if ( node == null ) return ; head . next = node . next ; head . next = deleteAlt ( head . next ) ; }
void findXOR ( int mat [ ] [ ] [ ] , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } System . out . println ( XOR ) ; }
int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }
int countSegments ( int a [ ] , int n , int x ) { boolean flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
void sumOfInfiniteAGP ( double a , double d , double r ) { double ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; System . out . print ( ans ) ; }
int findSubstrings ( String s , int k ) { int ans = 0 ; int cnt [ ] = new int [ 26 ] ; int i , j , n = s . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { Arrays . fill ( cnt , 0 ) ; for ( j = i ; j < n ; j ++ ) { cnt [ s . charAt ( j ) - ' a ' ] ++ ; if ( cnt [ s . charAt ( j ) - ' a ' ] <= k ) { ans ++ ; else { break ; } } } return ans ; }
boolean isRefactorableNumber ( int n ) { int divCount = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
void countSubString ( String s ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int x = 0 ; for ( int j = i ; j < s . length ( ) ; j ++ ) { int temp = 1 << s . charAt ( j ) - ' a ' ; x ^= temp ; if ( ( x & ( x - 1 ) ) == 0 ) res ++ ; } } System . out . print ( res ) ; }
void LCMPairs ( int arr [ ] , int N ) { int total_pairs = ( N * ( N - 1 ) ) / 2 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; System . out . println ( " Even ▁ = ▁ " + ( total_pairs - odd ) + " , ▁ Odd ▁ = ▁ " + odd ) ; }
void rotate90Clockwise ( int arr [ ] [ ] ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
int nthTerm ( int n ) { int An = ( ( int ) Math . pow ( 1 , n ) + ( int ) Math . pow ( 2 , n ) ) * ( int ) Math . pow ( 3 , n ) ; return An ; }
String minInt ( String str ) { String s = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= '5' ) { s += ( char ) ( ( '9' - str . charAt ( i ) ) + '0' ) ; } else { s += str . charAt ( i ) ; } } if ( str . charAt ( 0 ) == '0' ) s += '9' ; return s ; }
boolean checkFibinnary ( int n ) { int prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; }
int MinimumMoves ( int A [ ] , int B [ ] , int N ) { int totalOperations = 0 ; int carry = 0 ; int K = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int nearestMultiple = ( int ) ( Math . ceil ( ( double ) ( A [ i ] + carry ) / ( double ) ( B [ i ] ) ) * B [ i ] ) ; K = nearestMultiple - ( A [ i ] + carry ) ; totalOperations += K ; carry += K ; } return totalOperations ; }
int countConsecutive ( String s ) { int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; } else { count ++ ; } } return count ; }
boolean ishendecagonal ( int N ) { double n = ( 7 + Math . sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
int countTriplets ( int [ ] a , int n ) { ArrayList < Integer > s = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( a [ i ] ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int xr = a [ i ] ^ a [ j ] ; if ( s . contains ( xr ) && xr != a [ i ] && xr != a [ j ] ) count ++ ; } } return count / 3 ; }
float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
String make_palindrome ( String S1 , String S2 , String S3 ) { int maskA = 0 , maskC = 0 ; for ( char i : S1 . toCharArray ( ) ) maskA |= ( 1 << ( i - ' a ' ) ) ; for ( char i : S3 . toCharArray ( ) ) maskC |= ( 1 << ( i - ' a ' ) ) ; if ( ( maskA & maskC ) > 0 ) return " YES " ; return " NO " ; }
void countPermutations ( int N , int B ) { int x = ( int ) Math . pow ( B , N ) ; int y = ( int ) Math . pow ( B , N - 1 ) ; System . out . println ( x - y ) ; }
double Perimeter ( double s , int n ) { double perimeter = 1 ; perimeter = n * s ; return perimeter ; }
int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }
int countOfBinaryNumberLessThanN ( int N ) { Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 1 ) ; int cnt = 0 ; int t ; while ( q . size ( ) > 0 ) { t = q . peek ( ) ; q . remove ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; }
void convertToDecimal ( int N ) { System . out . print ( " Decimal ▁ number ▁ of ▁ " + N + " ▁ is : ▁ " ) ; if ( N != 0 ) { int decimalNumber = 0 , i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N /= 10 ; decimalNumber += remainder * Math . pow ( 3 , i ) ; ++ i ; } System . out . print ( decimalNumber + "NEW_LINE"); } else System . out . print ( "0" + "NEW_LINE"); }
int minApples ( int M , int K , int N , int S , int W , int E ) { if ( M <= S * K ) return M ; else if ( M <= S * K + E + W ) return S * K + ( M - S * K ) * K ; else return - 1 ; }
String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return new String ( result ) ; }
float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }
boolean pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; System . out . println ( " Odd ▁ = ▁ " + odd_count ) ; System . out . println ( " Even ▁ = ▁ " + even_count ) ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . max ( l , a ) ; int R = Math . min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += Math . pow ( i , i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
int countRotation ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }
float circlearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( float ) ( 3.14 * Math . pow ( l / 2 , 2 ) ) ; else return ( float ) ( 3.14 * Math . pow ( b / 2 , 2 ) ) ; }
void printPascal ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; System . out . print ( arr [ line ] [ i ] ) ; } System . out . println ( " " ) ; } } }
int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= Math . sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; }
int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return - 1 ; }
int equvInverse ( int [ ] arr , int N , int P ) { int cntElem = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; }
int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = Math . min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
void minOpsToEmptyString ( String S , int N ) { int one = 0 , zero = 0 ; int x0 = 0 , x1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == '0' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = Math . max ( x0 , zero ) ; one = Math . max ( x1 , one ) ; } System . out . println ( Math . max ( one , zero ) ) ; }
int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
int getOccurence ( int n , int d ) { int result = 0 ; int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
int rankLessThanK ( int [ ] arr , int k , int n ) { int rank = 1 ; int position = 1 ; Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
void getMax ( int arr [ ] , int N , int K ) { for ( int i = 1 ; i < N ; i ++ ) { int cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } System . out . print ( arr [ 0 ] ) ; }
int findMinimumK ( int a [ ] , int n , int S ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return ( int ) Math . ceil ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) ; }
boolean isPath ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }
int getResult ( int n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; }
int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
int TotalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
float Depreciation ( float v , float r , float t ) { float D = ( float ) ( v * Math . pow ( ( 1 - r / 100 ) , t ) ) ; return D ; }
float geometricMean ( int [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) Math . log ( arr [ i ] ) ; sum = sum / n ; return ( float ) Math . exp ( sum ) ; }
boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
int Octadecagonal_num ( int n ) { return ( 16 * n * n - 14 * n ) / 2 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
boolean checkIsFibonacci ( int arr [ ] , int n ) { if ( n == 1 n == 2 ) return true ; Arrays . sort ( arr ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; } return true ; }
int truncMod ( int a , int n ) { int q = a / n ; return a - n * q ; }
int angle ( int n ) { return 2 * n ; }
int smallestNumber ( int N ) { return ( int ) ( N * Math . ceil ( Math . pow ( 10 , ( N - 1 ) ) / N ) ) ; }
int checkArray ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }
void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; System . out . print ( f1 + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) System . out . print ( f3 + " ▁ " ) ; f1 = f2 ; f2 = f3 ; } }
String findWinner ( int A [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " Alice " ; else return " Bob " ; }
void expectedValue ( int P , int a , int b , int N ) { double expValue = P + ( N * 0.5 * ( a + b ) ) ; System . out . print ( expValue ) ; }
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; }
String FirstAndLast ( String str ) { char [ ] ch = str . toCharArray ( ) ; for ( int i = 0 ; i < ch . length ; i ++ ) { int k = i ; while ( i < ch . length && ch [ i ] != ' ▁ ' ) i ++ ; ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return new String ( ch ) ; }
int countWays ( int N ) { if ( N < 4 ) return 0 ; int ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; int s = 0 ; for ( int i = 2 ; i <= N - 3 ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }
int minProd ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return Math . max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return Math . max ( X - ( N - Y + 1 ) , 1 ) ; }
void checksum ( int n , int k ) { float first_term = ( float ) ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - ( int ) ( first_term ) == 0 ) { for ( int i = ( int ) first_term ; i <= first_term + k - 1 ; i ++ ) { System . out . print ( i + " ▁ " ) ; } } else System . out . print ( " - 1" ) ; }
void maxSubsequenceLen ( String s , int K ) { int N = s . length ( ) ; int start = 0 , end = 0 ; char S [ ] = s . toCharArray ( ) ; Arrays . sort ( S ) ; int ans = Integer . MIN_VALUE , sum = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum = sum + ( S [ end ] - ' a ' ) ; while ( sum + K < ( S [ end ] - ' a ' ) * ( end - start + 1 ) ) { sum = sum - ( S [ start ] - ' a ' ) ; start ++ ; } ans = Math . max ( ans , end - start + 1 ) ; } System . out . println ( ans ) ; }
float cyl ( float a ) { if ( a < 0 ) return - 1 ; float r = ( 2 * a * ( float ) ( Math . sqrt ( 2 ) ) / 3 ) ; float h = ( 2 * a ) / 3 ; float V = ( 3.14f * ( float ) ( Math . pow ( r , 2 ) * h ) ) ; return V ; }
int findNumber ( int N ) { int count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }
int lastElement ( int a [ ] , int n ) { int steps = 1 ; Vector < Integer > [ ] v = new Vector [ N ] ; for ( int i = 0 ; i < N ; i ++ ) v [ i ] = new Vector < Integer > ( ) ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . add ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps % 2 == 1 ) v [ steps ] . add ( v [ steps - 1 ] . get ( i ) | v [ steps - 1 ] . get ( i + 1 ) ) ; v [ steps ] . add ( v [ steps - 1 ] . get ( i ) ^ v [ steps - 1 ] . get ( i + 1 ) ) ; } } return v [ steps ] . get ( 0 ) ; }
void prevGreater ( int arr [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( arr [ 0 ] ) ; System . out . print ( " - 1 , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( s . empty ( ) == false && s . peek ( ) < arr [ i ] ) s . pop ( ) ; if ( s . empty ( ) == true ) System . out . print ( " - 1 , ▁ " ) ; else System . out . print ( s . peek ( ) + " , ▁ " ) ; s . push ( arr [ i ] ) ; } }
boolean checkrules ( String s ) { if ( s . length ( ) == 0 ) return true ; if ( s . charAt ( 0 ) != '1' ) return false ; if ( s . length ( ) > 2 ) { if ( s . charAt ( 1 ) == '0' && s . charAt ( 2 ) == '0' ) return checkrules ( s . substring ( 3 ) ) ; } return checkrules ( s . substring ( 1 ) ) ; }
String printDemlo ( String str ) { int len = str . length ( ) ; String res = " " ; for ( int i = 1 ; i <= len ; i ++ ) res += Integer . toString ( i ) ; for ( int i = len - 1 ; i >= 1 ; i -- ) res += Integer . toString ( i ) ; return res ; }
String encryptString ( String str , int n ) { int i = 0 , cnt = 0 ; String encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str . charAt ( i ) ; i ++ ; } return encryptedStr ; }
boolean isReachable ( long x1 , long y1 , long x2 , long y2 ) { while ( x2 > x1 && y2 > y1 ) { if ( x2 > y2 ) x2 %= y2 ; else y2 %= x2 ; } if ( x2 == x1 ) return ( y2 - y1 ) >= 0 && ( y2 - y1 ) % x1 == 0 ; else if ( y2 == y1 ) return ( x2 - x1 ) >= 0 && ( x2 - x1 ) % y1 == 0 ; else return false ; }
boolean isEven ( String s1 ) { int l = s1 . length ( ) ; char [ ] s = s1 . toCharArray ( ) ; boolean dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' && dotSeen == false ) continue ; if ( s [ i ] == ' . ' ) { dotSeen = true ; continue ; } if ( ( s [ i ] - '0' ) % 2 == 0 ) return true ; return false ; } return false ; }
int sum ( int n ) { int ans = ( n * ( n - 1 ) ) / 2 ; return ans ; }
void checkString ( String s , int k ) { int n = s . length ( ) ; if ( 2 * k + 1 > n ) { System . out . println ( " No " ) ; return ; } String a = s . substring ( 0 , k ) ; String b = s . substring ( n - k , n ) ; StringBuffer str = new StringBuffer ( b ) ; str . reverse ( ) ; b = str . toString ( ) ; if ( a . equals ( b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- > 0 ) { result = ( int ) Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
void findUniqueElements ( int arr [ ] , int N , int K ) { Set < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) s . add ( arr [ i ] ) ; int arr_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr_sum += arr [ i ] ; int set_sum = 0 ; Iterator it = s . iterator ( ) ; while ( it . hasNext ( ) ) { set_sum += ( int ) it . next ( ) ; } System . out . println ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ; }
int printOddFactorNumber ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) System . out . print ( i + " ▁ " ) ; } return 0 ; }
int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
void meanVector ( int mat [ ] [ ] ) { System . out . print ( " [ ▁ " ) ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; System . out . print ( ( int ) mean + " ▁ " ) ; } System . out . print ( " ] " ) ; }
int nextPowerOfFour ( int n ) { int x = ( int ) Math . floor ( Math . sqrt ( Math . sqrt ( n ) ) ) ; if ( Math . pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return ( int ) Math . pow ( x , 4 ) ; } }
boolean isPossibleToZero ( int a [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . pow ( a , i ) ) ; } return sum ; }
int findCount ( String s , int n , int a , int b ) { int res = 0 ; char [ ] s1 = s . toCharArray ( ) ; for ( int i = 0 ; i < b ; i ++ ) { if ( i == a ) { if ( s1 [ n - i - 1 ] != '1' ) res += 1 ; } else { if ( s1 [ n - i - 1 ] != '0' ) res += 1 ; } } return res ; }
boolean areSame ( Vector < Integer > a , Vector < Integer > b ) { Collections . sort ( a ) ; Collections . sort ( b ) ; return ( a == b ) ; }
int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
int countPairs ( int [ ] A , int n ) { int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }
int find_maximum_value ( int a [ ] , int n ) { int sum = 0 ; int minimum = Integer . MAX_VALUE ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = Math . min ( minimum , Math . abs ( a [ i ] ) ) ; sum += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }
boolean iszygodromeNum ( int N ) { String s = Integer . toString ( N ) ; s = ' ▁ ' + s + ' ▁ ' ; for ( int i = 1 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) && s . charAt ( i ) != s . charAt ( i + 1 ) ) { return false ; } } return true ; }
String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return " Yes " ; return " No " ; }
int maximumXOR ( int arr [ ] , int n , int K ) { K ++ ; int maxXor = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { if ( Integer . bitCount ( i ) == K ) { int cur_xor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) cur_xor = cur_xor ^ arr [ j ] ; } maxXor = Math . max ( maxXor , cur_xor ) ; } } return maxXor ; }
int rotateRec ( int n , int L [ ] , int B [ ] ) { int m = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }
> calculate ( int [ ] arr ) { int n = arr . length ; List < Integer > ans = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) { sum += Math . abs ( arr [ i ] - arr [ j ] ) ; } ans . add ( sum ) ; } return ans ; }
void predictTheWinner ( int K , int N ) { if ( N % ( K + 1 ) == 0 ) System . out . println ( " Bob " ) ; else System . out . println ( " Alice " ) ; }
long findF_N ( long n ) { long ans = 0 ; for ( long i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str . charAt ( n - 3 ) - '0' ) * 100 + ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 16 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; int third_last = str . charAt ( n - 3 ) - '0' ; int fourth_last = str . charAt ( n - 4 ) - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
void printArray ( int [ ] a , int n ) { Arrays . sort ( a ) ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( i == j ) { System . out . print ( a [ i ] + " ▁ " ) ; } else { System . out . print ( a [ j ] + " ▁ " ) ; System . out . print ( a [ i ] + " ▁ " ) ; } i = i + 1 ; j = j - 1 ; } System . out . println ( ) ; }
int setKthBit ( int n , int k ) { return ( ( 1 << k ) n ) ; }
int findMaxValue ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] ; int maxPossible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }
int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
int countDirectPath ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; }
void minimumOperations ( int [ ] arr , int N ) { int oddCnt = 0 , evenCnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } System . out . print ( Math . min ( oddCnt , evenCnt ) ) ; }
void allCharactersSame ( String s ) { Set < Character > s1 = new HashSet < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) s1 . add ( s . charAt ( i ) ) ; if ( s1 . size ( ) == 1 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
long getSum ( int n ) { long sum = 0 ; int k = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= k ; i ++ ) { sum += Math . floor ( n / i ) ; } sum *= 2 ; sum -= Math . pow ( k , 2 ) ; return sum ; }
String lexNext ( String str , int n ) { char [ ] s = str . toCharArray ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return String . valueOf ( s ) ; } s [ i ] = ' a ' ; } return null ; }
int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
void UpperHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i > j + 1 ) { System . out . print ( 0 + " ▁ " ) ; } else { System . out . print ( ( int ) ( Math . random ( ) * 10 ) + " ▁ " ) ; } } System . out . println ( ) ; } }
void CountTriangles ( int [ ] A ) { int n = A . length ; Arrays . sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } System . out . print ( " No ▁ of ▁ possible ▁ solutions : ▁ " + count ) ; }
void checkEvenOdd ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { System . out . print ( " Even " ) ; return ; } } System . out . println ( " Odd " ) ; }
void countSubsequence ( String s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case ' G ' : cntG ++ ; result += C ; break ; case ' F ' : cntF ++ ; C += cntG ; break ; default : continue ; } } System . out . println ( result ) ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }
boolean isPower ( int x , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } System . out . println ( " number ▁ is ▁ not " + " ▁ present ! " ) ; return - 1 ; }
boolean isPerfectCubeString ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) sum += ( int ) str . charAt ( i ) ; double cr = Math . round ( Math . cbrt ( sum ) ) ; return ( cr * cr * cr == sum ) ; }
boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
int absSumDidd ( int a [ ] ) { Arrays . sort ( a ) ; int midValue = a [ a . length / 2 ] ; int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum = sum + Math . abs ( a [ i ] - midValue ) ; } return sum ; }
boolean is_rtol ( String s ) { int tmp = ( int ) ( Math . sqrt ( s . length ( ) ) ) - 1 ; char first = s . charAt ( tmp ) ; for ( int pos = tmp ; pos < s . length ( ) - 1 ; pos += tmp ) { if ( s . charAt ( pos ) != first ) { return false ; } } return true ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
int maxXOR ( int n , int k ) { int c = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) { return false ; } } return true ; }
void findEquation ( int S , int M ) { System . out . println ( "1 ▁ " + ( ( - 1 ) * S ) + " ▁ " + M ) ; }
void printMaxOfMin ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } System . out . print ( maxOfMin + " ▁ " ) ; } }
int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str . charAt ( i ) == str . charAt ( K ) ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
float harmonicMean ( int arr [ ] , int freq [ ] , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return ( frequency_sum / sum ) ; }
int number_of_tower ( int house [ ] , int range , int n ) { Arrays . sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
double calculate_angle ( double n ) { double total_angle = 360 ; return total_angle / n ; }
int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = Math . min ( c2 , Math . min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . min ( c2 , c1 ) * 12 ; return sum ; }
int findCount ( String str1 , String str2 ) { int len = str1 . length ( ) ; int len2 = str2 . length ( ) ; int ans = Integer . MAX_VALUE ; int [ ] hash1 = new int [ 26 ] ; int [ ] hash2 = new int [ 26 ] ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ ( int ) ( str1 . charAt ( i ) - ' a ' ) ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ ( int ) ( str2 . charAt ( i ) - ' a ' ) ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] != 0 ) ans = Math . min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
String maxValue ( char [ ] a , char [ ] b ) { Arrays . sort ( b ) ; int n = a . length ; int m = b . length ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return String . valueOf ( a ) ; }
long minSum ( int n , int num [ ] , int price [ ] ) { long dp [ ] = new long [ n ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; long ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = ( long ) Math . min ( ( long ) dp [ j ] , ( long ) price [ i ] + ( long ) price [ j ] ) ; ans = Math . min ( ans , ( long ) dp [ i ] + ( long ) price [ j ] ) ; } } } return ans != Integer . MAX_VALUE ? ans : - 1 ; }
void nearestPowerOfTwo ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int lg = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ; int a = ( int ) ( Math . pow ( 2 , lg ) ) ; int b = ( int ) ( Math . pow ( 2 , lg + 1 ) ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) System . out . print ( a + " ▁ " ) ; else System . out . print ( b + " ▁ " ) ; } }
void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( float ) ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; System . out . println ( " Perpendicular ▁ distance ▁ is ▁ " + d ) ; } else System . out . println ( " Planes ▁ are ▁ not ▁ parallel " ) ; }
void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; }
void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { System . out . println ( " The ▁ shortest ▁ distance ▁ " + " between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) ) ; }
int calculateSum ( int n ) { return ( int ) Math . pow ( n * ( n + 1 ) / 2 , 2 ) ; }
int solve ( int X , int Y ) { if ( X > Y ) { int temp = X ; X = Y ; Y = temp ; } if ( X == Y ) System . out . println ( 0 ) ; else if ( Y % X == 0 ) System . out . println ( 1 ) ; else System . out . println ( 2 ) ; return 0 ; }
float Area_of_Triangle ( int a , int b , int k ) { float area = ( float ) ( ( 1 / 2.0 ) * a * b * Math . sin ( k ) ) ; return area ; }
int findMaxCock ( int ar [ ] [ ] ) { if ( R < 3 C < 3 ) return - 1 ; int max_sum = Integer . MIN_VALUE ; for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) { int sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = Math . max ( max_sum , sum ) ; } } return max_sum ; }
int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ; int res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; System . out . print ( " Min ▁ Difference ▁ = ▁ " + res ) ; }
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; }
void countCharacterType ( String str ) { int vowels = 0 , consonant = 0 , specialChar = 0 , digit = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) { ch = Character . toLowerCase ( ch ) ; ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) vowels ++ ; else consonant ++ ; } else if ( ch >= '0' && ch <= '9' ) digit ++ ; else specialChar ++ ; } System . out . println ( " Vowels : ▁ " + vowels ) ; System . out . println ( " Consonant : ▁ " + consonant ) ; System . out . println ( " Digit : ▁ " + digit ) ; System . out . println ( " Special ▁ Character : ▁ " + specialChar ) ; }
boolean isoctagonal ( int N ) { double n = ( 2 + Math . sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
int findValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) ans = Math . max ( ans , Math . abs ( arr [ i ] - arr [ j ] ) + Math . abs ( i - j ) ) ; return ans ; }
void findLarger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) System . out . print ( arr [ i ] + " ▁ " ) ; }
int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
int maxLengthSquare ( int row , int column , int [ ] [ ] arr , int k ) { int sum [ ] [ ] = new int [ row + 1 ] [ column + 1 ] ; int cur_max = 1 ; int max = 0 ; for ( int i = 1 ; i <= row ; i ++ ) { for ( int j = 1 ; j <= column ; j ++ ) { sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; }
int Minimum ( int N , int K ) { int sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return - 1 ; if ( K <= N ) return 1 ; sum = 0 ; int count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " ▁ " ) ; }
void newvol ( double x ) { System . out . print ( " percentage ▁ increase ▁ " + " in ▁ the ▁ volume ▁ of ▁ the ▁ cylinder ▁ is ▁ " + x + " % " ) ; }
int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
int clearLastBit ( int N , int K ) { int mask = ( - 1 << K + 1 ) ; return N = N & mask ; }
float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
void findPair ( int A , int B , int N ) { int X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { System . out . print ( " - 1" ) ; } else { X = X / 2 ; Y = N - X ; System . out . print ( X + " ▁ " + Y ) ; } }
int findRectNum ( int n ) { return n * ( n + 1 ) ; }
void findTriangle ( int a [ ] , int n ) { int b [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . max ( p - j , 0 ) ; z += q - p ; } } } System . out . println ( " Acute ▁ Triangle : ▁ " + x ) ; System . out . println ( " Right ▁ Triangle : ▁ " + y ) ; System . out . println ( " Obtuse ▁ Triangle : ▁ " + z ) ; }
int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
int sum_all_divisors ( int num ) { int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( num ) ; i ++ ) { sum += t1 + t2 ; } return sum ; }
double ReuleauxArea ( float a ) { if ( a < 0 ) return - 1 ; double A = ( double ) 0.70477 * Math . pow ( a , 2 ) ; return A ; }
int pairCount ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= Math . sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }
int countPairs ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
void splitString ( String S , int N ) { char c = S . charAt ( N - 1 ) ; int f = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S . charAt ( i ) == c ) { f = 1 ; break ; } } if ( f > 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
double Avgdifference ( double arr [ ] , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
int TotalBitwiseORPair ( int arr [ ] , int N ) { int totalOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalOR |= arr [ i ] ; } return totalOR ; }
int count_special ( int n ) { int [ ] fib = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; }
void solve ( long n ) { long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = ( int ) ( n / Math . floor ( n / l ) ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( int ) ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } System . out . print ( ( s + m ) % m ) ; }
int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
int findMaxK ( int N ) { int p = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; }
void sort ( char arr [ ] ) { int n = arr . length ; char output [ ] = new char [ n ] ; int count [ ] = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; ++ i ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; for ( int i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; }
int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
int minCount ( int A [ ] , int B [ ] , int N ) { int i = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) { i ++ ; } } return N - i ; }
void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }
void factorsOf3 ( int arr [ ] , int N ) { int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 3 == 0 ) a ++ ; else if ( arr [ i ] % 3 == 1 ) b ++ ; else if ( arr [ i ] % 3 == 2 ) c ++ ; } if ( a >= 1 && a <= b + c + 1 ) System . out . print ( " Yes " + "NEW_LINE"); else if ( a == 0 && b == 0 && c > 0 ) System . out . print ( " Yes " + "NEW_LINE"); else if ( a == 0 && c == 0 && b > 0 ) System . out . print ( " Yes " + "NEW_LINE"); else System . out . print ( " No " + "NEW_LINE"); }
void findUniquePair ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , " + y + " ) " ) ; }
int countChars ( String str , int n ) { int i = 0 , cnt = 0 ; while ( i < n ) { if ( str . charAt ( i ) == '0' ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; }
int distinctSubString ( String P , String Q , int K , int N ) { HashSet < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; String s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P . charAt ( j ) - ' a ' ; sum += Q . charAt ( pos ) - '0' ; s += P . charAt ( j ) ; if ( sum <= K ) { S . add ( s ) ; } else { break ; } } } return S . size ( ) ; }
int boost_hyperfactorial ( int num ) { int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
int bitwiseOrTillN ( int n ) { int result = 2 ; for ( int i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; }
void findNthTerm ( int n ) { System . out . print ( n * ( 2 * n + 1 ) ) ; }
float angle ( float R1 , float R2 , float D ) { float ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }
int minsteps ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += Math . abs ( arr [ i ] - Math . pow ( 2 , i ) ) ; } return ans ; }
int smallest ( int x , int y , int z ) { if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ; return ( ( x / z ) != 1 ) ? x : z ; }
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
int findCount ( int d ) { return 9 * ( ( int ) ( Math . pow ( 10 , d - 1 ) ) - ( int ) ( Math . pow ( 9 , d - 1 ) ) ) ; }
int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
int maxLen ( int [ ] arr , int n ) { int min_val = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int freq = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
int KthMinValAfterMconcatenate ( int [ ] A , int N , int M , int K ) { Arrays . sort ( A ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; }
int sum ( int A , int B , int R ) { int sum = 0 ; for ( int i = 1 ; i <= R ; i ++ ) { sum = sum + ( i * A ) ; A = A + B ; } return sum ; }
long centeredTridecagonalNum ( long n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
void findSubsequence ( String str , int k ) { int a [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) a [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( a [ str . charAt ( i ) - ' a ' ] >= k ) System . out . print ( str . charAt ( i ) ) ; }
void longestAlternating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count [ i ] + " ▁ " ) ; }
double getSum ( int n ) { double sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * Math . pow ( 10 , n - 1 ) * Math . pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; }
int icosidigonal_num ( int n ) { return ( 20 * n * n - 18 * n ) / 2 ; }
String largestMerge ( String word1 , String word2 ) { String merge = " " ; while ( word1 . length ( ) != 0 || word2 . length ( ) != 0 ) { if ( word1 . compareTo ( word2 ) == 0 || ( word1 . compareTo ( word2 ) > 0 ) ) { merge = merge + word1 . charAt ( 0 ) ; word1 = word1 . substring ( 1 ) ; } else { merge = merge + word2 . charAt ( 0 ) ; word2 = word2 . substring ( 1 ) ; } } return merge ; }
int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }
int clstNum ( int N ) { return ( N - 1 ) ; }
int findSubarraySum ( int arr [ ] , int n , int sum ) { HashMap < Integer , Integer > prevSum = new HashMap < > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . containsKey ( currsum - sum ) ) res += prevSum . get ( currsum - sum ) ; Integer count = prevSum . get ( currsum ) ; if ( count == null ) prevSum . put ( currsum , 1 ) ; else prevSum . put ( currsum , count + 1 ) ; } return res ; }
int find ( ArrayList < Integer > arr , int N ) { int Sum = 0 ; for ( int item : arr ) Sum += item ; if ( Sum % N == 1 ) return - 1 ; int k = Sum / N ; int ans = 0 ; int i = 0 ; while ( i < N ) { ans = ans + Math . abs ( k - arr . get ( i ) ) ; i += 1 ; } return ans / 2 ; }
int findK ( int n , int k ) { ArrayList < Integer > a = new ArrayList < Integer > ( n ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . add ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . add ( i ) ; return ( a . get ( k - 1 ) ) ; }
int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
boolean isPossible ( int r , int b , int g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } }
void printSeriesSum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) { sum += ( double ) i / ( i + 1 ) ; } else { sum -= ( double ) i / ( i + 1 ) ; } } System . out . print ( sum + "NEW_LINE"); }
void printPattern ( String str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { if ( ( i == j ) || ( i + j == len - 1 ) ) System . out . print ( str . charAt ( j ) ) ; else System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } }
int countDistinct ( int arr [ ] , int n ) { HashSet < Integer > hs = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ( ) ; }
int findMin ( int arr [ ] , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; ans = Math . max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int ans = 1 ; while ( n % 2 == 0 ) { n /= 2 ; ans *= 2 ; } return ans ; }
long oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
long countBT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
String intToRoman ( int num ) { String m [ ] = { " " , " M " , " MM " , " MMM " } ; String c [ ] = { " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM " } ; String x [ ] = { " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " } ; String i [ ] = { " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " } ; String thousands = m [ num / 1000 ] ; String hundereds = c [ ( num % 1000 ) / 100 ] ; String tens = x [ ( num % 100 ) / 10 ] ; String ones = i [ num % 10 ] ; String ans = thousands + hundereds + tens + ones ; return ans ; }
int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; }
int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
void mindigits ( int n ) { if ( n % 9 == 0 ) { System . out . println ( n / 9 ) ; } else { System . out . println ( ( n / 9 ) + 1 ) ; } }
void Bubble_Sort ( int [ ] arr , int n ) { boolean flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } }
int findLen ( int [ ] arr , int n , int m ) { Vector < Integer > filter = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . add ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_and = filter . get ( 0 ) ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_and &= filter . get ( i ) ; if ( c_and == m ) return filter . size ( ) ; return 0 ; }
int sumOfDigits ( String s ) { int curr = 0 ; int ret = 0 ; for ( char ch : s . toCharArray ( ) ) { if ( ch >= 48 && ch <= 57 ) { curr = curr * 10 + ch - '0' ; } else { ret += curr ; curr = 0 ; } } ret += curr ; return ret ; }
void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } System . out . println ( sum ) ; }
int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == s . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; }
double Volume_of_cone ( double R ) { double V = ( double ) ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; }
int CalculateMax ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; }
int min_operation ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += Math . abs ( a [ i ] - a [ i - 1 ] ) ; else ans += Math . abs ( a [ i ] ) ; } return ans ; }
boolean ContinuousElements ( int a [ ] , int n ) { if ( n == 1 ) return false ; int curr = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { if ( curr == 1 ) return false ; else curr = 0 ; } curr ++ ; } if ( curr == 1 ) return false ; return true ; }
int count ( int x , int y ) { Map < Integer , Integer > m = new HashMap < > ( ) ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . containsKey ( x ) ) return - 1 ; m . put ( x , 1 ) ; x = x * 10 ; } return ans ; }
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
void SternSequenceFunc ( Vector < Integer > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence . get ( i ) ; int precedent = BrocotSequence . get ( i - 1 ) ; BrocotSequence . add ( considered_element + precedent ) ; BrocotSequence . add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) System . out . print ( BrocotSequence . get ( i ) + " ▁ " ) ; }
int TotalXorPair ( int arr [ ] , int N ) { int totalXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; }
boolean checkPandigital ( int b , String n ) { if ( n . length ( ) < b ) return false ; boolean hash [ ] = new boolean [ b ] ; Arrays . fill ( hash , false ) ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i ) >= '0' && n . charAt ( i ) <= '9' ) hash [ n . charAt ( i ) - '0' ] = true ; else if ( n . charAt ( i ) - ' A ' <= b - 11 ) hash [ n . charAt ( i ) - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n != 0 && i < x . length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } System . out . println ( " Length ▁ - > ▁ " + answer ) ; System . out . println ( " Path ▁ - > ▁ " + " ( ▁ 1 , ▁ " + answer + " ▁ ) " + " and ▁ ( ▁ " + answer + " , ▁ 1 ▁ ) " ) ; }
int numberOfWays ( int N , int X , int Y ) { int S1 = ( N - 1 ) * X + Y ; int S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }
int findWater ( int arr [ ] , int n ) { int result = 0 ; int left_max = 0 , right_max = 0 ; int lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; }
int maxAndXor ( int arr [ ] , int n ) { int ans = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }
int number_of_digits ( int n ) { int i ; int res ; int sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
int segments ( int n , int [ ] p , int m ) { HashMap < Integer , Integer > c = new HashMap < > ( ) ; c . put ( 0 , 1 ) ; boolean has = false ; int sum = 0 ; int ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) has = true ; if ( has ) ans += ( c . get ( sum ) == null ? 0 : c . get ( sum ) ) + ( c . get ( sum - 1 ) == null ? 0 : c . get ( sum - 1 ) ) ; else c . put ( sum , c . get ( sum ) == null ? 1 : c . get ( sum ) + 1 ) ; } return ans ; }
boolean isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
void printGroups ( int n ) { int x = 1 ; int y = n * n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n / 2 ; j ++ ) { System . out . print ( " { ▁ " + x + " , ▁ " + y + " } ▁ " ) ; x ++ ; y -- ; } System . out . println ( ) ; } }
int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
int countOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 != 1 ) ) { count ++ ; } } int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }
int maxCost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
void sortSquares ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] * arr [ i ] ; Arrays . sort ( arr ) ; }
double Length_Diagonal ( int a , int b , double theta ) { double diagonal = Math . sqrt ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) - 2 * a * b * Math . cos ( theta * ( Math . PI / 180 ) ) ) ; return diagonal ; }
void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) System . out . print ( " Equal "); else if ( ( x & ( ~ y ) ) > y ) System . out . print ( y ) ; else System . out . print ( x ) ; }
int minSum ( int A [ ] , int B [ ] , int C [ ] , int i , int n , int curr , int [ ] [ ] dp ) { if ( n <= 0 ) return 0 ; if ( dp [ n ] [ curr ] != - 1 ) return dp [ n ] [ curr ] ; if ( curr == 0 ) { return dp [ n ] [ curr ] = Math . min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; }
float rectanglearea ( float r ) { if ( r < 0 ) return - 1 ; float a = r * r ; return a ; }
int canReplace ( int [ ] array ) { int i = 0 , count = 0 ; while ( i < array . length ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == array . length - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; }
int maxCostToRemove ( int arr [ ] , int N , int K ) { int maxCost = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N ; i += K ) { maxCost += arr [ i + 1 ] ; } return maxCost ; }
void complement ( String number1 ) { char [ ] number = number1 . toCharArray ( ) ; for ( int i = 0 ; i < number . length ; i ++ ) if ( number [ i ] != ' . ' ) number [ i ] = ( char ) ( ( int ) ( '9' ) - ( int ) ( number [ i ] ) + ( int ) ( '0' ) ) ; System . out . println ( "9 ' s ▁ complement ▁ is ▁ : ▁ " + String . valueOf ( number ) ) ; }
double polyarea ( double n , double r ) { if ( r < 0 && n < 0 ) return - 1 ; double A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
int IcositrigonalNum ( int n ) { return ( 21 * n * n - 19 * n ) / 2 ; }
double sumOfSeries ( int n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
int possibleTriplets ( int arr [ ] , int N ) { int freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( int ) ( ( freq * 1L * ( freq - 1 ) * ( freq - 2 ) ) / 6 ) ; }
void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr = 0 ; if ( n == 0 ) System . out . print ( first ) ; else if ( n == 1 n == 2 ) System . out . print ( second ) ; else if ( n == 3 ) System . out . print ( fourth ) ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } System . out . print ( curr ) ; } }
void split ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { count = 2 ; break ; } } System . out . print ( count ) ; }
boolean makeAndCheckString ( Vector < String > words , String str ) { int n = words . size ( ) ; boolean first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words . get ( i ) == str ) return true ; if ( str . charAt ( 0 ) == words . get ( i ) . charAt ( 1 ) ) first = true ; if ( str . charAt ( 1 ) == words . get ( i ) . charAt ( 0 ) ) second = true ; if ( first && second ) return true ; } return false ; }
int findSum ( String str ) { String temp = "0" ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( Character . isDigit ( ch ) ) temp += ch ; else { sum += Integer . parseInt ( temp ) ; temp = "0" ; } } return sum + Integer . parseInt ( temp ) ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = Math . max ( max_sum , a + b ) ; } } return max_sum ; }
int calculateMoves ( int n ) { int count = 0 ; int layers = n / 2 ; for ( int k = 1 ; k < layers + 1 ; k ++ ) { count += 8 * k * k ; } return count ; }
int oddFib ( int n ) { n = ( 3 * n + 1 ) / 2 ; int a = - 1 , b = 1 , c = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
void minDistance ( int n , int k , int point [ ] [ ] ) { for ( int i = 0 ; i < k ; i ++ ) Arrays . sort ( point [ i ] ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( point [ i ] [ ( int ) Math . ceil ( ( double ) ( n / 2 ) - 1 ) ] + " ▁ " ) ; }
int findArea ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int [ ] dimension = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . length ; for ( int i = 0 ; i < l ; i ++ ) { sum += ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }
void circle_equation ( double x1 , double y1 , double r ) { double a = - 2 * x1 ; double b = - 2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; System . out . print ( " x ^ 2 ▁ + ▁ ( " + a + " ▁ x ) ▁ + ▁ " ) ; System . out . print ( " y ^ 2 ▁ + ▁ ( " + b + " ▁ y ) ▁ = ▁ " ) ; System . out . println ( c + " . " ) ; }
int maxValue ( int arr [ ] , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = Math . min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
void sortBinaryArray ( int a [ ] , int n ) { int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; int temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } }
int superSeq ( String X , String Y , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; System . out . println ( first_3 + " ▁ " + last_3 ) ; }
int distinct ( int [ ] arr , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }
int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
int times ( int [ ] steps , int n ) { int current_level = 0 ; int previous_level = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; }
String SmallestString ( String s , char c ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) > c ) { String temp = s ; s = s . substring ( 0 , i ) ; s += c ; s += temp . substring ( i , temp . length ( ) ) ; return s ; } } s += c ; return s ; }
int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { int n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }
boolean checkSuffix ( int A , int B ) { int digit_B = ( int ) ( Math . log10 ( B ) + 1 ) ; A -= B ; return ( A % ( int ) ( Math . pow ( 10 , digit_B ) ) > 0 ) ; }
int uncrossedLines ( int [ ] a , int [ ] b , int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; }
int minSteps ( int m , int n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; int min_cost = inf ; for ( int i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = Math . min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }
int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
int ways ( int n ) { return n / 2 ; }
double findSum ( long n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }
void minSteps ( String S ) { String new_str = " " ; int N = S . length ( ) ; int i = 0 ; while ( i < N ) { new_str += S . charAt ( i ) ; int j = i ; while ( i < N && S . charAt ( i ) == S . charAt ( j ) ) ++ i ; } System . out . print ( ( int ) Math . ceil ( ( new_str . length ( ) + 1 ) / 2.0 ) ) ; }
int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
void printCase ( int n ) { if ( n <= 2 ) { System . out . print ( - 1 ) ; return ; } for ( int i = n ; i >= 1 ; i -- ) System . out . print ( i + " ▁ " ) ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
boolean oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
int maxProfit ( Integer [ ] arr ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int ans = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] - ( 1 * i ) ) > 0 ) ans += ( arr [ i ] - ( 1 * i ) ) ; if ( ( arr [ i ] - ( 1 * i ) ) == 0 ) break ; } return ans ; }
void maxPairs ( int [ ] nums , int k ) { Map < Integer , Integer > map = new HashMap < > ( ) ; int result = 0 ; for ( int i : nums ) { if ( map . containsKey ( i ) && map . get ( i ) > 0 ) { map . put ( i , map . get ( i ) - 1 ) ; result ++ ; } else { map . put ( k - i , map . getOrDefault ( k - i , 0 ) + 1 ) ; } } System . out . println ( result ) ; }
int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2 ) ; twentyfive = ( ( Z * 1 ) / 4 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return ( int ) result ; }
int countSortedArrays ( int start , int m , int size , int n ) { if ( size == m ) return 1 ; if ( start > n ) return 0 ; int notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }
int solve ( int n , int k , int mod , int dp [ ] ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; int cnt = 0 ; for ( int i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; }
double Area ( double l , double b , double h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; double x = ( l * b ) / ( l + b ) ; double A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . out . println ( " Loss ▁ = ▁ " + loss ) ; }
double probability ( int [ ] arr1 , int [ ] arr2 ) { int N = arr1 . length ; int M = arr2 . length ; double res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int y = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr2 [ j ] > arr1 [ i ] ) y ++ ; } res += y ; } res = ( double ) res / ( double ) ( N * M ) ; return res ; }
void conVowUpp ( char [ ] str ) { int N = str . length ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { char c = Character . toUpperCase ( str [ i ] ) ; str [ i ] = c ; } } for ( char c : str ) System . out . print ( c ) ; }
int solve ( double M , double N , double s ) { int ans = ( ( int ) ( Math . ceil ( M / s ) ) * ( int ) ( Math . ceil ( N / s ) ) ) ; return ans ; }
int maxSize ( Vector < Integer > v , int n ) { v . add ( 0 ) ; v . add ( 100001 ) ; n += 2 ; Collections . sort ( v ) ; int mx = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int L = v . get ( i - 1 ) + 1 ; int R = v . get ( i + 1 ) - 1 ; int cnt = R - L + 1 ; mx = max ( mx , cnt ) ; } return mx ; }
void maxMin ( int arr [ ] [ ] , int n ) { int min = + 2147483647 ; int max = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } System . out . print ( " Maximum ▁ = ▁ " + max + " , ▁ Minimum ▁ = ▁ " + min ) ; }
int countWays ( int index , int cnt , int dp [ ] [ ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }
int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
boolean isMyriagon ( int N ) { double n = ( 9996 + Math . sqrt ( 79984 * N + 99920016 ) ) / 19996 ; return ( n - ( int ) n ) == 0 ; }
int findWater ( int n ) { int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; int water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) left [ i ] = Math . max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) right [ i ] = Math . max ( right [ i + 1 ] , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) water += Math . min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; }
double findDiagonal ( double s ) { return ( double ) Math . sqrt ( 2 ) * s ; }
int myXOR ( int x , int y ) { return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) ; }
int countQuadruples ( int A [ ] , int N ) { int ans = 0 ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . containsKey ( A [ i ] ) ) ans += freq . get ( A [ i ] ) ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { if ( freq . containsKey ( A [ i ] * A [ j ] * A [ k ] ) ) { freq . put ( A [ i ] * A [ j ] * A [ k ] , freq . get ( A [ i ] * A [ j ] * A [ k ] ) + 1 ) ; } else { freq . put ( A [ i ] * A [ j ] * A [ k ] , 1 ) ; } } } } return ans ; }
int distinctSubstring ( String P , String Q , int K , int N ) { Set < String > S = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; String s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P . charAt ( j ) - ' a ' ; sum += Q . charAt ( pos ) - '0' ; s += P . charAt ( j ) ; if ( sum <= K ) { S . add ( s ) ; } else { break ; } } } return S . size ( ) ; }
int possibleBinaries ( int pos , int ones , int sum , int k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos ] [ ones ] [ sum ] != - 1 ) return dp [ pos ] [ ones ] [ sum ] ; int ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos ] [ ones ] [ sum ] = ret ; return dp [ pos ] [ ones ] [ sum ] ; }
int bellNumber ( int n ) { int [ ] [ ] bell = new int [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
int countSquares ( int n ) { int r = ( int ) Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) ; int l = ( int ) Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) ; return r - l ; }
boolean isTridecagon ( int N ) { float n = ( float ) ( ( 9 + Math . sqrt ( 88 * N + 81 ) ) / 22 ) ; return ( n - ( int ) n ) == 0 ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
void countPairs ( int N , int [ ] arr ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } System . out . println ( count / 2 ) ; }
int cntSplits ( String s ) { if ( s . charAt ( s . length ( ) - 1 ) == '1' ) return - 1 ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) ans += ( s . charAt ( i ) == '0' ) ? 1 : 0 ; return ans ; }
int longestSubseq ( String s ) { int n = s . length ( ) ; int [ ] pre_count_0 = new int [ n + 2 ] ; int [ ] pre_count_1 = new int [ n + 1 ] ; int [ ] post_count_0 = new int [ n + 2 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s . charAt ( j - 1 ) == '0' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s . charAt ( n - j ) == '0' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = Math . max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; }
int FlipBits ( int n ) { return n -= ( n & ( - n ) ) ; }
boolean check ( String [ ] v , int len ) { int n = v . length ; char [ ] tempArray ; for ( int i = 0 ; i < n ; i ++ ) { tempArray = v [ i ] . toCharArray ( ) ; Arrays . sort ( tempArray ) ; v [ i ] = new String ( tempArray ) ; } for ( int i = 0 ; i < len - 1 ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( v [ i ] . charAt ( j ) > v [ i + 1 ] . charAt ( j ) ) return false ; return true ; }
int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; }
int XorAscii ( String str , int len ) { int ans = ( str . charAt ( 0 ) ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( ( str . charAt ( i ) ) ) ) ; } return ans ; }
String getResult ( int n ) { String st = Integer . toString ( n ) ; for ( int i = 0 ; i < st . length ( ) ; i ++ ) { int d = st . charAt ( i ) - 48 ; if ( n % d == 0 ) { return " Yes " ; } } return " No " ; }
String toggleCase ( char [ ] a ) { for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] ^= 32 ; } return new String ( a ) ; }
void printNumber ( int holes ) { if ( holes == 0 ) System . out . print ( "1" ) ; else if ( holes == 1 ) System . out . print ( "0" ) ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) System . out . print ( "4" ) ; for ( int i = 0 ; i < quo ; i ++ ) System . out . print ( "8" ) ; } }
void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = sum - ( arr [ i ] + arr [ j ] ) ; if ( s . contains ( x ) ) System . out . printf ( "%d %d %dNEW_LINE", x, arr[i], arr[j]); else s . add ( arr [ j ] ) ; } } }
int calculate ( int a [ ] , int n ) { Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }
boolean isMultipleOf4 ( int n ) { if ( n == 1 ) return false ; int XOR = 0 ; for ( int i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; }
int calculate_minimum_split ( int n , int a [ ] , int k ) { Integer [ ] p = new Integer [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) p [ i - 1 ] = a [ i ] - a [ i - 1 ] ; Arrays . sort ( p , new Comparator < Integer > ( ) { public int compare ( Integer a , Integer b ) { return b - a ; } } ) ; int min_sum = 0 ; for ( int i = 0 ; i < k - 1 ; i ++ ) min_sum += p [ i ] ; int res = a [ n - 1 ] - a [ 0 ] - min_sum ; return res ; }
int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; }
void findPair ( int x ) { int lim = 120 ; for ( int i = - lim ; i <= lim ; i ++ ) { for ( int j = - lim ; j <= lim ; j ++ ) { if ( Math . pow ( i , 5 ) - Math . pow ( j , 5 ) == x ) { System . out . print ( i + " ▁ " + j + "NEW_LINE"); return ; } } } System . out . print ( " - 1" ) ; }
void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
int nthOdd ( int n ) { return ( 2 * n - 1 ) ; }
double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
boolean canBecomeEmpty ( String str , String sub_str ) { while ( str . length ( ) > 0 ) { int idx = str . indexOf ( sub_str ) ; if ( idx == - 1 ) { break ; } str = str . replaceFirst ( sub_str , " " ) ; } return ( str . length ( ) == 0 ) ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
int countMinReversals ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) return - 1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr . charAt ( i ) == ' { ' ) open ++ ; else { if ( open == 0 ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close != 0 ) ans += 2 ; return ans ; }
boolean linearSearch ( int a [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == key ) return true ; } return false ; }
int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; }
String isAnBn ( String str ) { int n = str . length ( ) ; if ( ( n & 1 ) != 0 ) return " No " ; int i ; for ( i = 0 ; i < n / 2 ; i ++ ) if ( str . charAt ( i ) != ' a ' || str . charAt ( n - i - 1 ) != ' b ' ) return " No " ; return " Yes " ; }
int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + ( n ^ x ) ) ++ c ; return c ; }
int findMinRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
void bitonicSequence ( int num , int lower , int upper ) { if ( num > ( upper - lower ) * 2 + 1 ) { System . out . println ( - 1 ) ; return ; } Deque < Integer > ans = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < Math . min ( upper - lower + 1 , num - 1 ) ; i ++ ) ans . add ( upper - i ) ; for ( int i = 0 ; i < num - ans . size ( ) ; i ++ ) ans . addFirst ( upper - i - 1 ) ; System . out . println ( ans ) ; }
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Integer . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
boolean isEven ( int n ) { boolean isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
int sizeSubSet ( int a [ ] , int k , int n ) { Arrays . sort ( a ) ; HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . get ( a [ i ] / k ) == null ) s . put ( a [ i ] , s . get ( a [ i ] ) == null ? 1 : s . get ( a [ i ] ) + 1 ) ; } return s . size ( ) ; }
void printRepeating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( " Repeated ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; else count [ arr [ i ] ] ++ ; } }
int minOperation ( boolean arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
void countPairs ( int arr [ ] , int N , int K ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . get ( K - arr [ i ] ) != null ) cnt += mp . get ( K - arr [ i ] ) ; mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; } System . out . println ( cnt ) ; }
int findPermutation ( int n ) { int len = ( int ) Math . ceil ( Math . log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * ( int ) Math . pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; }
int totalSumDivisibleByNum ( int n , int number ) { int firstnum = ( int ) Math . pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
int maxcntPairsSumKRemoved ( int [ ] arr , int k ) { int cntPairs = 0 ; if ( arr . length <= 1 ) return cntPairs ; Arrays . sort ( arr ) ; int left = 0 ; int right = arr . length - 1 ; while ( left < right ) { int s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }
void SubString ( String str , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j <= n ; j ++ ) System . out . println ( str . substring ( i , j ) ) ; }
void findsolution ( long n , long x , long y ) { if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x y < n ) { System . out . println ( " No ▁ solution " ) ; return ; } System . out . println ( y - n + 1 ) ; while ( n -- > 1 ) System . out . println ( "1" ) ; }
int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) Math . pow ( i , res ) % mod ; return res ; }
boolean checkPointRange ( int arr [ ] [ ] , int X , int Y , int N ) { for ( int i = 0 ; i < N ; i ++ ) { double dist = Math . sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) ; if ( dist <= arr [ i ] [ 2 ] ) { return true ; } } return false ; }
int missingK ( int [ ] a , int k , int n ) { int difference = 0 , ans = 0 , count = k ; boolean flag = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; }
void occurredOnce ( int arr [ ] , int n ) { int i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else System . out . print ( arr [ i - 1 ] + " ▁ " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) System . out . print ( arr [ n - 1 ] ) ; }
int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
boolean isPrime ( int p ) { double checkNumber = Math . pow ( 2 , p ) - 1 ; double nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
void minOperations ( String S ) { int count = 0 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i - 1 ) ) { count += 1 ; } } System . out . print ( count ) ; }
int distribution ( int arr [ ] , int n ) { Set < Integer > resources = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) resources . add ( arr [ i ] ) ; return Math . min ( resources . size ( ) , n / 2 ) ; }
int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . cbrt ( N ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = ( int ) Math . cbrt ( diff ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
double nthHarmonic ( int N ) { float harmonic = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }
boolean isTriplet ( int ar [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( Math . abs ( ar [ i ] - ar [ j ] ) == 1 || Math . abs ( ar [ j ] - ar [ k ] ) == 1 || Math . abs ( ar [ i ] - ar [ k ] ) == 1 ) { int x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; }
int minimumReverse ( String s , int n ) { int k = 0 , l = 0 ; int sum1 = 0 , sum0 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) sum1 ++ ; else sum0 ++ ; if ( s . charAt ( i ) == s . charAt ( i - 1 ) && s . charAt ( i ) == '0' ) k ++ ; else if ( s . charAt ( i ) == s . charAt ( i - 1 ) && s . charAt ( i ) == '1' ) l ++ ; } if ( s . charAt ( 0 ) == '1' ) sum1 ++ ; sum0 ++ ; if ( Math . abs ( sum1 - sum0 ) > 1 ) return - 1 ; return Math . max ( k , l ) ; }
int highestPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; }
void checkArrangement ( Integer [ ] A1 , Integer [ ] A2 , int n , int k ) { Arrays . sort ( A1 ) ; Arrays . sort ( A2 , Collections . reverseOrder ( ) ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) System . out . println ( " No " ) ; else System . out . println ( " Yes " ) ; }
void findFactors ( int a , int b ) { int c ; c = a + b - 1 ; System . out . print ( c ) ; }
int maximumSum ( int [ ] a , int count , int index , int n , int [ ] [ ] dp ) { if ( index == n ) return 0 ; if ( dp [ index ] [ count ] != - 1 ) return dp [ index ] [ count ] ; int take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; int dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index ] [ count ] = Math . max ( take_element , dont_take ) ; }
int twoEggDrop ( int k ) { return ( int ) Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
int minCost ( int cost [ ] [ ] ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
boolean isPower ( int n ) { for ( int x = 2 ; x <= ( int ) Math . sqrt ( n ) ; x ++ ) { float f = ( float ) Math . log ( n ) / ( float ) Math . log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) System . out . println ( " Increasing " ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Decreasing " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Increasing ▁ then ▁ decreasing " ) ; else System . out . println ( " Decreasing ▁ then ▁ increasing " ) ; }
int term ( int n ) { int x = ( ( ( 1 ) + ( int ) Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }
int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
void printRectPattern ( int c1 , int c2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( ( Math . max ( Math . abs ( c1 - i ) , Math . abs ( c2 - j ) ) ) + " ▁ " ) ; } System . out . println ( ) ; } }
void reverseorder ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = n ; i >= 2 ; i -- ) if ( prime [ i ] == true ) System . out . print ( i + " ▁ " ) ; }
int sumOfParts ( int [ ] [ ] arr , int N ) { int sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; int totalsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j && i != j && i + j > 0 ) sum_part1 += arr [ i ] [ j ] ; else if ( i != j ) sum_part2 += arr [ i ] [ j ] ; } else { if ( i > j && i + j != N - 1 ) sum_part3 += arr [ i ] [ j ] ; else { if ( i + j != N - 1 && i != j ) sum_part4 += arr [ i ] [ j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }
String get_maximum ( char [ ] s , int a [ ] ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = ( char ) ( '0' + a [ s [ j ] - '0' ] ) ; j ++ ; } return String . valueOf ( s ) ; } } return String . valueOf ( s ) ; }
float circlearea ( float R ) { if ( R < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * R * R ) / 4 ) ; return a ; }
double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; }
int countSwaps ( int A [ ] , int n ) { Arrays . sort ( A ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }
> smallestSumpair ( int [ ] arr , int n ) { Vector < Integer > pair = new Vector < Integer > ( ) ; int min_sum = Integer . MAX_VALUE , i ; for ( i = 1 ; i < n ; i ++ ) { if ( min_sum > ( arr [ i ] + arr [ i - 1 ] ) ) { min_sum = arr [ i ] + arr [ i - 1 ] ; if ( pair . isEmpty ( ) ) { pair . add ( arr [ i - 1 ] ) ; pair . add ( arr [ i ] ) ; } else { pair . set ( 0 , arr [ i - 1 ] ) ; pair . set ( 1 , arr [ i ] ) ; } } } return pair ; }
int Balanced_Substring ( String str , int n ) { int ans = 0 ; int [ ] arr = new int [ n / 2 + 1 ] ; int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) d ++ ; else { if ( d == 1 ) { for ( int j = 2 ; j <= n / 2 + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; }
void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) System . out . print ( 1 + " ▁ " ) ; System . out . print ( N - K + 1 ) ; }
void interchangeFirstLast ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
boolean isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }
double pairProductMean ( int arr [ ] , int N ) { Vector < Integer > pairArray = new Vector < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . add ( pairProduct ) ; } } int length = pairArray . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray . get ( i ) ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; }
int maxSum ( int grid [ ] [ ] , int n ) { int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }
int minimum_sum ( int n , int k ) { if ( k % n == 0 ) return 0 ; return 1 ; }
int countIndices ( int arr [ ] , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; }
void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ; int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { System . out . println ( " No ▁ intersection " ) ; return ; } System . out . print ( " ( " + x5 + " , ▁ " + y5 + " ) ▁ " ) ; System . out . print ( " ( " + x6 + " , ▁ " + y6 + " ) ▁ " ) ; int x7 = x5 ; int y7 = y6 ; System . out . print ( " ( " + x7 + " , ▁ " + y7 + " ) ▁ " ) ; int x8 = x6 ; int y8 = y5 ; System . out . print ( " ( " + x8 + " , ▁ " + y8 + " ) ▁ " ) ; }
calculate sum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; }
void converthenumber ( int n ) { String s = Integer . toString ( n ) ; String res = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' || s . charAt ( i ) == '3' || s . charAt ( i ) == '5' || s . charAt ( i ) == '7' || s . charAt ( i ) == '9' ) res += s . charAt ( i ) ; if ( res . length ( ) == 2 ) break ; } if ( res . length ( ) == 2 ) System . out . println ( res ) ; else System . out . println ( - 1 ) ; }
void decimalToBinary ( int n ) { if ( n == 0 ) { System . out . print ( "0" ) ; return ; } decimalToBinary ( n / 2 ) ; System . out . print ( n % 2 ) ; }
int sumOfSeries ( int n ) { int ans = ( int ) Math . pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
void findNthTerm ( int n ) { System . out . println ( n * n - n + 1 ) ; }
int minMaxDiff ( int arr [ ] , int n , int k ) { int max_adj_dif = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = Math . max ( max_adj_dif , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; }
void printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { System . out . print ( m + " ▁ " ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; System . out . print ( binom + " ▁ " ) ; } System . out . println ( ) ; } }
int MaximumSides ( int n ) { if ( n < 4 ) return - 1 ; return n % 2 == 0 ? n / 2 : - 1 ; }
long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
int OR ( int a [ ] , int n ) { int ans = a [ 0 ] ; int i ; for ( i = 1 ; i < n ; i ++ ) { ans |= a [ i ] ; } return ans ; }
int cost ( String str ) { int len = str . length ( ) ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str . charAt ( i ) != str . charAt ( j ) ) res += Math . min ( str . charAt ( i ) , str . charAt ( j ) ) - ' a ' + 1 ; return res ; }
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
void encrypt ( char input [ ] ) { char evenPos = ' @ ' , oddPos = ' ! ' ; int repeat , ascii ; for ( int i = 0 ; i < input . length ; i ++ ) { ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) System . out . printf ( " % c " , oddPos ) ; else System . out . printf ( " % c " , evenPos ) ; } } }
int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
String separateChar ( String str ) { int n = str . length ( ) , digitSum = 0 ; int alphabetSum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { digitSum += ( int ) ( str . charAt ( i ) - '0' ) ; } else { alphabetSum += str . charAt ( i ) - ' a ' + 1 ; alphabetSum %= 26 ; } } String sumStr = " " + ( digitSum ) ; char alphabetStr = ( char ) ( alphabetSum + ' a ' - 1 ) ; sumStr += alphabetStr ; return sumStr ; }
float findAreaShaded ( float a ) { float sqArea = a * a ; float semiCircleArea = ( float ) ( 3.14 * ( a * a ) / 8 ) ; float ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; }
int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
int findLastIndex ( String str , Character x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }
double squareRoot ( double n , double l ) { double x = n ; double root ; int count = 0 ; while ( true ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( Math . abs ( root - x ) < l ) break ; x = root ; } return root ; }
void countPairs ( int arr [ ] , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } System . out . println ( answer ) ; }
int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }
void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; }
int fib ( int n ) { if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } }
boolean canFormPalindrome ( String a ) { int bitvector = 0 , mask = 0 ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { int x = a . charAt ( i ) - ' a ' ; mask = 1 << x ; bitvector = bitvector ^ mask ; } return ( bitvector & ( bitvector - 1 ) ) == 0 ; }
long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
void distinct ( String [ ] S , int M ) { int count = 0 ; for ( int i = 0 ; i < S . length ; i ++ ) { Set < Character > set = new HashSet < > ( ) ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( ! set . contains ( S [ i ] . charAt ( j ) ) ) set . add ( S [ i ] . charAt ( j ) ) ; } int c = set . size ( ) ; if ( c <= M ) count += 1 ; } System . out . println ( count ) ; }
float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
int count ( String S , int X ) { int count = 0 ; int N = S . length ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( S . charAt ( i ) != '0' ) { for ( int len = 1 ; ( i + len ) <= N ; ++ len ) { int num = Integer . parseInt ( S . substring ( i , i + len ) ) ; if ( num > X ) count ++ ; } } } return count ; }
int maxRemainingSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int i = 0 ; int j = n - 1 ; int result = 0 ; while ( i < j ) { if ( arr [ i ] < arr [ j ] ) { sum -= arr [ i ] ; i ++ ; } else { sum -= arr [ j ] ; j -- ; } result += sum ; } return result ; }
int findValue ( int R , int C ) { int k = ( R * ( R - 1 ) ) / 2 + 1 ; int diff = R + 1 ; for ( int i = 1 ; i < C ; i ++ ) { k = ( k + diff ) ; diff ++ ; } return k ; }
void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }
int getProduct ( int a [ ] , int n ) { int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { p *= Math . abs ( a [ i ] - a [ j ] ) ; } } return p ; }
char stringPalindrome ( String A , String B ) { int [ ] countA = new int [ MAX_CHAR ] ; int [ ] countB = new int [ MAX_CHAR ] ; int l1 = A . length ( ) ; int l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' A ' ; return ' B ' ; }
int findNumberOfStrings ( int n ) { int DP [ ] [ ] = new int [ n + 1 ] [ 6 ] ; DP [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 ; } else { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] ; } } } return DP [ n ] [ 5 ] ; }
void smallestNumber ( int N ) { System . out . print ( N * Math . floor ( ( Math . pow ( 10 , N ) - 1 ) / N ) ) ; }
int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; }
int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }
void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { System . out . print ( ( ( 1 << x ) + ( 1 << y ) ) + " ▁ " ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
void countEle ( Stack < Integer > s , int [ ] a , int N ) { HashMap < Integer , Boolean > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int num = a [ i ] ; if ( mp . containsKey ( num ) ) System . out . print ( "0 ▁ " ) ; else { int cnt = 0 ; while ( s . peek ( ) != num ) { mp . put ( s . peek ( ) , true ) ; s . pop ( ) ; cnt ++ ; } s . pop ( ) ; cnt ++ ; System . out . print ( cnt + " ▁ " ) ; } } }
void printXYZ ( int n ) { if ( n == 1 ) System . out . println ( - 1 ) ; else { System . out . println ( " x ▁ is ▁ " + n ) ; System . out . println ( " y ▁ is ▁ " + ( n + 1 ) ) ; System . out . println ( " z ▁ is ▁ " + ( n * ( n + 1 ) ) ) ; } }
float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float R = ( float ) ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) / 2 ; return R ; }
void countPairs ( int arr [ ] , int N ) { int countPowerof2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( Integer . bitCount ( arr [ i ] ) == 1 ) countPowerof2 ++ ; } int desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) / 2 ; System . out . print ( desiredPairs + " ▁ " ) ; }
int setRightmostUnsetBit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
void convertBfromA ( int a , int b ) { int moves = 0 ; int x = Math . abs ( a - b ) ; for ( int i = 10 ; i > 0 ; i -- ) { moves += x / i ; x = x % i ; } System . out . print ( moves + " ▁ " ) ; }
int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s . charAt ( i ) == ' ( ' && s . charAt ( i + 1 ) == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s . charAt ( i ) == ' ( ' && s . charAt ( j ) == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
int minFallingPathSum ( int A [ ] [ ] ) { for ( int R = n - 2 ; R >= 0 ; -- R ) { for ( int C = 0 ; C < n ; ++ C ) { int best = A [ R + 1 ] [ C ] ; if ( C > 0 ) best = Math . min ( best , A [ R + 1 ] [ C - 1 ] ) ; if ( C + 1 < n ) best = Math . min ( best , A [ R + 1 ] [ C + 1 ] ) ; A [ R ] [ C ] = A [ R ] [ C ] + best ; } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; ++ i ) ans = Math . min ( ans , A [ 0 ] [ i ] ) ; return ans ; }
void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; System . out . println ( ( float ) time ) ; }
int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
boolean isSaintExuperyNum ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; } } } return false ; }
void KthCharacter ( String S , int N , int K ) { char strarray [ ] = S . toCharArray ( ) ; Arrays . sort ( strarray ) ; char ch = strarray [ K - 1 ] ; int count = 0 ; for ( char c : strarray ) { if ( c == ch ) count ++ ; } System . out . println ( count ) ; }
int findHours ( int a , int b , int k ) { if ( a >= b ) return - 1 ; int time = k / ( b - a ) ; time = time + 1 ; return time ; }
int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a ; return res ; }
float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = ( int ) ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0f * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0f * A ) ) ; return sqrt_of_s ; }
void sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; System . out . print ( f [ 1 ] + " ▁ " + f [ 2 ] + " ▁ " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; System . out . print ( f [ i ] + " ▁ " ) ; } }
int summation ( int n ) { int abs_sum = n * ( n + 1 ) / 2 ; int sign = n + 1 % 2 == 0 ? 1 : - 1 ; int result_sum = sign * abs_sum ; return result_sum ; }
int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
int countPermutations ( int N ) { ArrayList < ArrayList < Integer > > adj = new ArrayList < ArrayList < Integer > > ( 105 ) ; for ( int i = 0 ; i < 105 ; i ++ ) adj . add ( new ArrayList < Integer > ( ) ) ; int indeg = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; int sum = i + j ; if ( Math . ceil ( Math . sqrt ( sum ) ) == Math . floor ( Math . sqrt ( sum ) ) ) { adj . get ( i ) . add ( j ) ; } } if ( adj . get ( i ) . size ( ) == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }
void findLargestRotation ( int num ) { int ans = num ; int len = ( int ) Math . floor ( ( ( int ) Math . log10 ( num ) ) + 1 ) ; int x = ( int ) Math . pow ( 10 , len - 1 ) ; for ( int i = 1 ; i < len ; i ++ ) { int lastDigit = num % 10 ; num = num / 10 ; num += ( lastDigit * x ) ; if ( num > ans ) { ans = num ; } } System . out . print ( ans ) ; }
void countDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) System . out . println ( " Even " ) ; else System . out . println ( " Odd " ) ; }
double Area_of_Rhombus ( int a , int theta ) { double area = ( a * a ) * Math . sin ( ( RADIAN * theta ) ) ; return area ; }
int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
int getChicks ( int n ) { int chicks = ( int ) Math . pow ( 3 , n - 1 ) ; return chicks ; }
int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; }
int countSubstrig ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . substring ( 0 , n2 ) . equals ( str2 ) ) return countSubstrig ( str1 . substring ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . substring ( n2 - 1 ) , str2 ) ; }
void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; System . out . println ( " Missing ▁ element ▁ is ▁ " + res ) ; }
double calculateArea ( int x , int y ) { double pi = 3.1415926536 ; double arx = pi * x * x ; double ary = pi * y * y ; return arx - ary ; }
int find ( int index , int openbrk , int n , int adj [ ] [ ] ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
int maxPartition ( String s ) { int n = s . length ( ) , P = 0 ; String current = " " , previous = " " ; for ( int i = 0 ; i < n ; i ++ ) { current += s . charAt ( i ) ; if ( ! current . equals ( previous ) ) { previous = current ; current = " " ; P ++ ; } } return P ; }
int condition ( int a , int b ) { int d = Math . abs ( a - b ) , count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; }
int countPairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int maxP = Math . min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; int cnt = maxP - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; }
boolean ifPossible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }
int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left + 1 ; int d = arr [ 1 ] / arr [ 0 ] ; int ans = arr [ left - 1 ] ; if ( d == 1 ) ans = ans * d * k ; else ans = ans * ( ( int ) Math . pow ( d , k ) - 1 / ( d - 1 ) ) ; return ans ; }
int digSum ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; }
int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
void lcmpair ( int l , int r ) { int x , y ; x = l ; y = 2 * l ; if ( y > r ) { System . out . print ( "-1NEW_LINE"); } else { System . out . print ( " X ▁ = ▁ " + x + " ▁ Y ▁ = ▁ " + y + "NEW_LINE"); } }
int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; }
int minOccupiedPosition ( int A [ ] , int n ) { int minPos = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; }
double findArea ( double d ) { return ( d * d ) / 2 ; }
boolean isCornerPresent ( String str , String corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . equals ( corner ) && str . substring ( n - cl , n ) . equals ( corner ) ) ; }
int minimum_deci_binary_number ( String s ) { int m = Integer . MIN_VALUE ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int temp = s . charAt ( i ) - '0' ; if ( temp > m ) { m = temp ; } } return m ; }
boolean modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; Arrays . fill ( DP , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; Arrays . fill ( temp , false ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
int maxTripletSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
void countPairs ( int [ ] arr , int k , int size ) { int count = 0 , x ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < size ; j ++ ) { x = arr [ i ] | arr [ j ] ; if ( x == k ) count ++ ; } } System . out . println ( count ) ; }
void minCost ( int costs [ ] [ ] , int N ) { if ( N == 0 ) return ; int dp [ ] [ ] = new int [ N ] [ 3 ] ; dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = Math . min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } System . out . println ( Math . min ( dp [ N - 1 ] [ 0 ] , Math . min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) ; }
int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }
long findMinSum ( long a [ ] , long b [ ] , long n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
long multiplyByMersenne ( long N , long M ) { long x = ( int ) ( Math . log ( M + 1 ) / Math . log ( 2 ) ) ; return ( ( N << x ) - N ) ; }
int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
long sumOfSumSeries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int evenNumSubstring ( String str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str . charAt ( i ) - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
int countOpenDoors ( int N ) { int doorsOpen = ( int ) Math . sqrt ( N ) ; return doorsOpen ; }
int maxSubarrayProduct ( int arr [ ] ) { int result = arr [ 0 ] ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { int mul = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { result = Math . max ( result , mul ) ; mul *= arr [ j ] ; } result = Math . max ( result , mul ) ; } return result ; }
void findWinner ( int a [ ] , int n ) { int win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) System . out . print ( " A " ) ; else System . out . print ( " B " ) ; }
int icosikaiheptagonalNum ( int n ) { return ( 25 * n * n - 23 * n ) / 2 ; }
double average ( int arr [ ] , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; Arrays . sort ( arr ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
int nextPerfectCube ( int N ) { int nextN = ( int ) Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; }
int cost ( int [ ] a , int n ) { int min = a [ 0 ] ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }
long operation ( int arr [ ] , int N ) { int right = 0 ; int num = 0 ; long ans = 0 ; for ( int left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }
void occurredOnce ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; if ( arr [ 0 ] != arr [ 1 ] ) System . out . println ( arr [ 0 ] + " ▁ " ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) System . out . print ( arr [ i ] + " ▁ " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) System . out . print ( arr [ n - 1 ] + " ▁ " ) ; }
void findNums ( int n ) { if ( n <= 11 ) { if ( n == 8 ) System . out . print ( "4 ▁ 4" ) ; if ( n == 10 ) System . out . print ( "4 ▁ 6" ) ; else System . out . print ( " - 1" ) ; return ; } if ( n % 2 == 0 ) System . out . print ( "4 ▁ " + ( n - 4 ) ) ; else System . out . print ( "9 ▁ " + ( n - 9 ) ) ; }
int isvalid ( int s ) { double k = ( - 1.0 + Math . sqrt ( 1 + 8 * s ) ) / 2 ; if ( Math . ceil ( k ) == Math . floor ( k ) ) return ( int ) k ; else return - 1 ; }
int lds ( int arr [ ] , int n ) { int lds [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
int solve ( int [ ] a ) { int n = a . length ; int [ ] dp = new int [ n + 1 ] ; int [ ] val = new int [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int sum = a [ i ] ; int j = i ; while ( j + 1 < n && sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }
int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
int MinimumNoOfWays ( int arr [ ] , int n ) { int mini_no_of_ways ; if ( n % 2 == 0 ) { mini_no_of_ways = n / 2 ; } else { mini_no_of_ways = n / 2 + 1 ; } return mini_no_of_ways ; }
int countTriplets ( int [ ] arr , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) { ans ++ ; } } } } return ans ; }
int subarray ( int arr [ ] , int n ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
int firstNonRepeating ( String str ) { int NO_OF_CHARS = 256 ; int arr [ ] = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( arr [ str . charAt ( i ) ] == - 1 ) arr [ str . charAt ( i ) ] = i ; else arr [ str . charAt ( i ) ] = - 2 ; } int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = Math . min ( res , arr [ i ] ) ; return res ; }
int minvalue_y ( int x ) { int n = ( int ) Math . sqrt ( x ) ; if ( n * n == x ) return x + 1 ; return ( int ) Math . pow ( n + 1 , 2 ) ; }
boolean isSumEqual ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
void longestSubSequence ( int [ ] [ ] A , int N ) { int [ ] dp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] && A [ j ] [ 1 ] > A [ i ] [ 1 ] ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } } System . out . println ( dp [ N - 1 ] ) ; }
int sum ( int h ) { return ( int ) Math . pow ( 2 , h - 1 ) ; }
boolean isPowerOfTwo ( int n ) { return ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) == Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; }
int MaximumPath ( int [ ] [ ] grid ) { int N = grid . length ; int M = grid [ 0 ] . length ; int [ ] [ ] sum = new int [ N + 1 ] [ M + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { sum [ i ] [ j ] = Math . max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ; } } return sum [ N ] [ M ] ; }
int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; }
int maxSelections ( int A [ ] , int n , int k ) { Arrays . sort ( A ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }
int countNumber ( int N , int S ) { int countElements = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; }
int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; }
boolean areSetBitsIncreasing ( int n ) { int prev_count = Integer . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
boolean isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ j ] + " , ▁ " + A [ k ] ) ; return true ; } } } } return false ; }
int countInscribed ( int R1 , int R2 ) { if ( R2 > R1 ) return 0 ; double angle ; double ratio ; int number_of_circles = 0 ; ratio = R2 / ( double ) ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = Math . abs ( Math . asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = ( int ) ( 360 / ( 2 * Math . floor ( angle ) ) ) ; } return number_of_circles ; }
boolean checkHankelMatrix ( int n , int m [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }
boolean squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
int AND ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
void lowerWythoff ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; for ( int i = 1 ; i <= n ; i ++ ) { double ans = Math . floor ( i * phi ) ; System . out . print ( ( int ) ans ) ; if ( i != n ) System . out . print ( " ▁ , ▁ " ) ; } }
int find ( int A , int B , int C , int N ) { int [ ] arr = new int [ N ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; for ( int i = 3 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 3 ] ; } return arr [ N - 1 ] ; }
void findLine ( int distance , float degree ) { float x = ( float ) ( degree * 3.14159 / 180 ) ; if ( degree > 90 ) { System . out . print ( " Not ▁ Possible " ) ; return ; } float result_1 = ( float ) Math . sin ( x ) ; float result_2 = ( float ) Math . cos ( x ) ; System . out . print ( String . format ( " % .2f " , result_2 ) + " x ▁ + " + String . format ( " % .2f " , result_1 ) + " y ▁ = ▁ " + distance ) ; }
void findNumbers ( int n , int b ) { double even = 0 , odd = 0 ; if ( b % 2 == 0 ) { even = Math . pow ( b , n ) - 2 ; odd = Math . pow ( b , n ) - 1 ; } else { even = Math . pow ( b , n ) - 1 ; odd = Math . pow ( b , n ) - 2 ; } System . out . println ( " Even ▁ Number ▁ = ▁ " + ( int ) even ) ; System . out . print ( " Odd ▁ Number ▁ = ▁ " + ( int ) odd ) ; }
void countPairs ( long L , long R ) { long firstNum = 2 * L ; long lastNum = 2 * R ; long Cntpairs = lastNum - firstNum + 1 ; System . out . println ( Cntpairs ) ; }
int findMaxRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
boolean checkSame ( int n ) { int set = 0 ; int unset = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; }
int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }
int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }
int singleelement ( int arr [ ] , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; }
void cal_cos ( float n ) { float accuracy = ( float ) 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( float ) ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= cosval - cosx ) ; System . out . println ( cosx ) ; }
void splitString ( String str ) { StringBuffer alpha = new StringBuffer ( ) , num = new StringBuffer ( ) , special = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isDigit ( str . charAt ( i ) ) ) num . append ( str . charAt ( i ) ) ; else if ( Character . isAlphabetic ( str . charAt ( i ) ) ) alpha . append ( str . charAt ( i ) ) ; else special . append ( str . charAt ( i ) ) ; } System . out . println ( alpha ) ; System . out . println ( num ) ; System . out . println ( special ) ; }
int printCountDP ( int dist ) { int [ ] ways = new int [ 3 ] ; int n = dist ; ways [ 0 ] = 1 ; ways [ 1 ] = 1 ; ways [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] ; return ways [ n % 3 ] ; }
int calculateSum ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; }
int largest_subarray ( int a [ ] , int n ) { HashMap < Integer , Integer > index = new HashMap < Integer , Integer > ( ) ; int ans = 0 ; for ( int i = 0 , j = 0 ; i < n ; i ++ ) { j = Math . max ( index . containsKey ( a [ i ] ) ? index . get ( a [ i ] ) : 0 , j ) ; ans = Math . max ( ans , i - j + 1 ) ; index . put ( a [ i ] , i + 1 ) ; } return ans ; }
void permute ( String input ) { int n = input . length ( ) ; int max = 1 << n ; input = input . toLowerCase ( ) ; for ( int i = 0 ; i < max ; i ++ ) { char combination [ ] = input . toCharArray ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = ( char ) ( combination [ j ] - 32 ) ; } System . out . print ( combination ) ; System . out . print ( " ▁ " ) ; } }
int minimumSwaps ( int [ ] arr ) { int count = 0 ; int i = 0 ; while ( i < arr . length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; }
int countSubarrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { long product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
void findSumOfGP ( double a , double r ) { if ( Math . abs ( r ) >= 1 ) { System . out . print ( " Infinite " ) ; return ; } double sum = a / ( 1 - r ) ; System . out . print ( sum ) ; }
double area_of_tetrahedron ( int side ) { return ( Math . sqrt ( 3 ) * ( side * side ) ) ; }
int countGroups ( int position , int previous_sum , int length , char [ ] num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }
void minXOR ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { System . out . print ( ( Arr [ i ] ^ 3 ) + " ▁ " ) ; } else { System . out . print ( ( Arr [ i ] ^ 2 ) + " ▁ " ) ; } } }
int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; }
int countSubstrings ( String s , char c ) { int n = s . length ( ) ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
int countOccurrances ( int n , int d ) { int count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = n / 10 ; } return count ; }
String LexicographicalMaxString ( String str ) { String mx = " " ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( mx . compareTo ( str . substring ( i ) ) <= 0 ) { mx = str . substring ( i ) ; } } return mx ; }
double nDigitPerfectSquares ( int n , int b ) { double largest = Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( b , n ) ) ) - 1 , 2 ) ; return largest ; }
boolean checkOverlap ( int R , int Xc , int Yc , int X1 , int Y1 , int X2 , int Y2 ) { int Xn = Math . max ( X1 , Math . min ( Xc , X2 ) ) ; int Yn = Math . max ( Y1 , Math . min ( Yc , Y2 ) ) ; int Dx = Xn - Xc ; int Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; }
int transformSubsequence ( int n , int m , int [ ] A , int [ ] B ) { if ( B . length == 0 ) return n ; int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return n - dp [ n ] [ m ] ; }
void multiplicativeCongruentialMethod ( int Xo , int m , int a , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } }
int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . ceil ( eq_root ) + l ) ; }
int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
int maxDistance ( int [ ] arr , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ; } return max_dist ; }
boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 8 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; int third_last = str . charAt ( n - 3 ) - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
int countCrossLine ( int arr [ ] , int n ) { int count_crossline = 0 ; int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
int knapSack ( int [ ] nums , int S ) { int sum = 0 ; for ( int i : nums ) sum += i ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; int [ ] dp = new int [ ( S + sum ) / 2 + 1 ] ; dp [ 0 ] = 1 ; for ( int num : nums ) { for ( int i = dp . length - 1 ; i >= num ; i -- ) { dp [ i ] += dp [ i - num ] ; } } return dp [ dp . length - 1 ] ; }
long minPerimeter ( int n ) { int l = ( int ) Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
long maxOR ( long arr [ ] , int n , int k , int x ) { long preSum [ ] = new long [ n + 1 ] ; long suffSum [ ] = new long [ n + 1 ] ; long res = 0 , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; }
int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return ( n & 1 ) > 0 ? 1 : 6 ; }
void countSubstrings ( String s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; for ( char i : s . toCharArray ( ) ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } System . out . println ( ans ) ; }
int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
int maxConsecutiveCnt ( int [ ] arr ) { int X = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] <= ( X + 1 ) ) { X = X + arr [ i ] ; } else { break ; } } return X + 1 ; }
int findOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
double sumOfTheSeries ( int n ) { double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
boolean checkFittingArrays ( int [ ] A , int [ ] B , int N ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
int getSum ( int n ) { return ( ( n - 1 ) + ( int ) Math . pow ( n , 2 ) ) ; }
void recaman ( int n ) { int arr [ ] = new int [ n ] ; arr [ 0 ] = 0 ; System . out . print ( arr [ 0 ] + " ▁ , " ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; System . out . print ( arr [ i ] + " , ▁ " ) ; } }
boolean divisorsSame ( int n ) { return ( n - 2 ) % 4 == 0 ; }
int maxDistance ( int [ ] array ) { int max1 = Integer . MIN_VALUE ; int min1 = Integer . MAX_VALUE ; int max2 = Integer . MIN_VALUE ; int min2 = Integer . MAX_VALUE ; for ( int i = 0 ; i < array . length ; i ++ ) { max1 = Math . max ( max1 , array [ i ] + i ) ; min1 = Math . min ( min1 , array [ i ] + i ) ; max2 = Math . max ( max2 , array [ i ] - i ) ; min2 = Math . min ( min2 , array [ i ] - i ) ; } return Math . max ( max1 - min1 , max2 - min2 ) ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
int fun ( int n ) { return n & ( n - 1 ) ; }
int findSum ( int n , int k ) { int val = ( k / ( n - 1 ) ) * n ; int rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } int sum = ( val * ( val + 1 ) ) / 2 ; int x = k / ( n - 1 ) ; int sum_of_multiples = ( x * ( x + 1 ) * n ) / 2 ; sum -= sum_of_multiples ; return sum ; }
int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; return solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
int findCount ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }
boolean isdodecagonal ( int N ) { float n = ( float ) ( ( 4 + Math . sqrt ( 20 * N + 16 ) ) / 10 ) ; return ( n - ( int ) n ) == 0 ; }
int solve ( int n , int k , int m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) return 0 ; if ( n < 0 k < 0 ) return 0 ; if ( dp [ n ] [ k ] > 0 ) return dp [ n ] [ k ] ; int ans = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n ] [ k ] = ans ; }
void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { System . out . println ( arr [ i ] + " ▁ " + arr [ j ] + " ▁ " + arr [ k ] ) ; } } } } }
int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; }
int maxSum ( int arr [ ] , int i , int n , int k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = true ; int tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( int j = i ; j < ( i + k ) && ( j < n ) ; j ++ ) { tot += arr [ j ] ; dp [ i ] = Math . max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; }
int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
void dfs ( int [ ] val , int [ ] cost , Vector < Integer > [ ] tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . size ( ) ; i ++ ) { dfs ( val , cost , tr , tr [ u ] . get ( i ) , s ) ; } }
int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 2 * n + 2 ; }
int numOfCombinations ( int arr [ ] , int N ) { int C [ ] = { 0 , 0 , 0 } ; for ( int i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
int minToggle ( int arr [ ] , int n ) { int zero [ ] = new int [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ans == - 1 ) ans = ( A [ i ] & B [ j ] ) ; else ans ^= ( A [ i ] & B [ j ] ) ; } } return ans ; }
void printSpiral ( int [ ] [ ] mat , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) System . out . print ( mat [ low_row ] [ i ] + " ▁ " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) System . out . print ( mat [ i ] [ high_column ] + " ▁ " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) System . out . print ( mat [ high_row ] [ i ] + " ▁ " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) System . out . print ( mat [ i ] [ low_column ] + " ▁ " ) ; low_column -= 1 ; } System . out . println ( ) ; }
void lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } System . out . println ( ans ) ; }
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( " Touch " ) ; else if ( radius > dist ) System . out . println ( " Intersect " ) ; else System . out . println ( " Outside " ) ; }
int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; }
int countDe ( int arr [ ] , int n ) { int v [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; Arrays . sort ( arr ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; Collections . reverse ( Arrays . asList ( arr ) ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . min ( count1 , count2 ) ) ; }
boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }
int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) map . put ( arr [ i ] - i , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) map . put ( arr [ i ] - i , map . get ( arr [ i ] - i ) + 1 ) ; int res = 0 ; for ( int x : map . values ( ) ) { int cnt = x ; res += ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } return res ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = ( int ) ( Math . pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) System . out . print ( ans ) ; else System . out . print ( 2 * ans ) ; }
int getMaxOnes ( int n , int x ) { int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; int total = n * n ; int ans = total - zeroes ; return ans ; }
int findCost ( String s1 , String s2 , int a , int b , int c , int d , int n ) { int cost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 . charAt ( i ) == s2 . charAt ( i ) ) continue ; else { if ( ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '2' ) || ( s2 . charAt ( i ) == '1' && s1 . charAt ( i ) == '2' ) ) cost += Math . min ( d , Math . min ( a , b + c ) ) ; else if ( ( s1 . charAt ( i ) == '2' && s2 . charAt ( i ) == '3' ) || ( s2 . charAt ( i ) == '2' && s1 . charAt ( i ) == '3' ) ) cost += Math . min ( d , Math . min ( b , a + c ) ) ; else if ( ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '3' ) || ( s2 . charAt ( i ) == '1' && s1 . charAt ( i ) == '3' ) ) cost += Math . min ( d , Math . min ( c , a + b ) ) ; } } return cost ; }
String canSplitArray ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= k ) { return " No " ; } } return " Yes " ; }
int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; }
int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return ( int ) ( Math . floor ( digits ) ) + 1 ; }
int minimumValue ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }
int maxGCD ( int n ) { return ( n / 2 ) ; }
float trianglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = ( float ) ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / ( 4 * b ) ; return area ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) System . out . println ( first ) ; else if ( n == 6 ) System . out . println ( sixth ) ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } System . out . println ( curr ) ; }
boolean isConvertible ( String str1 , String str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
void poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { System . out . print ( ( int ) Math . ceil ( Math . log ( buckets ) / Math . log ( ( minutesToTest / minutesToDie ) + 1 ) ) ) ; }
boolean possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
void query ( String s , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
int findSum ( int [ ] arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] == 1 ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; dp [ l ] [ r ] = Math . min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; return dp [ l ] [ r ] ; }
int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 ; int ans = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }
int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . toCharArray ( ) ; for ( int i = 0 ; i < new_str . length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
double distance ( int x1 , int y1 , int x2 , int y2 ) { return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; }
void printArr ( int n ) { if ( n % 4 == 0 ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) System . out . print ( i * 2 + " ▁ " ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) System . out . print ( i * 2 - 1 + " ▁ " ) ; System . out . println ( n + n / 2 - 1 ) ; } else System . out . print ( " - 1" ) ; }
int count ( int n ) { HashMap < Integer , Integer > dp = new HashMap < Integer , Integer > ( ) ; dp . put ( 0 , 0 ) ; dp . put ( 1 , 1 ) ; if ( ! dp . containsKey ( n ) ) dp . put ( n , 1 + Math . min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ) ; return dp . get ( n ) ; }
void nearestPerfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = ( int ) Math . sqrt ( arr [ i ] ) ; if ( ( sr & 1 ) == ( arr [ i ] & 1 ) ) System . out . print ( ( sr * sr ) + " ▁ " ) ; else { sr ++ ; System . out . print ( ( sr * sr ) + " ▁ " ) ; } } }
int find_next ( int n , int k ) { int M = n + 1 ; while ( true ) { if ( ( M & ( 1L << k ) ) > 0 ) break ; M ++ ; } return M ; }
int countCompositions ( int n ) { return 1 << ( n - 1 ) ; }
int rhombusAreaPeri ( int d1 , int d2 ) { int area , perimeter ; area = ( d1 * d2 ) / 2 ; perimeter = ( int ) ( 2 * Math . sqrt ( Math . pow ( d1 , 2 ) + Math . pow ( d2 , 2 ) ) ) ; System . out . println ( " The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " + d1 + " ▁ and ▁ " + d2 + " ▁ is ▁ " + area + " . " ) ; System . out . println ( " The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " + d1 + " ▁ and ▁ " + d2 + " ▁ is ▁ " + perimeter + " . " ) ; return 0 ; }
boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 9 == 0 ) ; }
long productAscii ( String str ) { long prod = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= str . charAt ( i ) ; } return prod ; }
int ways ( int arr [ ] , int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; }
int steps ( int source , int step , int dest ) { if ( Math . abs ( source ) > ( dest ) ) return Integer . MAX_VALUE ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . min ( pos , neg ) ; }
int findCount ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == ( str . charAt ( i ) - ' a ' ) || i == ( str . charAt ( i ) - ' A ' ) ) { result ++ ; } } return result ; }
int shortestChainLen ( String start , String target , Set < String > D ) { if ( start == target ) return 0 ; if ( ! D . contains ( target ) ) return 0 ; int level = 0 , wordlength = start . length ( ) ; Queue < String > Q = new LinkedList < > ( ) ; Q . add ( start ) ; while ( ! Q . isEmpty ( ) ) { ++ level ; int sizeofQ = Q . size ( ) ; for ( int i = 0 ; i < sizeofQ ; ++ i ) { char [ ] word = Q . peek ( ) . toCharArray ( ) ; Q . remove ( ) ; for ( int pos = 0 ; pos < wordlength ; ++ pos ) { char orig_char = word [ pos ] ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) { word [ pos ] = c ; if ( String . valueOf ( word ) . equals ( target ) ) return level + 1 ; if ( ! D . contains ( String . valueOf ( word ) ) ) continue ; D . remove ( String . valueOf ( word ) ) ; Q . add ( String . valueOf ( word ) ) ; } word [ pos ] = orig_char ; } } } return 0 ; }
boolean checkEvenPower ( int n ) { int x = 0 ; while ( x < n ) { int value = ( int ) Math . pow ( 2 , x ) ; if ( value == n ) { if ( x % 2 == 0 ) return true ; else return false ; } x ++ ; } return false ; }
float Cel_To_Fah ( float n ) { return ( ( n * 9.0f / 5.0f ) + 32.0f ) ; }
void printpenta ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 1 ; int curr = 0 ; if ( n == 0 n == 1 n == 2 n == 3 ) System . out . print ( first + "NEW_LINE"); else if ( n == 5 ) System . out . print ( fifth + "NEW_LINE"); else { for ( int i = 5 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = curr ; } System . out . print ( curr + "NEW_LINE"); } }
int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
long countEvenSum ( int a [ ] , int n ) { long res = 0 ; int s = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] % 2 == 1 ) { s = n - i - 1 - s ; } else { s = s + 1 ; } res = res + s ; } return res ; }
float areaOfKite ( int a , int b , double angle ) { angle = angle * PI ; double area = a * b * Math . sin ( angle ) ; return ( float ) area ; }
int minSumDifference ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; int rem = sum % n ; return rem * ( n - rem ) ; }
int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
void sum_of_elements ( int [ ] arr , int n ) { int sumfirst = 0 , sumsecond = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { sumfirst += arr [ i ] ; } else { sumsecond += arr [ i ] ; } } System . out . println ( " Sum ▁ of ▁ first ▁ half ▁ elements ▁ is ▁ " + sumfirst ) ; System . out . println ( " Sum ▁ of ▁ second ▁ half ▁ elements ▁ is ▁ " + sumsecond ) ; }
boolean isUnique ( int [ ] a , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
boolean check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * ( int ) Math . pow ( 2 , n - 1 ) ; return sum ; }
int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; }
boolean isFancy ( String num ) { Map < Character , Character > fp = new HashMap < Character , Character > ( ) ; fp . put ( '0' , '0' ) ; fp . put ( '1' , '1' ) ; fp . put ( '6' , '9' ) ; fp . put ( '8' , '8' ) ; fp . put ( '9' , '6' ) ; int n = num . length ( ) ; int l = 0 , r = n - 1 ; while ( l <= r ) { if ( ! fp . containsKey ( num . charAt ( l ) ) || fp . get ( num . charAt ( l ) ) != num . charAt ( r ) ) return false ; l ++ ; r -- ; } return true ; }
void check ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
boolean almostSort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
int no_of_digit ( int a , int b ) { return ( ( int ) ( b * Math . log10 ( a ) ) + 1 ) ; }
void SubarraysWithSumS ( int n , int k , int s ) { for ( int i = 0 ; i < k ; i ++ ) System . out . print ( s + " ▁ " ) ; for ( int i = k ; i < n ; i ++ ) System . out . print ( s + 1 + " ▁ " ) ; }
int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = Math . max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = Math . max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + 2 * n - 5 ; }
void isEqualFactors ( int N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
int maxSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; }
int MaxTraceSub ( int mat [ ] [ ] ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . max ( trace , max_trace ) ; } } } return max_trace ; }
int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
int maxCandies ( int arr [ ] , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
long multiply ( long x , long n ) { return x << n ; }
int countDistinctCode ( String str ) { Set < String > codes = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) codes . add ( str . substring ( i , i + 2 ) ) ; return codes . size ( ) ; }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }
int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }
float hexadiagonal ( float a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }
void print_triplet ( int arr [ ] , int n ) { for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { System . out . print ( i - 1 + " ▁ " + i + " ▁ " + ( i + 1 ) ) ; return ; } } System . out . print ( - 1 ) ; }
void canBeReduced ( int x , int y ) { int maxi = Math . max ( x , y ) ; int mini = Math . min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) System . out . print ( " YES " + "NEW_LINE"); else System . out . print ( " NO " + "NEW_LINE"); }
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) { return - 1 ; } Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
void maxProductSum ( String str , int m ) { int n = str . length ( ) ; int maxProd = Integer . MIN_VALUE , maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str . charAt ( j ) - '0' ) ; sum = sum + ( str . charAt ( j ) - '0' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } System . out . println ( " Maximum ▁ Product ▁ = ▁ " + maxProd ) ; System . out . print ( " Maximum Sum = " + maxSum); }
int maxLenSubStr ( String s ) { if ( s . length ( ) < 3 ) return s . length ( ) ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) || s . charAt ( i ) != s . charAt ( i - 2 ) ) temp ++ ; else { ans = Math . max ( temp , ans ) ; temp = 2 ; } } ans = Math . max ( temp , ans ) ; return ans ; }
void printGMeans ( int A , int B , int N ) { float R = ( float ) Math . pow ( ( float ) ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( A * Math . pow ( R , i ) + " ▁ " ) ; }
int Maxlen ( int arr [ ] , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = Math . max ( ans , count ) ; } return ans ; }
float normal ( float m , float n ) { float N = ( float ) ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; }
void getPairs ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } System . out . print ( count ) ; }
int countEvenSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
int countWords ( String str ) { int state = OUT ; int wc = 0 ; int i = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == ' ▁ ' || str . charAt ( i ) == 'NEW_LINE' || str . charAt ( i ) == ' TABSYMBOL ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }
int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
void construct_Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( K * i + " ▁ " ) ; } }
void minSum ( int N ) { int ans = ( int ) Math . ceil ( 2 * Math . sqrt ( N + 1 ) ) ; System . out . println ( ans ) ; }
int concentric_Haxagon ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) / 2 ; }
int getValue ( int [ ] arr , int N ) { int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int min = arr [ i ] ; int max = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { min = Math . min ( arr [ j ] , min ) ; max = Math . max ( arr [ j ] , max ) ; dp [ i ] = Math . max ( dp [ i ] , max - min + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; }
int nthTerm ( int n ) { return 6 * ( int ) Math . pow ( n , 2 ) - 4 * n - 2 ; }
int minInsertionStepToSortArray ( int arr [ ] , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
boolean isIdentity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
int largestKSubmatrix ( int [ ] [ ] a ) { int [ ] [ ] dp = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }
int nobleInteger ( int arr [ ] ) { int size = arr . length ; for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }
int minCost ( String A , String B ) { int n = A . length ( ) ; int i = 0 ; int maxlen = 0 ; while ( i < n ) { int length = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( A . charAt ( i ) == B . charAt ( j ) ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = Math . max ( maxlen , length ) ; } return n - maxlen ; }
void equation_parabola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; float e1 = - 2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; System . out . println ( " equation ▁ of ▁ parabola ▁ is ▁ " + a1 + " ▁ x ^ 2 ▁ + ▁ " + b1 + " ▁ y ^ 2 ▁ + ▁ " + c1 + " ▁ x ▁ + ▁ " + d1 + " ▁ y ▁ + ▁ " + e1 + " ▁ xy ▁ + ▁ " + f1 + " ▁ = ▁ 0 . " ) ; }
int nthTerm ( int n ) { return 5 * ( int ) Math . pow ( n , 2 ) - 5 * n ; }
int findNthNonSquare ( int n ) { double x = ( double ) n ; double ans = x + Math . floor ( 0.5 + Math . sqrt ( x ) ) ; return ( int ) ans ; }
void isEqualFactors ( int N ) { int ev_count = 0 , od_count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count == od_count ) System . out . print ( " YES " + "NEW_LINE"); else System . out . print ( " NO " + "NEW_LINE"); }
long SubArraySum ( int arr [ ] , int n ) { long result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
int countsubarray ( int array [ ] , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
void oddDivisors ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int powerOfTwo = 2 ; int count = 0 ; while ( powerOfTwo <= arr [ i ] ) { count ++ ; powerOfTwo = 2 * powerOfTwo ; } System . out . print ( count + " ▁ " ) ; } return ; }
int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } System . out . println ( " Number ▁ of ▁ different ▁ bits ▁ : ▁ " + count ) ; }
int getMissingNo ( int a [ ] , int n ) { int total = 1 ; for ( int i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
void sumOfSubarrayProd ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } System . out . println ( ans ) ; }
void convert ( String str ) { int n = str . length ( ) ; String str1 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) str1 = str1 + ' _ ' ; else str1 = str1 + Character . toLowerCase ( str . charAt ( i ) ) ; } System . out . print ( str1 ) ; }
void perfectSquares ( float l , float r ) { int number = ( int ) Math . ceil ( Math . sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { System . out . print ( n2 + " ▁ " ) ; n2 = n2 + number ; number += 2 ; } }
float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
void printDistinct ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) != ' ▁ ' ) count [ ( int ) str . charAt ( i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ ( int ) str . charAt ( i ) ] == 1 ) System . out . print ( str . charAt ( i ) ) ; }
void reverse ( String str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str ) ; else { System . out . print ( str . charAt ( str . length ( ) - 1 ) ) ; reverse ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } }
int countZeros ( int x ) { int total_bits = sizeofInt * 8 ; int res = 0 ; while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) { x = ( x << 1 ) ; res ++ ; } return res ; }
int smallestOdd ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
boolean isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int minMergeCost ( int i , int j , int [ ] arr ) { if ( i == j ) return 0 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = true ; int x = dp [ i ] [ j ] ; x = Integer . MAX_VALUE ; int tot = 0 ; for ( int k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { x = Math . min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }
String compute ( String str , int n ) { String reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " ; int l = str . length ( ) ; String answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer = answer + str . charAt ( i ) ; for ( int i = n ; i < l ; i ++ ) answer = answer + reverseAlphabet . charAt ( str . charAt ( i ) - ' a ' ) ; return answer ; }
int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
float CubeVolume ( float d ) { float Volume ; Volume = ( float ) ( Math . sqrt ( 3 ) * Math . pow ( d , 3 ) ) / 9 ; return Volume ; }
void printRotatedString ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) System . out . print ( sb . charAt ( i + j ) ) ; System . out . println ( ) ; } }
boolean checkArrInStack ( Stack < Integer > s , int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( freq . containsKey ( arr [ i ] ) ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; else freq . put ( arr [ i ] , 1 ) ; while ( ! s . isEmpty ( ) ) { int poppedEle = s . peek ( ) ; s . pop ( ) ; if ( freq . containsKey ( poppedEle ) ) freq . put ( poppedEle , freq . get ( poppedEle ) - 1 ) ; } if ( freq . size ( ) == 0 ) return false ; return true ; }
void maxValueAtIndexK ( int N , int K , int M ) { int S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; int X = ( M + S1 + S2 ) / N ; System . out . println ( X ) ; }
float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; }
boolean flipsPossible ( int [ ] a , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }
void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) System . out . print ( i + " ▁ " ) ; }
int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; }
int geometricMean ( int n ) { return ( int ) Math . sqrt ( n ) ; }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; System . out . print ( ith_term + " , ▁ " ) ; } }
int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
boolean checkEvenPower ( long N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; }
int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
int maximumSum ( int [ ] A , int N , int K , int D ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) { int sum = 0 ; int c = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( i >> j & 1 ) != 0 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = Math . max ( ans , sum ) ; } return ans ; }
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
int distribution ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , n / 2 ) ; }
int nondecdigits ( int n ) { int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; boolean flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; }
boolean checkRectangles ( int [ ] arr , int n ) { boolean ans = true ; Arrays . sort ( arr ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }
boolean isKAlternating ( String s , int k ) { if ( s . length ( ) < k ) return false ; int checker = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int bitAtIndex = s . charAt ( i ) - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( int i = k ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i - k ) != s . charAt ( i ) ) return false ; return true ; }
int noOfTriangles ( int n ) { return ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
void printORSumforEachElement ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int req_sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { req_sum += ( arr [ i ] arr [ j ] ) ; } System . out . print ( req_sum + " ▁ " ) ; } }
boolean isCenteredOctadecagonal ( int N ) { double n = ( 9 + Math . sqrt ( 36 * N + 45 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
boolean isPossible ( int w , int h , int x , int y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }
String isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 3 * n - 5 ; }
int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; } return 2 * cnt ; }
int countPS ( String str ) { int N = str . length ( ) ; int [ ] [ ] cps = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( str . charAt ( i ) == str . charAt ( k ) ) { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; } else { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; }
String convert ( String s ) { int n = s . length ( ) ; String s1 = " " ; s1 = s1 + Character . toLowerCase ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ▁ ' && i < n ) { s1 = s1 + " ▁ " + Character . toLowerCase ( s . charAt ( i + 1 ) ) ; i ++ ; } else s1 = s1 + Character . toUpperCase ( s . charAt ( i ) ) ; } return s1 ; }
void divParts ( int N ) { if ( N % 2 == 0 ) System . out . println ( ( N / 2 ) - 1 ) ; else System . out . println ( ( N / 2 ) ) ; }
String sortString ( String str , int n ) { int i ; char [ ] arr = new char [ 26 ] ; String new_str = " " ; for ( i = 0 ; i < n ; i ++ ) ++ arr [ str . charAt ( i ) - ' a ' ] ; for ( i = 0 ; i < 26 ; i ++ ) while ( arr [ i ] -- > 0 ) { new_str += String . valueOf ( ( char ) ( i + ' a ' ) ) ; } return new_str ; }
void compute ( int [ ] query ) { int [ ] v = new int [ 100001 ] ; int [ ] dp = new int [ 100001 ] ; v [ 1 ] = 1 ; v [ 2 ] = 0 ; dp [ 1 ] = 0 ; dp [ 2 ] = 0 ; for ( int i = 3 ; i < 100001 ; i ++ ) { if ( i % 2 != 0 ) { if ( ( i / 2 ) % 2 == 0 ) { v [ i ] = 1 ; dp [ i ] = dp [ i - 1 ] ; } else { v [ i ] = v [ i / 2 ] + 1 ; dp [ i ] = dp [ i - 1 ] + v [ i ] - 1 ; } } else { v [ i ] = 0 ; dp [ i ] = dp [ i - 1 ] ; } } for ( int x : query ) System . out . print ( dp [ x ] + "NEW_LINE"); }
int number_of_ways ( int arr [ ] , int n , int k ) { if ( k == 1 ) return 1 ; int dp [ ] = new int [ k + 1 ] ; int i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }
boolean isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
double Avgdifference ( double arr [ ] , int N , int K ) { double min = 1000000 , max = - 1 ; for ( int i = 0 ; i <= N - K ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < K ; j ++ ) { sum += arr [ i + j ] ; } if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
boolean isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; }
boolean unique ( String s ) { Arrays . sort ( s . toCharArray ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { return false ; } } return true ; }
int maxArea ( int A [ ] , int len ) { int l = 0 ; int r = len - 1 ; int area = 0 ; while ( l < r ) { area = Math . max ( area , Math . min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; }
int countSquares ( int row , int column ) { int topLeft = Math . min ( row , column ) - 1 ; int bottomRight = 8 - Math . max ( row , column ) ; int topRight = Math . min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
int power ( int x , int y , int p ) { int res = 1 x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; }
float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; float r1 = r ; float h1 = h ; float V = ( float ) ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = Math . max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }
boolean isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; }
void countCountries ( int ans [ ] , int N ) { int total_countries = 0 , i = 0 ; boolean invalid = false ; while ( i < N ) { int curr_size = ans [ i ] ; int num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { System . out . print ( "Invalid AnswerNEW_LINE" ); return ; } else num -- ; i ++ ; } total_countries ++ ; } System . out . print ( " There ▁ are ▁ " + total_countries + " distinct companies in the group.NEW_LINE" ); }
double vol_tetra ( int side ) { double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }
boolean isicositetragonal ( int N ) { float n = ( float ) ( ( 10 + Math . sqrt ( 44 * N + 100 ) ) / 22 ) ; return ( n - ( int ) n ) == 0 ; }
int squareSum ( int n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
String checkNumber ( int N ) { int temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp /= 1000 ; else if ( temp % 100 == 14 ) temp /= 100 ; else if ( temp % 10 == 1 ) temp /= 10 ; else { return " NO " ; } } return " YES " ; }
long center_pentadecagonal_num ( long n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
long cntEvenSumPairs ( long X , long Y ) { long cntXEvenNums = X / 2 ; long cntXOddNums = ( X + 1 ) / 2 ; long cntYEvenNums = Y / 2 ; long cntYOddNums = ( Y + 1 ) / 2 ; long cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; }
void printRLE ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int count = 1 ; while ( i + 1 < s . length ( ) && s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; count ++ ; } System . out . print ( s . charAt ( i ) + " " + count + " ▁ " ) ; } System . out . println ( ) ; }
String getCount ( int N ) { if ( N % 2 == 1 ) return "0" ; String result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
boolean isKPartitionPossible ( int arr [ ] , int N , int K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; int target = sum / K ; int [ ] dp = new int [ ( 1 << 15 ) ] ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == - 1 ) continue ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( ( mask & ( 1 << i ) ) == 0 ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; }
void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) System . out . println ( "2 ▁ solutions " ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) System . out . println ( "1 ▁ solution " ) ; else System . out . println ( " No ▁ solutions " ) ; }
int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int minOperations ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int maxFreq = Integer . MIN_VALUE ; maxFreq = Collections . max ( mp . entrySet ( ) , Comparator . comparingInt ( Map . Entry :: getKey ) ) . getValue ( ) ; return ( n - maxFreq ) ; }
float slope ( float x1 , float y1 , float x2 , float y2 ) { if ( x1 == x2 ) return Integer . MAX_VALUE ; return ( y2 - y1 ) / ( x2 - x1 ) ; }
int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; }
int smallestMaximum ( int N , int K ) { int sum = ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return ( sum / N ) + 1 ; else return sum / N ; }
int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } }
int countDigit ( int n ) { boolean prime [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) prime [ i ] = false ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] == true ) count ++ ; } return count ; }
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
void make_sequence ( int N ) { int [ ] arr = new int [ N + 1 ] ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . pow ( ( a * Math . sqrt ( 3 ) ) / ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; }
int findBucketNo ( int p ) { return ( int ) Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
int min_cost ( String S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char c : S . toCharArray ( ) ) if ( c == ' ▁ ' ) count ++ ; int n = S . length ( ) - count ; if ( n == 1 ) return cost ; for ( char in : S . toCharArray ( ) ) { if ( in != ' ▁ ' ) { if ( B != 0 ) { cost += Math . min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }
float sph ( float r , float h ) { if ( r < 0 && h < 0 ) return - 1 ; float R = r ; return R ; }
int printTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) System . out . println ( arr [ i ] + " , ▁ " + arr [ j ] + " , ▁ " + arr [ k ] ) ; } } return 0 ; }
void translate ( char str [ ] ) { for ( int i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; int j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ▁ ' ; } } return ; }
int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
int largestArea ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int end = 0 , start = 0 , i = 0 , j = 0 ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr1 ) ; while ( i < n && j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 start == 0 ) return 0 ; else return ( end - start ) ; }
int xorPairCount ( int arr [ ] , int n , int x ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( x ^ arr [ i ] ) && ( x ^ arr [ i ] ) == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { result ++ ; } s . add ( arr [ i ] ) ; } return result ; }
void perfectSquares ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( Math . sqrt ( i ) == ( int ) Math . sqrt ( i ) ) System . out . print ( i + " ▁ " ) ; } }
int getCount ( String a , String b ) { if ( b . length ( ) % a . length ( ) != 0 ) return - 1 ; int count = b . length ( ) / a . length ( ) ; String str = " " ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str . equals ( b ) ) return count ; return - 1 ; }
boolean areVowelsInOrder ( String s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' a ' || s . charAt ( i ) == ' e ' || s . charAt ( i ) == ' i ' || s . charAt ( i ) == ' o ' || s . charAt ( i ) == ' u ' ) { if ( s . charAt ( i ) < c ) return false ; else { c = s . charAt ( i ) ; } } } return true ; }
int printNthElement ( int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }
int countSub ( String str ) { int n = ( int ) str . length ( ) ; int ans = 0 ; int [ ] cnt = new int [ 26 ] ; int i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str . charAt ( j ) - ' a ' ] == 0 ) ) { cnt [ str . charAt ( j ) - ' a ' ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str . charAt ( i ) - ' a ' ] -- ; i ++ ; } } return ans ; }
int bitwiseOrTillN ( int n ) { if ( n < 2 ) return 0 ; int bitCount = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( int ) Math . pow ( 2 , bitCount ) - 2 ; }
float largestCube ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 2 * r ) / ( float ) Math . sqrt ( 3 ) ; return a ; }
void performQueries ( int n , int q , int k , int [ ] arr , int [ ] [ ] query ) { for ( int i = 1 ; i <= q ; i ++ ) { int count = 0 ; if ( query [ i - 1 ] [ 0 ] == 1 ) { for ( int j = query [ i - 1 ] [ 1 ] ; j <= query [ i - 1 ] [ 2 ] ; j ++ ) { if ( arr [ j ] == k ) count ++ ; } System . out . print ( count + "NEW_LINE"); } else { arr [ query [ i - 1 ] [ 1 ] ] = query [ i - 1 ] [ 2 ] ; } } }
boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; }
float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float area = ( l * b ) / 2 ; return area ; }
int kthNum ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; }
double area ( double a , double b , double c ) { double d = Math . abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
int cntSubarr ( int arr [ ] , int N ) { int res = 0 ; int prefixXor = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }
int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }
void find_set ( int n ) { if ( n <= 2 ) { System . out . println ( " - 1" ) ; return ; } int sum1 = ( n * ( n - 1 ) ) / 2 ; int sum2 = n ; System . out . println ( sum1 + " ▁ " + sum2 ) ; }
boolean uniqueCharacters ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int bitAtIndex = str . charAt ( i ) - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) return false ; checker = checker | ( 1 << bitAtIndex ) ; } return true ; }
int breakEvenPoint ( int exp1 , int S , int M ) { double earn = S - M ; double exp = exp1 ; double res = Math . ceil ( exp / earn ) ; int res1 = ( int ) res ; return res1 ; }
int closetAND ( int arr [ ] , int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; }
int longestPalSubstr ( String str ) { int n = str . length ( ) ; int maxLength = 1 , start = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = i ; j < str . length ( ) ; j ++ ) { int flag = 1 ; for ( int k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str . charAt ( i + k ) != str . charAt ( j - k ) ) flag = 0 ; if ( flag != 0 && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }
int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; }
int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; }
int getNumToAdd ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; int numToAdd = - 1 ; boolean numAdded = false ; for ( int i = 2 ; i < n ; i ++ ) { int diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; }
int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
boolean CheckArray ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) System . out . print ( i + " ▁ " ) ; }
long nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m % 2 != 0 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; }
int Nth_Term ( int n ) { return ( int ) ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int minDiffSubArray ( int arr [ ] , int n ) { int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) total_sum += arr [ i ] ; int prefix_sum = 0 ; int minDiff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix_sum += arr [ i ] ; int diff = Math . abs ( ( total_sum - prefix_sum ) - prefix_sum ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
void countOfNumbers ( int N ) { int ans = 1 ; for ( int index = 1 ; index <= N ; ++ index ) { int choices = 0 ; for ( int digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * choices ) % mod ; } System . out . println ( ans ) ; }
int maxSum ( int arr [ ] , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
void printMultiples ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { System . out . print ( ( i * j ) + " ▁ " ) ; } System . out . println ( ) ; } }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; System . out . println ( edges_max_secondary + 3 ) ; } else System . out . println ( " Not ▁ Possible " ) ; }
boolean check ( int a [ ] , int n ) { boolean flag = false ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = true ; } if ( flag ) return false ; else return true ; }
int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
int isSumDivides ( int N ) { int temp = N ; int sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
void possibleOrNot ( long a1 , long a2 , long b1 , long b2 , long c1 , long c2 ) { long dis1 = ( long ) Math . pow ( b1 - a1 , 2 ) + ( long ) Math . pow ( b2 - a2 , 2 ) ; long dis2 = ( long ) Math . pow ( c1 - b1 , 2 ) + ( long ) Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) System . out . print ( " No " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . print ( " No " ) ; else System . out . print ( " Yes " ) ; }
void numberOfGates ( String s ) { int N = s . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < ( int ) s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' . ' || s . charAt ( i ) == ' + ' || s . charAt ( i ) == '1' ) { ans ++ ; } } System . out . println ( ans ) ; }
boolean areSumSame ( int a [ ] [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
int minRemoval ( String str ) { int hash [ ] = new int [ MAX_CHAR ] ; Arrays . fill ( hash , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) hash [ str . charAt ( i ) - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( hash [ i ] % 2 == 1 ) count ++ ; return ( count == 0 ) ? 0 : count - 1 ; }
String areBookingsPossible ( int [ ] A , int [ ] B , int K ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( i + K < A . length && A [ i + K ] < B [ i ] ) { return " No " ; } } return " Yes " ; }
int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . pow ( b , 2 ) ; }
void countPairsWithDiffK ( int arr [ ] , int N , int K ) { int [ ] vis = new int [ N ] ; Arrays . fill ( vis , 0 ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( vis [ i ] == 1 ) continue ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( vis [ j ] == 1 ) continue ; if ( Math . abs ( arr [ i ] - arr [ j ] ) >= K ) { count ++ ; vis [ i ] = 1 ; vis [ j ] = 1 ; break ; } } } System . out . print ( count ) ; }
int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
void checkPoint ( int radius , int x , int y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; double polarradius = Math . sqrt ( x * x + y * y ) ; double Angle = Math . atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) System . out . print ( " Point " + " ( " + x + " , " + y + " ) " + " exist in the circle sectorNEW_LINE"); else System . out . print ( " Point " + " ( " + x + " , " + y + " ) " + " exist in the circle sectorNEW_LINE"); }
void addAP ( int A [ ] , int Q , int [ ] [ ] operations ) { for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j ] [ 0 ] , R = operations [ j ] [ 1 ] , a = operations [ j ] [ 2 ] , d = operations [ j ] [ 3 ] ; int curr = a ; for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr ; curr += d ; } } for ( int i = 0 ; i < 4 ; ++ i ) System . out . print ( A [ i ] + " ▁ " ) ; }
int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
boolean SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }
void getBuckets ( int [ ] arr , int N ) { int availableWater = N * ( N - 1 ) / 2 ; Arrays . sort ( arr ) ; int i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } System . out . println ( i - 1 ) ; }
void constructXORArray ( int A [ ] , int n , int K ) { int [ ] B = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) B [ i ] = A [ i ] ^ K ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( B [ i ] + " ▁ " ) ; System . out . println ( ) ; }
int countElements ( int p [ ] , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }
int CountTriangles ( int n ) { int curr = 1 ; int Tri_count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { Tri_count = ( curr * 3 ) + 2 ; curr = Tri_count ; } return Tri_count ; }
int findPermutation ( Set < Integer > arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! arr . contains ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . add ( i ) ; res += findPermutation ( arr , N ) ; arr . remove ( i ) ; } } } return res ; }
int intersection ( int n ) { return n * ( n - 1 ) ; }
void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; System . out . print ( ( int ) Median ) ; }
void find_winner ( String str , int n ) { String str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str . charAt ( i ) ; } else { str2 += str . charAt ( i ) ; } } char a [ ] = str1 . toCharArray ( ) ; Arrays . sort ( a ) ; char b [ ] = str2 . toCharArray ( ) ; Arrays . sort ( b ) ; str1 = new String ( a ) ; str2 = new String ( b ) ; if ( str1 . compareTo ( str2 ) < 0 ) System . out . print ( " A " ) ; else if ( str1 . compareTo ( str2 ) > 0 ) System . out . print ( " B " ) ; else System . out . print ( " Tie " ) ; }
boolean checkIndices ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ ] [ ] = new int [ R ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } System . out . println ( ans ) ; } }
int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; Arrays . sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; }
int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
int findMaxPairs ( int a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { if ( Math . abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }
void commonSubstring ( String s ) { int n = s . length ( ) ; int i = 0 ; int j = n - 1 ; String ans = " " ; while ( j >= 0 ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { ans += s . charAt ( i ) ; i ++ ; j -- ; } else { break ; } } if ( ans . length ( ) == 0 ) System . out . println ( " False " ) ; else { System . out . println ( " True ▁ " ) ; System . out . println ( ans ) ; } }
int countTriplets ( int n , int sum ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) ans ++ ; } } return ans ; }
int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
int countOddSum ( int ar [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
void solve ( int n ) { int n_2 = n / 2 ; String den ; den = "1" ; while ( n_2 -- > 0 ) den += '0' ; System . out . println ( 1 + " / " + den ) ; }
int findNthDigit ( int p , int q , int N ) { int res = 0 ; while ( N > 0 ) { N -- ; p *= 10 ; res = p / q ; p %= q ; } return res ; }
int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
void isKthBitSet ( int n , int k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) System . out . print ( " SET " ) ; else System . out . print ( " NOT ▁ SET " ) ; }
int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
void divide ( int n , int m ) { System . out . println ( " Remainder ▁ = ▁ " + ( ( n ) & ( m - 1 ) ) ) ; System . out . println ( " Quotient ▁ = ▁ " + ( n >> ( int ) ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; }
int subString ( String s , int n ) { Map < Integer , Integer > hash = new HashMap < > ( ) ; hash . put ( 0 , 1 ) ; int pre = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << ( int ) ( s . charAt ( i ) - 97 ) ) ; count += hash . getOrDefault ( pre , 0 ) ; hash . put ( pre , hash . getOrDefault ( pre , 0 ) + 1 ) ; } return count ; }
int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
int binarySearch ( String [ ] arr , String x ) { int l = 0 , r = arr . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; int res = x . compareTo ( arr [ m ] ) ; if ( res == 0 ) return m ; if ( res > 0 ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) System . out . print ( i + " ▁ " ) ; }
int positionAfterKJumps ( int X , int Y , int K ) { int addY = Y * ( K / 2 ) ; int reduceX = - 1 * X * ( K / 2 + K % 2 ) ; return addY + reduceX ; }
void printAlter ( int [ ] arr , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex += 2 ) { System . out . print ( arr [ currIndex ] + " ▁ " ) ; } }
char maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } cur_count = 1 ; } } return res ; }
long powerNumbers ( int n ) { HashSet < Long > v = new HashSet < Long > ( ) ; for ( long i = 2 ; i * i * i <= n ; i ++ ) { long j = i * i ; while ( j * i <= n ) { j *= i ; long s = ( long ) Math . sqrt ( j ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size ( ) + ( long ) Math . sqrt ( n ) ; }
int sumOfTermsInNthRow ( int n ) { int sum = ( int ) ( n * ( 2 * pow ( n , 2 ) + 1 ) ) ; return sum ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; }
String isDivisible ( int n ) { int temp = n ; while ( n > 0 ) { int k = n % 10 ; if ( temp % k == 0 ) { return " YES " ; } n /= 10 ; } return " NO " ; }
int minDiff ( int [ ] A , int K ) { Arrays . sort ( A ) ; int n = A . length ; if ( n <= K ) return 0 ; int mindiff = A [ n - 1 ] - A [ 0 ] ; if ( K == 0 ) return mindiff ; for ( int i = 0 , j = n - 1 - K ; j < n ; ) { mindiff = Math . min ( mindiff , A [ j ] - A [ i ] ) ; i ++ ; j ++ ; } return mindiff ; }
void addASCII ( char [ ] S , char [ ] N ) { for ( int i = 0 ; i < S . length ; i ++ ) { int a = ( int ) ( N [ i ] ) - '0' ; int b = ( int ) ( S [ i ] ) + a ; if ( b > 122 ) b -= 26 ; S [ i ] = ( char ) ( b ) ; } System . out . print ( S ) ; }
void maxSum ( int [ ] [ ] arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = Math . max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = Math . max ( r2 , temp + arr [ 1 ] [ i ] ) ; } System . out . println ( Math . max ( r1 , r2 ) ) ; }
void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { System . out . print ( " a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b ) ; } else System . out . println ( - 1 ) ; }
int minCountOfNumbers ( int N ) { int k = N % 10 ; int z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else return - 1 ; }
int MinimumCost ( int A [ ] , int B [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = Math . min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = Math . min ( mod_B , B [ i ] - mod_B ) ; totalCost += Math . min ( totalCost_A , totalCost_B ) ; } return totalCost ; }
void checkWinner ( int N , int K ) { if ( N % ( K + 1 ) > 0 ) { System . out . print ( " A " ) ; } else { System . out . print ( " B " ) ; } }
void findNumbers ( String s ) { int n = s . length ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s . charAt ( left ) == s . charAt ( right ) ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; System . out . println ( result ) ; }
float Area ( float a , float b ) { if ( a < 0 && b < 0 ) return - 1 ; float h = ( float ) Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; float A = ( float ) ( 0.70477 * Math . pow ( h , 2 ) ) ; return A ; }
int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; }
void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; { System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
void main ( String [ ] args ) { String Str = " IDID " ; int N = Str . length ( ) ; int [ ] ptr = DiStirngMatch ( Str ) ; for ( int i = 0 ; i <= N ; i ++ ) System . out . print ( ptr [ i ] + " ▁ " ) ; } }
int maximizeExpression ( int a , int b ) { int result = a ; for ( int bit = MAX - 1 ; bit >= 0 ; bit -- ) { int bitOfD = 1 << bit ; int x = b & bitOfD ; if ( x == bitOfD ) { int y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }
int countTriplets ( int [ ] A ) { int cnt = 0 ; HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ; for ( int a : A ) for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; } for ( int a : A ) for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) ) if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ; return cnt ; }
int countNums ( int n , int x , int y ) { boolean [ ] arr = new boolean [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
int FindMaxS ( int X , int Y , int Z , int n , int A [ ] , int B [ ] , int C [ ] ) { if ( X < 0 Y < 0 Z < 0 ) return Integer . MIN_VALUE ; if ( n < 0 ) return 0 ; int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = Math . max ( ch , Math . max ( ca , Math . max ( co , no ) ) ) ; return maximum ; }
boolean isCubeSum ( int n ) { for ( int i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }
int next ( int [ ] arr , int target ) { int start = 0 , end = arr . length - 1 ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }
int countSubStr ( String str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) ans += ( i + 1 ) ; } return ans ; }
void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( div [ i ] + " ▁ " ) ; }
float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " ▁ " ) ; square = square + odd ; odd = odd + 2 ; } }
void printRLE ( String str ) { int n = str . length ( ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) { count ++ } else { System . out . print ( str . charAt ( i ) ) ; System . out . print ( count ) ; count = 1 } System . out . print ( str . charAt ( i ) ) ; System . out . print ( count ) ; } }
void FindRank ( int arr [ ] , int length ) { System . out . print ( "1" + " ▁ " ) ; for ( int i = 1 ; i < arr . length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } System . out . print ( rank + " ▁ " ) ; } }
String removeDuplicates ( String S ) { String ans = " " ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( ans . isEmpty ( ) || ans . charAt ( ans . length ( ) - 1 ) != S . charAt ( i ) ) ans += S . charAt ( i ) ; else if ( ans . charAt ( ans . length ( ) - 1 ) == S . charAt ( i ) ) ans = ans . substring ( 0 , ans . length ( ) - 1 ) ; } return ans ; }
int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
void foot ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; DecimalFormat form = new DecimalFormat ( "0.0" ) ; System . out . print ( " ▁ x2 ▁ = ▁ " + form . format ( x2 ) ) ; System . out . print ( " ▁ y2 ▁ = ▁ " + form . format ( y2 ) ) ; System . out . print ( " ▁ z2 ▁ = ▁ " + form . format ( z2 ) ) ; }
void isPerfectSquare ( int x ) { int sr = ( int ) Math . sqrt ( x ) ; if ( sr * sr == x ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
boolean areChractersUnique ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
void lengtang ( double r1 , double r2 , double d ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ direct " + " ▁ common ▁ tangent ▁ is ▁ " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }
int maxGCD ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
void countNo ( int A , int N , int L , int R ) { int ans = L - 1 + N + ( int ) Math . floor ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } System . out . println ( ans ) ; }
float median ( int a , int b , int c ) { float n = ( float ) ( Math . sqrt ( 2 * b * b + 2 * c * c - a * a ) / 2 ) ; return n ; }
boolean isPossible ( int A , int B ) { return ( A - B > 1 ) ; }
void pendulumArrangement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int op [ ] = new int [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; System . out . println ( " Pendulum ▁ arrangement : " ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( op [ i ] + " ▁ " ) ; System . out . println ( ) ; }
int andSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; System . out . println ( ratio ) ; }
int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
void minimumTriangleArea ( int a , int b ) { int area = a * b ; System . out . println ( area ) ; }
int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
int cntRect ( int points [ ] [ ] , int N , int rectangle [ ] [ ] ) { HashSet < Integer > cntHor = new HashSet < > ( ) ; HashSet < Integer > cntVer = new HashSet < > ( ) ; cntHor . add ( 0 ) ; cntVer . add ( 0 ) ; cntHor . add ( rectangle [ 3 ] [ 0 ] ) ; cntVer . add ( rectangle [ 3 ] [ 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . add ( points [ i ] [ 0 ] ) ; cntVer . add ( points [ i ] [ 1 ] ) ; } return ( cntHor . size ( ) - 1 ) * ( cntVer . size ( ) - 1 ) ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int sum = 0 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += i ; if ( sum <= K ) res ++ ; else break ; } return res ; }
void preprocess ( int list [ ] ) { ways [ 0 ] [ 8 ] [ 8 ] = 1 ; for ( int N = 1 ; N <= 14 ; N ++ ) { for ( int i = 1 ; i < depth ; i ++ ) { for ( int j = 1 ; j < depth ; j ++ ) { ways [ N ] [ i ] [ j ] = ways [ N - 1 ] [ i ] [ j + 1 ] + ways [ N - 1 ] [ i ] [ j - 1 ] + ways [ N - 1 ] [ i + 1 ] [ j ] + ways [ N - 1 ] [ i - 1 ] [ j ] + ways [ N - 1 ] [ i + 1 ] [ j - 1 ] + ways [ N - 1 ] [ i - 1 ] [ j + 1 ] ; } } list [ N ] = ways [ N ] [ 8 ] [ 8 ] ; } }
boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
String sumBaseB ( String a , String b , int base ) { int len_a , len_b ; len_a = a . length ( ) ; len_b = b . length ( ) ; String sum , s ; s = " " ; sum = " " ; int diff ; diff = Math . abs ( len_a - len_b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len_a < len_b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = Math . max ( len_a , len_b ) - 1 ; i > - 1 ; i -- ) { curr = carry + ( a . charAt ( i ) - '0' ) + ( b . charAt ( i ) - '0' ) ; carry = curr / base ; curr = curr % base ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; }
String GeberateDefangIP ( String str ) { String defangIP = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c == ' . ' ) { defangIP += " [ . ] " ; } else { defangIP += c ; } } return defangIP ; }
int maxWeight ( int arr [ ] , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; }
int maximumSubarrays ( int arr [ ] , int N , int target ) { int ans = 0 ; int availIdx = - 1 ; int cur_sum = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; mp . put ( 0 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { cur_sum += arr [ i ] ; if ( mp . containsKey ( cur_sum - target ) && mp . get ( cur_sum - target ) >= availIdx ) { ans ++ ; availIdx = i ; } mp . put ( cur_sum , i ) ; } return ans ; }
boolean check ( int arr [ ] , int n ) { int count = 0 ; int index = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) { count ++ ; index = i ; } } if ( count > 1 ) return false ; if ( count == 0 ) return true ; if ( index == n - 1 index == 1 ) return true ; if ( arr [ index - 1 ] < arr [ index + 1 ] ) return true ; if ( index - 2 >= 0 && arr [ index - 2 ] < arr [ index ] ) return true ; if ( index < 0 ) return true ; return false ; }
float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
void maxSumAfterKReverse ( Integer arr [ ] , int K , int N ) { int sum = Integer . MIN_VALUE ; if ( K % 2 != 0 ) Collections . reverse ( Arrays . asList ( arr ) ) ; int currsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = Math . max ( sum , currsum ) ; } System . out . print ( sum ) ; }
void generateLetters ( String S , int P , HashMap < Character , Character > M ) { if ( P == S . length ( ) ) { System . out . println ( S ) ; return ; } generateLetters ( S , P + 1 , M ) ; S = S . substring ( 0 , P ) + M . get ( S . charAt ( P ) ) + S . substring ( P + 1 ) ; generateLetters ( S , P + 1 , M ) ; return ; }
int previousFibonacci ( int n ) { double a = n / ( ( 1 + Math . sqrt ( 5 ) ) / 2.0 ) ; return ( int ) Math . round ( a ) ; }
void parallel ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
int solve ( int N , int M , int cp [ ] , int sp [ ] ) { Integer [ ] profit = new Integer [ N ] ; for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; Arrays . sort ( profit , Collections . reverseOrder ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
int minLength ( String S ) { Stack < Character > st = new Stack < > ( ) ; for ( char ch : S . toCharArray ( ) ) { if ( st . isEmpty ( ) ) st . push ( ch ) ; else { char top = st . peek ( ) ; if ( Math . abs ( ch - top ) == 1 ) st . pop ( ) ; else { st . push ( ch ) ; } } } return st . size ( ) ; }
int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
int DecreasingArray ( int a [ ] , int n ) { int sum = 0 , dif = 0 ; PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! pq . isEmpty ( ) && pq . element ( ) < a [ i ] ) { dif = a [ i ] - pq . element ( ) ; sum += dif ; pq . remove ( ) ; } pq . add ( a [ i ] ) ; } return sum ; }
int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; }
void minOpsToTurnArrToZero ( int [ ] arr , int N ) { Set < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . contains ( arr [ i ] ) arr [ i ] == 0 ) { continue ; } else { st . add ( arr [ i ] ) ; } } System . out . println ( st . size ( ) ) ; }
int countDistinctSums ( int N , int L , int R ) { int minSum = L * N ; int maxSum = R * N ; return maxSum - minSum + 1 ; }
void solve ( int A , int B ) { double p = B / 2.0 ; double M = Math . ceil ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; double Q = Math . ceil ( A * A + 4 * p * p ) ; System . out . println ( M + " ▁ " + N + " ▁ " + O + " ▁ " + Q ) ; }
int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; }
void findAandB ( double N ) { if ( N == 1 ) { System . out . print ( " No " ) ; return ; } double a = N * N / ( N - 1 ) ; double b = a / N ; System . out . print ( " a ▁ = ▁ " + a + "NEW_LINE"); System . out . print ( " b ▁ = ▁ " + b + "NEW_LINE"); }
void highestPowerOfTwo ( int num ) { String s = Integer . toString ( num ) ; for ( int i = 0 ; i < ( int ) s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' ) { System . out . print ( "0" ) ; continue ; } int lg = ( int ) ( Math . log ( s . charAt ( i ) - '0' ) / Math . log ( 2 ) ) ; int p = ( int ) Math . pow ( 2 , lg ) ; System . out . print ( ( char ) ( p + 48 ) ) ; } }
int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }
int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
String checkEvenPower ( int n ) { int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int value = ( int ) Math . pow ( 2 , mid ) ; if ( value == n ) { if ( mid % 2 == 1 ) return " No " ; else return " Yes " ; } else if ( value < n ) low = mid + 1 ; else high = mid - 1 ; } return " No " ; }
long product ( int [ ] arr ) { double occurrence = Math . pow ( 2 , arr . length - 1 ) ; double product = 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { product *= Math . pow ( arr [ i ] , occurrence ) ; } return ( long ) product ; }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
void genSequence ( int n , int val ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int x = i ^ ( i >> 1 ) ^ val ; System . out . print ( x + " ▁ " ) ; } }
void minMoves ( int arr [ ] , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; System . out . print ( moves ) ; }
int count_triangles ( int a , int b , int c , int d ) { int ans = 0 ; for ( int x = a ; x <= b ; ++ x ) { int num_greater_than_d = Math . max ( d , c + x ) - Math . max ( d , b + x - 1 ) ; ans += num_greater_than_d * ( d - c + 1 ) ; int r = Math . min ( Math . max ( c , c + x ) , d ) - c ; int l = Math . min ( Math . max ( c , b + x - 1 ) , d ) - c ; int x1 = ( r * ( r + 1 ) ) / 2 ; int x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; }
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
void printCollatz ( int n ) { while ( n != 1 ) { System . out . print ( n + " ▁ " ) ; if ( ( n & 1 ) == 1 ) n = 3 * n + 1 ; else n = n / 2 ; } System . out . print ( n ) ; }
int MinCost ( int days [ ] , int cost [ ] , int N ) { int size = days [ N - 1 ] + 1 ; int [ ] dp = new int [ size ] ; dp [ size - 1 ] = Math . min ( cost [ 0 ] , Math . min ( cost [ 1 ] , cost [ 2 ] ) ) ; int ptr = N - 2 ; for ( int i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { int val1 = dp [ i + 1 ] + cost [ 0 ] ; int val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; int val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = Math . min ( val1 , Math . min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }
int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
boolean isTrimorphic ( int N ) { int cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N /= 10 ; cube /= 10 ; } return true ; }
void checkValidPolygon ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
void find ( int N ) { int T , F , O ; F = ( int ) ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = ( int ) Math . floor ( ( N - 5 * F - O ) / 2 ) ; System . out . println ( " Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ " + F ) ; System . out . println ( " Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ " + T ) ; System . out . println ( " Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ " + O ) ; }
boolean powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
int longOddEvenIncSeq ( int arr [ ] , int n ) { int [ ] lioes = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
void countString ( String S ) { int count = 0 ; for ( char it : S . toCharArray ( ) ) { if ( it == '0' && count > 0 ) { count -- ; } else { count ++ ; } } System . out . print ( ( 1 << count ) - 1 ) ; }
double Area_of_Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * Math . sqrt ( x ) ; return area ; }
int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
long numbers ( int n ) { return ( long ) ( Math . pow ( 2 , n + 1 ) ) - 2 ; }
int maxRightmostElement ( int N , int k , int p , int arr [ ] ) { int ans = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int d = Math . min ( arr [ i ] / p , k / ( N - 1 - i ) ) ; k -= d * ( N - 1 - i ) ; ans += d * p ; } return ans ; }
int findFlips ( String str , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return res / 2 ; }
int items ( int n , int a [ ] ) { Arrays . sort ( a ) ; int z = a [ n - 1 ] ; int x = 1 ; int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }
int submatrixXor ( int [ ] [ ] arr ) { int n = 3 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + n - 2 ; }
int findLen ( int arr [ ] , int n , int m ) { Vector < Integer > filter = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . add ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_or = filter . get ( 0 ) ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_or |= filter . get ( i ) ; if ( c_or == m ) return filter . size ( ) ; return 0 ; }
double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( - 1 * b ) / a ; double rootProduct = ( double ) e / a ; return Math . abs ( rootSum - rootProduct ) ; }
float geometricMean ( int arr [ ] , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = ( float ) Math . pow ( product , ( float ) 1 / n ) ; return gm ; }
int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
double countNumbers ( int N ) { return ( Math . pow ( 10 , N ) - 1 ) - ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; }
int eggDrop ( int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; }
void minimumCost ( String a , String b ) { int fre1 [ ] = new int [ 256 ] ; int fre2 [ ] = new int [ 256 ] ; for ( char c : a . toCharArray ( ) ) fre1 [ ( int ) ( c ) ] ++ ; for ( char c : b . toCharArray ( ) ) fre2 [ ( int ) ( c ) ] ++ ; int mincost = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { mincost += Math . abs ( fre1 [ i ] - fre2 [ i ] ) ; } System . out . println ( mincost ) ; }
int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ; }
void Vertices ( int x , int y ) { int val = Math . abs ( x ) + Math . abs ( y ) ; System . out . print ( val * ( x < 0 ? - 1 : 1 ) + " ▁ 0 ▁ " ) ; System . out . print ( "0 ▁ " + val * ( y < 0 ? - 1 : 1 ) ) ; }
int minServerLoads ( int n , int [ ] servers ) { int totalLoad = 0 ; for ( int i = 0 ; i < servers . length ; i ++ ) totalLoad += servers [ i ] ; int requiredLoad = totalLoad / 2 ; int dp [ ] [ ] = new int [ n + 1 ] [ requiredLoad + 1 ] ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n ] [ requiredLoad ] ; }
void countSubString ( String s ) { int answer = 0 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; m . put ( 0 , 1 ) ; int x = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { x ^= 1 << ( s . charAt ( j ) - ' a ' ) ; answer += m . containsKey ( x ) ? m . get ( x ) : 0 ; for ( int i = 0 ; i < 26 ; ++ i ) { answer += m . containsKey ( x ^ ( 1 << i ) ) ? m . get ( x ^ ( 1 << i ) ) : 0 ; } if ( m . containsKey ( x ) ) m . put ( x , m . get ( x ) + 1 ) ; else m . put ( x , 1 ) ; } System . out . print ( answer ) ; }
String smallest ( String s ) { int l = s . length ( ) ; String ans = " " ; for ( int i = 0 ; i < l - 1 ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i + 1 ) ) { for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { ans += s . charAt ( j ) ; } } return ans ; } } ans = s . substring ( 0 , l - 1 ) ; return ans ; }
void digit_product_Sum ( int N ) { int a [ ] = new int [ N + 1 ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
boolean canBeBalanced ( String s , int n ) { if ( n % 2 == 1 ) return false ; String k = " ( " ; k += s + " ) " ; Vector < String > d = new Vector < > ( ) ; for ( int i = 0 ; i < k . length ( ) ; i ++ ) { if ( k . charAt ( i ) == ' ( ' ) d . add ( " ( " ) ; else { if ( d . size ( ) != 0 ) d . remove ( d . size ( ) - 1 ) ; else return false ; } } if ( d . isEmpty ( ) ) return true ; return false ; }
void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) System . out . println ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ identical " ) ; else System . out . println ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ not ▁ identical " ) ; }
String search ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return " Found " ; int backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( int i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " Found " ; return " Not ▁ Found " ; } } }
int minIndex ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }
float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int minSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n != 0 ; n = n >> 1 ) inv ^= n ; return inv ; }
int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; }
int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1 ; } return min ; }
void printCoins ( int arr [ ] , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) System . out . print ( arr [ i ] + " ▁ " ) ; }
int MaximumSum ( int a [ ] , int b [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , Math . max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) ; } else { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , b [ i ] ) ; } } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
int nthTerm ( int n ) { int d = 2 ; int a1 = 0 ; int An = a1 + ( n - 1 ) * d ; return ( int ) Math . pow ( An , 3 ) ; }
void middlesum ( int mat [ ] [ ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; System . out . println ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; System . out . println ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " + col_sum ) ; }
long count ( int N , int K , int R ) { long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
int countSquareMatrices ( int a [ ] [ ] , int N , int M ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] == 0 ) continue ; a [ i ] [ j ] = Math . min ( Math . min ( a [ i - 1 ] [ j ] , a [ i ] [ j - 1 ] ) , a [ i - 1 ] [ j - 1 ] ) + 1 ; } } for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) count += a [ i ] [ j ] ; return count ; }
float Time ( float arr [ ] , int n , float Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; }
boolean isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; }
void amendSentence ( String sstr ) { char [ ] str = sstr . toCharArray ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { str [ i ] = ( char ) ( str [ i ] + 32 ) ; if ( i != 0 ) System . out . print ( " ▁ " ) ; System . out . print ( str [ i ] ) ; } else System . out . print ( str [ i ] ) ; } }
int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) System . out . print ( i + " ▁ " ) ; System . out . print ( " ▁ 0 ▁ " ) ; }
int maximumSum ( int arr [ ] , int N ) { int Sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }
int longestSubsequence ( String s ) { int n = s . length ( ) ; int answer = 0 ; char prev = ' - ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( prev != s . charAt ( i ) ) { prev = s . charAt ( i ) ; answer ++ ; } } return answer ; }
String printSequence ( String arr [ ] , String input ) { String output = " " ; int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input . charAt ( i ) == ' ▁ ' ) output = output + "0" ; else { int position = input . charAt ( i ) - ' A ' ; output = output + arr [ position ] ; } } return output ; }
int deleteElement ( int A [ ] , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
void BalancedNumber ( String s ) { int Leftsum = 0 ; int Rightsum = 0 ; for ( int i = 0 ; i < s . length ( ) / 2 ; i ++ ) { Leftsum += ( int ) ( s . charAt ( i ) - '0' ) ; Rightsum += ( int ) ( s . charAt ( s . length ( ) - 1 - i ) - '0' ) ; } if ( Leftsum == Rightsum ) System . out . println ( " Balanced " ) ; else System . out . println ( " Not ▁ Balanced " ) ; }
long NthTerm ( long n ) { long x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
int log_a_to_base_b ( int a , int b ) { return ( int ) ( Math . log ( a ) / Math . log ( b ) ) ; }
int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; }
double Circumradius ( int a , int b , int c , int d ) { double s = ( a + b + c + d ) / 2.0 ; double radius = Math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }
void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { System . out . println ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; } else { System . out . println ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; } }
int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; int prefix_sum [ ] = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == false ) return false ; return true ; }
void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; }
void printLeaders ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
void removeLeadingZeros ( String str ) { String regex = " ^ 0 + ( ? ! $ ) " ; str = str . replaceAll ( regex , " " ) ; System . out . println ( str ) ; }
long fourthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
int Occurrence ( String s , int position ) { int count = 0 ; for ( int i = 0 ; i < position - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( position - 1 ) ) count ++ ; return count ; }
int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
void countOfSubarray ( int arr [ ] , int N ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int answer = 0 ; int sum = 0 ; if ( mp . get ( 1 ) != null ) mp . put ( 1 , mp . get ( 1 ) + 1 ) ; else mp . put ( 1 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( mp . get ( sum - i ) != null ) answer += mp . get ( sum - i ) ; if ( mp . get ( sum - i ) != null ) mp . put ( sum - i , mp . get ( sum - i ) + 1 ) ; else mp . put ( sum - i , 1 ) ; } System . out . print ( answer ) ; }
void subArray ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; } } }
int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
void printGolomb ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 1 ] = 1 ; System . out . print ( dp [ 1 ] + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; System . out . print ( dp [ i ] + " ▁ " ) ; } }
int smallSumSubset ( List < Integer > data , int target , int maxVal ) { int sum = 0 ; for ( Integer i : data ) sum += i ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . size ( ) ; else if ( data . get ( 0 ) >= target ) return 1 ; else if ( data . get ( 0 ) < target ) { List < Integer > temp = new ArrayList < > ( ) ; for ( int i = 1 ; i < data . size ( ) ; i ++ ) temp . add ( data . get ( i ) ) ; return Math . min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data . get ( 0 ) , maxVal ) ) ; } return - 1 ; }
int findKHCF ( int x , int y , int k ) { int small = Math . min ( x , y ) ; int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; }
int greyConverter ( int n ) { return n ^ ( n >> 1 ) ; }
boolean isheptagonal ( int N ) { double n = ( 3 + Math . sqrt ( 40 * N + 9 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }
void computePair ( double K ) { if ( K == 1 ) { System . out . print ( " No " ) ; return ; } else { System . out . print ( K * K / ( K - 1 ) + " ▁ " ) ; System . out . print ( K / ( K - 1 ) + "NEW_LINE"); } }
void minimumOperations ( int arr [ ] , int N ) { int mx = 0 , pos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } System . out . println ( ( mx - 1 ) * N + pos + 1 ) ; }
int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) System . out . println ( " Coplanar " ) ; else System . out . println ( " Not ▁ Coplanar " ) ; }
void countSmaller ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( str . charAt ( j ) < str . charAt ( i ) ) { cnt += 1 ; } } System . out . print ( cnt + " ▁ " ) ; } }
void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; int y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; System . out . println ( x + " ▁ " + y ) ; }
int minCost ( String s , int n ) { int minValue = 100000000 ; for ( int i = 0 ; i <= 25 ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { cnt += Math . min ( Math . abs ( i - ( s . charAt ( j ) - ' a ' ) ) , 26 - Math . abs ( i - ( s . charAt ( j ) - ' a ' ) ) ) ; } minValue = Math . min ( minValue , cnt ) ; } return minValue ; }
void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
int proizvolov ( int a [ ] , int b [ ] , int n ) { return n * n ; }
void findString ( int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( ( char ) ( ' A ' + i % K ) ) ; } }
int countOfSubarray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] -- ; int [ ] pref = new int [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + arr [ i ] ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int answer = 0 ; mp . put ( 0 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( pref [ i ] ) ) { answer += mp . get ( pref [ i ] ) ; mp . put ( pref [ i ] , mp . get ( pref [ i ] ) + 1 ) ; } else { mp . put ( pref [ i ] , 1 ) ; } } return answer ; }
double Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; System . out . println ( pixels ) ; return 0 ; }
int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; }
int findSum ( int L , int R ) { ArrayList < Integer > arr = new ArrayList < > ( ) ; int i = 0 ; int x = 2 ; while ( i <= R ) { arr . add ( i + x ) ; if ( i + 1 <= R ) arr . add ( i + 1 + x ) ; x *= - 1 ; i += 2 ; } int sum = 0 ; for ( i = L ; i <= R ; ++ i ) sum += arr . get ( i ) ; return sum ; }
float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float l = ( float ) ( Math . sqrt ( Math . pow ( h , 2 ) + 4 * Math . pow ( r , 2 ) ) ) ; return l ; }
double getSlope ( double m ) { return m ; }
int sumOfMinAbsDifferences ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
boolean checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }
float getArea ( int a ) { float area = ( float ) ( Math . PI * a * a ) / 4 ; return area ; }
int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; boolean [ ] arr = new boolean [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
void constructArray ( int A [ ] , int N , int K ) { int B [ ] = new int [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + " ▁ " ) ; } }
long nextFibonacci ( int n ) { double a = n * ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; return Math . round ( a ) ; }
void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( float ) ( x1 + x2 ) / 2 + " , ▁ " + ( float ) ( y1 + y2 ) / 2 ) ; }
void find ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int b = ( int ) Math . ceil ( n / k * 1.0 ) ; int min_sum = 0 , max_sum = 0 ; for ( int i = 0 ; i < b ; i ++ ) min_sum += arr [ i ] ; for ( int i = 2 ; i < arr . length ; i ++ ) max_sum += arr [ i ] ; System . out . println ( " minimum ▁ " + min_sum ) ; System . out . println ( " maximum ▁ " + max_sum ) ; }
int productAtKthLevel ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == ' ( ' ) { if ( tree . charAt ( i ) == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree . charAt ( i ) - '0' ; ++ i ; int leftproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; int rightproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } return Integer . MIN_VALUE ; }
void primesInRange ( int n ) { int fact = 1 ; for ( int k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) System . out . println ( k ) ; } }
boolean sameLength ( int A , int B ) { while ( ( A > 0 ) && ( B > 0 ) ) { A = A / 10 ; B = B / 10 ; } if ( ( A == 0 ) && ( B == 0 ) ) return true ; return false ; }
boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
int day_of_the_week ( int y , int m , int d ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
boolean Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
int getInteger ( int L , int R ) { int number = 0 ; for ( int i = L ; i <= R ; i ++ ) number += Math . pow ( 2 , i ) ; return number ; }
float find ( int N , int a , int b ) { float probability = 0.0f ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = ( float ) ( 1.0 / 6 ) ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; }
void calcSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; System . out . print ( sum + " ▁ " ) ; for ( int i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; System . out . print ( sum + " ▁ " ) ; } }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
void printTriplets ( int arr [ ] , int n , int sum ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( int x = j + 1 ; x <= k ; x ++ ) System . out . println ( arr [ i ] + " , ▁ " + arr [ j ] + " , ▁ " + arr [ x ] ) ; j ++ ; } } } }
void generateStr ( String a , String b , String s , int count , int len ) { if ( count == len ) { System . out . println ( s ) ; return ; } generateStr ( a . substring ( 1 ) , b . substring ( 1 ) , s + a . charAt ( 0 ) , count + 1 , len ) ; generateStr ( a . substring ( 1 ) , b . substring ( 1 ) , s + b . charAt ( 0 ) , count + 1 , len ) ; }
int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
void scoreOfParentheses ( String s ) { Stack < Integer > stack = new Stack < > ( ) ; stack . push ( 0 ) ; for ( char c : s . toCharArray ( ) ) { if ( c == ' ( ' ) stack . push ( 0 ) ; else { int tmp = stack . pop ( ) ; int val = 0 ; if ( tmp > 0 ) val = tmp * 2 ; else val = 1 ; stack . push ( stack . pop ( ) + val ) ; } } System . out . println ( stack . peek ( ) ) ; }
void findNthTerm ( int n ) { System . out . println ( Math . pow ( 2 , n ) - 2 * n ) ; }
boolean printPairs ( int arr [ ] , int n , int k ) { boolean isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { System . out . print ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " ▁ " ) ; isPairFound = true ; } } } return isPairFound ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
void printBinaryString ( int arr [ ] [ ] , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) { System . out . print ( 0 ) ; } else { System . out . print ( 1 ) ; } } }
double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }
int find ( Vector < Integer > arr , int N , int key ) { int l = 0 ; int h = N - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr . get ( mid ) == key ) return mid ; if ( arr . get ( l ) >= arr . get ( mid ) ) { if ( arr . get ( l ) >= key && key >= arr . get ( mid ) ) h = mid - 1 ; else l = mid + 1 ; } else { if ( arr . get ( mid ) >= key && key >= arr . get ( h ) ) l = mid + 1 ; else h = mid - 1 ; } } return - 1 ; }
long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = ( int ) total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
int No_of_squares ( int N , int K ) { int no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }
int arrayDivisionByTwo ( int arr [ ] , int n ) { int cnt = 0 ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; cnt ++ ; } ans = Math . min ( ans , cnt ) ; } return ans ; }
boolean check_order ( int [ ] arr ) { int cnt = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { if ( Math . abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( Math . abs ( arr [ 0 ] - arr [ arr . length - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; }
double findIndex ( int n ) { double x = Math . sqrt ( 2 * Math . pow ( 10 , ( n - 1 ) ) ) ; return Math . round ( x ) ; }
int countSum ( int a [ ] , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }
int min_operations ( int A [ ] , int n ) { if ( n == 0 ) return 0 ; int ans = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] > A [ i - 1 ] ) { ans += A [ i ] - A [ i - 1 ] ; } } return ans ; }
int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }
void findPairs ( int n ) { int cubeRoot = ( int ) Math . pow ( n , 1.0 / 3.0 ) ; int cube [ ] = new int [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { System . out . println ( " ( " + l + " , ▁ " + r + " ) " ) ; l ++ ; r -- ; } } }
int countPairs ( String s ) { Set < Character > st = new HashSet < Character > ( ) ; st . add ( ' a ' ) ; st . add ( ' e ' ) ; st . add ( ' i ' ) ; st . add ( ' o ' ) ; st . add ( ' u ' ) ; int count = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( st . contains ( s . charAt ( i ) ) && ! st . contains ( s . charAt ( i + 1 ) ) ) count ++ ; } return count ; }
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
double calTime ( double arr [ ] , int n ) { double work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; }
void finalPosition ( String move ) { int l = move . length ( ) ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( move . charAt ( i ) == ' U ' ) countUp ++ ; else if ( move . charAt ( i ) == ' D ' ) countDown ++ ; else if ( move . charAt ( i ) == ' L ' ) countLeft ++ ; else if ( move . charAt ( i ) == ' R ' ) countRight ++ ; } System . out . println ( " Final ▁ Position : ▁ ( " + ( countRight - countLeft ) + " , ▁ " + ( countUp - countDown ) + " ) " ) ; }
double subfactorial ( int N ) { double res = 0 , fact = 1 ; int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - ( 1 / fact ) ; else res = res + ( 1 / fact ) ; count ++ ; } return fact * ( 1 + res ) ; }
void waysToPaint ( int n ) { long same = 6 ; long diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } System . out . println ( same + diff ) ; }
int findSum ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
int summation ( int n ) { return n << ( n - 1 ) ; }
int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
void printDivisors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . printf ( " % d ▁ " , i ) ; else { System . out . printf ( " % d ▁ " , i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( " % d ▁ " , v . get ( i ) ) ; }
int nswpn ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }
int findMax ( int n , int a [ ] , int b [ ] , int k [ ] , int m ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { int lowerbound = a [ i ] ; int upperbound = b [ i ] ; for ( int j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; }
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; System . out . print ( f1 + " ▁ " ) ; for ( i = 1 ; i < n ; i ++ ) { System . out . print ( f2 + " ▁ " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) System . out . println ( " Angle ▁ not ▁ possible " ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; System . out . println ( sector ) ; } }
long minimumMoves ( int a [ ] , int n ) { long operations = 0 ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) operations += ( long ) Math . abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( k * ( 6 * i + 1 ) + " ▁ " + k * ( 6 * i + 2 ) + " ▁ " + k * ( 6 * i + 3 ) + " ▁ " + k * ( 6 * i + 5 ) ) ; } }
long removeRecur ( long n ) { long prev_digit = n % 10 ; long pow = 10 ; long res = prev_digit ; while ( n > 0 ) { long curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; }
void checkperfectsquare ( int n ) { if ( Math . ceil ( ( double ) Math . sqrt ( n ) ) == Math . floor ( ( double ) Math . sqrt ( n ) ) ) { System . out . print ( " perfect ▁ square " ) ; } else { System . out . print ( " not ▁ a ▁ perfect ▁ square " ) ; } }
void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; }
int min_moves ( int n ) { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = Math . min ( ans , i + n / i - 2 ) ; } } return ans ; }
String checkSameDigits ( int N ) { int digit = N % 10 ; while ( N != 0 ) { int current_digit = N % 10 ; N = N / 10 ; if ( current_digit != digit ) { return " No " ; } } return " Yes " ; }
int findCntTriplet ( int N ) { int cntTriplet = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += N / i ; } else { cntTriplet += ( N / i ) - 1 ; } } return cntTriplet ; }
int countTriplets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; }
int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; }
int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = Math . max ( buy , sell - arr [ i ] ) ; sell = Math . max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . max ( sell , buy ) ; }
int countStrings ( int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
int maxAND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = res > ( arr [ i ] & arr [ j ] ) ? res : ( arr [ i ] & arr [ j ] ) ; return res ; }
void Kmultiples ( int n , int k ) { int a = n ; for ( int i = 1 ; i <= k ; i ++ ) { System . out . print ( n + " ▁ * ▁ " + i + " ▁ = ▁ " + a + "NEW_LINE"); int j = 0 ; while ( n >= ( 1 << j ) ) { a += n & ( 1 << j ) ; j ++ ; } } }
void equal_xor_sum ( int arr [ ] , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; System . out . println ( num ) ; }
boolean isValid ( String s ) { if ( ( s . indexOf ( " geek " ) != - 1 ) && ( s . indexOf ( " keeg " , s . indexOf ( " geek " ) + 4 ) != - 1 ) ) return true ; return false ; }
boolean isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }
boolean isSortedArray ( int [ ] arr , int n ) { int l = 0 , r = ( n - 1 ) ; while ( ( l + 1 ) < r ) { if ( arr [ l ] >= Math . max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= Math . max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l ++ ; r -- ; } else { return false ; } } return true ; }
boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
String noAdjacentDup ( String s1 ) { int n = s1 . length ( ) ; char [ ] s = s1 . toCharArray ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( new String ( s ) ) ; }
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
int findArrangement ( int N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }
void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( i * g + " ▁ " ) ; ; }
int countOfPairs ( int arr [ ] , int N , int X ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; }
int reachTarget ( int target ) { target = Math . abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
int findM ( int N ) { int M = 0 ; int MSB = ( int ) Math . log ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; }
boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
int minPossibleValue ( int N , int K , int X ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) System . out . print ( a [ i ] + " ▁ " ) ; } }
int Last_set_bit ( int n ) { int p = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) { return p ; } p ++ ; n = n >> 1 ; } return - 1 ; }
void firstSubsequence ( String s ) { Vector < String > allsubseq = new Vector < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String k = " " ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( i != j ) { k += s . charAt ( j ) ; } } allsubseq . add ( k ) ; } Collections . sort ( allsubseq ) ; System . out . print ( allsubseq . get ( 0 ) ) ; }
boolean isPossible ( int index , int sum ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } boolean placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) ; boolean placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) ; if ( placeAdd placeMinus ) return true ; return false ; }
boolean checkLuhn ( String cardNo ) { int nDigits = cardNo . length ( ) ; int nSum = 0 ; boolean isSecond = false ; for ( int i = nDigits - 1 ; i >= 0 ; i -- ) { int d = cardNo . charAt ( i ) - '0' ; if ( isSecond == true ) d = d * 2 ; nSum += d / 10 ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; }
boolean isProductEven ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
double e ( int x , int n ) { double r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; }
void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }
void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; }
void result ( long n , long k , long t ) { if ( t <= k ) System . out . println ( t ) ; else if ( t <= n ) System . out . println ( k ) ; else { long temp = t - n ; temp = k - temp ; System . out . println ( temp ) ; } }
int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
int maxSum ( int arr [ ] , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
void print ( int n , int k ) { System . out . print ( k + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int x = ( int ) ( Math . pow ( k , i ) - Math . pow ( k , i - 1 ) ) ; System . out . print ( x + " ▁ " ) ; } }
boolean LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }
int count_rectangles ( int N , int M ) { int p_x = ( N * ( N - 1 ) ) / 2 ; int p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }
void EditDistDP ( String str1 , String str2 ) { int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; int [ ] [ ] DP = new int [ 2 ] [ len1 + 1 ] ; for ( int i = 0 ; i <= len1 ; i ++ ) DP [ 0 ] [ i ] = i ; for ( int i = 1 ; i <= len2 ; i ++ ) { for ( int j = 0 ; j <= len1 ; j ++ ) { if ( j == 0 ) DP [ i % 2 ] [ j ] = i ; else if ( str1 . charAt ( j - 1 ) == str2 . charAt ( i - 1 ) ) { DP [ i % 2 ] [ j ] = DP [ ( i - 1 ) % 2 ] [ j - 1 ] ; } else { DP [ i % 2 ] [ j ] = 1 + Math . min ( DP [ ( i - 1 ) % 2 ] [ j ] , Math . min ( DP [ i % 2 ] [ j - 1 ] , DP [ ( i - 1 ) % 2 ] [ j - 1 ] ) ) ; } } } System . out . print ( DP [ len2 % 2 ] [ len1 ] + "NEW_LINE"); }
int CountPairs ( int [ ] arr , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }
boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; 1 << i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
int max_sum ( int a [ ] , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; }
int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }
double pentdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.22 * a ; return d ; }
void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( " x ▁ = ▁ " + i + " , ▁ y ▁ = ▁ " + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( " No ▁ solution " ) ; }
int minimal ( int a [ ] , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
int numberOfGP ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
int getFirstElement ( int [ ] a , int N , int K , int M ) { K %= N ; int index = ( K + M - 1 ) % N ; int result = a [ index ] ; return result ; }
boolean isPalindrome ( float num ) { String s = String . valueOf ( num ) ; int low = 0 ; int high = s . length ( ) - 1 ; while ( low < high ) { if ( s . charAt ( low ) != s . charAt ( high ) ) return false ; low ++ ; high -- ; } return true ; }
int summation ( int n ) { int sum ; sum = ( int ) ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
int getOddOccurrence ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
boolean findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; }
int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
boolean isPossible ( int a [ ] , int n ) { int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; }
int maxFreq ( String s , int a , int b ) { int fre [ ] = new int [ 10 ] ; int n = s . length ( ) ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } for ( int i = 0 ; i < n ; i ++ ) fre [ s . charAt ( i ) - '0' ] ++ ; if ( fre [ a ] == 0 && fre [ b ] == 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
int sumOfFirstM ( int A [ ] , int N , int M ) { int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { sum = sum + A [ i % N ] ; } return sum ; }
boolean topsyTurvy ( char [ ] str ) { for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == '2' str [ i ] == '4' str [ i ] == '5' str [ i ] == '6' str [ i ] == '7' str [ i ] == '9' ) { return false ; } } return true ; }
void minAtEachIndex ( int n , int arr [ ] ) { int dp1 [ ] = new int [ n ] ; int dp2 [ ] = new int [ n ] ; int i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = Math . min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = Math . min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; ArrayList < Integer > v = new ArrayList < Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) v . add ( Math . min ( dp1 [ i ] , dp2 [ i ] ) ) ; for ( int x : v ) System . out . print ( x + " ▁ " ) ; }
int count_pairs ( int x ) { int ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = x / 2 ; } return ans ; }
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
int findAnswer ( int n , int [ ] arr ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
int gonNum120 ( int n ) { return ( 118 * n * n - 116 * n ) / 2 ; }
void isSubsetAndZero ( int array [ ] , int length , int N ) { int arrAnd = array [ 0 ] ; for ( int i = 1 ; i < length ; i ++ ) { arrAnd = arrAnd & array [ i ] ; } if ( ( arrAnd & N ) == 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { System . out . print ( j * j * j + " ▁ " ) ; break ; } } } }
int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) Math . pow ( i , k ) ; } return sum ; }
int countPaths ( int sum , int get , int m , int n , int dp [ ] [ ] ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != - 1 ) return dp [ sum ] [ get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; }
int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N ++ ; return N ; }
void minProduct ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= ( n - 4 ) / 2 ; i ++ ) { ans = ( int ) ( 1L * ans * ( n - 2 ) ) % mod ; } ans = ( int ) ( 1L * ans * ( n - 2 ) * ( n - 1 ) ) % mod ; System . out . print ( ans + "NEW_LINE"); }
float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = ( float ) Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; }
int maxHeight ( int h1 , int h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }
void sumOfTwoPerfectCubes ( int N ) { HashMap < Integer , Integer > cubes = new HashMap < > ( ) ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes . put ( ( i * i * i ) , i ) ; Iterator < Map . Entry < Integer , Integer > > itr = cubes . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = itr . next ( ) ; int firstNumber = entry . getKey ( ) ; int secondNumber = N - entry . getKey ( ) ; if ( cubes . containsKey ( secondNumber ) ) { System . out . println ( " True " ) ; return ; } } System . out . println ( " False " ) ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int findEletobeInserted ( int A [ ] , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; }
int stepRequired ( int N ) { int cnt = 0 ; while ( N > 0 ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }
int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
int calculateSum ( String arr [ ] , int n ) { if ( n == 0 ) return 0 ; String s = arr [ 0 ] ; int value = Integer . parseInt ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = Integer . parseInt ( s ) ; char operation = arr [ i - 1 ] . charAt ( 0 ) ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
float angleOncirCumference ( float z ) { return ( z / 2 ) ; }
boolean is_distinct ( long n , long k ) { HashSet < Long > s = new HashSet < Long > ( ) ; for ( int i = 1 ; i <= k ; i ++ ) { long tmp = n % i ; if ( s . contains ( tmp ) ) { return false ; } s . add ( tmp ) ; } return true ; }
int printNumber ( int N , int K , int M ) { int sum = K * ( M * ( M + 1 ) / 2 ) ; return sum - N ; }
int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; }
void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " + x + " ▁ & ▁ " + y ) ; }
void min_visible_bottles ( int [ ] arr , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } ans = Math . max ( ans , mp . get ( arr [ i ] ) ) ; } System . out . print ( " Minimum ▁ number ▁ of ▁ " + " Visible ▁ Bottles ▁ are : ▁ " + ans + "NEW_LINE"); }
void rearrange ( int [ ] arr ) { if ( arr == null arr . length % 2 == 1 ) return ; int currIdx = ( arr . length - 1 ) / 2 ; while ( currIdx > 0 ) { int count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } }
boolean isLucky ( int n ) { boolean arr [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; System . out . println ( " equation ▁ of ▁ plane ▁ is ▁ " + a + " ▁ x ▁ + ▁ " + b + " ▁ y ▁ + ▁ " + c + " ▁ z ▁ + ▁ " + d + " ▁ = ▁ 0 . " ) ; }
void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
void checkVantieghemsTheorem ( int limit ) { long prod = 1 ; for ( long n = 2 ; n < limit ; n ++ ) { if ( ( ( prod - n < 0 ? 0 : prod - n ) % ( ( 1 << n ) - 1 ) ) == 0 ) System . out . print ( n + " is primeNEW_LINE"); prod *= ( ( 1 << n ) - 1 ) ; } }
int minTrees ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; boolean isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } }
int cntSubsets ( int [ ] arr , int n ) { int max = ( int ) Math . pow ( 2 , n ) ; int result = 0 ; for ( int i = 0 ; i < max ; i ++ ) { int counter = i ; if ( ( counter & ( counter >> 1 ) ) > 0 ) continue ; result ++ ; } return result ; }
int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; boolean marked [ ] = new boolean [ nNew + 1 ] ; Arrays . fill ( marked , false ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) System . out . print ( 2 + " ▁ " ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + " ▁ " ) ; return - 1 ; }
void findNthTerm ( int n ) { System . out . println ( n * ( 5 * n + 3 ) / 2 ) ; }
double maxAverageOfPath ( int cost [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
void Bubble_Sort ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } } } }
void countDigit ( int arr [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i ] [ j ] ; int d = ( int ) ( Math . floor ( Math . log10 ( X ) * 1.0 ) + 1 ) ; System . out . print ( d + " ▁ " ) ; } System . out . println ( ) ; } }
int multiplyWith4 ( int n ) { return ( n << 2 ) ; }
int productSubSeqCount ( ArrayList < Integer > arr , int k ) { int n = arr . size ( ) ; int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr . get ( j - 1 ) <= i && arr . get ( j - 1 ) > 0 ) dp [ i ] [ j ] += dp [ i / arr . get ( j - 1 ) ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }
void Alphabet_N_Pattern ( int N ) { int index , side_index , size ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { System . out . print ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) System . out . print ( " ▁ " ) ; if ( index != 0 && index != N - 1 ) System . out . print ( Diagonal ++ ) ; else System . out . print ( " ▁ " ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) System . out . print ( " ▁ " ) ; System . out . print ( Right ++ ) ; System . out . println ( ) ; } }
int cntSubsets ( int [ ] arr , int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } int result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
void mirrorMatrix ( int mat1 [ ] [ ] , int mat2 [ ] [ ] , int N ) { int row = 0 ; int col = 0 ; boolean isMirrorImage = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
int countStrings ( String s ) { int sum = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) == ' $ ' ) sum *= 21 ; else if ( s . charAt ( i ) == ' $ ' ) sum *= 5 ; } return sum ; }
int nDigitPalindromes ( int n ) { return ( 9 * ( int ) Math . pow ( 10 , ( n - 1 ) / 2 ) ) ; }
int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; }
int findInGrid ( int i , int j ) { if ( i == j ) return ( i * i - ( i - 1 ) ) ; else if ( i > j ) { if ( i % 2 == 0 ) return i * i - ( j - 1 ) ; else return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ; } else { if ( j % 2 == 0 ) return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ; else return j * j - ( i - 1 ) ; } }
int findNumber ( int n ) { int x = ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }
double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; System . out . print ( "1 ▁ " ) ; for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; System . out . print ( multi ) ; System . out . print ( " ▁ " ) ; multi = multi * x ; } System . out . println ( ) ; return total ; }
int largestNum ( int [ ] arr ) { Set < Integer > set = new HashSet < > ( ) ; int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { set . add ( arr [ i ] ) ; if ( set . contains ( - 1 * arr [ i ] ) ) { res = Math . max ( res , Math . abs ( arr [ i ] ) ) ; } } return res ; }
int findMinX ( int num [ ] , int rem [ ] , int k ) { while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
void splitArray ( int arr [ ] , int n , int K ) { Arrays . sort ( arr ) ; int i = n - 1 ; int result = 0 ; while ( K -- != 0 ) { result += arr [ i - 1 ] ; i -= 2 ; } System . out . print ( result ) ; }
void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( - v . get ( i ) + " ▁ " + v . get ( i ) ) ; }
boolean isPossibleToZero ( int a [ ] , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
String generateNumber ( String number ) { int temp = 0 , adding_number = 0 ; String result = " " ; int len = number . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { int digit = ( int ) number . charAt ( i ) - ( int ) '0' ; if ( temp % 2 == 0 ) { adding_number += 1 ; digit += adding_number ; if ( digit >= 10 ) { digit %= 9 ; if ( digit == 0 ) digit = 9 ; } } result = digit + result ; temp += 1 ; } return result ; }
String findNumber ( int n , int d ) { String ans = " " ; if ( d != 10 ) { ans += Integer . toString ( d ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += " Impossible " ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; }
int findLUSlength ( String a , String b ) { if ( a . equals ( b ) == true ) return 0 ; return Math . max ( a . length ( ) , b . length ( ) ) ; }
void swap ( int a , int b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; System . out . print ( " After ▁ swapping : ▁ a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b ) ; }
