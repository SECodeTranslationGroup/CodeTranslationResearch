public List < Tuple < string , double >> CustomerExpensiveOrdersTotalMax ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalMax = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Where ( o => o . Total > 100 ) . Max ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalMax ; }
public int ProjectedStringElementAt ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = strings . Select ( s => s . Length ) . Where ( i => i % 2 == 0 ) . ElementAt ( 2 ) ; return firstStringLength ; }
public List < Tuple < string , int >> CustomerEachCountryOrdersMin ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int >> ordersMin = customers . GroupBy ( c => c . Country ) . Select ( g => Tuple . Create ( g . Key , g . Min ( c => c . Orders . Count ) ) ) . ToList ( ) ; return ordersMin ; }
public List < Tuple < string , DateTime >> CustomerOrdersEachNestedSkip ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> after3EachOrders = customers . SelectMany ( c => c . Orders . Skip ( 3 ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return after3EachOrders ; }
public int OddNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = numbers . FirstOrDefault ( n => n % 2 == 1 , - 2 ) ; return firstNum ; }
public List < Tuple < string , int >> CustomerExpensiveOrdersCount ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int >> orderCounts = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Count ( o => o . Total > 100 ) ) ) . ToList ( ) ; return orderCounts ; }
public Dictionary < char , List < string >> StringGroupByFirstCharDictOrderbyDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Dictionary < char , List < string >> wordsGroups = words . GroupBy ( w => char . ToLower ( w [ 0 ] ) ) . ToDictionary ( g => g . Key , g => g . OrderByDescending ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ) ; return wordsGroups ; }
public List < int > IntWithSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > q = numbers . Where ( ( n , i ) => n < i * i ) . ToList ( ) ; return q ; }
public int [ ] ProjectionIntConcat ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = numbersA . Select ( n => n + 1 ) ; var second = numbersB . Select ( n => n - 1 ) ; int [ ] numbers = first . Concat ( second ) . ToArray ( ) ; return numbers ; }
public List < int > RangeOfEvenIntsStartFrom ( int start , int count ) { List < int > numbers = Enumerable . Range ( start , count ) . Where ( n => n % 2 == 0 ) . ToList ( ) ; return numbers ; }
public List < Tuple < string , string >> ProductLeftOuterJoinCategoriesName ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , string >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . SelectMany ( t => t . Item2. Select ( p => p . ProductName ) . DefaultIfEmpty ( " No ▁ Product " ) , ( t , n ) => Tuple . Create ( t . Item1 , n ) ) . ToList ( ) ; return q ; }
public List < Tuple < string , int , double >> CustomerSelectManyCustomerNewOrderIdAndTotals ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int , double >> customerProperties = customers . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderId , o . Total ) ) . ToList ( ) ; return customerProperties ; }
public Dictionary < string , List < Product >> ProductEachCategoryMaxUnitPriceProductsDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice == g . Max ( p => p . UnitPrice ) ) . ToList ( ) ) ; return categories ; }
public Product ProductFirstOrDefault ( ) { List < Product > products = GetProductList ( ) ; Product product12 = products . FirstOrDefault ( p => p . ProductId == 12 , Product . Default ) ; return product12 ; }
public int OddFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int factorsCount = factorsOf300. Count ( n => n % 2 == 1 ) ; return factorsCount ; }
public List < double > DoubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n % 1.5 ) . ThenByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public double DoubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . FirstOrDefault ( 3.14 ) ; return firstNum ; }
public List < int > RangeOfEvenIntsStartFrom ( ) { List < int > numbers = Enumerable . Range ( 100 , 100 ) . Where ( n => n % 2 == 0 ) . ToList ( ) ; return numbers ; }
public Dictionary < string , List < Product >> ProductEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice == g . Min ( p => p . UnitPrice ) ) . ToList ( ) ) ; return categories ; }
public Dictionary < string , double > CustomerOrdersTotalSumDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalSum = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Sum ( o => o . Total ) ) ; return ordersTotalSum ; }
public List < Tuple < string , List < Order >>> CustomerIdAndOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , List < Order >>> customerProperties = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders ) ) . ToList ( ) ; return customerProperties ; }
public List < double > BigDoubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 3 ) . OrderBy ( n => n % 1.5 ) . ThenBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public List < Tuple < string , Order >> CustomerSelectManyCustomerOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Order >> customerProperties = customers . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o ) ) . ToList ( ) ; return customerProperties ; }
public Dictionary < string , Dictionary < string , Customer >> CustomerNestedGroupByRegionAndName ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , Dictionary < string , Customer >> customerGroups = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . ToDictionary ( c => c . CompanyName , c => c ) ) ; return customerGroups ; }
public List < Order > CustomerOrdersTakeWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Order > firstOrdersWhile = customers . SelectMany ( c => c . Orders ) . TakeWhile ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) . ToList ( ) ; return firstOrdersWhile ; }
public Dictionary < double , double > ConvertArrayToDictionaryWithDistinctAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 1.7 , 2.9 } ; Dictionary < double , double > doublesDict = doubles . Distinct ( ) . ToDictionary ( sr => sr , sr => sr * 2 ) ; foreach ( var pair in doublesDict ) Console . WriteLine ( pair . Key + " ▁ " + pair . Value ) ; return doublesDict ; }
public double [ ] ProjectionDoubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = numbersA . Select ( n => n - ( int ) n ) ; var second = numbersB . Select ( n => n - ( int ) n ) ; double [ ] numbers = first . Intersect ( second ) . ToArray ( ) ; return numbers ; }
public List < Tuple < string , string >> CustomerCrossGroupJoinRegionsPhone ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , string >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. Select ( c => c . Phone ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public List < double > BigDoubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 5 ) . OrderByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public List < int > IntTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > firstNumbers = numbers . TakeWhile ( ( n , i ) => n > i ) . ToList ( ) ; return firstNumbers ; }
public List < int > IntSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > afterNumbers = numbers . SkipWhile ( ( n , i ) => n > i ) . ToList ( ) ; return afterNumbers ; }
public double BigNumbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = numbers . Where ( n => n > 5 ) . Average ( n => n * 2 ) ; return averageNum ; }
public Dictionary < string , double > CustomerExpensiveOrdersTotalSumDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalSum = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Where ( o => o . Total > 100 ) . Sum ( o => o . Total ) ) ; return ordersTotalSum ; }
public Dictionary < string , List < Product >> ProductEachGroupTake ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> first3EachGroups = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Take ( 3 ) . ToList ( ) ) ; return first3EachGroups ; }
public double BigDoubleNumbersFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . First ( d => d > 5 ) ; return firstNum ; }
public double ProductUnitPriceMin ( ) { List < Product > products = GetProductList ( ) ; double minUnitPrice = products . Min ( p => p . UnitPrice ) ; return minUnitPrice ; }
public List < Tuple < string , string >> CustomerLeftOuterJoinRegionsName ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , string >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. Select ( c => c . CompanyName ) . DefaultIfEmpty ( " No ▁ Customer " ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public int ProjectedBigNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = numbers . Select ( i => ( int ) Math . Pow ( 2 , i ) ) . First ( n => n > 100 ) ; return firstNum ; }
public Dictionary < int , Dictionary < int , List < Order >>> CustomerNestedGroupByOrderYearAndMonth ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < int , Dictionary < int , List < Order >>> customerOrderGroups = customers . SelectMany ( c => c . Orders ) . GroupBy ( o => o . OrderDate . Year ) . ToDictionary ( yg => yg . Key , yg => yg . GroupBy ( o => o . OrderDate . Month ) . ToDictionary ( mg => mg . Key , mg => mg . ToList ( ) ) ) ; return customerOrderGroups ; }
public List < Tuple < string , List < Product >>> ProductEachCategoryFirstOrDefaultUnitPriceProducts ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < Product >>> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Where ( p => p . UnitPrice == g . FirstOrDefault ( Product . Default ) . UnitPrice ) . ToList ( ) ) ) . ToList ( ) ; return categories ; }
public bool StringAnyMatch ( char c ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; bool anyMatch = words . Any ( w => w [ 0 ] > c ) ; return anyMatch ; }
public Dictionary < string , double > CustomerEachRegionOrdersTotalMaxDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalMax = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . SelectMany ( c => c . Orders ) . Max ( o => o . Total ) ) ; return ordersTotalMax ; }
public List < Tuple < double , List < double >>> DoubleGroupByMod ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; List < Tuple < double , List < double >>> numberGroups = numbers . GroupBy ( n => n % 1.5 ) . Select ( g => Tuple . Create ( g . Key , g . ToList ( ) ) ) . ToList ( ) ; return numberGroups ; }
public Dictionary < string , int > CustomerEachRegionOrdersMinDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > ordersMin = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . Min ( c => c . Orders . Count ) ) ; return ordersMin ; }
public int BigNumbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = numbers . Where ( n => n > 5 ) . Sum ( n => n * 2 ) ; return numbersSum ; }
public List < int > IntSquareSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > afterNumbersWhile = numbers . Select ( i => i * i ) . SkipWhile ( i => i > 3 ) . ToList ( ) ; return afterNumbersWhile ; }
public Dictionary < string , bool > ProductEachGroupAllMatch ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , bool > allMatch = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . All ( p => p . UnitsInStock > 0 ) ) ; return allMatch ; }
public bool LongStringAnyMatch ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; bool anyMatch = words . Where ( w => w . Length > 5 ) . Any ( n => string . CompareOrdinal ( n , " b " ) > 0 ) ; return anyMatch ; }
public List < Product > ProductOrderbyDescendingName ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderByDescending ( p => p . ProductName ) . ToList ( ) ; return sortedProducts ; }
public bool [ ] BigIntWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool [ ] numSelected = numbers . Where ( n => n > 5 ) . Select ( ( n , i ) => n == i ) . ToArray ( ) ; return numSelected ; }
public double ProductUnitPriceTotalSum ( ) { List < Product > products = GetProductList ( ) ; double totalSum = products . Sum ( p => p . UnitPrice ) ; return totalSum ; }
public List < Tuple < string , Customer >> CustomerLeftOuterJoinRegions ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Customer >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. DefaultIfEmpty ( null ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public Dictionary < string , int > CustomerNewOrdersCountDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > orderCounts = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Count ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) ) ; return orderCounts ; }
public List < string > StringOrderbyLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . OrderBy ( w => w . Length ) . ToList ( ) ; return sortedWords ; }
public string [ ] SelectByCaseConcat ( ) { string [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; string [ ] upperLowerWords = words . Select ( w => w . ToUpper ( ) + w . ToLower ( ) ) . ToArray ( ) ; return upperLowerWords ; }
public List < Product > ProductOrderbyDescendingId ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderByDescending ( p => p . ProductId ) . ToList ( ) ; return sortedProducts ; }
public Dictionary < string , List < Product >> ProductsConvertGroupingToDictionaryAndPrint ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> catagory = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; foreach ( var pair in catagory ) { Console . WriteLine ( pair . Key + " : " ) ; foreach ( var product in pair . Value ) Console . WriteLine ( " \ t " + product ) ; } return catagory ; }
public List < Tuple < string , double >> CustomerOrdersTotalSum ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalSum = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Sum ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalSum ; }
public List < Tuple < int , string >> CustomerCrossJoinRegionsWithCodeName ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < int , string >> q = regions . Join ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r . Item2 , c . CompanyName ) ) . ToList ( ) ; return q ; }
public double BigNumbersAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = numbers . Where ( n => n > 2 ) . Aggregate ( seed , ( a , b ) => a * b ) ; return product ; }
public int ProjectedStringFirst ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = strings . Select ( s => s . Length ) . First ( i => i % 2 == 0 ) ; return firstStringLength ; }
public bool ProductAnyMatch ( ) { List < Product > products = GetProductList ( ) ; bool anyMatch = products . Any ( p => p . UnitsInStock > 0 ) ; return anyMatch ; }
public List < Tuple < string , int , double >> CustomerSelectManyCustomerOrderIdAndTotals ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int , double >> customerProperties = customers . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderId , o . Total ) ) . ToList ( ) ; return customerProperties ; }
public int NumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = numbers . Sum ( ) ; return numbersSum ; }
public char [ ] ShortStringFirstChar ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; char [ ] selected = strings . Where ( w => w . Length < 4 ) . Select ( w => w [ 0 ] ) . ToArray ( ) ; return selected ; }
public int [ ] OddFactorOf300And900Count ( ) { int [ ] [ ] factorsOf300And900 = { new [ ] { 2 , 2 , 3 , 5 , 5 } , new [ ] { 2 , 2 , 3 , 3 , 5 , 5 } } ; int [ ] factorsCount = factorsOf300And900. Select ( a => a . Count ( n => n % 2 == 1 ) ) . ToArray ( ) ; return factorsCount ; }
public List < Tuple < string , double >> CustomerEachRegionOrdersTotalSum ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalSum = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . SelectMany ( c => c . Orders ) . Sum ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalSum ; }
public int [ ] IntPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = numbers . Select ( n => n + 1 ) . ToArray ( ) ; return numSelected ; }
public List < Tuple < string , Customer >> CustomerCrossGroupJoinRegions ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Customer >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2 , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public bool WaCustomerOrdersNestedAnyMatch ( ) { List < Customer > customers = GetCustomerList ( ) ; bool anyMatch = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . Any ( t => t . Item2 > new DateTime ( 2000 , 1 , 1 ) ) ; return anyMatch ; }
public Dictionary < Tuple < string , int > , List < string >> CustomerGroupJoinRegionsWithCodeNameRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; Dictionary < Tuple < string , int > , List < string >> q = regions . GroupJoin ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r , c . Select ( c => c . CompanyName ) . ToList ( ) ) ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; return q ; }
public List < Tuple < string , DateTime >> CustomerOrdersNestedTakeWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> firstOrdersWhile = customers . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . TakeWhile ( t => t . Item2 > new DateTime ( 2000 , 1 , 1 ) ) . ToList ( ) ; return firstOrdersWhile ; }
public Tuple < int , int > [ ] SelectManyJoinSumEven ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Tuple < int , int > [ ] pairs = numbersA . SelectMany ( a => numbersB . Where ( b => ( a + b ) % 2 == 0 ) , ( a , b ) => Tuple . Create ( a , b ) ) . ToArray ( ) ; return pairs ; }
public int [ ] StringLength ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = strings . Select ( w => w . Length ) . ToArray ( ) ; return selected ; }
public int ShortStringMaxLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; int maxLength = words . Where ( w => w . Length < 7 ) . Max ( w => w . Length ) ; return maxLength ; }
public bool [ ] IntWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool [ ] numSelected = numbers . Select ( ( n , i ) => n == i ) . ToArray ( ) ; return numSelected ; }
public List < int > RangeOfSquareInts ( ) { List < int > numbers = Enumerable . Range ( 0 , 20 ) . Select ( n => n * n ) . ToList ( ) ; return numbers ; }
public Dictionary < bool , List < double >> DoubleGroupByBoolDictOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Dictionary < bool , List < double >> numbersGroups = numbers . GroupBy ( n => n > 5 ) . ToDictionary ( g => g . Key , g => g . OrderBy ( n => n - ( int ) n ) . ToList ( ) ) ; return numbersGroups ; }
public List < string > ShortStringOrderbyDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < string > sortedWords = words . Where ( w => w . Length < 6 ) . OrderByDescending ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public Dictionary < string , Order > CustomerEachRegionFirstOrderDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , Order > ordersMax = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . SelectMany ( c => c . Orders ) . First ( ) ) ; return ordersMax ; }
public List < Tuple < bool , List < int >>> ProductGroupByPriceWithId ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < bool , List < int >>> productGroup = products . GroupBy ( p => p . UnitPrice > 100 ) . Select ( g => Tuple . Create ( g . Key , g . Select ( p => p . ProductId ) . ToList ( ) ) ) . ToList ( ) ; return productGroup ; }
public List < Tuple < string , int >> CustomerDistinctOrdersCount ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int >> orderCounts = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Distinct ( ) . Count ( ) ) ) . ToList ( ) ; return orderCounts ; }
public int OddNumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = numbers . Where ( n => n % 2 == 1 ) . Sum ( ) ; return numbersSum ; }
public List < int > IntTakeCount ( int [ ] numbers , int n ) { List < int > firstNNumbers = numbers . Take ( n ) . ToList ( ) ; return firstNNumbers ; }
public List < Order > WaCustomerSelectManyNewOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Order > customerProperties = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) ) . ToList ( ) ; return customerProperties ; }
public List < double > DoubleFractionOrderbyReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Select ( n => n - ( int ) n ) . OrderBy ( n => n ) . Reverse ( ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < string , double > CustomerExpensiveOrdersTotalMinDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalMin = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Where ( o => o . Total > 100 ) . Min ( o => o . Total ) ) ; return ordersTotalMin ; }
public Dictionary < bool , List < int >> ProductGroupByInStockWithIdDictPrint ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < int >> productGroup = products . GroupBy ( p => p . UnitsInStock == 0 ) . ToDictionary ( g => g . Key , g => g . Select ( p => p . ProductId ) . ToList ( ) ) ; productGroup [ true ] . ForEach ( p => Console . Write ( p ) ) ; Console . WriteLine ( ) ; productGroup [ false ] . ForEach ( p => Console . Write ( p ) ) ; return productGroup ; }
public List < Tuple < string , double >> ProductCrossJoinCategoriesUnitPrice ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , double >> q = categories . Join ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p . UnitPrice ) ) . ToList ( ) ; return q ; }
public Dictionary < string , double > CustomerOrdersTotalMaxDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalMax = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Max ( o => o . Total ) ) ; return ordersTotalMax ; }
public List < string > StringTakeCount ( string [ ] strings , int n ) { List < string > firstNWords = strings . Take ( n ) . ToList ( ) ; return firstNWords ; }
public void NumbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int i = 0 ; var q = numbers . Select ( n => n * 2 ) . Select ( n => i += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public double [ ] DoublesConvertToDescendingArrayAndPrintForeach ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = doubles . OrderByDescending ( d => d ) . ToArray ( ) ; foreach ( double d in doublesArray ) Console . WriteLine ( d ) ; return doublesArray ; }
public double ExpensiveProductUnitPriceTotalSum ( ) { List < Product > products = GetProductList ( ) ; double totalSum = products . Where ( p => p . UnitPrice > 100 ) . Sum ( p => p . UnitPrice ) ; return totalSum ; }
public List < double > BigDoubleOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 5 ) . OrderBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < string , int > ConvertTuplesToDictionaryAndPrint ( ) { List < Tuple < string , int >> scoreRecords = new List < Tuple < string , int >> { Tuple . Create ( " Alice " , 50 ) , Tuple . Create ( " Bob " , 40 ) , Tuple . Create ( " Cathy " , 45 ) } ; Dictionary < string , int > scoreRecordsDict = scoreRecords . ToDictionary ( sr => sr . Item1 , sr => sr . Item2 ) ; foreach ( var pair in scoreRecordsDict ) Console . WriteLine ( pair . Key + " ▁ " + pair . Value ) ; return scoreRecordsDict ; }
public List < Product > RepeatedProductsWithCount ( int count ) { List < Product > products = Enumerable . Repeat ( Product . Default , count ) . ToList ( ) ; return products ; }
public List < string > StringSkipWhileCount ( string [ ] strings , char c ) { List < string > afterWordsWhile = strings . SkipWhile ( w => w [ 0 ] > c ) . ToList ( ) ; return afterWordsWhile ; }
public List < int > IntTakeWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > firstNumbers = numbers . TakeWhile ( ( n , i ) => n > i ) . ToList ( ) ; return firstNumbers ; }
public double InputNumbersAggregate ( double [ ] numbers ) { double product = numbers . Aggregate ( ( runningProduct , nextFactor ) => runningProduct * nextFactor ) ; return product ; }
public List < string > StringTakeWhileCount ( string [ ] strings , char c ) { List < string > firstWordsWhile = strings . TakeWhile ( w => w [ 0 ] > c ) . ToList ( ) ; return firstWordsWhile ; }
public List < int > StringLengthTake ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < int > first3Words = words . Select ( w => w . Length ) . Take ( 3 ) . ToList ( ) ; return first3Words ; }
public void StringLengthEager ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; int i = 0 ; var q = words . Select ( w => w . Length ) . Select ( n => i += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public int BigNumbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = numbers . Where ( n => n > 5 ) . Max ( n => n * 2 ) ; return maxNum ; }
public List < Product > ProductIndexedWhere ( ) { List < Product > products = GetProductList ( ) ; List < Product > q = products . Where ( ( w , i ) => w . UnitsInStock > 0 && i % 2 == 1 ) . ToList ( ) ; return q ; }
public List < Tuple < string , Product >> ProductCrossJoinCategories ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , Product >> q = categories . Join ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . ToList ( ) ; return q ; }
public int [ ] ShortStringLength ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = strings . Where ( w => w . Length < 4 ) . Select ( w => w . Length ) . ToArray ( ) ; return selected ; }
public List < Product > InStockProductTakeWhile ( ) { List < Product > products = GetProductList ( ) ; List < Product > firstProductsWhile = products . Where ( p => p . UnitsInStock > 0 ) . TakeWhile ( p => p . ProductId > 100 ) . ToList ( ) ; return firstProductsWhile ; }
public List < Tuple < string , int >> ConvertSelectedTupleToListAndPrint ( ) { object [ ] numbers = { Tuple . Create ( " Alice " , " 50 " ) , Tuple . Create ( " Bob " , 40 ) , Tuple . Create ( " Cathy " , 45 ) } ; List < Tuple < string , int >> strings = numbers . OfType < Tuple < string , int >> ( ) . ToList ( ) ; for ( var i = 0 ; i < strings . Count ; i ++ ) Console . WriteLine ( strings [ i ] . Item1 + " : " + strings [ i ] . Item2 ) ; return strings ; }
public int [ ] TransformIndexHashToInt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] textNums = numbers . Select ( n => numbers [ n * 97 % 10 ] ) . ToArray ( ) ; return textNums ; }
public int ExpensiveOrdersCount ( string region ) { List < Customer > customers = GetCustomerList ( ) ; int count = customers . SelectMany ( c => c . Orders ) . Count ( o => o . Total > 100 ) ; return count ; }
public Dictionary < string , int > ConvertTuplesToDictionary ( ) { List < Tuple < string , int >> scoreRecords = new List < Tuple < string , int >> { Tuple . Create ( " Alice " , 50 ) , Tuple . Create ( " Bob " , 40 ) , Tuple . Create ( " Cathy " , 45 ) } ; Dictionary < string , int > scoreRecordsDict = scoreRecords . ToDictionary ( sr => sr . Item1 , sr => sr . Item2 ) ; return scoreRecordsDict ; }
public double NumbersDoubledAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = numbers . Select ( n => n * 2 ) . Aggregate ( seed , ( a , b ) => a * b ) ; return product ; }
public Dictionary < string , List < double >> ProductGroupUnitPriceDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < double >> productNames = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Select ( p => p . UnitPrice ) . ToList ( ) ) ; return productNames ; }
public int [ ] IntTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = numbers . Select ( n => n * 2 ) . ToArray ( ) ; return numSelected ; }
public List < Tuple < string , double >> CustomerInRegionOrdersTotalMin ( string region ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalMin = customers . Where ( c => c . Region . Equals ( region ) ) . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Min ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalMin ; }
public List < double > OutOfStockProductUnitPrice ( ) { List < Product > products = GetProductList ( ) ; List < double > productNames = products . Where ( p => p . UnitsInStock == 0 ) . Select ( p => p . UnitPrice ) . ToList ( ) ; return productNames ; }
public bool EqualInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; bool equal = numbersA . SequenceEqual ( numbersB ) ; return equal ; }
public Product [ ] ProductsConvertToDescendingArrayAndPrintForeach ( ) { List < Product > products = GetProductList ( ) ; Product [ ] productsArray = products . OrderByDescending ( p => p . UnitPrice ) . ToArray ( ) ; foreach ( Product p in productsArray ) Console . WriteLine ( p ) ; return productsArray ; }
public bool IntAnyMatchInput ( int i ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool anyMatch = numbers . Any ( n => n > i ) ; return anyMatch ; }
public List < string > LongStringIndexedWhere ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > q = words . Where ( w => w . Length > 5 ) . Where ( ( w , i ) => w . Length < i * 3 ) . ToList ( ) ; return q ; }
public List < string > StringOrderbyLengthCustomThenby ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > sortedWords = words . OrderBy ( w => w . Length , new CustomNumberComparer ( ) ) . ThenBy ( w => w ) . ToList ( ) ; return sortedWords ; }
public List < Tuple < String , int >> CountRegionDistinctCustomer ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < String , int >> regionCounts = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . Distinct ( ) . Count ( ) ) ) . ToList ( ) ; return regionCounts ; }
public int [ ] TransformIndexToInt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] textNums = numbers . Select ( n => numbers [ n ] ) . ToArray ( ) ; return textNums ; }
public List < double > DoubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n % 1.5 ) . ThenBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public double ExpensiveProductUnitPriceAggregateAverageWithSeed ( ) { List < Product > products = GetProductList ( ) ; double seed = 15.5 ; double aggregateSum = products . Select ( p => p . UnitPrice ) . Where ( d => d > 100 ) . Aggregate ( seed , ( a , b ) => ( a + b ) / 2 ) ; return aggregateSum ; }
public List < string > ExpensiveProductNameOrderbyDescending ( ) { List < Product > products = GetProductList ( ) ; List < string > sortedProducts = products . Where ( p => p . UnitPrice > 100 ) . Select ( p => p . ProductName ) . OrderByDescending ( n => n ) . ToList ( ) ; return sortedProducts ; }
public char [ ] ProjectionStringExcept ( ) { string [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; string [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = wordsA . Select ( n => n [ 0 ] ) ; var second = wordsB . Select ( n => n [ 0 ] ) ; char [ ] words = first . Except ( second ) . ToArray ( ) ; return words ; }
public Dictionary < string , List < Product >> ProductEachGroupSkip ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> after3EachGroups = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Skip ( 3 ) . ToList ( ) ) ; return after3EachGroups ; }
public List < Tuple < string , Product >> ProductEachCategoryElementAt ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , Product >> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . ElementAt ( 1 ) ) ) . ToList ( ) ; return categories ; }
public List < string > StringOrderbyThenbyLengthCustom ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > sortedWords = words . OrderBy ( w => w ) . ThenBy ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public int DistinctProductCategoryCount ( ) { List < Product > products = GetProductList ( ) ; int count = products . Select ( p => p . Category ) . Distinct ( ) . Count ( ) ; return count ; }
public Dictionary < string , List < Customer >> CustomerEachCountryOrdersMaxCustomerDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < Customer >> customerOrdersMax = customers . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . Where ( c => c . Orders . Count == g . Max ( c => c . Orders . Count ) ) . ToList ( ) ) ; return customerOrdersMax ; }
public int BigNumbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = numbers . Where ( n => n > 5 ) . Min ( n => n * 2 ) ; return minNum ; }
public List < Tuple < string , string >> CustomerIdAndName ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , string >> customerProperties = customers . Select ( c => Tuple . Create ( c . CustomerId , c . CompanyName ) ) . ToList ( ) ; return customerProperties ; }
public List < Tuple < bool , List < Product >>> ProductGroupByInStock ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < bool , List < Product >>> productGroup = products . GroupBy ( p => p . UnitsInStock == 0 ) . Select ( g => Tuple . Create ( g . Key , g . ToList ( ) ) ) . ToList ( ) ; return productGroup ; }
public double [ ] ProjectionDoubleConcat ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = numbersA . Select ( n => n - ( int ) n ) ; var second = numbersB . Select ( n => n - ( int ) n ) ; double [ ] numbers = first . Concat ( second ) . ToArray ( ) ; return numbers ; }
public Product [ ] ProductsConvertToArray ( ) { List < Product > products = GetProductList ( ) ; Product [ ] productsArray = products . OrderBy ( p => p . UnitPrice ) . ToArray ( ) ; return productsArray ; }
public List < double > DoubleOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n - ( int ) n ) . ToList ( ) ; return sortedNumbers ; }
public double ExpensiveProductUnitPriceAverage ( ) { List < Product > products = GetProductList ( ) ; double averageUnitPrice = products . Where ( p => p . UnitPrice > 100 ) . Average ( p => p . UnitPrice ) ; return averageUnitPrice ; }
public List < Product > RepeatedProducts ( ) { List < Product > products = Enumerable . Repeat ( Product . Default , 30 ) . ToList ( ) ; return products ; }
public int ProjectedStringFirstOrDefault ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = strings . Select ( s => s . Length ) . FirstOrDefault ( i => i % 2 == 0 , - 1 ) ; return firstStringLength ; }
public List < Tuple < string , int >> ConvertSelectedTupleToList ( ) { object [ ] numbers = { Tuple . Create ( " Alice " , " 50 " ) , Tuple . Create ( " Bob " , 40 ) , Tuple . Create ( " Cathy " , 45 ) } ; List < Tuple < string , int >> strings = numbers . OfType < Tuple < string , int >> ( ) . ToList ( ) ; return strings ; }
public List < int > IntTakeWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > firstNumbersWhile = numbers . TakeWhile ( i => i > 3 ) . ToList ( ) ; return firstNumbersWhile ; }
public List < Tuple < string , int , string >> CustomerCrossJoinRegionsWithCodeNameRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int , string >> q = regions . Join ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r . Item1 , r . Item2 , c . CompanyName ) ) . ToList ( ) ; return q ; }
public List < Product > ProductsConvertToList ( ) { List < Product > products = GetProductList ( ) ; List < Product > productsList = products . OrderBy ( p => p . UnitPrice ) . ToList ( ) ; return productsList ; }
public List < Product > RepeatedProductsWithBase ( Product product ) { List < Product > products = Enumerable . Repeat ( product , 10 ) . ToList ( ) ; return products ; }
public List < Tuple < string , List < Product >>> ProductGroupByCategoryOrderbyId ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < Product >>> productsGroups = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . OrderBy ( p => p . ProductId ) . ToList ( ) ) ) . ToList ( ) ; return productsGroups ; }
public Dictionary < string , int > CustomerEachRegionOrdersSumDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > ordersTotalSum = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . Sum ( c => c . Orders . Count ) ) ; return ordersTotalSum ; }
public List < string > StringIndexedWhere ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > q = words . Where ( ( w , i ) => w . Length < i ) . ToList ( ) ; return q ; }
public bool CategoryProductAnyMatch ( ) { List < Product > products = GetProductList ( ) ; bool anyMatch = products . Where ( p => p . Category == " Beverages " ) . Any ( p => p . UnitsInStock > 0 ) ; return anyMatch ; }
public List < Tuple < string , Product >> ProductEachCategoryFirst ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , Product >> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . First ( ) ) ) . ToList ( ) ; return categories ; }
public double DoubleFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . First ( ) ; return firstNum ; }
public List < int > ShortStringLengthOrderbyDescending ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < int > sortedWords = words . Where ( w => w . Length < 6 ) . Select ( w => w . Length ) . OrderByDescending ( w => w ) . ToList ( ) ; return sortedWords ; }
public List < double > BigDoubleFractionOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 5 ) . Select ( n => n - ( int ) n ) . OrderBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < string , int > ConvertSelectedTupleToDictionaryAndPrint ( ) { object [ ] numbers = { Tuple . Create ( " Alice " , " 50 " ) , Tuple . Create ( " Bob " , 40 ) , Tuple . Create ( " Cathy " , 45 ) } ; Dictionary < string , int > strings = numbers . OfType < Tuple < string , int >> ( ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; foreach ( var pair in strings ) Console . WriteLine ( pair . Key + " : " + pair . Value ) ; return strings ; }
public double BigDoubleNumbersSum ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numbersSum = numbers . Where ( d => d > 5 ) . Sum ( ) ; return numbersSum ; }
public List < int > IntIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > q = numbers . Where ( ( n , i ) => n < i ) . ToList ( ) ; return q ; }
public int [ ] OddIntPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = numbers . Where ( n => n % 2 == 1 ) . Select ( n => n + 1 ) . ToArray ( ) ; return numSelected ; }
public List < Tuple < bool , List < string >>> StringGroupByLengthOrderbyLengthCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Tuple < bool , List < string >>> wordsGroups = words . GroupBy ( w => w . Length > 8 ) . Select ( g => Tuple . Create ( g . Key , g . OrderBy ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ) ) . ToList ( ) ; return wordsGroups ; }
public List < string > ConcatOfRegion ( ) { string [ ] regions = { " WA " , " AF " , " RO " } ; List < Customer > customers = GetCustomerList ( ) ; var customerRegions = customers . Select ( c => c . Region ) ; List < string > allRegions = customerRegions . Concat ( regions ) . ToList ( ) ; return allRegions ; }
public List < double > DoubleOrderbyFractionThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n - ( int ) n ) . ThenBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public List < Tuple < string , Order >> WaCustomerSelectManyCustomerNewOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Order >> customerProperties = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o ) ) . ToList ( ) ; return customerProperties ; }
public List < Order > CustomerSelectManyNewOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Order > customerProperties = customers . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) ) . ToList ( ) ; return customerProperties ; }
public List < double > BigDoubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 3 ) . OrderBy ( n => n % 1.5 ) . ThenByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public int [ ] IntZipAdd ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int [ ] addNumbers = numbersA . Zip ( numbersB , ( a , b ) => a + b ) . ToArray ( ) ; return addNumbers ; }
public List < Tuple < bool , List < int >>> IntGroupByBool ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Tuple < bool , List < int >>> numberGroups = numbers . GroupBy ( n => n > 4 ) . Select ( g => Tuple . Create ( g . Key , g . ToList ( ) ) ) . ToList ( ) ; return numberGroups ; }
public Dictionary < string , bool > ExpensiveProductEachGroupAllMatch ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , bool > allMatch = products . Where ( p => p . UnitPrice > 100 ) . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . All ( p => p . UnitsInStock > 0 ) ) ; return allMatch ; }
public List < string > ShortStringOrderbyDescendingLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < string > sortedWords = words . Where ( w => w . Length < 6 ) . OrderByDescending ( w => w . Length ) . ToList ( ) ; return sortedWords ; }
public List < Product > ExpensiveProductTakeWhile ( ) { List < Product > products = GetProductList ( ) ; List < Product > firstProductsWhile = products . Where ( p => p . UnitPrice > 100 ) . TakeWhile ( p => p . ProductId > 100 ) . ToList ( ) ; return firstProductsWhile ; }
public List < Tuple < string , double >> CustomerOrdersTotalAverage ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalAverage = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Average ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalAverage ; }
public Dictionary < String , int > CountDistinctProductByCategoryDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < String , int > categoryCounts = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Distinct ( ) . Count ( ) ) ; return categoryCounts ; }
public List < string > StringOrderby ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . OrderBy ( w => w ) . ToList ( ) ; return sortedWords ; }
public List < Tuple < string , double >> ProductCrossGroupJoinCategoriesUnitPrice ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , double >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . SelectMany ( t => t . Item2. Select ( p => p . UnitPrice ) , ( t , n ) => Tuple . Create ( t . Item1 , n ) ) . ToList ( ) ; return q ; }
public double NumbersAggregateFindMin ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double aggregateSum = numbers . Aggregate ( ( a , b ) => Math . Min ( a , b ) ) ; return aggregateSum ; }
public void OddNumbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int i = 0 ; var q = numbers . Where ( n => n % 2 == 1 ) . Select ( n => i += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public Dictionary < string , List < Product >> ProductGroupByCategoryDictOrderbyDescendingId ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> productsGroups = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . OrderByDescending ( p => p . ProductId ) . ToList ( ) ) ; return productsGroups ; }
public bool UnequalStrings ( ) { List < string > wordsA = new List < string > { " Alpha " , " Beta " , " Gamma " } ; List < string > wordsB = new List < string > { " aLPhA " , " bETa " , " gAaMa " } ; bool equal = wordsA . SequenceEqual ( wordsB ) ; return equal ; }
public List < double > DoubleOrderbyDescendingFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderByDescending ( n => n - ( int ) n ) . ToList ( ) ; return sortedNumbers ; }
public List < string > IntersectOfCategory ( ) { string [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = GetProductList ( ) ; var productCategories = products . Select ( p => p . Category ) ; List < string > sharedCategories = productCategories . Intersect ( categories ) . ToList ( ) ; return sharedCategories ; }
public Dictionary < string , List < string >> CustomerGroupJoinRegionsName ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < string >> q = regions . GroupJoin ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c . Select ( c1 => c1. CompanyName ) . ToList ( ) ) ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; return q ; }
public List < Product > ProductSkip ( ) { List < Product > products = GetProductList ( ) ; List < Product > after3Products = products . Skip ( 3 ) . ToList ( ) ; return after3Products ; }
public bool StringAnyMatch ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; bool anyMatch = words . Any ( n => string . CompareOrdinal ( n , " b " ) > 0 ) ; return anyMatch ; }
public List < Tuple < string , List < Customer >>> CustomerGroupByRegion ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , List < Customer >>> catagory = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . ToList ( ) ) ) . ToList ( ) ; return catagory ; }
public void OddNumbersTwiceDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int i = 0 ; var q = numbers . Where ( n => n % 2 == 1 ) . Select ( n => n * 2 ) . Select ( n => i += n ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public int UniqueFactorsCount ( int [ ] factors ) { int factorsCount = factors . Distinct ( ) . Count ( ) ; return factorsCount ; }
public List < Tuple < string , DateTime >> CustomerOrdersEachNestedTakeWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> firstOrdersEachWhile = customers . SelectMany ( c => c . Orders . TakeWhile ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return firstOrdersEachWhile ; }
public string [ ] StringConcat ( ) { string [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; string [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; string [ ] allWords = wordsA . Concat ( wordsB ) . ToArray ( ) ; return allWords ; }
public List < double > DoubleOrderbyFractionDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderByDescending ( n => n - ( int ) n ) . ThenByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < bool , List < int >> IntGroupByBoolDictPrint ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Dictionary < bool , List < int >> numberGroups = numbers . GroupBy ( n => n > 4 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; numberGroups [ true ] . ForEach ( n => Console . Write ( n ) ) ; Console . WriteLine ( ) ; numberGroups [ false ] . ForEach ( n => Console . Write ( n ) ) ; return numberGroups ; }
public List < Tuple < string , DateTime >> CustomerSelectManyCustomerOrderDates ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> customerProperties = customers . SelectMany ( c => c . Orders , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return customerProperties ; }
public List < Tuple < string , string >> CustomerCrossJoinRegionsPhone ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , string >> q = regions . Join ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c . Phone ) ) . ToList ( ) ; return q ; }
public double [ ] DoubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] sharedNumbers = numbersA . Intersect ( numbersB ) . ToArray ( ) ; return sharedNumbers ; }
public List < char > ConcatOfNameFirstChar ( ) { List < Product > products = GetProductList ( ) ; List < Customer > customers = GetCustomerList ( ) ; var productFirstChars = products . Select ( p => p . ProductName [ 0 ] ) ; var customerFirstChars = customers . Select ( c => c . CompanyName [ 0 ] ) ; List < char > allFirstChars = productFirstChars . Concat ( customerFirstChars ) . ToList ( ) ; return allFirstChars ; }
public List < string > UnionOfCategory ( ) { string [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = GetProductList ( ) ; var productCategories = products . Select ( p => p . Category ) ; List < string > uniqueCategories = productCategories . Union ( categories ) . ToList ( ) ; return uniqueCategories ; }
public double NumbersAggregateSqrtWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double aggregateSum = numbers . Aggregate ( seed , ( a , b ) => Math . Sqrt ( a * b ) ) ; return aggregateSum ; }
public List < Product > ProductOrderbyCategoryThenbyDescendingName ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderBy ( p => p . Category ) . ThenByDescending ( p => p . ProductName ) . ToList ( ) ; return sortedProducts ; }
public List < Product > ExpensiveProductOrderbyDescendingName ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . Where ( p => p . UnitPrice > 100 ) . OrderByDescending ( p => p . ProductName ) . ToList ( ) ; return sortedProducts ; }
public List < Tuple < Tuple < string , int > , string >> CustomerLeftOuterJoinRegionsWithCodeNameRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < Tuple < string , int > , string >> q = regions . GroupJoin ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. Select ( c => c . CompanyName ) . DefaultIfEmpty ( " No ▁ Customer " ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public List < int > IntSquareSkip ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > after3Numbers = numbers . Select ( i => i * i ) . Skip ( 3 ) . ToList ( ) ; return after3Numbers ; }
public Tuple < string , bool > [ ] SelectByEvenOdd ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Tuple < string , bool > [ ] evenOddWords = numbers . Select ( n => Tuple . Create ( strings [ n ] , n % 2 == 0 ) ) . ToArray ( ) ; return evenOddWords ; }
public List < Tuple < string , double >> CustomerEachCountryOrdersAverage ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersAverage = customers . GroupBy ( c => c . Country ) . Select ( g => Tuple . Create ( g . Key , g . Average ( c => c . Orders . Count ) ) ) . ToList ( ) ; return ordersAverage ; }
public List < double > DoubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public List < Tuple < Tuple < string , int > , Customer >> CustomerLeftOuterJoinRegionsWithCodeRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < Tuple < string , int > , Customer >> q = regions . GroupJoin ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . SelectMany ( t => t . Item2. DefaultIfEmpty ( null ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public int [ ] BigIntTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = numbers . Where ( n => n > 5 ) . Select ( n => n * 2 ) . ToArray ( ) ; return numSelected ; }
public List < Tuple < string , double >> ExpensiveProductEachCategoryStock ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , double >> categories = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Where ( p => p . UnitPrice > 100 ) . Average ( p => p . UnitsInStock ) ) ) . ToList ( ) ; return categories ; }
public List < Tuple < string , int , Customer >> CustomerCrossJoinRegionsWithCodeRegion ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int , Customer >> q = regions . Join ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r . Item1 , r . Item2 , c ) ) . ToList ( ) ; return q ; }
public List < Tuple < string , List < Customer >>> CustomerEachCountryOrdersFirstCustomer ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , List < Customer >>> customerOrdersFirst = customers . GroupBy ( c => c . Country ) . Select ( g => Tuple . Create ( g . Key , g . Where ( c => c . Orders . Count == g . First ( ) . Orders . Count ) . ToList ( ) ) ) . ToList ( ) ; return customerOrdersFirst ; }
public double ProjectedDoubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . Select ( i => Math . Log2 ( i ) ) . FirstOrDefault ( n => n > 3 , 3.01 ) ; return firstNum ; }
public Dictionary < string , List < string >> ProductGroupNameDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < string >> productNames = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Select ( p => p . ProductName ) . ToList ( ) ) ; return productNames ; }
public List < string > StringSkipCount ( string [ ] strings , int n ) { List < string > afterNWords = strings . Skip ( n ) . ToList ( ) ; return afterNWords ; }
public Dictionary < bool , List < Product >> ProductGroupByInStockDictPrint ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < Product >> productGroup = products . GroupBy ( p => p . UnitsInStock == 0 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; productGroup [ true ] . ForEach ( p => Console . Write ( p ) ) ; Console . WriteLine ( ) ; productGroup [ false ] . ForEach ( p => Console . Write ( p ) ) ; return productGroup ; }
public Dictionary < string , double > CustomerOrdersTotalMinDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalMin = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Min ( o => o . Total ) ) ; return ordersTotalMin ; }
public List < Tuple < string , List < Product >>> ExpensiveProductEachCategoryMinUnitPriceProducts ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < Product >>> categories = products . Where ( p => p . UnitPrice > 100 ) . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Where ( p => p . UnitPrice == g . Min ( p => p . UnitPrice ) ) . ToList ( ) ) ) . ToList ( ) ; return categories ; }
public Dictionary < string , int > CustomerEachCountryOrdersSumDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > ordersTotalSum = customers . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . Sum ( c => c . Orders . Count ) ) ; return ordersTotalSum ; }
public int BigNumbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = numbers . Where ( n => n > 5 ) . Min ( ) ; return minNum ; }
public Dictionary < char , List < string >> StringGroupByFirstCharDictOrderbyDescending ( ) { string [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Dictionary < char , List < string >> wordsGroups = words . GroupBy ( w => w [ 0 ] ) . ToDictionary ( g => g . Key , g => g . OrderByDescending ( w => w ) . ToList ( ) ) ; return wordsGroups ; }
public double ProductUnitPriceAggregateAverageWithSeed ( ) { List < Product > products = GetProductList ( ) ; double seed = 15.5 ; double aggregateSum = products . Select ( p => p . UnitPrice ) . Aggregate ( seed , ( a , b ) => ( a + b ) / 2 ) ; return aggregateSum ; }
public char [ ] ProjectionStringConcat ( ) { string [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; string [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = wordsA . Select ( n => n [ 0 ] ) ; var second = wordsB . Select ( n => n [ 0 ] ) ; char [ ] words = first . Concat ( second ) . ToArray ( ) ; return words ; }
public List < Tuple < string , DateTime >> CustomerSelectManyCustomerNewOrderDates ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> customerProperties = customers . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return customerProperties ; }
public double [ ] DoubleConcat ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] allNumbers = numbersA . Concat ( numbersB ) . ToArray ( ) ; return allNumbers ; }
public List < Tuple < char , List < string >>> StringGroupByFirstCharOrderbyDescending ( ) { string [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Tuple < char , List < string >>> wordsGroups = words . GroupBy ( w => w [ 0 ] ) . Select ( g => Tuple . Create ( g . Key , g . OrderByDescending ( w => w ) . ToList ( ) ) ) . ToList ( ) ; return wordsGroups ; }
public List < string > LongStringSkip ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > after3Words = words . Where ( w => w . Length > 5 ) . Skip ( 3 ) . ToList ( ) ; return after3Words ; }
public List < int > IntTakeWhileIndexedCount ( int [ ] numbers , int n ) { List < int > firstNumbers = numbers . TakeWhile ( ( n , i ) => n > i ) . ToList ( ) ; return firstNumbers ; }
public string StringFirstOrDefaultStartWith ( char c ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string startWithChar = strings . FirstOrDefault ( s => s [ 0 ] == c , " none " ) ; return startWithChar ; }
public Dictionary < bool , List < int >> ProductGroupByPriceWithIdDictPrint ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < int >> productGroup = products . GroupBy ( p => p . UnitPrice > 100 ) . ToDictionary ( g => g . Key , g => g . Select ( p => p . ProductId ) . ToList ( ) ) ; productGroup [ true ] . ForEach ( p => Console . Write ( p ) ) ; Console . WriteLine ( ) ; productGroup [ false ] . ForEach ( p => Console . Write ( p ) ) ; return productGroup ; }
public List < string > ShortStringOrderby ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < string > sortedWords = words . Where ( w => w . Length < 6 ) . OrderBy ( w => w ) . ToList ( ) ; return sortedWords ; }
public bool [ ] BigIntWithOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool [ ] numSelected = numbers . Select ( ( n , i ) => Tuple . Create ( n > 5 , n == i ) ) . Where ( t => t . Item1 ) . Select ( t => t . Item2 ) . ToArray ( ) ; return numSelected ; }
public int NumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = numbers . FirstOrDefault ( - 1 ) ; return firstNum ; }
public int ShortStringMinLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; int minLength = words . Where ( w => w . Length < 7 ) . Min ( w => w . Length ) ; return minLength ; }
public List < double > IntSqrtSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < double > afterNumbers = numbers . Select ( i => Math . Sqrt ( i ) ) . TakeWhile ( ( n , i ) => n > i ) . ToList ( ) ; return afterNumbers ; }
public List < string > LongStringSkipWhile ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > afterWordsWhile = words . Where ( w => w . Length > 5 ) . SkipWhile ( w => w [ 0 ] > ' b ' ) . ToList ( ) ; return afterWordsWhile ; }
public Dictionary < string , List < string >> ProductGroupJoinCategoriesName ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; Dictionary < string , List < string >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p . Select ( p1 => p1. ProductName ) . ToList ( ) ) ) . ToDictionary ( t => t . Item1 , t => t . Item2 ) ; return q ; }
public bool IntSquareAllMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; bool allMatch = numbers . Select ( i => i * i ) . All ( n => n > 3 ) ; return allMatch ; }
public Product [ ] ProductsConvertToDescendingArrayAndPrint ( ) { List < Product > products = GetProductList ( ) ; Product [ ] productsArray = products . OrderByDescending ( p => p . UnitPrice ) . ToArray ( ) ; for ( int i = 0 ; i < productsArray . Length ; i ++ ) Console . WriteLine ( productsArray [ i ] ) ; return productsArray ; }
public List < Tuple < string , DateTime >> CustomerOrdersEachNestedSkipWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> afterOrdersEachWhile = customers . SelectMany ( c => c . Orders . SkipWhile ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return afterOrdersEachWhile ; }
public List < bool > WaCustomerOrdersEachNestedAllMatch ( ) { List < Customer > customers = GetCustomerList ( ) ; List < bool > allMatch = customers . Where ( c => c . Region == " WA " ) . Select ( c => c . Orders . All ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) ) . ToList ( ) ; return allMatch ; }
public Dictionary < string , List < Order >> CustomerEachRegionOrdersTotalMaxCustomerDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < Order >> customerOrdersTotalMax = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . SelectMany ( c => c . Orders ) . Where ( o => o . Total == g . SelectMany ( c => c . Orders ) . Max ( o => o . Total ) ) . ToList ( ) ) ; return customerOrdersTotalMax ; }
public double DoubleSum ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numbersSum = numbers . Sum ( ) ; return numbersSum ; }
public string [ ] StringProjectionZipAdd ( ) { string [ ] wordsA = { " Alpha " , " Beta " , " Gamma " } ; string [ ] wordsB = { " red " , " green " , " blue " } ; string [ ] results = wordsA . Select ( w => w [ 0 ] . ToString ( ) ) . Zip ( wordsB . Select ( w => w [ 0 ] ) , ( a , b ) => a + b ) . ToArray ( ) ; return results ; }
public Dictionary < string , List < Product >> ProductGroupSkipWhile ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> afterGroupsWhile = products . GroupBy ( p => p . Category ) . SkipWhile ( g => g . Key . Length > 6 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return afterGroupsWhile ; }
public List < Tuple < string , List < string >>> ProductGroupName ( ) { List < Product > products = GetProductList ( ) ; List < Tuple < string , List < string >>> productNames = products . GroupBy ( p => p . Category ) . Select ( g => Tuple . Create ( g . Key , g . Select ( p => p . ProductName ) . ToList ( ) ) ) . ToList ( ) ; return productNames ; }
public List < Tuple < int , string >> CustomerCrossGroupJoinRegionsWithCodeName ( ) { List < Tuple < string , int >> regions = new List < Tuple < string , int >> { Tuple . Create ( " BC " , 101 ) , Tuple . Create ( " BC " , 105 ) , Tuple . Create ( " OR " , 121 ) , Tuple . Create ( " LA " , 143 ) } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < int , string >> q = regions . GroupJoin ( customers , r => r . Item1 , c => c . Region , ( r , c ) => Tuple . Create ( r . Item2 , c ) ) . SelectMany ( t => t . Item2. Select ( c => c . CompanyName ) , ( t , c ) => Tuple . Create ( t . Item1 , c ) ) . ToList ( ) ; return q ; }
public Dictionary < string , List < Product >> ProductsConvertGroupingToDictionary ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> catagory = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return catagory ; }
public List < Product > RepeatedProductsWithBaseAndCount ( Product product , int count ) { List < Product > products = Enumerable . Repeat ( product , count ) . ToList ( ) ; return products ; }
public List < int > IntsConvertToList ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < int > intsList = ints . OrderBy ( d => d ) . ToList ( ) ; return intsList ; }
public List < Tuple < char , List < string >>> StringGroupByFirstCharOrderbyCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Tuple < char , List < string >>> wordsGroups = words . GroupBy ( w => char . ToLower ( w [ 0 ] ) ) . Select ( g => Tuple . Create ( g . Key , g . OrderBy ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ) ) . ToList ( ) ; return wordsGroups ; }
public List < Tuple < string , Customer >> CustomerCrossJoinRegions ( ) { string [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , Customer >> q = regions . Join ( customers , r => r , c => c . Region , ( r , c ) => Tuple . Create ( r , c ) ) . ToList ( ) ; return q ; }
public double BigNumbersAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = numbers . Where ( n => n > 2 ) . Aggregate ( ( a , b ) => a * b ) ; return product ; }
public string StringElementAtStartWithO ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string startWithO = strings . Where ( s => s [ 0 ] == ' o ' ) . ElementAt ( 0 ) ; return startWithO ; }
public int AggregateWithdrawMoney ( ) { int [ ] attemptedWithdrawals = { 100 , 20 , 10 , 40 , 50 , 10 , 70 , 30 } ; int endBalance = attemptedWithdrawals . Aggregate ( ( balance , nextWithdrawal ) => nextWithdrawal <= balance ? balance - nextWithdrawal : balance ) ; return 0 ; }
public int [ ] IntZipSub ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int [ ] subNumbers = numbersA . Zip ( numbersB , ( a , b ) => a - b ) . ToArray ( ) ; return subNumbers ; }
public List < int > IntSkipWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > afterNumbers = numbers . SkipWhile ( ( n , i ) => n > i ) . ToList ( ) ; return afterNumbers ; }
public List < string > LongStringTakeWhile ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > firstWordsWhile = words . Where ( w => w . Length > 5 ) . TakeWhile ( w => w [ 0 ] > ' b ' ) . ToList ( ) ; return firstWordsWhile ; }
public string StringElementAtStartWith ( char c ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string startWithChar = strings . Where ( s => s [ 0 ] == c ) . ElementAt ( 2 ) ; return startWithChar ; }
public Dictionary < string , List < Customer >> CustomerEachRegionOrdersMaxCustomerDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < Customer >> customerOrdersMax = customers . GroupBy ( c => c . Region ) . ToDictionary ( g => g . Key , g => g . Where ( c => c . Orders . Count == g . Max ( c => c . Orders . Count ) ) . ToList ( ) ) ; return customerOrdersMax ; }
public bool StringLengthAnyMatch ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; bool anyMatch = words . Select ( w => w . Length ) . Any ( n => n > 5 ) ; return anyMatch ; }
public List < string > StringOrderbyDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < string > sortedWords = words . OrderByDescending ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public string StringFirstOrDefaultLong ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string startsWithO = strings . FirstOrDefault ( s => s . Length > 4 , " empty " ) ; return startsWithO ; }
public bool ProjectionEqualInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 6 , 10 } ; bool equal = numbersA . Select ( n => n + 1 ) . SequenceEqual ( numbersB ) ; return equal ; }
public Dictionary < bool , List < string >> StringGroupByLengthDict ( ) { string [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Dictionary < bool , List < string >> wordsGroups = words . GroupBy ( w => w . Length > 8 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return wordsGroups ; }
public List < double > DoubleOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public string [ ] SelectByStringAndLengthConcat ( ) { string [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; string [ ] upperLowerWords = words . Select ( w => w + w . Length ) . ToArray ( ) ; return upperLowerWords ; }
public List < Tuple < string , int >> CustomerEachRegionOrdersMin ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int >> ordersMin = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . Min ( c => c . Orders . Count ) ) ) . ToList ( ) ; return ordersMin ; }
public double ProjectedDoubleFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . Select ( i => Math . Log ( i ) ) . First ( n => n > 3 ) ; return firstNum ; }
public double ExpensiveProductUnitPriceMin ( ) { List < Product > products = GetProductList ( ) ; double minUnitPrice = products . Where ( p => p . UnitPrice > 100 ) . Min ( p => p . UnitPrice ) ; return minUnitPrice ; }
public List < string > StringOrderbyCustomThenbyLengthDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < string > sortedWords = words . OrderBy ( w => w , new CaseInsensitiveComparer ( ) ) . ThenByDescending ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public int [ ] ProjectionIntUnion ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = numbersA . Select ( n => n + 1 ) ; var second = numbersB . Select ( n => n - 1 ) ; int [ ] numbers = first . Union ( second ) . ToArray ( ) ; return numbers ; }
public string [ ] StringExcept ( ) { string [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; string [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; string [ ] differentWords = wordsA . Except ( wordsB ) . ToArray ( ) ; return differentWords ; }
public Dictionary < char , List < string >> StringGroupByFirstCharDictOrderbyCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Dictionary < char , List < string >> wordsGroups = words . GroupBy ( w => char . ToLower ( w [ 0 ] ) ) . ToDictionary ( g => g . Key , g => g . OrderBy ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ) ; return wordsGroups ; }
public Dictionary < string , int > ExpensiveProductEachCategoryStockDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , int > categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice > 100 ) . Max ( p => p . UnitsInStock ) ) ; return categories ; }
public Dictionary < string , List < Product >> ProductEachCategoryFirstUnitPriceProductsDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice == g . First ( ) . UnitPrice ) . ToList ( ) ) ; return categories ; }
public List < string > StringOrderbyLengthReverse ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . OrderBy ( w => w . Length ) . Reverse ( ) . ToList ( ) ; return sortedWords ; }
public int OddNumbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = numbers . Where ( n => n % 2 == 1 ) . Max ( n => n * 2 ) ; return maxNum ; }
public List < Product > ProductOrderbyId ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderBy ( p => p . ProductId ) . ToList ( ) ; return sortedProducts ; }
public bool ExpensiveProductAllMatch ( ) { List < Product > products = GetProductList ( ) ; bool allMatch = products . Where ( p => p . UnitPrice > 100 ) . All ( p => p . UnitsInStock > 0 ) ; return allMatch ; }
public List < Product > ExpensiveProductOrderbyId ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . Where ( p => p . UnitPrice > 100 ) . OrderBy ( p => p . ProductId ) . ToList ( ) ; return sortedProducts ; }
public double ShortStringAverageLength ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; double averageLength = words . Where ( w => w . Length < 7 ) . Average ( w => w . Length ) ; return averageLength ; }
public int OddNumbersMax ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = numbers . Where ( n => n % 2 == 1 ) . Max ( ) ; return maxNum ; }
public List < double > ExpensiveProductUnitPrice ( ) { List < Product > products = GetProductList ( ) ; List < double > productNames = products . Where ( p => p . UnitPrice > 100 ) . Select ( p => p . UnitPrice ) . ToList ( ) ; return productNames ; }
public double [ ] ProjectionDoubleExcept ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = numbersA . Select ( n => n - ( int ) n ) ; var second = numbersB . Select ( n => n - ( int ) n ) ; double [ ] numbers = first . Except ( second ) . ToArray ( ) ; return numbers ; }
public List < Tuple < string , string >> ProductCrossGroupJoinCategoriesName ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , string >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . SelectMany ( t => t . Item2. Select ( p => p . ProductName ) , ( t , n ) => Tuple . Create ( t . Item1 , n ) ) . ToList ( ) ; return q ; }
public Dictionary < bool , List < Product >> ProductGroupByPriceDictPrint ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < Product >> productGroup = products . GroupBy ( p => p . UnitPrice > 100 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; productGroup [ true ] . ForEach ( p => Console . Write ( p ) ) ; Console . WriteLine ( ) ; productGroup [ false ] . ForEach ( p => Console . Write ( p ) ) ; return productGroup ; }
public int [ ] IntsConvertToArrayAndPrintForeach ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; int [ ] intsArray = ints . OrderBy ( d => d ) . ToArray ( ) ; foreach ( int i in intsArray ) Console . WriteLine ( i ) ; return intsArray ; }
public List < Product > InStockProductSkipWhile ( ) { List < Product > products = GetProductList ( ) ; List < Product > afterProductsWhile = products . Where ( p => p . UnitsInStock > 0 ) . SkipWhile ( p => p . ProductId > 100 ) . ToList ( ) ; return afterProductsWhile ; }
public int OddNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = numbers . First ( n => n % 2 == 1 ) ; return firstNum ; }
public int TotalOrdersCount ( string region ) { List < Customer > customers = GetCustomerList ( ) ; int count = customers . SelectMany ( c => c . Orders ) . Count ( ) ; return count ; }
public Dictionary < char , List < string >> StringGroupByFirstCharDict ( ) { string [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Dictionary < char , List < string >> wordsGroups = words . GroupBy ( w => w [ 0 ] ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return wordsGroups ; }
public List < string > StringReverse ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " } ; List < string > sortedWords = words . Reverse ( ) . ToList ( ) ; return sortedWords ; }
public Dictionary < string , int > CustomerEachCountryOrdersMaxDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , int > ordersMax = customers . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . Max ( c => c . Orders . Count ) ) ; return ordersMax ; }
public double BigNumbersAverage ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = numbers . Where ( n => n > 5 ) . Average ( ) ; return averageNum ; }
public void OddNumbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int i = 0 ; var q = numbers . Where ( n => n % 2 == 1 ) . Select ( n => n * 2 ) . Select ( n => i += n ) . ToList ( ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + i ) ; }
public Dictionary < int , bool > RangeOfIntsToDict ( ) { Dictionary < int , bool > numbers = Enumerable . Range ( 0 , 100 ) . ToDictionary ( n => n , n => n % 2 == 0 ) ; return numbers ; }
public List < int > IntsConvertToDescendingListAndPrint ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < int > intsList = ints . OrderByDescending ( d => d ) . ToList ( ) ; for ( int i = 0 ; i < intsList . Count ; i ++ ) Console . WriteLine ( intsList [ i ] ) ; return intsList ; }
public Dictionary < string , List < Customer >> CustomerEachCountryOrdersFirstCustomerDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , List < Customer >> customerOrdersFirst = customers . GroupBy ( c => c . Country ) . ToDictionary ( g => g . Key , g => g . Where ( c => c . Orders . Count == g . First ( ) . Orders . Count ) . ToList ( ) ) ; return customerOrdersFirst ; }
public List < Tuple < string , double >> CustomerEachRegionOrdersTotalMax ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalMax = customers . GroupBy ( c => c . Region ) . Select ( g => Tuple . Create ( g . Key , g . SelectMany ( c => c . Orders ) . Max ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalMax ; }
public List < double > BigDoubleFractionOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . Where ( n => n > 5 ) . Select ( n => n - ( int ) n ) . OrderByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < bool , List < Product >> ProductGroupByInStockDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < Product >> productGroup = products . GroupBy ( p => p . UnitsInStock == 0 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return productGroup ; }
public int UniqueFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int uniqueFactorsCount = factorsOf300. Distinct ( ) . Count ( ) ; return uniqueFactorsCount ; }
public bool LongStringAllMatch ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; bool allMatch = words . Where ( w => w . Length > 5 ) . All ( n => string . CompareOrdinal ( n , " b " ) > 0 ) ; return allMatch ; }
public List < Product > ProductTakeWhile ( ) { List < Product > products = GetProductList ( ) ; List < Product > firstProductsWhile = products . TakeWhile ( p => p . ProductId > 100 ) . ToList ( ) ; return firstProductsWhile ; }
public int OddNumbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = numbers . Where ( n => n % 2 == 1 ) . Min ( n => n * 2 ) ; return minNum ; }
public void BigDoubleNumbersDeferred ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double d = 0 ; var q = numbers . Where ( d => d > 5 ) . Select ( n => d += n ) ; foreach ( var v in q ) Console . Write ( v + " ▁ " + d ) ; }
public List < Tuple < string , DateTime >> WaCustomerOrdersEachNestedTakeWhile ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> firstOrdersEachWhile = customers . Where ( c => c . Region == " WA " ) . SelectMany ( c => c . Orders . TakeWhile ( o => o . OrderDate > new DateTime ( 2000 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return firstOrdersEachWhile ; }
public Dictionary < string , int > ExpensiveProductEachCategoryStockDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , int > categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice > 100 ) . Sum ( p => p . UnitsInStock ) ) ; return categories ; }
public List < string > StringOrderbyThenbyLengthDescendingCustom ( ) { string [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < string > sortedWords = words . OrderBy ( w => w ) . ThenByDescending ( w => w . Length , new CustomNumberComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public double BigDoubleNumbersFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . FirstOrDefault ( d => d > 5 , - 2.3 ) ; return firstNum ; }
public Dictionary < string , double > CustomerInRegionOrdersTotalSumDict ( string region ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalSum = customers . Where ( c => c . Region . Equals ( region ) ) . ToDictionary ( c => c . CustomerId , c => c . Orders . Sum ( o => o . Total ) ) ; return ordersTotalSum ; }
public List < double > DoubleOrderbyFractionDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderByDescending ( n => n - ( int ) n ) . ThenBy ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public Dictionary < string , List < Product >> ProductGroupSkip ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> after3Groups = products . GroupBy ( p => p . Category ) . Skip ( 3 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return after3Groups ; }
public Dictionary < bool , List < Product >> ProductGroupByPriceDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < bool , List < Product >> productGroup = products . GroupBy ( p => p . UnitPrice > 100 ) . ToDictionary ( g => g . Key , g => g . ToList ( ) ) ; return productGroup ; }
public int NumbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = numbers . Min ( ) ; return minNum ; }
public List < string > ExpensiveProductNameOrderby ( ) { List < Product > products = GetProductList ( ) ; List < string > sortedProducts = products . Where ( p => p . UnitPrice > 100 ) . Select ( p => p . ProductName ) . OrderBy ( n => n ) . ToList ( ) ; return sortedProducts ; }
public bool ProjectionEqualDoubles ( ) { double [ ] numbersA = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; double [ ] numbersB = { 6.5 , 1.3 , 8.7 , 2.4 , 4.8 } ; bool equal = numbersA . Select ( n => n - ( int ) n ) . SequenceEqual ( numbersB . Select ( n => n - ( int ) n ) ) ; return equal ; }
public List < Product > ProductOrderbyCategoryThenbyDescendingId ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderBy ( p => p . Category ) . ThenByDescending ( p => p . ProductId ) . ToList ( ) ; return sortedProducts ; }
public List < string > ShortStringOrderbyCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < string > sortedWords = words . Where ( w => w . Length < 6 ) . OrderBy ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ; return sortedWords ; }
public List < Product > ProductOrderbyName ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderBy ( p => p . ProductName ) . ToList ( ) ; return sortedProducts ; }
public List < Product > ProductOrderbyCategoryThenbyName ( ) { List < Product > products = GetProductList ( ) ; List < Product > sortedProducts = products . OrderBy ( p => p . Category ) . ThenBy ( p => p . ProductName ) . ToList ( ) ; return sortedProducts ; }
public bool ProjectionEqualStrings ( ) { List < string > wordsA = new List < string > { " Alpha " , " Beta " , " Gamma " } ; List < string > wordsB = new List < string > { " aLPhA " , " bETa " , " gAaMa " } ; bool equal = wordsA . Select ( w => w . ToLower ( ) ) . SequenceEqual ( wordsB . Select ( w => w . ToLower ( ) ) ) ; return equal ; }
public List < Order > CustomerSelectManyBigOrders ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Order > customerProperties = customers . SelectMany ( c => c . Orders . Where ( o => o . Total > 100 ) ) . ToList ( ) ; return customerProperties ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( field_1_vcenter ) ; }
public virtual void AddAll ( NGit . Util . BlockList < T > src ) { if ( src . size == 0 ) { return ; } int srcDirIdx = 0 ; for ( ; srcDirIdx < src . tailDirIdx ; srcDirIdx ++ ) { AddAll ( src . directory [ srcDirIdx ] , 0 , BLOCK_SIZE ) ; } if ( src . tailBlkIdx != 0 ) { AddAll ( src . tailBlock , 0 , src . tailBlkIdx ) ; } }
public override void WriteByte ( byte b ) { if ( outerInstance . upto == outerInstance . blockSize ) { if ( outerInstance . currentBlock != null ) { outerInstance . blocks . Add ( outerInstance . currentBlock ) ; outerInstance . blockEnd . Add ( outerInstance . upto ) ; } outerInstance . currentBlock = new byte [ outerInstance . blockSize ] ; outerInstance . upto = 0 ; } outerInstance . currentBlock [ outerInstance . upto ++ ] = ( byte ) b ; }
public virtual ObjectId GetObjectId ( ) { return objectId ; }
public virtual DeleteDomainEntryResponse DeleteDomainEntry ( DeleteDomainEntryRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteDomainEntryRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteDomainEntryResponseUnmarshaller . Instance ; return Invoke < DeleteDomainEntryResponse > ( request , options ) ; }
public virtual long RamBytesUsed ( ) { return fst == null ? 0 : fst . GetSizeInBytes ( ) ; }
public string GetFullMessage ( ) { byte [ ] raw = buffer ; int msgB = RawParseUtils . TagMessage ( raw , 0 ) ; if ( msgB < 0 ) { return string . Empty ; } Encoding enc = RawParseUtils . ParseEncoding ( raw ) ; return RawParseUtils . Decode ( enc , raw , msgB , raw . Length ) ; }
public POIFSFileSystem ( ) { HeaderBlock headerBlock = new HeaderBlock ( bigBlockSize ) ; _property_table = new PropertyTable ( headerBlock ) ; _documents = new ArrayList ( ) ; _root = null ; }
public void Init ( int address ) { slice = pool . Buffers [ address >> ByteBlockPool . BYTE_BLOCK_SHIFT ] ; Debug . Assert ( slice != null ) ; upto = address & ByteBlockPool . BYTE_BLOCK_MASK ; offset0 = address ; Debug . Assert ( upto < slice . Length ) ; }
public virtual NGit . Api . SubmoduleAddCommand SetPath ( string path ) { this . path = path ; return this ; }
public virtual ListIngestionsResponse ListIngestions ( ListIngestionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListIngestionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListIngestionsResponseUnmarshaller . Instance ; return Invoke < ListIngestionsResponse > ( request , options ) ; }
public QueryParserTokenManager ( ICharStream stream , int lexState ) : this ( stream ) { SwitchTo ( lexState ) ; }
public virtual GetShardIteratorResponse GetShardIterator ( GetShardIteratorRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetShardIteratorRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetShardIteratorResponseUnmarshaller . Instance ; return Invoke < GetShardIteratorResponse > ( request , options ) ; }
public ModifyStrategyRequest ( ) : base ( " aegis " , " 2016 - 11 - 11 " , " ModifyStrategy " , " vipaegis " , " openAPI " ) { Method = MethodType . POST ; }
public override bool ready ( ) { lock ( @ lock ) { if ( @ in == null ) { throw new System . IO . IOException ( " InputStreamReader ▁ is ▁ closed " ) ; } try { return bytes . hasRemaining ( ) || @ in . available ( ) > 0 ; } catch ( System . IO . IOException ) { return false ; } } }
protected internal EscherOptRecord GetOptRecord ( ) { return _optRecord ; }
public override int read ( byte [ ] buffer , int offset , int length ) { lock ( this ) { if ( buffer == null ) { throw new System . ArgumentNullException ( " buffer ▁ == ▁ null " ) ; } java . util . Arrays . checkOffsetAndCount ( buffer . Length , offset , length ) ; if ( length == 0 ) { return 0 ; } int copylen = count - pos < length ? count - pos : length ; { for ( int i = 0 ; i < copylen ; i ++ ) { buffer [ offset + i ] = unchecked ( ( byte ) this . buffer [ pos + i ] ) ; } } pos += copylen ; return copylen ; } }
public OpenNLPSentenceBreakIterator ( NLPSentenceDetectorOp sentenceOp ) { this . sentenceOp = sentenceOp ; }
public virtual void print ( string str ) { write ( str != null ? str : Sharpen . StringHelper . GetValueOf ( ( object ) null ) ) ; }
public NotImplementedFunctionException ( string functionName , NotImplementedException cause ) : base ( functionName , cause ) { this . functionName = functionName ; }
public override V next ( ) { return this . nextEntry ( ) . value ; }
public override sealed void ReadBytes ( byte [ ] b , int offset , int len , bool useBuffer ) { int available = bufferLength - bufferPosition ; if ( len <= available ) { if ( len > 0 ) { Buffer . BlockCopy ( m_buffer , bufferPosition , b , offset , len ) ; } bufferPosition += len ; } else { if ( available > 0 ) { Buffer . BlockCopy ( m_buffer , bufferPosition , b , offset , available ) ; offset += available ; len -= available ; bufferPosition += available ; } if ( useBuffer && len < bufferSize ) { Refill ( ) ; if ( bufferLength < len ) { Buffer . BlockCopy ( m_buffer , 0 , b , offset , bufferLength ) ; throw new EndOfStreamException ( " read ▁ past ▁ EOF : ▁ " + this ) ; } else { Buffer . BlockCopy ( m_buffer , 0 , b , offset , len ) ; bufferPosition = len ; } } else { long after = bufferStart + bufferPosition + len ; if ( after > Length ) { throw new EndOfStreamException ( " read ▁ past ▁ EOF : ▁ " + this ) ; } ReadInternal ( b , offset , len ) ; bufferStart = after ; bufferPosition = 0 ; bufferLength = 0 ; } } }
public virtual TagQueueResponse TagQueue ( TagQueueRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = TagQueueRequestMarshaller . Instance ; options . ResponseUnmarshaller = TagQueueResponseUnmarshaller . Instance ; return Invoke < TagQueueResponse > ( request , options ) ; }
public override void Remove ( ) { throw new NotSupportedException ( ) ; }
public virtual ModifyCacheSubnetGroupResponse ModifyCacheSubnetGroup ( ModifyCacheSubnetGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ModifyCacheSubnetGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = ModifyCacheSubnetGroupResponseUnmarshaller . Instance ; return Invoke < ModifyCacheSubnetGroupResponse > ( request , options ) ; }
public override void SetParams ( string @ params ) { base . SetParams ( @ params ) ; culture = " " ; string ignore ; StringTokenizer st = new StringTokenizer ( @ params , " , " ) ; if ( st . MoveNext ( ) ) culture = st . Current ; if ( st . MoveNext ( ) ) culture += " - " + st . Current ; if ( st . MoveNext ( ) ) ignore = st . Current ; }
public virtual DeleteDocumentationVersionResponse DeleteDocumentationVersion ( DeleteDocumentationVersionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteDocumentationVersionRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteDocumentationVersionResponseUnmarshaller . Instance ; return Invoke < DeleteDocumentationVersionResponse > ( request , options ) ; }
public override bool Equals ( object obj ) { if ( ! ( obj is FacetLabel ) ) { return false ; } FacetLabel other = ( FacetLabel ) obj ; if ( Length != other . Length ) { return false ; } for ( int i = Length - 1 ; i >= 0 ; i -- ) { if ( ! Components [ i ] . Equals ( other . Components [ i ] , StringComparison . Ordinal ) ) { return false ; } } return true ; }
public virtual GetInstanceAccessDetailsResponse GetInstanceAccessDetails ( GetInstanceAccessDetailsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetInstanceAccessDetailsRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetInstanceAccessDetailsResponseUnmarshaller . Instance ; return Invoke < GetInstanceAccessDetailsResponse > ( request , options ) ; }
public HSSFPolygon CreatePolygon ( HSSFChildAnchor anchor ) { HSSFPolygon shape = new HSSFPolygon ( this , anchor ) ; shape . Parent = this ; shape . Anchor = anchor ; shapes . Add ( shape ) ; OnCreate ( shape ) ; return shape ; }
public String GetSheetName ( int sheetIndex ) { return GetBoundSheetRec ( sheetIndex ) . Sheetname ; }
public virtual GetDashboardResponse GetDashboard ( GetDashboardRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetDashboardRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetDashboardResponseUnmarshaller . Instance ; return Invoke < GetDashboardResponse > ( request , options ) ; }
public virtual AssociateSigninDelegateGroupsWithAccountResponse AssociateSigninDelegateGroupsWithAccount ( AssociateSigninDelegateGroupsWithAccountRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AssociateSigninDelegateGroupsWithAccountRequestMarshaller . Instance ; options . ResponseUnmarshaller = AssociateSigninDelegateGroupsWithAccountResponseUnmarshaller . Instance ; return Invoke < AssociateSigninDelegateGroupsWithAccountResponse > ( request , options ) ; }
public void AddMultipleBlanks ( MulBlankRecord mbr ) { for ( int j = 0 ; j < mbr . NumColumns ; j ++ ) { BlankRecord br = new BlankRecord ( ) ; br . Column = j + mbr . FirstColumn ; br . Row = mbr . Row ; br . XFIndex = ( mbr . GetXFAt ( j ) ) ; InsertCell ( br ) ; } }
public static string quote ( string @ string ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( " \\ Q " ) ; int apos = 0 ; int k ; while ( ( k = @ string . IndexOf ( " \\ E " , apos ) ) >= 0 ) { sb . append ( Sharpen . StringHelper . Substring ( @ string , apos , k + 2 ) ) . append ( " \\\\ E \\ Q " ) ; apos = k + 2 ; } return sb . append ( Sharpen . StringHelper . Substring ( @ string , apos ) ) . append ( " \\ E " ) . ToString ( ) ; }
public override java . nio . ByteBuffer putInt ( int value ) { throw new java . nio . ReadOnlyBufferException ( ) ; }
public ArrayPtg ( Object [ ] [ ] values2d ) { int nColumns = values2d [ 0 ] . Length ; int nRows = values2d . Length ; _nColumns = ( short ) nColumns ; _nRows = ( short ) nRows ; Object [ ] vv = new Object [ _nColumns * _nRows ] ; for ( int r = 0 ; r < nRows ; r ++ ) { Object [ ] rowData = values2d [ r ] ; for ( int c = 0 ; c < nColumns ; c ++ ) { vv [ GetValueIndex ( c , r ) ] = rowData [ c ] ; } } _arrayValues = vv ; _reserved0Int = 0 ; _reserved1Short = 0 ; _reserved2Byte = 0 ; }
public virtual GetIceServerConfigResponse GetIceServerConfig ( GetIceServerConfigRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetIceServerConfigRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetIceServerConfigResponseUnmarshaller . Instance ; return Invoke < GetIceServerConfigResponse > ( request , options ) ; }
public override String ToString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . Append ( GetType ( ) . Name ) . Append ( " ▁ [ " ) ; sb . Append ( GetValueAsString ( ) ) ; sb . Append ( " ] " ) ; return sb . ToString ( ) ; }
public override string ToString ( string field ) { return " ToChildBlockJoinQuery ▁ ( " + _parentQuery + " ) " ; }
public void IncRef ( ) { refCount . IncrementAndGet ( ) ; }
public virtual UpdateConfigurationSetSendingEnabledResponse UpdateConfigurationSetSendingEnabled ( UpdateConfigurationSetSendingEnabledRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateConfigurationSetSendingEnabledRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateConfigurationSetSendingEnabledResponseUnmarshaller . Instance ; return Invoke < UpdateConfigurationSetSendingEnabledResponse > ( request , options ) ; }
public int GetNextXBATChainOffset ( ) { return GetXBATEntriesPerBlock ( ) * LittleEndianConsts . INT_SIZE ; }
public void multiplyByPowerOfTen ( int pow10 ) { TenPower tp = TenPower . GetInstance ( Math . Abs ( pow10 ) ) ; if ( pow10 < 0 ) { mulShift ( tp . _divisor , tp . _divisorShift ) ; } else { mulShift ( tp . _multiplicand , tp . _multiplierShift ) ; } }
public override string ToString ( ) { StringBuilder builder = new StringBuilder ( ) ; int length = this . Length ; builder . Append ( Path . DirectorySeparatorChar ) ; for ( int i = 0 ; i < length ; i ++ ) { builder . Append ( this . GetComponent ( i ) ) ; if ( i < ( length - 1 ) ) { builder . Append ( Path . DirectorySeparatorChar ) ; } } return builder . ToString ( ) ; }
public void withFetcher ( ECSMetadataServiceCredentialsFetcher fetcher ) { this . fetcher = fetcher ; this . fetcher . SetRoleName ( roleName ) ; }
public virtual void SetProgressMonitor ( ProgressMonitor pm ) { progressMonitor = pm ; }
public override void Reset ( ) { if ( ! First ) { ptr = 0 ; if ( ! Eof ) { ParseEntry ( ) ; } } }
public E previous ( ) { if ( iterator . previousIndex ( ) >= start ) { return iterator . previous ( ) ; } throw new java . util . NoSuchElementException ( ) ; }
public virtual string GetNewPrefix ( ) { return this . newPrefix ; }
public virtual int indexOfValue ( int value ) { { for ( int i = 0 ; i < mSize ; i ++ ) { if ( mValues [ i ] == value ) { return i ; } } } return - 1 ; }
public IList < CharsRef > UniqueStems ( char [ ] word , int length ) { IList < CharsRef > stems = Stem ( word , length ) ; if ( stems . Count < 2 ) { return stems ; } CharArraySet terms = new CharArraySet ( LuceneVersion . LUCENE_CURRENT , 8 , dictionary . ignoreCase ) ; IList < CharsRef > deduped = new List < CharsRef > ( ) ; foreach ( CharsRef s in stems ) { if ( ! terms . Contains ( s ) ) { deduped . Add ( s ) ; terms . Add ( s ) ; } } return deduped ; }
public virtual GetGatewayResponsesResponse GetGatewayResponses ( GetGatewayResponsesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetGatewayResponsesRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetGatewayResponsesResponseUnmarshaller . Instance ; return Invoke < GetGatewayResponsesResponse > ( request , options ) ; }
public void SetPosition ( long position ) { currentBlockIndex = ( int ) ( position >> outerInstance . blockBits ) ; currentBlock = outerInstance . blocks [ currentBlockIndex ] ; currentBlockUpto = ( int ) ( position & outerInstance . blockMask ) ; }
public override long Skip ( long n ) { int s = ( int ) Math . Min ( Available ( ) , Math . Max ( 0 , n ) ) ; ptr += s ; return s ; }
public BootstrapActionDetail ( BootstrapActionConfig bootstrapActionConfig ) { _bootstrapActionConfig = bootstrapActionConfig ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( field_1_row ) ; out1. WriteShort ( field_2_col ) ; out1. WriteShort ( field_3_flags ) ; out1. WriteShort ( field_4_shapeid ) ; out1. WriteShort ( field_6_author . Length ) ; out1. WriteByte ( field_5_hasMultibyte ? 0x01 : 0x00 ) ; if ( field_5_hasMultibyte ) { StringUtil . PutUnicodeLE ( field_6_author , out1 ) ; } else { StringUtil . PutCompressedUnicode ( field_6_author , out1 ) ; } if ( field_7_padding != null ) { out1. WriteByte ( Convert . ToInt32 ( field_7_padding , CultureInfo . InvariantCulture ) ) ; } }
public virtual int lastIndexOf ( string @ string ) { return lastIndexOf ( @ string , count ) ; }
public override bool add ( E @ object ) { return addLastImpl ( @ object ) ; }
public virtual void UnsetSection ( string section , string subsection ) { ConfigSnapshot src ; ConfigSnapshot res ; do { src = state . Get ( ) ; res = UnsetSection ( src , section , subsection ) ; } while ( ! state . CompareAndSet ( src , res ) ) ; }
public string GetTagName ( ) { return tagName ; }
public void AddSubRecord ( int index , SubRecord element ) { subrecords . Insert ( index , element ) ; }
public virtual bool remove ( object @ object ) { lock ( mutex ) { return c . remove ( @ object ) ; } }
public override TokenStream Create ( TokenStream input ) { return new DoubleMetaphoneFilter ( input , maxCodeLength , inject ) ; }
public virtual long Length ( ) { return InCoreLength ( ) ; }
public virtual void SetValue ( bool newValue ) { value = newValue ; }
public Pair ( ContentSource oldSource , ContentSource newSource ) { this . oldSource = oldSource ; this . newSource = newSource ; }
public virtual int Get ( int i ) { if ( count <= i ) { throw Sharpen . Extensions . CreateIndexOutOfRangeException ( i ) ; } return entries [ i ] ; }
public CreateRepoRequest ( ) : base ( " cr " , " 2016 - 06 - 07 " , " CreateRepo " , " cr " , " openAPI " ) { UriPattern = " / repos " ; Method = MethodType . PUT ; }
public virtual bool IsDeltaBaseAsOffset ( ) { return deltaBaseAsOffset ; }
public void remove ( ) { if ( expectedModCount == list . modCount ) { if ( lastLink != null ) { java . util . LinkedList . Link < ET > next_1 = lastLink . next ; java . util . LinkedList . Link < ET > previous_1 = lastLink . previous ; next_1. previous = previous_1 ; previous_1. next = next_1 ; if ( lastLink == link ) { pos -- ; } link = previous_1 ; lastLink = null ; expectedModCount ++ ; list . _size -- ; list . modCount ++ ; } else { throw new System . InvalidOperationException ( ) ; } } else { throw new java . util . ConcurrentModificationException ( ) ; } }
public virtual MergeShardsResponse MergeShards ( MergeShardsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = MergeShardsRequestMarshaller . Instance ; options . ResponseUnmarshaller = MergeShardsResponseUnmarshaller . Instance ; return Invoke < MergeShardsResponse > ( request , options ) ; }
public virtual AllocateHostedConnectionResponse AllocateHostedConnection ( AllocateHostedConnectionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AllocateHostedConnectionRequestMarshaller . Instance ; options . ResponseUnmarshaller = AllocateHostedConnectionResponseUnmarshaller . Instance ; return Invoke < AllocateHostedConnectionResponse > ( request , options ) ; }
public int getBeginIndex ( ) { return start ; }
public static WeightedTerm [ ] GetTerms ( Query query ) { return GetTerms ( query , false ) ; }
public override java . nio . ByteBuffer compact ( ) { throw new java . nio . ReadOnlyBufferException ( ) ; }
public override void Decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { int byte0 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( int ) ( ( uint ) byte0 >> 2 ) ; int byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte0 & 3 ) << 4 ) | ( ( int ) ( ( uint ) byte1 >> 4 ) ) ; int byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 15 ) << 2 ) | ( ( int ) ( ( uint ) byte2 >> 6 ) ) ; values [ valuesOffset ++ ] = byte2 & 63 ; } }
public virtual string GetHumanishName ( ) { if ( string . Empty . Equals ( GetPath ( ) ) || GetPath ( ) == null ) { throw new ArgumentException ( ) ; } string s = GetPath ( ) ; string [ ] elements ; if ( " file " . Equals ( scheme ) || LOCAL_FILE . Matcher ( s ) . Matches ( ) ) { elements = s . Split ( " [ \\ " ▁ + ▁ FilePath . separatorChar ▁ + ▁ " / ] " ) ; } else { elements ▁ = ▁ s . Split ( " / " ) ; } if ▁ ( elements . Length ▁ == ▁ 0 ) { throw ▁ new ▁ ArgumentException ( ) ; } string ▁ result ▁ = ▁ elements [ elements . Length ▁ - ▁ 1 ] ; if ▁ ( Constants . DOT □ GIT . Equals ( result ) ) { result ▁ = ▁ elements [ elements . Length ▁ - ▁ 2 ] ; } else { if ▁ ( result . EndsWith ( Constants . DOT □ GIT □ EXT ) ) { result ▁ = ▁ Sharpen . Runtime . Substring ( result , ▁ 0 , ▁ result . Length ▁ - ▁ Constants . DOT □ GIT □ EXT . Length ) ; } } return ▁ result ; }
public virtual DescribeNotebookInstanceLifecycleConfigResponse DescribeNotebookInstanceLifecycleConfig ( DescribeNotebookInstanceLifecycleConfigRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeNotebookInstanceLifecycleConfigRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeNotebookInstanceLifecycleConfigResponseUnmarshaller . Instance ; return Invoke < DescribeNotebookInstanceLifecycleConfigResponse > ( request , options ) ; }
public string GetAccessKeySecret ( ) { return AccessSecret ; }
public virtual CreateVpnConnectionResponse CreateVpnConnection ( CreateVpnConnectionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateVpnConnectionRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateVpnConnectionResponseUnmarshaller . Instance ; return Invoke < CreateVpnConnectionResponse > ( request , options ) ; }
public virtual DescribeVoicesResponse DescribeVoices ( DescribeVoicesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeVoicesRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeVoicesResponseUnmarshaller . Instance ; return Invoke < DescribeVoicesResponse > ( request , options ) ; }
public virtual ListMonitoringExecutionsResponse ListMonitoringExecutions ( ListMonitoringExecutionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListMonitoringExecutionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListMonitoringExecutionsResponseUnmarshaller . Instance ; return Invoke < ListMonitoringExecutionsResponse > ( request , options ) ; }
public DescribeJobRequest ( string vaultName , string jobId ) { _vaultName = vaultName ; _jobId = jobId ; }
public EscherRecord GetEscherRecord ( int index ) { return escherRecords [ index ] ; }
public virtual GetApisResponse GetApis ( GetApisRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetApisRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetApisResponseUnmarshaller . Instance ; return Invoke < GetApisResponse > ( request , options ) ; }
public virtual DeleteSmsChannelResponse DeleteSmsChannel ( DeleteSmsChannelRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteSmsChannelRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteSmsChannelResponseUnmarshaller . Instance ; return Invoke < DeleteSmsChannelResponse > ( request , options ) ; }
public virtual TrackingRefUpdate GetTrackingRefUpdate ( ) { return trackingRefUpdate ; }
public virtual void print ( bool b ) { print ( b . ToString ( ) ) ; }
public virtual IQueryNode GetChild ( ) { return GetChildren ( ) [ 0 ] ; }
public NotIgnoredFilter ( int workdirTreeIndex ) { this . index = workdirTreeIndex ; }
public AreaRecord ( RecordInputStream in1 ) { field_1_formatFlags = in1. ReadShort ( ) ; }
public GetThumbnailRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetThumbnail " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public virtual DescribeTransitGatewayVpcAttachmentsResponse DescribeTransitGatewayVpcAttachments ( DescribeTransitGatewayVpcAttachmentsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeTransitGatewayVpcAttachmentsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeTransitGatewayVpcAttachmentsResponseUnmarshaller . Instance ; return Invoke < DescribeTransitGatewayVpcAttachmentsResponse > ( request , options ) ; }
public virtual PutVoiceConnectorStreamingConfigurationResponse PutVoiceConnectorStreamingConfiguration ( PutVoiceConnectorStreamingConfigurationRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = PutVoiceConnectorStreamingConfigurationRequestMarshaller . Instance ; options . ResponseUnmarshaller = PutVoiceConnectorStreamingConfigurationResponseUnmarshaller . Instance ; return Invoke < PutVoiceConnectorStreamingConfigurationResponse > ( request , options ) ; }
public override OrdRange GetOrdRange ( string dim ) { OrdRange result ; prefixToOrdRange . TryGetValue ( dim , out result ) ; return result ; }
public override string ToString ( ) { string symbol = string . Empty ; if ( startIndex >= 0 && startIndex < ( ( ICharStream ) InputStream ) . Size ) { symbol = ( ( ICharStream ) InputStream ) . GetText ( Interval . Of ( startIndex , startIndex ) ) ; symbol = Utils . EscapeWhitespace ( symbol , false ) ; } return string . Format ( CultureInfo . CurrentCulture , " { 0 } ( ' { 1 } ' ) " , typeof ( Antlr4. Runtime . LexerNoViableAltException ) . Name , symbol ) ; }
public virtual E peek ( ) { return peekFirstImpl ( ) ; }
public virtual CreateWorkspacesResponse CreateWorkspaces ( CreateWorkspacesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateWorkspacesRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateWorkspacesResponseUnmarshaller . Instance ; return Invoke < CreateWorkspacesResponse > ( request , options ) ; }
public override Object Clone ( ) { NumberFormatIndexRecord rec = new NumberFormatIndexRecord ( ) ; rec . field_1_formatIndex = field_1_formatIndex ; return rec ; }
public virtual DescribeRepositoriesResponse DescribeRepositories ( DescribeRepositoriesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeRepositoriesRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeRepositoriesResponseUnmarshaller . Instance ; return Invoke < DescribeRepositoriesResponse > ( request , options ) ; }
public SparseIntArray ( int initialCapacity ) { initialCapacity = android . util . @ internal . ArrayUtils . idealIntArraySize ( initialCapacity ) ; mKeys = new int [ initialCapacity ] ; mValues = new int [ initialCapacity ] ; mSize = 0 ; }
public override TokenStream Create ( TokenStream input ) { return new HyphenatedWordsFilter ( input ) ; }
public virtual CreateDistributionWithTagsResponse CreateDistributionWithTags ( CreateDistributionWithTagsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateDistributionWithTagsRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateDistributionWithTagsResponseUnmarshaller . Instance ; return Invoke < CreateDistributionWithTagsResponse > ( request , options ) ; }
public RandomAccessFile ( string fileName , string mode ) : this ( new java . io . File ( fileName ) , mode ) { throw new System . NotImplementedException ( ) ; }
public virtual DeleteWorkspaceImageResponse DeleteWorkspaceImage ( DeleteWorkspaceImageRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteWorkspaceImageRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteWorkspaceImageResponseUnmarshaller . Instance ; return Invoke < DeleteWorkspaceImageResponse > ( request , options ) ; }
public static string ToHex ( int value ) { return ToHex ( ( long ) value , 8 ) ; }
public virtual UpdateDistributionResponse UpdateDistribution ( UpdateDistributionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateDistributionRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateDistributionResponseUnmarshaller . Instance ; return Invoke < UpdateDistributionResponse > ( request , options ) ; }
public HSSFColor GetColor ( short index ) { if ( index == HSSFColor . Automatic . Index ) return HSSFColor . Automatic . GetInstance ( ) ; else { byte [ ] b = palette . GetColor ( index ) ; if ( b != null ) { return new CustomColor ( index , b ) ; } } return null ; }
public ValueEval Evaluate ( ValueEval [ ] operands , int srcRow , int srcCol ) { throw new NotImplementedFunctionException ( _functionName ) ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( ( short ) field_1_number_crn_records ) ; out1. WriteShort ( ( short ) field_2_sheet_table_index ) ; }
public virtual DescribeDBEngineVersionsResponse DescribeDBEngineVersions ( ) { return DescribeDBEngineVersions ( new DescribeDBEngineVersionsRequest ( ) ) ; }
public FormatRun ( short character , short fontIndex ) { this . _character = character ; this . _fontIndex = fontIndex ; }
public static byte [ ] toBigEndianUtf16Bytes ( char [ ] chars , int offset , int length ) { byte [ ] result = new byte [ length * 2 ] ; int end = offset + length ; int resultIndex = 0 ; { for ( int i = offset ; i < end ; ++ i ) { char ch = chars [ i ] ; result [ resultIndex ++ ] = unchecked ( ( byte ) ( ch >> 8 ) ) ; result [ resultIndex ++ ] = unchecked ( ( byte ) ch ) ; } } return result ; }
public virtual UploadArchiveResponse UploadArchive ( UploadArchiveRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UploadArchiveRequestMarshaller . Instance ; options . ResponseUnmarshaller = UploadArchiveResponseUnmarshaller . Instance ; return Invoke < UploadArchiveResponse > ( request , options ) ; }
public virtual IList < IToken > GetHiddenTokensToLeft ( int tokenIndex ) { return GetHiddenTokensToLeft ( tokenIndex , - 1 ) ; }
public override bool Equals ( object obj ) { if ( this == obj ) { return true ; } if ( ! base . Equals ( obj ) ) { return false ; } if ( this . GetType ( ) != obj . GetType ( ) ) { return false ; } AutomatonQuery other = ( AutomatonQuery ) obj ; if ( ! m_compiled . Equals ( other . m_compiled ) ) { return false ; } if ( m_term == null ) { if ( other . m_term != null ) { return false ; } } else if ( ! m_term . Equals ( other . m_term ) ) { return false ; } return true ; }
public virtual SpanQuery MakeSpanClause ( ) { List < SpanQuery > spanQueries = new List < SpanQuery > ( ) ; foreach ( var wsq in weightBySpanQuery ) { wsq . Key . Boost = wsq . Value ; spanQueries . Add ( wsq . Key ) ; } if ( spanQueries . Count == 1 ) return spanQueries [ 0 ] ; else return new SpanOrQuery ( spanQueries . ToArray ( ) ) ; }
public virtual StashCreateCommand StashCreate ( ) { return new StashCreateCommand ( repo ) ; }
public FieldInfo FieldInfo ( string fieldName ) { FieldInfo ret ; byName . TryGetValue ( fieldName , out ret ) ; return ret ; }
public virtual DescribeEventSourceResponse DescribeEventSource ( DescribeEventSourceRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeEventSourceRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeEventSourceResponseUnmarshaller . Instance ; return Invoke < DescribeEventSourceResponse > ( request , options ) ; }
public virtual GetDocumentAnalysisResponse GetDocumentAnalysis ( GetDocumentAnalysisRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetDocumentAnalysisRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetDocumentAnalysisResponseUnmarshaller . Instance ; return Invoke < GetDocumentAnalysisResponse > ( request , options ) ; }
public virtual CancelUpdateStackResponse CancelUpdateStack ( CancelUpdateStackRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CancelUpdateStackRequestMarshaller . Instance ; options . ResponseUnmarshaller = CancelUpdateStackResponseUnmarshaller . Instance ; return Invoke < CancelUpdateStackResponse > ( request , options ) ; }
public virtual ModifyLoadBalancerAttributesResponse ModifyLoadBalancerAttributes ( ModifyLoadBalancerAttributesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ModifyLoadBalancerAttributesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ModifyLoadBalancerAttributesResponseUnmarshaller . Instance ; return Invoke < ModifyLoadBalancerAttributesResponse > ( request , options ) ; }
public virtual SetInstanceProtectionResponse SetInstanceProtection ( SetInstanceProtectionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = SetInstanceProtectionRequestMarshaller . Instance ; options . ResponseUnmarshaller = SetInstanceProtectionResponseUnmarshaller . Instance ; return Invoke < SetInstanceProtectionResponse > ( request , options ) ; }
public virtual ModifyDBProxyResponse ModifyDBProxy ( ModifyDBProxyRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ModifyDBProxyRequestMarshaller . Instance ; options . ResponseUnmarshaller = ModifyDBProxyResponseUnmarshaller . Instance ; return Invoke < ModifyDBProxyResponse > ( request , options ) ; }
public virtual void Add ( char [ ] output , int offset , int len , int endOffset , int posLength ) { if ( count == outputs . Length ) { CharsRef [ ] next = new CharsRef [ ArrayUtil . Oversize ( 1 + count , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ] ; Array . Copy ( outputs , 0 , next , 0 , count ) ; outputs = next ; } if ( count == endOffsets . Length ) { int [ ] next = new int [ ArrayUtil . Oversize ( 1 + count , RamUsageEstimator . NUM_BYTES_INT32 ) ] ; Array . Copy ( endOffsets , 0 , next , 0 , count ) ; endOffsets = next ; } if ( count == posLengths . Length ) { int [ ] next = new int [ ArrayUtil . Oversize ( 1 + count , RamUsageEstimator . NUM_BYTES_INT32 ) ] ; Array . Copy ( posLengths , 0 , next , 0 , count ) ; posLengths = next ; } if ( outputs [ count ] == null ) { outputs [ count ] = new CharsRef ( ) ; } outputs [ count ] . CopyChars ( output , offset , len ) ; endOffsets [ count ] = endOffset ; posLengths [ count ] = posLength ; count ++ ; }
public FetchLibrariesRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " FetchLibraries " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public override bool Exists ( ) { return objects . Exists ( ) ; }
public FilterOutputStream ( java . io . OutputStream @ out ) { this . @ out = @ out ; }
public ScaleClusterRequest ( ) : base ( " CS " , " 2015 - 12 - 15 " , " ScaleCluster " , " cs " , " openAPI " ) { UriPattern = " / clusters / [ ClusterId ] " ; Method = MethodType . PUT ; }
public IDataValidationConstraint CreateTimeConstraint ( int operatorType , String formula1 , String formula2 ) { return DVConstraint . CreateTimeConstraint ( operatorType , formula1 , formula2 ) ; }
public virtual ListObjectParentPathsResponse ListObjectParentPaths ( ListObjectParentPathsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListObjectParentPathsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListObjectParentPathsResponseUnmarshaller . Instance ; return Invoke < ListObjectParentPathsResponse > ( request , options ) ; }
public virtual DescribeCacheSubnetGroupsResponse DescribeCacheSubnetGroups ( DescribeCacheSubnetGroupsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeCacheSubnetGroupsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeCacheSubnetGroupsResponseUnmarshaller . Instance ; return Invoke < DescribeCacheSubnetGroupsResponse > ( request , options ) ; }
public void SetSharedFormula ( bool flag ) { field_5_options = sharedFormula . SetShortBoolean ( field_5_options , flag ) ; }
public virtual bool IsReuseObjects ( ) { return reuseObjects ; }
public virtual IErrorNode AddErrorNode ( IToken badToken ) { ErrorNodeImpl t = new ErrorNodeImpl ( badToken ) ; AddChild ( t ) ; t . Parent = this ; return t ; }
public LatvianStemFilterFactory ( IDictionary < string , string > args ) : base ( args ) { if ( args . Count > 0 ) { throw new System . ArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public virtual RemoveSourceIdentifierFromSubscriptionResponse RemoveSourceIdentifierFromSubscription ( RemoveSourceIdentifierFromSubscriptionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = RemoveSourceIdentifierFromSubscriptionRequestMarshaller . Instance ; options . ResponseUnmarshaller = RemoveSourceIdentifierFromSubscriptionResponseUnmarshaller . Instance ; return Invoke < RemoveSourceIdentifierFromSubscriptionResponse > ( request , options ) ; }
public static TokenFilterFactory ForName ( string name , IDictionary < string , string > args ) { return loader . NewInstance ( name , args ) ; }
public AddAlbumPhotosRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " AddAlbumPhotos " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public virtual GetThreatIntelSetResponse GetThreatIntelSet ( GetThreatIntelSetRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetThreatIntelSetRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetThreatIntelSetResponseUnmarshaller . Instance ; return Invoke < GetThreatIntelSetResponse > ( request , options ) ; }
public override TreeFilter Clone ( ) { return new AndTreeFilter . Binary ( a . Clone ( ) , b . Clone ( ) ) ; }
public override bool Equals ( object o ) { return o is ArmenianStemmer ; }
public sealed override bool hasArray ( ) { return protectedHasArray ( ) ; }
public virtual UpdateContributorInsightsResponse UpdateContributorInsights ( UpdateContributorInsightsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateContributorInsightsRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateContributorInsightsResponseUnmarshaller . Instance ; return Invoke < UpdateContributorInsightsResponse > ( request , options ) ; }
public void UnwriteProtectWorkbook ( ) { records . Remove ( fileShare ) ; records . Remove ( WriteProtect ) ; fileShare = null ; writeProtect = null ; }
public SolrSynonymParser ( bool dedup , bool expand , Analyzer analyzer ) : base ( dedup , analyzer ) { this . expand = expand ; }
public virtual RequestSpotInstancesResponse RequestSpotInstances ( RequestSpotInstancesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = RequestSpotInstancesRequestMarshaller . Instance ; options . ResponseUnmarshaller = RequestSpotInstancesResponseUnmarshaller . Instance ; return Invoke < RequestSpotInstancesResponse > ( request , options ) ; }
public byte [ ] GetObjectData ( ) { return FindObjectRecord ( ) . ObjectData ; }
public virtual GetContactAttributesResponse GetContactAttributes ( GetContactAttributesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetContactAttributesRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetContactAttributesResponseUnmarshaller . Instance ; return Invoke < GetContactAttributesResponse > ( request , options ) ; }
public override string ToString ( ) { return GetKey ( ) + " : ▁ " + GetValue ( ) ; }
public virtual ListTextTranslationJobsResponse ListTextTranslationJobs ( ListTextTranslationJobsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListTextTranslationJobsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListTextTranslationJobsResponseUnmarshaller . Instance ; return Invoke < ListTextTranslationJobsResponse > ( request , options ) ; }
public virtual GetContactMethodsResponse GetContactMethods ( GetContactMethodsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetContactMethodsRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetContactMethodsResponseUnmarshaller . Instance ; return Invoke < GetContactMethodsResponse > ( request , options ) ; }
public static short LookupIndexByName ( String name ) { FunctionMetadata fd = GetInstance ( ) . GetFunctionByNameInternal ( name ) ; if ( fd == null ) { return - 1 ; } return ( short ) fd . Index ; }
public virtual DescribeAnomalyDetectorsResponse DescribeAnomalyDetectors ( DescribeAnomalyDetectorsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeAnomalyDetectorsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeAnomalyDetectorsResponseUnmarshaller . Instance ; return Invoke < DescribeAnomalyDetectorsResponse > ( request , options ) ; }
public static string InsertId ( string message , ObjectId changeId ) { return InsertId ( message , changeId , false ) ; }
public override long GetObjectSize ( AnyObjectId objectId , int typeHint ) { long sz = db . GetObjectSize ( this , objectId ) ; if ( sz < 0 ) { if ( typeHint == OBJ_ANY ) { throw new MissingObjectException ( objectId . Copy ( ) , " unknown " ) ; } throw new MissingObjectException ( objectId . Copy ( ) , typeHint ) ; } return sz ; }
public virtual ImportInstallationMediaResponse ImportInstallationMedia ( ImportInstallationMediaRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ImportInstallationMediaRequestMarshaller . Instance ; options . ResponseUnmarshaller = ImportInstallationMediaResponseUnmarshaller . Instance ; return Invoke < ImportInstallationMediaResponse > ( request , options ) ; }
public virtual PutLifecycleEventHookExecutionStatusResponse PutLifecycleEventHookExecutionStatus ( PutLifecycleEventHookExecutionStatusRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = PutLifecycleEventHookExecutionStatusRequestMarshaller . Instance ; options . ResponseUnmarshaller = PutLifecycleEventHookExecutionStatusResponseUnmarshaller . Instance ; return Invoke < PutLifecycleEventHookExecutionStatusResponse > ( request , options ) ; }
public NumberPtg ( ILittleEndianInput in1 ) { field_1_value = in1. ReadDouble ( ) ; }
public virtual GetFieldLevelEncryptionConfigResponse GetFieldLevelEncryptionConfig ( GetFieldLevelEncryptionConfigRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetFieldLevelEncryptionConfigRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetFieldLevelEncryptionConfigResponseUnmarshaller . Instance ; return Invoke < GetFieldLevelEncryptionConfigResponse > ( request , options ) ; }
public virtual DescribeDetectorResponse DescribeDetector ( DescribeDetectorRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeDetectorRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeDetectorResponseUnmarshaller . Instance ; return Invoke < DescribeDetectorResponse > ( request , options ) ; }
public virtual ReportInstanceStatusResponse ReportInstanceStatus ( ReportInstanceStatusRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ReportInstanceStatusRequestMarshaller . Instance ; options . ResponseUnmarshaller = ReportInstanceStatusResponseUnmarshaller . Instance ; return Invoke < ReportInstanceStatusResponse > ( request , options ) ; }
public virtual DeleteAlarmResponse DeleteAlarm ( DeleteAlarmRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteAlarmRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteAlarmResponseUnmarshaller . Instance ; return Invoke < DeleteAlarmResponse > ( request , options ) ; }
public override TokenStream Create ( TokenStream input ) { return new PortugueseStemFilter ( input ) ; }
public FtCblsSubRecord ( ) { reserved = new byte [ ENCODED_SIZE ] ; }
public virtual bool remove ( object @ object ) { lock ( mutex ) { return c . remove ( @ object ) ; } }
public virtual GetDedicatedIpResponse GetDedicatedIp ( GetDedicatedIpRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetDedicatedIpRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetDedicatedIpResponseUnmarshaller . Instance ; return Invoke < GetDedicatedIpResponse > ( request , options ) ; }
public override string ToString ( ) { return precedence + " ▁ >= ▁ □ p " ; }
public virtual ListStreamProcessorsResponse ListStreamProcessors ( ListStreamProcessorsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListStreamProcessorsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListStreamProcessorsResponseUnmarshaller . Instance ; return Invoke < ListStreamProcessorsResponse > ( request , options ) ; }
public DeleteLoadBalancerPolicyRequest ( string loadBalancerName , string policyName ) { _loadBalancerName = loadBalancerName ; _policyName = policyName ; }
public WindowProtectRecord ( int options ) { _options = options ; }
public UnbufferedCharStream ( int bufferSize ) { n = 0 ; data = new int [ bufferSize ] ; }
public virtual GetOperationsResponse GetOperations ( GetOperationsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetOperationsRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetOperationsResponseUnmarshaller . Instance ; return Invoke < GetOperationsResponse > ( request , options ) ; }
public virtual void CopyRawTo ( byte [ ] b , int o ) { NB . EncodeInt32 ( b , o , w1 ) ; NB . EncodeInt32 ( b , o + 4 , w2 ) ; NB . EncodeInt32 ( b , o + 8 , w3 ) ; NB . EncodeInt32 ( b , o + 12 , w4 ) ; NB . EncodeInt32 ( b , o + 16 , w5 ) ; }
public WindowOneRecord ( RecordInputStream in1 ) { field_1_h_hold = in1. ReadShort ( ) ; field_2_v_hold = in1. ReadShort ( ) ; field_3_width = in1. ReadShort ( ) ; field_4_height = in1. ReadShort ( ) ; field_5_options = in1. ReadShort ( ) ; field_6_active_sheet = in1. ReadShort ( ) ; field_7_first_visible_tab = in1. ReadShort ( ) ; field_8_num_selected_tabs = in1. ReadShort ( ) ; field_9_tab_width_ratio = in1. ReadShort ( ) ; }
public virtual StopWorkspacesResponse StopWorkspaces ( StopWorkspacesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = StopWorkspacesRequestMarshaller . Instance ; options . ResponseUnmarshaller = StopWorkspacesResponseUnmarshaller . Instance ; return Invoke < StopWorkspacesResponse > ( request , options ) ; }
public void close ( ) throws IOException { if ( isOpen ) { isOpen = false ; try { dump ( ) ; } finally { try { channel . truncate ( fileLength ) ; } finally { try { channel . close ( ) ; } finally { fos . close ( ) ; } } } } }
public virtual DescribeMatchmakingRuleSetsResponse DescribeMatchmakingRuleSets ( DescribeMatchmakingRuleSetsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeMatchmakingRuleSetsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeMatchmakingRuleSetsResponseUnmarshaller . Instance ; return Invoke < DescribeMatchmakingRuleSetsResponse > ( request , options ) ; }
public string GetPronunciation ( int wordId , char [ ] surface , int off , int len ) { return null ; }
public virtual string GetPath ( ) { return pathStr ; }
public static double devsq ( double [ ] v ) { double r = double . NaN ; if ( v != null && v . Length >= 1 ) { double m = 0 ; double s = 0 ; int n = v . Length ; for ( int i = 0 ; i < n ; i ++ ) { s += v [ i ] ; } m = s / n ; s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += ( v [ i ] - m ) * ( v [ i ] - m ) ; } r = ( n == 1 ) ? 0 : s ; } return r ; }
public virtual DescribeResizeResponse DescribeResize ( DescribeResizeRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeResizeRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeResizeResponseUnmarshaller . Instance ; return Invoke < DescribeResizeResponse > ( request , options ) ; }
public bool hasPassedThroughNonGreedyDecision ( ) { return passedThroughNonGreedyDecision ; }
public int end ( ) { return end ( 0 ) ; }
public void Traverse ( ICellHandler handler ) { int firstRow = range . FirstRow ; int lastRow = range . LastRow ; int firstColumn = range . FirstColumn ; int lastColumn = range . LastColumn ; int width = lastColumn - firstColumn + 1 ; SimpleCellWalkContext ctx = new SimpleCellWalkContext ( ) ; IRow currentRow = null ; ICell currentCell = null ; for ( ctx . rowNumber = firstRow ; ctx . rowNumber <= lastRow ; ++ ctx . rowNumber ) { currentRow = sheet . GetRow ( ctx . rowNumber ) ; if ( currentRow == null ) { continue ; } for ( ctx . colNumber = firstColumn ; ctx . colNumber <= lastColumn ; ++ ctx . colNumber ) { currentCell = currentRow . GetCell ( ctx . colNumber ) ; if ( currentCell == null ) { continue ; } if ( IsEmpty ( currentCell ) && ! traverseEmptyCells ) { continue ; } ctx . ordinalNumber = ( ctx . rowNumber - firstRow ) * width + ( ctx . colNumber - firstColumn + 1 ) ; handler . OnCell ( currentCell , ctx ) ; } } }
public int GetReadIndex ( ) { return _ReadIndex ; }
public virtual int CompareTo ( ScoreTerm other ) { if ( Term . BytesEquals ( other . Term ) ) { return 0 ; } if ( this . Boost == other . Boost ) { return other . Term . CompareTo ( this . Term ) ; } else { return this . Boost . CompareTo ( other . Boost ) ; } }
public virtual int Normalize ( char [ ] s , int len ) { for ( int i = 0 ; i < len ; i ++ ) { switch ( s [ i ] ) { case FARSI_YEH : case YEH_BARREE : s [ i ] = YEH ; break ; case KEHEH : s [ i ] = KAF ; break ; case HEH_YEH : case HEH_GOAL : s [ i ] = HEH ; break ; case HAMZA_ABOVE : len = StemmerUtil . Delete ( s , i , len ) ; i -- ; break ; default : break ; } } return len ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( _options ) ; }
public DiagnosticErrorListener ( bool exactOnly ) { this . exactOnly = exactOnly ; }
public KeySchemaElement ( string attributeName , KeyType keyType ) { _attributeName = attributeName ; _keyType = keyType ; }
public virtual GetAssignmentResponse GetAssignment ( GetAssignmentRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetAssignmentRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetAssignmentResponseUnmarshaller . Instance ; return Invoke < GetAssignmentResponse > ( request , options ) ; }
public virtual bool HasObject ( AnyObjectId id ) { return FindOffset ( id ) != - 1 ; }
public virtual GroupingSearch SetAllGroups ( bool allGroups ) { this . allGroups = allGroups ; return this ; }
public virtual void SetMultiValued ( string dimName , bool v ) { lock ( this ) { if ( ! fieldTypes . TryGetValue ( dimName , out DimConfig fieldType ) ) { fieldTypes [ dimName ] = new DimConfig { IsMultiValued = v } ; } else { fieldType . IsMultiValued = v ; } } }
public int GetCellsVal ( ) { int size = 0 ; foreach ( char c in cells . Keys ) { Cell e = At ( c ) ; if ( e . cmd >= 0 ) { size ++ ; } } return size ; }
public virtual DeleteVoiceConnectorResponse DeleteVoiceConnector ( DeleteVoiceConnectorRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteVoiceConnectorRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteVoiceConnectorResponseUnmarshaller . Instance ; return Invoke < DeleteVoiceConnectorResponse > ( request , options ) ; }
public virtual DeleteLifecyclePolicyResponse DeleteLifecyclePolicy ( DeleteLifecyclePolicyRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteLifecyclePolicyRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteLifecyclePolicyResponseUnmarshaller . Instance ; return Invoke < DeleteLifecyclePolicyResponse > ( request , options ) ; }
public void Write ( byte [ ] b ) { int len = b . Length ; CheckPosition ( len ) ; System . Array . Copy ( b , 0 , _buf , _writeIndex , len ) ; _writeIndex += len ; }
public virtual RebaseResult GetRebaseResult ( ) { return this . rebaseResult ; }
public static int GetNearestSetSize ( int maxNumberOfValuesExpected , float desiredSaturation ) { foreach ( var t in from t in _usableBitSetSizeslet numSetBitsAtDesiredSaturation = ( int ) ( t * desiredSaturation ) let estimatedNumUniqueValues = GetEstimatedNumberUniqueValuesAllowingForCollisions ( t , numSetBitsAtDesiredSaturation ) where estimatedNumUniqueValues > maxNumberOfValuesExpected select t ) { return t ; } return - 1 ; }
public virtual DescribeDashboardResponse DescribeDashboard ( DescribeDashboardRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeDashboardRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeDashboardResponseUnmarshaller . Instance ; return Invoke < DescribeDashboardResponse > ( request , options ) ; }
public virtual CreateSegmentResponse CreateSegment ( CreateSegmentRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateSegmentRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateSegmentResponseUnmarshaller . Instance ; return Invoke < CreateSegmentResponse > ( request , options ) ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ DBCELL ] \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . rowoffset ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( StringUtil . ToHexString ( RowOffset ) ) . Append ( " \ n " ) ; for ( int k = 0 ; k < field_2_cell_offsets . Length ; k ++ ) { buffer . Append ( " ▁ ▁ ▁ ▁ . cell □ " ) . Append ( k ) . Append ( " ▁ = ▁ " ) . Append ( HexDump . ShortToHex ( field_2_cell_offsets [ k ] ) ) . Append ( " \ n " ) ; } buffer . Append ( " [ / DBCELL ] \ n " ) ; return buffer . ToString ( ) ; }
public virtual IList < string > GetUndeletedList ( ) { return undeletedList ; }
public override String ToString ( ) { return " [ INTERFACEEND / ] \ n " ; }
public override object Clone ( ) { return this ; }
public PlainTextDictionary ( TextReader reader ) { @ in = reader ; }
public java . lang . StringBuilder append ( java . lang . CharSequence csq ) { if ( csq == null ) { appendNull ( ) ; } else { append0 ( csq , 0 , csq . Length ) ; } return this ; }
public virtual ListAssociatedStacksResponse ListAssociatedStacks ( ListAssociatedStacksRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListAssociatedStacksRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListAssociatedStacksResponseUnmarshaller . Instance ; return Invoke < ListAssociatedStacksResponse > ( request , options ) ; }
public static double avedev ( double [ ] v ) { double r = 0 ; double m = 0 ; double s = 0 ; for ( int i = 0 , iSize = v . Length ; i < iSize ; i ++ ) { s += v [ i ] ; } m = s / v . Length ; s = 0 ; for ( int i = 0 , iSize = v . Length ; i < iSize ; i ++ ) { s += Math . Abs ( v [ i ] - m ) ; } r = s / v . Length ; return r ; }
public virtual DescribeByoipCidrsResponse DescribeByoipCidrs ( DescribeByoipCidrsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeByoipCidrsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeByoipCidrsResponseUnmarshaller . Instance ; return Invoke < DescribeByoipCidrsResponse > ( request , options ) ; }
public virtual GetDiskResponse GetDisk ( GetDiskRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetDiskRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetDiskResponseUnmarshaller . Instance ; return Invoke < GetDiskResponse > ( request , options ) ; }
public virtual CreateDBClusterParameterGroupResponse CreateDBClusterParameterGroup ( CreateDBClusterParameterGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateDBClusterParameterGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateDBClusterParameterGroupResponseUnmarshaller . Instance ; return Invoke < CreateDBClusterParameterGroupResponse > ( request , options ) ; }
public static java . nio . CharBuffer wrap ( char [ ] array_1 , int start , int charCount ) { java . util . Arrays . checkOffsetAndCount ( array_1. Length , start , charCount ) ; java . nio . CharBuffer buf = new java . nio . ReadWriteCharArrayBuffer ( array_1 ) ; buf . _position = start ; buf . _limit = start + charCount ; return buf ; }
public virtual SubmoduleStatusType GetType ( ) { return type ; }
public virtual DescribeGameServerGroupResponse DescribeGameServerGroup ( DescribeGameServerGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeGameServerGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeGameServerGroupResponseUnmarshaller . Instance ; return Invoke < DescribeGameServerGroupResponse > ( request , options ) ; }
public java . util . regex . Pattern pattern ( ) { return _pattern ; }
public virtual V setValue ( V @ object ) { throw new System . NotSupportedException ( ) ; }
public StringBuilder Stem ( string word ) { string cmd = stemmer . GetLastOnPath ( word ) ; if ( cmd == null ) return null ; buffer . Length = 0 ; buffer . Append ( word ) ; Diff . Apply ( buffer , cmd ) ; if ( buffer . Length > 0 ) return buffer ; else return null ; }
public RenameFaceRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " RenameFace " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public virtual char RequireChar ( IDictionary < string , string > args , string name ) { return Require ( args , name ) [ 0 ] ; }
public static string ToStringTree ( ITree t ) { return ToStringTree ( t , ( IList < string > ) null ) ; }
public override string ToString ( ) { return " < deleted /> " ; }
public GetRepoWebhookLogListRequest ( ) : base ( " cr " , " 2016 - 06 - 07 " , " GetRepoWebhookLogList " , " cr " , " openAPI " ) { UriPattern = " / repos / [ RepoNamespace ] / [ RepoName ] / webhooks / [ WebhookId ] / logs " ; Method = MethodType . GET ; }
public virtual GetJobUnlockCodeResponse GetJobUnlockCode ( GetJobUnlockCodeRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetJobUnlockCodeRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetJobUnlockCodeResponseUnmarshaller . Instance ; return Invoke < GetJobUnlockCodeResponse > ( request , options ) ; }
public RemoveTagsRequest ( string resourceId ) { _resourceId = resourceId ; }
public virtual short GetGB2312Id ( char ch ) { try { byte [ ] buffer = Encoding . GetEncoding ( " GB2312 " ) . GetBytes ( ch . ToString ( ) ) ; if ( buffer . Length != 2 ) { return - 1 ; } int b0 = ( buffer [ 0 ] & 0x0FF ) - 161 ; int b1 = ( buffer [ 1 ] & 0x0FF ) - 161 ; return ( short ) ( b0 * 94 + b1 ) ; } catch ( ArgumentException e ) { throw new Exception ( e . ToString ( ) , e ) ; } }
public virtual NGit . BatchRefUpdate AddCommand ( ICollection < ReceiveCommand > cmd ) { Sharpen . Collections . AddAll ( commands , cmd ) ; return this ; }
public int CheckExternSheet ( int sheetNumber ) { return OrCreateLinkTable . CheckExternSheet ( sheetNumber ) ; }
public override bool Equals ( object @ object ) { return c . Equals ( @ object ) ; }
public virtual Query Build ( IQueryNode queryNode ) { AnyQueryNode andNode = ( AnyQueryNode ) queryNode ; BooleanQuery bQuery = new BooleanQuery ( ) ; IList < IQueryNode > children = andNode . GetChildren ( ) ; if ( children != null ) { foreach ( IQueryNode child in children ) { object obj = child . GetTag ( QueryTreeBuilder . QUERY_TREE_BUILDER_TAGID ) ; if ( obj != null ) { Query query = ( Query ) obj ; try { bQuery . Add ( query , Occur . SHOULD ) ; } catch ( BooleanQuery . TooManyClausesException ex ) { throw new QueryNodeException ( new Message ( QueryParserMessages . EMPTY_MESSAGE ) , ex ) ; } } } } bQuery . MinimumNumberShouldMatch = andNode . MinimumMatchingElements ; return bQuery ; }
public virtual DescribeStreamProcessorResponse DescribeStreamProcessor ( DescribeStreamProcessorRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeStreamProcessorRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeStreamProcessorResponseUnmarshaller . Instance ; return Invoke < DescribeStreamProcessorResponse > ( request , options ) ; }
public virtual DescribeDashboardPermissionsResponse DescribeDashboardPermissions ( DescribeDashboardPermissionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeDashboardPermissionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeDashboardPermissionsResponseUnmarshaller . Instance ; return Invoke < DescribeDashboardPermissionsResponse > ( request , options ) ; }
public virtual Ref Peel ( Ref @ ref ) { try { return RefDatabase . Peel ( @ ref ) ; } catch ( IOException ) { return @ ref ; } }
public override long RamBytesUsed ( ) { return RamUsageEstimator . AlignObjectSize ( RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + 2 * RamUsageEstimator . NUM_BYTES_INT32 + RamUsageEstimator . NUM_BYTES_OBJECT_REF ) + RamUsageEstimator . SizeOf ( blocks ) ; }
public virtual GetDomainSuggestionsResponse GetDomainSuggestions ( GetDomainSuggestionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetDomainSuggestionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetDomainSuggestionsResponseUnmarshaller . Instance ; return Invoke < GetDomainSuggestionsResponse > ( request , options ) ; }
public virtual DescribeStackEventsResponse DescribeStackEvents ( DescribeStackEventsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeStackEventsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeStackEventsResponseUnmarshaller . Instance ; return Invoke < DescribeStackEventsResponse > ( request , options ) ; }
public void SetRule ( int idx , IConditionalFormattingRule cfRule ) { SetRule ( idx , ( HSSFConditionalFormattingRule ) cfRule ) ; }
public virtual CreateResolverRuleResponse CreateResolverRule ( CreateResolverRuleRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateResolverRuleRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateResolverRuleResponseUnmarshaller . Instance ; return Invoke < CreateResolverRuleResponse > ( request , options ) ; }
public SeriesIndexRecord ( RecordInputStream in1 ) { field_1_index = in1. ReadShort ( ) ; }
public GetStylesRequest ( ) : base ( " lubancloud " , " 2018 - 05 - 09 " , " GetStyles " , " luban " , " openAPI " ) { Method = MethodType . POST ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( field_1_gridset_flag ) ; }
public override bool Equals ( object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( GetType ( ) != obj . GetType ( ) ) { return false ; } Toffs other = ( Toffs ) obj ; if ( StartOffset != other . StartOffset ) { return false ; } if ( EndOffset != other . EndOffset ) { return false ; } return true ; }
public virtual CreateGatewayGroupResponse CreateGatewayGroup ( CreateGatewayGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateGatewayGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateGatewayGroupResponseUnmarshaller . Instance ; return Invoke < CreateGatewayGroupResponse > ( request , options ) ; }
public virtual CreateParticipantConnectionResponse CreateParticipantConnection ( CreateParticipantConnectionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateParticipantConnectionRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateParticipantConnectionResponseUnmarshaller . Instance ; return Invoke < CreateParticipantConnectionResponse > ( request , options ) ; }
public static double irr ( double [ ] income ) { return irr ( income , 0.1d ) ; }
public virtual RegisterWorkspaceDirectoryResponse RegisterWorkspaceDirectory ( RegisterWorkspaceDirectoryRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = RegisterWorkspaceDirectoryRequestMarshaller . Instance ; options . ResponseUnmarshaller = RegisterWorkspaceDirectoryResponseUnmarshaller . Instance ; return Invoke < RegisterWorkspaceDirectoryResponse > ( request , options ) ; }
public virtual NGit . Api . RevertCommand Include ( Ref commit ) { CheckCallable ( ) ; commits . AddItem ( commit ) ; return this ; }
public override ValueEval Evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval inumberVE ) { ValueEval veText1 ; try { veText1 = OperandResolver . GetSingleValue ( inumberVE , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return e . GetErrorEval ( ) ; } String iNumber = OperandResolver . CoerceValueToString ( veText1 ) ; System . Text . RegularExpressions . Match m = COMPLEX_NUMBER_PATTERN . Match ( iNumber ) ; bool result = m . Success && m . Groups [ 0 ] . Length > 0 ; String imaginary = " " ; if ( result == true ) { String imaginaryGroup = m . Groups [ 5 ] . Value ; bool hasImaginaryPart = imaginaryGroup . Equals ( " i " ) || imaginaryGroup . Equals ( " j " ) ; if ( imaginaryGroup . Length == 0 ) { return new StringEval ( Convert . ToString ( 0 ) ) ; } if ( hasImaginaryPart ) { String sign = " " ; String imaginarySign = m . Groups [ ( GROUP3_IMAGINARY_SIGN ) ] . Value ; if ( imaginarySign . Length != 0 && ! ( imaginarySign . Equals ( " + " ) ) ) { sign = imaginarySign ; } String groupImaginaryNumber = m . Groups [ ( GROUP4_IMAGINARY_INTEGER_OR_DOUBLE ) ] . Value ; if ( groupImaginaryNumber . Length != 0 ) { imaginary = sign + groupImaginaryNumber ; } else { imaginary = sign + " 1 " ; } } } else { return ErrorEval . NUM_ERROR ; } return new StringEval ( imaginary ) ; }
public virtual E pollLast ( ) { java . util . MapClass . Entry < E , object > entry = backingMap . pollLastEntry ( ) ; return ( entry == null ) ? default ( E ) : entry . getKey ( ) ; }
public int ReadUShort ( ) { int ch1 = ReadUByte ( ) ; int ch2 = ReadUByte ( ) ; return ( ch2 << 8 ) + ( ch1 << 0 ) ; }
public ModifySnapshotAttributeRequest ( string snapshotId , SnapshotAttributeName attribute , OperationType operationType ) { _snapshotId = snapshotId ; _attribute = attribute ; _operationType = operationType ; }
public virtual ListBonusPaymentsResponse ListBonusPayments ( ListBonusPaymentsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListBonusPaymentsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListBonusPaymentsResponseUnmarshaller . Instance ; return Invoke < ListBonusPaymentsResponse > ( request , options ) ; }
public override V Get ( char [ ] text ) { if ( text == null ) { throw new ArgumentNullException ( " text " ) ; } return default ( V ) ; }
public override TokenStream Create ( TokenStream input ) { var commonGrams = ( CommonGramsFilter ) base . Create ( input ) ; return new CommonGramsQueryFilter ( commonGrams ) ; }
public virtual string GetPath ( ) { return path ; }
public virtual InitiateMultipartUploadResponse InitiateMultipartUpload ( InitiateMultipartUploadRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = InitiateMultipartUploadRequestMarshaller . Instance ; options . ResponseUnmarshaller = InitiateMultipartUploadResponseUnmarshaller . Instance ; return Invoke < InitiateMultipartUploadResponse > ( request , options ) ; }
public java . lang . StringBuilder insert ( int offset , int i ) { insert0 ( offset , System . Convert . ToString ( i ) ) ; return this ; }
public override void Decode ( long [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { long block = blocks [ blocksOffset ++ ] ; for ( int shift = 62 ; shift >= 0 ; shift -= 2 ) { values [ valuesOffset ++ ] = ( int ) ( ( ( long ) ( ( ulong ) block >> shift ) ) & 3 ) ; } } }
public override TokenStream Create ( TokenStream input ) { return new ElisionFilter ( input , articles ) ; }
public bool Eat ( Row @ in , int [ ] remap ) { int sum = 0 ; foreach ( Cell c in @ in . cells . Values ) { sum += c . cnt ; if ( c . @ ref >= 0 ) { if ( remap [ c . @ ref ] == 0 ) { c . @ ref = - 1 ; } } } int frame = sum / 10 ; bool live = false ; foreach ( Cell c in @ in . cells . Values ) { if ( c . cnt < frame && c . cmd >= 0 ) { c . cnt = 0 ; c . cmd = - 1 ; } if ( c . cmd >= 0 || c . @ ref >= 0 ) { live |= true ; } } return ! live ; }
public Token GetToken ( int index ) { Token t = Token ; for ( int i = 0 ; i < index ; i ++ ) { if ( t . Next != null ) t = t . Next ; else t = t . Next = TokenSource . GetNextToken ( ) ; } return t ; }
public override String ToString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . Append ( GetType ( ) . Name ) . Append ( " ▁ [ ARRAY ] \ n " ) ; sb . Append ( " ▁ range = " ) . Append ( Range . ToString ( ) ) . Append ( " \ n " ) ; sb . Append ( " ▁ options = " ) . Append ( HexDump . ShortToHex ( _options ) ) . Append ( " \ n " ) ; sb . Append ( " ▁ notUsed = " ) . Append ( HexDump . IntToHex ( _field3notUsed ) ) . Append ( " \ n " ) ; sb . Append ( " ▁ formula : " ) . Append ( " \ n " ) ; Ptg [ ] ptgs = _formula . Tokens ; for ( int i = 0 ; i < ptgs . Length ; i ++ ) { Ptg ptg = ptgs [ i ] ; sb . Append ( ptg . ToString ( ) ) . Append ( ptg . RVAType ) . Append ( " \ n " ) ; } sb . Append ( " ] " ) ; return sb . ToString ( ) ; }
public virtual GetFolderResponse GetFolder ( GetFolderRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetFolderRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetFolderResponseUnmarshaller . Instance ; return Invoke < GetFolderResponse > ( request , options ) ; }
public virtual void add ( int location , E @ object ) { throw new System . NotSupportedException ( ) ; }
public PositiveScoresOnlyCollector ( ICollector c ) { this . c = c ; }
public CreateRepoBuildRuleRequest ( ) : base ( " cr " , " 2016 - 06 - 07 " , " CreateRepoBuildRule " , " cr " , " openAPI " ) { UriPattern = " / repos / [ RepoNamespace ] / [ RepoName ] / rules " ; Method = MethodType . PUT ; }
public BaseRef ( RefEval re ) { _refEval = re ; _areaEval = null ; _firstRowIndex = re . Row ; _firstColumnIndex = re . Column ; _height = 1 ; _width = 1 ; }
public DrawingManager2 ( EscherDggRecord dgg ) { this . dgg = dgg ; }
public override void Reset ( ) { if ( ! First ) { Reset ( raw ) ; } }
public java . nio . charset . CharsetDecoder reset ( ) { status = INIT ; implReset ( ) ; return this ; }
public BufferedReader ( java . io . Reader @ in , int size ) : base ( @ in ) { if ( size <= 0 ) { throw new System . ArgumentException ( " size ▁ <= ▁ 0 " ) ; } this . @ in = @ in ; buf = new char [ size ] ; }
public virtual DescribeCodeRepositoryResponse DescribeCodeRepository ( DescribeCodeRepositoryRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeCodeRepositoryRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeCodeRepositoryResponseUnmarshaller . Instance ; return Invoke < DescribeCodeRepositoryResponse > ( request , options ) ; }
public virtual CreateDBSubnetGroupResponse CreateDBSubnetGroup ( CreateDBSubnetGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateDBSubnetGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateDBSubnetGroupResponseUnmarshaller . Instance ; return Invoke < CreateDBSubnetGroupResponse > ( request , options ) ; }
public virtual NGit . Api . RenameBranchCommand SetOldName ( string oldName ) { CheckCallable ( ) ; this . oldName = oldName ; return this ; }
public virtual NGit . Api . DeleteBranchCommand SetForce ( bool force ) { CheckCallable ( ) ; this . force = force ; return this ; }
public virtual StopCompilationJobResponse StopCompilationJob ( StopCompilationJobRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = StopCompilationJobRequestMarshaller . Instance ; options . ResponseUnmarshaller = StopCompilationJobResponseUnmarshaller . Instance ; return Invoke < StopCompilationJobResponse > ( request , options ) ; }
public void incrementSecondaryProgressBy ( int diff ) { lock ( this ) { setSecondaryProgress ( mSecondaryProgress + diff ) ; } }
public override int [ ] Clear ( ) { return bytesStart = null ; }
public string getRawPath ( ) { return path ; }
public GetUserSourceAccountRequest ( ) : base ( " cr " , " 2016 - 06 - 07 " , " GetUserSourceAccount " , " cr " , " openAPI " ) { UriPattern = " / users / sourceAccount " ; Method = MethodType . GET ; }
public virtual CreateExportJobResponse CreateExportJob ( CreateExportJobRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateExportJobRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateExportJobResponseUnmarshaller . Instance ; return Invoke < CreateExportJobResponse > ( request , options ) ; }
public virtual CreateDedicatedIpPoolResponse CreateDedicatedIpPool ( CreateDedicatedIpPoolRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateDedicatedIpPoolRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateDedicatedIpPoolResponseUnmarshaller . Instance ; return Invoke < CreateDedicatedIpPoolResponse > ( request , options ) ; }
public override bool Equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj is HSSFCellStyle ) { HSSFCellStyle other = ( HSSFCellStyle ) obj ; if ( _format == null ) { if ( other . _format != null ) return false ; } else if ( ! _format . Equals ( other . _format ) ) return false ; if ( index != other . index ) return false ; return true ; } return false ; }
public virtual ReleaseHostsResponse ReleaseHosts ( ReleaseHostsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ReleaseHostsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ReleaseHostsResponseUnmarshaller . Instance ; return Invoke < ReleaseHostsResponse > ( request , options ) ; }
public override bool Equals ( object @ object ) { if ( this == @ object ) { return true ; } if ( @ object is java . util . Set < E > ) { java . util . Set < E > s = ( java . util . Set < E > ) @ object ; try { return size ( ) == s . size ( ) && containsAll ( s ) ; } catch ( System . ArgumentNullException ) { return false ; } catch ( System . InvalidCastException ) { return false ; } } return false ; }
public virtual void SetRefLogMessage ( string msg , bool appendStatus ) { if ( msg == null && ! appendStatus ) { DisableRefLog ( ) ; } else { if ( msg == null && appendStatus ) { refLogMessage = string . Empty ; refLogIncludeResult = true ; } else { refLogMessage = msg ; refLogIncludeResult = appendStatus ; } } }
public StreamIDRecord ( RecordInputStream in1 ) { idstm = in1. ReadShort ( ) ; }
public RecognizeCarRequest ( ) : base ( " visionai - poc " , " 2020 - 04 - 08 " , " RecognizeCar " ) { Method = MethodType . POST ; }
public sealed override java . nio . ByteOrder order ( ) { return java . nio . ByteOrder . nativeOrder ( ) ; }
public virtual int GetAheadCount ( ) { return aheadCount ; }
public virtual bool IsNewFragment ( ) { return false ; }
public virtual GetCloudFrontOriginAccessIdentityConfigResponse GetCloudFrontOriginAccessIdentityConfig ( GetCloudFrontOriginAccessIdentityConfigRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetCloudFrontOriginAccessIdentityConfigRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetCloudFrontOriginAccessIdentityConfigResponseUnmarshaller . Instance ; return Invoke < GetCloudFrontOriginAccessIdentityConfigResponse > ( request , options ) ; }
public override bool Matches ( int symbol , int minVocabSymbol , int maxVocabSymbol ) { return token == symbol ; }
public virtual DeleteTransitGatewayResponse DeleteTransitGateway ( DeleteTransitGatewayRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteTransitGatewayRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteTransitGatewayResponseUnmarshaller . Instance ; return Invoke < DeleteTransitGatewayResponse > ( request , options ) ; }
public static double [ ] Grow ( double [ ] array , int minSize ) { Debug . Assert ( minSize >= 0 , " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ) ; if ( array . Length < minSize ) { double [ ] newArray = new double [ Oversize ( minSize , RamUsageEstimator . NUM_BYTES_DOUBLE ) ] ; Array . Copy ( array , 0 , newArray , 0 , array . Length ) ; return newArray ; } else { return array ; } }
public CreateTransactionRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " CreateTransaction " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public virtual NGit . BatchRefUpdate SetRefLogIdent ( PersonIdent pi ) { refLogIdent = pi ; return this ; }
public virtual GetLaunchTemplateDataResponse GetLaunchTemplateData ( GetLaunchTemplateDataRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetLaunchTemplateDataRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetLaunchTemplateDataResponseUnmarshaller . Instance ; return Invoke < GetLaunchTemplateDataResponse > ( request , options ) ; }
public ParseInfo ( ProfilingATNSimulator atnSimulator ) { this . atnSimulator = atnSimulator ; }
public SimpleQQParser ( string [ ] qqNames , string indexField ) { this . qqNames = qqNames ; this . indexField = indexField ; }
public virtual PromoteReadReplicaDBClusterResponse PromoteReadReplicaDBCluster ( PromoteReadReplicaDBClusterRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = PromoteReadReplicaDBClusterRequestMarshaller . Instance ; options . ResponseUnmarshaller = PromoteReadReplicaDBClusterResponseUnmarshaller . Instance ; return Invoke < PromoteReadReplicaDBClusterResponse > ( request , options ) ; }
public virtual DescribeCapacityReservationsResponse DescribeCapacityReservations ( DescribeCapacityReservationsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeCapacityReservationsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeCapacityReservationsResponseUnmarshaller . Instance ; return Invoke < DescribeCapacityReservationsResponse > ( request , options ) ; }
public override string ToString ( ) { return " IndexSearcher ( " + reader + " ; ▁ executor = " + executor + " ) " ; }
public override bool IncrementToken ( ) { return false ; }
public void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( main + 1 ) ; out1. WriteShort ( subFrom ) ; out1. WriteShort ( subTo ) ; }
public override void Decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { if ( bitsPerValue > 32 ) { throw new System . NotSupportedException ( " Cannot ▁ decode ▁ " + bitsPerValue + " - bits ▁ values ▁ into ▁ an ▁ int [ ] " ) ; } for ( int i = 0 ; i < iterations ; ++ i ) { long block = ReadInt64 ( blocks , blocksOffset ) ; blocksOffset += 8 ; valuesOffset = Decode ( block , values , valuesOffset ) ; } }
public virtual bool IsExpectedToken ( int symbol ) { ATN atn = Interpreter . atn ; ParserRuleContext ctx = _ctx ; ATNState s = atn . states [ State ] ; IntervalSet following = atn . NextTokens ( s ) ; if ( following . Contains ( symbol ) ) { return true ; } if ( ! following . Contains ( TokenConstants . EPSILON ) ) { return false ; } while ( ctx != null && ctx . invokingState >= 0 && following . Contains ( TokenConstants . EPSILON ) ) { ATNState invokingState = atn . states [ ctx . invokingState ] ; RuleTransition rt = ( RuleTransition ) invokingState . Transition ( 0 ) ; following = atn . NextTokens ( rt . followState ) ; if ( following . Contains ( symbol ) ) { return true ; } ctx = ( ParserRuleContext ) ctx . Parent ; } if ( following . Contains ( TokenConstants . EPSILON ) && symbol == TokenConstants . EOF ) { return true ; } return false ; }
public virtual UpdateStreamResponse UpdateStream ( UpdateStreamRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateStreamRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateStreamResponseUnmarshaller . Instance ; return Invoke < UpdateStreamResponse > ( request , options ) ; }
public override ValueEval Evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { try { OperandResolver . GetSingleValue ( arg0 , srcRowIndex , srcColumnIndex ) ; return ErrorEval . NA ; } catch ( EvaluationException e ) { int result = TranslateErrorCodeToErrorTypeValue ( e . GetErrorEval ( ) . ErrorCode ) ; return new NumberEval ( result ) ; } }
public override String ToString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . Append ( GetType ( ) . Name ) . Append ( " ▁ [ " ) ; sb . Append ( _index ) . Append ( " ▁ " ) . Append ( _name ) ; sb . Append ( " ] " ) ; return sb . ToString ( ) ; }
public virtual ListAssignmentsForHITResponse ListAssignmentsForHIT ( ListAssignmentsForHITRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListAssignmentsForHITRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListAssignmentsForHITResponseUnmarshaller . Instance ; return Invoke < ListAssignmentsForHITResponse > ( request , options ) ; }
public virtual DeleteAccessControlRuleResponse DeleteAccessControlRule ( DeleteAccessControlRuleRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteAccessControlRuleRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteAccessControlRuleResponseUnmarshaller . Instance ; return Invoke < DeleteAccessControlRuleResponse > ( request , options ) ; }
public FST . Arc < long ?> GetFirstArc ( FST . Arc < long ?> arc ) { return fst . GetFirstArc ( arc ) ; }
public override void Decode ( long [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { long block = blocks [ blocksOffset ++ ] ; for ( int shift = 48 ; shift >= 0 ; shift -= 16 ) { values [ valuesOffset ++ ] = ( int ) ( ( ( long ) ( ( ulong ) block >> shift ) ) & 65535 ) ; } } }
public override long skip ( long charCount ) { if ( charCount < 0 ) { throw new System . ArgumentException ( " charCount ▁ < ▁ 0 : ▁ " + charCount ) ; } lock ( @ lock ) { checkNotClosed ( ) ; if ( charCount == 0 ) { return 0 ; } long inSkipped ; int availableFromBuffer = buf . Length - pos ; if ( availableFromBuffer > 0 ) { long requiredFromIn = charCount - availableFromBuffer ; if ( requiredFromIn <= 0 ) { pos += ( int ) ( charCount ) ; return charCount ; } pos += availableFromBuffer ; inSkipped = @ in . skip ( requiredFromIn ) ; } else { inSkipped = @ in . skip ( charCount ) ; } return inSkipped + availableFromBuffer ; } }
public virtual IDictionary < string , Ref > GetRefsMap ( ) { return advertisedRefs ; }
public virtual UpdateApiKeyResponse UpdateApiKey ( UpdateApiKeyRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateApiKeyRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateApiKeyResponseUnmarshaller . Instance ; return Invoke < UpdateApiKeyResponse > ( request , options ) ; }
public override ObjectStream OpenStream ( ) { WindowCursor wc = new WindowCursor ( db ) ; InputStream @ in ; try { @ in = new PackInputStream ( pack , objectOffset + headerLength , wc ) ; } catch ( IOException ) { return wc . Open ( GetObjectId ( ) , type ) . OpenStream ( ) ; } @ in = new BufferedInputStream ( new InflaterInputStream ( @ in , wc . Inflater ( ) , 8192 ) , 8192 ) ; return new ObjectStream . Filter ( type , size , @ in ) ; }
public ArrayList ( ) { array = libcore . util . EmptyArray . OBJECT ; }
public virtual UpdateDetectorVersionResponse UpdateDetectorVersion ( UpdateDetectorVersionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateDetectorVersionRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateDetectorVersionResponseUnmarshaller . Instance ; return Invoke < UpdateDetectorVersionResponse > ( request , options ) ; }
public void Resize ( ) { Resize ( Double . MaxValue ) ; }
public RevFlagSet ( ICollection < RevFlag > s ) : this ( ) { Sharpen . Collections . AddAll ( this , s ) ; }
public override int size ( ) { return this . _enclosing . size ( ) ; }
public sealed override long getLong ( ) { int newPosition = _position + libcore . io . SizeOf . LONG ; if ( newPosition > _limit ) { throw new java . nio . BufferUnderflowException ( ) ; } long result = libcore . io . Memory . peekLong ( backingArray , offset + _position , _order ) ; _position = newPosition ; return result ; }
public java . lang . StringBuilder insert ( int offset , long l ) { insert0 ( offset , System . Convert . ToString ( l ) ) ; return this ; }
public TurkishLowerCaseFilter ( TokenStream @ in ) : base ( @ in ) { termAtt = AddAttribute < ICharTermAttribute > ( ) ; }
public virtual ParseTreeMatch Match ( IParseTree tree , ParseTreePattern pattern ) { MultiMap < string , IParseTree > labels = new MultiMap < string , IParseTree > ( ) ; IParseTree mismatchedNode = MatchImpl ( tree , pattern . PatternTree , labels ) ; return new ParseTreeMatch ( tree , pattern , labels , mismatchedNode ) ; }
public virtual void AddIfNoOverlap ( WeightedPhraseInfo wpi ) { foreach ( WeightedPhraseInfo existWpi in PhraseList ) { if ( existWpi . IsOffsetOverlap ( wpi ) ) { existWpi . TermsInfos . AddRange ( wpi . TermsInfos ) ; return ; } } PhraseList . Add ( wpi ) ; }
public override Merger NewMerger ( Repository db ) { return new StrategySimpleTwoWayInCore . InCoreMerger ( db ) ; }
public override float DocScore ( int docId , string field , int numPayloadsSeen , float payloadScore ) { return numPayloadsSeen > 0 ? ( payloadScore / numPayloadsSeen ) : 1 ; }
public override ICollection < IParseTree > Evaluate ( IParseTree t ) { return Trees . FindAllRuleNodes ( t , ruleIndex ) ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ CFRULE ] \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . condition □ type ▁ ▁ ▁ = " ) . Append ( field_1_condition_type ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ OPTION ▁ FLAGS = 0x " ) . Append ( string . Format ( " { 0 : X } " , Options ) ) . Append ( " \ n " ) ; if ( ContainsFontFormattingBlock ) { buffer . Append ( _fontFormatting . ToString ( ) ) . Append ( " \ n " ) ; } if ( ContainsBorderFormattingBlock ) { buffer . Append ( _borderFormatting . ToString ( ) ) . Append ( " \ n " ) ; } if ( ContainsPatternFormattingBlock ) { buffer . Append ( _patternFormatting . ToString ( ) ) . Append ( " \ n " ) ; } buffer . Append ( " ▁ ▁ ▁ ▁ Formula ▁ 1 ▁ = " ) . Append ( Arrays . ToString ( field_17_formula1. Tokens ) ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ Formula ▁ 2 ▁ = " ) . Append ( Arrays . ToString ( field_18_formula2. Tokens ) ) . Append ( " \ n " ) ; buffer . Append ( " [ / CFRULE ] \ n " ) ; return buffer . ToString ( ) ; }
public virtual DescribeServiceUpdatesResponse DescribeServiceUpdates ( DescribeServiceUpdatesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeServiceUpdatesRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeServiceUpdatesResponseUnmarshaller . Instance ; return Invoke < DescribeServiceUpdatesResponse > ( request , options ) ; }
public String GetNameName ( int index ) { String result = GetNameAt ( index ) . NameName ; return result ; }
public virtual DescribeLocationsResponse DescribeLocations ( ) { return DescribeLocations ( new DescribeLocationsRequest ( ) ) ; }
public override string ToString ( ) { return " < phraseslop ▁ value = ' " ▁ + ▁ GetValueString ( ) ▁ + ▁ " ' > " + " \ n " + GetChild ( ) . ToString ( ) + " \ n </ phraseslop > " ; }
public virtual DirCacheEntry GetDirCacheEntry ( ) { return currentSubtree == null ? currentEntry : null ; }
public virtual java . nio . IntBuffer put ( int [ ] src , int srcOffset , int intCount ) { java . util . Arrays . checkOffsetAndCount ( src . Length , srcOffset , intCount ) ; if ( intCount > remaining ( ) ) { throw new java . nio . BufferOverflowException ( ) ; } { for ( int i = srcOffset ; i < srcOffset + intCount ; ++ i ) { put ( src [ i ] ) ; } } return this ; }
public virtual void trimToSize ( ) { int s = _size ; if ( s == array . Length ) { return ; } if ( s == 0 ) { array = libcore . util . EmptyArray . OBJECT ; } else { object [ ] newArray = new object [ s ] ; System . Array . Copy ( array , 0 , newArray , 0 , s ) ; array = newArray ; } modCount ++ ; }
public virtual DescribeLocalGatewayVirtualInterfacesResponse DescribeLocalGatewayVirtualInterfaces ( DescribeLocalGatewayVirtualInterfacesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeLocalGatewayVirtualInterfacesRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeLocalGatewayVirtualInterfacesResponseUnmarshaller . Instance ; return Invoke < DescribeLocalGatewayVirtualInterfacesResponse > ( request , options ) ; }
public override TokenStream Create ( TokenStream input ) { return new RussianLightStemFilter ( input ) ; }
public int [ ] ToArray ( int [ ] a ) { int [ ] rval ; if ( a . Length == _limit ) { Array . Copy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = ToArray ( ) ; } return rval ; }
public BasicSessionCredentials ( string accessKeyId , string accessKeySecret , string sessionToken , long roleSessionDurationSeconds = 0 ) { if ( accessKeyId == null ) { throw new ArgumentOutOfRangeException ( " Access ▁ key ▁ ID ▁ cannot ▁ be ▁ null . " ) ; } if ( accessKeySecret == null ) { throw new ArgumentOutOfRangeException ( " Access ▁ key ▁ secret ▁ cannot ▁ be ▁ null . " ) ; } this . accessKeyId = accessKeyId ; this . accessKeySecret = accessKeySecret ; this . sessionToken = sessionToken ; this . roleSessionDurationSeconds = roleSessionDurationSeconds ; sessionStartedTimeInMilliSeconds = DateTime . UtcNow . currentTimeMillis ( ) ; }
public sealed override java . nio . ShortBuffer get ( short [ ] dst , int dstOffset , int shortCount ) { if ( shortCount > remaining ( ) ) { throw new java . nio . BufferUnderflowException ( ) ; } System . Array . Copy ( backingArray , offset + _position , dst , dstOffset , shortCount ) ; _position += shortCount ; return this ; }
public virtual ActivateEventSourceResponse ActivateEventSource ( ActivateEventSourceRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ActivateEventSourceRequestMarshaller . Instance ; options . ResponseUnmarshaller = ActivateEventSourceResponseUnmarshaller . Instance ; return Invoke < ActivateEventSourceResponse > ( request , options ) ; }
public virtual DescribeReceiptRuleSetResponse DescribeReceiptRuleSet ( DescribeReceiptRuleSetRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeReceiptRuleSetRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeReceiptRuleSetResponseUnmarshaller . Instance ; return Invoke < DescribeReceiptRuleSetResponse > ( request , options ) ; }
public Filter ( string name ) { _name = name ; }
public override java . nio . DoubleBuffer put ( double c ) { throw new java . nio . ReadOnlyBufferException ( ) ; }
public virtual CreateTrafficPolicyInstanceResponse CreateTrafficPolicyInstance ( CreateTrafficPolicyInstanceRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateTrafficPolicyInstanceRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateTrafficPolicyInstanceResponseUnmarshaller . Instance ; return Invoke < CreateTrafficPolicyInstanceResponse > ( request , options ) ; }
public JapaneseIterationMarkCharFilter ( TextReader input , bool normalizeKanji , bool normalizeKana ) : base ( input ) { this . normalizeKanji = normalizeKanji ; this . normalizeKana = normalizeKana ; buffer . Reset ( input ) ; }
public void WriteLong ( long v ) { WriteInt ( ( int ) ( v >> 0 ) ) ; WriteInt ( ( int ) ( v >> 32 ) ) ; }
public FileResolver ( ) { exports = new ConcurrentHashMap < string , Repository > ( ) ; exportBase = new CopyOnWriteArrayList < FilePath > ( ) ; }
public ValueEval GetRef3DEval ( Ref3DPtg rptg ) { SheetRangeEvaluator sre = CreateExternSheetRefEvaluator ( rptg . ExternSheetIndex ) ; return new LazyRefEval ( rptg . Row , rptg . Column , sre ) ; }
public virtual DeleteDatasetResponse DeleteDataset ( DeleteDatasetRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteDatasetRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteDatasetResponseUnmarshaller . Instance ; return Invoke < DeleteDatasetResponse > ( request , options ) ; }
public virtual StartRelationalDatabaseResponse StartRelationalDatabase ( StartRelationalDatabaseRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = StartRelationalDatabaseRequestMarshaller . Instance ; options . ResponseUnmarshaller = StartRelationalDatabaseResponseUnmarshaller . Instance ; return Invoke < StartRelationalDatabaseResponse > ( request , options ) ; }
public virtual DescribeReservedCacheNodesOfferingsResponse DescribeReservedCacheNodesOfferings ( ) { return DescribeReservedCacheNodesOfferings ( new DescribeReservedCacheNodesOfferingsRequest ( ) ) ; }
static public double PMT ( double r , int nper , double pv , double fv , int type ) { double pmt = - r * ( pv * Math . Pow ( 1 + r , nper ) + fv ) / ( ( 1 + r * type ) * ( Math . Pow ( 1 + r , nper ) - 1 ) ) ; return pmt ; }
public virtual DescribeDocumentVersionsResponse DescribeDocumentVersions ( DescribeDocumentVersionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeDocumentVersionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeDocumentVersionsResponseUnmarshaller . Instance ; return Invoke < DescribeDocumentVersionsResponse > ( request , options ) ; }
public virtual ListPublishingDestinationsResponse ListPublishingDestinations ( ListPublishingDestinationsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListPublishingDestinationsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListPublishingDestinationsResponseUnmarshaller . Instance ; return Invoke < ListPublishingDestinationsResponse > ( request , options ) ; }
public DeleteAccountAliasRequest ( string accountAlias ) { _accountAlias = accountAlias ; }
public static float [ ] Grow ( float [ ] array ) { return Grow ( array , 1 + array . Length ) ; }
public override string OutputToString ( object output ) { if ( ! ( output is IList ) ) { return outputs . OutputToString ( ( T ) output ) ; } else { IList outputList = ( IList ) output ; StringBuilder b = new StringBuilder ( ) ; b . Append ( ' [ ' ) ; for ( int i = 0 ; i < outputList . Count ; i ++ ) { if ( i > 0 ) { b . Append ( " , ▁ " ) ; } b . Append ( outputs . OutputToString ( ( T ) outputList [ i ] ) ) ; } b . Append ( ' ] ' ) ; return b . ToString ( ) ; } }
public void NotifyDeleteCell ( ICell cell ) { _bookEvaluator . NotifyDeleteCell ( new HSSFEvaluationCell ( cell ) ) ; }
public java . lang . StringBuilder replace ( int start , int end , string str ) { replace0 ( start , end , str ) ; return this ; }
public virtual SetIdentityPoolConfigurationResponse SetIdentityPoolConfiguration ( SetIdentityPoolConfigurationRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = SetIdentityPoolConfigurationRequestMarshaller . Instance ; options . ResponseUnmarshaller = SetIdentityPoolConfigurationResponseUnmarshaller . Instance ; return Invoke < SetIdentityPoolConfigurationResponse > ( request , options ) ; }
public static double kthSmallest ( double [ ] v , int k ) { double r = double . NaN ; k -- ; if ( v != null && v . Length > k && k >= 0 ) { Array . Sort ( v ) ; r = v [ k ] ; } return r ; }
public override void Set ( int index , long value ) { int o = ( int ) ( ( uint ) index >> 5 ) ; int b = index & 31 ; int shift = b << 1 ; blocks [ o ] = ( blocks [ o ] & ~ ( 3L << shift ) ) | ( value << shift ) ; }
public override string ToString ( ) { var children = GetChildren ( ) ; if ( children == null || children . Count == 0 ) return " < boolean ▁ operation = ' and ' /> " ; StringBuilder sb = new StringBuilder ( ) ; sb . Append ( " < boolean ▁ operation = ' and ' > " ) ; foreach ( IQueryNode child in children ) { sb . Append ( " \ n " ) ; sb . Append ( child . ToString ( ) ) ; } sb . Append ( " \ n </ boolean > " ) ; return sb . ToString ( ) ; }
public int SumTokenSizes ( int fromIx , int toIx ) { int result = 0 ; for ( int i = fromIx ; i < toIx ; i ++ ) { result += _ptgs [ i ] . Size ; } return result ; }
public virtual void SetReadonly ( bool @ readonly ) { if ( this . @ readonly && !@ readonly ) { throw new InvalidOperationException ( " can ' t alter readonly IntervalSet " ) ; } this . @ readonly ▁ = ▁ @ readonly ; }
public void ClearConsumingCell ( FormulaCellCacheEntry cce ) { if ( ! _consumingCells . Remove ( cce ) ) { throw new InvalidOperationException ( " Specified ▁ formula ▁ cell ▁ is ▁ not ▁ consumed ▁ by ▁ this ▁ cell " ) ; } }
public override java . util . List < E > subList ( int start , int end ) { lock ( mutex ) { return new java . util . Collections . SynchronizedRandomAccessList < E > ( list . subList ( start , end ) , mutex ) ; } }
public virtual FileHeader GetFileHeader ( ) { return file ; }
public virtual AttachLoadBalancersResponse AttachLoadBalancers ( AttachLoadBalancersRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AttachLoadBalancersRequestMarshaller . Instance ; options . ResponseUnmarshaller = AttachLoadBalancersResponseUnmarshaller . Instance ; return Invoke < AttachLoadBalancersResponse > ( request , options ) ; }
public InitiateJobRequest ( string accountId , string vaultName , JobParameters jobParameters ) { _accountId = accountId ; _vaultName = vaultName ; _jobParameters = jobParameters ; }
public override string ToString ( ) { return " SPL " ; }
public ReplaceableAttribute ( string name , string value , bool replace ) { _name = name ; _value = value ; _replace = replace ; }
public void Add ( IIndexableField field ) { fields . Add ( field ) ; }
public virtual DeleteStackSetResponse DeleteStackSet ( DeleteStackSetRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteStackSetRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteStackSetResponseUnmarshaller . Instance ; return Invoke < DeleteStackSetResponse > ( request , options ) ; }
public GetRepoBuildRuleListRequest ( ) : base ( " cr " , " 2016 - 06 - 07 " , " GetRepoBuildRuleList " , " cr " , " openAPI " ) { UriPattern = " / repos / [ RepoNamespace ] / [ RepoName ] / rules " ; Method = MethodType . GET ; }
public SparseArray ( int initialCapacity ) { initialCapacity = android . util . @ internal . ArrayUtils . idealIntArraySize ( initialCapacity ) ; mKeys = new int [ initialCapacity ] ; mValues = new object [ initialCapacity ] ; mSize = 0 ; }
public InvokeServiceRequest ( ) : base ( " industry - brain " , " 2018 - 07 - 12 " , " InvokeService " ) { Method = MethodType . POST ; }
public ListAlbumPhotosRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListAlbumPhotos " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public bool hasPrevious ( ) { return link != list . voidLink ; }
public virtual DeleteHsmConfigurationResponse DeleteHsmConfiguration ( DeleteHsmConfigurationRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteHsmConfigurationRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteHsmConfigurationResponseUnmarshaller . Instance ; return Invoke < DeleteHsmConfigurationResponse > ( request , options ) ; }
public CreateLoadBalancerRequest ( string loadBalancerName ) { _loadBalancerName = loadBalancerName ; }
public string getUserInfo ( ) { return decode ( userInfo ) ; }
public virtual TagAttendeeResponse TagAttendee ( TagAttendeeRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = TagAttendeeRequestMarshaller . Instance ; options . ResponseUnmarshaller = TagAttendeeResponseUnmarshaller . Instance ; return Invoke < TagAttendeeResponse > ( request , options ) ; }
public virtual string GetRefName ( ) { return name ; }
public override WAH8DocIdSet Build ( ) { if ( this . wordNum != - 1 ) { AddWord ( wordNum , ( byte ) word ) ; } return base . Build ( ) ; }
public virtual bool IsSubTotal ( int rowIndex , int columnIndex ) { return false ; }
public virtual DescribeDBProxiesResponse DescribeDBProxies ( DescribeDBProxiesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeDBProxiesRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeDBProxiesResponseUnmarshaller . Instance ; return Invoke < DescribeDBProxiesResponse > ( request , options ) ; }
public virtual GetVoiceConnectorProxyResponse GetVoiceConnectorProxy ( GetVoiceConnectorProxyRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetVoiceConnectorProxyRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetVoiceConnectorProxyResponseUnmarshaller . Instance ; return Invoke < GetVoiceConnectorProxyResponse > ( request , options ) ; }
public virtual void FromConfig ( Config rc ) { SetPackedGitOpenFiles ( rc . GetInt ( " core " , null , " packedgitopenfiles " , GetPackedGitOpenFiles ( ) ) ) ; SetPackedGitLimit ( rc . GetLong ( " core " , null , " packedgitlimit " , GetPackedGitLimit ( ) ) ) ; SetPackedGitWindowSize ( rc . GetInt ( " core " , null , " packedgitwindowsize " , GetPackedGitWindowSize ( ) ) ) ; SetPackedGitMMAP ( rc . GetBoolean ( " core " , null , " packedgitmmap " , IsPackedGitMMAP ( ) ) ) ; SetDeltaBaseCacheLimit ( rc . GetInt ( " core " , null , " deltabasecachelimit " , GetDeltaBaseCacheLimit ( ) ) ) ; long maxMem = Runtime . GetRuntime ( ) . MaxMemory ( ) ; long sft = rc . GetLong ( " core " , null , " streamfilethreshold " , GetStreamFileThreshold ( ) ) ; sft = Math . Min ( sft , maxMem / 4 ) ; sft = Math . Min ( sft , int . MaxValue ) ; SetStreamFileThreshold ( ( int ) sft ) ; }
public static DateTime GetJavaDate ( double date ) { return GetJavaDate ( date , false ) ; }
public virtual StartPersonTrackingResponse StartPersonTracking ( StartPersonTrackingRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = StartPersonTrackingRequestMarshaller . Instance ; options . ResponseUnmarshaller = StartPersonTrackingResponseUnmarshaller . Instance ; return Invoke < StartPersonTrackingResponse > ( request , options ) ; }
public override int size ( ) { return this . _enclosing . size ( ) ; }
public virtual GetRouteResponse GetRoute ( GetRouteRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetRouteRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetRouteResponseUnmarshaller . Instance ; return Invoke < GetRouteResponse > ( request , options ) ; }
public virtual DeleteClusterResponse DeleteCluster ( DeleteClusterRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteClusterRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteClusterResponseUnmarshaller . Instance ; return Invoke < DeleteClusterResponse > ( request , options ) ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ MMS ] \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . addMenu ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( StringUtil . ToHexString ( AddMenuCount ) ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . delMenu ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( StringUtil . ToHexString ( DelMenuCount ) ) . Append ( " \ n " ) ; buffer . Append ( " [ / MMS ] \ n " ) ; return buffer . ToString ( ) ; }
public FileBasedConfig ( Config @ base , FilePath cfgLocation , FS fs ) : base ( @ base ) { configFile = cfgLocation ; this . fs = fs ; this . snapshot = FileSnapshot . DIRTY ; this . hash = ObjectId . ZeroId ; }
public override int Following ( int pos ) { if ( pos < text . BeginIndex || pos > text . EndIndex ) { throw new ArgumentException ( " offset ▁ out ▁ of ▁ bounds " ) ; } else if ( 0 == sentenceStarts . Length ) { text . SetIndex ( text . BeginIndex ) ; return Done ; } else if ( pos >= sentenceStarts [ sentenceStarts . Length - 1 ] ) { text . SetIndex ( text . EndIndex ) ; currentSentence = sentenceStarts . Length - 1 ; return Done ; } else { currentSentence = ( sentenceStarts . Length - 1 ) / 2 ; MoveToSentenceAt ( pos , 0 , sentenceStarts . Length - 2 ) ; text . SetIndex ( sentenceStarts [ ++ currentSentence ] ) ; return Current ; } }
public virtual UpdateParameterGroupResponse UpdateParameterGroup ( UpdateParameterGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateParameterGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateParameterGroupResponseUnmarshaller . Instance ; return Invoke < UpdateParameterGroupResponse > ( request , options ) ; }
public override Object Clone ( ) { SeriesChartGroupIndexRecord rec = new SeriesChartGroupIndexRecord ( ) ; rec . field_1_chartGroupIndex = field_1_chartGroupIndex ; return rec ; }
public static double CalcDistanceFromErrPct ( IShape shape , double distErrPct , SpatialContext ctx ) { if ( distErrPct < 0 || distErrPct > 0.5 ) { throw new ArgumentException ( " distErrPct ▁ " + distErrPct + " ▁ must ▁ be ▁ between ▁ [ 0 ▁ to ▁ 0.5 ] " , " distErrPct " ) ; } if ( distErrPct == 0 || shape is IPoint ) { return 0 ; } IRectangle bbox = shape . BoundingBox ; IPoint ctr = bbox . Center ; double y = ( ctr . Y >= 0 ? bbox . MaxY : bbox . MinY ) ; double diagonalDist = ctx . DistCalc . Distance ( ctr , bbox . MaxX , y ) ; return diagonalDist * distErrPct ; }
public virtual int codePointAt ( int index ) { if ( index < 0 || index >= count ) { throw indexAndLength ( index ) ; } return Sharpen . CharHelper . CodePointAt ( value , index , count ) ; }
public void SetPasswordVerifier ( int passwordVerifier ) { this . passwordVerifier = passwordVerifier ; }
public ListVaultsRequest ( string accountId ) { _accountId = accountId ; }
public SquashMessageFormatter ( ) { dateFormatter = new GitDateFormatter ( GitDateFormatter . Format . DEFAULT ) ; }
public GetVideoCoverRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetVideoCover " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public override int lastIndexOf ( object @ object ) { int pos = _size ; java . util . LinkedList . Link < E > link = voidLink . previous ; if ( @ object != null ) { while ( link != voidLink ) { pos -- ; if ( @ object . Equals ( link . data ) ) { return pos ; } link = link . previous ; } } else { while ( link != voidLink ) { pos -- ; if ( ( object ) link . data == null ) { return pos ; } link = link . previous ; } } return - 1 ; }
public virtual DescribeSpotFleetRequestsResponse DescribeSpotFleetRequests ( DescribeSpotFleetRequestsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeSpotFleetRequestsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeSpotFleetRequestsResponseUnmarshaller . Instance ; return Invoke < DescribeSpotFleetRequestsResponse > ( request , options ) ; }
public virtual IndexFacesResponse IndexFaces ( IndexFacesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = IndexFacesRequestMarshaller . Instance ; options . ResponseUnmarshaller = IndexFacesResponseUnmarshaller . Instance ; return Invoke < IndexFacesResponse > ( request , options ) ; }
public override BreakIterator GetBreakIterator ( int script ) { switch ( script ) { case UScript . Japanese : return ( BreakIterator ) cjkBreakIterator . Clone ( ) ; case UScript . Myanmar : if ( myanmarAsWords ) { return ( BreakIterator ) defaultBreakIterator . Clone ( ) ; } else { return ( BreakIterator ) myanmarSyllableIterator . Clone ( ) ; } default : return ( BreakIterator ) defaultBreakIterator . Clone ( ) ; } }
public override String ToString ( ) { StringBuilder b = new StringBuilder ( ) ; b . Append ( " [ DCONREF ] \ n " ) ; b . Append ( " ▁ ▁ ▁ ▁ . ref \ n " ) ; b . Append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . firstrow ▁ ▁ ▁ = ▁ " ) . Append ( firstRow ) . Append ( " \ n " ) ; b . Append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . lastrow ▁ ▁ ▁ ▁ = ▁ " ) . Append ( lastRow ) . Append ( " \ n " ) ; b . Append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . firstcol ▁ ▁ ▁ = ▁ " ) . Append ( firstCol ) . Append ( " \ n " ) ; b . Append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . lastcol ▁ ▁ ▁ ▁ = ▁ " ) . Append ( lastCol ) . Append ( " \ n " ) ; b . Append ( " ▁ ▁ ▁ ▁ . cch ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( charCount ) . Append ( " \ n " ) ; b . Append ( " ▁ ▁ ▁ ▁ . stFile \ n " ) ; b . Append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . h ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( charType ) . Append ( " \ n " ) ; b . Append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . rgb ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( ReadablePath ) . Append ( " \ n " ) ; b . Append ( " [ / DCONREF ] \ n " ) ; return b . ToString ( ) ; }
public virtual int GetPackedGitOpenFiles ( ) { return packedGitOpenFiles ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ FEATURE ▁ HEADER ] \ n " ) ; buffer . Append ( " [ / FEATURE ▁ HEADER ] \ n " ) ; return buffer . ToString ( ) ; }
public static byte [ ] GetToUnicodeLE ( String string1 ) { return UTF16LE . GetBytes ( string1 ) ; }
public IList < string > GetFooterLines ( string keyName ) { return GetFooterLines ( new FooterKey ( keyName ) ) ; }
public override void Refresh ( ) { base . Refresh ( ) ; Rescan ( ) ; }
public override float get ( int index ) { checkIndex ( index ) ; return byteBuffer . getFloat ( index * libcore . io . SizeOf . FLOAT ) ; }
public virtual DeleteDetectorResponse DeleteDetector ( DeleteDetectorRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteDetectorRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteDetectorResponseUnmarshaller . Instance ; return Invoke < DeleteDetectorResponse > ( request , options ) ; }
public override int [ ] Grow ( ) { Debug . Assert ( bytesStart != null ) ; return bytesStart = ArrayUtil . Grow ( bytesStart , bytesStart . Length + 1 ) ; }
public virtual ListExclusionsResponse ListExclusions ( ListExclusionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListExclusionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListExclusionsResponseUnmarshaller . Instance ; return Invoke < ListExclusionsResponse > ( request , options ) ; }
public static SpatialStrategy GetSpatialStrategy ( int roundNumber ) { SpatialStrategy result ; if ( ! spatialStrategyCache . TryGetValue ( roundNumber , out result ) || result == null ) { throw new InvalidOperationException ( " Strategy ▁ should ▁ have ▁ been ▁ init ' ed by SpatialDocMaker by now " ) ; } return ▁ result ; }
public virtual RestoreDBClusterToPointInTimeResponse RestoreDBClusterToPointInTime ( RestoreDBClusterToPointInTimeRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = RestoreDBClusterToPointInTimeRequestMarshaller . Instance ; options . ResponseUnmarshaller = RestoreDBClusterToPointInTimeResponseUnmarshaller . Instance ; return Invoke < RestoreDBClusterToPointInTimeResponse > ( request , options ) ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( field_1_categoryDataType ) ; out1. WriteShort ( field_2_valuesDataType ) ; out1. WriteShort ( field_3_numCategories ) ; out1. WriteShort ( field_4_numValues ) ; out1. WriteShort ( field_5_bubbleSeriesType ) ; out1. WriteShort ( field_6_numBubbleValues ) ; }
public virtual PostAgentProfileResponse PostAgentProfile ( PostAgentProfileRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = PostAgentProfileRequestMarshaller . Instance ; options . ResponseUnmarshaller = PostAgentProfileResponseUnmarshaller . Instance ; return Invoke < PostAgentProfileResponse > ( request , options ) ; }
public virtual ParseTreePattern CompileParseTreePattern ( string pattern , int patternRuleIndex ) { if ( ( ( ITokenStream ) InputStream ) != null ) { ITokenSource tokenSource = ( ( ITokenStream ) InputStream ) . TokenSource ; if ( tokenSource is Lexer ) { Lexer lexer = ( Lexer ) tokenSource ; return CompileParseTreePattern ( pattern , patternRuleIndex , lexer ) ; } } throw new NotSupportedException ( " Parser ▁ can ' t discover a lexer to use " ) ; }
public virtual BacktrackDBClusterResponse BacktrackDBCluster ( BacktrackDBClusterRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = BacktrackDBClusterRequestMarshaller . Instance ; options . ResponseUnmarshaller = BacktrackDBClusterResponseUnmarshaller . Instance ; return Invoke < BacktrackDBClusterResponse > ( request , options ) ; }
public override string GetName ( ) { return strategyName ; }
public virtual void CopyTo ( byte [ ] b , int o ) { FormatHexByte ( b , o + 0 , w1 ) ; FormatHexByte ( b , o + 8 , w2 ) ; FormatHexByte ( b , o + 16 , w3 ) ; FormatHexByte ( b , o + 24 , w4 ) ; FormatHexByte ( b , o + 32 , w5 ) ; }
public static IntList LineMap ( byte [ ] buf , int ptr , int end ) { IntList map = new IntList ( ( end - ptr ) / 36 ) ; map . FillTo ( 1 , int . MinValue ) ; for ( ; ptr < end ; ptr = NextLF ( buf , ptr ) ) { map . Add ( ptr ) ; } map . Add ( end ) ; return map ; }
public virtual ICollection < ObjectId > GetAdditionalHaves ( ) { return Sharpen . Collections . EmptySet < ObjectId > ( ) ; }
public override long RamBytesUsed ( ) { return _termsCache . Values . Sum ( simpleTextTerms => ( simpleTextTerms != null ) ? simpleTextTerms . RamBytesUsed ( ) : 0 ) ; }
public String ToXml ( String tab ) { StringBuilder builder = new StringBuilder ( ) ; builder . Append ( tab ) . Append ( " < " ) . Append ( RecordName ) . Append ( " >\ n " ) ; for ( IEnumerator iterator = EscherRecords . GetEnumerator ( ) ; iterator . MoveNext ( ) ; ) { EscherRecord escherRecord = ( EscherRecord ) iterator . Current ; builder . Append ( escherRecord . ToXml ( tab + " \ t " ) ) ; } builder . Append ( tab ) . Append ( " </ " ) . Append ( RecordName ) . Append ( " >\ n " ) ; return builder . ToString ( ) ; }
public override TokenStream Create ( TokenStream input ) { return new GalicianMinimalStemFilter ( input ) ; }
public override string ToString ( ) { StringBuilder r = new StringBuilder ( ) ; r . Append ( " Commit " ) ; r . Append ( " = { \ n " ) ; r . Append ( " tree ▁ " ) ; r . Append ( treeId != null ? treeId . Name : " NOT □ SET " ) ; r . Append ( " \ n " ) ; foreach ( ObjectId p in parentIds ) { r . Append ( " parent ▁ " ) ; r . Append ( p . Name ) ; r . Append ( " \ n " ) ; } r . Append ( " author ▁ " ) ; r . Append ( author != null ? author . ToString ( ) : " NOT □ SET " ) ; r . Append ( " \ n " ) ; r . Append ( " committer ▁ " ) ; r . Append ( committer != null ? committer . ToString ( ) : " NOT □ SET " ) ; r . Append ( " \ n " ) ; if ( encoding != null && encoding != Constants . CHARSET ) { r . Append ( " encoding ▁ " ) ; r . Append ( encoding . Name ( ) ) ; r . Append ( " \ n " ) ; } r . Append ( " \ n " ) ; r . Append ( message != null ? message : string . Empty ) ; r . Append ( " } " ) ; return r . ToString ( ) ; }
public IndicNormalizationFilterFactory ( IDictionary < string , string > args ) : base ( args ) { if ( args . Count > 0 ) { throw new System . ArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public virtual CreateOptionGroupResponse CreateOptionGroup ( CreateOptionGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateOptionGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateOptionGroupResponseUnmarshaller . Instance ; return Invoke < CreateOptionGroupResponse > ( request , options ) ; }
public virtual AssociateMemberAccountResponse AssociateMemberAccount ( AssociateMemberAccountRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AssociateMemberAccountRequestMarshaller . Instance ; options . ResponseUnmarshaller = AssociateMemberAccountResponseUnmarshaller . Instance ; return Invoke < AssociateMemberAccountResponse > ( request , options ) ; }
public virtual void run ( ) { this . _enclosing . doRefreshProgress ( this . mId , this . mProgress , this . mFromUser , true ) ; this . _enclosing . mRefreshProgressRunnable = this ; }
public virtual SetTerminationProtectionResponse SetTerminationProtection ( SetTerminationProtectionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = SetTerminationProtectionRequestMarshaller . Instance ; options . ResponseUnmarshaller = SetTerminationProtectionResponseUnmarshaller . Instance ; return Invoke < SetTerminationProtectionResponse > ( request , options ) ; }
public virtual string GetErrorHeader ( RecognitionException e ) { int line = e . OffendingToken . Line ; int charPositionInLine = e . OffendingToken . Column ; return " line ▁ " + line + " : " + charPositionInLine ; }
public override java . nio . CharBuffer asReadOnlyBuffer ( ) { java . nio . CharToByteBufferAdapter buf = new java . nio . CharToByteBufferAdapter ( byteBuffer . asReadOnlyBuffer ( ) ) ; buf . _limit = _limit ; buf . _position = _position ; buf . _mark = _mark ; buf . byteBuffer . _order = byteBuffer . _order ; return buf ; }
public virtual StopSentimentDetectionJobResponse StopSentimentDetectionJob ( StopSentimentDetectionJobRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = StopSentimentDetectionJobRequestMarshaller . Instance ; options . ResponseUnmarshaller = StopSentimentDetectionJobResponseUnmarshaller . Instance ; return Invoke < StopSentimentDetectionJobResponse > ( request , options ) ; }
public virtual ObjectIdSubclassMap < ObjectId > GetNewObjectIds ( ) { if ( newObjectIds != null ) { return newObjectIds ; } return new ObjectIdSubclassMap < ObjectId > ( ) ; }
protected internal override void Clear ( ) { hash = Hash ( new byte [ 0 ] ) ; base . Clear ( ) ; }
public override void reset ( ) { lock ( @ lock ) { checkNotClosed ( ) ; if ( _mark == - 1 ) { throw new System . IO . IOException ( " Invalid ▁ mark " ) ; } pos = _mark ; } }
public RefErrorPtg ( ILittleEndianInput in1 ) { field_1_reserved = in1. ReadInt ( ) ; }
public virtual SuspendGameServerGroupResponse SuspendGameServerGroup ( SuspendGameServerGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = SuspendGameServerGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = SuspendGameServerGroupResponseUnmarshaller . Instance ; return Invoke < SuspendGameServerGroupResponse > ( request , options ) ; }
public ValueEval Evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { if ( args . Length != 3 ) { return ErrorEval . VALUE_INVALID ; } return Evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; }
public GetRepoRequest ( ) : base ( " cr " , " 2016 - 06 - 07 " , " GetRepo " , " cr " , " openAPI " ) { UriPattern = " / repos / [ RepoNamespace ] / [ RepoName ] " ; Method = MethodType . GET ; }
public virtual void SetDate ( DateTime ? date ) { if ( date . HasValue ) { SetDate ( DateTools . DateToString ( date . Value , DateTools . Resolution . SECOND ) ) ; } else { this . date = null ; } }
public override TokenStream Create ( TokenStream input ) { return new GermanMinimalStemFilter ( input ) ; }
public override object [ ] toArray ( ) { return ( object [ ] ) a . Clone ( ) ; }
public override void write ( char [ ] buffer , int offset , int len ) { java . util . Arrays . checkOffsetAndCount ( buffer . Length , offset , len ) ; lock ( @ lock ) { expand ( len ) ; System . Array . Copy ( buffer , offset , this . buf , this . count , len ) ; this . count += len ; } }
public static RevFilter After ( long ts ) { return new CommitTimeRevFilterAfter ( ts ) ; }
public DeleteGroupPolicyRequest ( string groupName , string policyName ) { _groupName = groupName ; _policyName = policyName ; }
public virtual DeregisterTransitGatewayMulticastGroupMembersResponse DeregisterTransitGatewayMulticastGroupMembers ( DeregisterTransitGatewayMulticastGroupMembersRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeregisterTransitGatewayMulticastGroupMembersRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeregisterTransitGatewayMulticastGroupMembersResponseUnmarshaller . Instance ; return Invoke < DeregisterTransitGatewayMulticastGroupMembersResponse > ( request , options ) ; }
public virtual BatchDeleteScheduledActionResponse BatchDeleteScheduledAction ( BatchDeleteScheduledActionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = BatchDeleteScheduledActionRequestMarshaller . Instance ; options . ResponseUnmarshaller = BatchDeleteScheduledActionResponseUnmarshaller . Instance ; return Invoke < BatchDeleteScheduledActionResponse > ( request , options ) ; }
public virtual CreateAlgorithmResponse CreateAlgorithm ( CreateAlgorithmRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateAlgorithmRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateAlgorithmResponseUnmarshaller . Instance ; return Invoke < CreateAlgorithmResponse > ( request , options ) ; }
public int ReadUByte ( ) { CheckPosition ( 1 ) ; return _buf [ _ReadIndex ++ ] & 0xFF ; }
public virtual void SetLength ( int sz ) { NB . EncodeInt32 ( info , infoOffset + P_SIZE , sz ) ; }
public virtual DescribeScalingProcessTypesResponse DescribeScalingProcessTypes ( ) { return DescribeScalingProcessTypes ( new DescribeScalingProcessTypesRequest ( ) ) ; }
public virtual ListResourceRecordSetsResponse ListResourceRecordSets ( ListResourceRecordSetsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListResourceRecordSetsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListResourceRecordSetsResponseUnmarshaller . Instance ; return Invoke < ListResourceRecordSetsResponse > ( request , options ) ; }
public override IToken RecoverInline ( Parser recognizer ) { InputMismatchException e = new InputMismatchException ( recognizer ) ; for ( ParserRuleContext context = recognizer . Context ; context != null ; context = ( ( ParserRuleContext ) context . Parent ) ) { context . exception = e ; } throw new ParseCanceledException ( e ) ; }
public virtual SetTagsForResourceResponse SetTagsForResource ( SetTagsForResourceRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = SetTagsForResourceRequestMarshaller . Instance ; options . ResponseUnmarshaller = SetTagsForResourceResponseUnmarshaller . Instance ; return Invoke < SetTagsForResourceResponse > ( request , options ) ; }
public ModifyStrategyRequest ( ) : base ( " aegis " , " 2016 - 11 - 11 " , " ModifyStrategy " , " vipaegis " , " openAPI " ) { Method = MethodType . POST ; }
public virtual DescribeVpcEndpointServicesResponse DescribeVpcEndpointServices ( DescribeVpcEndpointServicesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeVpcEndpointServicesRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeVpcEndpointServicesResponseUnmarshaller . Instance ; return Invoke < DescribeVpcEndpointServicesResponse > ( request , options ) ; }
public virtual EnableLoggingResponse EnableLogging ( EnableLoggingRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = EnableLoggingRequestMarshaller . Instance ; options . ResponseUnmarshaller = EnableLoggingResponseUnmarshaller . Instance ; return Invoke < EnableLoggingResponse > ( request , options ) ; }
public override bool contains ( object o ) { return this . _enclosing . containsValue ( o ) ; }
public SheetRangeIdentifier ( String bookName , NameIdentifier firstSheetIdentifier , NameIdentifier lastSheetIdentifier ) : base ( bookName , firstSheetIdentifier ) { _lastSheetIdentifier = lastSheetIdentifier ; }
public DomainMetadataRequest ( string domainName ) { _domainName = domainName ; }
public ParseException ( Token currentToken , int [ ] [ ] expectedTokenSequences , string [ ] tokenImage ) : base ( Initialize ( currentToken , expectedTokenSequences , tokenImage ) ) { this . CurrentToken = currentToken ; this . ExpectedTokenSequences = expectedTokenSequences ; this . TokenImage = tokenImage ; }
public FetchPhotosRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " FetchPhotos " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public java . io . PrintWriter writer ( ) { return _writer ; }
public NGramTokenizerFactory ( IDictionary < string , string > args ) : base ( args ) { minGramSize = GetInt32 ( args , " minGramSize " , NGramTokenizer . DEFAULT_MIN_NGRAM_SIZE ) ; maxGramSize = GetInt32 ( args , " maxGramSize " , NGramTokenizer . DEFAULT_MAX_NGRAM_SIZE ) ; if ( args . Count > 0 ) { throw new System . ArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public virtual bool IsDirectoryFileConflict ( ) { return dfConflict != null ; }
public IndonesianStemFilter ( TokenStream input , bool stemDerivational ) : base ( input ) { this . stemDerivational = stemDerivational ; termAtt = AddAttribute < ICharTermAttribute > ( ) ; keywordAtt = AddAttribute < IKeywordAttribute > ( ) ; }
public virtual CreateTrafficPolicyResponse CreateTrafficPolicy ( CreateTrafficPolicyRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateTrafficPolicyRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateTrafficPolicyResponseUnmarshaller . Instance ; return Invoke < CreateTrafficPolicyResponse > ( request , options ) ; }
public void Serialize ( ILittleEndianOutput out1 ) { out1. WriteInt ( fSD ) ; out1. WriteInt ( passwordVerifier ) ; StringUtil . WriteUnicodeString ( out1 , title ) ; out1. Write ( securityDescriptor ) ; }
public static double Floor ( double n , double s ) { double f ; if ( ( n < 0 && s > 0 ) || ( n > 0 && s < 0 ) || ( s == 0 && n != 0 ) ) { f = double . NaN ; } else { f = ( n == 0 || s == 0 ) ? 0 : Math . Floor ( n / s ) * s ; } return f ; }
public ByteArrayDataOutput ( byte [ ] bytes , int offset , int len ) { Reset ( bytes , offset , len ) ; }
public static IList < ITree > GetChildren ( ITree t ) { IList < ITree > kids = new List < ITree > ( ) ; for ( int i = 0 ; i < t . ChildCount ; i ++ ) { kids . Add ( t . GetChild ( i ) ) ; } return kids ; }
public override void clear ( ) { this . _enclosing . clear ( ) ; }
public RefreshAllRecord ( bool refreshAll ) : this ( 0 ) { RefreshAll = ( refreshAll ) ; }
public virtual DeleteNamedQueryResponse DeleteNamedQuery ( DeleteNamedQueryRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteNamedQueryRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteNamedQueryResponseUnmarshaller . Instance ; return Invoke < DeleteNamedQueryResponse > ( request , options ) ; }
public GraphvizFormatter ( ConnectionCosts costs ) { this . costs = costs ; this . bestPathMap = new Dictionary < string , string > ( ) ; sb . Append ( FormatHeader ( ) ) ; sb . Append ( " ▁ ▁ init ▁ [ style = invis ] \ n " ) ; sb . Append ( " ▁ ▁ init ▁ -> ▁ 0.0 ▁ [ label =\ " " + BOS_LABEL + " \ " ] \ n " ) ; }
public CheckMultiagentRequest ( ) : base ( " visionai - poc " , " 2020 - 04 - 08 " , " CheckMultiagent " ) { Method = MethodType . POST ; }
public virtual ListUserProfilesResponse ListUserProfiles ( ListUserProfilesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListUserProfilesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListUserProfilesResponseUnmarshaller . Instance ; return Invoke < ListUserProfilesResponse > ( request , options ) ; }
public virtual CreateRelationalDatabaseFromSnapshotResponse CreateRelationalDatabaseFromSnapshot ( CreateRelationalDatabaseFromSnapshotRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateRelationalDatabaseFromSnapshotRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateRelationalDatabaseFromSnapshotResponseUnmarshaller . Instance ; return Invoke < CreateRelationalDatabaseFromSnapshotResponse > ( request , options ) ; }
public virtual StartTaskResponse StartTask ( StartTaskRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = StartTaskRequestMarshaller . Instance ; options . ResponseUnmarshaller = StartTaskResponseUnmarshaller . Instance ; return Invoke < StartTaskResponse > ( request , options ) ; }
public virtual ICollection < string > GetIgnoredPaths ( ) { return ignoredPaths ; }
public FeatSmartTag ( RecordInputStream in1 ) { data = in1. ReadRemainder ( ) ; }
public Change ( ChangeAction action , ResourceRecordSet resourceRecordSet ) { _action = action ; _resourceRecordSet = resourceRecordSet ; }
public virtual DeleteImageResponse DeleteImage ( DeleteImageRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteImageRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteImageResponseUnmarshaller . Instance ; return Invoke < DeleteImageResponse > ( request , options ) ; }
public virtual CreateConfigurationSetResponse CreateConfigurationSet ( CreateConfigurationSetRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateConfigurationSetRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateConfigurationSetResponseUnmarshaller . Instance ; return Invoke < CreateConfigurationSetResponse > ( request , options ) ; }
public virtual java . util . Iterator < E > iterator ( ) { object [ ] snapshot = elements ; return new java . util . concurrent . CopyOnWriteArrayList . CowIterator < E > ( snapshot , 0 , snapshot . Length ) ; }
public override void VisitContainedRecords ( RecordVisitor rv ) { if ( _recs . Count == 0 ) { return ; } rv . VisitRecord ( _bofRec ) ; for ( int i = 0 ; i < _recs . Count ; i ++ ) { RecordBase rb = _recs [ i ] ; if ( rb is RecordAggregate ) { ( ( RecordAggregate ) rb ) . VisitContainedRecords ( rv ) ; } else { rv . VisitRecord ( ( Record ) rb ) ; } } rv . VisitRecord ( EOFRecord . instance ) ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ FtCbls ▁ ] " ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ size ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( DataSize ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ reserved ▁ = ▁ " ) . Append ( HexDump . ToHex ( reserved ) ) . Append ( " \ n " ) ; buffer . Append ( " [ / FtCbls ▁ ] " ) . Append ( " \ n " ) ; return buffer . ToString ( ) ; }
public static BATBlock CreateEmptyBATBlock ( POIFSBigBlockSize bigBlockSize , bool isXBAT ) { BATBlock block = new BATBlock ( bigBlockSize ) ; if ( isXBAT ) { block . SetXBATChain ( bigBlockSize , POIFSConstants . END_OF_CHAIN ) ; } return block ; }
public virtual TagResourceResponse TagResource ( TagResourceRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = TagResourceRequestMarshaller . Instance ; options . ResponseUnmarshaller = TagResourceResponseUnmarshaller . Instance ; return Invoke < TagResourceResponse > ( request , options ) ; }
public virtual DeleteMailboxPermissionsResponse DeleteMailboxPermissions ( DeleteMailboxPermissionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteMailboxPermissionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteMailboxPermissionsResponseUnmarshaller . Instance ; return Invoke < DeleteMailboxPermissionsResponse > ( request , options ) ; }
public virtual ListDatasetGroupsResponse ListDatasetGroups ( ListDatasetGroupsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListDatasetGroupsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListDatasetGroupsResponseUnmarshaller . Instance ; return Invoke < ListDatasetGroupsResponse > ( request , options ) ; }
public virtual ResumeProcessesResponse ResumeProcesses ( ResumeProcessesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ResumeProcessesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ResumeProcessesResponseUnmarshaller . Instance ; return Invoke < ResumeProcessesResponse > ( request , options ) ; }
public virtual GetPersonTrackingResponse GetPersonTracking ( GetPersonTrackingRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetPersonTrackingRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetPersonTrackingResponseUnmarshaller . Instance ; return Invoke < GetPersonTrackingResponse > ( request , options ) ; }
public String ToFormulaString ( String [ ] operands ) { if ( space . IsSet ( field_1_options ) ) { return operands [ 0 ] ; } else if ( optiIf . IsSet ( field_1_options ) ) { return ToFormulaString ( ) + " ( " + operands [ 0 ] + " ) " ; } else if ( optiSkip . IsSet ( field_1_options ) ) { return ToFormulaString ( ) + operands [ 0 ] ; } else { return ToFormulaString ( ) + " ( " + operands [ 0 ] + " ) " ; } }
public virtual T Merge ( T first , T second ) { throw new System . NotSupportedException ( ) ; }
public override string ToString ( ) { return this . m_message . Key + " : ▁ " + GetLocalizedMessage ( ) ; }
public XPath ( Parser parser , string path ) { this . parser = parser ; this . path = path ; elements = Split ( path ) ; }
public CreateAccountAliasRequest ( string accountAlias ) { _accountAlias = accountAlias ; }
public override void Decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { var block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 7 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 6 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 5 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 4 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 3 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 2 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 1 ) ) & 1 ; values [ valuesOffset ++ ] = block & 1 ; } }
public override PushConnection OpenPush ( ) { throw new NGit . Errors . NotSupportedException ( JGitText . Get ( ) . pushIsNotSupportedForBundleTransport ) ; }
public static void StrCpy ( char [ ] dst , int di , char [ ] src , int si ) { while ( src [ si ] != 0 ) { dst [ di ++ ] = src [ si ++ ] ; } dst [ di ] = ( char ) 0 ; }
public virtual K getKey ( ) { return mapEntry . getKey ( ) ; }
public static int NumNonnull ( object [ ] data ) { int n = 0 ; if ( data == null ) { return n ; } foreach ( object o in data ) { if ( o != null ) { n ++ ; } } return n ; }
public override void add ( int location , E @ object ) { if ( location >= 0 && location <= _size ) { java . util . LinkedList . Link < E > link = voidLink ; if ( location < ( _size / 2 ) ) { { for ( int i = 0 ; i <= location ; i ++ ) { link = link . next ; } } } else { { for ( int i = _size ; i > location ; i -- ) { link = link . previous ; } } } java . util . LinkedList . Link < E > previous = link . previous ; java . util . LinkedList . Link < E > newLink = new java . util . LinkedList . Link < E > ( @ object , previous , link ) ; previous . next = newLink ; link . previous = newLink ; _size ++ ; modCount ++ ; } else { throw new System . IndexOutOfRangeException ( ) ; } }
public virtual DescribeDomainResponse DescribeDomain ( DescribeDomainRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeDomainRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeDomainResponseUnmarshaller . Instance ; return Invoke < DescribeDomainResponse > ( request , options ) ; }
public override void flush ( ) { throw new System . NotImplementedException ( ) ; }
public PersianCharFilterFactory ( IDictionary < string , string > args ) : base ( args ) { if ( args . Count > 0 ) { throw new System . ArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public override bool IncrementToken ( ) { if ( used ) { return false ; } ClearAttributes ( ) ; termAttribute . Append ( value ) ; offsetAttribute . SetOffset ( 0 , value . Length ) ; used = true ; return true ; }
public static java . nio . FloatBuffer allocate ( int capacity_1 ) { if ( capacity_1 < 0 ) { throw new System . ArgumentException ( ) ; } return new java . nio . ReadWriteFloatArrayBuffer ( capacity_1 ) ; }
public NGit . Diff . Edit After ( NGit . Diff . Edit cut ) { return new NGit . Diff . Edit ( cut . endA , endA , cut . endB , endB ) ; }
public virtual UpdateRuleVersionResponse UpdateRuleVersion ( UpdateRuleVersionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateRuleVersionRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateRuleVersionResponseUnmarshaller . Instance ; return Invoke < UpdateRuleVersionResponse > ( request , options ) ; }
public virtual ListVoiceConnectorTerminationCredentialsResponse ListVoiceConnectorTerminationCredentials ( ListVoiceConnectorTerminationCredentialsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListVoiceConnectorTerminationCredentialsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListVoiceConnectorTerminationCredentialsResponseUnmarshaller . Instance ; return Invoke < ListVoiceConnectorTerminationCredentialsResponse > ( request , options ) ; }
public virtual GetDeploymentTargetResponse GetDeploymentTarget ( GetDeploymentTargetRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetDeploymentTargetRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetDeploymentTargetResponseUnmarshaller . Instance ; return Invoke < GetDeploymentTargetResponse > ( request , options ) ; }
public virtual void SetNoChildReport ( ) { letChildReport = false ; foreach ( PerfTask task in tasks ) { if ( task is TaskSequence ) { ( ( TaskSequence ) task ) . SetNoChildReport ( ) ; } } }
public override E get ( int location ) { try { return a [ location ] ; } catch ( System . IndexOutOfRangeException ) { throw java . util . ArrayList < E > . throwIndexOutOfBoundsException ( location , a . Length ) ; } }
public virtual DescribeDataSetResponse DescribeDataSet ( DescribeDataSetRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeDataSetRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeDataSetResponseUnmarshaller . Instance ; return Invoke < DescribeDataSetResponse > ( request , options ) ; }
public SkipWorkTreeFilter ( int treeIdx ) { this . treeIdx = treeIdx ; }
public virtual DescribeNetworkInterfacesResponse DescribeNetworkInterfaces ( ) { return DescribeNetworkInterfaces ( new DescribeNetworkInterfacesRequest ( ) ) ; }
public bool Contains ( int row , int col ) { return _firstRow <= row && _lastRow >= row && _firstColumn <= col && _lastColumn >= col ; }
public override string ToString ( ) { return new string ( this . chars ) ; }
public virtual FileHeader . PatchType GetPatchType ( ) { return patchType ; }
public override java . util . Iterator < K > iterator ( ) { return new java . util . Hashtable < K , V > . KeyIterator ( this . _enclosing ) ; }
public virtual CreateScriptResponse CreateScript ( CreateScriptRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateScriptRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateScriptResponseUnmarshaller . Instance ; return Invoke < CreateScriptResponse > ( request , options ) ; }
public override BytesRef Next ( ) { termUpto ++ ; if ( termUpto >= info . terms . Count ) { return null ; } else { info . terms . Get ( info . sortedTerms [ termUpto ] , br ) ; return br ; } }
public override string OutputToString ( CharsRef output ) { return output . ToString ( ) ; }
public virtual AssociateWebsiteAuthorizationProviderResponse AssociateWebsiteAuthorizationProvider ( AssociateWebsiteAuthorizationProviderRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AssociateWebsiteAuthorizationProviderRequestMarshaller . Instance ; options . ResponseUnmarshaller = AssociateWebsiteAuthorizationProviderResponseUnmarshaller . Instance ; return Invoke < AssociateWebsiteAuthorizationProviderResponse > ( request , options ) ; }
public virtual void Unpop ( RevCommit c ) { BlockRevQueue . Block b = head ; if ( b == null ) { b = free . NewBlock ( ) ; b . ResetToMiddle ( ) ; b . Add ( c ) ; head = b ; tail = b ; return ; } else { if ( b . CanUnpop ( ) ) { b . Unpop ( c ) ; return ; } } b = free . NewBlock ( ) ; b . ResetToEnd ( ) ; b . Unpop ( c ) ; b . next = head ; head = b ; }
public EdgeNGramTokenizerFactory ( IDictionary < string , string > args ) : base ( args ) { minGramSize = GetInt32 ( args , " minGramSize " , EdgeNGramTokenizer . DEFAULT_MIN_GRAM_SIZE ) ; maxGramSize = GetInt32 ( args , " maxGramSize " , EdgeNGramTokenizer . DEFAULT_MAX_GRAM_SIZE ) ; side = Get ( args , " side " , EdgeNGramTokenFilter . Side . FRONT . ToString ( ) ) ; if ( args . Count > 0 ) { throw new System . ArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public ModifyDBParameterGroupRequest ( string dbParameterGroupName , List < Parameter > parameters ) { _dbParameterGroupName = dbParameterGroupName ; _parameters = parameters ; }
public virtual GetHostedZoneLimitResponse GetHostedZoneLimit ( GetHostedZoneLimitRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetHostedZoneLimitRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetHostedZoneLimitResponseUnmarshaller . Instance ; return Invoke < GetHostedZoneLimitResponse > ( request , options ) ; }
public override void Set ( int index , long value ) { int o = ( int ) ( ( uint ) index >> 6 ) ; int b = index & 63 ; int shift = b << 0 ; blocks [ o ] = ( blocks [ o ] & ~ ( 1L << shift ) ) | ( value << shift ) ; }
public override RevFilter Clone ( ) { return new CommitterRevFilter . PatternSearch ( Pattern ( ) ) ; }
public override string ToString ( ) { return " spans ( " + m_term . ToString ( ) + " ) @ " + ( m_doc == - 1 ? " START " : ( m_doc == int . MaxValue ) ? " END " : m_doc + " - " + m_position ) ; }
public virtual bool CanAppendMatch ( ) { for ( int i = 0 ; i < heads . Count ; i ++ ) { if ( heads [ i ] != LastHead . INSTANCE ) { return true ; } } return false ; }
public override int lastIndexOf ( string subString , int start ) { lock ( this ) { return base . lastIndexOf ( subString , start ) ; } }
public virtual DeleteNetworkAclEntryResponse DeleteNetworkAclEntry ( DeleteNetworkAclEntryRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteNetworkAclEntryRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteNetworkAclEntryResponseUnmarshaller . Instance ; return Invoke < DeleteNetworkAclEntryResponse > ( request , options ) ; }
public virtual AssociateMemberToGroupResponse AssociateMemberToGroup ( AssociateMemberToGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AssociateMemberToGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = AssociateMemberToGroupResponseUnmarshaller . Instance ; return Invoke < AssociateMemberToGroupResponse > ( request , options ) ; }
public static int Committer ( byte [ ] b , int ptr ) { int sz = b . Length ; if ( ptr == 0 ) { ptr += 46 ; } while ( ptr < sz && b [ ptr ] == ' p ' ) { ptr += 48 ; } if ( ptr < sz && b [ ptr ] == ' a ' ) { ptr = NextLF ( b , ptr ) ; } return Match ( b , ptr , ObjectChecker . committer ) ; }
public virtual int getLineNumber ( ) { return row ; }
public virtual NGit . Api . SubmoduleUpdateCommand AddPath ( string path ) { paths . AddItem ( path ) ; return this ; }
public virtual GetPushTemplateResponse GetPushTemplate ( GetPushTemplateRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetPushTemplateRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetPushTemplateResponseUnmarshaller . Instance ; return Invoke < GetPushTemplateResponse > ( request , options ) ; }
public virtual DescribeVaultResponse DescribeVault ( DescribeVaultRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeVaultRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeVaultResponseUnmarshaller . Instance ; return Invoke < DescribeVaultResponse > ( request , options ) ; }
public virtual DescribeVpcPeeringConnectionsResponse DescribeVpcPeeringConnections ( ) { return DescribeVpcPeeringConnections ( new DescribeVpcPeeringConnectionsRequest ( ) ) ; }
public override java . nio . ByteBuffer putLong ( int index , long value ) { throw new System . NotImplementedException ( ) ; }
public virtual RegisterDeviceResponse RegisterDevice ( RegisterDeviceRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = RegisterDeviceRequestMarshaller . Instance ; options . ResponseUnmarshaller = RegisterDeviceResponseUnmarshaller . Instance ; return Invoke < RegisterDeviceResponse > ( request , options ) ; }
public static Format ById ( int id ) { foreach ( Format format in Values ) { if ( format . Id == id ) { return format ; } } throw new ArgumentException ( " Unknown ▁ format ▁ id : ▁ " + id ) ; }
public virtual DeleteAppResponse DeleteApp ( DeleteAppRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteAppRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteAppResponseUnmarshaller . Instance ; return Invoke < DeleteAppResponse > ( request , options ) ; }
public virtual GetBaiduChannelResponse GetBaiduChannel ( GetBaiduChannelRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetBaiduChannelRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetBaiduChannelResponseUnmarshaller . Instance ; return Invoke < GetBaiduChannelResponse > ( request , options ) ; }
public FST . BytesReader GetBytesReader ( ) { return fst . GetBytesReader ( ) ; }
public static bool isValidSchemeChar ( int index , char c ) { if ( ( c >= ' a ' && c <= ' z ' ) || ( c >= ' A ' && c <= ' Z ' ) ) { return true ; } if ( index > 0 && ( ( c >= ' 0 ' && c <= ' 9 ' ) || c == ' + ' || c == ' - ' || c == ' . ' ) ) { return true ; } return false ; }
public virtual ListAppliedSchemaArnsResponse ListAppliedSchemaArns ( ListAppliedSchemaArnsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListAppliedSchemaArnsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListAppliedSchemaArnsResponseUnmarshaller . Instance ; return Invoke < ListAppliedSchemaArnsResponse > ( request , options ) ; }
public System . Uri BaseUri { get ; set ; }
public ValueEval Evaluate ( ValueEval [ ] args , OperationEvaluationContext ec ) { if ( args . Length < 1 ) { return ErrorEval . VALUE_INVALID ; } bool isA1style ; String text ; try { ValueEval ve = OperandResolver . GetSingleValue ( args [ 0 ] , ec . RowIndex , ec . ColumnIndex ) ; text = OperandResolver . CoerceValueToString ( ve ) ; switch ( args . Length ) { case 1 : isA1style = true ; break ; case 2 : isA1style = EvaluateBooleanArg ( args [ 1 ] , ec ) ; break ; default : return ErrorEval . VALUE_INVALID ; } } catch ( EvaluationException e ) { return e . GetErrorEval ( ) ; } return EvaluateIndirect ( ec , text , isA1style ) ; }
public int CompareTo ( int [ ] bs , int p ) { int cmp ; cmp = NB . CompareUInt32 ( w1 , bs [ p ] ) ; if ( cmp != 0 ) { return cmp ; } cmp = NB . CompareUInt32 ( w2 , bs [ p + 1 ] ) ; if ( cmp != 0 ) { return cmp ; } cmp = NB . CompareUInt32 ( w3 , bs [ p + 2 ] ) ; if ( cmp != 0 ) { return cmp ; } cmp = NB . CompareUInt32 ( w4 , bs [ p + 3 ] ) ; if ( cmp != 0 ) { return cmp ; } return NB . CompareUInt32 ( w5 , bs [ p + 4 ] ) ; }
public void RemoveName ( int index ) { names . RemoveAt ( index ) ; workbook . RemoveName ( index ) ; }
public GetQueueAttributesRequest ( string queueUrl , List < string > attributeNames ) { _queueUrl = queueUrl ; _attributeNames = attributeNames ; }
public static bool [ ] copyOf ( bool [ ] original , int newLength ) { if ( newLength < 0 ) { throw new java . lang . NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; }
public static void setEnabled ( bool enabled ) { ENABLED = enabled ; }
public virtual DeleteLogPatternResponse DeleteLogPattern ( DeleteLogPatternRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteLogPatternRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteLogPatternResponseUnmarshaller . Instance ; return Invoke < DeleteLogPatternResponse > ( request , options ) ; }
public virtual bool Contains ( char [ ] text , int offset , int length ) { return map . ContainsKey ( text , offset , length ) ; }
public int GetFirstSheetIndexFromExternSheetIndex ( int externSheetNumber ) { return linkTable . GetFirstInternalSheetIndexForExtIndex ( externSheetNumber ) ; }
public virtual bool Handles ( string commandLine ) { return command . Length + 1 < commandLine . Length && commandLine [ command . Length ] == ' ▁ ' && commandLine . StartsWith ( command ) ; }
public static void Register ( MergeStrategy imp ) { Register ( imp . GetName ( ) , imp ) ; }
public long RamBytesUsed ( ) { return ( ( index != null ) ? index . GetSizeInBytes ( ) : 0 ) ; }
public HostedZone ( string id , string name , string callerReference ) { _id = id ; _name = name ; _callerReference = callerReference ; }
public virtual GetFindingsResponse GetFindings ( GetFindingsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetFindingsRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetFindingsResponseUnmarshaller . Instance ; return Invoke < GetFindingsResponse > ( request , options ) ; }
public virtual DescribeTopicsDetectionJobResponse DescribeTopicsDetectionJob ( DescribeTopicsDetectionJobRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeTopicsDetectionJobRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeTopicsDetectionJobResponseUnmarshaller . Instance ; return Invoke < DescribeTopicsDetectionJobResponse > ( request , options ) ; }
public bool ProcessMatch ( ValueEval eval ) { if ( eval is NumericValueEval ) { if ( minimumValue == null ) { minimumValue = eval ; } else { double currentValue = ( ( NumericValueEval ) eval ) . NumberValue ; double oldValue = ( ( NumericValueEval ) minimumValue ) . NumberValue ; if ( currentValue < oldValue ) { minimumValue = eval ; } } } return true ; }
public override void Write ( ILittleEndianOutput out1 ) { out1. WriteByte ( sid + PtgClass ) ; out1. WriteShort ( field_1_len_ref_subexpression ) ; }
public static int Main ( string [ ] args ) { bool printTree = false ; string path = null ; for ( int i = 0 ; i < args . Length ; i ++ ) { if ( args [ i ] . Equals ( " - printTree " , StringComparison . Ordinal ) ) { printTree = true ; } else { path = args [ i ] ; } } if ( args . Length != ( printTree ? 2 : 1 ) ) { throw new ArgumentException ( ) ; } using ( Store . Directory dir = FSDirectory . Open ( new DirectoryInfo ( path ) ) ) { using ( var r = new DirectoryTaxonomyReader ( dir ) ) { PrintStats ( r , System . Console . Out , printTree ) ; } } return 0 ; }
public virtual void SetByteValue ( byte value ) { if ( ! ( FieldsData is Byte ) ) { throw new System . ArgumentException ( " cannot ▁ change ▁ value ▁ type ▁ from ▁ " + FieldsData . GetType ( ) . Name + " ▁ to ▁ Byte " ) ; } FieldsData = new Byte ( value ) ; }
public static int Initialize ( ) { return Initialize ( DefaultSeed ) ; }
public CachingDoubleValueSource ( ValueSource source ) { this . m_source = source ; m_cache = new JCG . Dictionary < int , double > ( ) ; }
public AttributeDefinition ( string attributeName , ScalarAttributeType attributeType ) { _attributeName = attributeName ; _attributeType = attributeType ; }
public static string Join ( ICollection < string > parts , string separator ) { return NGit . Util . StringUtils . Join ( parts , separator , separator ) ; }
public virtual ListTaskDefinitionFamiliesResponse ListTaskDefinitionFamilies ( ListTaskDefinitionFamiliesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListTaskDefinitionFamiliesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListTaskDefinitionFamiliesResponseUnmarshaller . Instance ; return Invoke < ListTaskDefinitionFamiliesResponse > ( request , options ) ; }
public virtual ListComponentsResponse ListComponents ( ListComponentsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListComponentsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListComponentsResponseUnmarshaller . Instance ; return Invoke < ListComponentsResponse > ( request , options ) ; }
public ActivatePhotosRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " ActivatePhotos " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public virtual CreateMatchmakingRuleSetResponse CreateMatchmakingRuleSet ( CreateMatchmakingRuleSetRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateMatchmakingRuleSetRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateMatchmakingRuleSetResponseUnmarshaller . Instance ; return Invoke < CreateMatchmakingRuleSetResponse > ( request , options ) ; }
public virtual ListAvailableManagementCidrRangesResponse ListAvailableManagementCidrRanges ( ListAvailableManagementCidrRangesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListAvailableManagementCidrRangesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListAvailableManagementCidrRangesResponseUnmarshaller . Instance ; return Invoke < ListAvailableManagementCidrRangesResponse > ( request , options ) ; }
public virtual ObjectIdSubclassMap < ObjectId > GetBaseObjectIds ( ) { if ( baseObjectIds != null ) { return baseObjectIds ; } return new ObjectIdSubclassMap < ObjectId > ( ) ; }
public virtual DeletePushTemplateResponse DeletePushTemplate ( DeletePushTemplateRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeletePushTemplateRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeletePushTemplateResponseUnmarshaller . Instance ; return Invoke < DeletePushTemplateResponse > ( request , options ) ; }
public virtual CreateDomainEntryResponse CreateDomainEntry ( CreateDomainEntryRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateDomainEntryRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateDomainEntryResponseUnmarshaller . Instance ; return Invoke < CreateDomainEntryResponse > ( request , options ) ; }
public static int GetEncodedSize ( Array values ) { int result = values . Length * 1 ; for ( int i = 0 ; i < values . Length ; i ++ ) { result += GetEncodedSize ( values . GetValue ( i ) ) ; } return result ; }
public OpenNLPTokenizerFactory ( IDictionary < string , string > args ) : base ( args ) { sentenceModelFile = Require ( args , SENTENCE_MODEL ) ; tokenizerModelFile = Require ( args , TOKENIZER_MODEL ) ; if ( args . Any ( ) ) { throw new ArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public sealed override int getInt ( int index ) { checkIndex ( index , libcore . io . SizeOf . INT ) ; return libcore . io . Memory . peekInt ( backingArray , offset + index , _order ) ; }
public virtual IList < Head > GetNextHeads ( char c ) { if ( Matches ( c ) ) { return newHeads ; } else { return FileNameMatcher . EMPTY_HEAD_LIST ; } }
public override java . nio . ByteBuffer putShort ( short value ) { throw new System . NotImplementedException ( ) ; }
public virtual void writeUnshared ( object @ object ) { throw new System . NotImplementedException ( ) ; }
public virtual int offsetByCodePoints ( int index , int codePointOffset ) { return Sharpen . CharHelper . OffsetByCodePoints ( value , 0 , count , index , codePointOffset ) ; }
public static int GetUniqueAlt ( IEnumerable < BitSet > altsets ) { BitSet all = GetAlts ( altsets ) ; if ( all . Cardinality ( ) == 1 ) { return all . NextSetBit ( 0 ) ; } return ATN . INVALID_ALT_NUMBER ; }
public virtual DateTime GetWhen ( ) { return Sharpen . Extensions . CreateDate ( when ) ; }
public RuleTagToken ( string ruleName , int bypassTokenType , string label ) { if ( string . IsNullOrEmpty ( ruleName ) ) { throw new ArgumentException ( " ruleName ▁ cannot ▁ be ▁ null ▁ or ▁ empty . " ) ; } this . ruleName = ruleName ; this . bypassTokenType = bypassTokenType ; this . label = label ; }
public virtual DisableOrganizationAdminAccountResponse DisableOrganizationAdminAccount ( DisableOrganizationAdminAccountRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DisableOrganizationAdminAccountRequestMarshaller . Instance ; options . ResponseUnmarshaller = DisableOrganizationAdminAccountResponseUnmarshaller . Instance ; return Invoke < DisableOrganizationAdminAccountResponse > ( request , options ) ; }
public virtual CreateRoomResponse CreateRoom ( CreateRoomRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateRoomRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateRoomResponseUnmarshaller . Instance ; return Invoke < CreateRoomResponse > ( request , options ) ; }
public virtual DeleteReplicationGroupResponse DeleteReplicationGroup ( DeleteReplicationGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteReplicationGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteReplicationGroupResponseUnmarshaller . Instance ; return Invoke < DeleteReplicationGroupResponse > ( request , options ) ; }
public java . nio . CharBuffer decode ( java . nio . ByteBuffer buffer ) { try { return newDecoder ( ) . onMalformedInput ( java . nio . charset . CodingErrorAction . REPLACE ) . onUnmappableCharacter ( java . nio . charset . CodingErrorAction . REPLACE ) . decode ( buffer ) ; } catch ( java . nio . charset . CharacterCodingException ex ) { throw new System . Exception ( ex . Message , ex ) ; } }
public Distribution ( string id , string status , string domainName ) { _id = id ; _status = status ; _domainName = domainName ; }
public sealed override object array ( ) { return protectedArray ( ) ; }
public DateWindow1904Record ( RecordInputStream in1 ) { field_1_window = in1. ReadShort ( ) ; }
public DeleteDBSnapshotRequest ( string dbSnapshotIdentifier ) { _dbSnapshotIdentifier = dbSnapshotIdentifier ; }
public ParserExtension GetExtension ( string key ) { if ( key == null || ! this . extensions . TryGetValue ( key , out ParserExtension value ) ) return null ; return value ; }
public virtual void Inform ( IResourceLoader loader ) { try { if ( chunkerModelFile != null ) { OpenNLPOpsFactory . GetChunkerModel ( chunkerModelFile , loader ) ; } } catch ( IOException e ) { throw new ArgumentException ( e . ToString ( ) , e ) ; } }
public virtual CompleteVaultLockResponse CompleteVaultLock ( CompleteVaultLockRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CompleteVaultLockRequestMarshaller . Instance ; options . ResponseUnmarshaller = CompleteVaultLockResponseUnmarshaller . Instance ; return Invoke < CompleteVaultLockResponse > ( request , options ) ; }
public int [ ] GetCharIntervals ( ) { return ( int [ ] ) ( Array ) _points . Clone ( ) ; }
public long RamBytesUsed ( ) { return RamUsageEstimator . AlignObjectSize ( 3 * RamUsageEstimator . NUM_BYTES_OBJECT_REF + 2 * RamUsageEstimator . NUM_BYTES_INT32 ) + RamUsageEstimator . SizeOf ( data ) + positions . RamBytesUsed ( ) + wordNums . RamBytesUsed ( ) ; }
public virtual RegisterInstancesWithLoadBalancerResponse RegisterInstancesWithLoadBalancer ( RegisterInstancesWithLoadBalancerRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = RegisterInstancesWithLoadBalancerRequestMarshaller . Instance ; options . ResponseUnmarshaller = RegisterInstancesWithLoadBalancerResponseUnmarshaller . Instance ; return Invoke < RegisterInstancesWithLoadBalancerResponse > ( request , options ) ; }
public DescribeClusterUserKubeconfigRequest ( ) : base ( " CS " , " 2015 - 12 - 15 " , " DescribeClusterUserKubeconfig " , " cs " , " openAPI " ) { UriPattern = " / k8s / [ ClusterId ] / user □ config " ; Method = MethodType . GET ; }
public PrecisionRecord ( RecordInputStream in1 ) { field_1_precision = in1. ReadShort ( ) ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( LeftRowGutter ) ; out1. WriteShort ( TopColGutter ) ; out1. WriteShort ( RowLevelMax ) ; out1. WriteShort ( ColLevelMax ) ; }
public virtual DeleteVirtualInterfaceResponse DeleteVirtualInterface ( DeleteVirtualInterfaceRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteVirtualInterfaceRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteVirtualInterfaceResponseUnmarshaller . Instance ; return Invoke < DeleteVirtualInterfaceResponse > ( request , options ) ; }
public Entry GetEntry ( String name ) { if ( excludes . Contains ( name ) ) { throw new FileNotFoundException ( name ) ; } Entry entry = directory . GetEntry ( name ) ; return WrapEntry ( entry ) ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ BACKUP ] \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . backup ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( StringUtil . ToHexString ( Backup ) ) . Append ( " \ n " ) ; buffer . Append ( " [ / BACKUP ] \ n " ) ; return buffer . ToString ( ) ; }
public virtual DeleteVoiceConnectorOriginationResponse DeleteVoiceConnectorOrigination ( DeleteVoiceConnectorOriginationRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteVoiceConnectorOriginationRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteVoiceConnectorOriginationResponseUnmarshaller . Instance ; return Invoke < DeleteVoiceConnectorOriginationResponse > ( request , options ) ; }
public virtual OpenStringBuilder Append ( char c ) { Write ( c ) ; return this ; }
public static long GenerationFromSegmentsFileName ( string fileName ) { if ( fileName . Equals ( IndexFileNames . SEGMENTS , StringComparison . Ordinal ) ) { return 0 ; } else if ( fileName . StartsWith ( IndexFileNames . SEGMENTS , StringComparison . Ordinal ) ) { return Number . Parse ( fileName . Substring ( 1 + IndexFileNames . SEGMENTS . Length ) , Character . MaxRadix ) ; } else { throw new System . ArgumentException ( " fileName ▁ \ " " + fileName + " \ " ▁ is ▁ not ▁ a ▁ segments ▁ file " ) ; } }
public static NGit . Transport . TagOpt FromOption ( string o ) { if ( o == null || o . Length == 0 ) { return AUTO_FOLLOW ; } foreach ( NGit . Transport . TagOpt tagopt in Values ( ) ) { if ( tagopt . Option ( ) . Equals ( o ) ) { return tagopt ; } } throw new ArgumentException ( MessageFormat . Format ( JGitText . Get ( ) . invalidTagOption , o ) ) ; }
public virtual StartContentModerationResponse StartContentModeration ( StartContentModerationRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = StartContentModerationRequestMarshaller . Instance ; options . ResponseUnmarshaller = StartContentModerationResponseUnmarshaller . Instance ; return Invoke < StartContentModerationResponse > ( request , options ) ; }
public static string quoteReplacement ( string s ) { java . lang . StringBuilder result = new java . lang . StringBuilder ( s . Length ) ; { for ( int i = 0 ; i < s . Length ; i ++ ) { char c = s [ i ] ; if ( c == ' \\ ' ▁ || ▁ c ▁ == ▁ ' $ ' ) { result . append ( ' \\ ' ) ; } result . append ( c ) ; } } return result . ToString ( ) ; }
public void set ( V newValue ) { value = newValue ; }
public QueryParserTokenManager ( ICharStream stream ) { InitBlock ( ) ; m_input_stream = stream ; }
public long ValueFor ( double elapsed ) { double val ; if ( modBy == 0 ) val = elapsed / factor ; elseval = elapsed / factor % modBy ; if ( type == ' 0 ' ) return ( long ) Math . Round ( val ) ; else return ( long ) val ; }
public override java . nio . LongBuffer get ( long [ ] dst , int dstOffset , int longCount ) { byteBuffer . limit ( _limit * libcore . io . SizeOf . LONG ) ; byteBuffer . position ( _position * libcore . io . SizeOf . LONG ) ; if ( byteBuffer is java . nio . DirectByteBuffer ) { ( ( java . nio . DirectByteBuffer ) byteBuffer ) . get ( dst , dstOffset , longCount ) ; } else { ( ( java . nio . HeapByteBuffer ) byteBuffer ) . get ( dst , dstOffset , longCount ) ; } this . _position += longCount ; return this ; }
public virtual void RemoveErrorListeners ( ) { _listeners = new IAntlrErrorListener < Symbol > [ 0 ] ; }
public CommonTokenStream ( ITokenSource tokenSource , int channel ) : this ( tokenSource ) { this . channel = channel ; }
public virtual ListObjectPoliciesResponse ListObjectPolicies ( ListObjectPoliciesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListObjectPoliciesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListObjectPoliciesResponseUnmarshaller . Instance ; return Invoke < ListObjectPoliciesResponse > ( request , options ) ; }
public ObjectToPack ( AnyObjectId src , int type ) : base ( src ) { flags = type << TYPE_SHIFT ; }
public virtual int Stem ( char [ ] s , int len ) { int numVowels_Renamed = NumVowels ( s , len ) ; for ( int i = 0 ; i < affixes . Length ; i ++ ) { Affix affix = affixes [ i ] ; if ( numVowels_Renamed > affix . vc && len >= affix . affix . Length + 3 && StemmerUtil . EndsWith ( s , len , affix . affix ) ) { len -= affix . affix . Length ; return affix . palatalizes ? Unpalatalize ( s , len ) : len ; } } return len ; }
public virtual void Recover ( Parser recognizer , RecognitionException e ) { if ( lastErrorIndex == ( ( ITokenStream ) recognizer . InputStream ) . Index && lastErrorStates != null && lastErrorStates . Contains ( recognizer . State ) ) { recognizer . Consume ( ) ; } lastErrorIndex = ( ( ITokenStream ) recognizer . InputStream ) . Index ; if ( lastErrorStates == null ) { lastErrorStates = new IntervalSet ( ) ; } lastErrorStates . Add ( recognizer . State ) ; IntervalSet followSet = GetErrorRecoverySet ( recognizer ) ; ConsumeUntil ( recognizer , followSet ) ; }
public override String ToFormulaString ( ) { String value = field_3_string ; int len = value . Length ; StringBuilder sb = new StringBuilder ( len + 4 ) ; sb . Append ( FORMULA_DELIMITER ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value [ i ] ; if ( c == FORMULA_DELIMITER ) { sb . Append ( FORMULA_DELIMITER ) ; } sb . Append ( c ) ; } sb . Append ( FORMULA_DELIMITER ) ; return sb . ToString ( ) ; }
public UnlinkFaceRequest ( ) : base ( " LinkFace " , " 2018 - 07 - 20 " , " UnlinkFace " ) { Protocol = ProtocolType . HTTPS ; Method = MethodType . POST ; }
public ConfigurationOptionSetting ( string awsNamespace , string optionName , string value ) { _awsNamespace = awsNamespace ; _optionName = optionName ; _value = value ; }
public override string GetFully ( string key ) { StringBuilder result = new StringBuilder ( m_tries . Count * 2 ) ; for ( int i = 0 ; i < m_tries . Count ; i ++ ) { string r = m_tries [ i ] . GetFully ( key ) ; if ( r == null || ( r . Length == 1 && r [ 0 ] == EOM ) ) { return result . ToString ( ) ; } result . Append ( r ) ; } return result . ToString ( ) ; }
public virtual DescribeMountTargetSecurityGroupsResponse DescribeMountTargetSecurityGroups ( DescribeMountTargetSecurityGroupsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeMountTargetSecurityGroupsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeMountTargetSecurityGroupsResponseUnmarshaller . Instance ; return Invoke < DescribeMountTargetSecurityGroupsResponse > ( request , options ) ; }
public virtual GetApiMappingResponse GetApiMapping ( GetApiMappingRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetApiMappingRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetApiMappingResponseUnmarshaller . Instance ; return Invoke < GetApiMappingResponse > ( request , options ) ; }
public HttpRequest ( string strUrl ) { Url = strUrl ; Headers = new Dictionary < string , string > ( ) ; }
public MemFuncPtg ( int subExprLen ) { field_1_len_ref_subexpression = subExprLen ; }
public static TermStats [ ] GetHighFreqTerms ( IndexReader reader , int numTerms , string field , IComparer < TermStats > comparer ) { TermStatsQueue tiq = null ; if ( field != null ) { Fields fields = MultiFields . GetFields ( reader ) ; if ( fields == null ) { throw new Exception ( " field ▁ " + field + " ▁ not ▁ found " ) ; } Terms terms = fields . GetTerms ( field ) ; if ( terms != null ) { TermsEnum termsEnum = terms . GetIterator ( null ) ; tiq = new TermStatsQueue ( numTerms , comparer ) ; tiq . Fill ( field , termsEnum ) ; } } else { Fields fields = MultiFields . GetFields ( reader ) ; if ( fields == null ) { throw new Exception ( " no ▁ fields ▁ found ▁ for ▁ this ▁ index " ) ; } tiq = new TermStatsQueue ( numTerms , comparer ) ; foreach ( string fieldName in fields ) { Terms terms = fields . GetTerms ( fieldName ) ; if ( terms != null ) { tiq . Fill ( fieldName , terms . GetIterator ( null ) ) ; } } } TermStats [ ] result = new TermStats [ tiq . Count ] ; int count = tiq . Count - 1 ; while ( tiq . Count != 0 ) { result [ count ] = tiq . Pop ( ) ; count -- ; } return result ; }
public virtual DeleteApnsVoipChannelResponse DeleteApnsVoipChannel ( DeleteApnsVoipChannelRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteApnsVoipChannelRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteApnsVoipChannelResponseUnmarshaller . Instance ; return Invoke < DeleteApnsVoipChannelResponse > ( request , options ) ; }
public virtual ListFacesResponse ListFaces ( ListFacesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListFacesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListFacesResponseUnmarshaller . Instance ; return Invoke < ListFacesResponse > ( request , options ) ; }
public ShapeFieldCacheDistanceValueSource ( SpatialContext ctx , ShapeFieldCacheProvider < IPoint > provider , IPoint from , double multiplier ) { this . ctx = ctx ; this . from = from ; this . provider = provider ; this . multiplier = multiplier ; }
public override char get ( int index ) { checkIndex ( index ) ; return sequence [ index ] ; }
public virtual UpdateConfigurationProfileResponse UpdateConfigurationProfile ( UpdateConfigurationProfileRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateConfigurationProfileRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateConfigurationProfileResponseUnmarshaller . Instance ; return Invoke < UpdateConfigurationProfileResponse > ( request , options ) ; }
public virtual DescribeLifecycleHooksResponse DescribeLifecycleHooks ( DescribeLifecycleHooksRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeLifecycleHooksRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeLifecycleHooksResponseUnmarshaller . Instance ; return Invoke < DescribeLifecycleHooksResponse > ( request , options ) ; }
public virtual DescribeHostReservationsResponse DescribeHostReservations ( DescribeHostReservationsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeHostReservationsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeHostReservationsResponseUnmarshaller . Instance ; return Invoke < DescribeHostReservationsResponse > ( request , options ) ; }
public static PredictionContext FromRuleContext ( ATN atn , RuleContext outerContext ) { if ( outerContext == null ) outerContext = ParserRuleContext . EMPTY ; if ( outerContext . Parent == null || outerContext == ParserRuleContext . EMPTY ) return PredictionContext . EMPTY ; PredictionContext parent = PredictionContext . FromRuleContext ( atn , outerContext . Parent ) ; ATNState state = atn . states [ outerContext . invokingState ] ; RuleTransition transition = ( RuleTransition ) state . Transition ( 0 ) ; return parent . GetChild ( transition . followState . stateNumber ) ; }
public override string ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ SXVDEX ] \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . grbit1 ▁ = " ) . Append ( HexDump . IntToHex ( grbit1 ) ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . grbit2 ▁ = " ) . Append ( HexDump . ByteToHex ( grbit2 ) ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . citmShow ▁ = " ) . Append ( HexDump . ByteToHex ( citmShow ) ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . isxdiSort ▁ = " ) . Append ( HexDump . ShortToHex ( isxdiSort ) ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . isxdiShow ▁ = " ) . Append ( HexDump . ShortToHex ( isxdiShow ) ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . subName ▁ = " ) . Append ( subName ) . Append ( " \ n " ) ; buffer . Append ( " [ / SXVDEX ] \ n " ) ; return buffer . ToString ( ) ; }
public override string ToString ( ) { StringBuilder r = new StringBuilder ( ) ; r . Append ( " BlameResult : ▁ " ) ; r . Append ( GetResultPath ( ) ) ; return r . ToString ( ) ; }
public virtual ListChangeSetsResponse ListChangeSets ( ListChangeSetsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListChangeSetsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListChangeSetsResponseUnmarshaller . Instance ; return Invoke < ListChangeSetsResponse > ( request , options ) ; }
public virtual bool IsAllowNonFastForwards ( ) { return allowNonFastForwards ; }
public FeatRecord ( ) { futureHeader = new FtrHeader ( ) ; futureHeader . RecordType = ( sid ) ; }
public override java . nio . ShortBuffer put ( short c ) { throw new java . nio . ReadOnlyBufferException ( ) ; }
public virtual void SetQuery ( string query ) { this . query = query ; this . m_message = new Message ( QueryParserMessages . INVALID_SYNTAX_CANNOT_PARSE , query , " " ) ; }
public virtual StashApplyCommand StashApply ( ) { return new StashApplyCommand ( repo ) ; }
public ICollection NameSet ( ) { return dictionaryNameToID . Keys ; }
public static int getEffectivePort ( string scheme , int specifiedPort ) { if ( specifiedPort != - 1 ) { return specifiedPort ; } if ( Sharpen . StringHelper . EqualsIgnoreCase ( " http " , scheme ) ) { return 80 ; } else { if ( Sharpen . StringHelper . EqualsIgnoreCase ( " https " , scheme ) ) { return 443 ; } else { return - 1 ; } } }
public virtual ListAssessmentTemplatesResponse ListAssessmentTemplates ( ListAssessmentTemplatesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListAssessmentTemplatesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListAssessmentTemplatesResponseUnmarshaller . Instance ; return Invoke < ListAssessmentTemplatesResponse > ( request , options ) ; }
public virtual RestoreFromClusterSnapshotResponse RestoreFromClusterSnapshot ( RestoreFromClusterSnapshotRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = RestoreFromClusterSnapshotRequestMarshaller . Instance ; options . ResponseUnmarshaller = RestoreFromClusterSnapshotResponseUnmarshaller . Instance ; return Invoke < RestoreFromClusterSnapshotResponse > ( request , options ) ; }
public void AddShape ( HSSFShape shape ) { shape . Patriarch = ( this . Patriarch ) ; shape . Parent = ( this ) ; shapes . Add ( shape ) ; }
public override bool Equals ( object o ) { if ( this == o ) return true ; if ( o == null || GetType ( ) != o . GetType ( ) ) return false ; FacetEntry that = ( FacetEntry ) o ; if ( count != that . count ) return false ; if ( ! value . Equals ( that . value ) ) return false ; return true ; }
public static int Prev ( byte [ ] b , int ptr , char chrA ) { if ( ptr == b . Length ) { -- ptr ; } while ( ptr >= 0 ) { if ( b [ ptr -- ] == chrA ) { return ptr ; } } return ptr ; }
public virtual bool IsDeltaRepresentation ( ) { return deltaBase != null ; }
public virtual IToken EmitEOF ( ) { int cpos = Column ; int line = Line ; IToken eof = _factory . Create ( _tokenFactorySourcePair , TokenConstants . EOF , null , TokenConstants . DefaultChannel , _input . Index , _input . Index - 1 , line , cpos ) ; Emit ( eof ) ; return eof ; }
public UpdateUserRequest ( string userName ) { _userName = userName ; }
public virtual RevFilter Negate ( ) { return NotRevFilter . Create ( this ) ; }
public virtual void SetTagger ( PersonIdent taggerIdent ) { tagger = taggerIdent ; }
public static BufferSize Automatic ( ) { long max , total , free ; using ( var proc = Process . GetCurrentProcess ( ) ) { max = proc . PeakVirtualMemorySize64 ; total = proc . VirtualMemorySize64 ; free = proc . PrivateMemorySize64 ; } long totalAvailableBytes = max - total + free ; long sortBufferByteSize = free / 2 ; long minBufferSizeBytes = MIN_BUFFER_SIZE_MB * MB ; if ( sortBufferByteSize < minBufferSizeBytes || totalAvailableBytes > 10 * minBufferSizeBytes ) { if ( totalAvailableBytes / 2 > minBufferSizeBytes ) { sortBufferByteSize = totalAvailableBytes / 2 ; } else { sortBufferByteSize = Math . Max ( ABSOLUTE_MIN_SORT_BUFFER_SIZE , sortBufferByteSize ) ; } } return new BufferSize ( Math . Min ( ( long ) int . MaxValue , sortBufferByteSize ) ) ; }
public static int TrimTrailingWhitespace ( byte [ ] raw , int start , int end ) { int ptr = end - 1 ; while ( start <= ptr && IsWhitespace ( raw [ ptr ] ) ) { ptr -- ; } return ptr + 1 ; }
public TopMarginRecord ( RecordInputStream in1 ) { field_1_margin = in1. ReadDouble ( ) ; }
public RetrieveEnvironmentInfoRequest ( EnvironmentInfoType infoType ) { _infoType = infoType ; }
public virtual CreatePlayerSessionsResponse CreatePlayerSessions ( CreatePlayerSessionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreatePlayerSessionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreatePlayerSessionsResponseUnmarshaller . Instance ; return Invoke < CreatePlayerSessionsResponse > ( request , options ) ; }
public virtual CreateProxySessionResponse CreateProxySession ( CreateProxySessionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateProxySessionRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateProxySessionResponseUnmarshaller . Instance ; return Invoke < CreateProxySessionResponse > ( request , options ) ; }
public virtual int GetObjectType ( ) { return type ; }
public virtual string GetScheme ( ) { return scheme ; }
public override void Characters ( char [ ] ch , int start , int length ) { contents . Append ( ch , start , length ) ; }
public FetchAlbumTagPhotosRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " FetchAlbumTagPhotos " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public virtual DeleteMembersResponse DeleteMembers ( DeleteMembersRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteMembersRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteMembersResponseUnmarshaller . Instance ; return Invoke < DeleteMembersResponse > ( request , options ) ; }
public virtual GetContactReachabilityStatusResponse GetContactReachabilityStatus ( GetContactReachabilityStatusRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetContactReachabilityStatusRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetContactReachabilityStatusResponseUnmarshaller . Instance ; return Invoke < GetContactReachabilityStatusResponse > ( request , options ) ; }
public override bool remove ( object o ) { lock ( this . _enclosing ) { int oldSize = this . _enclosing . _size ; this . _enclosing . remove ( o ) ; return this . _enclosing . _size != oldSize ; } }
public virtual E last ( ) { return backingMap . lastKey ( ) ; }
public virtual CreateStreamingDistributionResponse CreateStreamingDistribution ( CreateStreamingDistributionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateStreamingDistributionRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateStreamingDistributionResponseUnmarshaller . Instance ; return Invoke < CreateStreamingDistributionResponse > ( request , options ) ; }
public bool isAbsolute ( ) { return absolute ; }
public virtual DisableAddOnResponse DisableAddOn ( DisableAddOnRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DisableAddOnRequestMarshaller . Instance ; options . ResponseUnmarshaller = DisableAddOnResponseUnmarshaller . Instance ; return Invoke < DisableAddOnResponse > ( request , options ) ; }
public virtual DescribeAliasResponse DescribeAlias ( DescribeAliasRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeAliasRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeAliasResponseUnmarshaller . Instance ; return Invoke < DescribeAliasResponse > ( request , options ) ; }
public override void Next ( int delta ) { while ( -- delta >= 0 ) { if ( currentSubtree != null ) { ptr += currentSubtree . GetEntrySpan ( ) ; } else { ptr ++ ; } if ( Eof ) { break ; } ParseEntry ( ) ; } }
public override RevFilter Clone ( ) { return new AndRevFilter . Binary ( a . Clone ( ) , b . Clone ( ) ) ; }
public override TextReader Create ( TextReader input ) { return new PersianCharFilter ( input ) ; }
public virtual string Option ( ) { return option ; }
public override string ToString ( ) { var sb = new StringBuilder ( " [ " ) ; foreach ( var item in this ) { if ( sb . Length > 1 ) { sb . Append ( " , ▁ " ) ; } sb . Append ( item ) ; } return sb . Append ( ' ] ' ) . ToString ( ) ; }
public virtual DescribeSignalingChannelResponse DescribeSignalingChannel ( DescribeSignalingChannelRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeSignalingChannelRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeSignalingChannelResponseUnmarshaller . Instance ; return Invoke < DescribeSignalingChannelResponse > ( request , options ) ; }
public virtual AttachStaticIpResponse AttachStaticIp ( AttachStaticIpRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AttachStaticIpRequestMarshaller . Instance ; options . ResponseUnmarshaller = AttachStaticIpResponseUnmarshaller . Instance ; return Invoke < AttachStaticIpResponse > ( request , options ) ; }
public override String ToString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; CellReference crA = new CellReference ( _firstRowIndex , _firstColumnIndex , false , false ) ; CellReference crB = new CellReference ( _lastRowIndex , _lastColumnIndex , false , false ) ; sb . Append ( GetType ( ) . Name ) ; sb . Append ( " ▁ [ " ) . Append ( crA . FormatAsString ( ) ) . Append ( ' : ' ) . Append ( crB . FormatAsString ( ) ) . Append ( " ] " ) ; return sb . ToString ( ) ; }
public BloomFilteringPostingsFormat ( PostingsFormat delegatePostingsFormat , BloomFilterFactory bloomFilterFactory ) : base ( ) { _delegatePostingsFormat = delegatePostingsFormat ; _bloomFilterFactory = bloomFilterFactory ; }
public virtual ListTemplatesResponse ListTemplates ( ListTemplatesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListTemplatesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListTemplatesResponseUnmarshaller . Instance ; return Invoke < ListTemplatesResponse > ( request , options ) ; }
public TimerThread ( long resolution , Counter counter ) : base ( THREAD_NAME ) { this . resolution = resolution ; this . counter = counter ; this . IsBackground = ( true ) ; }
public DrawingRecord ( ) { recordData = EMPTY_BYTE_ARRAY ; }
public virtual ListDirectoriesResponse ListDirectories ( ListDirectoriesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListDirectoriesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListDirectoriesResponseUnmarshaller . Instance ; return Invoke < ListDirectoriesResponse > ( request , options ) ; }
public override void Decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { var block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 7 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 6 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 5 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 4 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 3 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 2 ) ) & 1 ; values [ valuesOffset ++ ] = ( ( int ) ( ( uint ) block >> 1 ) ) & 1 ; values [ valuesOffset ++ ] = block & 1 ; } }
public virtual GroupingSearch DisableCaching ( ) { this . maxCacheRAMMB = null ; this . maxDocsToCache = null ; return this ; }
public static int idealByteArraySize ( int need ) { { for ( int i = 4 ; i < 32 ; i ++ ) { if ( need <= ( 1 << i ) - 12 ) { return ( 1 << i ) - 12 ; } } } return need ; }
public virtual UpdateAssessmentTargetResponse UpdateAssessmentTarget ( UpdateAssessmentTargetRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateAssessmentTargetRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateAssessmentTargetResponseUnmarshaller . Instance ; return Invoke < UpdateAssessmentTargetResponse > ( request , options ) ; }
public virtual ModifyVolumeResponse ModifyVolume ( ModifyVolumeRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ModifyVolumeRequestMarshaller . Instance ; options . ResponseUnmarshaller = ModifyVolumeResponseUnmarshaller . Instance ; return Invoke < ModifyVolumeResponse > ( request , options ) ; }
public override Cell Merge ( Cell m , Cell e ) { if ( m . cmd == e . cmd && m . @ ref == e . @ ref && m . skip == e . skip ) { Cell c = new Cell ( m ) ; c . cnt += e . cnt ; return c ; } else { return null ; } }
public override ByteBuffer Read ( int length , long position ) { if ( position >= Size ) throw new ArgumentException ( " Position ▁ " + position + " ▁ past ▁ the ▁ end ▁ of ▁ the ▁ file " ) ; ByteBuffer dst ; int worked = - 1 ; if ( writable ) { dst = ByteBuffer . CreateBuffer ( length ) ; worked = 0 ; } else { fileStream . Position = position ; dst = ByteBuffer . CreateBuffer ( length ) ; worked = IOUtils . ReadFully ( fileStream , dst . Buffer ) ; } if ( worked == - 1 ) throw new ArgumentException ( " Position ▁ " + position + " ▁ past ▁ the ▁ end ▁ of ▁ the ▁ file " ) ; dst . Position = 0 ; return dst ; }
public virtual RespondActivityTaskCompletedResponse RespondActivityTaskCompleted ( RespondActivityTaskCompletedRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = RespondActivityTaskCompletedRequestMarshaller . Instance ; options . ResponseUnmarshaller = RespondActivityTaskCompletedResponseUnmarshaller . Instance ; return Invoke < RespondActivityTaskCompletedResponse > ( request , options ) ; }
public void incrementProgressBy ( int diff ) { lock ( this ) { setProgress ( mProgress + diff ) ; } }
public virtual WorkingTreeIterator . MetadataDiff CompareMetadata ( DirCacheEntry entry ) { if ( entry . IsAssumeValid ) { return WorkingTreeIterator . MetadataDiff . EQUAL ; } if ( entry . IsUpdateNeeded ) { return WorkingTreeIterator . MetadataDiff . DIFFER_BY_METADATA ; } if ( ! entry . IsSmudged && entry . Length != ( int ) GetEntryLength ( ) ) { return WorkingTreeIterator . MetadataDiff . DIFFER_BY_METADATA ; } if ( IsModeDifferent ( entry . RawMode ) ) { return WorkingTreeIterator . MetadataDiff . DIFFER_BY_METADATA ; } long cacheLastModified = entry . LastModified ; long fileLastModified = GetEntryLastModified ( ) ; if ( cacheLastModified % 1000 == 0 || fileLastModified % 1000 == 0 ) { cacheLastModified = cacheLastModified - cacheLastModified % 1000 ; fileLastModified = fileLastModified - fileLastModified % 1000 ; } if ( fileLastModified != cacheLastModified ) { return WorkingTreeIterator . MetadataDiff . DIFFER_BY_TIMESTAMP ; } else { if ( ! entry . IsSmudged ) { return WorkingTreeIterator . MetadataDiff . EQUAL ; } else { return WorkingTreeIterator . MetadataDiff . SMUDGED ; } } }
public static NumberRecord ConvertToNumberRecord ( RKRecord rk ) { NumberRecord num = new NumberRecord ( ) ; num . Column = ( rk . Column ) ; num . Row = ( rk . Row ) ; num . XFIndex = ( rk . XFIndex ) ; num . Value = ( rk . RKNumber ) ; return num ; }
public override java . nio . CharBuffer put ( char [ ] src , int srcOffset , int charCount ) { byteBuffer . limit ( _limit * libcore . io . SizeOf . CHAR ) ; byteBuffer . position ( _position * libcore . io . SizeOf . CHAR ) ; if ( byteBuffer is java . nio . ReadWriteDirectByteBuffer ) { ( ( java . nio . ReadWriteDirectByteBuffer ) byteBuffer ) . put ( src , srcOffset , charCount ) ; } else { ( ( java . nio . ReadWriteHeapByteBuffer ) byteBuffer ) . put ( src , srcOffset , charCount ) ; } this . _position += charCount ; return this ; }
public int GetCells ( ) { int size = 0 ; foreach ( char c in cells . Keys ) { Cell e = At ( c ) ; if ( e . cmd >= 0 || e . @ ref >= 0 ) { size ++ ; } } return size ; }
public BeiderMorseFilterFactory ( IDictionary < string , string > args ) : base ( args ) { NameType nameType = ( NameType ) Enum . Parse ( typeof ( NameType ) , Get ( args , " nameType " , NameType . GENERIC . ToString ( ) ) , true ) ; RuleType ruleType = ( RuleType ) Enum . Parse ( typeof ( RuleType ) , Get ( args , " ruleType " , RuleType . APPROX . ToString ( ) ) , true ) ; bool concat = GetBoolean ( args , " concat " , true ) ; engine = new PhoneticEngine ( nameType , ruleType , concat ) ; ISet < string > langs = GetSet ( args , " languageSet " ) ; languageSet = ( null == langs || ( 1 == langs . Count && langs . Contains ( " auto " ) ) ) ? null : LanguageSet . From ( langs ) ; if ( ! ( args . Count == 0 ) ) { throw new ArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static double varp ( double [ ] v ) { double r = Double . NaN ; if ( v != null && v . Length > 1 ) { r = devsq ( v ) / v . Length ; } return r ; }
public PersianNormalizationFilterFactory ( IDictionary < string , string > args ) : base ( args ) { if ( args . Count > 0 ) { throw new System . ArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static WeightedTerm [ ] GetTerms ( Query query , bool prohibited , string fieldName ) { var terms = new JCG . HashSet < WeightedTerm > ( ) ; if ( fieldName != null ) { fieldName = fieldName . Intern ( ) ; } GetTerms ( query , terms , prohibited , fieldName ) ; return terms . ToArray ( ) ; }
public virtual DeleteDocumentationPartResponse DeleteDocumentationPart ( DeleteDocumentationPartRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteDocumentationPartRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteDocumentationPartResponseUnmarshaller . Instance ; return Invoke < DeleteDocumentationPartResponse > ( request , options ) ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ CHART ] \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . x ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( " 0x " ) . Append ( HexDump . ToHex ( X ) ) . Append ( " ▁ ( " ) . Append ( X ) . Append ( " ▁ ) " ) ; buffer . Append ( Environment . NewLine ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . y ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( " 0x " ) . Append ( HexDump . ToHex ( Y ) ) . Append ( " ▁ ( " ) . Append ( Y ) . Append ( " ▁ ) " ) ; buffer . Append ( Environment . NewLine ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . width ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( " 0x " ) . Append ( HexDump . ToHex ( Width ) ) . Append ( " ▁ ( " ) . Append ( Width ) . Append ( " ▁ ) " ) ; buffer . Append ( Environment . NewLine ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . height ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( " 0x " ) . Append ( HexDump . ToHex ( Height ) ) . Append ( " ▁ ( " ) . Append ( Height ) . Append ( " ▁ ) " ) ; buffer . Append ( Environment . NewLine ) ; buffer . Append ( " [ / CHART ] \ n " ) ; return buffer . ToString ( ) ; }
public sealed override short get ( int index ) { checkIndex ( index ) ; return backingArray [ offset + index ] ; }
public override string ToString ( ) { return Image ; }
public override ValueEval Evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { try { AreaEval reA = EvaluateRef ( arg0 ) ; AreaEval reB = EvaluateRef ( arg1 ) ; AreaEval result = ResolveRange ( reA , reB ) ; if ( result == null ) { return ErrorEval . NULL_INTERSECTION ; } return result ; } catch ( EvaluationException e ) { return e . GetErrorEval ( ) ; } }
public virtual void Clear ( ) { weightBySpanQuery . Clear ( ) ; }
public virtual int FindEndOffset ( StringBuilder buffer , int start ) { if ( start > buffer . Length || start < 0 ) return start ; bi . SetText ( buffer . ToString ( start , buffer . Length - start ) ) ; return bi . Next ( ) + start ; }
public SrndQuery PrimaryQuery ( ) { SrndQuery q ; switch ( ( jj_ntk == - 1 ) ? Jj_ntk ( ) : jj_ntk ) { case RegexpToken . LPAREN : Jj_consume_token ( RegexpToken . LPAREN ) ; q = FieldsQuery ( ) ; Jj_consume_token ( RegexpToken . RPAREN ) ; break ; case RegexpToken . OR : case RegexpToken . AND : case RegexpToken . W : case RegexpToken . N : q = PrefixOperatorQuery ( ) ; break ; case RegexpToken . TRUNCQUOTED : case RegexpToken . QUOTED : case RegexpToken . SUFFIXTERM : case RegexpToken . TRUNCTERM : case RegexpToken . TERM : q = SimpleTerm ( ) ; break ; default : jj_la1 [ 5 ] = jj_gen ; Jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } OptionalWeights ( q ) ; { if ( true ) return q ; } throw new Exception ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public virtual DeleteApiKeyResponse DeleteApiKey ( DeleteApiKeyRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteApiKeyRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteApiKeyResponseUnmarshaller . Instance ; return Invoke < DeleteApiKeyResponse > ( request , options ) ; }
public InsertTagsRequest ( ) : base ( " Ots " , " 2016 - 06 - 20 " , " InsertTags " , " ots " , " openAPI " ) { Method = MethodType . POST ; }
public virtual DeleteUserByPrincipalIdResponse DeleteUserByPrincipalId ( DeleteUserByPrincipalIdRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteUserByPrincipalIdRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteUserByPrincipalIdResponseUnmarshaller . Instance ; return Invoke < DeleteUserByPrincipalIdResponse > ( request , options ) ; }
public virtual DescribeNetworkInterfacesResponse DescribeNetworkInterfaces ( DescribeNetworkInterfacesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeNetworkInterfacesRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeNetworkInterfacesResponseUnmarshaller . Instance ; return Invoke < DescribeNetworkInterfacesResponse > ( request , options ) ; }
public override int Serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . BeforeRecordSerialize ( offset , RecordId , this ) ; LittleEndian . PutShort ( data , offset , Options ) ; LittleEndian . PutShort ( data , offset + 2 , RecordId ) ; LittleEndian . PutInt ( data , offset + 4 , 8 ) ; LittleEndian . PutInt ( data , offset + 8 , field_1_numShapes ) ; LittleEndian . PutInt ( data , offset + 12 , field_2_lastMSOSPID ) ; listener . AfterRecordSerialize ( offset + 16 , RecordId , RecordSize , this ) ; return RecordSize ; }
public virtual CreateSecurityConfigurationResponse CreateSecurityConfiguration ( CreateSecurityConfigurationRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateSecurityConfigurationRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateSecurityConfigurationResponseUnmarshaller . Instance ; return Invoke < CreateSecurityConfigurationResponse > ( request , options ) ; }
public virtual DescribeClientVpnConnectionsResponse DescribeClientVpnConnections ( DescribeClientVpnConnectionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeClientVpnConnectionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeClientVpnConnectionsResponseUnmarshaller . Instance ; return Invoke < DescribeClientVpnConnectionsResponse > ( request , options ) ; }
public static void fill ( double [ ] array , double value ) { { for ( int i = 0 ; i < array . Length ; i ++ ) { array [ i ] = value ; } } }
public bool hasNext ( ) { return pos < maxColumn ; }
public DocsEnum Reset ( int [ ] postings ) { this . postings = postings ; upto = - 2 ; freq_Renamed = 0 ; return this ; }
public bool HasAll ( RevFlagSet set ) { return ( flags & set . mask ) == set . mask ; }
public virtual ModifyAccountResponse ModifyAccount ( ModifyAccountRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ModifyAccountRequestMarshaller . Instance ; options . ResponseUnmarshaller = ModifyAccountResponseUnmarshaller . Instance ; return Invoke < ModifyAccountResponse > ( request , options ) ; }
public virtual IToken LT ( int k ) { LazyInit ( ) ; if ( k == 0 ) { return null ; } if ( k < 0 ) { return Lb ( - k ) ; } int i = p + k - 1 ; Sync ( i ) ; if ( i >= tokens . Count ) { return tokens [ tokens . Count - 1 ] ; } return tokens [ i ] ; }
public void RemoveSheet ( int sheetIndex ) { if ( boundsheets . Count > sheetIndex ) { records . Remove ( records . Bspos - ( boundsheets . Count - 1 ) + sheetIndex ) ; boundsheets . RemoveAt ( sheetIndex ) ; FixTabIdRecord ( ) ; } int sheetNum1Based = sheetIndex + 1 ; for ( int i = 0 ; i < NumNames ; i ++ ) { NameRecord nr = GetNameRecord ( i ) ; if ( nr . SheetNumber == sheetNum1Based ) { nr . SheetNumber = ( 0 ) ; } else if ( nr . SheetNumber > sheetNum1Based ) { nr . SheetNumber = ( nr . SheetNumber - 1 ) ; } } if ( linkTable != null ) { for ( int i = sheetIndex + 1 ; i < NumSheets + 1 ; i ++ ) { linkTable . RemoveSheet ( i ) ; } } }
public void RemoveName ( int index ) { names . RemoveAt ( index ) ; workbook . RemoveName ( index ) ; }
public override bool Equals ( Object o ) { if ( ! ( o is Property ) ) return false ; Property p = ( Property ) o ; Object pValue = p . Value ; long pId = p . ID ; if ( id != pId || ( id != 0 && ! TypesAreEqual ( type , p . Type ) ) ) return false ; if ( value == null && pValue == null ) return true ; if ( value == null || pValue == null ) return false ; Type valueClass = value . GetType ( ) ; Type pValueClass = pValue . GetType ( ) ; if ( ! ( valueClass . IsAssignableFrom ( pValueClass ) ) &&! ( pValueClass . IsAssignableFrom ( valueClass ) ) ) return false ; if ( value is byte [ ] ) return Arrays . Equals ( ( byte [ ] ) value , ( byte [ ] ) pValue ) ; return value . Equals ( pValue ) ; }
public GetRepoBuildListRequest ( ) : base ( " cr " , " 2016 - 06 - 07 " , " GetRepoBuildList " , " cr " , " openAPI " ) { UriPattern = " / repos / [ RepoNamespace ] / [ RepoName ] / build " ; Method = MethodType . GET ; }
public MessageWriter ( ) { buf = new ByteArrayOutputStream ( ) ; enc = new OutputStreamWriter ( GetRawStream ( ) , Constants . CHARSET ) ; }
public void Append ( RecordBase r ) { _recs . Add ( r ) ; }
public override void Close ( ) { if ( this . Read ( this . skipBuffer ) != - 1 || this . actualSize != this . expectedSize ) { throw new CorruptObjectException ( MessageFormat . Format ( JGitText . Get ( ) . packfileCorruptionDetected , JGitText . Get ( ) . wrongDecompressedLength ) ) ; } int used = this . _enclosing . bAvail - this . inf . RemainingInput ; if ( 0 < used ) { this . _enclosing . OnObjectData ( this . src , this . _enclosing . buf , this . p , used ) ; this . _enclosing . Use ( used ) ; } this . inf . Reset ( ) ; }
public virtual DescribeModelPackageResponse DescribeModelPackage ( DescribeModelPackageRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeModelPackageRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeModelPackageResponseUnmarshaller . Instance ; return Invoke < DescribeModelPackageResponse > ( request , options ) ; }
public void Construct ( CellValueRecordInterface rec , RecordStream rs , SharedValueManager sfh ) { if ( rec is FormulaRecord ) { FormulaRecord formulaRec = ( FormulaRecord ) rec ; StringRecord cachedText = null ; Type nextClass = rs . PeekNextClass ( ) ; if ( nextClass == typeof ( StringRecord ) ) { cachedText = ( StringRecord ) rs . GetNext ( ) ; } else { cachedText = null ; } InsertCell ( new FormulaRecordAggregate ( formulaRec , cachedText , sfh ) ) ; } else { InsertCell ( rec ) ; } }
public override object Clone ( ) { return new DeflateDecompressor ( ) ; }
public virtual UpdateS3ResourcesResponse UpdateS3Resources ( UpdateS3ResourcesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateS3ResourcesRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateS3ResourcesResponseUnmarshaller . Instance ; return Invoke < UpdateS3ResourcesResponse > ( request , options ) ; }
public GroupQueryNode ( IQueryNode query ) { if ( query == null ) { throw new QueryNodeError ( new Message ( QueryParserMessages . PARAMETER_VALUE_NOT_SUPPORTED , " query " , " null " ) ) ; } Allocate ( ) ; IsLeaf = false ; Add ( query ) ; }
public override string ToQueryString ( IEscapeQuerySyntax escaper ) { StringBuilder path = new StringBuilder ( ) ; path . Append ( " / " ) . Append ( GetFirstPathElement ( ) ) ; foreach ( QueryText pathelement in GetPathElements ( 1 ) ) { string value = escaper . Escape ( new StringCharSequence ( pathelement . Value ) , CultureInfo . InvariantCulture , EscapeQuerySyntaxType . STRING ) . ToString ( ) ; path . Append ( " /\ " " ) . Append ( value ) . Append ( " \ " " ) ; } return path . ToString ( ) ; }
public void RemoveCellComment ( ) { HSSFComment comment2 = _sheet . FindCellComment ( _record . Row , _record . Column ) ; comment = null ; if ( null == comment2 ) { return ; } ( _sheet . DrawingPatriarch as HSSFPatriarch ) . RemoveShape ( comment2 ) ; }
public void Reset ( ) { count = 0 ; Debug . Assert ( forwardCount == 0 , " pos = " + pos + " ▁ forwardCount = " + forwardCount ) ; }
public virtual ActivateUserResponse ActivateUser ( ActivateUserRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ActivateUserRequestMarshaller . Instance ; options . ResponseUnmarshaller = ActivateUserResponseUnmarshaller . Instance ; return Invoke < ActivateUserResponse > ( request , options ) ; }
public virtual bool isCharsetDetected ( ) { throw new System . NotSupportedException ( ) ; }
public virtual ModifySnapshotCopyRetentionPeriodResponse ModifySnapshotCopyRetentionPeriod ( ModifySnapshotCopyRetentionPeriodRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ModifySnapshotCopyRetentionPeriodRequestMarshaller . Instance ; options . ResponseUnmarshaller = ModifySnapshotCopyRetentionPeriodResponseUnmarshaller . Instance ; return Invoke < ModifySnapshotCopyRetentionPeriodResponse > ( request , options ) ; }
public virtual DeleteClusterSubnetGroupResponse DeleteClusterSubnetGroup ( DeleteClusterSubnetGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteClusterSubnetGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteClusterSubnetGroupResponseUnmarshaller . Instance ; return Invoke < DeleteClusterSubnetGroupResponse > ( request , options ) ; }
public static string Decode ( byte [ ] buffer ) { return Decode ( buffer , 0 , buffer . Length ) ; }
public virtual int GetDefaultPort ( ) { return - 1 ; }
public virtual StopTaskResponse StopTask ( StopTaskRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = StopTaskRequestMarshaller . Instance ; options . ResponseUnmarshaller = StopTaskResponseUnmarshaller . Instance ; return Invoke < StopTaskResponse > ( request , options ) ; }
public override void SeekExact ( BytesRef target , TermState otherState ) { if ( ! target . Equals ( term_Renamed ) ) { state . CopyFrom ( otherState ) ; term_Renamed = BytesRef . DeepCopyOf ( target ) ; seekPending = true ; } }
public SeriesToChartGroupRecord ( RecordInputStream in1 ) { field_1_chartGroupIndex = in1. ReadShort ( ) ; }
public static void WriteUnicodeStringFlagAndData ( ILittleEndianOutput out1 , String value ) { bool is16Bit = HasMultibyte ( value ) ; out1. WriteByte ( is16Bit ? 0x01 : 0x00 ) ; if ( is16Bit ) { PutUnicodeLE ( value , out1 ) ; } else { PutCompressedUnicode ( value , out1 ) ; } }
public virtual AuthorizeSecurityGroupIngressResponse AuthorizeSecurityGroupIngress ( AuthorizeSecurityGroupIngressRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AuthorizeSecurityGroupIngressRequestMarshaller . Instance ; options . ResponseUnmarshaller = AuthorizeSecurityGroupIngressResponseUnmarshaller . Instance ; return Invoke < AuthorizeSecurityGroupIngressResponse > ( request , options ) ; }
public void AddFile ( string file ) { CheckFileNames ( new [ ] { file } ) ; setFiles . Add ( file ) ; }
public virtual void setSize ( int width , int height ) { mWidth = width ; mHeight = height ; }
public void SetPrecedenceFilterSuppressed ( bool value ) { if ( value ) { this . reachesIntoOuterContext |= SUPPRESS_PRECEDENCE_FILTER ; } else { this . reachesIntoOuterContext &= ~ SUPPRESS_PRECEDENCE_FILTER ; } }
public virtual IntervalSet Look ( ATNState s , RuleContext ctx ) { return Look ( s , null , ctx ) ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( OptionFlags ) ; out1. WriteShort ( RowHeight ) ; }
public Builder ( bool dedup ) { this . dedup = dedup ; }
public Hashtable ( int capacity , float loadFactor ) : this ( capacity ) { if ( loadFactor <= 0 || float . IsNaN ( loadFactor ) ) { throw new System . ArgumentException ( " Load ▁ factor : ▁ " + loadFactor ) ; } }
public virtual object Get ( string key ) { int bucket = normalCompletion . GetBucket ( key ) ; return bucket == - 1 ? ( long ? ) null : bucket ; }
public virtual ListHyperParameterTuningJobsResponse ListHyperParameterTuningJobs ( ListHyperParameterTuningJobsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListHyperParameterTuningJobsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListHyperParameterTuningJobsResponseUnmarshaller . Instance ; return Invoke < ListHyperParameterTuningJobsResponse > ( request , options ) ; }
public virtual DeleteTableResponse DeleteTable ( string tableName ) { var request = new DeleteTableRequest ( ) ; request . TableName = tableName ; return DeleteTable ( request ) ; }
protected internal override bool LessThan ( TextFragment fragA , TextFragment fragB ) { if ( fragA . Score == fragB . Score ) return fragA . FragNum > fragB . FragNum ; else return fragA . Score < fragB . Score ; }
public void FreeBefore ( int pos ) { Debug . Assert ( pos >= 0 ) ; Debug . Assert ( pos <= nextPos ) ; int newCount = nextPos - pos ; Debug . Assert ( newCount <= count , " newCount = " + newCount + " ▁ count = " + count ) ; Debug . Assert ( newCount <= buffer . Length , " newCount = " + newCount + " ▁ buf . length = " + buffer . Length ) ; count = newCount ; }
public virtual UpdateHITTypeOfHITResponse UpdateHITTypeOfHIT ( UpdateHITTypeOfHITRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateHITTypeOfHITRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateHITTypeOfHITResponseUnmarshaller . Instance ; return Invoke < UpdateHITTypeOfHITResponse > ( request , options ) ; }
public virtual UpdateRecommenderConfigurationResponse UpdateRecommenderConfiguration ( UpdateRecommenderConfigurationRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateRecommenderConfigurationRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateRecommenderConfigurationResponseUnmarshaller . Instance ; return Invoke < UpdateRecommenderConfigurationResponse > ( request , options ) ; }
public int CompareTo ( object other ) { BytesRef br = other as BytesRef ; Debug . Assert ( br != null ) ; return utf8SortedAsUnicodeSortOrder . Compare ( this , br ) ; }
public virtual int Stem ( char [ ] s , int len ) { if ( len > 4 && s [ len - 1 ] == ' s ' ) { len -- ; } if ( len > 5 && ( StemmerUtil . EndsWith ( s , len , " ene " ) || ( StemmerUtil . EndsWith ( s , len , " ane " ) && useNynorsk ) ) ) { return len - 3 ; } if ( len > 4 && ( StemmerUtil . EndsWith ( s , len , " er " ) || StemmerUtil . EndsWith ( s , len , " en " ) || StemmerUtil . EndsWith ( s , len , " et " ) || ( StemmerUtil . EndsWith ( s , len , " ar " ) && useNynorsk ) ) ) { return len - 2 ; } if ( len > 3 ) { switch ( s [ len - 1 ] ) { case ' a ' : case ' e ' : return len - 1 ; } } return len ; }
public virtual DescribeDBSnapshotsResponse DescribeDBSnapshots ( DescribeDBSnapshotsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeDBSnapshotsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeDBSnapshotsResponseUnmarshaller . Instance ; return Invoke < DescribeDBSnapshotsResponse > ( request , options ) ; }
public SortedSetDocValuesFacetField ( string dim , string label ) : base ( " dummy " , TYPE ) { FacetField . VerifyLabel ( label ) ; FacetField . VerifyLabel ( dim ) ; this . Dim = dim ; this . Label = label ; }
public virtual CreateDocumentationPartResponse CreateDocumentationPart ( CreateDocumentationPartRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateDocumentationPartRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateDocumentationPartResponseUnmarshaller . Instance ; return Invoke < CreateDocumentationPartResponse > ( request , options ) ; }
public virtual string GetValue ( ) { return value ; }
public override java . nio . ShortBuffer asReadOnlyBuffer ( ) { return duplicate ( ) ; }
public virtual UpdateDataSourcePermissionsResponse UpdateDataSourcePermissions ( UpdateDataSourcePermissionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateDataSourcePermissionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateDataSourcePermissionsResponseUnmarshaller . Instance ; return Invoke < UpdateDataSourcePermissionsResponse > ( request , options ) ; }
public static Record CreateSingleRecord ( RecordInputStream in1 ) { if ( _recordCreatorsById . ContainsKey ( in1. Sid ) ) { I_RecordCreator constructor = _recordCreatorsById [ in1. Sid ] ; return constructor . Create ( in1 ) ; } else { return new UnknownRecord ( in1 ) ; } }
public override int getCount ( ) { return this . _enclosing . mTabLayout . getChildCount ( ) ; }
public virtual DeleteApplicationReferenceDataSourceResponse DeleteApplicationReferenceDataSource ( DeleteApplicationReferenceDataSourceRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteApplicationReferenceDataSourceRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteApplicationReferenceDataSourceResponseUnmarshaller . Instance ; return Invoke < DeleteApplicationReferenceDataSourceResponse > ( request , options ) ; }
public virtual CreateProjectVersionResponse CreateProjectVersion ( CreateProjectVersionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateProjectVersionRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateProjectVersionResponseUnmarshaller . Instance ; return Invoke < CreateProjectVersionResponse > ( request , options ) ; }
public override java . nio . IntBuffer slice ( ) { return new java . nio . ReadOnlyIntArrayBuffer ( remaining ( ) , backingArray , offset + _position ) ; }
public sealed override byte get ( ) { throw new System . NotImplementedException ( ) ; }
public override java . nio . LongBuffer put ( int index , long c ) { checkIndex ( index ) ; backingArray [ offset + index ] = c ; return this ; }
public StoredField ( string name , float value ) : base ( name , TYPE ) { FieldsData = new Single ( value ) ; }
public virtual IntervalSet GetExpectedTokensWithinCurrentRule ( ) { ATN atn = Interpreter . atn ; ATNState s = atn . states [ State ] ; return atn . NextTokens ( s ) ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ FILESHARING ] \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . Readonly ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( ReadOnly == 1 ? " true " : " false " ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . password ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( StringUtil . ToHexString ( Password ) ) . Append ( " \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . username ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( Username ) . Append ( " \ n " ) ; buffer . Append ( " [ / FILESHARING ] \ n " ) ; return buffer . ToString ( ) ; }
protected internal SubmoduleInitCommand ( Repository repo ) : base ( repo ) { paths = new AList < string > ( ) ; }
public virtual void Include ( string name , AnyObjectId id ) { if ( ! Repository . IsValidRefName ( name ) ) { throw new ArgumentException ( MessageFormat . Format ( JGitText . Get ( ) . invalidRefName , name ) ) ; } if ( include . ContainsKey ( name ) ) { throw new InvalidOperationException ( JGitText . Get ( ) . duplicateRef + name ) ; } include . Put ( name , id . ToObjectId ( ) ) ; }
public virtual EnableSnapshotCopyResponse EnableSnapshotCopy ( EnableSnapshotCopyRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = EnableSnapshotCopyRequestMarshaller . Instance ; options . ResponseUnmarshaller = EnableSnapshotCopyResponseUnmarshaller . Instance ; return Invoke < EnableSnapshotCopyResponse > ( request , options ) ; }
public virtual ValueFiller GetValueFiller ( ) { return new ValueFillerAnonymousInnerClassHelper ( this ) ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteByte ( Pane ) ; out1. WriteShort ( ActiveCellRow ) ; out1. WriteShort ( ActiveCellCol ) ; out1. WriteShort ( ActiveCellRef ) ; int nRefs = field_6_refs . Length ; out1. WriteShort ( nRefs ) ; for ( int i = 0 ; i < field_6_refs . Length ; i ++ ) { field_6_refs [ i ] . Serialize ( out1 ) ; } }
public static Counter NewCounter ( ) { return NewCounter ( false ) ; }
public virtual int Get ( string name , int dflt ) { int [ ] vals ; object temp ; if ( valByRound . TryGetValue ( name , out temp ) && temp != null ) { vals = ( int [ ] ) temp ; return vals [ roundNumber % vals . Length ] ; } string sval ; if ( ! props . TryGetValue ( name , out sval ) ) { sval = dflt . ToString ( CultureInfo . InvariantCulture ) ; } if ( sval . IndexOf ( ' : ' ) < 0 ) { return int . Parse ( sval , CultureInfo . InvariantCulture ) ; } int k = sval . IndexOf ( ' : ' ) ; string colName = sval . Substring ( 0 , k - 0 ) ; sval = sval . Substring ( k + 1 ) ; colForValByRound [ name ] = colName ; vals = PropToInt32Array ( sval ) ; valByRound [ name ] = vals ; return vals [ roundNumber % vals . Length ] ; }
public void PreSerialize ( ) { if ( records . Tabpos > 0 ) { TabIdRecord tir = ( TabIdRecord ) records [ ( records . Tabpos ) ] ; if ( tir . _tabids . Length < boundsheets . Count ) { FixTabIdRecord ( ) ; } } }
public LimitTokenCountAnalyzer ( Analyzer @ delegate , int maxTokenCount , bool consumeAllTokens ) : base ( @ delegate . Strategy ) { this . @ delegate = @ delegate ; this . maxTokenCount = maxTokenCount ; this . consumeAllTokens = consumeAllTokens ; }
public ExternalBookBlock ( int numberOfSheets ) { _externalBookRecord = SupBookRecord . CreateInternalReferences ( ( short ) numberOfSheets ) ; _externalNameRecords = new ExternalNameRecord [ 0 ] ; _crnBlocks = new CRNBlock [ 0 ] ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ SCENARIOPROTECT ] \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . protect ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( Protect ) . Append ( " \ n " ) ; buffer . Append ( " [ / SCENARIOPROTECT ] \ n " ) ; return buffer . ToString ( ) ; }
public virtual NGit . Api . PushCommand SetThin ( bool thin ) { CheckCallable ( ) ; this . thin = thin ; return this ; }
public int CompareTo ( SearcherTracker other ) { return other . RecordTimeSec . CompareTo ( RecordTimeSec ) ; }
public override TokenStream Create ( TokenStream input ) { return new ReverseStringFilter ( m_luceneMatchVersion , input ) ; }
public BlockList ( ) { directory = NGit . Util . BlockList < T > . NewDirectory ( 256 ) ; directory [ 0 ] = NGit . Util . BlockList < T > . NewBlock ( ) ; tailBlock = directory [ 0 ] ; }
public QueryScorer ( WeightedSpanTerm [ ] weightedTerms ) { this . fieldWeightedSpanTerms = new JCG . Dictionary < string , WeightedSpanTerm > ( weightedTerms . Length ) ; foreach ( WeightedSpanTerm t in weightedTerms ) { if ( ! fieldWeightedSpanTerms . TryGetValue ( t . Term , out WeightedSpanTerm existingTerm ) || ( existingTerm == null ) || ( existingTerm . Weight < t . Weight ) ) { fieldWeightedSpanTerms [ t . Term ] = t ; maxTermWeight = Math . Max ( maxTermWeight , t . Weight ) ; } } skipInitExtractor = true ; }
public override bool Equals ( object other ) { Debug . Assert ( NeverEquals ( other ) ) ; if ( other is MergedGroup < T > otherMergedGroup ) { if ( groupValue == null ) { return otherMergedGroup == null ; } else { return groupValueIsValueType ? JCG . EqualityComparer < T > . Default . Equals ( groupValue , otherMergedGroup . groupValue ) : J2N . Collections . StructuralEqualityComparer . Default . Equals ( groupValue , otherMergedGroup . groupValue ) ; } } else { return false ; } }
public java . nio . charset . Charset charset ( ) { return cs ; }
public virtual DescribeExperimentResponse DescribeExperiment ( DescribeExperimentRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeExperimentRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeExperimentResponseUnmarshaller . Instance ; return Invoke < DescribeExperimentResponse > ( request , options ) ; }
public EscherGraphics ( HSSFShapeGroup escherGroup , HSSFWorkbook workbook , Color forecolor , float verticalPointsPerPixel ) { this . escherGroup = escherGroup ; this . workbook = workbook ; this . verticalPointsPerPixel = verticalPointsPerPixel ; this . verticalPixelsPerPoint = 1 / verticalPointsPerPixel ; this . font = new Font ( " Arial " , 10 ) ; this . foreground = forecolor ; }
public virtual string Pattern ( ) { return patternText ; }
public virtual DeleteRouteTableResponse DeleteRouteTable ( DeleteRouteTableRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteRouteTableRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteRouteTableResponseUnmarshaller . Instance ; return Invoke < DeleteRouteTableResponse > ( request , options ) ; }
public virtual AssociateVPCWithHostedZoneResponse AssociateVPCWithHostedZone ( AssociateVPCWithHostedZoneRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AssociateVPCWithHostedZoneRequestMarshaller . Instance ; options . ResponseUnmarshaller = AssociateVPCWithHostedZoneResponseUnmarshaller . Instance ; return Invoke < AssociateVPCWithHostedZoneResponse > ( request , options ) ; }
public virtual PutIntegrationResponse PutIntegration ( PutIntegrationRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = PutIntegrationRequestMarshaller . Instance ; options . ResponseUnmarshaller = PutIntegrationResponseUnmarshaller . Instance ; return Invoke < PutIntegrationResponse > ( request , options ) ; }
public SimpleEntry ( K theKey , V theValue ) { key = theKey ; value = theValue ; }
public override void Decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { int byte0 = blocks [ blocksOffset ++ ] & 0xFF ; int byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 4 ) | ( ( int ) ( ( uint ) byte1 >> 4 ) ) ; int byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 15 ) << 8 ) | byte2 ; } }
public virtual DisassociateConnectionFromLagResponse DisassociateConnectionFromLag ( DisassociateConnectionFromLagRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DisassociateConnectionFromLagRequestMarshaller . Instance ; options . ResponseUnmarshaller = DisassociateConnectionFromLagResponseUnmarshaller . Instance ; return Invoke < DisassociateConnectionFromLagResponse > ( request , options ) ; }
public virtual FileMode GetOldMode ( ) { return oldMode ; }
public override string ToString ( ) { return mapEntry . ToString ( ) ; }
public virtual StopKeyPhrasesDetectionJobResponse StopKeyPhrasesDetectionJob ( StopKeyPhrasesDetectionJobRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = StopKeyPhrasesDetectionJobRequestMarshaller . Instance ; options . ResponseUnmarshaller = StopKeyPhrasesDetectionJobResponseUnmarshaller . Instance ; return Invoke < StopKeyPhrasesDetectionJobResponse > ( request , options ) ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( " [ Array ▁ Formula ▁ or ▁ Shared ▁ Formula ] \ n " ) ; buffer . Append ( " row ▁ = ▁ " ) . Append ( Row ) . Append ( " \ n " ) ; buffer . Append ( " col ▁ = ▁ " ) . Append ( Column ) . Append ( " \ n " ) ; return buffer . ToString ( ) ; }
public virtual ListDominantLanguageDetectionJobsResponse ListDominantLanguageDetectionJobs ( ListDominantLanguageDetectionJobsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListDominantLanguageDetectionJobsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListDominantLanguageDetectionJobsResponseUnmarshaller . Instance ; return Invoke < ListDominantLanguageDetectionJobsResponse > ( request , options ) ; }
public override string ToString ( ) { return " slice ▁ start = " + Start + " ▁ length = " + Length + " ▁ readerIndex = " + ReaderIndex ; }
public static int ParseHexInt4 ( byte digit ) { sbyte r = digits16 [ digit ] ; if ( r < 0 ) { throw new IndexOutOfRangeException ( ) ; } return r ; }
public Attribute ( string name , string value ) { _name = name ; _value = value ; }
public virtual DescribeStackSetOperationResponse DescribeStackSetOperation ( DescribeStackSetOperationRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeStackSetOperationRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeStackSetOperationResponseUnmarshaller . Instance ; return Invoke < DescribeStackSetOperationResponse > ( request , options ) ; }
public ICell GetCell ( short cellnum ) { int ushortCellNum = cellnum & 0x0000FFFF ; return GetCell ( ushortCellNum ) ; }
public void Write ( byte [ ] b ) { WriteContinueIfRequired ( b . Length ) ; _ulrOutput . Write ( b ) ; }
public ResetImageAttributeRequest ( string imageId , ResetImageAttributeName attribute ) { _imageId = imageId ; _attribute = attribute ; }
public virtual void DiscardResultContents ( ) { resultContents = null ; }
public virtual ObjectId GetPeeledObjectId ( ) { return GetLeaf ( ) . GetPeeledObjectId ( ) ; }
public virtual UndeprecateDomainResponse UndeprecateDomain ( UndeprecateDomainRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UndeprecateDomainRequestMarshaller . Instance ; options . ResponseUnmarshaller = UndeprecateDomainResponseUnmarshaller . Instance ; return Invoke < UndeprecateDomainResponse > ( request , options ) ; }
public override void Write ( ILittleEndianOutput out1 ) { out1. WriteByte ( sid + PtgClass ) ; out1. WriteByte ( field_3_string . Length ) ; out1. WriteByte ( _is16bitUnicode ? 0x01 : 0x00 ) ; if ( _is16bitUnicode ) { StringUtil . PutUnicodeLE ( field_3_string , out1 ) ; } else { StringUtil . PutCompressedUnicode ( field_3_string , out1 ) ; } }
public virtual DeleteQueueResponse DeleteQueue ( string queueUrl ) { var request = new DeleteQueueRequest ( ) ; request . QueueUrl = queueUrl ; return DeleteQueue ( request ) ; }
public virtual void SetCheckEofAfterPackFooter ( bool b ) { checkEofAfterPackFooter = b ; }
public virtual void Swap ( ) { int sBegin = beginA ; int sEnd = endA ; beginA = beginB ; endA = endB ; beginB = sBegin ; endB = sEnd ; }
public virtual int GetPackedGitWindowSize ( ) { return packedGitWindowSize ; }
public virtual PutMetricDataResponse PutMetricData ( PutMetricDataRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = PutMetricDataRequestMarshaller . Instance ; options . ResponseUnmarshaller = PutMetricDataResponseUnmarshaller . Instance ; return Invoke < PutMetricDataResponse > ( request , options ) ; }
public virtual GetCelebrityRecognitionResponse GetCelebrityRecognition ( GetCelebrityRecognitionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetCelebrityRecognitionRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetCelebrityRecognitionResponseUnmarshaller . Instance ; return Invoke < GetCelebrityRecognitionResponse > ( request , options ) ; }
public CreateQueueRequest ( string queueName ) { _queueName = queueName ; }
public Area3DPxg ( int externalWorkbookNumber , SheetIdentifier sheetName , AreaReference arearef ) : base ( arearef ) { this . externalWorkbookNumber = externalWorkbookNumber ; this . firstSheetName = sheetName . SheetId . Name ; if ( sheetName is SheetRangeIdentifier ) { this . lastSheetName = ( ( SheetRangeIdentifier ) sheetName ) . LastSheetIdentifier . Name ; } else { this . lastSheetName = null ; } }
public virtual void SetBaseline ( long clockTime ) { t0 = clockTime ; timeout = t0 + ticksAllowed ; }
public virtual MoveAddressToVpcResponse MoveAddressToVpc ( MoveAddressToVpcRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = MoveAddressToVpcRequestMarshaller . Instance ; options . ResponseUnmarshaller = MoveAddressToVpcResponseUnmarshaller . Instance ; return Invoke < MoveAddressToVpcResponse > ( request , options ) ; }
public override string ToString ( ) { string coll = m_collectionModel . GetName ( ) ; if ( coll != null ) { return string . Format ( " LM ▁ { 0 } ▁ - ▁ { 1 } " , GetName ( ) , coll ) ; } else { return string . Format ( " LM ▁ { 0 } " , GetName ( ) ) ; } }
public virtual DescribeLagsResponse DescribeLags ( DescribeLagsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeLagsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeLagsResponseUnmarshaller . Instance ; return Invoke < DescribeLagsResponse > ( request , options ) ; }
public AreaEval Offset ( int relFirstRowIx , int relLastRowIx , int relFirstColIx , int relLastColIx ) { if ( _refEval == null ) { return _areaEval . Offset ( relFirstRowIx , relLastRowIx , relFirstColIx , relLastColIx ) ; } return _refEval . Offset ( relFirstRowIx , relLastRowIx , relFirstColIx , relLastColIx ) ; }
public override java . nio . ShortBuffer put ( short [ ] src , int srcOffset , int shortCount ) { byteBuffer . limit ( _limit * libcore . io . SizeOf . SHORT ) ; byteBuffer . position ( _position * libcore . io . SizeOf . SHORT ) ; if ( byteBuffer is java . nio . ReadWriteDirectByteBuffer ) { ( ( java . nio . ReadWriteDirectByteBuffer ) byteBuffer ) . put ( src , srcOffset , shortCount ) ; } else { ( ( java . nio . ReadWriteHeapByteBuffer ) byteBuffer ) . put ( src , srcOffset , shortCount ) ; } this . _position += shortCount ; return this ; }
public override void Initialize ( String cat ) { this . _cat = cat ; }
public override void write ( int oneByte ) { throw new System . NotImplementedException ( ) ; }
public virtual DescribeImportImageTasksResponse DescribeImportImageTasks ( DescribeImportImageTasksRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeImportImageTasksRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeImportImageTasksResponseUnmarshaller . Instance ; return Invoke < DescribeImportImageTasksResponse > ( request , options ) ; }
public ColumnInfoRecord ( RecordInputStream in1 ) { _first_col = in1. ReadUShort ( ) ; _last_col = in1. ReadUShort ( ) ; _col_width = in1. ReadUShort ( ) ; _xf_index = in1. ReadUShort ( ) ; _options = in1. ReadUShort ( ) ; switch ( in1. Remaining ) { case 2 : field_6_reserved = in1. ReadUShort ( ) ; break ; case 1 : field_6_reserved = in1. ReadByte ( ) ; break ; case 0 : field_6_reserved = 0 ; break ; default : throw new Exception ( " Unusual ▁ record ▁ size ▁ remaining = ( " + in1. Remaining + " ) " ) ; } }
public Status ( IndexDiff diff ) : base ( ) { this . diff = diff ; clean = diff . GetAdded ( ) . IsEmpty ( ) && diff . GetChanged ( ) . IsEmpty ( ) && diff . GetRemoved ( ) . IsEmpty ( ) && diff . GetMissing ( ) . IsEmpty ( ) && diff . GetModified ( ) . IsEmpty ( ) && diff . GetUntracked ( ) . IsEmpty ( ) && diff . GetConflicting ( ) . IsEmpty ( ) ; }
public virtual CreateExperimentResponse CreateExperiment ( CreateExperimentRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateExperimentRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateExperimentResponseUnmarshaller . Instance ; return Invoke < CreateExperimentResponse > ( request , options ) ; }
public override Object Clone ( ) { return this ; }
public override java . nio . FloatBuffer slice ( ) { byteBuffer . limit ( _limit * libcore . io . SizeOf . FLOAT ) ; byteBuffer . position ( _position * libcore . io . SizeOf . FLOAT ) ; java . nio . ByteBuffer bb = byteBuffer . slice ( ) . order ( byteBuffer . order ( ) ) ; java . nio . FloatBuffer result = new java . nio . FloatToByteBufferAdapter ( bb ) ; byteBuffer . clear ( ) ; return result ; }
public virtual DescribeSnapshotSchedulesResponse DescribeSnapshotSchedules ( DescribeSnapshotSchedulesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeSnapshotSchedulesRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeSnapshotSchedulesResponseUnmarshaller . Instance ; return Invoke < DescribeSnapshotSchedulesResponse > ( request , options ) ; }
public virtual ListImagesResponse ListImages ( ListImagesRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListImagesRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListImagesResponseUnmarshaller . Instance ; return Invoke < ListImagesResponse > ( request , options ) ; }
public Diff ( int ins , int del , int rep , int noop ) { INSERT = ins ; DELETE = del ; REPLACE = rep ; NOOP = noop ; }
public override String ToFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( operands [ 0 ] ) ; buffer . Append ( " , " ) ; buffer . Append ( operands [ 1 ] ) ; return buffer . ToString ( ) ; }
public static void SetupEnvironment ( String [ ] workbookNames , ForkedEvaluator [ ] Evaluators ) { WorkbookEvaluator [ ] wbEvals = new WorkbookEvaluator [ Evaluators . Length ] ; for ( int i = 0 ; i < wbEvals . Length ; i ++ ) { wbEvals [ i ] = Evaluators [ i ] . _evaluator ; } CollaboratingWorkbooksEnvironment . Setup ( workbookNames , wbEvals ) ; }
public ListPhotoTagsRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListPhotoTags " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public RandomSamplingFacetsCollector ( int sampleSize , long seed ) : base ( false ) { this . sampleSize = sampleSize ; this . random = new XORShift64Random ( seed ) ; this . sampledDocs = null ; }
public virtual AllocateStaticIpResponse AllocateStaticIp ( AllocateStaticIpRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AllocateStaticIpRequestMarshaller . Instance ; options . ResponseUnmarshaller = AllocateStaticIpResponseUnmarshaller . Instance ; return Invoke < AllocateStaticIpResponse > ( request , options ) ; }
public FeatRecord ( RecordInputStream in1 ) { futureHeader = new FtrHeader ( in1 ) ; isf_sharedFeatureType = in1. ReadShort ( ) ; reserved1 = ( byte ) in1. ReadByte ( ) ; reserved2 = in1. ReadInt ( ) ; int cref = in1. ReadUShort ( ) ; cbFeatData = in1. ReadInt ( ) ; reserved3 = in1. ReadShort ( ) ; cellRefs = new CellRangeAddress [ cref ] ; for ( int i = 0 ; i < cellRefs . Length ; i ++ ) { cellRefs [ i ] = new CellRangeAddress ( in1 ) ; } switch ( isf_sharedFeatureType ) { case FeatHdrRecord . SHAREDFEATURES_ISFPROTECTION : sharedFeature = new FeatProtection ( in1 ) ; break ; case FeatHdrRecord . SHAREDFEATURES_ISFFEC2 : sharedFeature = new FeatFormulaErr2 ( in1 ) ; break ; case FeatHdrRecord . SHAREDFEATURES_ISFFACTOID : sharedFeature = new FeatSmartTag ( in1 ) ; break ; default : logger . Log ( POILogger . ERROR , " Unknown ▁ Shared ▁ Feature ▁ " + isf_sharedFeatureType + " ▁ found ! " ) ; break ; } }
public virtual RevCommit TryFastForward ( RevCommit newCommit ) { Ref head = repo . GetRef ( Constants . HEAD ) ; if ( head == null || head . GetObjectId ( ) == null ) { throw new RefNotFoundException ( MessageFormat . Format ( JGitText . Get ( ) . refNotResolved , Constants . HEAD ) ) ; } ObjectId headId = head . GetObjectId ( ) ; if ( headId == null ) { throw new RefNotFoundException ( MessageFormat . Format ( JGitText . Get ( ) . refNotResolved , Constants . HEAD ) ) ; } RevCommit headCommit = walk . LookupCommit ( headId ) ; if ( walk . IsMergedInto ( newCommit , headCommit ) ) { return newCommit ; } string headName ; if ( head . IsSymbolic ( ) ) { headName = head . GetTarget ( ) . GetName ( ) ; } else { headName = " detached ▁ HEAD " ; } return TryFastForward ( headName , headCommit , newCommit ) ; }
public virtual CreateSnapshotScheduleResponse CreateSnapshotSchedule ( CreateSnapshotScheduleRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateSnapshotScheduleRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateSnapshotScheduleResponseUnmarshaller . Instance ; return Invoke < CreateSnapshotScheduleResponse > ( request , options ) ; }
public Record GetNext ( ) { if ( _nextIndex >= _list . Count ) { throw new Exception ( " Attempt ▁ to ▁ Read ▁ past ▁ end ▁ of ▁ record ▁ stream " ) ; } _countRead ++ ; return ( Record ) _list [ _nextIndex ++ ] ; }
public override string ToString ( ) { return RawParseUtils . Decode ( buf . ToByteArray ( ) ) ; }
public ListTablesRequest ( string exclusiveStartTableName ) { _exclusiveStartTableName = exclusiveStartTableName ; }
public virtual EnableAlarmActionsResponse EnableAlarmActions ( EnableAlarmActionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = EnableAlarmActionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = EnableAlarmActionsResponseUnmarshaller . Instance ; return Invoke < EnableAlarmActionsResponse > ( request , options ) ; }
public Builder ( ) : base ( ) { lastDocID = - 1 ; wordNum = - 1 ; word = 0 ; }
public override bool Equals ( object obj ) { State other = ( State ) obj ; return is_final == other . is_final && Arrays . Equals ( this . labels , other . labels ) && ReferenceEquals ( this . states , other . states ) ; }
public override TokenStream Create ( TokenStream input ) { return new EnglishPossessiveFilter ( m_luceneMatchVersion , input ) ; }
public void ClearFormatting ( ) { _string = CloneStringIfRequired ( ) ; _string . ClearFormatting ( ) ; AddToSSTIfRequired ( ) ; }
public override int Get ( int index , long [ ] arr , int off , int len ) { Debug . Assert ( len > 0 , " len ▁ must ▁ be ▁ > ▁ 0 ▁ ( got ▁ " + len + " ) " ) ; Debug . Assert ( index >= 0 && index < valueCount ) ; len = Math . Min ( len , valueCount - index ) ; Arrays . Fill ( arr , off , off + len , 0 ) ; return len ; }
public virtual DeleteRouteResponseResponse DeleteRouteResponse ( DeleteRouteResponseRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteRouteResponseRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteRouteResponseResponseUnmarshaller . Instance ; return Invoke < DeleteRouteResponseResponse > ( request , options ) ; }
public virtual string ToPrivateString ( ) { return Format ( true , false ) ; }
public virtual CreatePresignedDomainUrlResponse CreatePresignedDomainUrl ( CreatePresignedDomainUrlRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreatePresignedDomainUrlRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreatePresignedDomainUrlResponseUnmarshaller . Instance ; return Invoke < CreatePresignedDomainUrlResponse > ( request , options ) ; }
public override void write ( int oneChar ) { doWrite ( new char [ ] { ( char ) oneChar } , 0 , 1 ) ; }
public SSTRecord GetSSTRecord ( ) { return sstRecord ; }
public override string ToString ( ) { return " term = " + term + " , field = " + field + " , value = " + value ; }
public override bool IsSaturated ( FuzzySet bloomFilter , FieldInfo fieldInfo ) { return bloomFilter . GetSaturation ( ) > 0.9f ; }
public Builder ( bool ignoreCase ) { this . ignoreCase = ignoreCase ; }
public override string ToString ( ) { return GetType ( ) . Name + " ( maxBasicQueries : ▁ " + maxBasicQueries + " , ▁ queriesMade : ▁ " + queriesMade + " ) " ; }
public virtual DeleteDataSourceResponse DeleteDataSource ( DeleteDataSourceRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteDataSourceRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteDataSourceResponseUnmarshaller . Instance ; return Invoke < DeleteDataSourceResponse > ( request , options ) ; }
public virtual RebootNodeResponse RebootNode ( RebootNodeRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = RebootNodeRequestMarshaller . Instance ; options . ResponseUnmarshaller = RebootNodeResponseUnmarshaller . Instance ; return Invoke < RebootNodeResponse > ( request , options ) ; }
public void ProcessChildRecords ( ) { ConvertRawBytesToEscherRecords ( ) ; }
public virtual CreateOrUpdateTagsResponse CreateOrUpdateTags ( CreateOrUpdateTagsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateOrUpdateTagsRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateOrUpdateTagsResponseUnmarshaller . Instance ; return Invoke < CreateOrUpdateTagsResponse > ( request , options ) ; }
public FileSnapshot GetSnapShot ( ) { return snapShot ; }
public Stream OpenResource ( string resource ) { Stream stream = this . clazz . GetTypeInfo ( ) . Assembly . FindAndGetManifestResourceStream ( clazz , resource ) ; if ( stream == null ) { throw new IOException ( " Resource ▁ not ▁ found : ▁ " + resource ) ; } return stream ; }
public override String ToString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . Append ( GetType ( ) . Name ) . Append ( " ▁ [ " ) ; sb . Append ( " sid = " ) . Append ( HexDump . ShortToHex ( _sid ) ) ; sb . Append ( " ▁ size = " ) . Append ( _data . Length ) ; sb . Append ( " ▁ : ▁ " ) . Append ( HexDump . ToHex ( _data ) ) ; sb . Append ( " ] \ n " ) ; return sb . ToString ( ) ; }
public virtual int nextIndex ( ) { return index ; }
public override string ToQueryString ( IEscapeQuerySyntax escaper ) { if ( IsDefaultField ( this . m_field ) ) { return " \ " " + GetTermEscapeQuoted ( escaper ) + " \ " " ; } else { return this . m_field + " : " + " \ " " + GetTermEscapeQuoted ( escaper ) + " \ " " ; } }
public override Object Clone ( ) { CalcModeRecord rec = new CalcModeRecord ( ) ; rec . field_1_calcmode = field_1_calcmode ; return rec ; }
public virtual bool IsOutput ( ) { return output ; }
public virtual CreateNetworkInterfaceResponse CreateNetworkInterface ( CreateNetworkInterfaceRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateNetworkInterfaceRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateNetworkInterfaceResponseUnmarshaller . Instance ; return Invoke < CreateNetworkInterfaceResponse > ( request , options ) ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( field_1_password ) ; }
public virtual StopDominantLanguageDetectionJobResponse StopDominantLanguageDetectionJob ( StopDominantLanguageDetectionJobRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = StopDominantLanguageDetectionJobRequestMarshaller . Instance ; options . ResponseUnmarshaller = StopDominantLanguageDetectionJobResponseUnmarshaller . Instance ; return Invoke < StopDominantLanguageDetectionJobResponse > ( request , options ) ; }
public void WithConnectionTimeout ( int milliseconds ) { connectionTimeoutInMilliseconds = milliseconds ; }
public virtual GetGatewayGroupResponse GetGatewayGroup ( GetGatewayGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetGatewayGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetGatewayGroupResponseUnmarshaller . Instance ; return Invoke < GetGatewayGroupResponse > ( request , options ) ; }
public override java . nio . FloatBuffer slice ( ) { return new java . nio . ReadOnlyFloatArrayBuffer ( remaining ( ) , backingArray , offset + _position ) ; }
public static string Join ( ICollection < string > parts , string separator , string lastSeparator ) { StringBuilder sb = new StringBuilder ( ) ; int i = 0 ; int lastIndex = parts . Count - 1 ; foreach ( string part in parts ) { sb . Append ( part ) ; if ( i == lastIndex - 1 ) { sb . Append ( lastSeparator ) ; } else { if ( i != lastIndex ) { sb . Append ( separator ) ; } } i ++ ; } return sb . ToString ( ) ; }
public override string ToString ( ) { return " ( " + a . ToString ( ) + " ▁ AND ▁ " + b . ToString ( ) + " ) " ; }
public ListSubscriptionsByTopicRequest ( string topicArn , string nextToken ) { _topicArn = topicArn ; _nextToken = nextToken ; }
public override byte ReadByte ( ) { return bytes [ pos -- ] ; }
public virtual TerminateClientVpnConnectionsResponse TerminateClientVpnConnections ( TerminateClientVpnConnectionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = TerminateClientVpnConnectionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = TerminateClientVpnConnectionsResponseUnmarshaller . Instance ; return Invoke < TerminateClientVpnConnectionsResponse > ( request , options ) ; }
public ReceiveMessageRequest ( string queueUrl ) { _queueUrl = queueUrl ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( field_1_barSpace ) ; out1. WriteShort ( field_2_categorySpace ) ; out1. WriteShort ( field_3_formatFlags ) ; }
public override object Common ( object output1 , object output2 ) { return outputs . Common ( ( T ) output1 , ( T ) output2 ) ; }
public virtual CreateVariableResponse CreateVariable ( CreateVariableRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateVariableRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateVariableResponseUnmarshaller . Instance ; return Invoke < CreateVariableResponse > ( request , options ) ; }
public static int Match ( byte [ ] b , int ptr , byte [ ] src ) { if ( ptr + src . Length > b . Length ) { return - 1 ; } for ( int i = 0 ; i < src . Length ; i ++ , ptr ++ ) { if ( b [ ptr ] != src [ i ] ) { return - 1 ; } } return ptr ; }
public override int FillFields ( byte [ ] data , int offset , IEscherRecordFactory recordFactory ) { int bytesRemaining = ReadHeader ( data , offset ) ; int pos = offset + 8 ; int size = 0 ; field_1_rectX1 = LittleEndian . GetInt ( data , pos + size ) ; size += 4 ; field_2_rectY1 = LittleEndian . GetInt ( data , pos + size ) ; size += 4 ; field_3_rectX2 = LittleEndian . GetInt ( data , pos + size ) ; size += 4 ; field_4_rectY2 = LittleEndian . GetInt ( data , pos + size ) ; size += 4 ; bytesRemaining -= size ; if ( bytesRemaining != 0 ) throw new RecordFormatException ( " Expected ▁ no ▁ remaining ▁ bytes ▁ but ▁ got ▁ " + bytesRemaining ) ; return 8 + size + bytesRemaining ; }
public virtual CreateCloudFrontOriginAccessIdentityResponse CreateCloudFrontOriginAccessIdentity ( CreateCloudFrontOriginAccessIdentityRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateCloudFrontOriginAccessIdentityRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateCloudFrontOriginAccessIdentityResponseUnmarshaller . Instance ; return Invoke < CreateCloudFrontOriginAccessIdentityResponse > ( request , options ) ; }
public virtual bool isNamespaceAware ( ) { return getFeature ( org . xmlpull . v1. XmlPullParserClass . FEATURE_PROCESS_NAMESPACES ) ; }
public virtual void SetOverridable ( bool on ) { overridable = on ; }
public virtual string getClassName ( ) { return className ; }
public virtual DirectoryReader GetIndexReader ( ) { lock ( this ) { if ( indexReader != null ) { indexReader . IncRef ( ) ; } return indexReader ; } }
public virtual int indexOfKey ( int key ) { return binarySearch ( mKeys , 0 , mSize , key ) ; }
public BlankRecord ( RecordInputStream in1 ) { field_1_row = in1. ReadUShort ( ) ; field_2_col = in1. ReadShort ( ) ; field_3_xf = in1. ReadShort ( ) ; }
public override long length ( ) { return length_Renamed ; }
public PasswordRecord ( RecordInputStream in1 ) { field_1_password = in1. ReadShort ( ) ; }
public HashMap ( int capacity , float loadFactor ) : this ( capacity ) { if ( loadFactor <= 0 || float . IsNaN ( loadFactor ) ) { throw new System . ArgumentException ( " Load ▁ factor : ▁ " + loadFactor ) ; } }
public override void Run ( ) { long lastReopenStartNS = DateTime . UtcNow . Ticks * 100 ; while ( ! finish ) { bool hasWaiting ; lock ( this ) hasWaiting = waitingGen > searchingGen ; long nextReopenStartNS = lastReopenStartNS + ( hasWaiting ? targetMinStaleNS : targetMaxStaleNS ) ; long sleepNS = nextReopenStartNS - Time . NanoTime ( ) ; if ( sleepNS > 0 ) try { reopenCond . WaitOne ( TimeSpan . FromMilliseconds ( sleepNS / Time . MILLISECONDS_PER_NANOSECOND ) ) ; } catch ( ThreadInterruptedException ie ) { Thread . CurrentThread . Interrupt ( ) ; return ; } if ( finish ) { break ; } lastReopenStartNS = Time . NanoTime ( ) ; refreshStartGen = writer . GetAndIncrementGeneration ( ) ; try { manager . MaybeRefreshBlocking ( ) ; } catch ( System . IO . IOException ioe ) { throw new Exception ( ioe . ToString ( ) , ioe ) ; } } RefreshDone ( ) ; }
public DeleteLoginProfileRequest ( string userName ) { _userName = userName ; }
public virtual E pollFirst ( ) { return ( _size == 0 ) ? default ( E ) : removeFirstImpl ( ) ; }
public CreatePhotoRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " CreatePhoto " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public override string GetName ( ) { return " resolve " ; }
public virtual int FindEndOffset ( StringBuilder buffer , int start ) { if ( start > buffer . Length || start < 0 ) return start ; int offset , count = m_maxScan ; for ( offset = start ; offset < buffer . Length && count > 0 ; count -- ) { if ( m_boundaryChars . Contains ( buffer [ offset ] ) ) return offset ; offset ++ ; } return start ; }
public virtual void SetObjectChecker ( ObjectChecker oc ) { objCheck = oc ; }
public BaseRef ( AreaEval ae ) { _refEval = null ; _areaEval = ae ; _firstRowIndex = ae . FirstRow ; _firstColumnIndex = ae . FirstColumn ; _height = ae . LastRow - ae . FirstRow + 1 ; _width = ae . LastColumn - ae . FirstColumn + 1 ; }
public virtual CreateVpcEndpointResponse CreateVpcEndpoint ( CreateVpcEndpointRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateVpcEndpointRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateVpcEndpointResponseUnmarshaller . Instance ; return Invoke < CreateVpcEndpointResponse > ( request , options ) ; }
public virtual DeregisterWorkspaceDirectoryResponse DeregisterWorkspaceDirectory ( DeregisterWorkspaceDirectoryRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeregisterWorkspaceDirectoryRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeregisterWorkspaceDirectoryResponseUnmarshaller . Instance ; return Invoke < DeregisterWorkspaceDirectoryResponse > ( request , options ) ; }
public ChartFRTInfoRecord ( RecordInputStream in1 ) { rt = in1. ReadShort ( ) ; grbitFrt = in1. ReadShort ( ) ; verOriginator = ( byte ) in1. ReadByte ( ) ; verWriter = ( byte ) in1. ReadByte ( ) ; int cCFRTID = in1. ReadShort ( ) ; rgCFRTID = new CFRTID [ cCFRTID ] ; for ( int i = 0 ; i < cCFRTID ; i ++ ) { rgCFRTID [ i ] = new CFRTID ( in1 ) ; } }
public override Merger NewMerger ( Repository db ) { return new StrategyOneSided . OneSide ( db , treeIndex ) ; }
public virtual CreateDataSourceFromRedshiftResponse CreateDataSourceFromRedshift ( CreateDataSourceFromRedshiftRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = CreateDataSourceFromRedshiftRequestMarshaller . Instance ; options . ResponseUnmarshaller = CreateDataSourceFromRedshiftResponseUnmarshaller . Instance ; return Invoke < CreateDataSourceFromRedshiftResponse > ( request , options ) ; }
public override void ClearDFA ( ) { for ( int d = 0 ; d < decisionToDFA . Length ; d ++ ) { decisionToDFA [ d ] = new DFA ( atn . GetDecisionState ( d ) , d ) ; } }
public void RemoveName ( String name ) { int index = GetNameIndex ( name ) ; RemoveName ( index ) ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ RightMargin ] \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . margin ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( " ▁ ( " ) . Append ( Margin ) . Append ( " ▁ ) \ n " ) ; buffer . Append ( " [ / RightMargin ] \ n " ) ; return buffer . ToString ( ) ; }
public override Object Clone ( ) { return new RefreshAllRecord ( _options ) ; }
public StandardQueryNodeProcessorPipeline ( QueryConfigHandler queryConfig ) : base ( queryConfig ) { Add ( new WildcardQueryNodeProcessor ( ) ) ; Add ( new MultiFieldQueryNodeProcessor ( ) ) ; Add ( new FuzzyQueryNodeProcessor ( ) ) ; Add ( new MatchAllDocsQueryNodeProcessor ( ) ) ; Add ( new OpenRangeQueryNodeProcessor ( ) ) ; Add ( new NumericQueryNodeProcessor ( ) ) ; Add ( new NumericRangeQueryNodeProcessor ( ) ) ; Add ( new LowercaseExpandedTermsQueryNodeProcessor ( ) ) ; Add ( new TermRangeQueryNodeProcessor ( ) ) ; Add ( new AllowLeadingWildcardProcessor ( ) ) ; Add ( new AnalyzerQueryNodeProcessor ( ) ) ; Add ( new PhraseSlopQueryNodeProcessor ( ) ) ; Add ( new BooleanQuery2ModifierNodeProcessor ( ) ) ; Add ( new NoChildOptimizationQueryNodeProcessor ( ) ) ; Add ( new RemoveDeletedQueryNodesProcessor ( ) ) ; Add ( new RemoveEmptyNonLeafQueryNodeProcessor ( ) ) ; Add ( new BooleanSingleChildOptimizationQueryNodeProcessor ( ) ) ; Add ( new DefaultPhraseSlopQueryNodeProcessor ( ) ) ; Add ( new BoostQueryNodeProcessor ( ) ) ; Add ( new MultiTermRewriteMethodProcessor ( ) ) ; }
public String FormatAsString ( String sheetName , bool useAbsoluteAddress ) { StringBuilder sb = new StringBuilder ( ) ; if ( sheetName != null ) { sb . Append ( SheetNameFormatter . Format ( sheetName ) ) ; sb . Append ( " ! " ) ; } CellReference cellRefFrom = new CellReference ( FirstRow , FirstColumn , useAbsoluteAddress , useAbsoluteAddress ) ; CellReference cellRefTo = new CellReference ( LastRow , LastColumn , useAbsoluteAddress , useAbsoluteAddress ) ; sb . Append ( cellRefFrom . FormatAsString ( ) ) ; if ( ! cellRefFrom . Equals ( cellRefTo ) || IsFullColumnRange || IsFullRowRange ) { sb . Append ( ' : ' ) ; sb . Append ( cellRefTo . FormatAsString ( ) ) ; } return sb . ToString ( ) ; }
public override java . nio . ByteBuffer put ( int index , byte value ) { throw new System . NotImplementedException ( ) ; }
public virtual void Mode ( int m ) { _mode = m ; }
public override java . nio . ShortBuffer slice ( ) { return new java . nio . ReadWriteShortArrayBuffer ( remaining ( ) , backingArray , offset + _position ) ; }
public virtual void Set ( int index , long n ) { if ( count < index ) { throw Sharpen . Extensions . CreateIndexOutOfRangeException ( index ) ; } else { if ( count == index ) { Add ( n ) ; } else { entries [ index ] = n ; } } }
public override java . nio . ByteBuffer putFloat ( float value ) { throw new java . nio . ReadOnlyBufferException ( ) ; }
public static double Max ( double [ ] values ) { double max = double . NegativeInfinity ; for ( int i = 0 , iSize = values . Length ; i < iSize ; i ++ ) { max = Math . Max ( max , values [ i ] ) ; } return max ; }
public UpdateRepoWebhookRequest ( ) : base ( " cr " , " 2016 - 06 - 07 " , " UpdateRepoWebhook " , " cr " , " openAPI " ) { UriPattern = " / repos / [ RepoNamespace ] / [ RepoName ] / webhooks / [ WebhookId ] " ; Method = MethodType . POST ; }
public DeleteAttributesRequest ( string domainName , string itemName , List < Attribute > attributes , UpdateCondition expected ) { _domainName = domainName ; _itemName = itemName ; _attributes = attributes ; _expected = expected ; }
public override string ToString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . Append ( " [ SXPI ] \ n " ) ; for ( int i = 0 ; i < _fieldInfos . Length ; i ++ ) { sb . Append ( " ▁ ▁ ▁ ▁ item [ " ) . Append ( i ) . Append ( " ] = " ) ; _fieldInfos [ i ] . AppendDebugInfo ( sb ) ; sb . Append ( ' \ n ' ) ; } sb . Append ( " [ / SXPI ] \ n " ) ; return sb . ToString ( ) ; }
public virtual bool IsSuccessful ( ) { if ( mergeResult != null ) { return mergeResult . GetMergeStatus ( ) . IsSuccessful ( ) ; } else { if ( rebaseResult != null ) { return rebaseResult . GetStatus ( ) . IsSuccessful ( ) ; } } return true ; }
public virtual void SetBytesValue ( byte [ ] value ) { SetBytesValue ( new BytesRef ( value ) ) ; }
public virtual DescribeConnectionsResponse DescribeConnections ( DescribeConnectionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeConnectionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeConnectionsResponseUnmarshaller . Instance ; return Invoke < DescribeConnectionsResponse > ( request , options ) ; }
public DeletePhotosRequest ( ) : base ( " CloudPhoto " , " 2017 - 07 - 11 " , " DeletePhotos " , " cloudphoto " , " openAPI " ) { Protocol = ProtocolType . HTTPS ; }
public void add ( E @ object ) { iterator . add ( @ object ) ; subList . sizeChanged ( true ) ; end ++ ; }
public static java . nio . ByteBuffer allocate ( int capacity_1 ) { if ( capacity_1 < 0 ) { throw new System . ArgumentException ( ) ; } return new java . nio . ReadWriteHeapByteBuffer ( capacity_1 ) ; }
public virtual SrndQuery GetSubQuery ( int qn ) { return m_queries [ qn ] ; }
public override float CurrentScore ( int docId , string field , int start , int end , int numPayloadsSeen , float currentScore , float currentPayloadScore ) { if ( numPayloadsSeen == 0 ) { return currentPayloadScore ; } else { return Math . Min ( currentPayloadScore , currentScore ) ; } }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ BLANK ] \ n " ) ; buffer . Append ( " row ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( HexDump . ShortToHex ( Row ) ) . Append ( " \ n " ) ; buffer . Append ( " col ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( HexDump . ShortToHex ( Column ) ) . Append ( " \ n " ) ; buffer . Append ( " xf ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( HexDump . ShortToHex ( XFIndex ) ) . Append ( " \ n " ) ; buffer . Append ( " [ / BLANK ] \ n " ) ; return buffer . ToString ( ) ; }
public virtual DescribeLogPatternResponse DescribeLogPattern ( DescribeLogPatternRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DescribeLogPatternRequestMarshaller . Instance ; options . ResponseUnmarshaller = DescribeLogPatternResponseUnmarshaller . Instance ; return Invoke < DescribeLogPatternResponse > ( request , options ) ; }
public virtual RegisterTransitGatewayMulticastGroupMembersResponse RegisterTransitGatewayMulticastGroupMembers ( RegisterTransitGatewayMulticastGroupMembersRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = RegisterTransitGatewayMulticastGroupMembersRequestMarshaller . Instance ; options . ResponseUnmarshaller = RegisterTransitGatewayMulticastGroupMembersResponseUnmarshaller . Instance ; return Invoke < RegisterTransitGatewayMulticastGroupMembersResponse > ( request , options ) ; }
public virtual GetPhoneNumberSettingsResponse GetPhoneNumberSettings ( GetPhoneNumberSettingsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetPhoneNumberSettingsRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetPhoneNumberSettingsResponseUnmarshaller . Instance ; return Invoke < GetPhoneNumberSettingsResponse > ( request , options ) ; }
public virtual ObjectId GetData ( ) { return data ; }
public override bool isDirect ( ) { return false ; }
public DeleteServerCertificateRequest ( string serverCertificateName ) { _serverCertificateName = serverCertificateName ; }
public java . lang . StringBuffer append ( bool b ) { return append ( b ? " true " : " false " ) ; }
public virtual GetEvaluationResponse GetEvaluation ( GetEvaluationRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetEvaluationRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetEvaluationResponseUnmarshaller . Instance ; return Invoke < GetEvaluationResponse > ( request , options ) ; }
public BRAIRecord GetDataName ( ) { return dataName ; }
public bool find ( int start_1 ) { findPos = start_1 ; if ( findPos < _regionStart ) { findPos = _regionStart ; } else { if ( findPos >= _regionEnd ) { matchFound = false ; return false ; } } matchFound = findImpl ( address , input , findPos , matchOffsets ) ; if ( matchFound ) { findPos = matchOffsets [ 1 ] ; } return matchFound ; }
public virtual GetLifecyclePolicyPreviewResponse GetLifecyclePolicyPreview ( GetLifecyclePolicyPreviewRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetLifecyclePolicyPreviewRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetLifecyclePolicyPreviewResponseUnmarshaller . Instance ; return Invoke < GetLifecyclePolicyPreviewResponse > ( request , options ) ; }
public SinglePositionTokenStream ( string word ) { termAtt = AddAttribute < ICharTermAttribute > ( ) ; posIncrAtt = AddAttribute < IPositionIncrementAttribute > ( ) ; this . word = word ; returned = true ; }
public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( field_1_print_gridlines ) ; }
public override string ToString ( ) { StringBuilder s = new StringBuilder ( ) ; s . Append ( Constants . TypeString ( Type ) ) ; s . Append ( ' ▁ ' ) ; s . Append ( Name ) ; s . Append ( ' ▁ ' ) ; s . Append ( commitTime ) ; s . Append ( ' ▁ ' ) ; AppendCoreFlags ( s ) ; return s . ToString ( ) ; }
public virtual NGit . Api . LsRemoteCommand SetRemote ( string remote ) { CheckCallable ( ) ; this . remote = remote ; return this ; }
public void CollapseRow ( int rowNumber ) { int startRow = FindStartOfRowOutlineGroup ( rowNumber ) ; RowRecord rowRecord = GetRow ( startRow ) ; int lastRow = WriteHidden ( rowRecord , startRow , true ) ; if ( GetRow ( lastRow + 1 ) != null ) { GetRow ( lastRow + 1 ) . Colapsed = ( true ) ; } else { RowRecord row = CreateRow ( lastRow + 1 ) ; row . Colapsed = ( true ) ; InsertRow ( row ) ; } }
public virtual AssociateSkillGroupWithRoomResponse AssociateSkillGroupWithRoom ( AssociateSkillGroupWithRoomRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AssociateSkillGroupWithRoomRequestMarshaller . Instance ; options . ResponseUnmarshaller = AssociateSkillGroupWithRoomResponseUnmarshaller . Instance ; return Invoke < AssociateSkillGroupWithRoomResponse > ( request , options ) ; }
public override String ToString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . Append ( " [ SERIESLIST ] \ n " ) ; buffer . Append ( " ▁ ▁ ▁ ▁ . seriesNumbers ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . Append ( " ▁ ( " ) . Append ( SeriesNumbers ) . Append ( " ▁ ) " ) ; buffer . Append ( Environment . NewLine ) ; buffer . Append ( " [ / SERIESLIST ] \ n " ) ; return buffer . ToString ( ) ; }
public virtual QueryConfigHandler GetQueryConfigHandler ( ) { return this . queryConfig ; }
public virtual string GetClassArg ( ) { if ( null != originalArgs ) { string className = originalArgs [ CLASS_NAME ] ; if ( null != className ) { return className ; } } return this . GetType ( ) . Name ; }
int changeEvenBits ( int n ) { int to_subtract = 0 ; int m = 0 ; for ( int x = n ; x > 0 ; x >>= 2 ) { if ( ( x & 1 ) > 0 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
bool checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
void FindPairs ( int n , int k ) { Console . Write ( 1 + " ▁ " + n + " STRNEWLINE " ) ; k -- ; for ( long i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { Console . Write ( 1 + " ▁ " + i + " STRNEWLINE " ) ; k -- ; if ( k == 0 ) break ; if ( i != n / i ) { Console . Write ( 1 + " ▁ " + n / i + " STRNEWLINE " ) ; k -- ; } if ( k == 0 ) break ; } } }
void decrypt ( String Str , int Start , int End ) { if ( Start > End ) { return ; } int mid = ( Start + End ) >> 1 ; Console . Write ( Str [ mid ] ) ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
bool prefixDivisble ( int n ) { int i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = n / 10 ; i ++ ; } return true ; }
int minimum_required_operations ( int [ ] arr , int n , int k ) { int answer = 0 ; long mod = 1000000007 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer = ( int ) ( answer % mod ) ; } } return answer ; }
void transpose ( int [ , ] A ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i , j ] ; A [ i , j ] = A [ j , i ] ; A [ j , i ] = temp ; } }
void checkFactors ( long N ) { long ev_count = 0 , od_count = 0 ; for ( long i = 1 ; i <= Math . Sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) Console . Write ( " Yes " + " STRNEWLINE " ) ; else Console . Write ( " No " + " STRNEWLINE " ) ; }
int findevenPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; }
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
int enneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; }
int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
void Main ( String [ ] args ) { int n = 8 ; int [ ] v = Findpermutation ( n ) ; for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( v [ i ] + " ▁ " ) ; } }
int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
int minTime ( int [ ] arr , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . Min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . Min ( incl , excl ) ; }
int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; }
int countPairs ( int [ ] arr , int n ) { int ans = 0 ; Dictionary < int , int > count = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . ContainsKey ( arr [ i ] ) ) { ans += count [ arr [ i ] ] ; count [ arr [ i ] ] = count [ arr [ i ] ] + 1 ; } else { count . Add ( arr [ i ] , 1 ) ; } } return ans ; }
double findRadius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . Sqrt ( a3 / 3.14 ) ; return r3 ; }
void BeattySequence ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { double ans = Math . Floor ( i * Math . Sqrt ( 2 ) ) ; Console . Write ( ans + " , ▁ " ) ; } }
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = ( int ) ( Math . Pow ( a , n ) + Math . Pow ( b , n ) ) ; double c = Math . Pow ( pow_sum , 1.0 / n ) ; int c_pow = ( int ) Math . Pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { Console . WriteLine ( " Count ▁ example ▁ found " ) ; return ; } } Console . WriteLine ( " No ▁ counter ▁ example ▁ within " + " ▁ given ▁ range ▁ and ▁ data " ) ; }
void freq ( int [ , ] ar , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i , j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } Console . WriteLine ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " + odd ) ; Console . WriteLine ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ " + even ) ; }
int findSum ( int [ ] arr , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = Math . Min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
int countSubStr ( char [ ] str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
int search ( int [ ] arr , int x ) { int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
void findPairs ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = Math . Abs ( arr [ i ] ) ; Array . Sort ( arr ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } Console . Write ( ans ) ; }
int possibleStrings ( int n , int r , int b , int g ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
void pairStar ( String input , int i ) { output = output + input [ i ] ; if ( i == input . Length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' * ' ; pairStar ( input , i + 1 ) ; }
int findLCMPrime ( int a , int b ) { if ( a == b ) { return a ; } return a * b ; }
long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
int get ( int x , int y , int z ) { if ( x > z ) return - 1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; }
bool checkForSorting ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { else return false ; } } return true ; }
void printModulus ( int X , int Y ) { int n = Math . Max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) Console . Write ( i + " ▁ " ) ; } }
int findMinLength ( int [ ] arr ) { int index = ( int ) arr . Length - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }
int countCon ( int [ ] ar , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
int largestNum ( int a , int b ) { return a * ( ( a / b ) > 0 ? 1 : 0 ) + b * ( ( b / a ) > 0 ? 1 : 0 ) ; }
long factorial ( int n ) { long M = 1000000007 ; long f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) return f ; }
void possibleToReach ( int x , int y , int z ) { if ( z < Math . Abs ( x ) + Math . Abs ( y ) || ( z - Math . Abs ( x ) - Math . Abs ( y ) ) % 2 == 1 ) { Console . Write ( " Not ▁ Possible " + " STRNEWLINE " ) ; } else Console . Write ( " Possible " + " STRNEWLINE " ) ; }
int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . Pow ( x , 2 ) * ( Math . Pow ( x , 2 * n ) - 1 ) ) / ( Math . Pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . Pow ( x , n ) * Math . Pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; }
void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; Console . Write ( A + " ▁ " + B ) ; }
int countStrings ( String s ) { int cnt = 0 ; for ( int i = 1 ; i < s . Length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
int findLargestString ( String s , int i , int r ) { if ( i == s . Length ) { if ( r == 0 ) return 0 ; else return INT_MIN ; } if ( v [ i , r ] == 1 ) return dp [ i , r ] ; v [ i , r ] = 1 ; dp [ i , r ] = Math . Max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i , r ] ; }
int productPairs ( int [ ] arr , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = int . MinValue ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . Max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
int getCount ( int [ ] arr , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
int minimumX ( int n , int k ) { int mini = int . MaxValue ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . Min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . Min ( num2 , mini ) ; } } return mini ; }
int NumberofTimes ( String str ) { int temporary_sum = 0 , count = 0 ; while ( str . Length > 1 ) { temporary_sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) temporary_sum += ( str [ i ] - '0' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
double ReuleauxArea ( double r ) { if ( r < 0 ) return - 1 ; double A = 0.70477 * 2 * Math . Pow ( r , 2 ) ; return A ; }
int findMinRooms ( string [ ] slots , int n , int m ) { int [ ] counts = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
void thirdLargest ( int [ ] arr , int arr_size ) { if ( arr_size < 3 ) { Console . Write ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = - int . MaxValue ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = - int . MaxValue ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; Console . Write ( " The ▁ third ▁ Largest ▁ " + " element ▁ is ▁ " + third ) ; }
bool isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
void printSeriesSum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += Math . Pow ( i , i - 1 ) ; } Console . Write ( sum + " STRNEWLINE " ) ; }
Boolean validQuadruple ( int [ ] arr , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
long hexadecagonalNum ( long n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
bool isDivisibleBy5 ( String str ) { int n = str . Length ; return ( ( ( str [ n - 1 ] - '0' ) == 0 ) || ( ( str [ n - 1 ] - '0' ) == 5 ) ) ; }
int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 1 ] = insert ; for ( int i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . Min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = Math . Min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
int numberSequence ( int n ) { int num = ( int ) ( Math . Pow ( 4 , n ) - Math . Pow ( 2 , n ) ) - 1 ; return num ; }
int findSubarrays ( int [ ] arr , int N , int K ) { return N - K + 1 ; }
void FindTrip ( int [ ] arr , int N ) { for ( int i = 1 ; i < N - 1 ; i ++ ) { int p = arr [ i - 1 ] ; int q = arr [ i ] ; int r = arr [ i + 1 ] ; if ( p < q && q > r ) { Console . WriteLine ( ( i - 1 ) + " ▁ " + ( i ) + " ▁ " + ( i + 1 ) ) ; return ; } } Console . WriteLine ( - 1 ) ; }
double polyapothem ( double n , double a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . Tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
String reverse ( char [ ] str , int len , int l , int r ) { if ( l < 0 r >= len l > r ) return " Invalid ▁ range ! " ; while ( l < r ) { char c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } return String . Join ( " " , str ) ; }
long divide ( long dividend , long divisor ) { long sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . Abs ( dividend ) ; divisor = Math . Abs ( divisor ) ; long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1L L << i ; } } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
int MinimumMoves ( int [ ] a , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
int subsequence ( int [ ] S , int [ ] T , int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; int mod = 1000000007 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = 1 ; for ( int j = 0 ; j <= m ; j ++ ) dp [ 0 , j ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] - dp [ i - 1 , j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i , j ] += dp [ i - 1 , j - 1 ] ; dp [ i , j ] += mod ; dp [ i , j ] %= mod ; } } return dp [ n , m ] ; }
int findMaxSum ( int [ ] arr , int n ) { int [ ] preSum = new int [ n ] ; int [ ] suffSum = new int [ n ] ; int ans = int . MinValue ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . Max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . Max ( ans , preSum [ i ] ) ; } return ans ; }
int minMoves ( List < int > arr ) { int N = arr . Count ; if ( N <= 2 ) return 0 ; int ans = Int32 . MaxValue ; for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . Abs ( i ) + Math . Abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( Math . Abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . Abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag != 0 ) ans = Math . Min ( ans , moves ) ; } } if ( ans == Int32 . MaxValue ) return - 1 ; return ans ; }
void length_of_chord ( double r , double x ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ chord " + " ▁ of ▁ the ▁ circle ▁ is ▁ " + 2 * r * Math . Sin ( x * ( 3.14 / 180 ) ) ) ; }
int max_min ( int [ ] a , int n ) { Array . Sort ( a ) ; return Math . Min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
void Permutation ( int n , int k ) { int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( p [ i ] + " ▁ " ) ; }
void countElement ( int [ ] A , int N , int [ ] B , int M , int K ) { int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int currentElement = B [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { int diff = Math . Abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } Console . Write ( cnt ) ; }
void findFreq ( String str , int N ) { int [ ] freq = new int [ 256 ] ; int max = 0 ; char charMax = '0' ; for ( int i = 0 ; i < N ; i ++ ) { char ch = str [ i ] ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; charMax = ch ; } Console . WriteLine ( charMax + " ▁ - > ▁ " + max ) ; } }
int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . Max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
void evenXorSubarray ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int XOR = 0 ; for ( int j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } Console . WriteLine ( ans ) ; }
int equilibrium ( int [ ] arr , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
int countSubStr ( String str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
void PrintBothArrays ( int [ ] a , int n ) { List < int > v1 = new List < int > ( ) ; List < int > v2 = new List < int > ( ) ; Dictionary < int , int > mpp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mpp . ContainsKey ( a [ i ] ) ) mpp [ a [ i ] ] = mpp [ a [ i ] ] + 1 ; else mpp [ a [ i ] ] = 1 ; if ( mpp [ a [ i ] ] == 1 ) v1 . Add ( a [ i ] ) ; else if ( mpp [ a [ i ] ] == 2 ) v2 . Add ( a [ i ] ) ; else { Console . WriteLine ( " Not ▁ possible " ) ; return ; } } v1 . Sort ( ) ; Console . WriteLine ( " Strictly ▁ increasing ▁ array ▁ is : " ) ; for ( int i = 0 ; i < v1 . Count ; i ++ ) Console . Write ( v1 [ i ] + " ▁ " ) ; v2 . Sort ( ) ; v2 . Reverse ( ) ; Console . WriteLine ( " STRNEWLINE Strictly ▁ decreasing ▁ array ▁ is : " ) ; for ( int i = 0 ; i < v2 . Count ; i ++ ) Console . Write ( v2 [ i ] + " ▁ " ) ; }
int findTrailingZeros ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; else { int ans = 0 ; n /= 2 ; while ( n != 0 ) { ans += n / 5 ; n /= 5 ; } return ans ; } }
bool checkWord ( char [ , ] board , String word , int index , int row , int col ) { if ( row < 0 || col < 0 || row >= board . GetLength ( 0 ) || col >= board . GetLength ( 1 ) ) return false ; if ( board [ row , col ] != word [ index ] ) return false ; else if ( index == word . Length - 1 ) return true ; char temp = board [ row , col ] ; board [ row , col ] = ' * ' ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row , col ] = temp ; return true ; } board [ row , col ] = temp ; return false ; }
void printRoots ( long a , long b , long c ) { Console . WriteLine ( "1 , ▁ " + c / ( a * 1.0 ) ) ; }
int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
double hexDiagonal ( float a ) { if ( a < 0 ) return - 1 ; double d = ( double ) 1.73 * a ; return d ; }
int countDigit ( long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; }
void printLastElement ( int [ ] arr , int N ) { bool leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } Console . Write ( arr [ head - 1 ] ) ; }
int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
void countFreq ( int [ ] arr , int n ) { Boolean [ ] visited = new Boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } Console . WriteLine ( arr [ i ] + " ▁ " + count ) ; } }
int calc_distance ( int [ ] A , int [ ] B , int n ) { int distance_traveled_A = 0 ; int distance_traveled_B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
int pairs ( int n ) { int [ , ] c = new int [ 10 , 10 ] ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp , i % 10 ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += c [ i , j ] * c [ j , i ] ; return ans ; }
int linearSearch ( int [ ] arr , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
int minOperations ( string str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ ( i ) ] != str [ ( i + 1 ) ] ) count ++ ; } return ( count + 1 ) / 2 ; }
int minOperation ( int [ ] arr ) { int minOp = int . MinValue ; int minNeg = 0 , maxPos = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return Math . Abs ( minNeg ) + maxPos ; }
int maxHamming ( int [ ] arr , int n ) { int [ ] brr = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = Math . Max ( maxHam , currHam ) ; } return maxHam ; }
int mod ( int a , int m ) { return ( a % m + m ) % m ; }
void check ( int [ ] arr , int N ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
void count ( int n , int k ) { long count = ( long ) ( Math . Pow ( 10 , k ) - Math . Pow ( 10 , k - 1 ) ) ; Console . Write ( count ) ; }
int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( ( n - 2 ) * 180 ) ; }
int countNumbers ( int N ) { return ( int ) ( Math . Pow ( 10 , N ) - Math . Pow ( 8 , N ) ) / 2 ; }
int countToMake0lternate ( string s ) { int result = 0 ; for ( int i = 0 ; i < ( s . Length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
String check ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Dictionary < int , int > hm = new Dictionary < int , int > ( ) ; int count = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( hm . ContainsKey ( ( arr [ j ] ) ) ) hm [ arr [ j ] ] ++ ; else hm . Add ( arr [ j ] , 1 ) ; if ( hm [ arr [ j ] ] == 1 ) count ++ ; if ( hm [ arr [ j ] ] == 2 ) count -- ; if ( count == 0 ) return " No " ; } } return " Yes " ; }
int findSubstringCount ( string str ) { int result = 0 ; int n = str . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( char ) ( str [ i ] + 1 ) == str [ i + 1 ] ) { result ++ ; while ( ( char ) ( str [ i ] + 1 ) == str [ i + 1 ] ) { i ++ ; } } } return result ; }
int countDigits ( int n ) { return ( int ) ( n * Math . Log10 ( 2 ) + 1 ) ; }
int findPeak ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } return 0 ; }
long countNumberOfStrings ( String s ) { int n = s . Length - 1 ; long count = ( long ) ( Math . Pow ( 2 , n ) ) ; return count ; }
int posOfRightMostSameBit ( int m , int n ) { int loopCounter = 1 ; while ( m > 0 n > 0 ) { Boolean a = m % 2 == 1 ; Boolean b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return - 1 ; }
int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }
bool pairExists ( int [ ] arr1 , int m , int [ ] arr2 , int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s . Contains ( arr2 [ j ] - arr1 [ i ] ) ) return true ; } s . Add ( arr1 [ i ] ) ; } return false ; }
int largest ( int [ ] arr , int n ) { return arr . Max ( ) ; }
int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
void findEquation ( int A , int B , int C ) { Console . Write ( " ( " + C + " ) " + " x ^ 2 ▁ + ( " + B + " ) x ▁ + ▁ ( " + A + " ) ▁ = ▁ 0" ) ; }
int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
int getM ( int n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
void subtract ( int [ ] [ ] A , int [ ] [ ] B , int [ , ] C ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { C [ i , j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } } }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + n - 3 ; }
double volumeRec ( double a , double b , double e , double h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
long findNthNumber ( long N ) { long result = 0 ; long p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = N / 9 ; p = p * 10 ; } return result ; }
int countSquares ( int n ) { return ( int ) ( Math . Pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
int lis ( int [ ] arr , int n ) { int [ ] lis = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
Boolean isPossible ( int [ ] a , int n ) { int cur = a [ 0 ] ; cur -- ; for ( int i = 1 ; i < n ; i ++ ) { int nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }
double circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; }
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
int getMin ( int [ ] arr , int n ) { int minVal = arr . Min ( ) ; return minVal ; }
int colMaxDiff ( int [ , ] mat ) { int max_diff = int . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 , i ] , min_val = mat [ 0 , i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = Math . Max ( max_val , mat [ j , i ] ) ; min_val = Math . Min ( min_val , mat [ j , i ] ) ; } max_diff = Math . Max ( max_diff , max_val - min_val ) ; } return max_diff ; }
int findSmallestNumK ( int n ) { int cummAnd = n ; int i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
double area ( double d1 , double a ) { double d2 = Math . Sqrt ( 4 * ( a * a ) - d1 * d1 ) ; double area = 0.5 * d1 * d2 ; return area ; }
int evenNumSubstring ( string str ) { int len = str . Length ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
void printChar ( String str , int n ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 1 ) { Console . Write ( str [ i ] ) ; } } }
bool isPossible ( int [ ] A , int [ ] B , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Array . Sort ( A ) ; Array . Sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
int getMinOps ( int [ ] arr ) { int ans = 0 ; for ( int i = 0 ; i < arr . Length - 1 ; i ++ ) { ans += Math . Max ( arr [ i ] - arr [ i + 1 ] , 0 ) ; } return ans ; }
double MinimumMail ( int n , int k , int x ) { double m = ( n - 1 ) + Math . Ceiling ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . Ceiling ( n * 1.0 / x ) * ( k - n ) ; return m ; }
bool can_empty ( int a , int b , int c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = Math . Min ( a , Math . Min ( b , c ) ) ; if ( m < ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
string removeDuplicatesFromString ( string string1 ) { int counter = 0 ; char [ ] str = string1 . ToCharArray ( ) ; int i = 0 ; int size = str . Length ; int x ; int length = 0 ; while ( i < size ) { x = str [ i ] - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = ( char ) ( ' a ' + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return ( new string ( str ) ) . Substring ( 0 , length ) ; }
long centeredDodecagonal ( long n ) { return 6 * n * ( n - 1 ) + 1 ; }
int summation ( int N ) { int co = ( N + 1 ) / 2 ; int ce = ( N ) / 2 ; int se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; int so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . Pow ( 10 , n - 1 ) ) ; }
long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
int countUnique ( int [ , ] mat , int n , int m ) { int [ ] rowsum = new int [ n ] ; int [ ] colsum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i , j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i , j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . Min ( x , Math . Min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
int center_octadecagon_num ( int n ) { return 9 * n * n - 9 * n + 1 ; }
long polynomialRollingHash ( String str ) { int p = 31 ; int m = ( int ) ( 1e9 + 9 ) ; long power_of_p = 1 ; long hash_val = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { hash_val = ( hash_val + ( str [ i ] - ' a ' + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
bool isFibbinaryNum ( int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) Math . Pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }
void maxPossibleSum ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } Console . WriteLine ( sum ) ; }
int maxWater ( int [ ] arr , int n ) { int left = 0 ; int right = n - 1 ; int l_max = 0 ; int r_max = 0 ; int result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += Math . Max ( 0 , r_max - arr [ right ] ) ; r_max = Math . Max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += Math . Max ( 0 , l_max - arr [ left ] ) ; l_max = Math . Max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
void maxArea ( int [ ] point_x , int [ ] point_y , int n , int length , int width ) { Array . Sort ( point_x ) ; Array . Sort ( point_y ) ; int dx = point_x [ 0 ] ; int dy = point_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = Math . Max ( dx , point_x [ i ] - point_x [ i - 1 ] ) ; dy = Math . Max ( dy , point_y [ i ] - point_y [ i - 1 ] ) ; } dx = Math . Max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) ; dy = Math . Max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) ; Console . WriteLine ( ( dx - 1 ) * ( dy - 1 ) ) ; }
double sumNodes ( int l ) { double leafNodeCount = Math . Pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; }
double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return Math . Sqrt ( r ) ; }
void Kroneckerproduct ( int [ , ] A , int [ , ] B ) { int [ , ] C = new int [ rowa * rowb , cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 , j + k + 1 ] = A [ i , j ] * B [ k , l ] ; Console . Write ( C [ i + l + 1 , j + k + 1 ] + " ▁ " ) ; } } Console . WriteLine ( ) ; } } }
bool Survives ( int n ) { for ( int i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= n / i ; } }
int countSwaps ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int max_frequency = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } max_frequency = Math . Max ( max_frequency , mp [ arr [ i ] ] ) ; } return n - max_frequency ; }
int maxLength ( int [ ] arr , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . Max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . Max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
bool isSubsetSum ( int [ ] set , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int No_of_cubes ( int N , int K ) { int No = 0 ; No = ( N - K + 1 ) ; No = ( int ) Math . Pow ( No , 3 ) ; return No ; }
void maxModProdSubarr ( int [ ] arr , int n , int M ) { int ans = 0 ; int length = n ; for ( int i = 0 ; i < n ; i ++ ) { int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } Console . WriteLine ( " Maximum ▁ subarray ▁ product ▁ is ▁ " + ans ) ; Console . WriteLine ( " Minimum ▁ length ▁ of ▁ the ▁ maximum ▁ " + " product ▁ subarray ▁ is ▁ " + length ) ; }
void printNSE ( int [ ] arr , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } Console . WriteLine ( arr [ i ] + " ▁ - - ▁ " + next ) ; } }
bool isPowerOfK ( int n , int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
float computeMaxValue ( float [ ] arr , int n ) { float ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { float val = Math . Max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = Math . Max ( ans , val ) ; } } return ans ; }
void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { double d = Math . Pow ( ( Math . Pow ( x2 - x1 , 2 ) + Math . Pow ( y2 - y1 , 2 ) + Math . Pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; Console . WriteLine ( " Distance ▁ is ▁ STRNEWLINE " + d ) ; return ; }
bool isLoeschian ( int n ) { for ( int x = 1 ; x <= Math . Sqrt ( n ) ; x ++ ) { for ( int y = 1 ; y <= Math . Sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
int countNegative ( int [ , ] M , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i , j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
float heightCalculate ( int H , int n , int m ) { float N = ( float ) ( n * 1.0 ) ; float M = ( float ) ( m * 1.0 ) ; float h = H * ( float ) Math . Sqrt ( N / ( N + M ) ) ; return h ; }
void Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( i * ( 7 * i - 5 ) / 2 ) ; Console . Write ( " ▁ " ) ; } }
int eulerian ( int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i , j ] = 1 ; else dp [ i , j ] = ( ( i - j ) * dp [ i - 1 , j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 , j ] ) ; } } } return dp [ n , m ] ; }
void findDecimal ( double [ ] arr , int N ) { int bit , power = 0 , result = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { bit = Math . Abs ( ( int ) Math . Floor ( arr [ i ] ) - ( int ) Math . Round ( arr [ i ] ) ) ; if ( bit != 0 ) result += ( int ) Math . Pow ( 2 , power ) ; power ++ ; } Console . WriteLine ( result ) ; }
int MatrixChainOrder ( int [ ] p , int n ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i , i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i , i + L ] = Math . Min ( dp [ i + 1 , i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i , i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 , n - 1 ] ; }
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
int findOccurrences ( string str1 , string substr1 ) { int counter = 0 ; for ( int i = 0 ; i < str1 . Length ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) { for ( int j = i + 1 ; j < str1 . Length ; j ++ ) { if ( str1 [ j ] == substr1 [ 1 ] ) { for ( int k = j + 1 ; k < str1 . Length ; k ++ ) { if ( str1 [ k ] == substr1 [ 2 ] ) counter ++ ; } } } } } return counter ; }
int lenOfLongSubarr ( int [ ] arr , int n ) { Dictionary < int , int > um = new Dictionary < int , int > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . ContainsKey ( sum ) ) um . Add ( sum , i ) ; if ( um . ContainsKey ( sum - 1 ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) c ; if ( Math . Floor ( z ) == Math . Ceiling ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . Max ( maxVal , x + y + ( int ) z ) ; } } return maxVal ; }
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] == 1 ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
bool isTwoAlter ( string s ) { for ( int i = 0 ; i < s . Length - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }
int count9s ( String number ) { int count = 0 ; int n = number . Length ; for ( int i = 0 ; i < n ; i ++ ) { int sum = number [ i ] - '0' ; if ( number [ i ] == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; }
void printDuplicates ( int [ ] arr , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { Console . Write ( arr [ i ] % n + " ▁ " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! ( fl > 0 ) ) Console . Write ( " - 1" ) ; }
int countSubsequences ( int [ ] arr , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) % 2 == 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; }
int getPairsCount ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . Abs ( i - j ) ) count ++ ; } } return count ; }
void answer ( int L , int R ) { if ( 2 * L <= R ) Console . WriteLine ( L + " , ▁ " + ( 2 * L ) ) ; else Console . WriteLine ( " - 1" ) ; }
void precompute ( string s , string K ) { int n = s . Length ; for ( int i = 0 ; i < n - 2 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] ; if ( s . Substring ( i , K . Length ) . Equals ( K ) ) { cnt [ i + 1 ] += 1 ; } } cnt [ n - 2 + 1 ] = cnt [ n - 2 ] ; }
int check ( int n , int m ) { if ( m % n == 0 ) { Console . Write ( " YES " ) ; } else { Console . Write ( " NO " ) ; } return 0 ; }
int det ( int [ , ] d ) { int Sum = d [ 0 , 0 ] * ( ( d [ 1 , 1 ] * d [ 2 , 2 ] ) - ( d [ 2 , 1 ] * d [ 1 , 2 ] ) ) ; Sum -= d [ 0 , 1 ] * ( ( d [ 1 , 0 ] * d [ 2 , 2 ] ) - ( d [ 1 , 2 ] * d [ 2 , 0 ] ) ) ; Sum += d [ 0 , 2 ] * ( ( d [ 0 , 1 ] * d [ 1 , 2 ] ) - ( d [ 0 , 2 ] * d [ 1 , 1 ] ) ) ; return Sum ; }
int countEvenPairs ( int N , int M ) { int count = 0 ; int nEven = ( int ) Math . Floor ( ( double ) N / 2 ) ; int nOdd = ( int ) Math . Ceiling ( ( double ) N / 2 ) ; int mEven = ( int ) Math . Floor ( ( double ) M / 2 ) ; int mOdd = ( int ) Math . Ceiling ( ( double ) M / 2 ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
void solve ( int n , int d , int [ ] input ) { int [ ] a = new int [ N ] ; int [ ] cnt = new int [ V + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) a [ i ] = input [ i ] ; int answer = 0 ; for ( int i = 0 ; i < d ; ++ i ) cnt [ a [ i ] ] ++ ; for ( int i = d ; i <= n - 1 ; ++ i ) { int acc = 0 ; int low_median = - 1 , high_median = - 1 ; for ( int v = 0 ; v <= V ; ++ v ) { acc += cnt [ v ] ; if ( low_median == - 1 && acc >= ( int ) ( Math . Floor ( ( d + 1 ) / 2.0 ) ) ) low_median = v ; if ( high_median == - 1 && acc >= ( int ) ( Math . Ceiling ( ( d + 1 ) / 2.0 ) ) ) high_median = v ; } int double_median = low_median + high_median ; if ( a [ i ] >= double_median ) answer ++ ; cnt [ a [ i - d ] ] -- ; cnt [ a [ i ] ] ++ ; } Console . Write ( answer + " STRNEWLINE " ) ; }
void maximumValue ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = Math . Max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } Console . Write ( ans ) ; }
int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i , curr ] = l ; if ( r != - 1 ) dp [ i , curr ] = Math . Max ( dp [ i , curr ] , r + 1 ) ; return dp [ i , curr ] ; }
void findPairs ( int [ ] arr1 , int [ ] arr2 , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) Console . WriteLine ( arr1 [ i ] + " ▁ " + arr2 [ j ] ) ; }
int smallest_pair ( int [ ] a , int n ) { int min = int . MaxValue , secondMin = int . MaxValue ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
int maxSum ( int N ) { int ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum ; int max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
int minMovesToSort ( int [ ] arr , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; }
void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; Console . WriteLine ( " The ▁ Perimeter ▁ of ▁ " + " Decagon ▁ is ▁ : ▁ " + Perimeter ) ; }
long sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( long ) Math . Pow ( n , n ) + sum ( n - 1 ) ) ; }
void path_to_root ( int node ) { while ( node >= 1 ) { Console . Write ( node + " ▁ " ) ; node /= 2 ; } }
string check ( int current_row , int current_col , int destination_row , int destination_col ) { if ( current_row == destination_row ) return " POSSIBLE " ; else if ( current_col == destination_col ) return " POSSIBLE " ; else return " NOT ▁ POSSIBLE " ; }
void findSumOfAllSubsets ( int [ ] arr , int n , int k ) { int factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( int i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( int i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; int freq = factorial_N / ( factorial_d * factorial_D ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; Console . WriteLine ( " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " + k + " ▁ is ▁ = > ▁ " + sum ) ; }
int maximumCandy ( int [ ] candies , int [ ] safety , int N , int M ) { int total = 0 ; int ans = Int32 . MaxValue ; bool all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . Min ( ans , safety [ i ] ) ; } else { ans = Math . Min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n != 0 ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
float sphere ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; return r ; }
float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . Round ( fn * PHI ) ; t ++ ; } return fn ; }
void bin ( long n ) { long i ; Console . Write ( "0" ) ; for ( i = 1 << 30 ; i > 0 ; i = i / 2 ) { if ( ( n & i ) != 0 ) { Console . Write ( "1" ) ; } else { Console . Write ( "0" ) ; } } }
bool ispalindrome ( String s ) { int l = s . Length ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) { return false ; } } return true ; }
void Main ( String [ ] args ) { int A = 6 ; double theta = 45 ; double [ ] ans = Length_Diagonals ( A , theta ) ; Console . Write ( " { 0 : F2 } " + " ▁ " + " { 1 : F2 } " , ans [ 0 ] , ans [ 1 ] ) ; } }
void solve ( int n ) { int ans = 0 ; for ( int y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } Console . Write ( ans ) ; }
int maximizeFinalElement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; }
int nthTerm ( int n ) { return 4 * ( int ) Math . Pow ( n , 2 ) - 3 * n + 2 ; }
int findOddPair ( int [ ] A , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
string fractionToDecimal ( int numr , int denr ) { string res = " " ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int rem = numr % denr ; while ( ( rem != 0 ) && ( ! mp . ContainsValue ( rem ) ) ) { mp [ rem ] = res . Length ; rem = rem * 10 ; int res_part = rem / denr ; res += res_part . ToString ( ) ; rem = rem % denr ; } if ( rem == 0 ) return " " ; else if ( mp . ContainsKey ( rem ) ) return res . Substring ( mp [ rem ] ) ; return " " ; }
int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
int closetAND ( int [ ] arr , int n , int k ) { int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . Min ( ans , Math . Abs ( k - X ) ) ; } } return ans ; }
int minSteps ( int [ ] arr , int n , int k ) { int i , cnt = 0 ; int flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
int waysOfDecoding ( String s ) { long [ ] dp = new long [ s . Length + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != '0' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return ( int ) dp [ s . Length ] ; }
void lengtang ( double r1 , double r2 , double d ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ direct " + " ▁ common ▁ tangent ▁ is ▁ " + ( Math . Sqrt ( Math . Pow ( d , 2 ) - Math . Pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }
int majorityNumber ( int [ ] arr , int n ) { int ans = - 1 ; Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . ContainsKey ( arr [ i ] ) ) { freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 ; } else { freq . Add ( arr [ i ] , 1 ) ; } if ( freq [ arr [ i ] ] > n / 2 ) ans = arr [ i ] ; } return ans ; }
int minCost ( int [ ] cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
int countCubes ( int a , int b ) { return ( int ) ( Math . Floor ( Math . Cbrt ( b ) ) - Math . Ceiling ( Math . Cbrt ( a ) ) + 1 ) ; }
string largestSubStr ( string s ) { while ( s . Length != 0 && s [ s . Length - 1 ] == '1' ) s = s . Substring ( 0 , s . Length - 1 ) ; if ( s . Length == 0 ) return " - 1" ; else return s ; }
int maxSum ( int [ , ] mat , int n ) { if ( n == 1 ) return mat [ 0 , 0 ] ; int [ , ] dp = new int [ n , n ] ; int maxSum = int . MinValue , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 , j ] = mat [ n - 1 , j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = int . MinValue ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 , j - 1 ] ) ) max = dp [ i + 1 , j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 , j + 1 ] ) ) max = dp [ i + 1 , j + 1 ] ; dp [ i , j ] = mat [ i , j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 , j ] ) maxSum = dp [ 0 , j ] ; return maxSum ; }
bool areElementsContiguous ( int [ ] arr , int n ) { int max = int . MinValue ; int min = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . Max ( max , arr [ i ] ) ; min = Math . Min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; bool [ ] visited = new bool [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
int getSum ( int [ ] arr , int p ) { return arr . Length ; }
long fun ( int [ ] marks , int n ) { long [ ] dp = new long [ n ] ; long temp ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
int findMinValue ( int [ ] arr , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( int ) ( sum / n ) + 1 ) ; }
int count ( int [ ] a , int n ) { int countElements = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool flag = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; }
int countDigit ( double n ) { return ( ( int ) Math . Floor ( Math . Log10 ( n ) + 1 ) ) ; }
void line ( double x0 , double y0 ) { double c = ( int ) ( 2 * y0 * x0 ) ; Console . WriteLine ( y0 + " x " + " ▁ + ▁ " + x0 + " y ▁ = ▁ " + c ) ; }
float find_angle ( int x , int y , int z ) { int volume = x * x * y ; float ans = 0 ; if ( z < volume / 2 ) { float d = ( float ) ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = ( float ) Math . Atan ( d ) ; } else { z = volume - z ; float d = ( 2 * z ) / ( float ) ( x * x * x ) ; ans = ( float ) Math . Atan ( d ) ; } ans = ( float ) ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }
int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
void asciiToSentence ( String str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; Console . Write ( ch ) ; num = 0 ; } } }
int countWords ( String str ) { int count = 1 ; for ( int i = 1 ; i < str . Length - 1 ; i ++ ) { if ( str [ i ] >= 65 && str [ i ] <= 90 ) count ++ ; } return count ; }
void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) Console . Write ( 1 ) ; else Console . Write ( 0 ) ; } Console . WriteLine ( ) ; } }
bool isPossible ( int x , int y ) { if ( ( x - y ) == 1 ) return false ; return true ; }
int maxSumArray ( int [ ] arr , int n ) { int sum = 0 ; Dictionary < int , int > m = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( m . ContainsKey ( arr [ i ] ) ) { var val = m [ arr [ i ] ] ; m . Remove ( arr [ i ] ) ; m . Add ( arr [ i ] , val + 1 ) ; } else { m . Add ( arr [ i ] , 1 ) ; } } int minimum = int . MaxValue ; foreach ( KeyValuePair < int , int > x in m ) minimum = Math . Min ( minimum , ( x . Value * x . Key ) ) ; return ( sum - minimum ) ; }
int minRemove ( int [ ] arr , int n ) { int [ ] LIS = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . Max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . Max ( len , LIS [ i ] ) ; } return n - len ; }
void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; Console . Write ( real + " ▁ + ▁ " + imag + " i " ) ; }
int numSeq ( int n ) { return ( int ) ( ( Math . Pow ( 3 , n ) + 3 * Math . Pow ( - 1 , n ) ) / 4 ) ; }
int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * ( int ) Math . Pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
int pairs_count ( int [ ] arr , int n , int sum ) { int ans = 0 ; Array . Sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( ( i < j ) && ( arr [ i ] == x ) ) i ++ ; int y = arr [ j ] , yy = j ; while ( ( j >= i ) && ( arr [ j ] == y ) ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
int DecakismyriagonNum ( int N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
void insertAfter ( Node prev_node , int new_data ) { if ( prev_node == null ) { Console . WriteLine ( " The ▁ given ▁ previous ▁ node " + " ▁ cannot ▁ be ▁ null " ) ; return ; } Node new_node = new Node ( new_data ) ; new_node . next = prev_node . next ; prev_node . next = new_node ; }
bool judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
void LeftRightNode ( int [ ] preorder , int n ) { int min = int . MaxValue , max = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > preorder [ i ] ) min = preorder [ i ] ; if ( max < preorder [ i ] ) max = preorder [ i ] ; } Console . WriteLine ( " Leftmost ▁ node ▁ is ▁ " + min ) ; Console . WriteLine ( " Rightmost ▁ node ▁ is ▁ " + max ) ; }
float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int Substring ( String s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . Max ( ans , temp ) ; temp = 1 ; } } ans = Math . Max ( ans , temp ) ; return ans ; }
void RightRotate ( int [ ] a , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { Console . Write ( a [ n + i - k ] + " ▁ " ) ; } else { Console . Write ( a [ i - k ] + " ▁ " ) ; } } Console . WriteLine ( ) ; }
float squareSide ( float a ) { if ( a < 0 ) return - 1 ; float x = ( 0.423f * a ) ; return x ; }
bool solve ( String s1 , String s2 ) { bool flag1 = false , flag2 = false ; if ( s1 . Length != s2 . Length ) return false ; int l = s1 . Length ; for ( int i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == '1' ) flag1 = true ; if ( s2 [ i ] == '1' ) flag2 = true ; if ( flag1 == true && flag2 == true ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
int getPosition ( int N , int M ) { if ( M > ( N / 2 ) ) { return ( M - ( N / 2 ) ) ; } return ( M + ( N / 2 ) ) ; }
void distributeN ( int A , int B , int C , int n ) { int max1 = Math . Max ( A , B ) ; int max2 = Math . Max ( B , C ) ; int maximum = Math . Max ( max1 , max2 ) ; int sum = A + B + C ; int p = ( 3 * maximum ) - sum ; int diff = n - p ; if ( diff < 0 diff % 3 == 0 ) Console . Write ( " No " ) ; else Console . Write ( " Yes " ) ; }
void findSum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) + 1 ; int expSum = ( int ) ( Math . Pow ( 2 , r ) ) - 1 ; Console . Write ( sum - expSum ) ; }
void printMissingElements ( int [ ] arr , int N ) { int diff = arr [ 0 ] - 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { Console . Write ( i + diff + " ▁ " ) ; diff ++ ; } } } }
int maxsubStringLength ( char [ ] S , int N ) { int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; int maxLen = 0 ; int curr_sum = 0 ; Dictionary < int , int > hash = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = Math . Max ( maxLen , i + 1 ) ; if ( hash . ContainsKey ( curr_sum ) ) maxLen = Math . Max ( maxLen , i - hash [ curr_sum ] ) ; else hash . Add ( curr_sum , i ) ; } return maxLen ; }
void countSubString ( String S , char C ) { int count = 0 ; int conCount = 0 ; for ( int i = 0 ; i < S . Length ; i ++ ) { char ch = S [ i ] ; if ( ch == C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; Console . Write ( count ) ; }
float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
bool findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; }
string check ( int [ ] a , int [ ] b , int Na , int Nb , int k , int m ) { if ( Na < k < m ) return " No " ; Array . Sort ( a ) ; Array . Sort ( b ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return " Yes " ; } return " No " ; }
void completeSequence ( String s ) { int n = s . Length ; int open = 0 , close = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) open ++ ; else close ++ ; if ( close > open ) { Console . Write ( " IMPOSSIBLE " ) ; return ; } } Console . Write ( s ) ; for ( int i = 0 ; i < open - close ; i ++ ) Console . Write ( " ) " ) ; }
void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; Console . Write ( Math . Max ( Math . Max ( left , right ) , Math . Max ( above , below ) ) ) ; }
void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) Console . Write ( i + " ▁ " ) ; } }
int averageRuns ( int runs , int matches , int notout ) { int out1 ; out1 = matches - notout ; if ( out1 == 0 ) return - 1 ; int avg = ( runs ) / out1 ; return avg ; }
int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; }
int maxSelectionCount ( int [ ] a , int n ) { int res = 0 ; Array . Sort ( a ) ; int select = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
int calculateSum ( int n ) { return ( ( int ) Math . Pow ( 2 , n + 1 ) + n - 2 ) ; }
int minParentheses ( string p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . Length ; ++ i ) { bal += p [ i ] == ' ( ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
int minSwaps ( int N , int M , int [ , ] A , int [ , ] B ) { int count01 = 0 ; int count10 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i , j ] != B [ i , j ] ) { if ( A [ i , j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return - 1 ; }
int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
int countNum ( int [ ] arr , int n ) { int count = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
void printModulus ( int X , int Y ) { int d = Math . Abs ( X - Y ) ; int i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { Console . Write ( i + " ▁ " ) ; if ( d / i != i ) Console . Write ( d / i + " ▁ " ) ; } i ++ ; } }
int SubseqWidths ( int [ ] A , int n ) { Array . Sort ( A ) ; int [ ] pow2 = new int [ n ] ; pow2 [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }
int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = ( int ) Math . Pow ( 4 , odd_indices ) ; int arr_even = ( int ) Math . Pow ( 5 , even_indices ) ; return arr_odd * arr_even ; }
String balancedTernary ( int n ) { String output = " " ; while ( n > 0 ) { int rem = n % 3 ; n = n / 3 ; if ( rem == 2 ) { rem = - 1 ; n ++ ; } output = ( rem == 0 ? '0' : ( rem == 1 ) ? '1' : ' Z ' ) + output ; } return output ; }
int MinOfCubedDP ( int k ) { int [ ] DP = new int [ k + 1 ] ; int j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = int . MaxValue ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
double Mixture ( int X , int Y , int Z ) { double result1 = 0.0 , result = 0.0 ; result1 = ( ( X - Y ) / ( float ) X ) ; result = Math . Pow ( result1 , Z ) ; result = result * X ; return result ; }
int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
double SumofInverseDivisors ( int N , int Sum ) { double ans = ( double ) ( Sum ) * 1.0 / ( double ) ( N ) ; return ans ; }
double vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return Math . Sqrt ( sum ) ; }
int countSubSeq ( string str , int len ) { int ans = 0 ; int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) ans += mul ; mul *= 2 ; } return ans ; }
bool isPentadecagon ( int N ) { double n = ( 11 + Math . Sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; }
bool isSubSeqDivisible ( string str ) { int i , j , k , l = str . Length ; int [ ] arr = new int [ l ] ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = str [ i ] - '0' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
bool EqualNumber ( int A , int B ) { if ( ( A ^ B ) > 0 ) return true ; else return false ; }
String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return " Yes " ; return " No " ; }
int findUnique ( int [ ] a , int n , int k ) { byte sizeof_int = 4 ; int INT_SIZE = 8 * sizeof_int ; int [ ] count = new int [ INT_SIZE ] ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; int res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
int Maxcost ( string s , int [ ] cost ) { int maxcost = 0 ; int i = 0 ; while ( i < s . Length - 1 ) { if ( s [ i ] == s [ i + 1 ] ) { if ( cost [ i ] > cost [ i + 1 ] ) maxcost += cost [ i ] ; else { maxcost += cost [ i + 1 ] ; cost [ i + 1 ] = cost [ i ] ; } } i ++ ; } return maxcost ; }
double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
void GenerateArray ( int N , int X ) { int prev_xor = X ; for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( i ^ prev_xor ) ; if ( i != N ) { Console . Write ( " ▁ " ) ; } prev_xor = i ; } }
int MinOperation ( int [ ] a , int [ ] b , int n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . Abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . Abs ( a [ i ] - b [ i ] ) ; } return result ; }
int LCIS ( int [ ] arr1 , int n , int [ ] arr2 , int m ) { int [ ] table = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
int distinctCount ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . Add ( Math . Abs ( arr [ i ] ) ) ; return s . Count ; }
int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
void countWays ( int n ) { if ( n <= 2 ) { Console . WriteLine ( " - 1" ) ; } else { int ans = ( n - 1 ) * ( n - 2 ) / 2 ; Console . WriteLine ( ans ) ; } }
void findMinLength ( int [ ] arr , int N ) { int front = 0 , back = N - 1 ; while ( front < back ) { int x = arr [ front ] ; if ( arr [ front ] != arr [ back ] ) break ; while ( arr [ front ] == x && front <= back ) front ++ ; while ( arr [ back ] == x && front <= back ) back -- ; } Console . WriteLine ( back - front + 1 ) ; }
int TetracontaoctagonalNum ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
int sumBitDifferences ( int [ ] arr , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) == 0 ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
double distance ( int r , int R ) { double d = Math . Sqrt ( Math . Pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
void findMinimumTime ( String tasks , int K ) { Dictionary < char , int > map = new Dictionary < char , int > ( ) ; int curr_time = 0 ; foreach ( char c in tasks . ToCharArray ( ) ) { if ( map . ContainsKey ( c ) ) { if ( curr_time - map <= K ) { curr_time += K - ( curr_time - map ) + 1 ; } } if ( ! map . ContainsKey ( c ) ) map . Add ( c , curr_time ) ; else map = curr_time ; curr_time ++ ; } Console . WriteLine ( curr_time ) ; }
long centered_heptagonal_num ( long n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
void smallestNumber ( int N ) { Console . Write ( N * Math . Ceiling ( Math . Pow ( 2 , ( N - 1 ) ) / N ) ) ; }
int findRepeatFirstN2 ( string s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . Length ; i ++ ) { for ( j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
int maxSubarrayXOR ( int [ ] arr , int n ) { int ans = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . Max ( ans , curr_xor ) ; } } return ans ; }
bool isStar ( int N ) { double n = ( 6 + Math . Sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
bool solve ( int [ ] a , int n ) { int mx = Int32 . MinValue ; for ( int j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = Math . Max ( mx , a [ j - 1 ] ) ; } return true ; }
int longestSubstring ( string s ) { int cnt = 1 , maxi = 1 ; int n = s . Length ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; else { maxi = Math . Max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . Max ( cnt , maxi ) ; return maxi ; }
char Colour_Combination ( string s ) { char temp = s [ 0 ] ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' B ' temp == ' G ' ) && ( s [ i ] == ' G ' s [ i ] == ' B ' ) ) temp = ' Y ' ; else if ( ( temp == ' B ' temp == ' Y ' ) && ( s [ i ] == ' Y ' s [ i ] == ' B ' ) ) temp = ' G ' ; else temp = ' B ' ; } } return temp ; }
int totalTriangles ( int h , int v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; int total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
int lucas ( int n ) { int a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
bool checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . Abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
void createArray ( int n , int s ) { if ( 2 * n <= s ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { Console . Write ( 2 + " ▁ " ) ; s -= 2 ; } Console . WriteLine ( s ) ; Console . WriteLine ( 1 ) ; } else Console . Write ( " - 1" ) ; }
void solve ( int [ ] arr , int n ) { int countzeroes = 0 ; int countones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( Math . Abs ( countzeroes - countones ) == 1 ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
int sumoflength ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . Contains ( arr [ j ] ) ) { s . Add ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . Remove ( arr [ i ] ) ; } return ans ; }
bool prodSquare ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
bool isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
void checkEVENodd ( int [ ] arr , int n , int l , int r ) { if ( arr [ r ] == 1 ) Console . WriteLine ( " odd " ) ; else Console . WriteLine ( " even " ) ; }
bool sumSquare ( int n ) { Dictionary < int , int > s = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i * i <= n ; ++ i ) { s . Add ( i * i , 1 ) ; if ( s . ContainsKey ( n - i * i ) ) { Console . WriteLine ( ( int ) Math . Sqrt ( n - i * i ) + " ^ 2 ▁ + ▁ " + i + " ^ 2" ) ; return true ; } } return false ; }
bool isCentereddecagonal ( int N ) { double n = ( 5 + Math . Sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
void isConversionPossible ( String s1 , String s2 , int x ) { int diff = 0 , n ; n = s1 . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( ( int ) ( s2 [ i ] - s1 [ i ] ) + 26 ) % 26 ; if ( diff > x ) { Console . Write ( " NO " ) ; return ; } } Console . Write ( " YES " ) ; }
bool isDefeat ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == '0' && s2 [ i ] == '1' ) || ( s1 [ i ] == '1' && s2 [ i ] == '0' ) ) continue ; else if ( ( s1 [ i ] == '0' && s2 [ i ] == ' Z ' ) || ( s1 [ i ] == ' Z ' && s2 [ i ] == '0' ) ) continue ; else { return true ; } } return false ; }
int nearest ( int n ) { int prevSquare = ( int ) Math . Sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; }
void printSorted ( int a , int b , int c ) { int get_max = Math . Max ( a , Math . Max ( b , c ) ) ; int get_min = - Math . Max ( - a , Math . Max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; Console . Write ( get_min + " ▁ " + get_mid + " ▁ " + get_max ) ; }
int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; }
int dealnnoy ( int n , int m ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i , 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 , i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 1 , j - 1 ] + dp [ i , j - 1 ] ; return dp [ m , n ] ; }
int totalSubSets ( int n , int l , int r ) { int zero = ( int ) Math . Floor ( ( double ) r / 3 ) - ( int ) Math . Ceiling ( ( double ) l / 3 ) + 1 ; int one = ( int ) Math . Floor ( ( double ) ( r - 1 ) / 3 ) - ( int ) Math . Ceiling ( ( double ) ( l - 1 ) / 3 ) + 1 ; int two = ( int ) Math . Floor ( ( double ) ( r - 2 ) / 3 ) - ( int ) Math . Ceiling ( ( double ) ( l - 2 ) / 3 ) + 1 ; int [ , ] dp = new int [ n , 3 ] ; dp [ 0 , 0 ] = zero ; dp [ 0 , 1 ] = one ; dp [ 0 , 2 ] = two ; for ( int i = 1 ; i < n ; ++ i ) { dp [ i , 0 ] = ( ( dp [ i - 1 , 0 ] * zero ) + ( dp [ i - 1 , 1 ] * two ) + ( dp [ i - 1 , 2 ] * one ) ) % MOD ; dp [ i , 1 ] = ( ( dp [ i - 1 , 0 ] * one ) + ( dp [ i - 1 , 1 ] * zero ) + ( dp [ i - 1 , 2 ] * two ) ) % MOD ; dp [ i , 2 ] = ( ( dp [ i - 1 , 0 ] * two ) + ( dp [ i - 1 , 1 ] * one ) + ( dp [ i - 1 , 2 ] * zero ) ) % MOD ; } return dp [ n - 1 , 0 ] ; }
int minimumflip ( int [ , ] mat , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i , j ] != mat [ j , i ] ) flip ++ ; return flip ; }
void findLast ( int [ , ] mat ) { int m = 3 ; int n = 3 ; HashSet < int > rows = new HashSet < int > ( ) ; HashSet < int > cols = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( mat [ i , j ] > 0 ) ) { rows . Add ( i ) ; cols . Add ( j ) ; } } } int avRows = m - rows . Count ; int avCols = n - cols . Count ; int choices = Math . Min ( avRows , avCols ) ; if ( ( choices & 1 ) != 0 ) Console . WriteLine ( " P1" ) ; else Console . WriteLine ( " P2" ) ; }
int count ( String N , int X , String subStr , int index , int n ) { if ( index == n ) return 0 ; String a = subStr + N [ index ] ; int b = 0 ; if ( long . Parse ( a ) % X == 0 ) b = 1 ; int m1 = count ( N , X , a , index + 1 , n ) ; int m2 = b + count ( N , X , " " , index + 1 , n ) ; return Math . Max ( m1 , m2 ) ; }
long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
int permutationCoeff ( int n , int k ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }
int Centered_Triangular_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
double findMedian ( int [ ] a , int n ) { Array . Sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
int count ( Node head , int key ) { if ( head == null ) return 0 ; if ( head . data == key ) return 1 + count ( head . next , key ) ; return count ( head . next , key ) ; }
float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float radius = ( float ) Math . Sqrt ( Math . Pow ( l , 2 ) + Math . Pow ( b , 2 ) ) / 2 ; return radius ; }
int longestSubArray ( int [ ] arr , int n ) { bool isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
void checkSolution ( int a , int b , int c ) { if ( a == c ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
void mulsum ( int [ ] arr , int n , int N ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } Console . Write ( sum ) ; }
bool divisibleBy36 ( String num ) { int l = num . Length ; if ( l == 0 ) return false ; if ( l == 1 && num [ 0 ] != '0' ) return false ; int two_digit_num = ( num [ l - 2 ] - '0' ) * 10 + ( num [ l - 1 ] - '0' ) ; if ( two_digit_num % 4 != 0 ) return false ; int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - '0' ) ; if ( sum % 9 != 0 ) return false ; return true ; }
bool isRepdigit ( int num , int b ) { int prev = - 1 ; while ( num != 0 ) { int digit = num % b ; num /= b ; if ( prev != - 1 && digit != prev ) return false ; prev = digit ; } return true ; }
int CountTriplets ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int first = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
int findAns ( int [ , ] mat , int x , int y , int n , int m ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i , j ] == 1 ) { ans += Math . Abs ( x - i ) + Math . Abs ( y - j ) ; } } } return ans ; }
int maxRepeating ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ ( arr [ i ] % k ) ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
int FindMaxS ( int X , int Y , int Z , int n , int [ ] A , int [ ] B , int [ ] C ) { if ( X < 0 Y < 0 Z < 0 ) return Int32 . MinValue ; if ( n < 0 ) return 0 ; if ( dp [ n , X , Y , Z ] != - 1 ) { return dp [ n , X , Y , Z ] ; } int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = Math . Max ( ch , Math . Max ( ca , Math . Max ( co , no ) ) ) ; return dp [ n , X , Y , Z ] = maximum ; }
int count ( int n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; int [ ] table = new int [ n + 1 ] ; int i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
int FindMinimumCost ( int ind , int [ ] a , int n , int k , int [ ] dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { int ans = int . MaxValue ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . Min ( ans , Math . Abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
int MatrixChainOrder ( int [ ] p , int i , int j ) { if ( i == j ) return 0 ; int min = int . MaxValue ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . Abs ( n - n1 ) < Math . Abs ( n - n2 ) ) return n1 ; return n2 ; }
int maxTripletSum ( int [ ] arr , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
bool adjacentSet ( int n ) { int x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }
void maxGcd ( int a , int b ) { Console . Write ( Math . Abs ( a - b ) ) ; }
void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod ) { if ( n == 1 ) { Console . WriteLine ( " Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; Console . WriteLine ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; }
void sortExceptUandL ( int [ ] a , int l , int u , int n ) { int [ ] b = new int [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; Array . Sort < int > ( b , 0 , n - ( u - l + 1 ) ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
int maxOR ( int [ ] arr , int n ) { int max_value = arr . Max ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . Max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; }
bool inProportion ( int [ ] arr ) { int n = 4 ; Array . Sort ( arr ) ; long extremes = ( long ) arr [ 0 ] * ( long ) arr [ 3 ] ; long means = ( long ) arr [ 1 ] * ( long ) arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
int findWaysToPair ( int p ) { int [ ] dp = new int [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }
double decdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.902 * a ; return d ; }
int doMatch ( String A , String B ) { for ( int i = 0 ; i < A . Length ; i ++ ) { if ( A [ i ] != ' * ' && B [ i ] != ' * ' ) if ( A [ i ] != B [ i ] ) return 0 ; } return 1 ; }
int countTriplets ( int N ) { int cnt = 0 ; for ( int A = 1 ; A <= N ; ++ A ) { for ( int B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
int findMinSum ( int [ , ] mat , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i , j ] ; } } sum += res ; } return sum ; }
void generatepermutation ( int N ) { int [ ] answer = new int [ N ] ; answer [ 0 ] = N ; for ( int i = 1 ; i < N ; i ++ ) { answer [ i ] = i ; } foreach ( int i in answer ) Console . Write ( i + " ▁ " ) ; }
int minimumCost ( int [ ] cost , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . Min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . Min ( dp1 , dp2 ) ; }
int countSubstrs ( string str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
int lastDigit2PowerN ( int n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
Boolean IsPrime ( int i ) { if ( i % 2 == 0 && i != 2 ) return false ; else { for ( int j = 3 ; j <= Math . Sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) return false ; } return true ; } }
int MaximumPath ( int [ , ] Mat ) { int result = 0 ; int [ , ] dp = new int [ N , N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 , i + 1 ] = Mat [ 0 , i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j - 1 ] , Math . Max ( dp [ i - 1 , j ] , dp [ i - 1 , j + 1 ] ) ) + Mat [ i , j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . Max ( result , dp [ N - 1 , i ] ) ; return result ; }
bool allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
void findTemperature ( int x , int y , int s ) { double Day1 , Day2 ; double diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; Console . Write ( " Day1 ▁ : ▁ " + Day1 + ' STRNEWLINE ' ) ; Console . WriteLine ( " Day2 ▁ : ▁ " + Day2 + ' STRNEWLINE ' ) ; }
double numberOfTriangles ( int n ) { double ans = 2 * ( Math . Pow ( 3 , n ) ) - 1 ; return ans ; }
int areaSquare ( int side ) { int area = side * side ; return area ; }
int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . Min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
int findNumber ( int N ) { int [ ] ans = { 1 , 2 , 4 , 8 , 7 , 5 } ; return ans [ N % 6 ] ; }
void shuffle ( int N , int key ) { int NO_OF_BITS = N ; int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } Console . Write ( reverse_num ) ; }
void FindSub ( string str , string res , int i ) { if ( i == str . Length ) { if ( res . Length > 0 ) { Console . Write ( res + " ▁ " ) ; } return ; } char ch = str [ i ] ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + ( int ) ch , i + 1 ) ; }
void findAngle ( double M1 , double M2 ) { double angle = Math . Abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; double ret = Math . Atan ( angle ) ; double val = ( ret * 180 ) / PI ; Console . Write ( val ) ; }
int binary_searched_find_x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( Math . Pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; }
bool sentencePalindrome ( String str ) { int l = 0 ; int h = str . Length - 1 ; str = str . ToLower ( ) ; while ( l <= h ) { char getAtl = str [ l ] ; char getAth = str [ h ] ; if ( ! ( getAtl >= ' a ' && getAtl <= ' z ' ) ) l ++ ; else if ( ! ( getAth >= ' a ' && getAth <= ' z ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; }
int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; }
int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . Max ( 2 * screen [ n - 4 ] , Math . Max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
int maxbalancedprefix ( string str , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
bool productOfSingelDgt ( int n ) { if ( n >= 0 && n <= 9 ) return true ; int [ ] prime = { 2 , 3 , 5 , 7 } ; for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
int minimumStepReqArr ( int [ ] arr , int N ) { int cntStep = 0 ; N += 1 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }
void twoWaySort ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }
void minimumIncreasingSubsequences ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int count = 0 ; int i = 0 ; while ( i < N ) { int x = arr [ i ] ; int freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = Math . Max ( count , freqX ) ; } Console . Write ( count ) ; }
int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( Math . Max ( Math . Abs ( i - r ) , Math . Abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
int LCSubStr ( string X , string Y , int m , int n ) { int [ , ] LCStuff = new int [ m + 1 , n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i , j ] = LCStuff [ i - 1 , j - 1 ] + 1 ; result = Math . Max ( result , LCStuff [ i , j ] ) ; } else LCStuff [ i , j ] = 0 ; } } return result ; }
long increment ( long i ) { i = - ( ~ i ) ; return i ; }
float squareArea ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) ( Math . Pow ( 1.268 , 2 ) * Math . Pow ( a , 2 ) ) ; return area ; }
int findMin ( int [ ] arr , int N , int k ) { int pairs = 0 ; for ( int i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return - 1 ; else return 2 * k + N - 1 ; }
void nearestPerfectSquare ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = ( int ) Math . Sqrt ( arr [ i ] ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) Console . Write ( a + " ▁ " ) ; else Console . Write ( b + " ▁ " ) ; } }
int printNthElement ( int n ) { int [ ] arr = new int [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
float weightedMean ( int [ ] X , int [ ] W , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) ( numWeight ) / sum ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int smallestNum ( int n ) { for ( int i = 2 ; ; i *= 2 ) { int length = ( int ) ( Math . Log10 ( i ) ) + 1 ; if ( length == n ) return ( int ) ( Math . Log ( i ) / Math . Log ( 2 ) ) ; } }
int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
int findOddPair ( int [ ] A , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
void maximizeProduct ( int N ) { int MSB = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) { X += 1 << i ; Y += 1 << i ; } } Console . Write ( X + " ▁ " + Y ) ; }
int kthNonDivisible ( int N , int K ) { return ( int ) ( K + Math . Floor ( ( double ) ( K - 1 ) / ( N - 1 ) ) ) ; }
int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
void precompute ( ) { int fact = 1 ; for ( int i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m . Add ( fact , i ) ; } }
int maxPointCount ( int [ ] arr , int K , int size ) { int curr_points = 0 ; int max_points = 0 ; for ( int i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; int j = size - 1 ; for ( int i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = Math . Max ( curr_points , max_points ) ; j -- ; } return max_points ; }
int CountSubarray ( int [ ] arr , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
int findLCS ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } return mp . Count ; }
int findDiff ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . Max ( max_count , count ) ; min_count = Math . Min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
StringBuilder findMaximumNum ( StringBuilder str , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str [ i ] != '9' ) { str [ i ] = '9' ; k -- ; } } return str ; }
char FindKthChar ( string str , int K , int X ) { char ans = ' ▁ ' ; int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { int digit = ( int ) str [ i ] - 48 ; int range = ( int ) Math . Pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; }
void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) Console . Write ( " - 1" ) ; else { Console . Write ( d ) ; k -- ; while ( k -- > 0 ) Console . Write ( "0" ) ; } }
int gonNum257 ( int n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
bool isTidy ( int num ) { int prev = 10 ; while ( num != 0 ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
void minimumDiff ( int [ ] arr , int N ) { int res = arr [ 0 ] , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min_diff = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( Math . Abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = Math . Abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } Console . Write ( res ) ; }
int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
int largestNum ( int n ) { int num = 0 ; for ( int i = 0 ; i <= 32 ; i ++ ) { int x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
void gcdMax ( int [ ] a , int [ ] b , int n , int N ) { int [ ] cnt = new int [ N ] ; int [ ] first = new int [ N ] ; int [ ] second = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . Max ( first [ i ] , j ) ; cnt = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . Max ( second [ i ] , j ) ; int x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; Console . WriteLine ( first [ x ] + " ▁ " + second [ x ] ) ; }
void canMakeEqual ( String S ) { int N = S . Length ; int weightOfString = 0 ; for ( int i = 0 ; i < N ; i ++ ) { weightOfString += S [ i ] - ' a ' + 1 ; } if ( weightOfString % N == 0 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int Max_Sum ( int [ ] arr1 , int [ ] arr2 , int n ) { int [ , ] dp = new int [ n , 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i , 0 ] = arr1 [ i ] ; dp [ i , 1 ] = arr2 [ i ] ; continue ; } dp [ i , 0 ] = Math . Max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] + arr1 [ i ] ) ; dp [ i , 1 ] = Math . Max ( dp [ i - 1 , 1 ] , dp [ i - 1 , 0 ] + arr2 [ i ] ) ; } return Math . Max ( dp [ n - 1 , 0 ] , dp [ n - 1 , 1 ] ) ; }
int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
void findFourElements ( int [ ] A , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) { if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) Console . Write ( A [ i ] + " ▁ " + A [ j ] + " ▁ " + A [ k ] + " ▁ " + A [ l ] ) ; } } } } }
int findK ( int [ , ] A , int i , int j , int n , int m , int k ) { if ( n < 1 m < 1 ) return - 1 ; if ( k <= m ) return A [ i + 0 , j + k - 1 ] ; if ( k <= ( m + n - 1 ) ) return A [ i + ( k - m ) , j + m - 1 ] ; if ( k <= ( m + n - 1 + m - 1 ) ) return A [ i + n - 1 , j + m - 1 - ( k - ( m + n - 1 ) ) ] ; if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) return A [ i + n - 1 - ( k - ( m + n - 1 + m - 1 ) ) , j + 0 ] ; return findK ( A , i + 1 , j + 1 , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) ; }
void maximumSumPermutation ( int [ ] arr ) { int N = arr . Length ; Array . Sort ( arr ) ; int temp = arr [ 0 ] ; arr [ 0 ] = arr [ N - 1 ] ; arr [ N - 1 ] = temp ; foreach ( int i in arr ) { Console . Write ( i + " ▁ " ) ; } }
int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }
int numberOfWays ( int x ) { int [ ] dp = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
int minOps ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int max = arr [ arr . Length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
int KnapSack ( int [ ] val , int [ ] wt , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) dp [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . Max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
int LIS ( int [ ] a , int n ) { int [ ] dp = new int [ N ] ; int [ ] d = new int [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . Max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . Max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . Max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
void findSide ( float a , double B , double C ) { double A = 180 - C - B ; double radA = ( Math . PI * ( A / 180 ) ) ; double radB = ( Math . PI * ( B / 180 ) ) ; double radC = ( Math . PI * ( C / 180 ) ) ; double b = ( a / Math . Sin ( radA ) * Math . Sin ( radB ) ) ; double c = ( a / Math . Sin ( radA ) * Math . Sin ( radC ) ) ; Console . Write ( " { 0 : F15 } " , b ) ; Console . Write ( " { 0 : F15 } " , c ) ; }
void first_digit ( int x , int y ) { int length = ( int ) ( Math . Log ( x ) / Math . Log ( y ) + 1 ) ; int first_digit = ( int ) ( x / Math . Pow ( y , length - 1 ) ) ; Console . Write ( first_digit ) ; }
int maxOperations ( int X , int Y ) { if ( X > Y ) return - 1 ; int diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
void findPoint ( int n , int h ) { for ( int i = 1 ; i < n ; i ++ ) Console . Write ( " { 0 : F2 } ▁ " , Math . Sqrt ( i / ( n * 1.0 ) ) * h ) ; }
long minValue ( int [ ] a , int [ ] b , int n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( a [ i ] * b [ n - i - 1 ] ) ; return result ; }
String find_number ( int N , int K ) { String r ; if ( N % 100 == 0 ) { N += 1 ; r = N . ToString ( ) ; } else { r = N . ToString ( ) ; } for ( int i = 1 ; i <= K ; i ++ ) r += "00" ; return r ; }
long computeXOR ( int n ) { int x = n & 3 ; switch ( x ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } return 0 ; }
int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
int countSubStr ( char [ ] str , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) { res ++ ; } } } } return res ; }
bool possibleToReach ( int a , int b ) { int c = ( int ) Math . Pow ( a * b , ( double ) 1 / 3 ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
int findSubsequenceCount ( string S , string T ) { int m = T . Length ; int n = S . Length ; if ( m > n ) return 0 ; int [ , ] mat = new int [ m + 1 , n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i , 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 , j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i , j ] = mat [ i , j - 1 ] ; else mat [ i , j ] = mat [ i , j - 1 ] + mat [ i - 1 , j - 1 ] ; } } return mat [ m , n ] ; }
void minNum ( int n ) { if ( n < 3 ) Console . WriteLine ( - 1 ) ; else Console . WriteLine ( 210 * ( ( int ) ( Math . Pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; }
int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' a ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' b ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' c ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
int SubArrayProdct ( int [ ] arr , int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result *= ( int ) ( Math . Pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ) ; return result ; }
int maxSumPairWithDifferenceLessThanK ( int [ ] arr , int N , int k ) { int maxSum = 0 ; Array . Sort ( arr ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
int countTotalDistinct ( String str ) { int cnt = 0 ; HashSet < String > items = new HashSet < String > ( ) ; for ( int i = 0 ; i < str . Length ; ++ i ) { String temp = " " ; HashSet < char > ans = new HashSet < char > ( ) ; for ( int j = i ; j < str . Length ; ++ j ) { temp = temp + str [ j ] ; ans . Add ( str [ j ] ) ; if ( ! items . Contains ( temp ) ) { items . Add ( temp ) ; cnt += ans . Count ; } } } return cnt ; }
void canBreakN ( long n ) { for ( long i = 2 ; ; i ++ ) { long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long k = n - m ; if ( k % i != 0 ) continue ; Console . Write ( i ) ; return ; } Console . Write ( " - 1" ) ; }
int countNegative ( int [ , ] M , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i , j ] < 0 ) count += 1 ; else break ; } } return count ; }
int countPairs ( int [ ] X , int [ ] Y , int m , int n ) { int [ ] suffix = new int [ 1005 ] ; long total_pairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( int i = ( int ) 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return ( int ) total_pairs ; }
double solve ( int s ) { double area = ( 1.732 * Math . Pow ( s , 2 ) ) / 8 ; return area ; }
void print ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j ) Console . WriteLine ( a [ i ] + " ▁ " + a [ j ] ) ; } } }
double nth_group ( int n ) { return n * ( 2 * Math . Pow ( n , 2 ) + 1 ) ; }
int minCostToMakeElementEqual ( int [ ] a , int n ) { int y ; if ( n % 2 == 1 ) y = a [ n / 2 ] ; else y = ( a [ n / 2 ] + a [ ( n - 2 ) / 2 ] ) / 2 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) s += Math . Abs ( a [ i ] - y ) ; return s ; }
bool isProduct ( int [ ] arr , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
int countOddSquares ( int n , int m ) { return ( int ) Math . Pow ( ( double ) m , 0.5 ) - ( int ) Math . Pow ( ( double ) n - 1 , 0.5 ) ; }
int properDivisorSum ( int n ) { int sum = 0 ; int i ; for ( i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; }
int HexacontatetragonNum ( int n ) { return ( 62 * n * n - 60 * n ) / 2 ; }
int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 1 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; }
void no_of_moves ( int [ , ] Matrix , int x , int y ) { int moves = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( Matrix [ i , j ] != 0 ) { moves += Math . Abs ( x - i ) ; moves += Math . Abs ( y - j ) ; } } } Console . WriteLine ( moves ) ; }
int findSteps ( int n , int m , int [ ] a ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
int count ( int [ ] arr , int low , int high , int x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , ( low + high ) / 2 , x ) + count ( arr , 1 + ( low + high ) / 2 , high , x ) ; }
void printOdds ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; int set_bit = res & ( ~ ( res - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit ) != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } Console . WriteLine ( x + " ▁ " + y ) ; }
float correlationCoefficient ( int [ ] X , int [ ] Y , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( Math . Sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
int solve ( ArrayList values , ArrayList salary ) { int ret = 1 ; int amt = 0 ; values . Sort ( ) ; salary . Sort ( ) ; while ( salary . Count > 0 ) { while ( values . Count > 0 && ( int ) values [ values . Count - 1 ] >= ( int ) salary [ salary . Count - 1 ] ) { amt ++ ; values . RemoveAt ( values . Count - 1 ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . RemoveAt ( salary . Count - 1 ) ; } return ret ; }
void String ( int l , int x , int y ) { int p = 97 ; for ( int j = 0 ; j < l ; j ++ ) { char ans = ( char ) ( p + ( j % y ) ) ; Console . Write ( ans ) ; } }
int numberOfWays ( int n , int k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= ( int ) Math . Pow ( 2 , k ) ) { int curr_val = ( int ) Math . Pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; }
void equation_ellipse ( float x1 , float y1 , float a , float b , float c , float e ) { float t = a * a + b * b ; float a1 = t - e * ( a * a ) ; float b1 = t - e * ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; float e1 = - 2 * e * a * b ; float f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; System . Console . WriteLine ( " Equation ▁ of ▁ ellipse ▁ is ▁ " ) ; System . Console . WriteLine ( a1 + " ▁ x ^ 2 ▁ + ▁ " + b1 + " ▁ y ^ 2 ▁ + ▁ " + c1 + " ▁ x ▁ + ▁ " + d1 + " ▁ y ▁ + ▁ " + e1 + " ▁ xy ▁ + ▁ " + f1 + " ▁ = ▁ 0" ) ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
int find_max ( int i , int sum , int [ ] v , int k ) { if ( i == v . Length ) return 0 ; if ( dp [ i , sum ] != - 1 ) return dp [ i , sum ] ; int ans = 0 ; if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) ans = find_max ( i + 1 , sum , v , k ) ; if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) ans = Math . Max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) ; return dp [ i , sum ] = ans ; }
int getCount ( int rows , int columns , int [ , ] A ) { int res = 0 ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = i + 1 ; j < rows ; j ++ ) { if ( A [ i , 0 ] * A [ j , 1 ] == A [ i , 1 ] * A [ j , 0 ] ) { res ++ ; } } } return res ; }
void SubMasks ( int N ) { for ( int S = N ; S > 0 ; S = ( S - 1 ) & N ) { Console . Write ( S + " ▁ " ) ; } }
int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
void sortArray ( int [ ] A , int N ) { int x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } Console . Write ( " Sorted ▁ Array : ▁ " ) ; for ( int i = 0 ; i < N ; i ++ ) Console . Write ( A [ i ] + " ▁ " ) ; } else { Console . Write ( " - 1" ) ; } }
uint getModulo ( uint n , uint d ) { return ( n & ( d - 1 ) ) ; }
long largestNumber ( int N ) { if ( N > 45 ) return - 1 ; int num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
void printFourSquares ( int a ) { for ( int i = 0 ; i * i <= a ; i ++ ) { for ( int j = i ; j * j <= a ; j ++ ) { for ( int k = j ; k * k <= a ; k ++ ) { for ( int l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { Console . Write ( a + " ▁ = ▁ " + i + " * " + i + " ▁ + ▁ " + j + " * " + j + " ▁ + ▁ " ) ; Console . Write ( k + " * " + k + " ▁ + ▁ " + l + " * " + l + " STRNEWLINE " ) ; } } } } } }
int countBuildings ( int [ ] arr , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
int minimumSteps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
char lastRemovedCharacter ( char [ ] str ) { int n = str . Length ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == '0' ) { return ( char ) ( '1' - str [ n - 1 ] + '0' ) ; } else return str [ n - 1 ] ; }
string updateString ( string S , string A , string B ) { int l = A . Length ; for ( int i = 0 ; i + l <= S . Length ; i ++ ) { string curr = S . Substring ( i , l ) ; if ( curr . Equals ( A ) ) { string new_string = S . Substring ( 0 , i ) + B + S . Substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { string new_string = S . Substring ( 0 , i ) + A + S . Substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; }
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) Console . WriteLine ( "1" ) ; else Console . WriteLine ( "0" ) ; } int mul = ( int ) Math . Pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; Console . WriteLine ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
void minimumMEX ( int [ ] arr , int N , int K ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s . Add ( i ) ; for ( int i = 0 ; i < K ; i ++ ) s . Remove ( arr [ i ] ) ; int mex = s . First ( ) ; for ( int i = K ; i < N ; i ++ ) { s . Remove ( arr [ i ] ) ; s . Add ( arr [ i - K ] ) ; int firstElem = s . First ( ) ; mex = Math . Min ( mex , firstElem ) ; } Console . Write ( mex + " ▁ " ) ; }
void findSolutions ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( ( i + N / i ) % 2 == 0 ) { count ++ ; } } } Console . Write ( 4 * count ) ; }
int leastValue ( int P , int A , int N , int [ ] a ) { int ans = - 1 ; float tmp = float . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { float t = ( float ) ( P - a [ i ] * 0.006 ) ; if ( Math . Abs ( t - A ) < tmp ) { tmp = Math . Abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
int area_fun ( int side ) { int area = side * side ; return area ; }
bool checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
void group_formed ( String S ) { int count = 1 ; for ( int i = 0 ; i < S . Length - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } Console . Write ( count ) ; }
void solve ( int N ) { int ans = 0 ; while ( N != 0 ) { ans += N ; N /= 2 ; } Console . Write ( ans ) ; }
void segregateElements ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
void removeAll ( int [ ] arr , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) Console . Write ( " YES " ) ; else Console . Write ( " NO " ) ; }
void printPairs ( int [ ] arr , int n ) { HashSet < int > pairs = new HashSet < int > ( ) ; bool pair_exists = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) pairs . Add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) if ( pairs . Contains ( - arr [ i ] ) ) { Console . WriteLine ( arr [ i ] + " , ▁ " + - arr [ i ] ) ; pair_exists = true ; } } if ( pair_exists == false ) Console . WriteLine ( " No ▁ such ▁ pair ▁ exists " ) ; }
int lenghtOfLongestAP ( int [ ] A , int n ) { Dictionary < int , Dictionary < int , int > > dp = new Dictionary < int , Dictionary < int , int > > ( ) ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; if ( dp . ContainsKey ( d ) ) { if ( dp [ d ] . ContainsKey ( i ) ) { dp [ d ] [ j ] = dp [ d ] [ i ] + 1 ; } else { dp [ d ] [ j ] = 2 ; } } else { dp [ d ] = new Dictionary < int , int > ( ) ; dp [ d ] [ j ] = 2 ; } res = Math . Max ( res , dp [ d ] [ j ] ) ; } } return res ; }
int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
int calculateWays ( int [ ] arr1 , int [ ] arr2 , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( int c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( int d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
int areaOfSquare ( int S ) { int area = S * S ; return area ; }
float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; }
bool graphExists ( ArrayList a , int n ) { while ( true ) { a . Sort ( ) ; a . Reverse ( ) ; if ( ( int ) a [ 0 ] == 0 ) return true ; int v = ( int ) a [ 0 ] ; a . Remove ( a [ 0 ] ) ; if ( v > a . Count ) return false ; for ( int i = 0 ; i < v ; i ++ ) { a [ i ] = ( int ) a [ i ] - 1 ; if ( ( int ) a [ i ] < 0 ) return false ; } } }
void solve ( string s , int k ) { int count = 0 , length = 0 , pos = 0 ; Dictionary < char , int > m = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( m . ContainsKey ( s [ i ] ) ) m [ s [ i ] ] ++ ; else m [ s [ i ] ] = 1 ; length ++ ; if ( length > k ) { m [ s [ pos ] ] -- ; pos ++ ; length -- ; } if ( length == k && m [ s [ i ] ] == length ) count ++ ; } Console . WriteLine ( count ) ; }
int findCnt ( int [ ] arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i , required_sum + Base ] ) return dp [ i , required_sum + Base ] ; v [ i , required_sum + Base ] = true ; dp [ i , required_sum + Base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i , required_sum + Base ] ; }
bool isPossible ( int x , int y , int k ) { int minMoves = Math . Abs ( x ) + Math . Abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
int ceilDifference ( int [ ] arr , int n , int x ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += ( int ) Math . Ceiling ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int totalCeilSum = ( int ) Math . Ceiling ( ( double ) ( totalSum ) / ( double ) ( x ) ) ; return Math . Abs ( perElementSum - totalCeilSum ) ; }
void print ( String str1 ) { char [ ] str = str1 . ToCharArray ( ) ; Console . Write ( str [ 0 ] ) ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( ( str [ i ] == str [ i - 1 ] + 1 ) || ( str [ i ] == str [ i - 1 ] - 1 ) ) { Console . Write ( str [ i ] ) ; } else { Console . Write ( " STRNEWLINE " + str [ i ] ) ; } } }
void findNumbers ( int [ ] arr , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += ( int ) Math . Pow ( arr [ i ] , 2 ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; Console . WriteLine ( " A ▁ = ▁ " + A + " B = " }
void minimumCost ( int [ ] cost , int n , int x ) { int [ ] dp = new int [ n + 2 ] ; dp [ 0 ] = cost [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + Math . Min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + Math . Min ( dp [ i - 1 ] , Math . Min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } Console . WriteLine ( dp [ n - 1 ] ) ; }
int numOfWays ( int [ , ] a , int n , int i , HashSet < int > blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i , j ] == 1 && ! blue . Contains ( j ) ) { blue . Add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . Remove ( j ) ; } } return count ; }
bool isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; }
int countSticks ( String str , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str [ i ] - '0' ] ) ; } return cnt ; }
int maxOR ( int [ ] arr , int n ) { int max_value = arr . Max ( ) ; int number_of_bits = ( int ) ( Math . Log ( max_value ) ) + 2 ; int complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = Math . Max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
void check ( int n , int m ) { if ( n == 2 m == 2 n % m == 0 ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } }
long fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
int getMinCost ( int [ ] A , int [ ] B , int N ) { int mini = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . Min ( mini , Math . Min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
float findRadiusOfcircumcircle ( float n , float a ) { if ( n < 0 a < 0 ) return - 1 ; float radius = ( float ) ( a / Math . Sqrt ( 2 - ( 2 * Math . Cos ( 360 / n ) ) ) ) ; return radius ; }
int getCount ( int N , int M ) { int total_count = 0 ; total_count += ( N / 10 ) ; int x = ( N / 10 ) * 10 ; if ( ( N - x ) >= M ) { total_count = total_count + 1 ; } return total_count ; }
int pairAndSum ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
int getDivisors ( int min , int n ) { int total = 0 ; for ( int i = min ; i < n ; ++ i ) if ( n % i == 0 && n / i >= i ) { ++ total ; if ( n / i > i ) total += getDivisors ( i , n / i ) ; } return total ; }
void findNum ( int n , int k ) { int q = k / ( n - 1 ) ; int r = k % ( n - 1 ) ; int a = 0 ; if ( r != 0 ) a = ( n * q ) + r ; else a = ( n * q ) - 1 ; Console . WriteLine ( a ) ; }
double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; }
void printOriginalMatrix ( int [ ] a , int [ ] b , int [ , ] mat ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i , j ] == 1 ) Console . Write ( Math . Min ( a [ i ] , b [ j ] ) + " ▁ " ) ; else Console . Write ( "0" + " ▁ " ) ; } Console . WriteLine ( ) ; } }
bool prodSquare ( int n ) { Dictionary < float , float > s = new Dictionary < float , float > ( ) ; for ( int i = 2 ; i * i <= n ; ++ i ) { s . Add ( ( float ) ( i * i ) , ( float ) 1 ) ; if ( s . ContainsKey ( ( float ) n / ( i * i ) ) ) return true ; } return false ; }
double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = ( Math . PI / 180 ) * ( lat2 - lat1 ) ; double dLon = ( Math . PI / 180 ) * ( lon2 - lon1 ) ; lat1 = ( Math . PI / 180 ) * ( lat1 ) ; lat2 = ( Math . PI / 180 ) * ( lat2 ) ; double a = Math . Pow ( Math . Sin ( dLat / 2 ) , 2 ) + Math . Pow ( Math . Sin ( dLon / 2 ) , 2 ) * Math . Cos ( lat1 ) * Math . Cos ( lat2 ) ; double rad = 6371 ; double c = 2 * Math . Asin ( Math . Sqrt ( a ) ) ; return rad * c ; }
double findRadius ( double r1 , double r2 , double r3 ) { double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * Math . Sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 ; }
double areaCircle ( double b ) { double area = ( double ) 3.1415926 * b * b ; return area ; }
void sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } }
string printBinary ( double num ) { if ( num >= 1 num <= 0 ) return " ERROR " ; string binary = " " ; double frac = 0.5 ; binary += " . " ; while ( num > 0 ) { if ( binary . Length >= 32 ) return " ERROR " ; if ( num >= frac ) { binary += "1" ; num -= frac ; } else binary += "0" ; frac /= 2 ; } return binary ; }
void countSamePrefixSuffix ( string s , int n ) { string prefix = " " ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix += s [ i ] ; string suffix = s . Substring ( n - 1 - i , i + 1 ) ; if ( prefix == suffix ) { Console . Write ( prefix . Length + " ▁ " ) ; } } }
int findMin ( int [ ] a , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . Log ( a [ i ] ) ; int x = ( int ) Math . Exp ( sum / n ) ; return x + 1 ; }
String getWinner ( String str , int len ) { int total = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' S ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " First " ; return " Second " ; }
int FindElement ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { int m = sum / n ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return - 1 ; }
float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; }
int solution ( ArrayList arr , int x ) { int closestSum = int . MaxValue ; for ( int i = 0 ; i < arr . Count ; i ++ ) { for ( int j = i + 1 ; j < arr . Count ; j ++ ) { for ( int k = j + 1 ; k < arr . Count ; k ++ ) { if ( Math . Abs ( x - closestSum ) > Math . Abs ( x - ( ( int ) arr [ i ] + ( int ) arr [ j ] + ( int ) arr [ k ] ) ) ) { closestSum = ( ( int ) arr [ i ] + ( int ) arr [ j ] + ( int ) arr [ k ] ) ; } } } } return closestSum ; }
void printSubstrings ( int n ) { int s = ( int ) Math . Log10 ( n ) ; int d = ( int ) ( Math . Pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { Console . WriteLine ( n / d ) ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } }
int minsteps ( int n , int m ) { if ( m > n ) { return - 1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }
string xoring ( string a , string b , int n ) { string ans = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == b [ i ] ) ans += "0" ; else ans += "1" ; } return ans ; }
int distinctRemainders ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) ; return ( 1 + ( n / 2 ) ) ; }
void radius ( double n , double d ) { Console . WriteLine ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " + d / ( ( n - 1 ) * Math . Sqrt ( 2 ) ) ) ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i , curr ] = l ; if ( r != - 1 ) dp [ i , curr ] = Math . Max ( dp [ i , curr ] , r + 1 ) ; return dp [ i , curr ] ; }
void decode_String ( String str , int K ) { String ans = " " ; for ( int i = 0 ; i < str . Length ; i += K ) ans += str [ i ] ; for ( int i = str . Length - ( K - 1 ) ; i < str . Length ; i ++ ) ans += str [ i ] ; Console . WriteLine ( ans ) ; }
int HogbenNumber ( int a ) { int p = ( int ) ( Math . Pow ( a , 2 ) - a + 1 ) ; return p ; }
int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
Boolean aredisjoint ( int [ ] set1 , int [ ] set2 ) { int i = 0 , j = 0 ; Array . Sort ( set1 ) ; Array . Sort ( set2 ) ; while ( i < set1 . Length && j < set2 . Length ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } return true ; }
int count_required_sequence ( int n , int [ ] arr ) { int total_required_subsequence = 0 ; int total_n_required_subsequence = 0 ; int [ , ] dp = new int [ N , 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { int turn_required = 0 ; for ( int j = - 1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j , 0 ] ; int required_end_i = ( total_required_subsequence + turn_required ) ; int n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] , 1 ] += required_end_i ; dp [ arr [ i ] , 0 ] += n_required_end_i ; } return total_required_subsequence ; }
int findkthElement ( int [ ] arr , int n , int K ) { int l = 0 ; int h = n - 1 , r ; while ( l + 1 < h ) { int mid = ( l + h ) / 2 ; if ( arr [ l ] >= arr [ mid ] ) l = mid ; else h = mid ; } if ( arr [ l ] < arr [ h ] ) r = l ; else r = h ; if ( K <= r + 1 ) return arr [ r + 1 - K ] ; else return arr [ n - ( K - ( r + 1 ) ) ] ; }
int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }
int calculateSum ( int n ) { return ( ( int ) Math . Pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / ( int ) Math . Pow ( 9 , 3 ) - n * ( n + 1 ) / 18 ; }
long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . Log10 ( n / M_E ) + Math . Log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . Floor ( x ) + 1 ; }
void countDigits ( string st , int n ) { if ( n > 0 ) { int cnt = 1 , i ; string st2 = " " ; for ( i = 1 ; i < st . Length ; i ++ ) { if ( st [ ( i ) ] == st [ ( i - 1 ) ] ) cnt ++ ; else { st2 += ( ( char ) 0 + ( char ) cnt ) ; st2 += st [ ( i - 1 ) ] ; cnt = 1 ; } } st2 += ( ( char ) 0 + ( char ) cnt ) ; st2 += st [ ( i - 1 ) ] ; countDigits ( st2 , -- n ) ; } else Console . Write ( st ) ; }
void radius ( int n , int d ) { Console . Write ( " The ▁ radius ▁ of ▁ each ▁ circle ▁ is ▁ " + d / ( 2 * n - 2 ) ) ; }
int minimiseMedian ( int [ ] arr , int n ) { Array . Sort ( arr ) ; return Math . Abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
void generateString ( int n ) { String s = " " ; for ( int i = 0 ; i < n ; i ++ ) s += ( ( i & 2 ) > 1 ? ' b ' : ' a ' ) ; Console . WriteLine ( s ) ; }
void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( Math . Sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
int centeredTetrahedralNumber ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
void isValid ( string s ) { int n = ( int ) Math . Sqrt ( s . Length ) ; char check = s [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = i , y = i ; while ( x >= 0 && y < n ) { if ( s [ ( n * x ) + y ] != check || s [ ( n * y ) + x ] != check ) { Console . Write ( " No " ) ; return ; } x -- ; y ++ ; } } Console . Write ( " Yes " ) ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
void constructArr ( int [ ] arr , int [ ] pair , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
int numberOfPaths ( int m , int n ) { int [ , ] count = new int [ m , n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i , 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 , j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) } return count [ m - 1 , n - 1 ] ; }
void findNumbers ( int n ) { String ans = " " ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans += '7' ; String even = ans + '6' ; String odd = ans + '7' ; Console . WriteLine ( " Even ▁ : ▁ " + even ) ; Console . WriteLine ( " Odd ▁ : ▁ " + odd ) ; }
bool DivisibleBy41 ( int first , int second , int c , int n ) { int [ ] digit = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
void printClosest ( int [ ] arr , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = int . MaxValue ; while ( r > l ) { if ( Math . Abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . Abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } Console . Write ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; }
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { Console . WriteLine ( ( x1 + x2 ) / 2 + " ▁ , ▁ " + ( y1 + y2 ) / 2 ) ; }
int term ( int n ) { return n * ( n + 1 ) / 2 ; }
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
float kPresentProbability ( int [ ] a , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; }
int findDivisor ( int x , int y ) { if ( x == y ) return y ; return 2 ; }
long countTriplets ( int A , int B , int C ) { long ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; }
int LISusingLCS ( List < int > seq ) { int n = seq . Count ; int [ , ] L = new int [ n + 1 , n + 1 ] ; List < int > sortedseq = new List < int > ( seq ) ; sortedseq . Sort ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; else L [ i , j ] = Math . Max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } return L [ n , n ] ; }
int maxBottles ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
int minCost ( int [ ] cost , int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int min_cost = Int32 . MaxValue ; for ( int j = 0 ; j < i ; j ++ ) if ( j < n && cost [ j ] != - 1 ) min_cost = Math . Min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; dp [ i ] = min_cost ; } return dp [ n ] ; }
void product_subarrays ( int [ ] arr , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } Console . Write ( product + " STRNEWLINE " ) ; }
int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; Console . Write ( ith_term + " , ▁ " ) ; } }
int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
char nextGreatestAlphabet ( char [ ] alphabets , char K ) { int n = alphabets . Length ; if ( K >= alphabets [ n - 1 ] ) return alphabets [ 0 ] ; int l = 0 , r = alphabets . Length - 1 ; int ans = - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
int countDigits ( int a , int b ) { int count = 0 ; int p = Math . Abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
double innerCirclearea ( double radius ) { if ( radius < 0 ) { return - 1 ; } double r = radius / 2 ; double Area = ( 3.14 * Math . Pow ( r , 2 ) ) ; return Area ; }
double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; bool sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
void getIndex ( int n , int [ , ] shuffle ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i , 0 ] == n ) n = shuffle [ i , 1 ] ; else if ( shuffle [ i , 1 ] == n ) n = shuffle [ i , 0 ] ; } Console . WriteLine ( n ) ; }
void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { Console . Write ( i + " , ▁ " + j + " , ▁ " + k ) ; return ; } } } Console . Write ( " No ▁ Triplet " ) ; }
int findSmallest ( int [ ] arr , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
int findDuplicate ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 ; while ( i < n ) { int j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; }
long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
char first ( string str ) { for ( int i = 0 ; i < str . Length ; i ++ ) if ( char . IsUpper ( str [ i ] ) ) return str [ i ] ; return '0' ; }
String check ( int S , int [ ] prices , int [ ] type , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return " Yes " ; } } } } return " No " ; }
void findAngles ( double a , double b , double c , double d ) { double numerator = a * a + d * d - b * b - c * c ; double denominator = 2 * ( a * b + c * d ) ; double x = numerator / denominator ; Console . WriteLine ( " A : ▁ " + Math . Round ( ( ( Math . Acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; numerator = a * a + b * b - c * c - d * d ; x = numerator / denominator ; Console . WriteLine ( " B : ▁ " + Math . Round ( ( ( Math . Acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; numerator = c * c + b * b - a * a - d * d ; x = numerator / denominator ; Console . WriteLine ( " C : ▁ " + Math . Round ( ( ( Math . Acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; numerator = d * d + c * c - a * a - b * b ; x = numerator / denominator ; Console . WriteLine ( " D : ▁ " + Math . Round ( ( ( Math . Acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; }
int minimumAdjacentDifference ( int [ ] a , int n , int k ) { int minDiff = int . MaxValue ; for ( int i = 0 ; i <= k ; i ++ ) { int maxDiff = int . MinValue ; for ( int j = 0 ; j < n - k - 1 ; j ++ ) { for ( int p = i ; p <= i + j ; p ++ ) { maxDiff = Math . Max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; } } minDiff = Math . Min ( minDiff , maxDiff ) ; } return minDiff ; }
int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m > 0 ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m /= 2 ; } return ans ; }
void checkCount ( int [ ] A , int [ , ] Q , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i , 0 ] ; int R = Q [ i , 1 ] ; L -- ; R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
void maxSide ( int [ ] a , int n ) { int sideLength = 0 ; Array . Sort ( a ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } Console . Write ( sideLength ) ; }
bool check ( int [ ] a , int n ) { int ma = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = Math . Max ( ma , Math . Abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } Console . Write ( " Amplitude ▁ = ▁ " + ma ) ; Console . WriteLine ( ) ; return true ; }
void printPalindrome ( int n ) { if ( n == 1 ) { Console . WriteLine ( " Smallest ▁ Palindrome : ▁ 0" ) ; Console . WriteLine ( " Largest ▁ Palindrome : ▁ 9" ) ; } else { Console . WriteLine ( " Smallest ▁ Palindrome : ▁ " + ( int ) ( Math . Pow ( 10 , n - 1 ) ) + 1 ) ; Console . WriteLine ( " Largest ▁ Palindrome : ▁ " + ( ( int ) ( Math . Pow ( 10 , n ) ) - 1 ) ) ; } }
int countP ( int n , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 , k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i , j ] = 1 ; else dp [ i , j ] = j * dp [ i - 1 , j ] + dp [ i - 1 , j - 1 ] ; return dp [ n , k ] ; }
int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
void findAngle ( int n ) { int interiorAngle , exteriorAngle ; interiorAngle = ( n - 2 ) * 180 / n ; exteriorAngle = 360 / n ; Console . Write ( " Interior ▁ angle : ▁ " + interiorAngle + " STRNEWLINE " ) ; Console . Write ( " Exterior ▁ angle : ▁ " + exteriorAngle ) ; }
int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) count += 1 ; } return count ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) - 4 * n + 2 ; }
void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { Console . Write ( fact + " ▁ " ) ; fact = fact * x ; x ++ ; } }
int getPairs ( int [ ] a ) { int n = a . Length ; int count = ( n * ( n - 1 ) ) / 2 ; return count ; }
int CountWays ( int r , int b , int l , int R , int B , int W , int [ , , ] dp ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r , b , l ] != - 1 ) return dp [ r , b , l ] ; int ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r , b , l ] = ans ; }
int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
int lbs ( int [ ] arr , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
int minJumps ( int [ ] arr , int N ) { int MAX = 1000000 ; int [ ] fib = new int [ 30 ] ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int [ ] DP = new int [ N + 2 ] ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { for ( int j = 1 ; j < 30 ; j ++ ) { if ( ( i == N + 1 arr [ i - 1 ] == 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = Math . Min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return - 1 ; }
void Main ( ) { int n = 5 , k = 42 ; char [ ] arr = lexo_small ( n , k ) ; Console . WriteLine ( new string ( arr ) ) ; } }
bool isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
int difference ( int n ) { int S , res ; S = ( n * ( n + 1 ) ) / 2 ; res = S * ( S - 1 ) ; return res ; }
float harmonicMean ( float [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }
bool isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( Math . Ceiling ( a ) == 1 && Math . Floor ( a ) == 1 ) return true ; return false ; }
void printSumSimple ( int [ , ] mat , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p , q ] ; Console . Write ( sum + " ▁ " ) ; } Console . WriteLine ( ) ; } }
bool isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
void printIntersection ( int [ , ] A , int [ , ] B ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i , j ] == B [ i , j ] ) Console . Write ( A [ i , j ] + " ▁ " ) ; else Console . Write ( " * ▁ " ) ; } Console . WriteLine ( " ▁ " ) ; } }
int findMaxSum ( int [ ] arr , int n ) { int res = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . Max ( res , prefix_sum ) ; } return res ; }
int XorSum ( int [ ] A , int [ ] B , int N , int M ) { int ans1 = 0 , ans2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( int i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
int xorOfSum ( int [ ] a , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
int maxArea ( int [ ] a ) { int Area = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { for ( int j = i + 1 ; j < a . Length ; j ++ ) { Area = Math . Max ( Area , Math . Min ( a [ i ] , a [ j ] ) * ( j - i ) ) ; } } return Area ; }
void alter ( long x , long y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } Console . WriteLine ( " X ▁ = ▁ " + x + " , ▁ " + " Y ▁ = ▁ " + y ) ; }
float sumOfSeries ( int x , int k ) { float y = ( float ) ( ( ( float ) ( x ) / 81 ) * ( 9 * k - 1 + Math . Pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }
float avgOfFirstN ( int n ) { return ( float ) ( 1 + n ) / 2 ; }
int highestPower ( int n ) { return ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; }
bool ishexadecagonal ( int N ) { double n = ( 12 + Math . Sqrt ( 112 * N + 144 ) ) / 28 ; return ( n - ( int ) n ) == 0 ; }
int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
int MatrixChainOrder ( int [ ] p , int n ) { int [ , ] m = new int [ n , n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i , i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i , j ] = int . MaxValue ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i , k ] + m [ k + 1 , j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i , j ] ) m [ i , j ] = q ; } } } return m [ 1 , n - 1 ] ; }
int Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / N1 ; return ( int ) rate ; }
int findSmallestDifference ( int [ ] A , int [ ] B , int m , int n ) { Array . Sort ( A ) ; Array . Sort ( B ) ; int a = 0 , b = 0 ; int result = int . MaxValue ; while ( a < m && b < n ) { if ( Math . Abs ( A [ a ] - B [ b ] ) < result ) result = Math . Abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
int getTotalNumberOfSequences ( int m , int n ) { int [ , ] T = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i , j ] = 0 ; else if ( i < j ) T [ i , j ] = 0 ; else if ( j == 1 ) T [ i , j ] = i ; else T [ i , j ] = T [ i - 1 , j ] + T [ i / 2 , j - 1 ] ; } } return T [ m , n ] ; }
int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; }
void newvol ( double x ) { Console . Write ( " percentage ▁ increase ▁ " + " in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ " + ( Math . Pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . Pow ( x , 2 ) ) / 100 ) ) ; Console . Write ( " % " ) ; }
void positions ( string str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ( str [ i ] & NUM ) + " ▁ " ) ; } }
void leastBricks ( List < List < int > > wall ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int res = 0 ; foreach ( List < int > subList in wall ) { int width = 0 ; for ( int i = 0 ; i < subList . Count - 1 ; i ++ ) { width += subList [ i ] ; if ( map . ContainsKey ( width ) ) map [ width ] ++ ; else map . Add ( width , 1 ) ; res = Math . Max ( res , map [ width ] ) ; } } Console . Write ( wall . Count - res ) ; }
int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
int tripletAndSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & ( 1 << bit ) ) != 0 ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; }
int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
bool isValid ( string str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
String perfectSquare ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int p = ( int ) Math . Sqrt ( arr [ i ] ) ; if ( p * p != arr [ i ] ) { return " No " ; } } return " Yes " ; }
int largestCoprime ( int N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
void oppositeFaceOfDice ( int N ) { int ans = 7 - N ; Console . Write ( ans ) ; }
int countPaths ( int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 , i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] ; return dp [ n , m ] ; }
void findBalance ( int x , float bal ) { if ( x % 10 == 0 && ( ( float ) x + 1.50 ) <= bal ) { Console . Write ( " { 0 : F2 } STRNEWLINE " , bal - x - 1.50 ) ; } else { Console . Write ( " { 0 : F2 } STRNEWLINE " , bal ) ; } }
int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; }
bool aredisjoint ( int [ ] set1 , int [ ] set2 ) { for ( int i = 0 ; i < set1 . Length ; i ++ ) { for ( int j = 0 ; j < set2 . Length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) { return false ; } } } return true ; }
bool IsRedundantBraces ( string A ) { int a = 0 , b = 0 ; for ( int i = 0 ; i < A . Length ; i ++ ) { if ( A [ i ] == ' ( ' && A [ i + 2 ] == ' ) ' ) return true ; if ( A [ i ] == ' * ' A [ i ] == ' + ' A [ i ] == ' - ' A [ i ] == ' / ' ) a ++ ; if ( A [ i ] == ' ( ' ) b ++ ; } if ( b > a ) return true ; return false ; }
int cntCells ( int n ) { int cells = ( int ) Math . Pow ( n , 2 ) + ( int ) Math . Pow ( n - 1 , 2 ) ; return cells ; }
bool isPossible ( int [ ] arr , int p , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
int minOperation ( int k ) { int [ ] dp = new int [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . Min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { Console . WriteLine ( " Angle ▁ cannot " + " ▁ be ▁ formed " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
double getTime ( int u , int v , int x ) { double speed = u + v ; double time = x / speed ; return time ; }
int maxSumBitonicSubArr ( int [ ] arr , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = int . MinValue ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
int ceilSearch ( int [ ] arr , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
bool isSymmetric ( int [ , ] mat , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i , j ] != mat [ j , i ] ) return false ; return true ; }
int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
int Divisible ( int [ ] arr , int n ) { int count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) count_even ++ ; return count_even + ( n - count_even ) / 2 ; }
int minSum ( int [ ] A , int n ) { int min_val = A . Min ( ) ; return ( min_val * ( n - 1 ) ) ; }
int NthComposite ( int N ) { int MAX_SIZE = 1000005 ; bool [ ] IsPrime = new bool [ MAX_SIZE ] ; Array . Fill ( IsPrime , true ) ; for ( int p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( int i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } List < int > Composites = new List < int > ( ) ; for ( int p = 4 ; p < MAX_SIZE ; p ++ ) if ( ! IsPrime [ p ] ) Composites . Add ( p ) ; return Composites [ N - 1 ] ; }
int minimumRectangleArea ( int [ ] A , int N ) { int ans ; Array . Sort ( A ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = Math . Min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
void nDigitPerfectCubes ( int n ) { int smallest = ( int ) Math . Pow ( Math . Ceiling ( MathF . Cbrt ( ( float ) Math . Pow ( 10 , ( n - 1 ) ) ) ) , 3 ) ; Console . Write ( smallest + " ▁ " ) ; int largest = ( int ) Math . Pow ( Math . Ceiling ( MathF . Cbrt ( ( float ) Math . Pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ; Console . Write ( largest ) ; }
int countNestedPolygons ( int sides ) { int count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; }
int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; }
int minSum ( int [ ] arr , int n , int x ) { int sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; int sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . Min ( sum , sumAfterOperation ) ; }
void flippingBits ( int N , int K ) { int X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; Console . Write ( N ) ; }
int CountWays ( int N , int M ) { int count = 1 ; count = ( int ) Math . Pow ( 3 , M + N ) ; count *= ( int ) Math . Pow ( 2 , M * N ) ; return count ; }
int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
bool canBeSumofConsec ( int n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; }
int findMaxPoints ( int [ , ] A ) { int [ , ] P1S = new int [ M + 2 , N + 2 ] ; int [ , ] P1E = new int [ M + 2 , N + 2 ] ; int [ , ] P2S = new int [ M + 2 , N + 2 ] ; int [ , ] P2E = new int [ M + 2 , N + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1S [ i , j ] = Math . Max ( P1S [ i - 1 , j ] , P1S [ i , j - 1 ] ) + A [ i - 1 , j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = M ; j >= 1 ; j -- ) P1E [ i , j ] = Math . Max ( P1E [ i + 1 , j ] , P1E [ i , j + 1 ] ) + A [ i - 1 , j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2S [ i , j ] = Math . Max ( P2S [ i + 1 , j ] , P2S [ i , j - 1 ] ) + A [ i - 1 , j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2E [ i , j ] = Math . Max ( P2E [ i - 1 , j ] , P2E [ i , j + 1 ] ) + A [ i - 1 , j - 1 ] ; int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i , j - 1 ] + P1E [ i , j + 1 ] + P2S [ i + 1 , j ] + P2E [ i - 1 , j ] ; int op2 = P1S [ i - 1 , j ] + P1E [ i + 1 , j ] + P2S [ i , j - 1 ] + P2E [ i , j + 1 ] ; ans = Math . Max ( ans , Math . Max ( op1 , op2 ) ) ; } } return ans ; }
string isDivisibleByDivisor ( int S , int D ) { S %= D ; List < int > hashMap = new List < int > ( ) ; ; hashMap . Add ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . Contains ( S ) ) { if ( S == 0 ) { return " Yes " ; } return " No " ; } else hashMap . Add ( S ) ; } return " Yes " ; }
void findNumbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) Console . Write ( "1" + " ▁ " ) ; Console . Write ( "2" + " ▁ " ) ; Console . Write ( n + d ) ; }
void singleDigitSubarrayCount ( int [ ] arr , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } Console . Write ( res ) ; }
void search ( String txt , String pat ) { int M = pat . Length ; int N = txt . Length ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) Console . WriteLine ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } }
int maxScore ( int [ ] arr ) { int N = arr . Length ; N ++ ; int [ , ] dp = new int [ N + 1 , 2 * ( N - 1 ) + 1 ] ; dp [ 0 , 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int s = 1 ; s <= 2 * ( N - 1 ) ; s ++ ) { for ( int j = 1 ; j <= N - 1 && j <= s ; j ++ ) { dp [ i , s ] = Math . Max ( dp [ i , s ] , arr [ j - 1 ] + dp [ i - 1 , s - j ] ) ; } } } return dp [ N , 2 * ( N - 1 ) ] - 1 ; }
void checkPascaltriangle ( int N ) { double x = ( Math . Sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( Math . Ceiling ( x ) - x == 0 ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
void isCycleExists ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { Console . WriteLine ( " Yes " ) ; return ; } } Console . WriteLine ( " No " ) ; }
bool findPair ( int [ ] arr , int n ) { int size = arr . Length ; int i = 0 , j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { Console . Write ( " Pair ▁ Found : ▁ " + " ( ▁ " + arr [ i ] + " , ▁ " + arr [ j ] + " ▁ ) " ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } Console . Write ( " No ▁ such ▁ pair " ) ; return false ; }
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( float ) Math . Pow ( h , 3 ) ; return a ; }
void minOpsToEmptyString ( string s ) { int ans = 0 ; int cn0 = 0 ; int cn1 = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . Max ( ans , Math . Max ( cn0 , cn1 ) ) ; } Console . Write ( ans ) ; }
bool isdecagonal ( int N ) { double n = ( 3 + Math . Sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - ( int ) n ) == 0 ; }
int reduceZero ( int N ) { int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) dp [ i ] = ( int ) 1e9 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { foreach ( char c in String . Join ( " " , i ) . ToCharArray ( ) ) { dp [ i ] = Math . Min ( dp [ i ] , dp [ i - ( c - '0' ) ] + 1 ) ; } } return dp [ N ] ; }
int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( int ) ( ( first_term * ( Math . Pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . Pow ( 2 , N - 1 ) ) - 1 ) ) ; return nth ; }
int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
int sameEulerTotient ( int N ) { return ( N & 1 ) ; }
void isEqualSubstring ( string str , int x ) { int n = str . Length ; int i = 0 ; while ( i < n && i < x ) { if ( str [ i ] != str [ n - i - 1 ] ) { Console . Write ( " false " ) ; return ; } i ++ ; } Console . Write ( " true " ) ; }
int countTriplets ( int [ ] arr , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } int c1 = odd * ( even * ( even - 1 ) ) / 2 ; int c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ; return c1 + c2 ; }
void waysToPaint ( int n ) { long same = 6 ; long diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } Console . WriteLine ( same + diff ) ; }
int find_and ( int [ ] arr ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) { ans = ( ans & arr [ i ] ) ; } return ans ; }
string findString ( string [ ] arr , int N ) { string ans = " " ; for ( int i = 0 ; i < N ; i ++ ) { ans += arr [ i ] [ i ] == '0' ? '1' : '0' ; } return ans ; }
void find_rectangle ( int area ) { int l = 0 , b = 0 ; int M = ( int ) Math . Sqrt ( area ) ; for ( int i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } Console . WriteLine ( " l ▁ = ▁ " + l + " , ▁ b ▁ = ▁ " + b ) ; }
int xorPairSum ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; }
float gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . Abs ( b ) < 0.001 ) return ( float ) a ; else return ( float ) ( gcd ( b , a - Math . Floor ( a / b ) * b ) ) ; }
int NoCarrySum ( int N , int M ) { return N ^ M ; }
int findMinSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
bool isPossible ( int n ) { int [ ] fac = new int [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; }
void leftRotate ( int [ ] arr , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) Console . Write ( arr [ i % n ] + " ▁ " ) ; }
int findCount ( int [ , ] mat , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 , 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i , j , m ] ) return dp [ i , j , m ] ; v [ i , j , m ] = true ; dp [ i , j , m ] = findCount ( mat , i - 1 , j , m - mat [ i , j ] ) + findCount ( mat , i , j - 1 , m - mat [ i , j ] ) ; return dp [ i , j , m ] ; }
void linearCongruentialMethod ( int Xo , int m , int a , int c , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } }
void hasEqualBlockFrequency ( int N ) { string S = Convert . ToString ( N , 2 ) ; HashSet < int > p = new HashSet < int > ( ) ; int c = 1 ; for ( int i = 0 ; i < S . Length - 1 ; i ++ ) { if ( S [ i ] == S [ i + 1 ] ) c += 1 ; else { p . Add ( c ) ; c = 1 ; } p . Add ( c ) ; } if ( p . Count == 1 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
void findMaximumProfit ( int [ ] arr , int M , int N ) { List < int > max_heap = new List < int > ( ) ; int maxProfit = 0 ; for ( int i = 0 ; i < N ; i ++ ) max_heap . Add ( arr [ i ] ) ; max_heap . Sort ( ) ; max_heap . Reverse ( ) ; while ( M > 0 ) { M -- ; int X = max_heap [ 0 ] ; max_heap . RemoveAt ( 0 ) ; maxProfit += X ; max_heap . Add ( X - 1 ) ; max_heap . Sort ( ) ; max_heap . Reverse ( ) ; } Console . Write ( maxProfit ) ; }
int squares ( int l , int b , int a ) { return ( int ) ( Math . Ceiling ( l / ( double ) a ) * Math . Ceiling ( b / ( double ) a ) ) ; }
int cntSubArrays ( int [ ] arr , int n , int k ) { int res = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; res += Math . Max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }
void printFreq ( int [ ] arr , int N ) { int freq = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { freq ++ ; } else { Console . WriteLine ( " Frequency ▁ of ▁ " + arr [ i - 1 ] + " ▁ is : ▁ " + freq ) ; freq = 1 ; } } Console . WriteLine ( " Frequency ▁ of ▁ " + arr [ N - 1 ] + " ▁ is : ▁ " + freq ) ; }
bool ToCheckPowerofX ( int n , int x ) { while ( n > 0 ) { int rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; }
String isPossible ( int [ ] arr , int n ) { int mini = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) mini = Math . Min ( mini , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; int Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return " No " ; } return " Yes " ; }
bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
void constructXOR ( int [ ] A , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
int subsetXOR ( int [ ] arr , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . Log ( max_ele , 2 ) + 1 ) ) - 1 ; if ( k > m ) { return 0 ; } int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i , j ] = 0 ; dp [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 1 , j ^ arr [ i - 1 ] ] ; return dp [ n , k ] ; }
double findsolution ( double d , double h , double m , double n ) { double k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return - 1 ; double ans = ( h / ( k - n ) ) ; return ans ; }
double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ; t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
void convertToASCII ( int N ) { String num = N . ToString ( ) ; foreach ( char ch in num . ToCharArray ( ) ) { Console . Write ( ch + " ▁ ( " + ( int ) ch + " ) STRNEWLINE " ) ; } }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int count ( int n ) { return ( - 1 + ( int ) Math . Sqrt ( 1 + 8 * n ) ) / 2 ; }
void subString ( string str , int n ) { for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; for ( int k = i ; k <= j ; k ++ ) Console . Write ( str [ k ] ) ; Console . WriteLine ( ) ; } } }
double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / Math . Pow ( i , i ) ; sums += ser ; } return sums ; }
int linearCheck ( int [ , ] ar , int [ ] arr ) { for ( int i = 0 ; i < m ; i ++ ) { bool matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ar [ i , j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; }
bool isOctadecagon ( int N ) { double n = ( 14 + Math . Sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - ( int ) n ) == 0 ; }
int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . Floor ( Math . Sqrt ( N ) ) + 1 ; return nextN * nextN ; }
int productAtKthLevel ( string tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; }
int countPoints ( int n , int m , int [ ] a , int [ ] b , int x , int y ) { Array . Sort ( a ) ; Array . Sort ( b ) ; int j = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; }
int findElement ( int [ ] arr , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
void performQueries ( String str , int n , int [ , ] queries , int q ) { int ptr = 0 ; for ( int i = 0 ; i < q ; i ++ ) { if ( queries [ i , 0 ] == 1 ) { ptr = ( ptr + queries [ i , 1 ] ) % n ; } else { int k = queries [ i , 1 ] ; int index = ( ptr + k - 1 ) % n ; Console . WriteLine ( str [ index ] ) ; } } }
long evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
bool is_Chiliagon ( int N ) { float n = ( float ) ( 996 + Math . Sqrt ( 7984 * N + 992016 ) ) / 1996 ; return ( n - ( int ) n ) == 0 ; }
string even_or_odd ( string N ) { int len = N . Length ; if ( N [ len - 1 ] == '0' N [ len - 1 ] == '2' N [ len - 1 ] == '4' N [ len - 1 ] == '6' N [ len - 1 ] == '8' N [ len - 1 ] == ' A ' N [ len - 1 ] == ' C ' N [ len - 1 ] == ' E ' ) return ( " Even " ) ; else return ( " Odd " ) ; }
int minimumHammingDistance ( string S , int K ) { int n = S . Length ; int [ ] pref = new int [ n ] ; pref [ 0 ] = ( int ) S [ 0 ] - 48 ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( ( int ) S [ i ] - 48 ) ; int cnt = pref [ n - 1 ] ; int ans = cnt ; for ( int i = 0 ; i < n - K ; i ++ ) { int value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = Math . Min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
double circumference ( double r ) { double PI = 3.1415 ; double cir = 2 * PI * r ; return cir ; }
void checkArrays ( int [ ] arr1 , int [ ] arr2 , int N ) { int count = 0 ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = false ; break ; } } } } if ( ( flag && ( count == 0 ) ) == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
void checkSolution ( int a , int b , int c ) { if ( b == 0 ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
int min_noOf_operation ( int [ ] arr , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
int numberOfElements ( int [ ] height , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
int findK ( int [ ] arr , int size , int N ) { Array . Sort ( arr ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; }
void factors ( int n , int i ) { if ( i <= n ) { if ( n % i == 0 ) { Console . WriteLine ( i + " ▁ " ) ; } factors ( n , i + 1 ) ; } }
long moduloMultiplication ( long a , long b , long mod ) { a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; } return res ; }
void findRemainders ( long n ) { List < long > vc = new List < long > ( ) ; for ( long i = 1 ; i <= Math . Ceiling ( Math . Sqrt ( n ) ) ; i ++ ) vc . Add ( n / i ) ; for ( long i = ( long ) ( n / Math . Ceiling ( Math . Sqrt ( n ) ) - 1 ) ; i >= 0 ; i -- ) vc . Add ( i ) ; vc . Reverse ( ) ; foreach ( long it in vc ) Console . Write ( it + " ▁ " ) ; }
int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . Abs ( sumSet1 - sumSet2 ) ; }
void minimumDifference ( int N ) { int sum1 = ( 1 << N ) , sum2 = 0 ; for ( int i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( int i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; Console . WriteLine ( sum1 - sum2 ) ; }
int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; }
void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; Console . WriteLine ( num ) ; }
int sum_star_num ( int n ) { int summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
int countSubsequece ( int [ ] a , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }
int checkValidity ( int a , int b , int c ) { if ( a + b <= c a + c <= b b + c <= a ) return 0 ; else return 1 ; }
int maximumTurns ( int [ ] arr , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; }
long findWays ( int f , int d , int s ) { long [ , ] mem = new long [ d + 1 , s + 1 ] ; mem [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i , j ] = mem [ i , j - 1 ] + mem [ i - 1 , j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i , j ] -= mem [ i - 1 , j - f - 1 ] ; } } return mem [ d , s ] ; }
int optimalStrategyOfGame ( int [ ] arr , int n ) { int [ , ] table = new int [ n , n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 , j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 , j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i , j - 2 ] : 0 ; table [ i , j ] = Math . Max ( arr [ i ] + Math . Min ( x , y ) , arr [ j ] + Math . Min ( y , z ) ) ; } } return table [ 0 , n - 1 ] ; }
void leftRotate ( int [ ] arr , int d , int n ) { int i , j ; if ( d == 0 d == n ) return ; i = d ; j = n - d ; while ( i != j ) { if ( i < j ) { swap ( arr , d - i , d + j - i , i ) ; j -= i ; } else { swap ( arr , d - i , d , j ) ; i -= j ; } } swap ( arr , d - i , d , i ) ; }
bool canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Array . Sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
int countPoints ( int D ) { int count = 0 ; for ( int x = 1 ; x * x < D * D ; x ++ ) { int y = ( int ) Math . Sqrt ( ( D * D - x * x ) ) ; if ( x * x + y * y == D * D ) { count += 4 ; } } count += 4 ; return count ; }
int countChar ( string str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( str [ i ] == x ) count ++ ; int repetitions = n / str . Length ; count = count * repetitions ; for ( int i = 0 ; i < n % str . Length ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; }
float getPercentile ( int rank , int students ) { float result = ( float ) ( students - rank ) / students * 100 ; return result ; }
int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = ( int ) Math . Pow ( 10 , digit - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
void check_euler_four_square_identity ( int a , int b , int ab ) { int s = 0 ; for ( int i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( int j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( int k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( int l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { Console . Write ( " i ▁ = ▁ " + i + " STRNEWLINE " ) ; Console . Write ( " j ▁ = ▁ " + j + " STRNEWLINE " ) ; Console . Write ( " k ▁ = ▁ " + k + " STRNEWLINE " ) ; Console . Write ( " l ▁ = ▁ " + l + " STRNEWLINE " ) ; Console . Write ( " Product ▁ of ▁ " + a + " ▁ and ▁ " + b ) ; Console . Write ( " ▁ can ▁ be ▁ written " + " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " + " j , ▁ k , ▁ l STRNEWLINE " ) ; Console . Write ( ab + " ▁ = ▁ " ) ; Console . Write ( i + " * " + i + " ▁ + ▁ " ) ; Console . Write ( j + " * " + j + " ▁ + ▁ " ) ; Console . Write ( k + " * " + k + " ▁ + ▁ " ) ; Console . Write ( l + " * " + l + " STRNEWLINE " ) ; Console . Write ( " STRNEWLINE " ) ; } } } } } }
int minCount ( int [ ] arr , int n , int k ) { int ans = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; int l = 0 ; int r = 0 ; int tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = Math . Max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
int clearBit ( int num , int i ) { int mask = ~ ( 1 << i ) ; return num & mask ; }
void splitArr ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
void TowerOfHanoi ( int N ) { for ( int x = 1 ; x <= Math . Pow ( 2 , N ) - 1 ; x ++ ) { Console . Write ( " Move ▁ from ▁ Rod ▁ " + ( ( x & x - 1 ) % 3 + 1 ) + " ▁ to ▁ Rod ▁ " + ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) + " STRNEWLINE " ) ; } }
void printSumSeries ( int N ) { float sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( float ) 1.0 / ( 2 * i - 1 ) ; } Console . WriteLine ( sum ) ; }
void contain ( int L , int U , int M ) { int count = 0 ; for ( int j = L ; j < U ; j ++ ) { HashSet < string > num = new HashSet < string > ( ) ; string str = j . ToString ( ) ; num . Add ( str ) ; if ( j % M == 0 && ! num . Contains ( M . ToString ( ) ) ) { count += 1 ; } } Console . Write ( count - 2 ) ; }
int countDigits ( int a , int b ) { double digits = Math . Log10 ( Math . Abs ( a ) ) - Math . Log10 ( Math . Abs ( b ) ) + 1 ; return ( int ) Math . Floor ( digits ) ; }
bool isStraighLineNum ( int N ) { if ( N <= 99 ) return false ; string s = N . ToString ( ) ; int d = s [ 1 ] - s [ 0 ] ; for ( int i = 2 ; i < s . Length ; i ++ ) if ( s [ i ] - s [ i - 1 ] != d ) return false ; return true ; }
void replace_elements ( int [ ] arr , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; }
String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " No " ; n = n >> 1 ; } return " Yes " ; }
int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
void rearrage ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; int small = 0 , large = n - 1 ; bool flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
String removeDuplicates ( String str ) { int n = str . Length ; String res = " " ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) break ; if ( j == n ) res = res + str [ i ] ; } return res ; }
bool checkCentrosymmetricted ( int n , int [ , ] m ) { int mid_row ; if ( ( n & 1 ) > 0 ) mid_row = n / 2 + 1 ; else mid_row = n / 2 ; for ( int i = 0 ; i < mid_row ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i , j ] != m [ n - i - 1 , n - j - 1 ] ) return false ; } } return true ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
long count_triples ( int n , int k ) { int i = 0 , j = 0 , l = 0 ; int count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { for ( l = 1 ; l <= n ; l ++ ) { if ( ( i + j ) % k == 0 && ( i + l ) % k == 0 && ( j + l ) % k == 0 ) count ++ ; } } } return count ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) - n - 1 ; }
bool checkEquilibrium ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int resx = x1 + x2 + x3 ; int resy = y1 + y2 + y3 ; int resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; }
double findAverage ( int N ) { double avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
void reorder ( ) { for ( int i = 0 ; i < arr . Length ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; char oldTargetE = ( char ) arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }
bool isCenterednonadecagonal ( int N ) { float n = ( float ) ( ( 19 + Math . Sqrt ( 152 * N + 209 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; }
void check ( int n ) { HashSet < int > digits = new HashSet < int > ( ) ; int temp = n ; int sum = 0 ; int count = 0 ; while ( temp > 0 ) { sum += temp % 10 ; digits . Add ( temp % 10 ) ; count ++ ; temp = temp / 10 ; } if ( sum % count == 0 && digits . Contains ( sum / count ) ) Console . Write ( " Yes " + " STRNEWLINE " ) ; else Console . Write ( " No " + " STRNEWLINE " ) ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
void printValueOfPi ( int N ) { double pi = 2 * Math . Acos ( 0.0 ) ; Console . WriteLine ( pi ) ; }
int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; }
bool canVote ( int [ ] a , int n , int x ) { int [ , ] dp = new int [ n + 1 , x + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < x + 1 ; j ++ ) { dp [ i , j ] = 0 ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , a [ i ] + dp [ i - 1 , j - a [ i ] ] ) ; else dp [ i , j ] = dp [ i - 1 , j ] ; return ( sum - dp [ n , x ] >= x ) ; }
double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = Math . Sqrt ( temp ) ; return result ; }
int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
int minCost ( int [ ] a , int n , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i , j ] = inf ; dp [ 0 , 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i , j ] = Math . Min ( dp [ i , j ] , dp [ m , j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n , k ] ; }
int minimum_sum ( int [ ] A , int N ) { Array . Sort ( A ) ; int sum = 2147483647 ; for ( int i = 0 ; i <= N - 3 ; i ++ ) { sum = Math . Min ( sum , Math . Abs ( A [ i ] - A [ i + 1 ] ) + Math . Abs ( A [ i + 1 ] - A [ i + 2 ] ) ) ; } return sum ; }
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( int ) ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ; Array . Sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double median1 = arr [ size / 2 ] ; return median1 ; }
int changeTheArray ( int [ ] arr , int n ) { int minEle = arr . Min ( ) ; int maxEle = arr . Max ( ) ; int minOperations = int . MaxValue ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . Abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . Min ( minOperations , operations ) ; } return minOperations ; }
void dupLastIndex ( int [ ] arr , int n ) { if ( arr == null n <= 0 ) return ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { Console . WriteLine ( " Last ▁ index : " + i ) ; Console . WriteLine ( " Last ▁ duplicate ▁ item : ▁ " + arr [ i ] ) ; return ; } } Console . WriteLine ( " no ▁ duplicate ▁ found " ) ; }
int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; }
int Remainder ( String str , int R ) { int len = str . Length ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - '0' ) ; Rem = Num % R ; } return Rem ; }
bool check ( int [ ] arr , int x , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double y = Math . Sqrt ( arr [ i ] ) ; if ( Math . Floor ( y ) == Math . Ceiling ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; }
int getMinSteps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; }
void findSides ( double A , double C , double c ) { double B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; double a = ( c / Math . Sin ( C ) ) * Math . Sin ( A ) ; double b = ( c / Math . Sin ( C ) ) * Math . Sin ( B ) ; Console . WriteLine ( " { 0 : F2 } " , a ) ; Console . WriteLine ( " { 0 : F2 } " , b ) ; }
void makeZero ( int x , int y , int a , int b ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int tot_cost = ( y - x ) * a ; int cost1 = 2 * x * a ; int cost2 = x * b ; tot_cost += Math . Min ( cost1 , cost2 ) ; Console . Write ( tot_cost ) ; }
int countways ( int n ) { int [ ] A = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( h * r * ( float ) Math . Sqrt ( 2 ) ) / ( h + ( float ) Math . Sqrt ( 2 ) * r ) ; return a ; }
int getPairsCount ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . Abs ( arr [ i ] - arr [ j ] ) >= Math . Min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
int FindMaxSum ( int [ ] arr , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
int binarySearch ( int [ ] arr , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }
int countGroups ( int position , int previous_sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
void printRepeating ( int [ ] arr , int size ) { int i , j ; Console . Write ( " Repeated ▁ Elements ▁ are ▁ : " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) Console . Write ( arr [ i ] + " ▁ " ) ; } } }
> Diagonals ( int a , int b , int c , int d ) { List < float > ans = new List < float > ( ) ; ans . Add ( ( float ) Math . Sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; ans . Add ( ( float ) Math . Sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return ans ; }
void findRightAngle ( double A , double H ) { double D = Math . Pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { double root1 = ( H * H + Math . Sqrt ( D ) ) / 2 ; double root2 = ( H * H - Math . Sqrt ( D ) ) / 2 ; double a = Math . Sqrt ( root1 ) ; double b = Math . Sqrt ( root2 ) ; if ( b >= a ) Console . WriteLine ( a + " ▁ " + b + " ▁ " + H ) ; else Console . WriteLine ( b + " ▁ " + a + " ▁ " + H ) ; } else Console . WriteLine ( " - 1" ) ; }
int minOperations ( String s ) { int len = s . Length ; int result = 0 ; for ( int i = 0 ; i < len / 2 ; i ++ ) { int D1 = Math . Max ( s [ i ] , s [ len - 1 - i ] ) - Math . Min ( s [ i ] , s [ len - 1 - i ] ) ; int D2 = 26 - D1 ; result += Math . Min ( D1 , D2 ) ; } return result ; }
int maxSum ( int [ ] arr , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . Max ( res , next_val ) ; } return res ; }
Boolean isPossible ( int [ ] a , int n ) { int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != i + 1 ) k ++ ; } if ( k <= 2 ) return true ; return false ; }
long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
int countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( N / i != i ) { count ++ ; } } } return count ; }
void findMax ( int [ , ] arr ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i , j ] == 1 && j >= 0 ) { row = i ; j -- ; } } Console . Write ( " Row ▁ number ▁ = ▁ " + ( row + 1 ) ) ; Console . Write ( " , ▁ MaxCount ▁ = ▁ " + ( N - 1 - j ) ) ; }
int minDiffSubArray ( int [ ] arr , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int [ ] suffix_sum = new int [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int minDiff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = Math . Abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
int minimumBox ( int [ ] arr , int n ) { Queue < int > q = new Queue < int > ( ) ; Array . Sort ( arr ) ; q . Enqueue ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . Peek ( ) ; if ( arr [ i ] >= 2 * now ) q . Dequeue ( ) ; q . Enqueue ( arr [ i ] ) ; } return q . Count ; }
String findPrefix ( String str1 , String str2 ) { bool pos = false ; while ( str1 . Length > 0 ) { if ( ! str2 . Contains ( str1 ) ) str1 = str1 . Substring ( 0 , str1 . Length - 1 ) ; else { pos = str2 . Contains ( str1 ) ; break ; } } if ( pos == false ) return " - 1" ; return str1 ; }
int getCount ( int [ ] arr , int N ) { int count = 0 ; if ( N < 3 ) return 0 ; for ( int b = 0 ; b < N ; b ++ ) { for ( int a = 0 ; a < N ; a ++ ) { if ( a == b ) continue ; for ( int c = 0 ; c < N ; c ++ ) { if ( c == a c == b ) continue ; int d = arr [ b ] * arr [ b ] / 4 ; if ( arr [ a ] * arr <= d ) count ++ ; } } } return count ; }
bool permutation ( int [ ] arr , int n ) { HashSet < int > hash = new HashSet < int > ( ) ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . Add ( arr [ i ] ) ; maxEle = Math . Max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . Count == n ) return true ; return false ; }
void XOROfElements ( int [ ] arr , int n ) { int FirstHalfXOR = 0 ; int SecondHalfXOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } Console . Write ( FirstHalfXOR + " , " + SecondHalfXOR + " STRNEWLINE " ) ; }
int sum ( int [ ] a , int n ) { int maxSum = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) maxSum = Math . Max ( maxSum , a [ i ] + a [ j ] ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; }
int findpos ( String n ) { int pos = 0 ; for ( int i = 0 ; i < n . Length ; i ++ ) { switch ( n [ i ] ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; }
void reorder ( ) { int [ ] temp = new int [ arr . Length ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
void sieve ( ) { int [ ] arr = new int [ N + 1 ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i <= Math . Sqrt ( N ) ; i ++ ) if ( arr [ i ] == 0 ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; long runningPrimeSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
bool findPair ( int [ ] a , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
int findMinCost ( int [ , ] arr , int X , int n , int i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return Int32 . MaxValue ; int inc = findMinCost ( arr , X - arr [ i , 0 ] , n , i + 1 ) ; if ( inc != Int32 . MaxValue ) inc += arr [ i , 1 ] ; int exc = findMinCost ( arr , X , n , i + 1 ) ; return Math . Min ( inc , exc ) ; }
int maxlength ( String s ) { int n = s . Length , i , j ; int ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s [ i ] == '1' ) { int count = 1 ; for ( j = i + 1 ; j <= n - 1 && s [ j ] == '1' ; j ++ ) count ++ ; ans = Math . Max ( ans , count ) ; } } return ans ; }
bool Check_is_possible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) count ++ ; } return ( count > 1 ) ; }
int count_pairs ( int [ ] arr , int [ ] brr , int N , int M , int K ) { int i = 0 ; int j = 0 ; int cntPairs = 0 ; Array . Sort ( arr ) ; Array . Sort ( brr ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
int MaxSubsetlength ( string [ ] arr , int A , int B ) { int [ , ] dp = new int [ A + 1 , B + 1 ] ; foreach ( string str in arr ) { int zeros = 0 , ones = 0 ; foreach ( char ch in str . ToCharArray ( ) ) { if ( ch == '0' ) zeros ++ ; else ones ++ ; } for ( int i = A ; i >= zeros ; i -- ) for ( int j = B ; j >= ones ; j -- ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i - zeros , j - ones ] + 1 ) ; } return dp [ A , B ] ; }
int findSum ( String s ) { int sum = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { for ( int j = i + 1 ; j < s . Length ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
int Count ( String s , int pos ) { int c = s [ pos - 1 ] ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s [ i ] == c ) counter = counter + 1 ; } return counter ; }
int productSum ( int [ ] arr ) { int cntOne = 0 ; int N = arr . Length ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) cntOne ++ ; } return cntOne * ( cntOne - 1 ) / 2 ; }
int two_sets ( int [ ] a , int n ) { Array . Sort ( a ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; }
void arrayEvenAndOdd ( int [ ] arr , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) Console . Write ( arr [ k ] + " ▁ " ) ; }
void findWays ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } Console . Write ( dp [ N ] ) ; }
int longestSubsequenceCommonSegment ( int k , string s1 , string s2 ) { int n = s1 . Length ; int m = s2 . Length ; int [ , ] lcs = new int [ n + 1 , m + 1 ] ; int [ , ] cnt = new int [ n + 1 , m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i , j ] = Math . Max ( lcs [ i - 1 , j ] , lcs [ i , j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i , j ] = cnt [ i - 1 , j - 1 ] + 1 ; if ( cnt [ i , j ] >= k ) { for ( int a = k ; a <= cnt [ i , j ] ; a ++ ) lcs [ i , j ] = Math . Max ( lcs [ i , j ] , lcs [ i - a , j - a ] + a ) ; } } } return lcs [ n , m ] ; }
float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . Pow ( r , 2 ) / 5 ) ; return a ; }
void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . Length ; i ++ ) { String sub = str . Substring ( i , k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . Length - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub [ j ] - '0' ) * Math . Pow ( b , counter ) ) ) ; counter ++ ; } Console . Write ( sum + " ▁ " ) ; } }
int findsubArray ( int [ ] arr , int N , int K ) { int res = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { int curr_prod = 1 ; for ( int j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = Math . Min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
int missingNumber ( int [ ] arr1 , int [ ] arr2 , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
int numberOfUniqueOutcomes ( int N , int S ) { if ( S < N ) return 0 ; if ( N == 1 N == S ) return 1 ; return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) ; }
int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
bool findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } }
int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }
int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; }
bool check ( char [ ] s ) { int l = s . Length ; Array . Sort ( s ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; }
bool isDivisible ( int n ) { int d ; while ( n / 100 > 0 ) { d = n % 10 ; n /= 10 ; n = Math . Abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . Sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
int findMinDiff ( int [ ] arr , int n ) { int diff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . Abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
double surface_area_octahedron ( double side ) { return ( 2 * ( Math . Sqrt ( 3 ) ) * ( side * side ) ) ; }
int countPairs ( int [ ] A , int [ ] B ) { int n = A . Length ; int ans = 0 ; Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
void smallestNumber ( int N ) { Console . WriteLine ( ( N % 9 + 1 ) * Math . Pow ( 10 , ( N / 9 ) ) - 1 ) ; }
int calculate ( int n , int k , int m , int power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
void LargestString ( string [ ] na ) { int N = na . Length ; int [ ] c = new int [ N ] ; int m = 0 ; for ( int j = 0 ; j < N ; j ++ ) { bool [ ] character = new bool [ 26 ] ; for ( int k = 0 ; k < na [ j ] . Length ; k ++ ) { int x = na [ j ] [ k ] - ' A ' ; if ( ( na [ j ] [ k ] != ' ▁ ' ) && ( character [ x ] == false ) ) { c [ j ] ++ ; character [ x ] = true ; } } if ( c [ j ] > c [ m ] ) m = j ; } Console . Write ( na [ m ] ) ; }
void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int longCommomAnagramSubseq ( string str1 , string str2 , int n1 , int n2 ) { int [ ] freq1 = new int [ SIZE ] ; int [ ] freq2 = new int [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += Math . Min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
int checkArray ( int [ ] arr , int N , int k ) { if ( N < 3 ) return - 1 ; int i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; int R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; int Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
void kth_String ( int n , int k ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( k <= ( n - i - 1 ) ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == i j == n - k ) Console . Write ( ' Y ' ) ; else Console . Write ( ' X ' ) ; } break ; } k -= ( n - i - 1 ) ; } }
void printNumberOfPairs ( int N ) { HashSet < int > st = new HashSet < int > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { int x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . Add ( x ) ; } } } Console . WriteLine ( st . Count ) ; }
int countSetBits ( int N ) { int count = 0 ; while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; } return count ; }
int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }
int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
bool checkSentence ( char [ ] str ) { int len = str . Length ; if ( str [ 0 ] < ' A ' str [ 0 ] > ' Z ' ) return false ; if ( str [ len - 1 ] != ' . ' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( index <= str . Length ) { if ( str [ index ] >= ' A ' && str [ index ] <= ' Z ' ) curr_state = 0 ; else if ( str [ index ] == ' ▁ ' ) curr_state = 1 ; else if ( str [ index ] >= ' a ' && str [ index ] <= ' z ' ) curr_state = 2 ; else if ( str [ index ] == ' . ' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . Length ) ; index ++ ; prev_state = curr_state ; } return false ; }
int findCost ( int [ ] a , int n ) { Array . Sort ( a ) ; Array . Reverse ( a ) ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
int countPairs ( string str ) { int result = 0 ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( str [ i ] - str [ j ] ) == Math . Abs ( i - j ) ) result ++ ; return result ; }
int minSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int x = arr [ ( int ) ( n / 2 ) ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . Abs ( arr [ i ] - x ) ; return sum ; }
int longLenSub ( int [ ] arr , int n ) { Dictionary < int , int > um = new Dictionary < int , int > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . ContainsKey ( arr [ i ] - 1 ) && len < um [ arr [ i ] - 1 ] ) len = um [ arr [ i ] - 1 ] ; if ( um . ContainsKey ( arr [ i ] + 1 ) && len < um [ arr [ i ] + 1 ] ) len = um [ arr [ i ] + 1 ] ; um [ arr [ i ] ] = len + 1 ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } return longLen ; }
int swapBits ( int n , int p1 , int p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
int subsetCount ( int [ ] arr , int n ) { return 1 << n ; }
Boolean isValidSeq ( int [ ] a , int n ) { int nodes = n + 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 a [ i ] > nodes ) return false ; } return true ; }
void LowerHessenbergMatrix ( int n ) { Random rand = new Random ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) Console . Write ( 0 + " ▁ " ) ; else Console . Write ( rand . Next ( 1 , 10 ) + " ▁ " ) ; } Console . WriteLine ( ) ; } }
void CountPair ( int L , int R ) { int x = ( R - L + 1 ) ; Console . WriteLine ( x / 2 + " STRNEWLINE " ) ; }
bool isEven ( int n ) { return ( n % 2 == 0 ) ; }
int findTripleSum ( int A , int B , int C ) { int sum = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { int prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
int countWays ( int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
int swapBits ( int n , int p1 , int p2 ) { int bit1 = ( n >> p1 ) & 1 ; int bit2 = ( n >> p2 ) & 1 ; int x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; int result = n ^ x ; return result ; }
bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
int get_permutation ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += Math . Abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . Max ( l , a ) ; int R = Math . Min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int countNums ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { int lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
bool isAnyNotPalindrome ( String s ) { HashSet < char > unique = new HashSet < char > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) unique . Add ( s [ i ] ) ; if ( unique . Count > 1 ) return true ; else return false ; }
double findAverage ( int N ) { double S = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { S += i * i * i * i ; } return S / N ; }
void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } Console . Write ( res ) ; }
void atleastkDistinctChars ( string s , int k ) { int n = s . Length ; Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; int begin = 0 , end = 0 ; int ans = 0 ; while ( end < n ) { char c = s [ end ] ; if ( mp . ContainsKey ( c ) ) mp ++ ; else mp . Add ( c , 1 ) ; end ++ ; while ( mp . Count >= k ) { char pre = s [ begin ] ; mp [ pre ] -- ; if ( mp [ pre ] == 0 ) { mp . Remove ( pre ) ; } ans += s . Length - end + 1 ; begin ++ ; } } Console . Write ( ans ) ; }
int findProduct ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int prod = 1 * arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; }
int hIndex ( int [ ] citations , int n ) { int hindex = 0 ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } Console . WriteLine ( hindex ) ; return hindex ; }
double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
int magicOfSequence ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
void countPairs ( int [ ] A , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } Console . Write ( count ) ; }
void check_position ( int a , int b , int c , int d , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int value_1 = a * x1 + b * y1 + c * z1 + d ; int value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) Console . Write ( " On ▁ same ▁ side " ) ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) Console . Write ( " On ▁ different ▁ sides " ) ; if ( value_1 == 0 && value_2 == 0 ) Console . Write ( " Both ▁ on ▁ the ▁ plane " ) ; if ( value_1 == 0 && value_2 != 0 ) Console . Write ( " Point ▁ 1 ▁ on ▁ the ▁ plane " ) ; if ( value_1 != 0 && value_2 == 0 ) Console . Write ( " Point ▁ 2 ▁ on ▁ the ▁ plane " ) ; }
void generateArray ( int n , int k ) { int [ ] array = new int [ k ] ; int remaining = n - ( k * ( k + 1 ) / 2 ) ; if ( remaining < 0 ) Console . Write ( " NO " ) ; int right_most = remaining % k ; int high = ( int ) Math . Ceiling ( remaining / ( k * 1.0 ) ) ; int low = ( int ) Math . Floor ( remaining / ( k * 1.0 ) ) ; for ( int i = k - right_most ; i < k ; i ++ ) array [ i ] = high ; for ( int i = 0 ; i < ( k - right_most ) ; i ++ ) array [ i ] = low ; for ( int i = 0 ; i < k ; i ++ ) array [ i ] += i + 1 ; if ( k - 1 != remaining k == 1 ) { foreach ( int u in array ) Console . Write ( u + " ▁ " ) ; } else if ( k == 2 k == 3 ) Console . Write ( " - 1 STRNEWLINE " ) ; else { array [ 1 ] -= 1 ; array [ k - 1 ] += 1 ; foreach ( int u in array ) Console . Write ( u + " ▁ " ) ; } }
int nthSHN ( int n , int [ ] dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
int calcCount ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 ) count ++ ; } return count ; }
bool checkIfAllTogether ( string s , char c ) { bool oneSeen = false ; int i = 0 , n = s . Length ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }
int winner ( int [ ] a , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
int countPairs ( int [ ] P , int [ ] Q , int N , int M ) { int [ ] A = new int [ 2 ] ; int [ ] B = new int [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
int minDel ( string s1 , string s2 ) { int i = s1 . Length ; int j = s2 . Length ; while ( i > 0 && j > 0 ) { if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) { break ; } i -- ; j -- ; } return i + j ; }
void printAllAPTriplets ( int [ ] arr , int n ) { List < int > s = new List < int > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; bool exists = s . Exists ( element => element == ( arr [ i ] - diff ) ) ; if ( exists ) Console . WriteLine ( arr [ i ] - diff + " ▁ " + arr [ i ] + " ▁ " + arr [ j ] ) ; } s . Add ( arr [ i ] ) ; } }
int maxPathSum ( int [ , ] tri ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i , j ] += Math . Max ( tri [ i + 1 , j ] , tri [ i + 1 , j - 1 ] ) ; else tri [ i , j ] += tri [ i + 1 , j ] ; ans = Math . Max ( ans , tri [ i , j ] ) ; } } return ans ; }
void printDistSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool [ , ] dp = new bool [ n + 1 , sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i , arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 , j ] == true ) { dp [ i , j ] = true ; dp [ i , j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n , j ] == true ) Console . Write ( j + " ▁ " ) ; }
int find_index ( int [ ] arr , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
bool isHexagonal ( int N ) { float val = 8 * N + 1 ; float x = 1 + ( float ) Math . Sqrt ( val ) ; float n = ( x ) / 4 ; if ( ( n - ( int ) n ) == 0 ) { return true ; } else { return false ; } }
bool checkSequence ( String a , String b ) { if ( b . Length == 0 ) return true ; if ( a . Length == 0 ) return false ; if ( a [ 0 ] == b [ 0 ] ) return checkSequence ( a . Substring ( 1 ) , b . Substring ( 1 ) ) ; else return checkSequence ( a . Substring ( 1 ) , b ) ; }
string longestCommonPrefix ( String [ ] a ) { int size = a . Length ; if ( size == 0 ) return " " ; if ( size == 1 ) return a [ 0 ] ; Array . Sort ( a ) ; int end = Math . Min ( a [ 0 ] . Length , a [ size - 1 ] . Length ) ; int i = 0 ; while ( i < end && a [ 0 ] [ i ] == a [ size - 1 ] [ i ] ) i ++ ; string pre = a [ 0 ] . Substring ( 0 , i ) ; return pre ; }
int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
void printRect ( int [ ] X , int [ ] Y , int n ) { int Xmax = X . Max ( ) ; int Xmin = X . Min ( ) ; int Ymax = Y . Max ( ) ; int Ymin = Y . Min ( ) ; Console . WriteLine ( " { " + Xmin + " , ▁ " + Ymin + " } " ) ; Console . WriteLine ( " { " + Xmin + " , ▁ " + Ymax + " } " ) ; Console . WriteLine ( " { " + Xmax + " , ▁ " + Ymax + " } " ) ; Console . WriteLine ( " { " + Xmax + " , ▁ " + Ymin + " } " ) ; }
int setleftmostunsetbit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
String to_upper ( char [ ] str ) { for ( int i = 0 ; i < str . Length ; i ++ ) if ( ' a ' <= str [ i ] && str [ i ] <= ' z ' ) str [ i ] = ( char ) ( ( int ) str [ i ] & ( ~ ( 1 << 5 ) ) ) ; return String . Join ( " " , str ) ; }
void pairwiseDifference ( int [ ] arr , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; Console . WriteLine ( diff + " ▁ " ) ; } }
int product ( int N ) { int ans = 1 ; int val = ( int ) Math . Pow ( 2 , N - 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { ans *= ( int ) Math . Pow ( i , val ) ; } return ans ; }
int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
bool isAlphabaticOrder ( String s ) { int n = s . Length ; char [ ] c = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; } Array . Sort ( c ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; }
void findPairs ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { Console . Write ( " ( " + i + " , ▁ " + ( N - i ) + " ) , ▁ " ) ; } }
double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
int findMinMax ( int [ ] a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . Length ; ++ i ) { min_val = Math . Min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
bool hasAllcodes ( string s , int k ) { HashSet < string > us = new HashSet < string > ( ) ; for ( int i = 0 ; i + k <= s . Length ; i ++ ) { us . Add ( s . Substring ( i , k ) ) ; } return us . Count == 1 << k ; }
int minimumSizeArr ( int A , int B ) { int currXor = 0 ; int reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; int minSize = A ; if ( currXor == B ) return minSize ; else if ( ( currXor ^ B ) == A ) return minSize + 2 ; else return minSize + 1 ; }
double maxEdges ( double N ) { double edges = 0 ; edges = Math . Floor ( ( N * N ) / 4 ) ; return edges ; }
bool checkSolution ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { return ( ( a1 / a2 ) == ( b1 / b2 ) && ( b1 / b2 ) == ( c1 / c2 ) ) ; }
int MaxDotProduct ( int [ ] A , int [ ] B , int m , int n ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i , j ] = Math . Max ( ( dp [ i - 1 , j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i , j - 1 ] ) ; return dp [ n , m ] ; }
bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . Length , n2 = s2 . Length ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
int maxSubArraySumRepeated ( int [ ] a , int n , int k ) { int max_so_far = 0 ; int max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
void lastTwoDigits ( double N ) { if ( N >= 10 ) { Console . Write ( "00" ) ; return ; } double fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; Console . Write ( fac ) ; }
void maxValue ( int a ) { String c = Convert . ToString ( a , 2 ) ; String b = " " ; for ( int i = 0 ; i < c . Length ; i ++ ) { if ( ( c [ i ] - '0' ) == 1 ) b += '0' ; else b += '1' ; } Console . Write ( Convert . ToInt32 ( b , 2 ) ) ; }
double kthRoot ( double n , int k ) { return Math . Pow ( k , ( 1.0 / k ) * ( Math . Log ( n ) / Math . Log ( k ) ) ) ; }
int minElements ( int [ ] arr , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Array . Sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; Dictionary < char , int > m = new Dictionary < char , int > ( ) ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] && str [ i ] <= r ) ) { cnt ++ ; if ( ! m . ContainsKey ( str [ i ] ) ) { m [ str [ i ] ] = 0 ; Console . Write ( str [ i ] + " ▁ " ) ; } m [ str [ i ] ] ++ ; } } return cnt ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = ( int ) ( Math . Pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) Console . Write ( ans ) ; else Console . Write ( 2 * ans ) ; }
void findXOR ( int [ , , ] mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i , j , k ] ; XOR ^= mat [ i , j , N - k - 1 ] ; } } } } Console . WriteLine ( XOR ) ; }
int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; }
Boolean checkSorted ( int n , int [ ] arr ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; Array . Sort ( b , 0 , n ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; }
int extraElement ( int [ ] A , int [ ] B , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
void reArrange ( String [ ] words , int n ) { Dictionary < String , int > freq = new Dictionary < String , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . Add ( words [ i ] , ( i + 1 ) ) ; } Array . Sort ( words ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( freq [ words [ i ] ] + " ▁ " ) ; }
int findSum ( int n ) { return n * ( n + 1 ) / 2 ; }
float find_Area ( float a ) { float R = a * ( float ) ( 2.0 - Math . Sqrt ( 2 ) ) ; float area = ( float ) ( ( 3.14 * R * R ) / 2.0 ) ; return area ; }
int findNum ( int [ ] div , int [ ] rem , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( int ) ( Math . Ceiling ( val ) - x ) ; }
float knapSack ( int W , float [ ] wt , float [ ] val , int n ) { float maxratio = int . MinValue ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
void findTriangles ( int n ) { int num = n ; Console . Write ( num + " ▁ " ) ; Console . WriteLine ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }
double sum ( int n ) { double sum = 0 ; int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum ; }
int k_nonzero_numbers ( string s , int n , int k ) { int [ , , ] dp = new int [ n + 1 , 2 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) for ( int x = 0 ; x <= k ; x ++ ) dp [ i , j , x ] = 0 ; dp [ 0 , 0 , 0 ] = 1 ; for ( int i = 0 ; i < n ; ++ i ) { int sm = 0 ; while ( sm < 2 ) { for ( int j = 0 ; j < k + 1 ; ++ j ) { int x = 0 ; while ( x <= ( sm != 0 ? 9 : s [ i ] - '0' ) ) { if ( j + ( x > 0 ? 1 : 0 ) < k + 1 ) { dp [ i + 1 , ( ( sm != 0 || x < ( s [ i ] - '0' ) ) ? 1 : 0 ) , j + ( x > 0 ? 1 : 0 ) ] += dp [ i , sm , j ] ; } ++ x ; } } ++ sm ; } } return dp [ n , 0 , k ] + dp [ n , 1 , k ] ; }
int number_of_tower ( int [ ] house , int range , int n ) { Array . Sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
bool is_possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }
uint countOfMultiples ( uint n ) { return ( n / 3 + n / 5 - n / 15 ) ; }
bool Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
double square ( double a ) { if ( a < 0 ) return - 1 ; double x = 0.464 * a ; return x ; }
int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
void findPoint ( int x1 , int y1 , int x2 , int y2 ) { Console . WriteLine ( " ( " + ( int ) ( 2 * x2 - x1 ) + " , " + ( int ) ( 2 * y2 - y1 ) + " ▁ ) " ) ; }
int FirstDigit ( int [ ] arr , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . Log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . Floor ( S ) ; int ans = ( int ) Math . Pow ( 10 , fract_S ) ; return ans ; }
int findIndex ( int [ ] arr ) { int maxIndex = 0 ; for ( int i = 0 ; i < arr . Length ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( int i = 0 ; i < arr . Length ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return - 1 ; return maxIndex ; }
double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / Math . Pow ( 2 , fold ) ; }
int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
int maxOnesIndex ( int [ ] arr , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
int countPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
void findIntersection ( int [ , ] intervals , int N ) { int l = intervals [ 0 , 0 ] ; int r = intervals [ 0 , 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( intervals [ i , 0 ] > r intervals [ i , 1 ] < l ) { Console . WriteLine ( - 1 ) ; return ; } else { l = Math . Max ( l , intervals [ i , 0 ] ) ; r = Math . Min ( r , intervals [ i , 1 ] ) ; } } Console . WriteLine ( " [ " + l + " , ▁ " + r + " ] " ) ; }
void movesRequired ( int a , int b ) { int total_moves = a % b ; Console . Write ( total_moves ) ; }
int countDigits ( int a , int b ) { if ( a == 0 b == 0 ) return 1 ; return ( int ) Math . Floor ( Math . Log10 ( Math . Abs ( a ) ) + Math . Log10 ( Math . Abs ( b ) ) ) + 1 ; }
int PointInKSquares ( int n , int [ ] a , int k ) { Array . Sort ( a ) ; return a [ n - k ] ; }
int findCount ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int result = 1 ; int cur_max = arr [ 0 ] ; int cur_min = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
float findRadiusOfIncircle ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; float p = ( a + b + c ) / 2 ; float area = ( float ) Math . Sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float radius = area / p ; return ( float ) ( radius ) ; }
int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
int nCycle ( int N ) { return ( N ) * ( N - 1 ) + 1 ; }
double area_cicumscribed ( double c ) { return ( c * c * ( PI / 4 ) ) ; }
int maxLen ( int [ ] arr , int n ) { int c_sum = 0 ; Array . Sort ( arr ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { c_sum += arr [ i ] ; if ( c_sum < 0 ) return i ; } return n ; }
void findArea ( float a , float b ) { float Area ; Area = ( float ) 3.142 * a * b ; Console . WriteLine ( " Area : ▁ " + Area ) ; }
int right_angled ( int n ) { int count = 0 ; for ( int z = 1 ; z <= n ; z ++ ) { for ( int y = 1 ; y <= z ; y ++ ) { for ( int x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
bool isUpperTriangularMatrix ( int [ , ] mat ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i , j ] != 0 ) return false ; return true ; }
void findPairs ( int [ ] arr , int n ) { int cntEven = 0 , cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; Console . WriteLine ( " Odd ▁ pairs ▁ = ▁ " + oddPairs ) ; Console . WriteLine ( " Even ▁ pairs ▁ = ▁ " + evenPairs ) ; }
int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
int Division ( int [ ] a , int n ) { int maxi = int . MinValue , mini = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { maxi = Math . Max ( a [ i ] , maxi ) ; mini = Math . Min ( a [ i ] , mini ) ; } return maxi / mini ; }
float sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return ( float ) total ; }
void maxSubmatrixSum ( int [ , ] matrix ) { int r = matrix . GetLength ( 0 ) ; int c = matrix . GetLength ( 1 ) ; int maxSubmatrix = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int k = i ; k < r ; k ++ ) { for ( int l = j ; l < c ; l ++ ) { int sumSubmatrix = 0 ; for ( int m = i ; m <= k ; m ++ ) { for ( int n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m , n ] ; } } maxSubmatrix = Math . Max ( maxSubmatrix , sumSubmatrix ) ; } } } } Console . WriteLine ( maxSubmatrix ) ; }
char bs ( char [ ] ar , int n , int ele ) { int start = 0 ; int end = n - 1 ; char ch = ' @ ' ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
int maxSum ( int [ ] arr , int n ) { if ( n < 2 ) return - 1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = Math . Min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
bool checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; int [ ] v = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) v [ i ] = 0 ; v [ m ] = 1 ; while ( true ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } }
double Area ( double r ) { if ( r < 0 ) return - 1 ; double x = ( 2 * r ) / ( double ) ( Math . Sqrt ( 5 ) ) ; double A = 0.70477 * ( double ) ( Math . Pow ( x , 2 ) ) ; return A ; }
String to_upper ( char [ ] In ) { for ( int i = 0 ; i < In . Length ; i ++ ) { if ( ' a ' <= In [ i ] & In [ i ] <= ' z ' ) { In [ i ] = ( char ) ( In [ i ] - ' a ' + ' A ' ) ; } } return String . Join ( " " , In ) ; }
int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - ( int ) Math . Pow ( i , 2 ) ; else result = result + ( int ) Math . Pow ( i , 2 ) ; } return result ; }
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
void Perimeter ( double a , double b ) { double Perimeter ; Perimeter = ( double ) 2 * 3.14 * Math . Sqrt ( ( a * a + b * b ) / ( 2 * 1.0 ) ) ; Console . WriteLine ( " Perimeter : ▁ " + Perimeter ) ; }
int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
void findDirection ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) Console . Write ( " Up STRNEWLINE " ) ; else Console . Write ( " Down STRNEWLINE " ) ; } else { if ( n % 2 == 0 ) Console . Write ( " Left STRNEWLINE " ) ; else Console . Write ( " Right STRNEWLINE " ) ; } }
int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; }
void maximum_inversion ( int n , int k ) { int answer = 0 ; k = Math . Min ( k , n / 2 ) ; int left = 1 ; int right = n ; while ( k != 0 ) { k -- ; answer += 2 * ( right - left ) - 1 ; left ++ ; right -- ; } Console . WriteLine ( answer ) ; }
int maxXOR ( int [ , ] mat , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 ; c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i , j ] ; c_xor = c_xor ^ mat [ j , i ] ; } if ( max_xor < Math . Max ( r_xor , c_xor ) ) max_xor = Math . Max ( r_xor , c_xor ) ; } return max_xor ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . Max ( max_sum , i + j ) ; } } return max_sum ; }
int MinOp ( int N ) { if ( N <= 1 ) return N ; int bit = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) + 1 ; return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; }
int MinimumOperations ( int [ ] A , int N , int K ) { int Count = 0 ; int i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
void sumOfMedians ( int [ ] arr , int N , int K ) { int selectMedian = ( K + 1 ) / 2 ; int totalArrays = N / K ; int minSum = 0 ; int i = selectMedian - 1 ; while ( i < N && totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } Console . WriteLine ( minSum ) ; }
int strScore ( String [ ] str , String s , int n ) { int score = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . Length ; j ++ ) score += s [ j ] - ' a ' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }
long answer ( long n ) { long m = 2 ; long ans = 1 ; long r = 1 ; while ( r < n ) { r = ( ( long ) Math . Pow ( 2 , m ) - 1 ) * ( ( long ) Math . Pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
int stirlingFactorial ( double n ) { if ( n == 1 ) return 1 ; double z ; z = System . Math . Sqrt ( 2 * 3.14 * n ) * System . Math . Pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; }
void querySum ( int [ ] arr , int N , int [ , ] Q , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i , 0 ] ; int y = Q [ i , 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } Console . Write ( sum + " ▁ " ) ; } }
int minLength ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; }
int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
