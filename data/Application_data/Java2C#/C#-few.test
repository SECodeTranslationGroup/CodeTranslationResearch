public override void Serialize ( ILittleEndianOutput out1 ) { out1. WriteShort ( field_1_vcenter ) ; }
public virtual void AddAll ( NGit . Util . BlockList < T > src ) { if ( src . size == 0 ) { return ; } int srcDirIdx = 0 ; for ( ; srcDirIdx < src . tailDirIdx ; srcDirIdx ++ ) { AddAll ( src . directory [ srcDirIdx ] , 0 , BLOCK_SIZE ) ; } if ( src . tailBlkIdx != 0 ) { AddAll ( src . tailBlock , 0 , src . tailBlkIdx ) ; } }
public override void WriteByte ( byte b ) { if ( outerInstance . upto == outerInstance . blockSize ) { if ( outerInstance . currentBlock != null ) { outerInstance . blocks . Add ( outerInstance . currentBlock ) ; outerInstance . blockEnd . Add ( outerInstance . upto ) ; } outerInstance . currentBlock = new byte [ outerInstance . blockSize ] ; outerInstance . upto = 0 ; } outerInstance . currentBlock [ outerInstance . upto ++ ] = ( byte ) b ; }
public virtual ObjectId GetObjectId ( ) { return objectId ; }
public virtual DeleteDomainEntryResponse DeleteDomainEntry ( DeleteDomainEntryRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteDomainEntryRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteDomainEntryResponseUnmarshaller . Instance ; return Invoke < DeleteDomainEntryResponse > ( request , options ) ; }
public virtual long RamBytesUsed ( ) { return fst == null ? 0 : fst . GetSizeInBytes ( ) ; }
public string GetFullMessage ( ) { byte [ ] raw = buffer ; int msgB = RawParseUtils . TagMessage ( raw , 0 ) ; if ( msgB < 0 ) { return string . Empty ; } Encoding enc = RawParseUtils . ParseEncoding ( raw ) ; return RawParseUtils . Decode ( enc , raw , msgB , raw . Length ) ; }
public POIFSFileSystem ( ) { HeaderBlock headerBlock = new HeaderBlock ( bigBlockSize ) ; _property_table = new PropertyTable ( headerBlock ) ; _documents = new ArrayList ( ) ; _root = null ; }
public void Init ( int address ) { slice = pool . Buffers [ address >> ByteBlockPool . BYTE_BLOCK_SHIFT ] ; Debug . Assert ( slice != null ) ; upto = address & ByteBlockPool . BYTE_BLOCK_MASK ; offset0 = address ; Debug . Assert ( upto < slice . Length ) ; }
public virtual NGit . Api . SubmoduleAddCommand SetPath ( string path ) { this . path = path ; return this ; }
public virtual ListIngestionsResponse ListIngestions ( ListIngestionsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ListIngestionsRequestMarshaller . Instance ; options . ResponseUnmarshaller = ListIngestionsResponseUnmarshaller . Instance ; return Invoke < ListIngestionsResponse > ( request , options ) ; }
public QueryParserTokenManager ( ICharStream stream , int lexState ) : this ( stream ) { SwitchTo ( lexState ) ; }
public virtual GetShardIteratorResponse GetShardIterator ( GetShardIteratorRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetShardIteratorRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetShardIteratorResponseUnmarshaller . Instance ; return Invoke < GetShardIteratorResponse > ( request , options ) ; }
public ModifyStrategyRequest ( ) : base ( " aegis " , " 2016 - 11 - 11 " , " ModifyStrategy " , " vipaegis " , " openAPI " ) { Method = MethodType . POST ; }
public override bool ready ( ) { lock ( @ lock ) { if ( @ in == null ) { throw new System . IO . IOException ( " InputStreamReader ▁ is ▁ closed " ) ; } try { return bytes . hasRemaining ( ) || @ in . available ( ) > 0 ; } catch ( System . IO . IOException ) { return false ; } } }
protected internal EscherOptRecord GetOptRecord ( ) { return _optRecord ; }
public override int read ( byte [ ] buffer , int offset , int length ) { lock ( this ) { if ( buffer == null ) { throw new System . ArgumentNullException ( " buffer ▁ == ▁ null " ) ; } java . util . Arrays . checkOffsetAndCount ( buffer . Length , offset , length ) ; if ( length == 0 ) { return 0 ; } int copylen = count - pos < length ? count - pos : length ; { for ( int i = 0 ; i < copylen ; i ++ ) { buffer [ offset + i ] = unchecked ( ( byte ) this . buffer [ pos + i ] ) ; } } pos += copylen ; return copylen ; } }
public OpenNLPSentenceBreakIterator ( NLPSentenceDetectorOp sentenceOp ) { this . sentenceOp = sentenceOp ; }
public virtual void print ( string str ) { write ( str != null ? str : Sharpen . StringHelper . GetValueOf ( ( object ) null ) ) ; }
public NotImplementedFunctionException ( string functionName , NotImplementedException cause ) : base ( functionName , cause ) { this . functionName = functionName ; }
public override V next ( ) { return this . nextEntry ( ) . value ; }
public override sealed void ReadBytes ( byte [ ] b , int offset , int len , bool useBuffer ) { int available = bufferLength - bufferPosition ; if ( len <= available ) { if ( len > 0 ) { Buffer . BlockCopy ( m_buffer , bufferPosition , b , offset , len ) ; } bufferPosition += len ; } else { if ( available > 0 ) { Buffer . BlockCopy ( m_buffer , bufferPosition , b , offset , available ) ; offset += available ; len -= available ; bufferPosition += available ; } if ( useBuffer && len < bufferSize ) { Refill ( ) ; if ( bufferLength < len ) { Buffer . BlockCopy ( m_buffer , 0 , b , offset , bufferLength ) ; throw new EndOfStreamException ( " read ▁ past ▁ EOF : ▁ " + this ) ; } else { Buffer . BlockCopy ( m_buffer , 0 , b , offset , len ) ; bufferPosition = len ; } } else { long after = bufferStart + bufferPosition + len ; if ( after > Length ) { throw new EndOfStreamException ( " read ▁ past ▁ EOF : ▁ " + this ) ; } ReadInternal ( b , offset , len ) ; bufferStart = after ; bufferPosition = 0 ; bufferLength = 0 ; } } }
public virtual TagQueueResponse TagQueue ( TagQueueRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = TagQueueRequestMarshaller . Instance ; options . ResponseUnmarshaller = TagQueueResponseUnmarshaller . Instance ; return Invoke < TagQueueResponse > ( request , options ) ; }
public override void Remove ( ) { throw new NotSupportedException ( ) ; }
public virtual ModifyCacheSubnetGroupResponse ModifyCacheSubnetGroup ( ModifyCacheSubnetGroupRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = ModifyCacheSubnetGroupRequestMarshaller . Instance ; options . ResponseUnmarshaller = ModifyCacheSubnetGroupResponseUnmarshaller . Instance ; return Invoke < ModifyCacheSubnetGroupResponse > ( request , options ) ; }
public override void SetParams ( string @ params ) { base . SetParams ( @ params ) ; culture = " " ; string ignore ; StringTokenizer st = new StringTokenizer ( @ params , " , " ) ; if ( st . MoveNext ( ) ) culture = st . Current ; if ( st . MoveNext ( ) ) culture += " - " + st . Current ; if ( st . MoveNext ( ) ) ignore = st . Current ; }
public virtual DeleteDocumentationVersionResponse DeleteDocumentationVersion ( DeleteDocumentationVersionRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = DeleteDocumentationVersionRequestMarshaller . Instance ; options . ResponseUnmarshaller = DeleteDocumentationVersionResponseUnmarshaller . Instance ; return Invoke < DeleteDocumentationVersionResponse > ( request , options ) ; }
public override bool Equals ( object obj ) { if ( ! ( obj is FacetLabel ) ) { return false ; } FacetLabel other = ( FacetLabel ) obj ; if ( Length != other . Length ) { return false ; } for ( int i = Length - 1 ; i >= 0 ; i -- ) { if ( ! Components [ i ] . Equals ( other . Components [ i ] , StringComparison . Ordinal ) ) { return false ; } } return true ; }
public virtual GetInstanceAccessDetailsResponse GetInstanceAccessDetails ( GetInstanceAccessDetailsRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetInstanceAccessDetailsRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetInstanceAccessDetailsResponseUnmarshaller . Instance ; return Invoke < GetInstanceAccessDetailsResponse > ( request , options ) ; }
public HSSFPolygon CreatePolygon ( HSSFChildAnchor anchor ) { HSSFPolygon shape = new HSSFPolygon ( this , anchor ) ; shape . Parent = this ; shape . Anchor = anchor ; shapes . Add ( shape ) ; OnCreate ( shape ) ; return shape ; }
public String GetSheetName ( int sheetIndex ) { return GetBoundSheetRec ( sheetIndex ) . Sheetname ; }
public virtual GetDashboardResponse GetDashboard ( GetDashboardRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetDashboardRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetDashboardResponseUnmarshaller . Instance ; return Invoke < GetDashboardResponse > ( request , options ) ; }
public virtual AssociateSigninDelegateGroupsWithAccountResponse AssociateSigninDelegateGroupsWithAccount ( AssociateSigninDelegateGroupsWithAccountRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = AssociateSigninDelegateGroupsWithAccountRequestMarshaller . Instance ; options . ResponseUnmarshaller = AssociateSigninDelegateGroupsWithAccountResponseUnmarshaller . Instance ; return Invoke < AssociateSigninDelegateGroupsWithAccountResponse > ( request , options ) ; }
public void AddMultipleBlanks ( MulBlankRecord mbr ) { for ( int j = 0 ; j < mbr . NumColumns ; j ++ ) { BlankRecord br = new BlankRecord ( ) ; br . Column = j + mbr . FirstColumn ; br . Row = mbr . Row ; br . XFIndex = ( mbr . GetXFAt ( j ) ) ; InsertCell ( br ) ; } }
public static string quote ( string @ string ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( " \\ Q " ) ; int apos = 0 ; int k ; while ( ( k = @ string . IndexOf ( " \\ E " , apos ) ) >= 0 ) { sb . append ( Sharpen . StringHelper . Substring ( @ string , apos , k + 2 ) ) . append ( " \\\\ E \\ Q " ) ; apos = k + 2 ; } return sb . append ( Sharpen . StringHelper . Substring ( @ string , apos ) ) . append ( " \\ E " ) . ToString ( ) ; }
public override java . nio . ByteBuffer putInt ( int value ) { throw new java . nio . ReadOnlyBufferException ( ) ; }
public ArrayPtg ( Object [ ] [ ] values2d ) { int nColumns = values2d [ 0 ] . Length ; int nRows = values2d . Length ; _nColumns = ( short ) nColumns ; _nRows = ( short ) nRows ; Object [ ] vv = new Object [ _nColumns * _nRows ] ; for ( int r = 0 ; r < nRows ; r ++ ) { Object [ ] rowData = values2d [ r ] ; for ( int c = 0 ; c < nColumns ; c ++ ) { vv [ GetValueIndex ( c , r ) ] = rowData [ c ] ; } } _arrayValues = vv ; _reserved0Int = 0 ; _reserved1Short = 0 ; _reserved2Byte = 0 ; }
public virtual GetIceServerConfigResponse GetIceServerConfig ( GetIceServerConfigRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = GetIceServerConfigRequestMarshaller . Instance ; options . ResponseUnmarshaller = GetIceServerConfigResponseUnmarshaller . Instance ; return Invoke < GetIceServerConfigResponse > ( request , options ) ; }
public override String ToString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . Append ( GetType ( ) . Name ) . Append ( " ▁ [ " ) ; sb . Append ( GetValueAsString ( ) ) ; sb . Append ( " ] " ) ; return sb . ToString ( ) ; }
public override string ToString ( string field ) { return " ToChildBlockJoinQuery ▁ ( " + _parentQuery + " ) " ; }
public void IncRef ( ) { refCount . IncrementAndGet ( ) ; }
public virtual UpdateConfigurationSetSendingEnabledResponse UpdateConfigurationSetSendingEnabled ( UpdateConfigurationSetSendingEnabledRequest request ) { var options = new InvokeOptions ( ) ; options . RequestMarshaller = UpdateConfigurationSetSendingEnabledRequestMarshaller . Instance ; options . ResponseUnmarshaller = UpdateConfigurationSetSendingEnabledResponseUnmarshaller . Instance ; return Invoke < UpdateConfigurationSetSendingEnabledResponse > ( request , options ) ; }
public int GetNextXBATChainOffset ( ) { return GetXBATEntriesPerBlock ( ) * LittleEndianConsts . INT_SIZE ; }
public void multiplyByPowerOfTen ( int pow10 ) { TenPower tp = TenPower . GetInstance ( Math . Abs ( pow10 ) ) ; if ( pow10 < 0 ) { mulShift ( tp . _divisor , tp . _divisorShift ) ; } else { mulShift ( tp . _multiplicand , tp . _multiplierShift ) ; } }
public override string ToString ( ) { StringBuilder builder = new StringBuilder ( ) ; int length = this . Length ; builder . Append ( Path . DirectorySeparatorChar ) ; for ( int i = 0 ; i < length ; i ++ ) { builder . Append ( this . GetComponent ( i ) ) ; if ( i < ( length - 1 ) ) { builder . Append ( Path . DirectorySeparatorChar ) ; } } return builder . ToString ( ) ; }
public void withFetcher ( ECSMetadataServiceCredentialsFetcher fetcher ) { this . fetcher = fetcher ; this . fetcher . SetRoleName ( roleName ) ; }
public virtual void SetProgressMonitor ( ProgressMonitor pm ) { progressMonitor = pm ; }
public override void Reset ( ) { if ( ! First ) { ptr = 0 ; if ( ! Eof ) { ParseEntry ( ) ; } } }
public E previous ( ) { if ( iterator . previousIndex ( ) >= start ) { return iterator . previous ( ) ; } throw new java . util . NoSuchElementException ( ) ; }
public virtual string GetNewPrefix ( ) { return this . newPrefix ; }
public List < Tuple < string , double >> CustomerExpensiveOrdersTotalMax ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , double >> ordersTotalMax = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Where ( o => o . Total > 100 ) . Max ( o => o . Total ) ) ) . ToList ( ) ; return ordersTotalMax ; }
public int ProjectedStringElementAt ( ) { string [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = strings . Select ( s => s . Length ) . Where ( i => i % 2 == 0 ) . ElementAt ( 2 ) ; return firstStringLength ; }
public List < Tuple < string , int >> CustomerEachCountryOrdersMin ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int >> ordersMin = customers . GroupBy ( c => c . Country ) . Select ( g => Tuple . Create ( g . Key , g . Min ( c => c . Orders . Count ) ) ) . ToList ( ) ; return ordersMin ; }
public List < Tuple < string , DateTime >> CustomerOrdersEachNestedSkip ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , DateTime >> after3EachOrders = customers . SelectMany ( c => c . Orders . Skip ( 3 ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderDate ) ) . ToList ( ) ; return after3EachOrders ; }
public int OddNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = numbers . FirstOrDefault ( n => n % 2 == 1 , - 2 ) ; return firstNum ; }
public List < Tuple < string , int >> CustomerExpensiveOrdersCount ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int >> orderCounts = customers . Select ( c => Tuple . Create ( c . CustomerId , c . Orders . Count ( o => o . Total > 100 ) ) ) . ToList ( ) ; return orderCounts ; }
public Dictionary < char , List < string >> StringGroupByFirstCharDictOrderbyDescendingCustom ( ) { string [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Dictionary < char , List < string >> wordsGroups = words . GroupBy ( w => char . ToLower ( w [ 0 ] ) ) . ToDictionary ( g => g . Key , g => g . OrderByDescending ( w => w , new CaseInsensitiveComparer ( ) ) . ToList ( ) ) ; return wordsGroups ; }
public List < int > IntWithSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < int > q = numbers . Where ( ( n , i ) => n < i * i ) . ToList ( ) ; return q ; }
public int [ ] ProjectionIntConcat ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = numbersA . Select ( n => n + 1 ) ; var second = numbersB . Select ( n => n - 1 ) ; int [ ] numbers = first . Concat ( second ) . ToArray ( ) ; return numbers ; }
public List < int > RangeOfEvenIntsStartFrom ( int start , int count ) { List < int > numbers = Enumerable . Range ( start , count ) . Where ( n => n % 2 == 0 ) . ToList ( ) ; return numbers ; }
public List < Tuple < string , string >> ProductLeftOuterJoinCategoriesName ( ) { string [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = GetProductList ( ) ; List < Tuple < string , string >> q = categories . GroupJoin ( products , c => c , p => p . Category , ( c , p ) => Tuple . Create ( c , p ) ) . SelectMany ( t => t . Item2. Select ( p => p . ProductName ) . DefaultIfEmpty ( " No ▁ Product " ) , ( t , n ) => Tuple . Create ( t . Item1 , n ) ) . ToList ( ) ; return q ; }
public List < Tuple < string , int , double >> CustomerSelectManyCustomerNewOrderIdAndTotals ( ) { List < Customer > customers = GetCustomerList ( ) ; List < Tuple < string , int , double >> customerProperties = customers . SelectMany ( c => c . Orders . Where ( o => o . OrderDate > new DateTime ( 1998 , 1 , 1 ) ) , ( c , o ) => Tuple . Create ( c . CustomerId , o . OrderId , o . Total ) ) . ToList ( ) ; return customerProperties ; }
public Dictionary < string , List < Product >> ProductEachCategoryMaxUnitPriceProductsDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice == g . Max ( p => p . UnitPrice ) ) . ToList ( ) ) ; return categories ; }
public Product ProductFirstOrDefault ( ) { List < Product > products = GetProductList ( ) ; Product product12 = products . FirstOrDefault ( p => p . ProductId == 12 , Product . Default ) ; return product12 ; }
public int OddFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int factorsCount = factorsOf300. Count ( n => n % 2 == 1 ) ; return factorsCount ; }
public List < double > DoubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < double > sortedNumbers = numbers . OrderBy ( n => n % 1.5 ) . ThenByDescending ( n => n ) . ToList ( ) ; return sortedNumbers ; }
public double DoubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = numbers . FirstOrDefault ( 3.14 ) ; return firstNum ; }
public List < int > RangeOfEvenIntsStartFrom ( ) { List < int > numbers = Enumerable . Range ( 100 , 100 ) . Where ( n => n % 2 == 0 ) . ToList ( ) ; return numbers ; }
public Dictionary < string , List < Product >> ProductEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = GetProductList ( ) ; Dictionary < string , List < Product >> categories = products . GroupBy ( p => p . Category ) . ToDictionary ( g => g . Key , g => g . Where ( p => p . UnitPrice == g . Min ( p => p . UnitPrice ) ) . ToList ( ) ) ; return categories ; }
public Dictionary < string , double > CustomerOrdersTotalSumDict ( ) { List < Customer > customers = GetCustomerList ( ) ; Dictionary < string , double > ordersTotalSum = customers . ToDictionary ( c => c . CustomerId , c => c . Orders . Sum ( o => o . Total ) ) ; return ordersTotalSum ; }
nt countWords ( string str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
int minNum ( int [ ] arr , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . Min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
int findSum ( int [ ] arr , int n , int k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
void decodeStr ( String str , int len ) { char [ ] c = new char [ len ] ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len % 2 == 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) Console . Write ( c [ i ] ) ; }
int countSubArrayWithOddProduct ( int [ ] A , int N ) { int count = 0 ; int last = - 1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
void solve ( int [ ] arr , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
int nthTerm ( int N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
int smallestNum ( int N ) { float x = ( float ) ( Math . Pow ( 10 , ( N - 1 ) / 2.0 ) ) ; return ( int ) ( Math . Ceiling ( x ) ) ; }
long multiplyFactors ( int n ) { long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
int deleteElement ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
int findNumberOfTriangles ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; }
int cntPairs ( int [ ] a , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
bool isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * r * r ) / 4 ) ; return a ; }
void findSetBits ( int n ) { int [ ] dp = new int [ n + 1 ] ; Console . Write ( dp [ 0 ] + " ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i / 2 ] ; } else { dp [ i ] = dp [ i / 2 ] + 1 ; } Console . Write ( dp [ i ] + " ▁ " ) ; } }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
int check ( int n , List < int > marks ) { int x = marks . Max ( ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
double octaside ( double a ) { if ( a < 0 ) return - 1 ; double s = a / ( Math . Sqrt ( 2 ) + 1 ) ; return s ; }
int countTriplets ( int [ ] A ) { int cnt = 0 ; Dictionary < int , int > tuples = new Dictionary < int , int > ( ) ; foreach ( int a in A ) foreach ( int b in A ) { if ( tuples . ContainsKey ( a & b ) ) tuples [ a & b ] = tuples [ a & b ] + 1 ; else tuples . Add ( a & b , 1 ) ; } foreach ( int a in A ) foreach ( KeyValuePair < int , int > t in tuples ) if ( ( t . Key & a ) == 0 ) cnt += t . Value ; return cnt ; }
int minDiff ( int [ ] arr , int n , int k ) { int result = int . MaxValue ; Array . Sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . Min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
bool isSubseqPossible ( int [ ] arr , int N , int K ) { int i ; int odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base1 = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base1 ; base1 = base1 * 2 ; } return dec_value ; }
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
