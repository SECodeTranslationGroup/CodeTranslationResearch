public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_vcenter ) ; }
public void addAll ( BlockList < T > src ) { if ( src . size == 0 ) return ; int srcDirIdx = 0 ; for ( ; srcDirIdx < src . tailDirIdx ; srcDirIdx ++ ) addAll ( src . directory [ srcDirIdx ] , 0 , BLOCK_SIZE ) ; if ( src . tailBlkIdx != 0 ) addAll ( src . tailBlock , 0 , src . tailBlkIdx ) ; }
public void writeByte ( byte b ) { if ( upto == blockSize ) { if ( currentBlock != null ) { addBlock ( currentBlock ) ; } currentBlock = new byte [ blockSize ] ; upto = 0 ; } currentBlock [ upto ++ ] = b ; }
public ObjectId getObjectId ( ) { return objectId ; }
public DeleteDomainEntryResult deleteDomainEntry ( DeleteDomainEntryRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDomainEntry ( request ) ; }
public long ramBytesUsed ( ) { return ( ( termOffsets != null ) ? termOffsets . ramBytesUsed ( ) : 0 ) + ( ( termsDictOffsets != null ) ? termsDictOffsets . ramBytesUsed ( ) : 0 ) ; }
public final String getFullMessage ( ) { byte [ ] raw = buffer ; int msgB = RawParseUtils . tagMessage ( raw , 0 ) ; if ( msgB < 0 ) { return " " ; } return RawParseUtils . decode ( guessEncoding ( ) , raw , msgB , raw . length ) ; }
public POIFSFileSystem ( ) { this ( true ) ; _header . setBATCount ( 1 ) ; _header . setBATArray ( new int [ ] { 1 } ) ; BATBlock bb = BATBlock . createEmptyBATBlock ( bigBlockSize , false ) ; bb . setOurBlockIndex ( 1 ) ; _bat_blocks . add ( bb ) ; setNextBlock ( 0 , POIFSConstants . END_OF_CHAIN ) ; setNextBlock ( 1 , POIFSConstants . FAT_SECTOR_BLOCK ) ; _property_table . setStartBlock ( 0 ) ; }
public void init ( int address ) { slice = pool . buffers [ address >> ByteBlockPool . BYTE_BLOCK_SHIFT ] ; assert slice != null ; upto = address & ByteBlockPool . BYTE_BLOCK_MASK ; offset0 = address ; assert upto < slice . length ; }
public SubmoduleAddCommand setPath ( String path ) { this . path = path ; return this ; }
public ListIngestionsResult listIngestions ( ListIngestionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListIngestions ( request ) ; }
public QueryParserTokenManager ( CharStream stream , int lexState ) { this ( stream ) ; SwitchTo ( lexState ) ; }
public GetShardIteratorResult getShardIterator ( GetShardIteratorRequest request ) { request = beforeClientExecution ( request ) ; return executeGetShardIterator ( request ) ; }
public ModifyStrategyRequest ( ) { super ( " aegis " , " 2016 - 11 - 11 " , " ModifyStrategy " , " vipaegis " ) ; setMethod ( MethodType . POST ) ; }
public boolean ready ( ) throws IOException { synchronized ( lock ) { if ( in == null ) { throw new IOException ( " InputStreamReader ▁ is ▁ closed " ) ; } try { return bytes . hasRemaining ( ) || in . available ( ) > 0 ; } catch ( IOException e ) { return false ; } } }
public EscherOptRecord getOptRecord ( ) { return _optRecord ; }
public synchronized int read ( byte [ ] buffer , int offset , int length ) { if ( buffer == null ) { throw new NullPointerException ( " buffer ▁ == ▁ null " ) ; } Arrays . checkOffsetAndCount ( buffer . length , offset , length ) ; if ( length == 0 ) { return 0 ; } int copylen = count - pos < length ? count - pos : length ; for ( int i = 0 ; i < copylen ; i ++ ) { buffer [ offset + i ] = ( byte ) this . buffer . charAt ( pos + i ) ; } pos += copylen ; return copylen ; }
public OpenNLPSentenceBreakIterator ( NLPSentenceDetectorOp sentenceOp ) { this . sentenceOp = sentenceOp ; }
public void print ( String str ) { write ( str != null ? str : String . valueOf ( ( Object ) null ) ) ; }
public NotImplementedFunctionException ( String functionName , NotImplementedException cause ) { super ( functionName , cause ) ; this . functionName = functionName ; }
public V next ( ) { return super . nextEntry ( ) . getValue ( ) ; }
public final void readBytes ( byte [ ] b , int offset , int len , boolean useBuffer ) throws IOException { int available = bufferLength - bufferPosition ; if ( len <= available ) { if ( len > 0 ) System . arraycopy ( buffer , bufferPosition , b , offset , len ) ; bufferPosition += len ; } else { if ( available > 0 ) { System . arraycopy ( buffer , bufferPosition , b , offset , available ) ; offset += available ; len -= available ; bufferPosition += available ; } if ( useBuffer && len < bufferSize ) { refill ( ) ; if ( bufferLength < len ) { System . arraycopy ( buffer , 0 , b , offset , bufferLength ) ; throw new EOFException ( " read ▁ past ▁ EOF : ▁ " + this ) ; } else { System . arraycopy ( buffer , 0 , b , offset , len ) ; bufferPosition = len ; } } else { long after = bufferStart + bufferPosition + len ; if ( after > length ( ) ) throw new EOFException ( " read ▁ past ▁ EOF : ▁ " + this ) ; readInternal ( b , offset , len ) ; bufferStart = after ; bufferPosition = 0 ; bufferLength = 0 ; } } }
public TagQueueResult tagQueue ( TagQueueRequest request ) { request = beforeClientExecution ( request ) ; return executeTagQueue ( request ) ; }
public void remove ( ) { throw new UnsupportedOperationException ( ) ; }
public CacheSubnetGroup modifyCacheSubnetGroup ( ModifyCacheSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyCacheSubnetGroup ( request ) ; }
public void setParams ( String params ) { super . setParams ( params ) ; language = country = variant = " " ; StringTokenizer st = new StringTokenizer ( params , " , " ) ; if ( st . hasMoreTokens ( ) ) language = st . nextToken ( ) ; if ( st . hasMoreTokens ( ) ) country = st . nextToken ( ) ; if ( st . hasMoreTokens ( ) ) variant = st . nextToken ( ) ; }
public DeleteDocumentationVersionResult deleteDocumentationVersion ( DeleteDocumentationVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDocumentationVersion ( request ) ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof FacetLabel ) ) { return false ; } FacetLabel other = ( FacetLabel ) obj ; if ( length != other . length ) { return false ; } for ( int i = length - 1 ; i >= 0 ; i -- ) { if ( ! components [ i ] . equals ( other . components [ i ] ) ) { return false ; } } return true ; }
public GetInstanceAccessDetailsResult getInstanceAccessDetails ( GetInstanceAccessDetailsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInstanceAccessDetails ( request ) ; }
public HSSFPolygon createPolygon ( HSSFChildAnchor anchor ) { HSSFPolygon shape = new HSSFPolygon ( this , anchor ) ; shape . setParent ( this ) ; shape . setAnchor ( anchor ) ; shapes . add ( shape ) ; onCreate ( shape ) ; return shape ; }
public String getSheetName ( int sheetIndex ) { return getBoundSheetRec ( sheetIndex ) . getSheetname ( ) ; }
public GetDashboardResult getDashboard ( GetDashboardRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDashboard ( request ) ; }
public AssociateSigninDelegateGroupsWithAccountResult associateSigninDelegateGroupsWithAccount ( AssociateSigninDelegateGroupsWithAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateSigninDelegateGroupsWithAccount ( request ) ; }
public void addMultipleBlanks ( MulBlankRecord mbr ) { for ( int j = 0 ; j < mbr . getNumColumns ( ) ; j ++ ) { BlankRecord br = new BlankRecord ( ) ; br . setColumn ( ( short ) ( j + mbr . getFirstColumn ( ) ) ) ; br . setRow ( mbr . getRow ( ) ) ; br . setXFIndex ( mbr . getXFAt ( j ) ) ; insertCell ( br ) ; } }
public static String quote ( String string ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " \\ Q " ) ; int apos = 0 ; int k ; while ( ( k = string . indexOf ( " \\ E " , apos ) ) >= 0 ) { sb . append ( string . substring ( apos , k + 2 ) ) . append ( " \\\\ E \\ Q " ) ; apos = k + 2 ; } return sb . append ( string . substring ( apos ) ) . append ( " \\ E " ) . toString ( ) ; }
public ByteBuffer putInt ( int value ) { throw new ReadOnlyBufferException ( ) ; }
public ArrayPtg ( Object [ ] [ ] values2d ) { int nColumns = values2d [ 0 ] . length ; int nRows = values2d . length ; _nColumns = ( short ) nColumns ; _nRows = ( short ) nRows ; Object [ ] vv = new Object [ _nColumns * _nRows ] ; for ( int r = 0 ; r < nRows ; r ++ ) { Object [ ] rowData = values2d [ r ] ; for ( int c = 0 ; c < nColumns ; c ++ ) { vv [ getValueIndex ( c , r ) ] = rowData [ c ] ; } } _arrayValues = vv ; _reserved0Int = 0 ; _reserved1Short = 0 ; _reserved2Byte = 0 ; }
public GetIceServerConfigResult getIceServerConfig ( GetIceServerConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIceServerConfig ( request ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + getValueAsString ( ) + " ] " ; }
public String toString ( String field ) { return " ToChildBlockJoinQuery ▁ ( " + parentQuery . toString ( ) + " ) " ; }
public final void incRef ( ) { refCount . incrementAndGet ( ) ; }
public UpdateConfigurationSetSendingEnabledResult updateConfigurationSetSendingEnabled ( UpdateConfigurationSetSendingEnabledRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateConfigurationSetSendingEnabled ( request ) ; }
public int getNextXBATChainOffset ( ) { return getXBATEntriesPerBlock ( ) * LittleEndianConsts . INT_SIZE ; }
public void multiplyByPowerOfTen ( int pow10 ) { TenPower tp = TenPower . getInstance ( Math . abs ( pow10 ) ) ; if ( pow10 < 0 ) { mulShift ( tp . _divisor , tp . _divisorShift ) ; } else { mulShift ( tp . _multiplicand , tp . _multiplierShift ) ; } }
public String toString ( ) { final StringBuilder b = new StringBuilder ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; }
public InstanceProfileCredentialsProvider withFetcher ( ECSMetadataServiceCredentialsFetcher fetcher ) { this . fetcher = fetcher ; this . fetcher . setRoleName ( roleName ) ; return this ; }
public void setProgressMonitor ( ProgressMonitor pm ) { progressMonitor = pm ; }
public void reset ( ) { if ( ! first ( ) ) { ptr = 0 ; if ( ! eof ( ) ) parseEntry ( ) ; } }
public E previous ( ) { if ( iterator . previousIndex ( ) >= start ) { return iterator . previous ( ) ; } throw new NoSuchElementException ( ) ; }
public String getNewPrefix ( ) { return this . newPrefix ; }
public List < Pair < String , Double >> customerExpensiveOrdersTotalMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public int projectedStringElementAt ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . skip ( 2 ) . findFirst ( ) . getAsInt ( ) ; return firstStringLength ; }
public List < Pair < String , Integer >> customerEachCountryOrdersMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMin ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . skip ( 3 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public int oddNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . findFirst ( ) . orElse ( - 2 ) ; return firstNum ; }
public List < Pair < String , Integer >> customerExpensiveOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Integer > intWithSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] < i * i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public int [ ] projectionIntConcat ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] allNumbers = IntStream . concat ( first , second ) . toArray ( ) ; return allNumbers ; }
public List < Integer > rangeOfEvenIntsStartFrom ( int start , int count ) { List < Integer > numbers = IntStream . range ( start , start + count ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Pair < String , String >> productLeftOuterJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getProductName ( ) : " No ▁ Product " ) ) ) . toList ( ) ; return q ; }
public List < Triplet < String , Integer , Double >> customerSelectManyCustomerNewOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , List < Product >> productEachCategoryMaxUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public Product productFirstOrDefault ( ) { List < Product > products = getProductList ( ) ; Product product12 = products . stream ( ) . filter ( p -> p . getProductId ( ) == 12 ) . findFirst ( ) . orElse ( Product . DEFAULT ) ; return product12 ; }
public int oddFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int factorsCount = ( int ) Arrays . stream ( factorsOf300 ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return factorsCount ; }
public List < Double > doubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public double doubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . findFirst ( ) . orElse ( 3.14 ) ; return firstNum ; }
public List < Integer > rangeOfEvenIntsStartFrom ( ) { List < Integer > numbers = IntStream . range ( 100 , 200 ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public Map < String , List < Product >> productEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public Map < String , Double > customerOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
int countWords ( String str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ; else count *= 2 ; return count ; }
int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
int findSum ( int [ ] arr , int n , int k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
void decodeStr ( String str , int len ) { char [ ] c = new char [ len ] ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str . charAt ( 0 ) ; if ( len % 2 == 0 ) c [ med + 1 ] = str . charAt ( 1 ) ; if ( len % 2 == 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str . charAt ( i ) ; if ( len % 2 == 1 ) c [ med + pos ] = str . charAt ( i + 1 ) ; else c [ med + pos + 1 ] = str . charAt ( i + 1 ) ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) System . out . print ( c [ i ] ) ; }
int countSubArrayWithOddProduct ( int A [ ] , int N ) { int count = 0 ; int last = - 1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
int nthTerm ( int N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
int smallestNum ( int N ) { float x = ( float ) ( Math . pow ( 10 , ( N - 1 ) / 2.0 ) ) ; return ( int ) ( Math . ceil ( x ) ) ; }
long multiplyFactors ( int n ) { long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
int deleteElement ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
int findNumberOfTriangles ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; }
int cntPairs ( int a [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
boolean isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( float ) ( ( 3.14f * r * r ) / 4 ) ; return a ; }
void findSetBits ( int n ) { int [ ] dp = new int [ n + 1 ] ; System . out . print ( dp [ 0 ] + " ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i / 2 ] ; } else { dp [ i ] = dp [ i / 2 ] + 1 ; } System . out . print ( dp [ i ] + " ▁ " ) ; } }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
int check ( int n , List < Integer > marks ) { Integer x = Collections . max ( marks ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks . get ( i ) + bonus >= 50 ) c += 1 ; } return c ; }
double octaside ( double a ) { if ( a < 0 ) return - 1 ; double s = a / ( Math . sqrt ( 2 ) + 1 ) ; return s ; }
int countTriplets ( int [ ] A ) { int cnt = 0 ; HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ; for ( int a : A ) for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; } for ( int a : A ) for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) ) if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ; return cnt ; }
int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
boolean isSubseqPossible ( int [ ] arr , int N , int K ) { int i ; int odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
