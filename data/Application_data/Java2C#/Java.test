public List < Pair < String , Double >> customerExpensiveOrdersTotalMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public int projectedStringElementAt ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . skip ( 2 ) . findFirst ( ) . getAsInt ( ) ; return firstStringLength ; }
public List < Pair < String , Integer >> customerEachCountryOrdersMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMin ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedSkip ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . skip ( 3 ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public int oddNumbersFirstOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . findFirst ( ) . orElse ( - 2 ) ; return firstNum ; }
public List < Pair < String , Integer >> customerExpensiveOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public List < Integer > intWithSquareIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] < i * i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public int [ ] projectionIntConcat ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] allNumbers = IntStream . concat ( first , second ) . toArray ( ) ; return allNumbers ; }
public List < Integer > rangeOfEvenIntsStartFrom ( int start , int count ) { List < Integer > numbers = IntStream . range ( start , start + count ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public List < Pair < String , String >> productLeftOuterJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getProductName ( ) : " No ▁ Product " ) ) ) . toList ( ) ; return q ; }
public List < Triplet < String , Integer , Double >> customerSelectManyCustomerNewOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , List < Product >> productEachCategoryMaxUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public Product productFirstOrDefault ( ) { List < Product > products = getProductList ( ) ; Product product12 = products . stream ( ) . filter ( p -> p . getProductId ( ) == 12 ) . findFirst ( ) . orElse ( Product . DEFAULT ) ; return product12 ; }
public int oddFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int factorsCount = ( int ) Arrays . stream ( factorsOf300 ) . filter ( n -> ( n % 2 == 1 ) ) . count ( ) ; return factorsCount ; }
public List < Double > doubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public double doubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . findFirst ( ) . orElse ( 3.14 ) ; return firstNum ; }
public List < Integer > rangeOfEvenIntsStartFrom ( ) { List < Integer > numbers = IntStream . range ( 100 , 200 ) . filter ( n -> n % 2 == 0 ) . boxed ( ) . toList ( ) ; return numbers ; }
public Map < String , List < Product >> productEachCategoryMinUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return categories ; }
public Map < String , Double > customerOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public List < Pair < String , List < Order >>> customerIdAndOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Order >>> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Double > bigDoubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Pair < String , Order >> customerSelectManyCustomerOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o ) ) ) . toList ( ) ; return customerProperties ; }
public Map < String , Map < String , Customer >> customerNestedGroupByRegionAndName ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Map < String , Customer >> customerGroups = customers . stream ( ) . collect ( groupingBy ( p -> p . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( toMap ( c -> c . getCompanyName ( ) , c -> c ) ) ) ) ; return customerGroups ; }
public List < Order > customerOrdersTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . takeWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public Map < Double , Double > convertArrayToDictionaryWithDistinctAndPrint ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 1.7 , 2.9 } ; Map < Double , Double > doublesDict = Arrays . stream ( doubles ) . distinct ( ) . boxed ( ) . collect ( toMap ( sr -> sr , sr -> sr * 2 ) ) ; for ( var pair : doublesDict . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return doublesDict ; }
public double [ ] projectionDoubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] sharedNumbers = first . distinct ( ) . filter ( a -> second . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedNumbers ; }
public List < Pair < String , String >> customerCrossGroupJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getPhone ( ) ) ) ) . toList ( ) ; return q ; }
public List < Double > bigDoubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public List < Integer > intTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> numbers [ i ] > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < Integer > intSkipWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> numbers [ i ] > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public double bigNumbersAverageTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public Map < String , Double > customerExpensiveOrdersTotalSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public Map < String , List < Product >> productEachGroupTake ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . limit ( 3 ) . toList ( ) ) ) ; return after3EachGroups ; }
public double bigDoubleNumbersFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . filter ( d -> d > 5 ) . findFirst ( ) . getAsDouble ( ) ; return firstNum ; }
public double productUnitPriceMin ( ) { List < Product > products = getProductList ( ) ; double minUnitPrice = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . min ( ) . getAsDouble ( ) ; return minUnitPrice ; }
public List < Pair < String , String >> customerLeftOuterJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getCompanyName ( ) : " No ▁ Customer " ) ) ) . toList ( ) ; return q ; }
public int projectedBigNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . map ( i -> ( int ) Math . pow ( 2 , i ) ) . filter ( n -> n > 100 ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public Map < Integer , Map < Integer , List < Order >>> customerNestedGroupByOrderYearAndMonth ( ) { List < Customer > customers = getCustomerList ( ) ; Map < Integer , Map < Integer , List < Order >>> customerOrderGroups = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getYear ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( o -> o . getOrderDate ( ) . getMonthValue ( ) ) ) ) ) ; return customerOrderGroups ; }
public List < Pair < String , List < Product >>> productEachCategoryFirstOrDefaultUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . orElse ( Product . DEFAULT ) . getUnitPrice ( ) ) . toList ( ) ) ) . toList ( ) ; return categories ; }
public boolean stringAnyMatch ( char c ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . anyMatch ( w -> w . charAt ( 0 ) > c ) ; return anyMatch ; }
public Map < String , Double > customerEachRegionOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < Pair < Double , List < Double >>> doubleGroupByMod ( ) { double [ ] numbers = { 5.8 , 4.3 , 1.5 , 3.7 , 9.3 } ; List < Pair < Double , List < Double >>> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n % 1.5 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public Map < String , Integer > customerEachRegionOrdersMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) ; return ordersMin ; }
public int bigNumbersSumTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . sum ( ) ; return numbersSum ; }
public List < Integer > intSquareSkipWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . dropWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public Map < String , Boolean > productEachGroupAllMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > allMatch = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return allMatch ; }
public boolean longStringAnyMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . anyMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return anyMatch ; }
public List < Product > productOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public Boolean [ ] bigIntWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] bigNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . toArray ( ) ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , bigNumbers . length ) . mapToObj ( i -> bigNumbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public double productUnitPriceSum ( ) { List < Product > products = getProductList ( ) ; double totalSum = products . stream ( ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . sum ( ) ; return totalSum ; }
public List < Pair < String , Customer >> customerLeftOuterJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Customer >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public Map < String , Integer > customerNewOrdersCountDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > orderCounts = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> ( int ) c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . count ( ) ) ) ; return orderCounts ; }
public List < String > stringOrderbyLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . toList ( ) ; return sortedWords ; }
public String [ ] selectByCaseConcat ( ) { String [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; String [ ] upperLowerWords = ( String [ ] ) Arrays . stream ( words ) . map ( w -> w . toUpperCase ( ) + w . toLowerCase ( ) ) . toArray ( ) ; return upperLowerWords ; }
public List < Product > productOrderbyDescendingId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public Map < String , List < Product >> productsConvertGroupingToDictionaryAndPrint ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> catagory = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) ; for ( var pair : catagory . entrySet ( ) ) { System . out . println ( pair . getKey ( ) + " : " ) ; for ( var product : pair . getValue ( ) ) System . out . println ( " \ t " + product ) ; } return catagory ; }
public List < Pair < String , Double >> customerOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public List < Pair < Integer , String >> customerCrossJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , String >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Pair . with ( r . getValue1 ( ) , c . getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public double bigNumbersAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> a * b ) ; return product ; }
public int projectedStringFirst ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . findFirst ( ) . getAsInt ( ) ; return firstStringLength ; }
public boolean productAnyMatch ( ) { List < Product > products = getProductList ( ) ; boolean anyMatch = products . stream ( ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return anyMatch ; }
public List < Triplet < String , Integer , Double >> customerSelectManyCustomerOrderIdAndTotals ( ) { List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Double >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Triplet . with ( c . getCustomerId ( ) , o . getOrderId ( ) , o . getTotal ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public int numbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . sum ( ) ; return numbersSum ; }
public Character [ ] shortStringFirstChar ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Character [ ] selected = ( Character [ ] ) Arrays . stream ( strings ) . filter ( w -> w . length ( ) < 4 ) . map ( w -> w . charAt ( 0 ) ) . toArray ( ) ; return selected ; }
public int [ ] oddFactorOf300And900Count ( ) { int [ ] [ ] factorsOf300And900 = { { 2 , 2 , 3 , 5 , 5 } , { 2 , 2 , 3 , 3 , 5 , 5 } } ; int [ ] factorsCount = Arrays . stream ( factorsOf300And900 ) . mapToInt ( a -> ( int ) Arrays . stream ( a ) . filter ( n -> n % 2 == 1 ) . count ( ) ) . toArray ( ) ; return factorsCount ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalSum ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) . toList ( ) ; return ordersTotalSum ; }
public int [ ] intPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . map ( n -> n + 1 ) . toArray ( ) ; return numSelected ; }
public List < Pair < String , Customer >> customerCrossGroupJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Customer >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1 ) ) ) . toList ( ) ; return q ; }
public boolean waCustomerOrdersNestedAnyMatch ( ) { List < Customer > customers = getCustomerList ( ) ; boolean anyMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . anyMatch ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ; return anyMatch ; }
public Map < Pair < String , Integer > , List < String >> customerGroupJoinRegionsWithCodeNameRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; Map < Pair < String , Integer > , List < String >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> c . getCompanyName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Pair < String , LocalDate >> customerOrdersNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3Orders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . takeWhile ( t -> t . getValue1 ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . toList ( ) ; return after3Orders ; }
public Pair < Integer , Integer > [ ] selectManyJoinSumEven ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; Pair < Integer , Integer > [ ] pairs = ( Pair < Integer , Integer > [ ] ) Arrays . stream ( numbersA ) . boxed ( ) . flatMap ( a -> Arrays . stream ( numbersB ) . filter ( b -> ( a + b ) % 2 == 0 ) . mapToObj ( b -> Pair . with ( a , b ) ) ) . toArray ( ) ; return pairs ; }
public int [ ] stringLength ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = Arrays . stream ( strings ) . mapToInt ( w -> w . length ( ) ) . toArray ( ) ; return selected ; }
public int shortStringMaxLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int maxLength = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . max ( ) . getAsInt ( ) ; return maxLength ; }
public Boolean [ ] intWithIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , numbers . length ) . mapToObj ( i -> numbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public List < Integer > rangeOfSquareInts ( ) { List < Integer > numbers = IntStream . range ( 0 , 50 ) . map ( n -> n * n ) . boxed ( ) . toList ( ) ; return numbers ; }
public Map < Boolean , List < Double >> doubleGroupByBoolDictOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; Map < Boolean , List < Double >> numbersGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 5 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ) ) ; return numbersGroups ; }
public List < String > shortStringOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public Map < String , Order > customerEachRegionFirstOrderDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Order > ordersFirst = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . findFirst ( ) . get ( ) ) ) ; return ordersFirst ; }
public List < Pair < Boolean , List < Integer >>> productGroupByPriceWithId ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Integer >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) . toList ( ) ; return productGroup ; }
public List < Pair < String , Integer >> customerDistinctOrdersCount ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> orderCounts = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , ( int ) c . getOrders ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return orderCounts ; }
public int oddNumbersSum ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int numbersSum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . sum ( ) ; return numbersSum ; }
public List < Integer > intTakeCount ( int [ ] numbers , int n ) { List < Integer > afterNNumbers = Arrays . stream ( numbers ) . limit ( n ) . boxed ( ) . toList ( ) ; return afterNNumbers ; }
public List < Order > waCustomerSelectManyNewOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < parallel . linq101. datasource . Order > customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Double > doubleFractionOrderbyReverse ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedNumbers ; }
public Map < String , Double > customerExpensiveOrdersTotalMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public Map < Boolean , List < Integer >> productGroupByInStockWithIdDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Integer >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public List < Pair < String , Double >> productCrossJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Double >> q = Arrays . stream ( categories ) . flatMap ( c -> products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p -> Pair . with ( c , p . getUnitPrice ( ) ) ) ) . toList ( ) ; return q ; }
public Map < String , Double > customerOrdersTotalMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMax = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) ; return ordersTotalMax ; }
public List < String > stringTakeCount ( String [ ] strings , int n ) { List < String > afterNWords = Arrays . stream ( strings ) . limit ( 3 ) . toList ( ) ; return afterNWords ; }
public void numbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public double [ ] doublesConvertToDescendingArrayAndPrintForeach ( ) { double [ ] doubles = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double [ ] doublesArray = Arrays . stream ( doubles ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . mapToDouble ( d -> d ) . toArray ( ) ; for ( double d : doublesArray ) System . out . println ( d ) ; return doublesArray ; }
public double expensiveProductUnitPriceSum ( ) { List < Product > products = getProductList ( ) ; double totalSum = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . sum ( ) ; return totalSum ; }
public List < Double > bigDoubleOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public Map < String , Integer > convertTuplesToDictionaryAndPrint ( ) { List < Pair < String , Integer >> scoreRecords = Arrays . asList ( Pair . with ( " Alice " , 50 ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) ) ; Map < String , Integer > scoreRecordsDict = scoreRecords . stream ( ) . collect ( toMap ( sr -> sr . getValue0 ( ) , sr -> sr . getValue1 ( ) ) ) ; for ( var pair : scoreRecordsDict . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " ▁ " + pair . getValue ( ) ) ; return scoreRecordsDict ; }
public List < Product > repeatedProductsWithCount ( int count ) { List < Product > products = Collections . nCopies ( count , Product . DEFAULT ) ; return products ; }
public List < String > stringSkipWhileCount ( String [ ] strings , char c ) { List < String > afterNWords = Arrays . stream ( strings ) . dropWhile ( w -> w . charAt ( 0 ) > c ) . toList ( ) ; return afterNWords ; }
public List < Integer > intTakeWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public double inputNumbersAggregate ( double [ ] numbers ) { double product = Arrays . stream ( numbers ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public List < String > stringTakeWhileCount ( String [ ] strings , char c ) { List < String > afterNWords = Arrays . stream ( strings ) . takeWhile ( w -> w . charAt ( 0 ) > c ) . toList ( ) ; return afterNWords ; }
public List < Integer > stringLengthTake ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < Integer > after3Words = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . limit ( 3 ) . toList ( ) ; return after3Words ; }
public void stringLengthEager ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . map ( n -> i . addAndGet ( n ) ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public int bigNumbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public List < Product > productIndexedWhere ( ) { List < Product > products = getProductList ( ) ; List < Product > q = IntStream . range ( 0 , products . size ( ) ) . filter ( i -> products . get ( i ) . getUnitsInStock ( ) > 0 && i % 2 == 1 ) . mapToObj ( i -> products . get ( i ) ) . toList ( ) ; return q ; }
public List < Pair < String , Product >> productCrossJoinCategories ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Product >> q = Arrays . stream ( categories ) . flatMap ( c -> products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p -> Pair . with ( c , p ) ) ) . toList ( ) ; return q ; }
public int [ ] shortStringLength ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int [ ] selected = Arrays . stream ( strings ) . filter ( w -> w . length ( ) < 4 ) . mapToInt ( w -> w . length ( ) ) . toArray ( ) ; return selected ; }
public List < Product > inStockProductTakeWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public List < Pair < String , Integer >> convertSelectedTupleToListAndPrint ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; List < Pair < String , Integer >> strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . toList ( ) ; for ( var i = 0 ; i < strings . size ( ) ; i ++ ) System . out . println ( strings . get ( i ) . getValue0 ( ) + " : " + strings . get ( i ) . getValue1 ( ) ) ; return strings ; }
public int [ ] transformIndexHashToInt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] textNums = Arrays . stream ( numbers ) . map ( n -> numbers [ n * 97 % 10 ] ) . toArray ( ) ; return textNums ; }
public int expensiveOrdersCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . filter ( o -> o . getTotal ( ) > 100 ) . count ( ) ; return count ; }
public Map < String , Integer > convertTuplesToDictionary ( ) { List < Pair < String , Integer >> scoreRecords = Arrays . asList ( Pair . with ( " Alice " , 50 ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) ) ; Map < String , Integer > scoreRecordsDict = scoreRecords . stream ( ) . collect ( toMap ( sr -> sr . getValue0 ( ) , sr -> sr . getValue1 ( ) ) ) ; return scoreRecordsDict ; }
public double numbersDoubledAggregateMultiplyWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double product = product = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . reduce ( seed , ( a , b ) -> a * b ) ; return product ; }
public Map < String , List < Double >> productGroupUnitPriceDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Double >> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ) ) ; return productNames ; }
public int [ ] intTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . map ( n -> n * 2 ) . toArray ( ) ; return numSelected ; }
public List < Pair < String , Double >> customerInRegionOrdersTotalMin ( String region ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMin = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMin ; }
public List < Double > outOfStockProductUnitPrice ( ) { List < Product > products = getProductList ( ) ; List < Double > productNames = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) == 0 ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ; return productNames ; }
public boolean equalInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 0 , 2 , 4 , 5 , 9 } ; boolean equal = Arrays . equals ( numbersA , numbersB ) ; return equal ; }
public Product [ ] productsConvertToDescendingArrayAndPrintForeach ( ) { List < Product > products = getProductList ( ) ; Product [ ] productsArray = ( Product [ ] ) products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toArray ( ) ; for ( Product p : productsArray ) System . out . println ( p ) ; return productsArray ; }
public boolean intAnyMatchInput ( int i ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean anyMatch = Arrays . stream ( numbers ) . anyMatch ( n -> n > i ) ; return anyMatch ; }
public List < String > longStringIndexedWhere ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; String [ ] longWords = ( String [ ] ) Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . toArray ( ) ; List < String > q = IntStream . range ( 0 , longWords . length ) . filter ( i -> longWords [ i ] . length ( ) < i * 3 ) . mapToObj ( i -> longWords [ i ] ) . toList ( ) ; return q ; }
public List < String > stringOrderbyLengthCustomThenby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w . length ( ) , new CustomNumberComparer ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Pair < String , Integer >> countRegionDistinctCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> regionCounts = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) . toList ( ) ; return regionCounts ; }
public int [ ] transformIndexToInt ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] textNums = Arrays . stream ( numbers ) . map ( n -> numbers [ n ] ) . toArray ( ) ; return textNums ; }
public List < Double > doubleOrderbyModThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public double expensiveProductUnitPriceAggregateAverageWithSeed ( ) { List < Product > products = getProductList ( ) ; double seed = 15.5 ; double aggregateSum = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . filter ( d -> d > 100 ) . reduce ( seed , ( a , b ) -> ( a + b ) / 2 ) ; return aggregateSum ; }
public List < String > expensiveProductNameOrderbyDescending ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getProductName ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedProducts ; }
public Character [ ] projectionStringExcept ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = Arrays . stream ( wordsA ) . map ( n -> n . charAt ( 0 ) ) ; var second = Arrays . stream ( wordsB ) . map ( n -> n . charAt ( 0 ) ) ; Character [ ] differemtWords = ( Character [ ] ) first . distinct ( ) . filter ( a -> second . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtWords ; }
public Map < String , List < Product >> productEachGroupSkip ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3EachGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . skip ( 3 ) . toList ( ) ) ) ; return after3EachGroups ; }
public List < Pair < String , Product >> productEachCategoryElementAt ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . skip ( 1 ) . findFirst ( ) . get ( ) ) ) . toList ( ) ; return categories ; }
public List < String > stringOrderbyThenbyLengthCustom ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ; return sortedWords ; }
public int distinctProductCategoryCount ( ) { List < Product > products = getProductList ( ) ; int count = ( int ) products . stream ( ) . map ( p -> p . getCategory ( ) ) . distinct ( ) . count ( ) ; return count ; }
public Map < String , List < Customer >> customerEachCountryOrdersMaxCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersMax ; }
public int bigNumbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . map ( n -> n * 2 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public List < Pair < String , String >> customerIdAndName ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> customerProperties = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getCompanyName ( ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < Boolean , List < Product >>> productGroupByInStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < Boolean , List < Product >>> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return productGroup ; }
public double [ ] projectionDoubleConcat ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] allNumbers = DoubleStream . concat ( first , second ) . toArray ( ) ; return allNumbers ; }
public Product [ ] productsConvertToArray ( ) { List < Product > products = getProductList ( ) ; Product [ ] productsArray = ( Product [ ] ) products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) ) ) . toArray ( ) ; return productsArray ; }
public List < Double > doubleOrderbyFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public double expensiveProductUnitPriceAverage ( ) { List < Product > products = getProductList ( ) ; double averageUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . average ( ) . getAsDouble ( ) ; return averageUnitPrice ; }
public List < Product > repeatedProducts ( ) { List < Product > products = Collections . nCopies ( 30 , Product . DEFAULT ) ; return products ; }
public int projectedStringFirstOrDefault ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; int firstStringLength = Arrays . stream ( strings ) . mapToInt ( s -> s . length ( ) ) . filter ( i -> i % 2 == 0 ) . findFirst ( ) . orElse ( - 1 ) ; return firstStringLength ; }
public List < Pair < String , Integer >> convertSelectedTupleToList ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; List < Pair < String , Integer >> strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . toList ( ) ; return strings ; }
public List < Integer > intTakeWhile ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . takeWhile ( i -> i > 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public List < Triplet < String , Integer , String >> customerCrossJoinRegionsWithCodeNameRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , String >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Triplet . with ( r . getValue0 ( ) , r . getValue1 ( ) , c . getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public List < Product > productsConvertToList ( ) { List < Product > products = getProductList ( ) ; List < Product > productsList = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) ) ) . toList ( ) ; return productsList ; }
public List < Product > repeatedProductsWithBase ( Product product ) { List < Product > products = Collections . nCopies ( 10 , product ) ; return products ; }
public List < Pair < String , List < Product >>> productGroupByCategoryOrderbyId ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ) ) . toList ( ) ; return productsGroups ; }
public Map < String , Integer > customerEachRegionOrdersSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . sum ( ) ) ) ; return ordersSum ; }
public List < String > stringIndexedWhere ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; IntStream . range ( 0 , words . length ) . filter ( i -> words [ i ] . length ( ) < i ) . mapToObj ( i -> words [ i ] ) . toList ( ) ; List < String > q = IntStream . range ( 0 , words . length ) . filter ( i -> words [ i ] . length ( ) < i ) . mapToObj ( i -> words [ i ] ) . toList ( ) ; return q ; }
public boolean categoryProductAnyMatch ( ) { List < Product > products = getProductList ( ) ; boolean anyMatch = products . stream ( ) . filter ( p -> p . getCategory ( ) == " Beverages " ) . anyMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return anyMatch ; }
public List < Pair < String , Product >> productEachCategoryFirst ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) ) ) . toList ( ) ; return categories ; }
public double doubleFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . findFirst ( ) . getAsDouble ( ) ; return firstNum ; }
public List < Integer > shortStringLengthOrderbyDescending ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < Integer > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . map ( w -> w . length ( ) ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedWords ; }
public List < Double > bigDoubleFractionOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public Map < String , Integer > convertSelectedTupleToDictionaryAndPrint ( ) { Object [ ] numbers = { Pair . with ( " Alice " , " 50 " ) , Pair . with ( " Bob " , 40 ) , Pair . with ( " Cathy " , 45 ) } ; Map < String , Integer > strings = Arrays . stream ( numbers ) . filter ( o -> o instanceof Pair && ( ( Pair ) o ) . getValue0 ( ) instanceof String && ( ( Pair ) o ) . getValue1 ( ) instanceof Integer ) . map ( o -> ( Pair < String , Integer > ) o ) . collect ( toMap ( p -> p . getValue0 ( ) , p -> p . getValue1 ( ) ) ) ; for ( var pair : strings . entrySet ( ) ) System . out . println ( pair . getKey ( ) + " : " + pair . getValue ( ) ) ; return strings ; }
public double bigDoubleNumbersSum ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numbersSum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . sum ( ) ; return numbersSum ; }
public List < Integer > intIndexedWhere ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > q = IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] < i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return q ; }
public int [ ] oddIntPlusOne ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n + 1 ) . toArray ( ) ; return numSelected ; }
public List < Pair < Boolean , List < String >>> stringGroupByLengthOrderbyLengthCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Boolean , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( w -> w . length ( ) , new CustomNumberComparer ( ) ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public List < String > concatOfRegion ( ) { String [ ] regions = { " WA " , " AF " , " RO " } ; List < Customer > customers = getCustomerList ( ) ; var customerRegions = customers . stream ( ) . map ( c -> c . getRegion ( ) ) ; List < String > allRegions = Stream . concat ( customerRegions , Arrays . stream ( regions ) ) . toList ( ) ; return allRegions ; }
public List < Double > doubleOrderbyFractionThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < Pair < String , Order >> waCustomerSelectManyCustomerNewOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Order >> customerProperties = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o ) ) ) . toList ( ) ; return customerProperties ; }
public List < Order > customerSelectManyNewOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Double > bigDoubleOrderbyModThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 3 ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n % 1.5 ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public int [ ] intZipAdd ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int [ ] addNumbers = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] + numbersB [ i ] ) . toArray ( ) ; return addNumbers ; }
public List < Pair < Boolean , List < Integer >>> intGroupByBool ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Pair < Boolean , List < Integer >>> numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 4 ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return numberGroups ; }
public Map < String , Boolean > expensiveProductEachGroupAllMatch ( ) { List < Product > products = getProductList ( ) ; Map < String , Boolean > allMatch = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ) ) ; return allMatch ; }
public List < String > shortStringOrderbyDescendingLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( Comparator . comparing ( w -> w . length ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedWords ; }
public List < Product > expensiveProductTakeWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public List < Pair < String , Double >> customerOrdersTotalAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalAverage = customers . stream ( ) . map ( c -> Pair . with ( c . getCustomerId ( ) , c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalAverage ; }
public Map < String , Integer > countDistinctProductByCategoryDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categoryCounts = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> ( int ) g . getValue ( ) . stream ( ) . distinct ( ) . count ( ) ) ) ; return categoryCounts ; }
public List < String > stringOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public List < Pair < String , Double >> productCrossGroupJoinCategoriesUnitPrice ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , Double >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1. getUnitPrice ( ) ) ) ) . toList ( ) ; return q ; }
public double numbersAggregateFindMin ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( ( a , b ) -> Math . min ( a , b ) ) . getAsDouble ( ) ; return aggregateSum ; }
public void oddNumbersEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public Map < String , List < Product >> productGroupByCategoryDictOrderbyDescendingId ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> productsGroups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ) ) ; return productsGroups ; }
public boolean unequalStrings ( ) { List < String > wordsA = Arrays . asList ( " Alpha " , " Beta " , " Gamma " ) ; List < String > wordsB = Arrays . asList ( " aLPhA " , " bETa " , " gAaMa " ) ; boolean equal = wordsA . equals ( wordsB ) ; return equal ; }
public List < Double > doubleOrderbyDescendingFraction ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( n -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public List < String > intersectOfCategory ( ) { String [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = getProductList ( ) ; var productCategories = products . stream ( ) . map ( p -> p . getCategory ( ) ) ; List < String > sharedCategories = productCategories . distinct ( ) . filter ( a -> Arrays . stream ( categories ) . anyMatch ( b -> b . equals ( a ) ) ) . toList ( ) ; return sharedCategories ; }
public Map < String , List < String >> customerGroupJoinRegionsName ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; Map < String , List < String >> q = Arrays . stream ( regions ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> c . getCompanyName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public List < Product > productSkip ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . skip ( 3 ) . toList ( ) ; return after3Products ; }
public boolean stringAnyMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . anyMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return anyMatch ; }
public List < Pair < String , List < Customer >>> customerGroupByRegion ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> catagory = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) ) ) . toList ( ) ; return catagory ; }
public void oddNumbersTwiceDeferred ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + i ) ) ; }
public int uniqueFactorsCount ( int [ ] factors ) { int factorsCount = ( int ) Arrays . stream ( factors ) . distinct ( ) . count ( ) ; return factorsCount ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . takeWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public String [ ] stringConcat ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; String [ ] allWords = ( String [ ] ) Stream . concat ( Arrays . stream ( wordsA ) , Arrays . stream ( wordsB ) ) . toArray ( ) ; return allWords ; }
public List < Double > doubleOrderbyFractionDescendingThenbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public Map < Boolean , List < Integer >> intGroupByBoolDictPrint ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Map < Boolean , List < Integer >> numberGroups = numberGroups = Arrays . stream ( numbers ) . boxed ( ) . collect ( groupingBy ( n -> n > 4 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; numberGroups . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; numberGroups . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return numberGroups ; }
public List < Pair < String , LocalDate >> customerSelectManyCustomerOrderDates ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public List < Pair < String , String >> customerCrossJoinRegionsPhone ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , String >> q = Arrays . stream ( regions ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> Pair . with ( r , c . getPhone ( ) ) ) ) . toList ( ) ; return q ; }
public double [ ] doubleIntersect ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] sharedNumbers = Arrays . stream ( numbersA ) . distinct ( ) . filter ( a -> Arrays . stream ( numbersB ) . anyMatch ( b -> b == a ) ) . toArray ( ) ; return sharedNumbers ; }
public List < Character > concatOfNameFirstChar ( ) { List < Product > products = getProductList ( ) ; List < Customer > customers = getCustomerList ( ) ; var productFirstChars = products . stream ( ) . map ( p -> p . getProductName ( ) . charAt ( 0 ) ) ; var customerFirstChars = customers . stream ( ) . map ( c -> c . getCompanyName ( ) . charAt ( 0 ) ) ; List < Character > allFirstChars = Stream . concat ( productFirstChars , customerFirstChars ) . toList ( ) ; return allFirstChars ; }
public List < String > unionOfCategory ( ) { String [ ] categories = { " Furnitures " , " Seagoods " } ; List < Product > products = getProductList ( ) ; var productCategories = products . stream ( ) . map ( p -> p . getCategory ( ) ) ; List < String > uniqueCategories = Stream . concat ( productCategories , Arrays . stream ( categories ) ) . distinct ( ) . toList ( ) ; return uniqueCategories ; }
public double numbersAggregateSqrtWithSeed ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double seed = 1.6 ; double aggregateSum = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( seed , ( a , b ) -> Math . sqrt ( a * b ) ) ; return aggregateSum ; }
public List < Product > productOrderbyCategoryThenbyDescendingName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > expensiveProductOrderbyDescendingName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Pair < Pair < String , Integer > , String >> customerLeftOuterJoinRegionsWithCodeNameRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Pair < String , Integer > , String >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 != null ? p1. getCompanyName ( ) : " No ▁ Customer " ) ) ) . toList ( ) ; return q ; }
public List < Integer > intSquareSkip ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > after3Numbers = Arrays . stream ( numbers ) . map ( i -> i * i ) . skip ( 3 ) . boxed ( ) . toList ( ) ; return after3Numbers ; }
public Pair < String , Boolean > [ ] selectByEvenOdd ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; Pair < String , Boolean > [ ] evenOddWords = ( Pair < String , Boolean > [ ] ) Arrays . stream ( numbers ) . mapToObj ( n -> Pair . with ( strings [ n ] , n % 2 == 0 ) ) . toArray ( ) ; return evenOddWords ; }
public List < Pair < String , Double >> customerEachCountryOrdersAverage ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersAverage = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersAverage ; }
public List < Double > doubleOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public List < Pair < Pair < String , Integer > , Customer >> customerLeftOuterJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Pair < String , Integer > , Customer >> q = regions . stream ( ) . map ( r -> Pair . with ( r , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> defaultIfEmpty ( t . getValue1 ( ) , null ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1 ) ) ) . toList ( ) ; return q ; }
public int [ ] bigIntTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int [ ] numSelected = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n * 2 ) . toArray ( ) ; return numSelected ; }
public List < Pair < String , Double >> expensiveProductEachCategoryStock ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , Double >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . average ( ) . getAsDouble ( ) ) ) . toList ( ) ; return categories ; }
public List < Triplet < String , Integer , Customer >> customerCrossJoinRegionsWithCodeRegion ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Triplet < String , Integer , Customer >> q = regions . stream ( ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r . getValue0 ( ) ) ) . map ( c -> Triplet . with ( r . getValue0 ( ) , r . getValue1 ( ) , c ) ) ) . toList ( ) ; return q ; }
public List < Pair < String , List < Customer >>> customerEachCountryOrdersFirstCustomer ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , List < Customer >>> customerOrdersFirst = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) . getOrders ( ) . size ( ) ) . toList ( ) ) ) . toList ( ) ; return customerOrdersFirst ; }
public double projectedDoubleFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . map ( i -> Math . log ( i ) ) . filter ( n -> n > 3 ) . findFirst ( ) . orElse ( 3.01 ) ; return firstNum ; }
public Map < String , List < String >> productGroupNameDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < String >> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductName ( ) ) . toList ( ) ) ) ; return productNames ; }
public List < String > stringSkipCount ( String [ ] strings , int n ) { List < String > afterNWords = Arrays . stream ( strings ) . skip ( 3 ) . toList ( ) ; return afterNWords ; }
public Map < Boolean , List < Product >> productGroupByInStockDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public Map < String , Double > customerOrdersTotalMinDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalMin = customers . stream ( ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . min ( ) . getAsDouble ( ) ) ) ; return ordersTotalMin ; }
public List < Pair < String , List < Product >>> expensiveProductEachCategoryMinUnitPriceProducts ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < Product >>> categories = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) ) ) . entrySet ( ) . stream ( ) . min ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) . toList ( ) ; return categories ; }
public Map < String , Integer > customerEachCountryOrdersSumDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersSum = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . sum ( ) ) ) ; return ordersSum ; }
public int bigNumbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyDescending ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public double productUnitPriceAggregateAverageWithSeed ( ) { List < Product > products = getProductList ( ) ; double seed = 15.5 ; double aggregateSum = products . stream ( ) . map ( p -> p . getUnitPrice ( ) ) . reduce ( seed , ( a , b ) -> ( a + b ) / 2 ) ; return aggregateSum ; }
public Character [ ] projectionStringConcat ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; var first = Arrays . stream ( wordsA ) . map ( n -> n . charAt ( 0 ) ) ; var second = Arrays . stream ( wordsB ) . map ( n -> n . charAt ( 0 ) ) ; Character [ ] allWords = ( Character [ ] ) Stream . concat ( first , second ) . toArray ( ) ; return allWords ; }
public List < Pair < String , LocalDate >> customerSelectManyCustomerNewOrderDates ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 1998 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return customerProperties ; }
public double [ ] doubleConcat ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; double [ ] allNumbers = DoubleStream . concat ( Arrays . stream ( numbersA ) , Arrays . stream ( numbersB ) ) . toArray ( ) ; return allNumbers ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderbyDescending ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public List < String > longStringSkip ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . skip ( 3 ) . toList ( ) ; return after3Words ; }
public List < Integer > intTakeWhileIndexedCount ( int [ ] numbers , int n ) { List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public String stringFirstOrDefaultStartWith ( char c ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithChar = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == c ) . findFirst ( ) . orElse ( " none " ) ; return startWithChar ; }
public Map < Boolean , List < Integer >> productGroupByPriceWithIdDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Integer >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . map ( p -> p . getProductId ( ) ) . toList ( ) ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public List < String > shortStringOrderby ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " pear " , " peach " , " melon " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( ) . toList ( ) ; return sortedWords ; }
public Boolean [ ] bigIntWithOriginalIndex ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; Boolean [ ] numSelected = ( Boolean [ ] ) IntStream . range ( 0 , numbers . length ) . filter ( i -> numbers [ i ] > 5 ) . filter ( i -> numbers [ i ] % 2 == 1 ) . mapToObj ( i -> numbers [ i ] == i ) . toArray ( ) ; return numSelected ; }
public int numbersFirstOrDefaultOrDefault ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . findFirst ( ) . orElse ( - 1 ) ; return firstNum ; }
public int shortStringMinLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; int minLength = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . min ( ) . getAsInt ( ) ; return minLength ; }
public List < Double > intSqrtTakeWhileIndexed ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Double > afterNumbers = IntStream . range ( 0 , numbers . length ) . takeWhile ( i -> Math . sqrt ( numbers [ i ] ) > i ) . mapToDouble ( i -> Math . sqrt ( numbers [ i ] ) ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < String > longStringSkipWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . dropWhile ( w -> w . charAt ( 0 ) > ' b ' ) . toList ( ) ; return after3Words ; }
public Map < String , List < String >> productGroupJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; Map < String , List < String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . map ( p1 -> p1. getProductName ( ) ) . toList ( ) ) ) . collect ( toMap ( t -> t . getValue0 ( ) , t -> t . getValue1 ( ) ) ) ; return q ; }
public boolean intSquareAllMatch ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; boolean allMatch = Arrays . stream ( numbers ) . map ( i -> i * i ) . allMatch ( n -> n > 3 ) ; return allMatch ; }
public Product [ ] productsConvertToDescendingArrayAndPrint ( ) { List < Product > products = getProductList ( ) ; Product [ ] productsArray = ( Product [ ] ) products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getUnitPrice ( ) , Comparator . reverseOrder ( ) ) ) . toArray ( ) ; for ( int i = 0 ; i < productsArray . length ; i ++ ) System . out . println ( productsArray [ i ] ) ; return productsArray ; }
public List < Pair < String , LocalDate >> customerOrdersEachNestedSkipWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachOrders = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . dropWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachOrders ; }
public List < Boolean > waCustomerOrdersEachNestedAllMatch ( ) { List < Customer > customers = getCustomerList ( ) ; List < Boolean > allMatch = customers . stream ( ) . filter ( c -> c . getRegion ( ) == " WA " ) . map ( c -> c . getOrders ( ) . stream ( ) . allMatch ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) ) . toList ( ) ; return allMatch ; }
public Map < String , List < Order >> customerEachRegionOrdersTotalMaxCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Order >> customerOrdersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . collect ( groupingBy ( o -> o . getTotal ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersTotalMax ; }
public double doubleSum ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double numbersSum = Arrays . stream ( numbers ) . sum ( ) ; return numbersSum ; }
public String [ ] stringProjectionZipAdd ( ) { String [ ] wordsA = { " Alpha " , " Beta " , " Gamma " } ; String [ ] wordsB = { " red " , " green " , " blue " } ; int length = wordsA . length ; String [ ] results = ( String [ ] ) IntStream . range ( 0 , length ) . mapToObj ( i -> String . valueOf ( wordsA [ i ] . charAt ( 0 ) ) + wordsB [ i ] . charAt ( 0 ) ) . toArray ( ) ; return results ; }
public Map < String , List < Product >> productGroupSkipWhile ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . dropWhile ( g -> g . getKey ( ) . length ( ) > 6 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public List < Pair < String , List < String >>> productGroupName ( ) { List < Product > products = getProductList ( ) ; List < Pair < String , List < String >>> productNames = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . map ( p -> p . getProductName ( ) ) . toList ( ) ) ) . toList ( ) ; return productNames ; }
public List < Pair < Integer , String >> customerCrossGroupJoinRegionsWithCodeName ( ) { List < Pair < String , Integer >> regions = Arrays . asList ( Pair . with ( " BC " , 101 ) , Pair . with ( " BC " , 105 ) , Pair . with ( " OR " , 121 ) , Pair . with ( " LA " , 143 ) ) ; List < Customer > customers = getCustomerList ( ) ; List < Pair < Integer , String >> q = regions . stream ( ) . map ( r -> Pair . with ( r . getValue1 ( ) , customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( c1 -> Pair . with ( t . getValue0 ( ) , c1. getCompanyName ( ) ) ) ) . toList ( ) ; return q ; }
public Map < String , List < Product >> productsConvertGroupingToDictionary ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> catagory = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) ; return catagory ; }
public List < Product > repeatedProductsWithBaseAndCount ( Product product , int count ) { List < Product > products = Collections . nCopies ( count , product ) ; return products ; }
public List < Integer > intsConvertToList ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < Integer > intsList = Arrays . stream ( ints ) . boxed ( ) . sorted ( ) . toList ( ) ; return intsList ; }
public List < Pair < Character , List < String >>> stringGroupByFirstCharOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < Pair < Character , List < String >>> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ) ) . toList ( ) ; return wordsGroups ; }
public List < Pair < String , Customer >> customerCrossJoinRegions ( ) { String [ ] regions = { " BC " , " SP " , " OR " , " LA " } ; List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Customer >> q = Arrays . stream ( regions ) . flatMap ( r -> customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( r ) ) . map ( c -> Pair . with ( r , c ) ) ) . toList ( ) ; return q ; }
public double bigNumbersAggregateMultiply ( ) { double [ ] numbers = { 1.7 , 2.3 , 1.9 , 4.1 , 2.9 } ; double product = Arrays . stream ( numbers ) . filter ( n -> n > 2 ) . reduce ( ( a , b ) -> a * b ) . getAsDouble ( ) ; return product ; }
public String stringElementAtStartWithO ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithO = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == ' o ' ) . skip ( 0 ) . findFirst ( ) . get ( ) ; return startWithO ; }
public int aggregateWithdrawMoney ( ) { int [ ] attemptedWithdrawals = { 100 , 20 , 10 , 40 , 50 , 10 , 70 , 30 } ; int endBalance = Arrays . stream ( attemptedWithdrawals ) . reduce ( ( balance , nextWithdrawal ) -> nextWithdrawal <= balance ? balance - nextWithdrawal : balance ) . getAsInt ( ) ; return 0 ; }
public int [ ] intZipSub ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 , 10 , 11 } ; int length = numbersA . length ; int [ ] subNumbers = IntStream . range ( 0 , length ) . map ( i -> numbersA [ i ] - numbersB [ i ] ) . toArray ( ) ; return subNumbers ; }
public List < Integer > intSkipWhileIndexedCount ( int n ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; List < Integer > afterNumbers = IntStream . range ( 0 , numbers . length ) . dropWhile ( i -> n > i ) . map ( i -> numbers [ i ] ) . boxed ( ) . toList ( ) ; return afterNumbers ; }
public List < String > longStringTakeWhile ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > after3Words = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . takeWhile ( w -> w . charAt ( 0 ) > ' b ' ) . toList ( ) ; return after3Words ; }
public String stringElementAtStartWith ( char c ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startWithO = Arrays . stream ( strings ) . filter ( s -> s . charAt ( 0 ) == c ) . skip ( 2 ) . findFirst ( ) . get ( ) ; return startWithO ; }
public Map < String , List < Customer >> customerEachRegionOrdersMaxCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . collect ( groupingBy ( c -> c . getOrders ( ) . size ( ) ) ) . entrySet ( ) . stream ( ) . max ( Map . Entry . comparingByKey ( ) ) . get ( ) . getValue ( ) ) ) ; return customerOrdersMax ; }
public boolean stringLengthAnyMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean anyMatch = Arrays . stream ( words ) . map ( w -> w . length ( ) ) . anyMatch ( n -> n > 5 ) ; return anyMatch ; }
public List < String > stringOrderbyDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( new CaseInsensitiveComparer ( ) . reversed ( ) ) . toList ( ) ; return sortedWords ; }
public String stringFirstOrDefaultLong ( ) { String [ ] strings = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; String startsWithO = Arrays . stream ( strings ) . filter ( s -> s . length ( ) > 4 ) . findFirst ( ) . orElse ( " empty " ) ; return startsWithO ; }
public boolean projectionEqualInts ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 6 , 10 } ; boolean equal = Arrays . equals ( Arrays . stream ( numbersA ) . map ( n -> n + 1 ) . toArray ( ) , numbersB ) ; return equal ; }
public Map < Boolean , List < String >> stringGroupByLengthDict ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Boolean , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . length ( ) > 8 ) ) ; return wordsGroups ; }
public List < Double > doubleOrderby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( ) . toList ( ) ; return sortedNumbers ; }
public String [ ] selectByStringAndLengthConcat ( ) { String [ ] words = { " aPPLE " , " BlUeBeRrY " , " cHeRry " } ; String [ ] upperLowerWords = ( String [ ] ) Arrays . stream ( words ) . map ( w -> w + w . length ( ) ) . toArray ( ) ; return upperLowerWords ; }
public List < Pair < String , Integer >> customerEachRegionOrdersMin ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Integer >> ordersMin = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . min ( ) . getAsInt ( ) ) ) . toList ( ) ; return ordersMin ; }
public double projectedDoubleFirst ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . map ( i -> Math . log ( i ) ) . filter ( n -> n > 3 ) . findFirst ( ) . getAsDouble ( ) ; return firstNum ; }
public double expensiveProductUnitPriceMin ( ) { List < Product > products = getProductList ( ) ; double minUnitPrice = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToDouble ( p -> p . getUnitPrice ( ) ) . min ( ) . getAsDouble ( ) ; return minUnitPrice ; }
public List < String > stringOrderbyCustomThenbyLengthDescendingCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w , new CaseInsensitiveComparer ( ) ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public int [ ] projectionIntUnion ( ) { int [ ] numbersA = { 0 , 2 , 4 , 5 , 6 , 8 , 9 } ; int [ ] numbersB = { 1 , 3 , 5 , 7 , 8 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n + 1 ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - 1 ) ; int [ ] uniqueNumbers = IntStream . concat ( first , second ) . distinct ( ) . toArray ( ) ; return uniqueNumbers ; }
public String [ ] stringExcept ( ) { String [ ] wordsA = { " Alice " , " Bob " , " Foo " , " Bar " } ; String [ ] wordsB = { " Cafe " , " Bar " , " Restaurant " } ; String [ ] differemtWords = ( String [ ] ) Arrays . stream ( wordsA ) . distinct ( ) . filter ( a -> Arrays . stream ( wordsB ) . allMatch ( b -> ! b . equals ( a ) ) ) . toArray ( ) ; return differemtWords ; }
public Map < Character , List < String >> stringGroupByFirstCharDictOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> Character . toLowerCase ( w . charAt ( 0 ) ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ) ) ; return wordsGroups ; }
public Map < String , Integer > expensiveProductEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . max ( ) . getAsInt ( ) ) ) ; return categories ; }
public Map < String , List < Product >> productEachCategoryFirstUnitPriceProductsDict ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) . getUnitPrice ( ) ) . toList ( ) ) ) ; return categories ; }
public List < String > stringOrderbyLengthReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( w -> w . length ( ) ) ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public int oddNumbersMaxTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . map ( n -> n * 2 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public List < Product > productOrderbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ; return sortedProducts ; }
public boolean expensiveProductAllMatch ( ) { List < Product > products = getProductList ( ) ; boolean allMatch = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . allMatch ( p -> p . getUnitsInStock ( ) > 0 ) ; return allMatch ; }
public List < Product > expensiveProductOrderbyId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . sorted ( Comparator . comparing ( p -> p . getProductId ( ) ) ) . toList ( ) ; return sortedProducts ; }
public double shortStringAverageLength ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; double averageLength = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 7 ) . mapToInt ( w -> w . length ( ) ) . average ( ) . getAsDouble ( ) ; return averageLength ; }
public int oddNumbersMax ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int maxNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . max ( ) . getAsInt ( ) ; return maxNum ; }
public List < Double > expensiveProductUnitPrice ( ) { List < Product > products = getProductList ( ) ; List < Double > productNames = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getUnitPrice ( ) ) . toList ( ) ; return productNames ; }
public double [ ] projectionDoubleExcept ( ) { double [ ] numbersA = { 0.1 , 2.2 , 4.3 , 5.4 , 6.5 , 8.6 , 9.7 } ; double [ ] numbersB = { 0.1 , 3.3 , 5.4 , 7.7 , 8.6 } ; var first = Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) ; var second = Arrays . stream ( numbersB ) . map ( n -> n - ( int ) n ) ; double [ ] differemtNumbers = first . distinct ( ) . filter ( a -> second . allMatch ( b -> b != a ) ) . toArray ( ) ; return differemtNumbers ; }
public List < Pair < String , String >> productCrossGroupJoinCategoriesName ( ) { String [ ] categories = { " Beverages " , " Condiments " , " Vegetables " , " Dairy ▁ Products " , " Seafood " } ; List < Product > products = getProductList ( ) ; List < Pair < String , String >> q = Arrays . stream ( categories ) . map ( c -> Pair . with ( c , products . stream ( ) . filter ( p -> p . getCategory ( ) . equals ( c ) ) . collect ( Collectors . toList ( ) ) ) ) . flatMap ( t -> t . getValue1 ( ) . stream ( ) . map ( p1 -> Pair . with ( t . getValue0 ( ) , p1. getProductName ( ) ) ) ) . toList ( ) ; return q ; }
public Map < Boolean , List < Product >> productGroupByPriceDictPrint ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) ; productGroup . get ( true ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; System . out . println ( ) ; productGroup . get ( false ) . stream ( ) . forEach ( n -> System . out . print ( n ) ) ; return productGroup ; }
public int [ ] intsConvertToArrayAndPrintForeach ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; int [ ] intsArray = Arrays . stream ( ints ) . sorted ( ) . toArray ( ) ; for ( int i : intsArray ) System . out . println ( i ) ; return intsArray ; }
public List < Product > inStockProductSkipWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . filter ( p -> p . getUnitsInStock ( ) > 100 ) . dropWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public int oddNumbersFirst ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int firstNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . findFirst ( ) . getAsInt ( ) ; return firstNum ; }
public int totalOrdersCount ( String region ) { List < Customer > customers = getCustomerList ( ) ; int count = ( int ) customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . count ( ) ; return count ; }
public Map < Character , List < String >> stringGroupByFirstCharDict ( ) { String [ ] words = { " blueberry " , " chimpanzee " , " abacus " , " banana " , " apple " , " cheese " } ; Map < Character , List < String >> wordsGroups = Arrays . stream ( words ) . collect ( groupingBy ( w -> w . charAt ( 0 ) ) ) ; return wordsGroups ; }
public List < String > stringReverse ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " } ; List < String > sortedWords = Arrays . stream ( words ) . collect ( collectingAndThen ( toList ( ) , l -> { Collections . reverse ( l ) ; return l ; } ) ) ; return sortedWords ; }
public Map < String , Integer > customerEachCountryOrdersMaxDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Integer > ordersMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getCountry ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . mapToInt ( c -> c . getOrders ( ) . size ( ) ) . max ( ) . getAsInt ( ) ) ) ; return ordersMax ; }
public double bigNumbersAverage ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; double averageNum = Arrays . stream ( numbers ) . filter ( n -> n >= 5 ) . average ( ) . getAsDouble ( ) ; return averageNum ; }
public void oddNumbersTwiceEager ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; AtomicInteger i = new AtomicInteger ( 0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . map ( n -> n * 2 ) . map ( n -> i . addAndGet ( n ) ) . boxed ( ) . toList ( ) ; for ( var v : q ) System . out . println ( v + " ▁ " + i ) ; }
public Map < Integer , Boolean > rangeOfIntsToDict ( ) { Map < Integer , Boolean > numbers = IntStream . range ( 0 , 100 ) . boxed ( ) . collect ( toMap ( n -> n , n -> n % 2 == 0 ) ) ; return numbers ; }
public List < Integer > intsConvertToDescendingListAndPrint ( ) { int [ ] ints = { 2 , 3 , 1 , 5 , 4 } ; List < Integer > intsList = Arrays . stream ( ints ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; for ( int i = 0 ; i < intsList . size ( ) ; i ++ ) System . out . println ( intsList . get ( i ) ) ; return intsList ; }
public Map < String , List < Customer >> customerEachCountryOrdersFirstCustomerDict ( ) { List < Customer > customers = getCustomerList ( ) ; Map < String , List < Customer >> customerOrdersFirst = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( c -> c . getOrders ( ) . size ( ) == g . getValue ( ) . stream ( ) . findFirst ( ) . get ( ) . getOrders ( ) . size ( ) ) . toList ( ) ) ) ; return customerOrdersFirst ; }
public List < Pair < String , Double >> customerEachRegionOrdersTotalMax ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , Double >> ordersTotalMax = customers . stream ( ) . collect ( groupingBy ( c -> c . getRegion ( ) ) ) . entrySet ( ) . stream ( ) . map ( g -> Pair . with ( g . getKey ( ) , g . getValue ( ) . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) ) . mapToDouble ( o -> o . getTotal ( ) ) . max ( ) . getAsDouble ( ) ) ) . toList ( ) ; return ordersTotalMax ; }
public List < Double > bigDoubleFractionOrderbyDescending ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> n - ( int ) n ) . boxed ( ) . sorted ( Comparator . reverseOrder ( ) ) . toList ( ) ; return sortedNumbers ; }
public Map < Boolean , List < Product >> productGroupByInStockDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitsInStock ( ) > 0 ) ) ; return productGroup ; }
public int uniqueFactorOf300Count ( ) { int [ ] factorsOf300 = { 2 , 2 , 3 , 5 , 5 } ; int uniqueFactorsCount = ( int ) Arrays . stream ( factorsOf300 ) . distinct ( ) . count ( ) ; return uniqueFactorsCount ; }
public boolean longStringAllMatch ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; boolean allMatch = Arrays . stream ( words ) . filter ( w -> w . length ( ) > 5 ) . allMatch ( n -> n . compareTo ( " b " ) > 0 ) ; return allMatch ; }
public List < Product > productTakeWhile ( ) { List < Product > products = getProductList ( ) ; List < Product > after3Products = products . stream ( ) . takeWhile ( p -> p . getProductId ( ) > 100 ) . toList ( ) ; return after3Products ; }
public int oddNumbersMinTwice ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . map ( n -> n * 2 ) . min ( ) . getAsInt ( ) ; return minNum ; }
public void bigDoubleNumbersDeferred ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; AtomicReference < Double > d = new AtomicReference <> ( 0.0 ) ; var q = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . map ( n -> d . accumulateAndGet ( n , Double :: sum ) ) ; q . forEach ( v -> System . out . println ( v + " ▁ " + d ) ) ; }
public List < Pair < String , LocalDate >> waCustomerOrdersEachNestedTakeWhile ( ) { List < Customer > customers = getCustomerList ( ) ; List < Pair < String , LocalDate >> after3EachWAOrders = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( " WA " ) ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . takeWhile ( o -> o . getOrderDate ( ) . isAfter ( LocalDate . of ( 2000 , 1 , 1 ) ) ) . map ( o -> Pair . with ( c . getCustomerId ( ) , o . getOrderDate ( ) ) ) ) . toList ( ) ; return after3EachWAOrders ; }
public Map < String , Integer > expensiveProductEachCategoryStockDict ( ) { List < Product > products = getProductList ( ) ; Map < String , Integer > categories = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . mapToInt ( p -> p . getUnitsInStock ( ) ) . sum ( ) ) ) ; return categories ; }
public List < String > stringOrderbyThenbyLengthDescendingCustom ( ) { String [ ] words = { " cherry " , " apple " , " blueberry " , " banana " , " abacus " } ; List < String > sortedWords = Arrays . stream ( words ) . sorted ( Comparator . comparing ( ( String w ) -> w ) . thenComparing ( w -> w . length ( ) , new CustomNumberComparer ( ) . reversed ( ) ) ) . toList ( ) ; return sortedWords ; }
public double bigDoubleNumbersFirstOrDefault ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; double firstNum = Arrays . stream ( numbers ) . filter ( d -> d > 5 ) . findFirst ( ) . orElse ( - 2.3 ) ; return firstNum ; }
public Map < String , Double > customerInRegionOrdersTotalSumDict ( String region ) { List < Customer > customers = getCustomerList ( ) ; Map < String , Double > ordersTotalSum = customers . stream ( ) . filter ( c -> c . getRegion ( ) . equals ( region ) ) . collect ( toMap ( c -> c . getCustomerId ( ) , c -> c . getOrders ( ) . stream ( ) . mapToDouble ( o -> o . getTotal ( ) ) . sum ( ) ) ) ; return ordersTotalSum ; }
public List < Double > doubleOrderbyFractionDescendingThenby ( ) { double [ ] numbers = { 3.1 , 4.2 , 1.6 , 0.7 , 8.7 , 6.9 , 7.4 , 2.5 , 5.7 , 0 } ; List < Double > sortedNumbers = Arrays . stream ( numbers ) . boxed ( ) . sorted ( Comparator . comparing ( ( Double n ) -> n - ( int ) n . doubleValue ( ) , Comparator . reverseOrder ( ) ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . toList ( ) ; return sortedNumbers ; }
public Map < String , List < Product >> productGroupSkip ( ) { List < Product > products = getProductList ( ) ; Map < String , List < Product >> after3Groups = products . stream ( ) . collect ( groupingBy ( p -> p . getCategory ( ) ) ) . entrySet ( ) . stream ( ) . skip ( 3 ) . collect ( toMap ( g -> g . getKey ( ) , g -> g . getValue ( ) ) ) ; return after3Groups ; }
public Map < Boolean , List < Product >> productGroupByPriceDict ( ) { List < Product > products = getProductList ( ) ; Map < Boolean , List < Product >> productGroup = products . stream ( ) . collect ( groupingBy ( p -> p . getUnitPrice ( ) > 100 ) ) ; return productGroup ; }
public int numbersMin ( ) { int [ ] numbers = { 5 , 4 , 1 , 3 , 9 , 8 , 6 , 7 , 2 , 0 } ; int minNum = Arrays . stream ( numbers ) . min ( ) . getAsInt ( ) ; return minNum ; }
public List < String > expensiveProductNameOrderby ( ) { List < Product > products = getProductList ( ) ; List < String > sortedProducts = products . stream ( ) . filter ( p -> p . getUnitPrice ( ) > 100 ) . map ( p -> p . getProductName ( ) ) . sorted ( ) . toList ( ) ; return sortedProducts ; }
public boolean projectionEqualDoubles ( ) { double [ ] numbersA = { 0.5 , 2.3 , 4.7 , 5.4 , 9.8 } ; double [ ] numbersB = { 6.5 , 1.3 , 8.7 , 2.4 , 4.8 } ; boolean equal = Arrays . equals ( Arrays . stream ( numbersA ) . map ( n -> n - ( int ) n ) . toArray ( ) , numbersB ) ; return equal ; }
public List < Product > productOrderbyCategoryThenbyDescendingId ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductId ( ) , Comparator . reverseOrder ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < String > shortStringOrderbyCustom ( ) { String [ ] words = { " aPPLE " , " AbAcUs " , " bRaNcH " , " BlUeBeRrY " , " ClOvEr " , " cHeRry " } ; List < String > sortedWords = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 6 ) . sorted ( new CaseInsensitiveComparer ( ) ) . toList ( ) ; return sortedWords ; }
public List < Product > productOrderbyName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( p -> p . getProductName ( ) ) ) . toList ( ) ; return sortedProducts ; }
public List < Product > productOrderbyCategoryThenbyName ( ) { List < Product > products = getProductList ( ) ; List < Product > sortedProducts = products . stream ( ) . sorted ( Comparator . comparing ( ( Product p ) -> p . getCategory ( ) ) . thenComparing ( p -> p . getProductName ( ) ) ) . toList ( ) ; return sortedProducts ; }
public boolean projectionEqualStrings ( ) { List < String > wordsA = Arrays . asList ( " Alpha " , " Beta " , " Gamma " ) ; List < String > wordsB = Arrays . asList ( " aLPhA " , " bETa " , " gAaMa " ) ; boolean equal = wordsA . stream ( ) . map ( w -> w . toLowerCase ( ) ) . toList ( ) . equals ( wordsB ) ; return equal ; }
public List < Order > customerSelectManyBigOrders ( ) { List < Customer > customers = getCustomerList ( ) ; List < Order > customerProperties = customers . stream ( ) . flatMap ( c -> c . getOrders ( ) . stream ( ) . filter ( o -> o . getTotal ( ) > 100 ) ) . toList ( ) ; return customerProperties ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_vcenter ) ; }
public void addAll ( BlockList < T > src ) { if ( src . size == 0 ) return ; int srcDirIdx = 0 ; for ( ; srcDirIdx < src . tailDirIdx ; srcDirIdx ++ ) addAll ( src . directory [ srcDirIdx ] , 0 , BLOCK_SIZE ) ; if ( src . tailBlkIdx != 0 ) addAll ( src . tailBlock , 0 , src . tailBlkIdx ) ; }
public void writeByte ( byte b ) { if ( upto == blockSize ) { if ( currentBlock != null ) { addBlock ( currentBlock ) ; } currentBlock = new byte [ blockSize ] ; upto = 0 ; } currentBlock [ upto ++ ] = b ; }
public ObjectId getObjectId ( ) { return objectId ; }
public DeleteDomainEntryResult deleteDomainEntry ( DeleteDomainEntryRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDomainEntry ( request ) ; }
public long ramBytesUsed ( ) { return ( ( termOffsets != null ) ? termOffsets . ramBytesUsed ( ) : 0 ) + ( ( termsDictOffsets != null ) ? termsDictOffsets . ramBytesUsed ( ) : 0 ) ; }
public final String getFullMessage ( ) { byte [ ] raw = buffer ; int msgB = RawParseUtils . tagMessage ( raw , 0 ) ; if ( msgB < 0 ) { return " " ; } return RawParseUtils . decode ( guessEncoding ( ) , raw , msgB , raw . length ) ; }
public POIFSFileSystem ( ) { this ( true ) ; _header . setBATCount ( 1 ) ; _header . setBATArray ( new int [ ] { 1 } ) ; BATBlock bb = BATBlock . createEmptyBATBlock ( bigBlockSize , false ) ; bb . setOurBlockIndex ( 1 ) ; _bat_blocks . add ( bb ) ; setNextBlock ( 0 , POIFSConstants . END_OF_CHAIN ) ; setNextBlock ( 1 , POIFSConstants . FAT_SECTOR_BLOCK ) ; _property_table . setStartBlock ( 0 ) ; }
public void init ( int address ) { slice = pool . buffers [ address >> ByteBlockPool . BYTE_BLOCK_SHIFT ] ; assert slice != null ; upto = address & ByteBlockPool . BYTE_BLOCK_MASK ; offset0 = address ; assert upto < slice . length ; }
public SubmoduleAddCommand setPath ( String path ) { this . path = path ; return this ; }
public ListIngestionsResult listIngestions ( ListIngestionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListIngestions ( request ) ; }
public QueryParserTokenManager ( CharStream stream , int lexState ) { this ( stream ) ; SwitchTo ( lexState ) ; }
public GetShardIteratorResult getShardIterator ( GetShardIteratorRequest request ) { request = beforeClientExecution ( request ) ; return executeGetShardIterator ( request ) ; }
public ModifyStrategyRequest ( ) { super ( " aegis " , " 2016 - 11 - 11 " , " ModifyStrategy " , " vipaegis " ) ; setMethod ( MethodType . POST ) ; }
public boolean ready ( ) throws IOException { synchronized ( lock ) { if ( in == null ) { throw new IOException ( " InputStreamReader ▁ is ▁ closed " ) ; } try { return bytes . hasRemaining ( ) || in . available ( ) > 0 ; } catch ( IOException e ) { return false ; } } }
public EscherOptRecord getOptRecord ( ) { return _optRecord ; }
public synchronized int read ( byte [ ] buffer , int offset , int length ) { if ( buffer == null ) { throw new NullPointerException ( " buffer ▁ == ▁ null " ) ; } Arrays . checkOffsetAndCount ( buffer . length , offset , length ) ; if ( length == 0 ) { return 0 ; } int copylen = count - pos < length ? count - pos : length ; for ( int i = 0 ; i < copylen ; i ++ ) { buffer [ offset + i ] = ( byte ) this . buffer . charAt ( pos + i ) ; } pos += copylen ; return copylen ; }
public OpenNLPSentenceBreakIterator ( NLPSentenceDetectorOp sentenceOp ) { this . sentenceOp = sentenceOp ; }
public void print ( String str ) { write ( str != null ? str : String . valueOf ( ( Object ) null ) ) ; }
public NotImplementedFunctionException ( String functionName , NotImplementedException cause ) { super ( functionName , cause ) ; this . functionName = functionName ; }
public V next ( ) { return super . nextEntry ( ) . getValue ( ) ; }
public final void readBytes ( byte [ ] b , int offset , int len , boolean useBuffer ) throws IOException { int available = bufferLength - bufferPosition ; if ( len <= available ) { if ( len > 0 ) System . arraycopy ( buffer , bufferPosition , b , offset , len ) ; bufferPosition += len ; } else { if ( available > 0 ) { System . arraycopy ( buffer , bufferPosition , b , offset , available ) ; offset += available ; len -= available ; bufferPosition += available ; } if ( useBuffer && len < bufferSize ) { refill ( ) ; if ( bufferLength < len ) { System . arraycopy ( buffer , 0 , b , offset , bufferLength ) ; throw new EOFException ( " read ▁ past ▁ EOF : ▁ " + this ) ; } else { System . arraycopy ( buffer , 0 , b , offset , len ) ; bufferPosition = len ; } } else { long after = bufferStart + bufferPosition + len ; if ( after > length ( ) ) throw new EOFException ( " read ▁ past ▁ EOF : ▁ " + this ) ; readInternal ( b , offset , len ) ; bufferStart = after ; bufferPosition = 0 ; bufferLength = 0 ; } } }
public TagQueueResult tagQueue ( TagQueueRequest request ) { request = beforeClientExecution ( request ) ; return executeTagQueue ( request ) ; }
public void remove ( ) { throw new UnsupportedOperationException ( ) ; }
public CacheSubnetGroup modifyCacheSubnetGroup ( ModifyCacheSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyCacheSubnetGroup ( request ) ; }
public void setParams ( String params ) { super . setParams ( params ) ; language = country = variant = " " ; StringTokenizer st = new StringTokenizer ( params , " , " ) ; if ( st . hasMoreTokens ( ) ) language = st . nextToken ( ) ; if ( st . hasMoreTokens ( ) ) country = st . nextToken ( ) ; if ( st . hasMoreTokens ( ) ) variant = st . nextToken ( ) ; }
public DeleteDocumentationVersionResult deleteDocumentationVersion ( DeleteDocumentationVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDocumentationVersion ( request ) ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof FacetLabel ) ) { return false ; } FacetLabel other = ( FacetLabel ) obj ; if ( length != other . length ) { return false ; } for ( int i = length - 1 ; i >= 0 ; i -- ) { if ( ! components [ i ] . equals ( other . components [ i ] ) ) { return false ; } } return true ; }
public GetInstanceAccessDetailsResult getInstanceAccessDetails ( GetInstanceAccessDetailsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetInstanceAccessDetails ( request ) ; }
public HSSFPolygon createPolygon ( HSSFChildAnchor anchor ) { HSSFPolygon shape = new HSSFPolygon ( this , anchor ) ; shape . setParent ( this ) ; shape . setAnchor ( anchor ) ; shapes . add ( shape ) ; onCreate ( shape ) ; return shape ; }
public String getSheetName ( int sheetIndex ) { return getBoundSheetRec ( sheetIndex ) . getSheetname ( ) ; }
public GetDashboardResult getDashboard ( GetDashboardRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDashboard ( request ) ; }
public AssociateSigninDelegateGroupsWithAccountResult associateSigninDelegateGroupsWithAccount ( AssociateSigninDelegateGroupsWithAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateSigninDelegateGroupsWithAccount ( request ) ; }
public void addMultipleBlanks ( MulBlankRecord mbr ) { for ( int j = 0 ; j < mbr . getNumColumns ( ) ; j ++ ) { BlankRecord br = new BlankRecord ( ) ; br . setColumn ( ( short ) ( j + mbr . getFirstColumn ( ) ) ) ; br . setRow ( mbr . getRow ( ) ) ; br . setXFIndex ( mbr . getXFAt ( j ) ) ; insertCell ( br ) ; } }
public static String quote ( String string ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " \\ Q " ) ; int apos = 0 ; int k ; while ( ( k = string . indexOf ( " \\ E " , apos ) ) >= 0 ) { sb . append ( string . substring ( apos , k + 2 ) ) . append ( " \\\\ E \\ Q " ) ; apos = k + 2 ; } return sb . append ( string . substring ( apos ) ) . append ( " \\ E " ) . toString ( ) ; }
public ByteBuffer putInt ( int value ) { throw new ReadOnlyBufferException ( ) ; }
public ArrayPtg ( Object [ ] [ ] values2d ) { int nColumns = values2d [ 0 ] . length ; int nRows = values2d . length ; _nColumns = ( short ) nColumns ; _nRows = ( short ) nRows ; Object [ ] vv = new Object [ _nColumns * _nRows ] ; for ( int r = 0 ; r < nRows ; r ++ ) { Object [ ] rowData = values2d [ r ] ; for ( int c = 0 ; c < nColumns ; c ++ ) { vv [ getValueIndex ( c , r ) ] = rowData [ c ] ; } } _arrayValues = vv ; _reserved0Int = 0 ; _reserved1Short = 0 ; _reserved2Byte = 0 ; }
public GetIceServerConfigResult getIceServerConfig ( GetIceServerConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeGetIceServerConfig ( request ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + getValueAsString ( ) + " ] " ; }
public String toString ( String field ) { return " ToChildBlockJoinQuery ▁ ( " + parentQuery . toString ( ) + " ) " ; }
public final void incRef ( ) { refCount . incrementAndGet ( ) ; }
public UpdateConfigurationSetSendingEnabledResult updateConfigurationSetSendingEnabled ( UpdateConfigurationSetSendingEnabledRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateConfigurationSetSendingEnabled ( request ) ; }
public int getNextXBATChainOffset ( ) { return getXBATEntriesPerBlock ( ) * LittleEndianConsts . INT_SIZE ; }
public void multiplyByPowerOfTen ( int pow10 ) { TenPower tp = TenPower . getInstance ( Math . abs ( pow10 ) ) ; if ( pow10 < 0 ) { mulShift ( tp . _divisor , tp . _divisorShift ) ; } else { mulShift ( tp . _multiplicand , tp . _multiplierShift ) ; } }
public String toString ( ) { final StringBuilder b = new StringBuilder ( ) ; final int l = length ( ) ; b . append ( File . separatorChar ) ; for ( int i = 0 ; i < l ; i ++ ) { b . append ( getComponent ( i ) ) ; if ( i < l - 1 ) { b . append ( File . separatorChar ) ; } } return b . toString ( ) ; }
public InstanceProfileCredentialsProvider withFetcher ( ECSMetadataServiceCredentialsFetcher fetcher ) { this . fetcher = fetcher ; this . fetcher . setRoleName ( roleName ) ; return this ; }
public void setProgressMonitor ( ProgressMonitor pm ) { progressMonitor = pm ; }
public void reset ( ) { if ( ! first ( ) ) { ptr = 0 ; if ( ! eof ( ) ) parseEntry ( ) ; } }
public E previous ( ) { if ( iterator . previousIndex ( ) >= start ) { return iterator . previous ( ) ; } throw new NoSuchElementException ( ) ; }
public String getNewPrefix ( ) { return this . newPrefix ; }
public int indexOfValue ( int value ) { for ( int i = 0 ; i < mSize ; i ++ ) if ( mValues [ i ] == value ) return i ; return - 1 ; }
public List < CharsRef > uniqueStems ( char word [ ] , int length ) { List < CharsRef > stems = stem ( word , length ) ; if ( stems . size ( ) < 2 ) { return stems ; } CharArraySet terms = new CharArraySet ( 8 , dictionary . ignoreCase ) ; List < CharsRef > deduped = new ArrayList <> ( ) ; for ( CharsRef s : stems ) { if ( ! terms . contains ( s ) ) { deduped . add ( s ) ; terms . add ( s ) ; } } return deduped ; }
public GetGatewayResponsesResult getGatewayResponses ( GetGatewayResponsesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetGatewayResponses ( request ) ; }
public void setPosition ( long pos ) { currentBlockIndex = ( int ) ( pos >> blockBits ) ; currentBlock = blocks [ currentBlockIndex ] ; currentBlockUpto = ( int ) ( pos & blockMask ) ; }
public long skip ( long n ) { int s = ( int ) Math . min ( available ( ) , Math . max ( 0 , n ) ) ; ptr += s ; return s ; }
public BootstrapActionDetail ( BootstrapActionConfig bootstrapActionConfig ) { setBootstrapActionConfig ( bootstrapActionConfig ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_row ) ; out . writeShort ( field_2_col ) ; out . writeShort ( field_3_flags ) ; out . writeShort ( field_4_shapeid ) ; out . writeShort ( field_6_author . length ( ) ) ; out . writeByte ( field_5_hasMultibyte ? 0x01 : 0x00 ) ; if ( field_5_hasMultibyte ) { StringUtil . putUnicodeLE ( field_6_author , out ) ; } else { StringUtil . putCompressedUnicode ( field_6_author , out ) ; } if ( field_7_padding != null ) { out . writeByte ( field_7_padding . intValue ( ) ) ; } }
public int lastIndexOf ( String string ) { return lastIndexOf ( string , count ) ; }
public boolean add ( E object ) { return addLastImpl ( object ) ; }
public void unsetSection ( String section , String subsection ) { ConfigSnapshot src , res ; do { src = state . get ( ) ; res = unsetSection ( src , section , subsection ) ; } while ( ! state . compareAndSet ( src , res ) ) ; }
public final String getTagName ( ) { return tagName ; }
public void addSubRecord ( int index , SubRecord element ) { subrecords . add ( index , element ) ; }
public boolean remove ( Object o ) { synchronized ( mutex ) { return delegate ( ) . remove ( o ) ; } }
public DoubleMetaphoneFilter create ( TokenStream input ) { return new DoubleMetaphoneFilter ( input , maxCodeLength , inject ) ; }
public long length ( ) { return inCoreLength ( ) ; }
public void setValue ( boolean newValue ) { value = newValue ; }
public Pair ( ContentSource oldSource , ContentSource newSource ) { this . oldSource = oldSource ; this . newSource = newSource ; }
public int get ( int i ) { if ( count <= i ) throw new ArrayIndexOutOfBoundsException ( i ) ; return entries [ i ] ; }
public CreateRepoRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " CreateRepo " , " cr " ) ; setUriPattern ( " / repos " ) ; setMethod ( MethodType . PUT ) ; }
public boolean isDeltaBaseAsOffset ( ) { return deltaBaseAsOffset ; }
public void remove ( ) { if ( expectedModCount == list . modCount ) { if ( lastLink != null ) { Link < ET > next = lastLink . next ; Link < ET > previous = lastLink . previous ; next . previous = previous ; previous . next = next ; if ( lastLink == link ) { pos -- ; } link = previous ; lastLink = null ; expectedModCount ++ ; list . size -- ; list . modCount ++ ; } else { throw new IllegalStateException ( ) ; } } else { throw new ConcurrentModificationException ( ) ; } }
public MergeShardsResult mergeShards ( MergeShardsRequest request ) { request = beforeClientExecution ( request ) ; return executeMergeShards ( request ) ; }
public AllocateHostedConnectionResult allocateHostedConnection ( AllocateHostedConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeAllocateHostedConnection ( request ) ; }
public int getBeginIndex ( ) { return start ; }
public static final WeightedTerm [ ] getTerms ( Query query ) { return getTerms ( query , false ) ; }
public ByteBuffer compact ( ) { throw new ReadOnlyBufferException ( ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = byte0 >>> 2 ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte0 & 3 ) << 4 ) | ( byte1 >>> 4 ) ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 15 ) << 2 ) | ( byte2 >>> 6 ) ; values [ valuesOffset ++ ] = byte2 & 63 ; } }
public String getHumanishName ( ) throws IllegalArgumentException { String s = getPath ( ) ; if ( " / " . equals ( s ) || " " . equals ( s ) ) s = getHost ( ) ; if ( s == null ) throw new IllegalArgumentException ( ) ; String [ ] elements ; if ( " file " . equals ( scheme ) || LOCAL_FILE . matcher ( s ) . matches ( ) ) elements = s . split ( " [ \\ " ▁ + ▁ File . separatorChar ▁ + ▁ " / ] " ) ; ▁ elseelements ▁ = ▁ s . split ( " /+ " ) ; ▁ if ▁ ( elements . length ▁ == ▁ 0 ) throw ▁ new ▁ IllegalArgumentException ( ) ; String ▁ result ▁ = ▁ elements [ elements . length ▁ - ▁ 1 ] ; if ▁ ( Constants . DOT □ GIT . equals ( result ) ) result ▁ = ▁ elements [ elements . length ▁ - ▁ 2 ] ; else ▁ if ▁ ( result . endsWith ( Constants . DOT □ GIT □ EXT ) ) result ▁ = ▁ result . substring ( 0 , ▁ result . length ( ) - ▁ Constants . DOT □ GIT □ EXT . length ( ) ) ; return ▁ result ; }
public DescribeNotebookInstanceLifecycleConfigResult describeNotebookInstanceLifecycleConfig ( DescribeNotebookInstanceLifecycleConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNotebookInstanceLifecycleConfig ( request ) ; }
public String getAccessKeySecret ( ) { return this . accessKeySecret ; }
public CreateVpnConnectionResult createVpnConnection ( CreateVpnConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVpnConnection ( request ) ; }
public DescribeVoicesResult describeVoices ( DescribeVoicesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVoices ( request ) ; }
public ListMonitoringExecutionsResult listMonitoringExecutions ( ListMonitoringExecutionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListMonitoringExecutions ( request ) ; }
public DescribeJobRequest ( String vaultName , String jobId ) { setVaultName ( vaultName ) ; setJobId ( jobId ) ; }
public EscherRecord getEscherRecord ( int index ) { return escherRecords . get ( index ) ; }
public GetApisResult getApis ( GetApisRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApis ( request ) ; }
public DeleteSmsChannelResult deleteSmsChannel ( DeleteSmsChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteSmsChannel ( request ) ; }
public TrackingRefUpdate getTrackingRefUpdate ( ) { return trackingRefUpdate ; }
public void print ( boolean b ) { print ( String . valueOf ( b ) ) ; }
public QueryNode getChild ( ) { return getChildren ( ) . get ( 0 ) ; }
public NotIgnoredFilter ( int workdirTreeIndex ) { this . index = workdirTreeIndex ; }
public AreaRecord ( RecordInputStream in ) { field_1_formatFlags = in . readShort ( ) ; }
public GetThumbnailRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetThumbnail " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DescribeTransitGatewayVpcAttachmentsResult describeTransitGatewayVpcAttachments ( DescribeTransitGatewayVpcAttachmentsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTransitGatewayVpcAttachments ( request ) ; }
public PutVoiceConnectorStreamingConfigurationResult putVoiceConnectorStreamingConfiguration ( PutVoiceConnectorStreamingConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executePutVoiceConnectorStreamingConfiguration ( request ) ; }
public OrdRange getOrdRange ( String dim ) { return prefixToOrdRange . get ( dim ) ; }
public String toString ( ) { String symbol = " " ; if ( startIndex >= 0 && startIndex < getInputStream ( ) . size ( ) ) { symbol = getInputStream ( ) . getText ( Interval . of ( startIndex , startIndex ) ) ; symbol = Utils . escapeWhitespace ( symbol , false ) ; } return String . format ( Locale . getDefault ( ) , " % s ( ' % s ' ) " , LexerNoViableAltException . class . getSimpleName ( ) , symbol ) ; }
public E peek ( ) { return peekFirstImpl ( ) ; }
public CreateWorkspacesResult createWorkspaces ( CreateWorkspacesRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateWorkspaces ( request ) ; }
public NumberFormatIndexRecord clone ( ) { return copy ( ) ; }
public DescribeRepositoriesResult describeRepositories ( DescribeRepositoriesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeRepositories ( request ) ; }
public SparseIntArray ( int initialCapacity ) { initialCapacity = ArrayUtils . idealIntArraySize ( initialCapacity ) ; mKeys = new int [ initialCapacity ] ; mValues = new int [ initialCapacity ] ; mSize = 0 ; }
public HyphenatedWordsFilter create ( TokenStream input ) { return new HyphenatedWordsFilter ( input ) ; }
public CreateDistributionWithTagsResult createDistributionWithTags ( CreateDistributionWithTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDistributionWithTags ( request ) ; }
public RandomAccessFile ( String fileName , String mode ) throws FileNotFoundException { this ( new File ( fileName ) , mode ) ; }
public DeleteWorkspaceImageResult deleteWorkspaceImage ( DeleteWorkspaceImageRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteWorkspaceImage ( request ) ; }
public static String toHex ( long value ) { StringBuilder sb = new StringBuilder ( 16 ) ; writeHex ( sb , value , 16 , " " ) ; return sb . toString ( ) ; }
public UpdateDistributionResult updateDistribution ( UpdateDistributionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDistribution ( request ) ; }
public HSSFColor getColor ( short index ) { if ( index == HSSFColorPredefined . AUTOMATIC . getIndex ( ) ) { return HSSFColorPredefined . AUTOMATIC . getColor ( ) ; } byte [ ] b = _palette . getColor ( index ) ; return ( b == null ) ? null : new CustomColor ( index , b ) ; }
public ValueEval evaluate ( ValueEval [ ] operands , int srcRow , int srcCol ) { throw new NotImplementedFunctionException ( _functionName ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( ( short ) field_1_number_crn_records ) ; out . writeShort ( ( short ) field_2_sheet_table_index ) ; }
public DescribeDBEngineVersionsResult describeDBEngineVersions ( ) { return describeDBEngineVersions ( new DescribeDBEngineVersionsRequest ( ) ) ; }
public FormatRun ( short character , short fontIndex ) { this . _character = character ; this . _fontIndex = fontIndex ; }
public static byte [ ] toBigEndianUtf16Bytes ( char [ ] chars , int offset , int length ) { byte [ ] result = new byte [ length * 2 ] ; int end = offset + length ; int resultIndex = 0 ; for ( int i = offset ; i < end ; ++ i ) { char ch = chars [ i ] ; result [ resultIndex ++ ] = ( byte ) ( ch >> 8 ) ; result [ resultIndex ++ ] = ( byte ) ch ; } return result ; }
public UploadArchiveResult uploadArchive ( UploadArchiveRequest request ) { request = beforeClientExecution ( request ) ; return executeUploadArchive ( request ) ; }
public List < Token > getHiddenTokensToLeft ( int tokenIndex ) { return getHiddenTokensToLeft ( tokenIndex , - 1 ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; AutomatonQuery other = ( AutomatonQuery ) obj ; if ( ! compiled . equals ( other . compiled ) ) return false ; if ( term == null ) { if ( other . term != null ) return false ; } else if ( ! term . equals ( other . term ) ) return false ; return true ; }
public SpanQuery makeSpanClause ( ) { SpanQuery [ ] spanQueries = new SpanQuery [ size ( ) ] ; Iterator < SpanQuery > sqi = weightBySpanQuery . keySet ( ) . iterator ( ) ; int i = 0 ; while ( sqi . hasNext ( ) ) { SpanQuery sq = sqi . next ( ) ; float boost = weightBySpanQuery . get ( sq ) ; if ( boost != 1f ) { sq = new SpanBoostQuery ( sq , boost ) ; } spanQueries [ i ++ ] = sq ; } if ( spanQueries . length == 1 ) return spanQueries [ 0 ] ; else return new SpanOrQuery ( spanQueries ) ; }
public StashCreateCommand stashCreate ( ) { return new StashCreateCommand ( repo ) ; }
public FieldInfo fieldInfo ( String fieldName ) { return byName . get ( fieldName ) ; }
public DescribeEventSourceResult describeEventSource ( DescribeEventSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeEventSource ( request ) ; }
public GetDocumentAnalysisResult getDocumentAnalysis ( GetDocumentAnalysisRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDocumentAnalysis ( request ) ; }
public CancelUpdateStackResult cancelUpdateStack ( CancelUpdateStackRequest request ) { request = beforeClientExecution ( request ) ; return executeCancelUpdateStack ( request ) ; }
public ModifyLoadBalancerAttributesResult modifyLoadBalancerAttributes ( ModifyLoadBalancerAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyLoadBalancerAttributes ( request ) ; }
public SetInstanceProtectionResult setInstanceProtection ( SetInstanceProtectionRequest request ) { request = beforeClientExecution ( request ) ; return executeSetInstanceProtection ( request ) ; }
public ModifyDBProxyResult modifyDBProxy ( ModifyDBProxyRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyDBProxy ( request ) ; }
public void add ( char [ ] output , int offset , int len , int endOffset , int posLength ) { if ( count == outputs . length ) { outputs = ArrayUtil . grow ( outputs , count + 1 ) ; } if ( count == endOffsets . length ) { final int [ ] next = new int [ ArrayUtil . oversize ( 1 + count , Integer . BYTES ) ] ; System . arraycopy ( endOffsets , 0 , next , 0 , count ) ; endOffsets = next ; } if ( count == posLengths . length ) { final int [ ] next = new int [ ArrayUtil . oversize ( 1 + count , Integer . BYTES ) ] ; System . arraycopy ( posLengths , 0 , next , 0 , count ) ; posLengths = next ; } if ( outputs [ count ] == null ) { outputs [ count ] = new CharsRefBuilder ( ) ; } outputs [ count ] . copyChars ( output , offset , len ) ; endOffsets [ count ] = endOffset ; posLengths [ count ] = posLength ; count ++ ; }
public FetchLibrariesRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " FetchLibraries " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public boolean exists ( ) { return fs . exists ( objects ) ; }
public FilterOutputStream ( OutputStream out ) { this . out = out ; }
public ScaleClusterRequest ( ) { super ( " CS " , " 2015 - 12 - 15 " , " ScaleCluster " , " csk " ) ; setUriPattern ( " / clusters / [ ClusterId ] " ) ; setMethod ( MethodType . PUT ) ; }
public DataValidationConstraint createTimeConstraint ( int operatorType , String formula1 , String formula2 ) { return DVConstraint . createTimeConstraint ( operatorType , formula1 , formula2 ) ; }
public ListObjectParentPathsResult listObjectParentPaths ( ListObjectParentPathsRequest request ) { request = beforeClientExecution ( request ) ; return executeListObjectParentPaths ( request ) ; }
public DescribeCacheSubnetGroupsResult describeCacheSubnetGroups ( DescribeCacheSubnetGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCacheSubnetGroups ( request ) ; }
public void setSharedFormula ( boolean flag ) { field_5_options = sharedFormula . setShortBoolean ( field_5_options , flag ) ; }
public boolean isReuseObjects ( ) { return reuseObjects ; }
public ErrorNode addErrorNode ( Token badToken ) { ErrorNodeImpl t = new ErrorNodeImpl ( badToken ) ; addAnyChild ( t ) ; t . setParent ( this ) ; return t ; }
public LatvianStemFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public EventSubscription removeSourceIdentifierFromSubscription ( RemoveSourceIdentifierFromSubscriptionRequest request ) { request = beforeClientExecution ( request ) ; return executeRemoveSourceIdentifierFromSubscription ( request ) ; }
public static TokenFilterFactory forName ( String name , Map < String , String > args ) { return loader . newInstance ( name , args ) ; }
public AddAlbumPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " AddAlbumPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public GetThreatIntelSetResult getThreatIntelSet ( GetThreatIntelSetRequest request ) { request = beforeClientExecution ( request ) ; return executeGetThreatIntelSet ( request ) ; }
public RevFilter clone ( ) { return new Binary ( a . clone ( ) , b . clone ( ) ) ; }
public boolean equals ( Object o ) { return o instanceof ArmenianStemmer ; }
public final boolean hasArray ( ) { return protectedHasArray ( ) ; }
public UpdateContributorInsightsResult updateContributorInsights ( UpdateContributorInsightsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateContributorInsights ( request ) ; }
public void unwriteProtectWorkbook ( ) { records . remove ( fileShare ) ; records . remove ( writeProtect ) ; fileShare = null ; writeProtect = null ; }
public SolrSynonymParser ( boolean dedup , boolean expand , Analyzer analyzer ) { super ( dedup , analyzer ) ; this . expand = expand ; }
public RequestSpotInstancesResult requestSpotInstances ( RequestSpotInstancesRequest request ) { request = beforeClientExecution ( request ) ; return executeRequestSpotInstances ( request ) ; }
public byte [ ] getObjectData ( ) { return findObjectRecord ( ) . getObjectData ( ) ; }
public GetContactAttributesResult getContactAttributes ( GetContactAttributesRequest request ) { request = beforeClientExecution ( request ) ; return executeGetContactAttributes ( request ) ; }
public String toString ( ) { return getKey ( ) + " : ▁ " + getValue ( ) ; }
public ListTextTranslationJobsResult listTextTranslationJobs ( ListTextTranslationJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListTextTranslationJobs ( request ) ; }
public GetContactMethodsResult getContactMethods ( GetContactMethodsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetContactMethods ( request ) ; }
public static short lookupIndexByName ( String name ) { FunctionMetadata fd = getInstance ( ) . getFunctionByNameInternal ( name ) ; if ( fd == null ) { fd = getInstanceCetab ( ) . getFunctionByNameInternal ( name ) ; if ( fd == null ) { return - 1 ; } } return ( short ) fd . getIndex ( ) ; }
public DescribeAnomalyDetectorsResult describeAnomalyDetectors ( DescribeAnomalyDetectorsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAnomalyDetectors ( request ) ; }
public static String insertId ( String message , ObjectId changeId ) { return insertId ( message , changeId , false ) ; }
public long getObjectSize ( AnyObjectId objectId , int typeHint ) throws MissingObjectException , IncorrectObjectTypeException , IOException { long sz = db . getObjectSize ( this , objectId ) ; if ( sz < 0 ) { if ( typeHint == OBJ_ANY ) throw new MissingObjectException ( objectId . copy ( ) , JGitText . get ( ) . unknownObjectType2 ) ; throw new MissingObjectException ( objectId . copy ( ) , typeHint ) ; } return sz ; }
public ImportInstallationMediaResult importInstallationMedia ( ImportInstallationMediaRequest request ) { request = beforeClientExecution ( request ) ; return executeImportInstallationMedia ( request ) ; }
public PutLifecycleEventHookExecutionStatusResult putLifecycleEventHookExecutionStatus ( PutLifecycleEventHookExecutionStatusRequest request ) { request = beforeClientExecution ( request ) ; return executePutLifecycleEventHookExecutionStatus ( request ) ; }
public NumberPtg ( LittleEndianInput in ) { this ( in . readDouble ( ) ) ; }
public GetFieldLevelEncryptionConfigResult getFieldLevelEncryptionConfig ( GetFieldLevelEncryptionConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFieldLevelEncryptionConfig ( request ) ; }
public DescribeDetectorResult describeDetector ( DescribeDetectorRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDetector ( request ) ; }
public ReportInstanceStatusResult reportInstanceStatus ( ReportInstanceStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeReportInstanceStatus ( request ) ; }
public DeleteAlarmResult deleteAlarm ( DeleteAlarmRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAlarm ( request ) ; }
public TokenStream create ( TokenStream input ) { return new PortugueseStemFilter ( input ) ; }
public FtCblsSubRecord ( ) { reserved = new byte [ ENCODED_SIZE ] ; }
@ Override public boolean remove ( Object object ) { synchronized ( mutex ) { return c . remove ( object ) ; } }
public GetDedicatedIpResult getDedicatedIp ( GetDedicatedIpRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDedicatedIp ( request ) ; }
public String toString ( ) { return precedence + " ▁ >= ▁ □ p " ; }
public ListStreamProcessorsResult listStreamProcessors ( ListStreamProcessorsRequest request ) { request = beforeClientExecution ( request ) ; return executeListStreamProcessors ( request ) ; }
public DeleteLoadBalancerPolicyRequest ( String loadBalancerName , String policyName ) { setLoadBalancerName ( loadBalancerName ) ; setPolicyName ( policyName ) ; }
public WindowProtectRecord ( int options ) { _options = options ; }
public UnbufferedCharStream ( int bufferSize ) { n = 0 ; data = new int [ bufferSize ] ; }
public GetOperationsResult getOperations ( GetOperationsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetOperations ( request ) ; }
public void copyRawTo ( byte [ ] b , int o ) { NB . encodeInt32 ( b , o , w1 ) ; NB . encodeInt32 ( b , o + 4 , w2 ) ; NB . encodeInt32 ( b , o + 8 , w3 ) ; NB . encodeInt32 ( b , o + 12 , w4 ) ; NB . encodeInt32 ( b , o + 16 , w5 ) ; }
public WindowOneRecord ( RecordInputStream in ) { field_1_h_hold = in . readShort ( ) ; field_2_v_hold = in . readShort ( ) ; field_3_width = in . readShort ( ) ; field_4_height = in . readShort ( ) ; field_5_options = in . readShort ( ) ; field_6_active_sheet = in . readShort ( ) ; field_7_first_visible_tab = in . readShort ( ) ; field_8_num_selected_tabs = in . readShort ( ) ; field_9_tab_width_ratio = in . readShort ( ) ; }
public StopWorkspacesResult stopWorkspaces ( StopWorkspacesRequest request ) { request = beforeClientExecution ( request ) ; return executeStopWorkspaces ( request ) ; }
public void close ( ) throws IOException { if ( isOpen ) { isOpen = false ; try { dump ( ) ; } finally { try { channel . truncate ( fileLength ) ; } finally { try { channel . close ( ) ; } finally { fos . close ( ) ; } } } } }
public DescribeMatchmakingRuleSetsResult describeMatchmakingRuleSets ( DescribeMatchmakingRuleSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeMatchmakingRuleSets ( request ) ; }
public String getPronunciation ( int wordId , char surface [ ] , int off , int len ) { return null ; }
public String getPath ( ) { return pathStr ; }
public static double devsq ( double [ ] v ) { double r = Double . NaN ; if ( v != null && v . length >= 1 ) { double m = 0 ; double s = 0 ; int n = v . length ; for ( int i = 0 ; i < n ; i ++ ) { s += v [ i ] ; } m = s / n ; s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += ( v [ i ] - m ) * ( v [ i ] - m ) ; } r = ( n == 1 ) ? 0 : s ; } return r ; }
public DescribeResizeResult describeResize ( DescribeResizeRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeResize ( request ) ; }
public final boolean hasPassedThroughNonGreedyDecision ( ) { return passedThroughNonGreedyDecision ; }
public int end ( ) { return end ( 0 ) ; }
public void traverse ( CellHandler handler ) { int firstRow = range . getFirstRow ( ) ; int lastRow = range . getLastRow ( ) ; int firstColumn = range . getFirstColumn ( ) ; int lastColumn = range . getLastColumn ( ) ; final int width = lastColumn - firstColumn + 1 ; SimpleCellWalkContext ctx = new SimpleCellWalkContext ( ) ; Row currentRow = null ; Cell currentCell = null ; for ( ctx . rowNumber = firstRow ; ctx . rowNumber <= lastRow ; ++ ctx . rowNumber ) { currentRow = sheet . getRow ( ctx . rowNumber ) ; if ( currentRow == null ) { continue ; } for ( ctx . colNumber = firstColumn ; ctx . colNumber <= lastColumn ; ++ ctx . colNumber ) { currentCell = currentRow . getCell ( ctx . colNumber ) ; if ( currentCell == null ) { continue ; } if ( isEmpty ( currentCell ) && ! traverseEmptyCells ) { continue ; } long rowSize = ArithmeticUtils . mulAndCheck ( ( long ) ArithmeticUtils . subAndCheck ( ctx . rowNumber , firstRow ) , ( long ) width ) ; ctx . ordinalNumber = ArithmeticUtils . addAndCheck ( rowSize , ( ctx . colNumber - firstColumn + 1 ) ) ; handler . onCell ( currentCell , ctx ) ; } } }
public int getReadIndex ( ) { return pos ; }
public int compareTo ( ScoreTerm other ) { if ( this . boost == other . boost ) return other . bytes . get ( ) . compareTo ( this . bytes . get ( ) ) ; else return Float . compare ( this . boost , other . boost ) ; }
public int normalize ( char s [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { switch ( s [ i ] ) { case FARSI_YEH : case YEH_BARREE : s [ i ] = YEH ; break ; case KEHEH : s [ i ] = KAF ; break ; case HEH_YEH : case HEH_GOAL : s [ i ] = HEH ; break ; case HAMZA_ABOVE : len = delete ( s , i , len ) ; i -- ; break ; default : break ; } } return len ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( _options ) ; }
public DiagnosticErrorListener ( boolean exactOnly ) { this . exactOnly = exactOnly ; }
public KeySchemaElement ( String attributeName , KeyType keyType ) { setAttributeName ( attributeName ) ; setKeyType ( keyType . toString ( ) ) ; }
public GetAssignmentResult getAssignment ( GetAssignmentRequest request ) { request = beforeClientExecution ( request ) ; return executeGetAssignment ( request ) ; }
public boolean hasObject ( AnyObjectId id ) { return findOffset ( id ) != - 1 ; }
public GroupingSearch setAllGroups ( boolean allGroups ) { this . allGroups = allGroups ; return this ; }
public synchronized void setMultiValued ( String dimName , boolean v ) { DimConfig ft = fieldTypes . get ( dimName ) ; if ( ft == null ) { ft = new DimConfig ( ) ; fieldTypes . put ( dimName , ft ) ; } ft . multiValued = v ; }
public int getCellsVal ( ) { Iterator < Character > i = cells . keySet ( ) . iterator ( ) ; int size = 0 ; for ( ; i . hasNext ( ) ; ) { Character c = i . next ( ) ; Cell e = at ( c ) ; if ( e . cmd >= 0 ) { size ++ ; } } return size ; }
public DeleteVoiceConnectorResult deleteVoiceConnector ( DeleteVoiceConnectorRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVoiceConnector ( request ) ; }
public DeleteLifecyclePolicyResult deleteLifecyclePolicy ( DeleteLifecyclePolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLifecyclePolicy ( request ) ; }
public void write ( byte [ ] b ) { int len = b . length ; checkPosition ( len ) ; System . arraycopy ( b , 0 , _buf , _writeIndex , len ) ; _writeIndex += len ; }
public RebaseResult getRebaseResult ( ) { return this . rebaseResult ; }
public static int getNearestSetSize ( int maxNumberOfValuesExpected , float desiredSaturation ) { for ( int i = 0 ; i < usableBitSetSizes . length ; i ++ ) { int numSetBitsAtDesiredSaturation = ( int ) ( usableBitSetSizes [ i ] * desiredSaturation ) ; int estimatedNumUniqueValues = getEstimatedNumberUniqueValuesAllowingForCollisions ( usableBitSetSizes [ i ] , numSetBitsAtDesiredSaturation ) ; if ( estimatedNumUniqueValues > maxNumberOfValuesExpected ) { return usableBitSetSizes [ i ] ; } } return - 1 ; }
public DescribeDashboardResult describeDashboard ( DescribeDashboardRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDashboard ( request ) ; }
public CreateSegmentResult createSegment ( CreateSegmentRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSegment ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ DBCELL ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . rowoffset ▁ = ▁ " ) . append ( HexDump . intToHex ( field_1_row_offset ) ) . append ( " \ n " ) ; for ( int k = 0 ; k < field_2_cell_offsets . length ; k ++ ) { buffer . append ( " ▁ ▁ ▁ ▁ . cell □ " ) . append ( k ) . append ( " ▁ = ▁ " ) . append ( HexDump . shortToHex ( field_2_cell_offsets [ k ] ) ) . append ( " \ n " ) ; } buffer . append ( " [ / DBCELL ] \ n " ) ; return buffer . toString ( ) ; }
public List < String > getUndeletedList ( ) { return undeletedList ; }
public String toString ( ) { return " [ INTERFACEEND / ] \ n " ; }
public MergeScheduler clone ( ) { return this ; }
public PlainTextDictionary ( Reader reader ) { in = new BufferedReader ( reader ) ; }
public StringBuilder append ( CharSequence csq ) { if ( csq == null ) { appendNull ( ) ; } else { append0 ( csq , 0 , csq . length ( ) ) ; } return this ; }
public ListAssociatedStacksResult listAssociatedStacks ( ListAssociatedStacksRequest request ) { request = beforeClientExecution ( request ) ; return executeListAssociatedStacks ( request ) ; }
public static double avedev ( double [ ] v ) { double r = 0 ; double m = 0 ; double s = 0 ; for ( int i = 0 , iSize = v . length ; i < iSize ; i ++ ) { s += v [ i ] ; } m = s / v . length ; s = 0 ; for ( int i = 0 , iSize = v . length ; i < iSize ; i ++ ) { s += Math . abs ( v [ i ] - m ) ; } r = s / v . length ; return r ; }
public DescribeByoipCidrsResult describeByoipCidrs ( DescribeByoipCidrsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeByoipCidrs ( request ) ; }
public GetDiskResult getDisk ( GetDiskRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDisk ( request ) ; }
public DBClusterParameterGroup createDBClusterParameterGroup ( CreateDBClusterParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBClusterParameterGroup ( request ) ; }
public static CharBuffer wrap ( char [ ] array , int start , int charCount ) { Arrays . checkOffsetAndCount ( array . length , start , charCount ) ; CharBuffer buf = new ReadWriteCharArrayBuffer ( array ) ; buf . position = start ; buf . limit = start + charCount ; return buf ; }
public SubmoduleStatusType getType ( ) { return type ; }
public DescribeGameServerGroupResult describeGameServerGroup ( DescribeGameServerGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeGameServerGroup ( request ) ; }
public Pattern pattern ( ) { return pattern ; }
public V setValue ( V object ) { throw new UnsupportedOperationException ( ) ; }
public StringBuilder stem ( CharSequence word ) { CharSequence cmd = stemmer . getLastOnPath ( word ) ; if ( cmd == null ) return null ; buffer . setLength ( 0 ) ; buffer . append ( word ) ; Diff . apply ( buffer , cmd ) ; if ( buffer . length ( ) > 0 ) return buffer ; else return null ; }
public RenameFaceRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " RenameFace " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public char requireChar ( Map < String , String > args , String name ) { return require ( args , name ) . charAt ( 0 ) ; }
public static String toStringTree ( Tree t ) { return toStringTree ( t , ( List < String > ) null ) ; }
public String toString ( ) { return " < deleted /> " ; }
public GetRepoWebhookLogListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoWebhookLogList " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / webhooks / [ WebhookId ] / logs " ) ; setMethod ( MethodType . GET ) ; }
public GetJobUnlockCodeResult getJobUnlockCode ( GetJobUnlockCodeRequest request ) { request = beforeClientExecution ( request ) ; return executeGetJobUnlockCode ( request ) ; }
public RemoveTagsRequest ( String resourceId ) { setResourceId ( resourceId ) ; }
public short getGB2312Id ( char ch ) { try { byte [ ] buffer = Character . toString ( ch ) . getBytes ( " GB2312 " ) ; if ( buffer . length != 2 ) { return - 1 ; } int b0 = ( buffer [ 0 ] & 0x0FF ) - 161 ; int b1 = ( buffer [ 1 ] & 0x0FF ) - 161 ; return ( short ) ( b0 * 94 + b1 ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
public BatchRefUpdate addCommand ( Collection < ReceiveCommand > cmd ) { commands . addAll ( cmd ) ; return this ; }
public short checkExternSheet ( int sheetNumber ) { return ( short ) getOrCreateLinkTable ( ) . checkExternSheet ( sheetNumber ) ; }
@ Override public boolean equals ( Object object ) { return c . equals ( object ) ; }
public BooleanQuery build ( QueryNode queryNode ) throws QueryNodeException { AnyQueryNode andNode = ( AnyQueryNode ) queryNode ; BooleanQuery . Builder bQuery = new BooleanQuery . Builder ( ) ; List < QueryNode > children = andNode . getChildren ( ) ; if ( children != null ) { for ( QueryNode child : children ) { Object obj = child . getTag ( QueryTreeBuilder . QUERY_TREE_BUILDER_TAGID ) ; if ( obj != null ) { Query query = ( Query ) obj ; try { bQuery . add ( query , BooleanClause . Occur . SHOULD ) ; } catch ( TooManyClauses ex ) { throw new QueryNodeException ( new MessageImpl ( QueryParserMessages . EMPTY_MESSAGE ) , ex ) ; } } } } bQuery . setMinimumNumberShouldMatch ( andNode . getMinimumMatchingElements ( ) ) ; return bQuery . build ( ) ; }
public DescribeStreamProcessorResult describeStreamProcessor ( DescribeStreamProcessorRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStreamProcessor ( request ) ; }
public DescribeDashboardPermissionsResult describeDashboardPermissions ( DescribeDashboardPermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDashboardPermissions ( request ) ; }
public Ref peel ( Ref ref ) { try { return getRefDatabase ( ) . peel ( ref ) ; } catch ( IOException e ) { return ref ; } }
public long ramBytesUsed ( ) { return RamUsageEstimator . alignObjectSize ( RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + 2 * Integer . BYTES + RamUsageEstimator . NUM_BYTES_OBJECT_REF ) + RamUsageEstimator . sizeOf ( blocks ) ; }
public GetDomainSuggestionsResult getDomainSuggestions ( GetDomainSuggestionsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDomainSuggestions ( request ) ; }
public DescribeStackEventsResult describeStackEvents ( DescribeStackEventsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStackEvents ( request ) ; }
public void setRule ( int idx , ConditionalFormattingRule cfRule ) { setRule ( idx , ( HSSFConditionalFormattingRule ) cfRule ) ; }
public CreateResolverRuleResult createResolverRule ( CreateResolverRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateResolverRule ( request ) ; }
public SeriesIndexRecord ( RecordInputStream in ) { field_1_index = in . readShort ( ) ; }
public GetStylesRequest ( ) { super ( " lubancloud " , " 2018 - 05 - 09 " , " GetStyles " , " luban " ) ; setMethod ( MethodType . POST ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_gridset_flag ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } Toffs other = ( Toffs ) obj ; if ( getStartOffset ( ) != other . getStartOffset ( ) ) { return false ; } if ( getEndOffset ( ) != other . getEndOffset ( ) ) { return false ; } return true ; }
public CreateGatewayGroupResult createGatewayGroup ( CreateGatewayGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateGatewayGroup ( request ) ; }
public CreateParticipantConnectionResult createParticipantConnection ( CreateParticipantConnectionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateParticipantConnection ( request ) ; }
public static double irr ( double [ ] income ) { return irr ( income , 0.1d ) ; }
public RegisterWorkspaceDirectoryResult registerWorkspaceDirectory ( RegisterWorkspaceDirectoryRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterWorkspaceDirectory ( request ) ; }
public RevertCommand include ( AnyObjectId commit ) { return include ( commit . getName ( ) , commit ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval inumberVE ) { ValueEval veText1 ; try { veText1 = OperandResolver . getSingleValue ( inumberVE , srcRowIndex , srcColumnIndex ) ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } String iNumber = OperandResolver . coerceValueToString ( veText1 ) ; Matcher m = COMPLEX_NUMBER_PATTERN . matcher ( iNumber ) ; boolean result = m . matches ( ) ; String imaginary = " " ; if ( result ) { String imaginaryGroup = m . group ( 5 ) ; boolean hasImaginaryPart = imaginaryGroup . equals ( " i " ) || imaginaryGroup . equals ( " j " ) ; if ( imaginaryGroup . length ( ) == 0 ) { return new StringEval ( String . valueOf ( 0 ) ) ; } if ( hasImaginaryPart ) { String sign = " " ; String imaginarySign = m . group ( GROUP3_IMAGINARY_SIGN ) ; if ( imaginarySign . length ( ) != 0 && ! ( imaginarySign . equals ( " + " ) ) ) { sign = imaginarySign ; } String groupImaginaryNumber = m . group ( GROUP4_IMAGINARY_INTEGER_OR_DOUBLE ) ; if ( groupImaginaryNumber . length ( ) != 0 ) { imaginary = sign + groupImaginaryNumber ; } else { imaginary = sign + " 1 " ; } } } else { return ErrorEval . NUM_ERROR ; } return new StringEval ( imaginary ) ; }
public E pollLast ( ) { Map . Entry < E , Object > entry = backingMap . pollLastEntry ( ) ; return ( entry == null ) ? null : entry . getKey ( ) ; }
public int readUShort ( ) { int ch1 = readUByte ( ) ; int ch2 = readUByte ( ) ; return ( ch2 << 8 ) + ( ch1 << 0 ) ; }
public ModifySnapshotAttributeRequest ( String snapshotId , SnapshotAttributeName attribute , OperationType operationType ) { setSnapshotId ( snapshotId ) ; setAttribute ( attribute . toString ( ) ) ; setOperationType ( operationType . toString ( ) ) ; }
public ListBonusPaymentsResult listBonusPayments ( ListBonusPaymentsRequest request ) { request = beforeClientExecution ( request ) ; return executeListBonusPayments ( request ) ; }
public V get ( CharSequence cs ) { if ( cs == null ) throw new NullPointerException ( ) ; return null ; }
public TokenFilter create ( TokenStream input ) { CommonGramsFilter commonGrams = ( CommonGramsFilter ) super . create ( input ) ; return new CommonGramsQueryFilter ( commonGrams ) ; }
public String getPath ( ) { return path ; }
public InitiateMultipartUploadResult initiateMultipartUpload ( InitiateMultipartUploadRequest request ) { request = beforeClientExecution ( request ) ; return executeInitiateMultipartUpload ( request ) ; }
public StringBuilder insert ( int offset , int i ) { insert0 ( offset , Integer . toString ( i ) ) ; return this ; }
public void decode ( long [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; for ( int shift = 62 ; shift >= 0 ; shift -= 2 ) { values [ valuesOffset ++ ] = ( int ) ( ( block >>> shift ) & 3 ) ; } } }
public TokenStream create ( TokenStream input ) { return new ElisionFilter ( input , articles ) ; }
public boolean eat ( Row in , int remap [ ] ) { int sum = 0 ; for ( Iterator < Cell > i = in . cells . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Cell c = i . next ( ) ; sum += c . cnt ; if ( c . ref >= 0 ) { if ( remap [ c . ref ] == 0 ) { c . ref = - 1 ; } } } int frame = sum / 10 ; boolean live = false ; for ( Iterator < Cell > i = in . cells . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Cell c = i . next ( ) ; if ( c . cnt < frame && c . cmd >= 0 ) { c . cnt = 0 ; c . cmd = - 1 ; } if ( c . cmd >= 0 || c . ref >= 0 ) { live |= true ; } } return ! live ; }
final public Token getToken ( int index ) { Token t = jj_lookingAhead ? jj_scanpos : token ; for ( int i = 0 ; i < index ; i ++ ) { if ( t . next != null ) t = t . next ; else t = t . next = token_source . getNextToken ( ) ; } return t ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( getClass ( ) . getName ( ) ) . append ( " ▁ [ ARRAY ] \ n " ) ; sb . append ( " ▁ range = " ) . append ( getRange ( ) ) . append ( " \ n " ) ; sb . append ( " ▁ options = " ) . append ( HexDump . shortToHex ( _options ) ) . append ( " \ n " ) ; sb . append ( " ▁ notUsed = " ) . append ( HexDump . intToHex ( _field3notUsed ) ) . append ( " \ n " ) ; sb . append ( " ▁ formula : " ) . append ( " \ n " ) ; Ptg [ ] ptgs = _formula . getTokens ( ) ; for ( int i = 0 ; i < ptgs . length ; i ++ ) { Ptg ptg = ptgs [ i ] ; sb . append ( ptg ) . append ( ptg . getRVAType ( ) ) . append ( " \ n " ) ; } sb . append ( " ] " ) ; return sb . toString ( ) ; }
public GetFolderResult getFolder ( GetFolderRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFolder ( request ) ; }
@ Override public void add ( int location , E object ) { throw new UnsupportedOperationException ( ) ; }
public PositiveScoresOnlyCollector ( Collector in ) { super ( in ) ; }
public CreateRepoBuildRuleRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " CreateRepoBuildRule " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / rules " ) ; setMethod ( MethodType . PUT ) ; }
public BaseRef ( AreaEval ae ) { _refEval = null ; _areaEval = ae ; _firstRowIndex = ae . getFirstRow ( ) ; _firstColumnIndex = ae . getFirstColumn ( ) ; _height = ae . getLastRow ( ) - ae . getFirstRow ( ) + 1 ; _width = ae . getLastColumn ( ) - ae . getFirstColumn ( ) + 1 ; }
public DrawingManager2 ( EscherDggRecord dgg ) { this . dgg = dgg ; }
public void reset ( ) { if ( ! first ( ) ) reset ( raw ) ; }
public final CharsetDecoder reset ( ) { status = INIT ; implReset ( ) ; return this ; }
public BufferedReader ( Reader in , int size ) { super ( in ) ; if ( size <= 0 ) { throw new IllegalArgumentException ( " size ▁ <= ▁ 0 " ) ; } this . in = in ; buf = new char [ size ] ; }
public DescribeCodeRepositoryResult describeCodeRepository ( DescribeCodeRepositoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCodeRepository ( request ) ; }
public DBSubnetGroup createDBSubnetGroup ( CreateDBSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDBSubnetGroup ( request ) ; }
public RenameBranchCommand setOldName ( String oldName ) { checkCallable ( ) ; this . oldName = oldName ; return this ; }
public DeleteBranchCommand setForce ( boolean force ) { checkCallable ( ) ; this . force = force ; return this ; }
public StopCompilationJobResult stopCompilationJob ( StopCompilationJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopCompilationJob ( request ) ; }
public synchronized final void incrementSecondaryProgressBy ( int diff ) { setSecondaryProgress ( mSecondaryProgress + diff ) ; }
public int [ ] clear ( ) { return bytesStart = null ; }
public String getRawPath ( ) { return path ; }
public GetUserSourceAccountRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetUserSourceAccount " , " cr " ) ; setUriPattern ( " / users / sourceAccount " ) ; setMethod ( MethodType . GET ) ; }
public CreateExportJobResult createExportJob ( CreateExportJobRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateExportJob ( request ) ; }
public CreateDedicatedIpPoolResult createDedicatedIpPool ( CreateDedicatedIpPoolRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDedicatedIpPool ( request ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( obj instanceof HSSFCellStyle ) { final HSSFCellStyle other = ( HSSFCellStyle ) obj ; if ( _format == null ) { if ( other . _format != null ) { return false ; } } else if ( ! _format . equals ( other . _format ) ) { return false ; } if ( _index != other . _index ) { return false ; } return true ; } return false ; }
public ReleaseHostsResult releaseHosts ( ReleaseHostsRequest request ) { request = beforeClientExecution ( request ) ; return executeReleaseHosts ( request ) ; }
public boolean equals ( Object object ) { if ( this == object ) { return true ; } if ( object instanceof Set ) { Set <?> s = ( Set <?> ) object ; try { return size ( ) == s . size ( ) && containsAll ( s ) ; } catch ( NullPointerException ignored ) { return false ; } catch ( ClassCastException ignored ) { return false ; } } return false ; }
public void setRefLogMessage ( String msg , boolean appendStatus ) { customRefLog = true ; if ( msg == null && ! appendStatus ) { disableRefLog ( ) ; } else if ( msg == null && appendStatus ) { refLogMessage = " " ; refLogIncludeResult = true ; } else { refLogMessage = msg ; refLogIncludeResult = appendStatus ; } }
public StreamIDRecord ( RecordInputStream in ) { idstm = in . readShort ( ) ; }
public RecognizeCarRequest ( ) { super ( " visionai - poc " , " 2020 - 04 - 08 " , " RecognizeCar " ) ; setMethod ( MethodType . POST ) ; }
public final ByteOrder order ( ) { return ByteOrder . nativeOrder ( ) ; }
public int getAheadCount ( ) { return aheadCount ; }
public boolean isNewFragment ( ) { return false ; }
public GetCloudFrontOriginAccessIdentityConfigResult getCloudFrontOriginAccessIdentityConfig ( GetCloudFrontOriginAccessIdentityConfigRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCloudFrontOriginAccessIdentityConfig ( request ) ; }
public boolean matches ( int symbol , int minVocabSymbol , int maxVocabSymbol ) { return label == symbol ; }
public DeleteTransitGatewayResult deleteTransitGateway ( DeleteTransitGatewayRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteTransitGateway ( request ) ; }
public static byte [ ] grow ( byte [ ] array , int minSize ) { assert minSize >= 0 : " size ▁ must ▁ be ▁ positive ▁ ( got ▁ " + minSize + " ) : ▁ likely ▁ integer ▁ overflow ? " ; if ( array . length < minSize ) { return growExact ( array , oversize ( minSize , Byte . BYTES ) ) ; } else return array ; }
public CreateTransactionRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " CreateTransaction " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public BatchRefUpdate setRefLogIdent ( PersonIdent pi ) { refLogIdent = pi ; return this ; }
public GetLaunchTemplateDataResult getLaunchTemplateData ( GetLaunchTemplateDataRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLaunchTemplateData ( request ) ; }
public ParseInfo ( ProfilingATNSimulator atnSimulator ) { this . atnSimulator = atnSimulator ; }
public SimpleQQParser ( String qqNames [ ] , String indexField ) { this . qqNames = qqNames ; this . indexField = indexField ; }
public DBCluster promoteReadReplicaDBCluster ( PromoteReadReplicaDBClusterRequest request ) { request = beforeClientExecution ( request ) ; return executePromoteReadReplicaDBCluster ( request ) ; }
public DescribeCapacityReservationsResult describeCapacityReservations ( DescribeCapacityReservationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeCapacityReservations ( request ) ; }
public String toString ( ) { return " IndexSearcher ( " + reader + " ; ▁ executor = " + executor + " ; ▁ sliceExecutionControlPlane ▁ " + sliceExecutor + " ) " ; }
public final boolean incrementToken ( ) { return false ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( main + 1 ) ; out . writeShort ( subFrom ) ; out . writeShort ( subTo ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { if ( bitsPerValue > 32 ) { throw new UnsupportedOperationException ( " Cannot ▁ decode ▁ " + bitsPerValue + " - bits ▁ values ▁ into ▁ an ▁ int [ ] " ) ; } for ( int i = 0 ; i < iterations ; ++ i ) { final long block = readLong ( blocks , blocksOffset ) ; blocksOffset += 8 ; valuesOffset = decode ( block , values , valuesOffset ) ; } }
public boolean isExpectedToken ( int symbol ) { ATN atn = getInterpreter ( ) . atn ; ParserRuleContext ctx = _ctx ; ATNState s = atn . states . get ( getState ( ) ) ; IntervalSet following = atn . nextTokens ( s ) ; if ( following . contains ( symbol ) ) { return true ; } if ( ! following . contains ( Token . EPSILON ) ) return false ; while ( ctx != null && ctx . invokingState >= 0 && following . contains ( Token . EPSILON ) ) { ATNState invokingState = atn . states . get ( ctx . invokingState ) ; RuleTransition rt = ( RuleTransition ) invokingState . transition ( 0 ) ; following = atn . nextTokens ( rt . followState ) ; if ( following . contains ( symbol ) ) { return true ; } ctx = ( ParserRuleContext ) ctx . parent ; } if ( following . contains ( Token . EPSILON ) && symbol == Token . EOF ) { return true ; } return false ; }
public UpdateStreamResult updateStream ( UpdateStreamRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateStream ( request ) ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 ) { try { OperandResolver . getSingleValue ( arg0 , srcRowIndex , srcColumnIndex ) ; return ErrorEval . NA ; } catch ( EvaluationException e ) { int result = translateErrorCodeToErrorTypeValue ( e . getErrorEval ( ) . getErrorCode ( ) ) ; return new NumberEval ( result ) ; } }
public String toString ( ) { return getClass ( ) . getName ( ) + " ▁ [ " + _index + " ▁ " + _name + " ] " ; }
public ListAssignmentsForHITResult listAssignmentsForHIT ( ListAssignmentsForHITRequest request ) { request = beforeClientExecution ( request ) ; return executeListAssignmentsForHIT ( request ) ; }
public DeleteAccessControlRuleResult deleteAccessControlRule ( DeleteAccessControlRuleRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteAccessControlRule ( request ) ; }
public Arc < Long > getFirstArc ( FST . Arc < Long > arc ) { return fst . getFirstArc ( arc ) ; }
public void decode ( long [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long block = blocks [ blocksOffset ++ ] ; for ( int shift = 48 ; shift >= 0 ; shift -= 16 ) { values [ valuesOffset ++ ] = ( int ) ( ( block >>> shift ) & 65535 ) ; } } }
public long skip ( long charCount ) throws IOException { if ( charCount < 0 ) { throw new IllegalArgumentException ( " charCount ▁ < ▁ 0 : ▁ " + charCount ) ; } synchronized ( lock ) { checkNotClosed ( ) ; if ( charCount == 0 ) { return 0 ; } long inSkipped ; int availableFromBuffer = buf . length - pos ; if ( availableFromBuffer > 0 ) { long requiredFromIn = charCount - availableFromBuffer ; if ( requiredFromIn <= 0 ) { pos += charCount ; return charCount ; } pos += availableFromBuffer ; inSkipped = in . skip ( requiredFromIn ) ; } else { inSkipped = in . skip ( charCount ) ; } return inSkipped + availableFromBuffer ; } }
public Map < String , Ref > getRefsMap ( ) { return advertisedRefs ; }
public UpdateApiKeyResult updateApiKey ( UpdateApiKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateApiKey ( request ) ; }
public ObjectStream openStream ( ) throws MissingObjectException , IOException { PackInputStream packIn ; @ SuppressWarnings ( " resource " ) DfsReader ctx = db . newReader ( ) ; try { try { packIn = new PackInputStream ( pack , objectOffset + headerLength , ctx ) ; ctx = null ; } catch ( IOException packGone ) { ObjectId obj = pack . getReverseIdx ( ctx ) . findObject ( objectOffset ) ; return ctx . open ( obj , type ) . openStream ( ) ; } } finally { if ( ctx != null ) { ctx . close ( ) ; } } int bufsz = 8192 ; InputStream in = new BufferedInputStream ( new InflaterInputStream ( packIn , packIn . ctx . inflater ( ) , bufsz ) , bufsz ) ; return new ObjectStream . Filter ( type , size , in ) ; }
public ArrayList ( ) { array = EmptyArray . OBJECT ; }
public UpdateDetectorVersionResult updateDetectorVersion ( UpdateDetectorVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDetectorVersion ( request ) ; }
public void resize ( ) { resize ( Double . MAX_VALUE ) ; }
public RevFlagSet ( Collection < RevFlag > s ) { this ( ) ; addAll ( s ) ; }
public int size ( ) { return size ; }
public final long getLong ( ) { int newPosition = position + SizeOf . LONG ; if ( newPosition > limit ) { throw new BufferUnderflowException ( ) ; } long result = Memory . peekLong ( backingArray , offset + position , order ) ; position = newPosition ; return result ; }
public StringBuilder insert ( int offset , long l ) { insert0 ( offset , Long . toString ( l ) ) ; return this ; }
public TurkishLowerCaseFilter ( TokenStream in ) { super ( in ) ; }
public ParseTreeMatch match ( ParseTree tree , ParseTreePattern pattern ) { MultiMap < String , ParseTree > labels = new MultiMap < String , ParseTree > ( ) ; ParseTree mismatchedNode = matchImpl ( tree , pattern . getPatternTree ( ) , labels ) ; return new ParseTreeMatch ( tree , pattern , labels , mismatchedNode ) ; }
public void addIfNoOverlap ( WeightedPhraseInfo wpi ) { for ( WeightedPhraseInfo existWpi : getPhraseList ( ) ) { if ( existWpi . isOffsetOverlap ( wpi ) ) { existWpi . getTermsInfos ( ) . addAll ( wpi . getTermsInfos ( ) ) ; return ; } } getPhraseList ( ) . add ( wpi ) ; }
public ThreeWayMerger newMerger ( Repository db ) { return new InCoreMerger ( db ) ; }
public float docScore ( int docId , String field , int numPayloadsSeen , float payloadScore ) { return numPayloadsSeen > 0 ? ( payloadScore / numPayloadsSeen ) : 1 ; }
public Collection < ParseTree > evaluate ( ParseTree t ) { return Trees . findAllRuleNodes ( t , ruleIndex ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ CFRULE ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . condition □ type ▁ ▁ ▁ = " ) . append ( getConditionType ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ OPTION ▁ FLAGS = 0x " ) . append ( Integer . toHexString ( getOptions ( ) ) ) . append ( " \ n " ) ; if ( containsFontFormattingBlock ( ) ) { buffer . append ( _fontFormatting ) . append ( " \ n " ) ; } if ( containsBorderFormattingBlock ( ) ) { buffer . append ( _borderFormatting ) . append ( " \ n " ) ; } if ( containsPatternFormattingBlock ( ) ) { buffer . append ( _patternFormatting ) . append ( " \ n " ) ; } buffer . append ( " ▁ ▁ ▁ ▁ Formula ▁ 1 ▁ = " ) . append ( Arrays . toString ( getFormula1 ( ) . getTokens ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ Formula ▁ 2 ▁ = " ) . append ( Arrays . toString ( getFormula2 ( ) . getTokens ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / CFRULE ] \ n " ) ; return buffer . toString ( ) ; }
public DescribeServiceUpdatesResult describeServiceUpdates ( DescribeServiceUpdatesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeServiceUpdates ( request ) ; }
public String getNameName ( int index ) { return getNameAt ( index ) . getNameName ( ) ; }
public DescribeLocationsResult describeLocations ( ) { return describeLocations ( new DescribeLocationsRequest ( ) ) ; }
public String toString ( ) { return " < phraseslop ▁ value = ' " ▁ + ▁ getValueString ( ) ▁ + ▁ " ' > " + " \ n " + getChild ( ) . toString ( ) + " \ n </ phraseslop > " ; }
public DirCacheEntry getDirCacheEntry ( ) { return currentSubtree == null ? currentEntry : null ; }
public IntBuffer put ( int [ ] src , int srcOffset , int intCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , intCount ) ; if ( intCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + intCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public void trimToSize ( ) { int s = size ; if ( s == array . length ) { return ; } if ( s == 0 ) { array = EmptyArray . OBJECT ; } else { Object [ ] newArray = new Object [ s ] ; System . arraycopy ( array , 0 , newArray , 0 , s ) ; array = newArray ; } modCount ++ ; }
public DescribeLocalGatewayVirtualInterfacesResult describeLocalGatewayVirtualInterfaces ( DescribeLocalGatewayVirtualInterfacesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLocalGatewayVirtualInterfaces ( request ) ; }
public TokenStream create ( TokenStream input ) { return new RussianLightStemFilter ( input ) ; }
public int [ ] toArray ( final int [ ] a ) { int [ ] rval ; if ( a . length == _limit ) { System . arraycopy ( _array , 0 , a , 0 , _limit ) ; rval = a ; } else { rval = toArray ( ) ; } return rval ; }
public BasicSessionCredentials ( String accessKeyId , String accessKeySecret , String sessionToken , long roleSessionDurationSeconds ) { if ( accessKeyId == null ) { throw new IllegalArgumentException ( " Access ▁ key ▁ ID ▁ cannot ▁ be ▁ null . " ) ; } if ( accessKeySecret == null ) { throw new IllegalArgumentException ( " Access ▁ key ▁ secret ▁ cannot ▁ be ▁ null . " ) ; } this . accessKeyId = accessKeyId ; this . accessKeySecret = accessKeySecret ; this . sessionToken = sessionToken ; this . roleSessionDurationSeconds = roleSessionDurationSeconds ; this . sessionStartedTimeInMilliSeconds = System . currentTimeMillis ( ) ; }
public final ShortBuffer get ( short [ ] dst , int dstOffset , int shortCount ) { if ( shortCount > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } System . arraycopy ( backingArray , offset + position , dst , dstOffset , shortCount ) ; position += shortCount ; return this ; }
public ActivateEventSourceResult activateEventSource ( ActivateEventSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeActivateEventSource ( request ) ; }
public DescribeReceiptRuleSetResult describeReceiptRuleSet ( DescribeReceiptRuleSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeReceiptRuleSet ( request ) ; }
public Filter ( String name ) { setName ( name ) ; }
public DoubleBuffer put ( double c ) { throw new ReadOnlyBufferException ( ) ; }
public CreateTrafficPolicyInstanceResult createTrafficPolicyInstance ( CreateTrafficPolicyInstanceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTrafficPolicyInstance ( request ) ; }
public JapaneseIterationMarkCharFilter ( Reader input , boolean normalizeKanji , boolean normalizeKana ) { super ( input ) ; this . normalizeKanji = normalizeKanji ; this . normalizeKana = normalizeKana ; buffer . reset ( input ) ; }
public void writeLong ( long v ) { writeInt ( ( int ) ( v >> 0 ) ) ; writeInt ( ( int ) ( v >> 32 ) ) ; }
public FileResolver ( ) { exports = new ConcurrentHashMap <> ( ) ; exportBase = new CopyOnWriteArrayList <> ( ) ; }
public ValueEval getRef3DEval ( Ref3DPxg rptg ) { SheetRangeEvaluator sre = createExternSheetRefEvaluator ( rptg . getSheetName ( ) , rptg . getLastSheetName ( ) , rptg . getExternalWorkbookNumber ( ) ) ; return new LazyRefEval ( rptg . getRow ( ) , rptg . getColumn ( ) , sre ) ; }
public DeleteDatasetResult deleteDataset ( DeleteDatasetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDataset ( request ) ; }
public StartRelationalDatabaseResult startRelationalDatabase ( StartRelationalDatabaseRequest request ) { request = beforeClientExecution ( request ) ; return executeStartRelationalDatabase ( request ) ; }
public DescribeReservedCacheNodesOfferingsResult describeReservedCacheNodesOfferings ( ) { return describeReservedCacheNodesOfferings ( new DescribeReservedCacheNodesOfferingsRequest ( ) ) ; }
static public double pmt ( double r , int nper , double pv , double fv , int type ) { return - r * ( pv * Math . pow ( 1 + r , nper ) + fv ) / ( ( 1 + r * type ) * ( Math . pow ( 1 + r , nper ) - 1 ) ) ; }
public DescribeDocumentVersionsResult describeDocumentVersions ( DescribeDocumentVersionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDocumentVersions ( request ) ; }
public ListPublishingDestinationsResult listPublishingDestinations ( ListPublishingDestinationsRequest request ) { request = beforeClientExecution ( request ) ; return executeListPublishingDestinations ( request ) ; }
public DeleteAccountAliasRequest ( String accountAlias ) { setAccountAlias ( accountAlias ) ; }
public static long [ ] grow ( long [ ] array ) { return grow ( array , 1 + array . length ) ; }
public String outputToString ( Object output ) { if ( ! ( output instanceof List ) ) { return outputs . outputToString ( ( T ) output ) ; } else { List < T > outputList = ( List < T > ) output ; StringBuilder b = new StringBuilder ( ) ; b . append ( ' [ ' ) ; for ( int i = 0 ; i < outputList . size ( ) ; i ++ ) { if ( i > 0 ) { b . append ( " , ▁ " ) ; } b . append ( outputs . outputToString ( outputList . get ( i ) ) ) ; } b . append ( ' ] ' ) ; return b . toString ( ) ; } }
public void notifyDeleteCell ( Cell cell ) { _bookEvaluator . notifyDeleteCell ( new HSSFEvaluationCell ( ( HSSFCell ) cell ) ) ; }
public StringBuilder replace ( int start , int end , String str ) { replace0 ( start , end , str ) ; return this ; }
public SetIdentityPoolConfigurationResult setIdentityPoolConfiguration ( SetIdentityPoolConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeSetIdentityPoolConfiguration ( request ) ; }
public static double kthSmallest ( double [ ] v , int k ) { double r = Double . NaN ; int index = k - 1 ; if ( v != null && v . length > index && index >= 0 ) { Arrays . sort ( v ) ; r = v [ index ] ; } return r ; }
public void set ( int index , long value ) { final int o = index >>> 5 ; final int b = index & 31 ; final int shift = b << 1 ; blocks [ o ] = ( blocks [ o ] & ~ ( 3L << shift ) ) | ( value << shift ) ; }
public String toString ( ) { if ( getChildren ( ) == null || getChildren ( ) . size ( ) == 0 ) return " < boolean ▁ operation = ' and ' /> " ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " < boolean ▁ operation = ' and ' > " ) ; for ( QueryNode child : getChildren ( ) ) { sb . append ( " \ n " ) ; sb . append ( child . toString ( ) ) ; } sb . append ( " \ n </ boolean > " ) ; return sb . toString ( ) ; }
public int sumTokenSizes ( int fromIx , int toIx ) { int result = 0 ; for ( int i = fromIx ; i < toIx ; i ++ ) { result += _ptgs [ i ] . getSize ( ) ; } return result ; }
public void setReadonly ( boolean readonly ) { if ( this . readonly && ! readonly ) throw new IllegalStateException ( " can ' t alter readonly IntervalSet " ) ; this . readonly ▁ = ▁ readonly ; }
public final void clearConsumingCell ( FormulaCellCacheEntry cce ) { if ( ! _consumingCells . remove ( cce ) ) { throw new IllegalStateException ( " Specified ▁ formula ▁ cell ▁ is ▁ not ▁ consumed ▁ by ▁ this ▁ cell " ) ; } }
@ Override public List < E > subList ( int start , int end ) { synchronized ( mutex ) { return new SynchronizedRandomAccessList < E > ( list . subList ( start , end ) , mutex ) ; } }
public FileHeader getFileHeader ( ) { return file ; }
public AttachLoadBalancersResult attachLoadBalancers ( AttachLoadBalancersRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachLoadBalancers ( request ) ; }
public InitiateJobRequest ( String accountId , String vaultName , JobParameters jobParameters ) { setAccountId ( accountId ) ; setVaultName ( vaultName ) ; setJobParameters ( jobParameters ) ; }
public String toString ( ) { return " SPL " ; }
public ReplaceableAttribute ( String name , String value , Boolean replace ) { setName ( name ) ; setValue ( value ) ; setReplace ( replace ) ; }
public final void add ( IndexableField field ) { fields . add ( field ) ; }
public DeleteStackSetResult deleteStackSet ( DeleteStackSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteStackSet ( request ) ; }
public GetRepoBuildRuleListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoBuildRuleList " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / rules " ) ; setMethod ( MethodType . GET ) ; }
public SparseArray ( int initialCapacity ) { initialCapacity = ArrayUtils . idealIntArraySize ( initialCapacity ) ; mKeys = new int [ initialCapacity ] ; mValues = new Object [ initialCapacity ] ; mSize = 0 ; }
public InvokeServiceRequest ( ) { super ( " industry - brain " , " 2018 - 07 - 12 " , " InvokeService " ) ; setMethod ( MethodType . POST ) ; }
public ListAlbumPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListAlbumPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public boolean hasPrevious ( ) { return link != list . voidLink ; }
public DeleteHsmConfigurationResult deleteHsmConfiguration ( DeleteHsmConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteHsmConfiguration ( request ) ; }
public CreateLoadBalancerRequest ( String loadBalancerName ) { setLoadBalancerName ( loadBalancerName ) ; }
public String getUserInfo ( ) { return decode ( userInfo ) ; }
public TagAttendeeResult tagAttendee ( TagAttendeeRequest request ) { request = beforeClientExecution ( request ) ; return executeTagAttendee ( request ) ; }
public String getRefName ( ) { return name ; }
public SpanNearQuery build ( ) { return new SpanNearQuery ( clauses . toArray ( new SpanQuery [ clauses . size ( ) ] ) , slop , ordered ) ; }
public boolean isSubTotal ( int rowIndex , int columnIndex ) { return false ; }
public DescribeDBProxiesResult describeDBProxies ( DescribeDBProxiesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBProxies ( request ) ; }
public GetVoiceConnectorProxyResult getVoiceConnectorProxy ( GetVoiceConnectorProxyRequest request ) { request = beforeClientExecution ( request ) ; return executeGetVoiceConnectorProxy ( request ) ; }
public WindowCacheConfig fromConfig ( Config rc ) { setPackedGitUseStrongRefs ( rc . getBoolean ( CONFIG_CORE_SECTION , CONFIG_KEY_PACKED_GIT_USE_STRONGREFS , isPackedGitUseStrongRefs ( ) ) ) ; setPackedGitOpenFiles ( rc . getInt ( CONFIG_CORE_SECTION , null , CONFIG_KEY_PACKED_GIT_OPENFILES , getPackedGitOpenFiles ( ) ) ) ; setPackedGitLimit ( rc . getLong ( CONFIG_CORE_SECTION , null , CONFIG_KEY_PACKED_GIT_LIMIT , getPackedGitLimit ( ) ) ) ; setPackedGitWindowSize ( rc . getInt ( CONFIG_CORE_SECTION , null , CONFIG_KEY_PACKED_GIT_WINDOWSIZE , getPackedGitWindowSize ( ) ) ) ; setPackedGitMMAP ( rc . getBoolean ( CONFIG_CORE_SECTION , null , CONFIG_KEY_PACKED_GIT_MMAP , isPackedGitMMAP ( ) ) ) ; setDeltaBaseCacheLimit ( rc . getInt ( CONFIG_CORE_SECTION , null , CONFIG_KEY_DELTA_BASE_CACHE_LIMIT , getDeltaBaseCacheLimit ( ) ) ) ; long maxMem = Runtime . getRuntime ( ) . maxMemory ( ) ; long sft = rc . getLong ( CONFIG_CORE_SECTION , null , CONFIG_KEY_STREAM_FILE_TRESHOLD , getStreamFileThreshold ( ) ) ; sft = Math . min ( sft , maxMem / 4 ) ; sft = Math . min ( sft , Integer . MAX_VALUE ) ; setStreamFileThreshold ( ( int ) sft ) ; return this ; }
public static Date getJavaDate ( double date ) { return getJavaDate ( date , false , null , false ) ; }
public StartPersonTrackingResult startPersonTracking ( StartPersonTrackingRequest request ) { request = beforeClientExecution ( request ) ; return executeStartPersonTracking ( request ) ; }
@ Override public int size ( ) { return totalSize ; }
public GetRouteResult getRoute ( GetRouteRequest request ) { request = beforeClientExecution ( request ) ; return executeGetRoute ( request ) ; }
public DeleteClusterResult deleteCluster ( DeleteClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteCluster ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ MMS ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . addMenu ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getAddMenuCount ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . delMenu ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getDelMenuCount ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / MMS ] \ n " ) ; return buffer . toString ( ) ; }
public FileBasedConfig ( Config base , File cfgLocation , FS fs ) { super ( base ) ; configFile = cfgLocation ; this . fs = fs ; this . snapshot = FileSnapshot . DIRTY ; this . hash = ObjectId . zeroId ( ) ; }
public int following ( int pos ) { if ( pos < text . getBeginIndex ( ) || pos > text . getEndIndex ( ) ) { throw new IllegalArgumentException ( " offset ▁ out ▁ of ▁ bounds " ) ; } else if ( 0 == sentenceStarts . length ) { text . setIndex ( text . getBeginIndex ( ) ) ; return DONE ; } else if ( pos >= sentenceStarts [ sentenceStarts . length - 1 ] ) { text . setIndex ( text . getEndIndex ( ) ) ; currentSentence = sentenceStarts . length - 1 ; return DONE ; } else { currentSentence = ( sentenceStarts . length - 1 ) / 2 ; moveToSentenceAt ( pos , 0 , sentenceStarts . length - 2 ) ; text . setIndex ( sentenceStarts [ ++ currentSentence ] ) ; return current ( ) ; } }
public UpdateParameterGroupResult updateParameterGroup ( UpdateParameterGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateParameterGroup ( request ) ; }
public SeriesChartGroupIndexRecord clone ( ) { return copy ( ) ; }
public static double calcDistanceFromErrPct ( Shape shape , double distErrPct , SpatialContext ctx ) { if ( distErrPct < 0 || distErrPct > 0.5 ) { throw new IllegalArgumentException ( " distErrPct ▁ " + distErrPct + " ▁ must ▁ be ▁ between ▁ [ 0 ▁ to ▁ 0.5 ] " ) ; } if ( distErrPct == 0 || shape instanceof Point ) { return 0 ; } Rectangle bbox = shape . getBoundingBox ( ) ; Point ctr = bbox . getCenter ( ) ; double y = ( ctr . getY ( ) >= 0 ? bbox . getMaxY ( ) : bbox . getMinY ( ) ) ; double diagonalDist = ctx . getDistCalc ( ) . distance ( ctr , bbox . getMaxX ( ) , y ) ; return diagonalDist * distErrPct ; }
public int codePointAt ( int index ) { if ( index < 0 || index >= count ) { throw indexAndLength ( index ) ; } return Character . codePointAt ( value , index , count ) ; }
public void setPasswordVerifier ( int passwordVerifier ) { this . passwordVerifier = passwordVerifier ; }
public ListVaultsRequest ( String accountId ) { setAccountId ( accountId ) ; }
public SquashMessageFormatter ( ) { dateFormatter = new GitDateFormatter ( Format . DEFAULT ) ; }
public GetVideoCoverRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " GetVideoCover " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public int lastIndexOf ( Object object ) { int pos = size ; Link < E > link = voidLink . previous ; if ( object != null ) { while ( link != voidLink ) { pos -- ; if ( object . equals ( link . data ) ) { return pos ; } link = link . previous ; } } else { while ( link != voidLink ) { pos -- ; if ( link . data == null ) { return pos ; } link = link . previous ; } } return - 1 ; }
public DescribeSpotFleetRequestsResult describeSpotFleetRequests ( DescribeSpotFleetRequestsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSpotFleetRequests ( request ) ; }
public IndexFacesResult indexFaces ( IndexFacesRequest request ) { request = beforeClientExecution ( request ) ; return executeIndexFaces ( request ) ; }
public RuleBasedBreakIterator getBreakIterator ( int script ) { switch ( script ) { case UScript . JAPANESE : return ( RuleBasedBreakIterator ) cjkBreakIterator . clone ( ) ; case UScript . MYANMAR : if ( myanmarAsWords ) { return ( RuleBasedBreakIterator ) defaultBreakIterator . clone ( ) ; } else { return ( RuleBasedBreakIterator ) myanmarSyllableIterator . clone ( ) ; } default : return ( RuleBasedBreakIterator ) defaultBreakIterator . clone ( ) ; } }
public String toString ( ) { StringBuilder b = new StringBuilder ( ) ; b . append ( " [ DCONREF ] \ n " ) ; b . append ( " ▁ ▁ ▁ ▁ . ref \ n " ) ; b . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . firstrow ▁ ▁ ▁ = ▁ " ) . append ( firstRow ) . append ( " \ n " ) ; b . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . lastrow ▁ ▁ ▁ ▁ = ▁ " ) . append ( lastRow ) . append ( " \ n " ) ; b . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . firstcol ▁ ▁ ▁ = ▁ " ) . append ( firstCol ) . append ( " \ n " ) ; b . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . lastcol ▁ ▁ ▁ ▁ = ▁ " ) . append ( lastCol ) . append ( " \ n " ) ; b . append ( " ▁ ▁ ▁ ▁ . cch ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( charCount ) . append ( " \ n " ) ; b . append ( " ▁ ▁ ▁ ▁ . stFile \ n " ) ; b . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . h ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( charType ) . append ( " \ n " ) ; b . append ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . rgb ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getReadablePath ( ) ) . append ( " \ n " ) ; b . append ( " [ / DCONREF ] \ n " ) ; return b . toString ( ) ; }
public int getPackedGitOpenFiles ( ) { return packedGitOpenFiles ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ FEATURE ▁ HEADER ] \ n " ) ; buffer . append ( " [ / FEATURE ▁ HEADER ] \ n " ) ; return buffer . toString ( ) ; }
public static byte [ ] getToUnicodeLE ( String string ) { return string . getBytes ( UTF16LE ) ; }
public final List < String > getFooterLines ( String keyName ) { return getFooterLines ( new FooterKey ( keyName ) ) ; }
public void refresh ( ) { super . refresh ( ) ; clearReferences ( ) ; }
public float get ( int index ) { checkIndex ( index ) ; return byteBuffer . getFloat ( index * SizeOf . FLOAT ) ; }
public DeleteDetectorResult deleteDetector ( DeleteDetectorRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDetector ( request ) ; }
public int [ ] grow ( ) { assert bytesStart != null ; return bytesStart = ArrayUtil . grow ( bytesStart , bytesStart . length + 1 ) ; }
public ListExclusionsResult listExclusions ( ListExclusionsRequest request ) { request = beforeClientExecution ( request ) ; return executeListExclusions ( request ) ; }
public static SpatialStrategy getSpatialStrategy ( int roundNumber ) { SpatialStrategy result = spatialStrategyCache . get ( roundNumber ) ; if ( result == null ) { throw new IllegalStateException ( " Strategy ▁ should ▁ have ▁ been ▁ init ' ed by SpatialDocMaker by now " ) ; } return ▁ result ; }
public DBCluster restoreDBClusterToPointInTime ( RestoreDBClusterToPointInTimeRequest request ) { request = beforeClientExecution ( request ) ; return executeRestoreDBClusterToPointInTime ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_categoryDataType ) ; out . writeShort ( field_2_valuesDataType ) ; out . writeShort ( field_3_numCategories ) ; out . writeShort ( field_4_numValues ) ; out . writeShort ( field_5_bubbleSeriesType ) ; out . writeShort ( field_6_numBubbleValues ) ; }
public PostAgentProfileResult postAgentProfile ( PostAgentProfileRequest request ) { request = beforeClientExecution ( request ) ; return executePostAgentProfile ( request ) ; }
public ParseTreePattern compileParseTreePattern ( String pattern , int patternRuleIndex ) { if ( getTokenStream ( ) != null ) { TokenSource tokenSource = getTokenStream ( ) . getTokenSource ( ) ; if ( tokenSource instanceof Lexer ) { Lexer lexer = ( Lexer ) tokenSource ; return compileParseTreePattern ( pattern , patternRuleIndex , lexer ) ; } } throw new UnsupportedOperationException ( " Parser ▁ can ' t discover a lexer to use " ) ; }
public BacktrackDBClusterResult backtrackDBCluster ( BacktrackDBClusterRequest request ) { request = beforeClientExecution ( request ) ; return executeBacktrackDBCluster ( request ) ; }
public String getName ( ) { return strategyName ; }
public void copyTo ( byte [ ] b , int o ) { formatHexByte ( b , o + 0 , w1 ) ; formatHexByte ( b , o + 8 , w2 ) ; formatHexByte ( b , o + 16 , w3 ) ; formatHexByte ( b , o + 24 , w4 ) ; formatHexByte ( b , o + 32 , w5 ) ; }
public static final IntList lineMap ( byte [ ] buf , int ptr , int end ) { IntList map = new IntList ( ( end - ptr ) / 36 ) ; map . fillTo ( 1 , Integer . MIN_VALUE ) ; for ( ; ptr < end ; ptr = nextLF ( buf , ptr ) ) { map . add ( ptr ) ; } map . add ( end ) ; return map ; }
public Set < ObjectId > getAdditionalHaves ( ) { return Collections . emptySet ( ) ; }
public synchronized long ramBytesUsed ( ) { long sizeInBytes = BASE_RAM_BYTES_USED + fields . size ( ) * 2 * RamUsageEstimator . NUM_BYTES_OBJECT_REF ; for ( SimpleTextTerms simpleTextTerms : termsCache . values ( ) ) { sizeInBytes += ( simpleTextTerms != null ) ? simpleTextTerms . ramBytesUsed ( ) : 0 ; } return sizeInBytes ; }
public String toXml ( String tab ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( tab ) . append ( " < " ) . append ( getRecordName ( ) ) . append ( " >\ n " ) ; for ( EscherRecord escherRecord : getEscherRecords ( ) ) { builder . append ( escherRecord . toXml ( tab + " \ t " ) ) ; } builder . append ( tab ) . append ( " </ " ) . append ( getRecordName ( ) ) . append ( " >\ n " ) ; return builder . toString ( ) ; }
public TokenStream create ( TokenStream input ) { return new GalicianMinimalStemFilter ( input ) ; }
public String toString ( ) { StringBuilder r = new StringBuilder ( ) ; r . append ( " Commit " ) ; r . append ( " = { \ n " ) ; r . append ( " tree ▁ " ) ; r . append ( treeId != null ? treeId . name ( ) : " NOT □ SET " ) ; r . append ( " \ n " ) ; for ( ObjectId p : parentIds ) { r . append ( " parent ▁ " ) ; r . append ( p . name ( ) ) ; r . append ( " \ n " ) ; } r . append ( " author ▁ " ) ; r . append ( author != null ? author . toString ( ) : " NOT □ SET " ) ; r . append ( " \ n " ) ; r . append ( " committer ▁ " ) ; r . append ( committer != null ? committer . toString ( ) : " NOT □ SET " ) ; r . append ( " \ n " ) ; r . append ( " gpgSignature ▁ " ) ; r . append ( gpgSignature != null ? gpgSignature . toString ( ) : " NOT □ SET " ) ; r . append ( " \ n " ) ; if ( encoding != null && ! References . isSameObject ( encoding , UTF_8 ) ) { r . append ( " encoding ▁ " ) ; r . append ( encoding . name ( ) ) ; r . append ( " \ n " ) ; } r . append ( " \ n " ) ; r . append ( message != null ? message : " " ) ; r . append ( " } " ) ; return r . toString ( ) ; }
public IndicNormalizationFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public OptionGroup createOptionGroup ( CreateOptionGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateOptionGroup ( request ) ; }
public AssociateMemberAccountResult associateMemberAccount ( AssociateMemberAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateMemberAccount ( request ) ; }
public void run ( ) { doRefreshProgress ( mId , mProgress , mFromUser , true ) ; mRefreshProgressRunnable = this ; }
public SetTerminationProtectionResult setTerminationProtection ( SetTerminationProtectionRequest request ) { request = beforeClientExecution ( request ) ; return executeSetTerminationProtection ( request ) ; }
public String getErrorHeader ( RecognitionException e ) { int line = e . getOffendingToken ( ) . getLine ( ) ; int charPositionInLine = e . getOffendingToken ( ) . getCharPositionInLine ( ) ; return " line ▁ " + line + " : " + charPositionInLine ; }
public CharBuffer asReadOnlyBuffer ( ) { CharToByteBufferAdapter buf = new CharToByteBufferAdapter ( byteBuffer . asReadOnlyBuffer ( ) ) ; buf . limit = limit ; buf . position = position ; buf . mark = mark ; buf . byteBuffer . order = byteBuffer . order ; return buf ; }
public StopSentimentDetectionJobResult stopSentimentDetectionJob ( StopSentimentDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopSentimentDetectionJob ( request ) ; }
public ObjectIdSubclassMap < ObjectId > getNewObjectIds ( ) { if ( newObjectIds != null ) return newObjectIds ; return new ObjectIdSubclassMap <> ( ) ; }
public void clear ( ) { hash = hash ( new byte [ 0 ] ) ; super . clear ( ) ; }
public void reset ( ) throws IOException { synchronized ( lock ) { checkNotClosed ( ) ; if ( mark == - 1 ) { throw new IOException ( " Invalid ▁ mark " ) ; } pos = mark ; } }
public RefErrorPtg ( LittleEndianInput in ) { field_1_reserved = in . readInt ( ) ; }
public SuspendGameServerGroupResult suspendGameServerGroup ( SuspendGameServerGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeSuspendGameServerGroup ( request ) ; }
public final ValueEval evaluate ( ValueEval [ ] args , int srcRowIndex , int srcColumnIndex ) { if ( args . length != 3 ) { return ErrorEval . VALUE_INVALID ; } return evaluate ( srcRowIndex , srcColumnIndex , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; }
public GetRepoRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepo " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] " ) ; setMethod ( MethodType . GET ) ; }
public void setDate ( Date date ) { if ( date != null ) { setDate ( DateTools . dateToString ( date , DateTools . Resolution . SECOND ) ) ; } else { this . date = null ; } }
public TokenStream create ( TokenStream input ) { return new GermanMinimalStemFilter ( input ) ; }
public Object [ ] toArray ( ) { return a . clone ( ) ; }
public void write ( char [ ] buffer , int offset , int len ) { Arrays . checkOffsetAndCount ( buffer . length , offset , len ) ; synchronized ( lock ) { expand ( len ) ; System . arraycopy ( buffer , offset , this . buf , this . count , len ) ; this . count += len ; } }
public static final RevFilter after ( Date ts ) { return after ( ts . getTime ( ) ) ; }
public DeleteGroupPolicyRequest ( String groupName , String policyName ) { setGroupName ( groupName ) ; setPolicyName ( policyName ) ; }
public DeregisterTransitGatewayMulticastGroupMembersResult deregisterTransitGatewayMulticastGroupMembers ( DeregisterTransitGatewayMulticastGroupMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterTransitGatewayMulticastGroupMembers ( request ) ; }
public BatchDeleteScheduledActionResult batchDeleteScheduledAction ( BatchDeleteScheduledActionRequest request ) { request = beforeClientExecution ( request ) ; return executeBatchDeleteScheduledAction ( request ) ; }
public CreateAlgorithmResult createAlgorithm ( CreateAlgorithmRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateAlgorithm ( request ) ; }
public int readUByte ( ) { return readByte ( ) & 0x00FF ; }
public void setLength ( int sz ) { NB . encodeInt32 ( info , infoOffset + P_SIZE , sz ) ; }
public DescribeScalingProcessTypesResult describeScalingProcessTypes ( ) { return describeScalingProcessTypes ( new DescribeScalingProcessTypesRequest ( ) ) ; }
public ListResourceRecordSetsResult listResourceRecordSets ( ListResourceRecordSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListResourceRecordSets ( request ) ; }
public Token recoverInline ( Parser recognizer ) throws RecognitionException { InputMismatchException e = new InputMismatchException ( recognizer ) ; for ( ParserRuleContext context = recognizer . getContext ( ) ; context != null ; context = context . getParent ( ) ) { context . exception = e ; } throw new ParseCancellationException ( e ) ; }
public SetTagsForResourceResult setTagsForResource ( SetTagsForResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeSetTagsForResource ( request ) ; }
public ModifyStrategyRequest ( ) { super ( " CloudCallCenter " , " 2017 - 07 - 05 " , " ModifyStrategy " , " CloudCallCenter " , " innerAPI " ) ; }
public DescribeVpcEndpointServicesResult describeVpcEndpointServices ( DescribeVpcEndpointServicesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVpcEndpointServices ( request ) ; }
public EnableLoggingResult enableLogging ( EnableLoggingRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableLogging ( request ) ; }
public boolean contains ( Object o ) { return ConcurrentHashMap . this . containsValue ( o ) ; }
public SheetRangeIdentifier ( String bookName , NameIdentifier firstSheetIdentifier , NameIdentifier lastSheetIdentifier ) { super ( bookName , firstSheetIdentifier ) ; _lastSheetIdentifier = lastSheetIdentifier ; }
public DomainMetadataRequest ( String domainName ) { setDomainName ( domainName ) ; }
public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( new MessageImpl ( QueryParserMessages . INVALID_SYNTAX , initialise ( currentTokenVal , expectedTokenSequencesVal , tokenImageVal ) ) ) ; this . currentToken = currentTokenVal ; this . expectedTokenSequences = expectedTokenSequencesVal ; this . tokenImage = tokenImageVal ; }
public FetchPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " FetchPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public PrintWriter writer ( ) { return writer ; }
public NGramTokenizerFactory ( Map < String , String > args ) { super ( args ) ; minGramSize = getInt ( args , " minGramSize " , NGramTokenizer . DEFAULT_MIN_NGRAM_SIZE ) ; maxGramSize = getInt ( args , " maxGramSize " , NGramTokenizer . DEFAULT_MAX_NGRAM_SIZE ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public boolean isDirectoryFileConflict ( ) { return dfConflict != null ; }
public IndonesianStemFilter ( TokenStream input , boolean stemDerivational ) { super ( input ) ; this . stemDerivational = stemDerivational ; }
public CreateTrafficPolicyResult createTrafficPolicy ( CreateTrafficPolicyRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateTrafficPolicy ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeInt ( fSD ) ; out . writeInt ( passwordVerifier ) ; StringUtil . writeUnicodeString ( out , title ) ; out . write ( securityDescriptor ) ; }
public static double floor ( double n , double s ) { if ( s == 0 && n != 0 ) { return Double . NaN ; } else { return ( n == 0 || s == 0 ) ? 0 : Math . floor ( n / s ) * s ; } }
public ByteArrayDataOutput ( byte [ ] bytes , int offset , int len ) { reset ( bytes , offset , len ) ; }
public static List < Tree > getChildren ( Tree t ) { List < Tree > kids = new ArrayList < Tree > ( ) ; for ( int i = 0 ; i < t . getChildCount ( ) ; i ++ ) { kids . add ( t . getChild ( i ) ) ; } return kids ; }
public void clear ( ) { Hashtable . this . clear ( ) ; }
public RefreshAllRecord ( boolean refreshAll ) { this ( 0 ) ; setRefreshAll ( refreshAll ) ; }
public DeleteNamedQueryResult deleteNamedQuery ( DeleteNamedQueryRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNamedQuery ( request ) ; }
public GraphvizFormatter ( ConnectionCosts costs ) { this . costs = costs ; this . bestPathMap = new HashMap <> ( ) ; sb . append ( formatHeader ( ) ) ; sb . append ( " ▁ ▁ init ▁ [ style = invis ] \ n " ) ; sb . append ( " ▁ ▁ init ▁ -> ▁ 0.0 ▁ [ label =\ " " + BOS_LABEL + " \ " ] \ n " ) ; }
public CheckMultiagentRequest ( ) { super ( " visionai - poc " , " 2020 - 04 - 08 " , " CheckMultiagent " ) ; setMethod ( MethodType . POST ) ; }
public ListUserProfilesResult listUserProfiles ( ListUserProfilesRequest request ) { request = beforeClientExecution ( request ) ; return executeListUserProfiles ( request ) ; }
public CreateRelationalDatabaseFromSnapshotResult createRelationalDatabaseFromSnapshot ( CreateRelationalDatabaseFromSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRelationalDatabaseFromSnapshot ( request ) ; }
public StartTaskResult startTask ( StartTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeStartTask ( request ) ; }
public Set < String > getIgnoredPaths ( ) { return ignoredPaths ; }
public FeatSmartTag ( RecordInputStream in ) { data = in . readRemainder ( ) ; }
public Change ( ChangeAction action , ResourceRecordSet resourceRecordSet ) { setAction ( action . toString ( ) ) ; setResourceRecordSet ( resourceRecordSet ) ; }
public DeleteImageResult deleteImage ( DeleteImageRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteImage ( request ) ; }
public CreateConfigurationSetResult createConfigurationSet ( CreateConfigurationSetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateConfigurationSet ( request ) ; }
public Iterator < E > iterator ( ) { Object [ ] snapshot = elements ; return new CowIterator < E > ( snapshot , 0 , snapshot . length ) ; }
public void visitContainedRecords ( RecordVisitor rv ) { if ( _recs . isEmpty ( ) ) { return ; } rv . visitRecord ( _bofRec ) ; for ( int i = 0 ; i < _recs . size ( ) ; i ++ ) { RecordBase rb = _recs . get ( i ) ; if ( rb instanceof RecordAggregate ) { ( ( RecordAggregate ) rb ) . visitContainedRecords ( rv ) ; } else { rv . visitRecord ( ( org . apache . poi . hssf . record . Record ) rb ) ; } } rv . visitRecord ( EOFRecord . instance ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ FtCbls ▁ ] " ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ size ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getDataSize ( ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ reserved ▁ = ▁ " ) . append ( HexDump . toHex ( reserved ) ) . append ( " \ n " ) ; buffer . append ( " [ / FtCbls ▁ ] " ) . append ( " \ n " ) ; return buffer . toString ( ) ; }
public static BATBlock createEmptyBATBlock ( final POIFSBigBlockSize bigBlockSize , boolean isXBAT ) { BATBlock block = new BATBlock ( bigBlockSize ) ; if ( isXBAT ) { final int _entries_per_xbat_block = bigBlockSize . getXBATEntriesPerBlock ( ) ; block . _values [ _entries_per_xbat_block ] = POIFSConstants . END_OF_CHAIN ; } return block ; }
public TagResourceResult tagResource ( TagResourceRequest request ) { request = beforeClientExecution ( request ) ; return executeTagResource ( request ) ; }
public DeleteMailboxPermissionsResult deleteMailboxPermissions ( DeleteMailboxPermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMailboxPermissions ( request ) ; }
public ListDatasetGroupsResult listDatasetGroups ( ListDatasetGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDatasetGroups ( request ) ; }
public ResumeProcessesResult resumeProcesses ( ResumeProcessesRequest request ) { request = beforeClientExecution ( request ) ; return executeResumeProcesses ( request ) ; }
public GetPersonTrackingResult getPersonTracking ( GetPersonTrackingRequest request ) { request = beforeClientExecution ( request ) ; return executeGetPersonTracking ( request ) ; }
public String toFormulaString ( String [ ] operands ) { if ( space . isSet ( _options ) ) { return operands [ 0 ] ; } else if ( optiIf . isSet ( _options ) ) { return toFormulaString ( ) + " ( " + operands [ 0 ] + " ) " ; } else if ( optiSkip . isSet ( _options ) ) { return toFormulaString ( ) + operands [ 0 ] ; } else { return toFormulaString ( ) + " ( " + operands [ 0 ] + " ) " ; } }
public T merge ( T first , T second ) { throw new UnsupportedOperationException ( ) ; }
public String toString ( ) { return this . message . getKey ( ) + " : ▁ " + getLocalizedMessage ( ) ; }
public XPath ( Parser parser , String path ) { this . parser = parser ; this . path = path ; elements = split ( path ) ; }
public CreateAccountAliasRequest ( String accountAlias ) { setAccountAlias ( accountAlias ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { final byte block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( block >>> 7 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 6 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 5 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 4 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 3 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 2 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 1 ) & 1 ; values [ valuesOffset ++ ] = block & 1 ; } }
public PushConnection openPush ( ) throws TransportException { return new TcpPushConnection ( ) ; }
public static void strcpy ( char [ ] dst , int di , char [ ] src , int si ) { while ( src [ si ] != 0 ) { dst [ di ++ ] = src [ si ++ ] ; } dst [ di ] = 0 ; }
@ Override public K getKey ( ) { return mapEntry . getKey ( ) ; }
public static int numNonnull ( Object [ ] data ) { int n = 0 ; if ( data == null ) return n ; for ( Object o : data ) { if ( o != null ) n ++ ; } return n ; }
public void add ( int location , E object ) { if ( location >= 0 && location <= size ) { Link < E > link = voidLink ; if ( location < ( size / 2 ) ) { for ( int i = 0 ; i <= location ; i ++ ) { link = link . next ; } } else { for ( int i = size ; i > location ; i -- ) { link = link . previous ; } } Link < E > previous = link . previous ; Link < E > newLink = new Link < E > ( object , previous , link ) ; previous . next = newLink ; link . previous = newLink ; size ++ ; modCount ++ ; } else { throw new IndexOutOfBoundsException ( ) ; } }
public DescribeDomainResult describeDomain ( DescribeDomainRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDomain ( request ) ; }
public void flush ( ) throws IOException { super . flush ( ) ; }
public PersianCharFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public boolean incrementToken ( ) { if ( used ) { return false ; } clearAttributes ( ) ; termAttribute . append ( value ) ; offsetAttribute . setOffset ( 0 , length ) ; used = true ; return true ; }
public static FloatBuffer allocate ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( ) ; } return new ReadWriteFloatArrayBuffer ( capacity ) ; }
public final Edit after ( Edit cut ) { return new Edit ( cut . endA , endA , cut . endB , endB ) ; }
public UpdateRuleVersionResult updateRuleVersion ( UpdateRuleVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRuleVersion ( request ) ; }
public ListVoiceConnectorTerminationCredentialsResult listVoiceConnectorTerminationCredentials ( ListVoiceConnectorTerminationCredentialsRequest request ) { request = beforeClientExecution ( request ) ; return executeListVoiceConnectorTerminationCredentials ( request ) ; }
public GetDeploymentTargetResult getDeploymentTarget ( GetDeploymentTargetRequest request ) { request = beforeClientExecution ( request ) ; return executeGetDeploymentTarget ( request ) ; }
public void setNoChildReport ( ) { letChildReport = false ; for ( final PerfTask task : tasks ) { if ( task instanceof TaskSequence ) { ( ( TaskSequence ) task ) . setNoChildReport ( ) ; } } }
public E get ( int location ) { try { return a [ location ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw java . util . ArrayList . throwIndexOutOfBoundsException ( location , a . length ) ; } }
public DescribeDataSetResult describeDataSet ( DescribeDataSetRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDataSet ( request ) ; }
public SkipWorkTreeFilter ( int treeIdx ) { this . treeIdx = treeIdx ; }
public DescribeNetworkInterfacesResult describeNetworkInterfaces ( ) { return describeNetworkInterfaces ( new DescribeNetworkInterfacesRequest ( ) ) ; }
public final boolean contains ( int row , int col ) { return _firstRow <= row && _lastRow >= row && _firstColumn <= col && _lastColumn >= col ; }
public String toString ( ) { return new String ( this . chars ) ; }
public PatchType getPatchType ( ) { return patchType ; }
public Iterator < K > iterator ( ) { return new KeyIterator ( ) ; }
public CreateScriptResult createScript ( CreateScriptRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateScript ( request ) ; }
public BytesRef next ( ) { termUpto ++ ; if ( termUpto >= info . terms . size ( ) ) { return null ; } else { info . terms . get ( info . sortedTerms [ termUpto ] , br ) ; return br ; } }
public String outputToString ( CharsRef output ) { return output . toString ( ) ; }
public AssociateWebsiteAuthorizationProviderResult associateWebsiteAuthorizationProvider ( AssociateWebsiteAuthorizationProviderRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateWebsiteAuthorizationProvider ( request ) ; }
public void unpop ( RevCommit c ) { Block b = head ; if ( b == null ) { b = free . newBlock ( ) ; b . resetToMiddle ( ) ; b . add ( c ) ; head = b ; tail = b ; return ; } else if ( b . canUnpop ( ) ) { b . unpop ( c ) ; return ; } b = free . newBlock ( ) ; b . resetToEnd ( ) ; b . unpop ( c ) ; b . next = head ; head = b ; }
public EdgeNGramTokenizerFactory ( Map < String , String > args ) { super ( args ) ; minGramSize = getInt ( args , " minGramSize " , EdgeNGramTokenizer . DEFAULT_MIN_GRAM_SIZE ) ; maxGramSize = getInt ( args , " maxGramSize " , EdgeNGramTokenizer . DEFAULT_MAX_GRAM_SIZE ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public ModifyDBParameterGroupRequest ( String dBParameterGroupName , java . util . List < Parameter > parameters ) { setDBParameterGroupName ( dBParameterGroupName ) ; setParameters ( parameters ) ; }
public GetHostedZoneLimitResult getHostedZoneLimit ( GetHostedZoneLimitRequest request ) { request = beforeClientExecution ( request ) ; return executeGetHostedZoneLimit ( request ) ; }
public void set ( int index , long value ) { final int o = index >>> 6 ; final int b = index & 63 ; final int shift = b << 0 ; blocks [ o ] = ( blocks [ o ] & ~ ( 1L << shift ) ) | ( value << shift ) ; }
public RevFilter clone ( ) { return new PatternSearch ( pattern ( ) ) ; }
public String toString ( ) { return " spans ( " + term . toString ( ) + " ) @ " + ( doc == - 1 ? " START " : ( doc == NO_MORE_DOCS ) ? " ENDDOC " : doc + " ▁ - ▁ " + ( position == NO_MORE_POSITIONS ? " ENDPOS " : position ) ) ; }
public boolean canAppendMatch ( ) { for ( Head head : heads ) { if ( head != LastHead . INSTANCE ) { return true ; } } return false ; }
public synchronized int lastIndexOf ( String subString , int start ) { return super . lastIndexOf ( subString , start ) ; }
public DeleteNetworkAclEntryResult deleteNetworkAclEntry ( DeleteNetworkAclEntryRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteNetworkAclEntry ( request ) ; }
public AssociateMemberToGroupResult associateMemberToGroup ( AssociateMemberToGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateMemberToGroup ( request ) ; }
public static final int committer ( byte [ ] b , int ptr ) { final int sz = b . length ; if ( ptr == 0 ) ptr += 46 ; while ( ptr < sz && b [ ptr ] == ' p ' ) ptr += 48 ; if ( ptr < sz && b [ ptr ] == ' a ' ) ptr = nextLF ( b , ptr ) ; return match ( b , ptr , committer ) ; }
public int getLineNumber ( ) { return row ; }
public SubmoduleUpdateCommand addPath ( String path ) { paths . add ( path ) ; return this ; }
public GetPushTemplateResult getPushTemplate ( GetPushTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeGetPushTemplate ( request ) ; }
public DescribeVaultResult describeVault ( DescribeVaultRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeVault ( request ) ; }
public DescribeVpcPeeringConnectionsResult describeVpcPeeringConnections ( ) { return describeVpcPeeringConnections ( new DescribeVpcPeeringConnectionsRequest ( ) ) ; }
public ByteBuffer putLong ( int index , long value ) { throw new ReadOnlyBufferException ( ) ; }
public RegisterDeviceResult registerDevice ( RegisterDeviceRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterDevice ( request ) ; }
public static Format byId ( int id ) { for ( Format format : Format . values ( ) ) { if ( format . getId ( ) == id ) { return format ; } } throw new IllegalArgumentException ( " Unknown ▁ format ▁ id : ▁ " + id ) ; }
public DeleteAppResult deleteApp ( DeleteAppRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApp ( request ) ; }
public GetBaiduChannelResult getBaiduChannel ( GetBaiduChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeGetBaiduChannel ( request ) ; }
public FST . BytesReader getBytesReader ( ) { return fst . getBytesReader ( ) ; }
public static boolean isValidSchemeChar ( int index , char c ) { if ( ( c >= ' a ' && c <= ' z ' ) || ( c >= ' A ' && c <= ' Z ' ) ) { return true ; } if ( index > 0 && ( ( c >= ' 0 ' && c <= ' 9 ' ) || c == ' + ' || c == ' - ' || c == ' . ' ) ) { return true ; } return false ; }
public ListAppliedSchemaArnsResult listAppliedSchemaArns ( ListAppliedSchemaArnsRequest request ) { request = beforeClientExecution ( request ) ; return executeListAppliedSchemaArns ( request ) ; }
public String name ( ) { return this . name ; }
public ValueEval evaluate ( ValueEval [ ] args , OperationEvaluationContext ec ) { if ( args . length < 1 ) { return ErrorEval . VALUE_INVALID ; } boolean isA1style ; String text ; try { ValueEval ve = OperandResolver . getSingleValue ( args [ 0 ] , ec . getRowIndex ( ) , ec . getColumnIndex ( ) ) ; text = OperandResolver . coerceValueToString ( ve ) ; switch ( args . length ) { case 1 : isA1style = true ; break ; case 2 : isA1style = evaluateBooleanArg ( args [ 1 ] , ec ) ; break ; default : return ErrorEval . VALUE_INVALID ; } } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } return evaluateIndirect ( ec , text , isA1style ) ; }
public final int compareTo ( int [ ] bs , int p ) { int cmp ; cmp = NB . compareUInt32 ( w1 , bs [ p ] ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w2 , bs [ p + 1 ] ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w3 , bs [ p + 2 ] ) ; if ( cmp != 0 ) return cmp ; cmp = NB . compareUInt32 ( w4 , bs [ p + 3 ] ) ; if ( cmp != 0 ) return cmp ; return NB . compareUInt32 ( w5 , bs [ p + 4 ] ) ; }
public void removeName ( int index ) { names . remove ( index ) ; workbook . removeName ( index ) ; }
public GetQueueAttributesRequest ( String queueUrl , java . util . List < String > attributeNames ) { setQueueUrl ( queueUrl ) ; setAttributeNames ( attributeNames ) ; }
public static boolean [ ] copyOf ( boolean [ ] original , int newLength ) { if ( newLength < 0 ) { throw new NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; }
public static void setEnabled ( boolean enabled ) { ENABLED = enabled ; }
public DeleteLogPatternResult deleteLogPattern ( DeleteLogPatternRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteLogPattern ( request ) ; }
public boolean contains ( char [ ] text , int off , int len ) { return map . containsKey ( text , off , len ) ; }
public int getFirstSheetIndexFromExternSheetIndex ( int externSheetNumber ) { return linkTable . getFirstInternalSheetIndexForExtIndex ( externSheetNumber ) ; }
public boolean handles ( String commandLine ) { return command . length ( ) + 1 < commandLine . length ( ) && commandLine . charAt ( command . length ( ) ) == ' ▁ ' && commandLine . startsWith ( command ) ; }
public static void register ( MergeStrategy imp ) { register ( imp . getName ( ) , imp ) ; }
public long ramBytesUsed ( ) { return BASE_RAM_BYTES_USED + ( ( index != null ) ? index . ramBytesUsed ( ) : 0 ) ; }
public HostedZone ( String id , String name , String callerReference ) { setId ( id ) ; setName ( name ) ; setCallerReference ( callerReference ) ; }
public GetFindingsResult getFindings ( GetFindingsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetFindings ( request ) ; }
public DescribeTopicsDetectionJobResult describeTopicsDetectionJob ( DescribeTopicsDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeTopicsDetectionJob ( request ) ; }
public boolean processMatch ( ValueEval eval ) { if ( eval instanceof NumericValueEval ) { if ( minimumValue == null ) { minimumValue = eval ; } else { double currentValue = ( ( NumericValueEval ) eval ) . getNumberValue ( ) ; double oldValue = ( ( NumericValueEval ) minimumValue ) . getNumberValue ( ) ; if ( currentValue < oldValue ) { minimumValue = eval ; } } } return true ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeShort ( field_1_len_ref_subexpression ) ; }
public static void main ( String [ ] args ) throws IOException { boolean printTree = false ; String path = null ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] . equals ( " - printTree " ) ) { printTree = true ; } else { path = args [ i ] ; } } if ( args . length != ( printTree ? 2 : 1 ) ) { System . out . println ( " \ nUsage : ▁ java ▁ - classpath ▁ ... ▁ org . apache . lucene . facet . util . PrintTaxonomyStats ▁ [ - printTree ] ▁ / path / to / taxononmy / index \ n " ) ; System . exit ( 1 ) ; } Directory dir = FSDirectory . open ( Paths . get ( path ) ) ; TaxonomyReader r = new DirectoryTaxonomyReader ( dir ) ; printStats ( r , System . out , printTree ) ; r . close ( ) ; dir . close ( ) ; }
public void setByteValue ( byte value ) { if ( ! ( fieldsData instanceof Byte ) ) { throw new IllegalArgumentException ( " cannot ▁ change ▁ value ▁ type ▁ from ▁ " + fieldsData . getClass ( ) . getSimpleName ( ) + " ▁ to ▁ Byte " ) ; } fieldsData = Byte . valueOf ( value ) ; }
public static int initialize ( ) { return initialize ( DEFAULT_SEED ) ; }
public CachingDoubleValueSource ( DoubleValuesSource source ) { this . source = source ; cache = new HashMap <> ( ) ; }
public AttributeDefinition ( String attributeName , ScalarAttributeType attributeType ) { setAttributeName ( attributeName ) ; setAttributeType ( attributeType . toString ( ) ) ; }
public static String join ( Collection < String > parts , String separator ) { return StringUtils . join ( parts , separator , separator ) ; }
public ListTaskDefinitionFamiliesResult listTaskDefinitionFamilies ( ListTaskDefinitionFamiliesRequest request ) { request = beforeClientExecution ( request ) ; return executeListTaskDefinitionFamilies ( request ) ; }
public ListComponentsResult listComponents ( ListComponentsRequest request ) { request = beforeClientExecution ( request ) ; return executeListComponents ( request ) ; }
public ActivatePhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ActivatePhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public CreateMatchmakingRuleSetResult createMatchmakingRuleSet ( CreateMatchmakingRuleSetRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateMatchmakingRuleSet ( request ) ; }
public ListAvailableManagementCidrRangesResult listAvailableManagementCidrRanges ( ListAvailableManagementCidrRangesRequest request ) { request = beforeClientExecution ( request ) ; return executeListAvailableManagementCidrRanges ( request ) ; }
public ObjectIdSubclassMap < ObjectId > getBaseObjectIds ( ) { if ( baseObjectIds != null ) return baseObjectIds ; return new ObjectIdSubclassMap <> ( ) ; }
public DeletePushTemplateResult deletePushTemplate ( DeletePushTemplateRequest request ) { request = beforeClientExecution ( request ) ; return executeDeletePushTemplate ( request ) ; }
public CreateDomainEntryResult createDomainEntry ( CreateDomainEntryRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDomainEntry ( request ) ; }
public static int getEncodedSize ( Object [ ] values ) { int result = values . length * 1 ; for ( Object value : values ) { result += getEncodedSize ( value ) ; } return result ; }
public OpenNLPTokenizerFactory ( Map < String , String > args ) { super ( args ) ; sentenceModelFile = require ( args , SENTENCE_MODEL ) ; tokenizerModelFile = require ( args , TOKENIZER_MODEL ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public final int getInt ( int index ) { checkIndex ( index , SizeOf . INT ) ; return Memory . peekInt ( backingArray , offset + index , order ) ; }
public List < Head > getNextHeads ( char c ) { if ( matches ( c ) ) { return newHeads ; } return FileNameMatcher . EMPTY_HEAD_LIST ; }
public ByteBuffer putShort ( short value ) { throw new ReadOnlyBufferException ( ) ; }
public void writeUnshared ( Object object ) throws IOException { writeObject ( object , true ) ; }
public int offsetByCodePoints ( int index , int codePointOffset ) { return Character . offsetByCodePoints ( value , 0 , count , index , codePointOffset ) ; }
public static int getUniqueAlt ( Collection < BitSet > altsets ) { BitSet all = getAlts ( altsets ) ; if ( all . cardinality ( ) == 1 ) return all . nextSetBit ( 0 ) ; return ATN . INVALID_ALT_NUMBER ; }
public Date getWhen ( ) { return new Date ( when ) ; }
public RuleTagToken ( String ruleName , int bypassTokenType , String label ) { if ( ruleName == null || ruleName . isEmpty ( ) ) { throw new IllegalArgumentException ( " ruleName ▁ cannot ▁ be ▁ null ▁ or ▁ empty . " ) ; } this . ruleName = ruleName ; this . bypassTokenType = bypassTokenType ; this . label = label ; }
public DisableOrganizationAdminAccountResult disableOrganizationAdminAccount ( DisableOrganizationAdminAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableOrganizationAdminAccount ( request ) ; }
public CreateRoomResult createRoom ( CreateRoomRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateRoom ( request ) ; }
public ReplicationGroup deleteReplicationGroup ( DeleteReplicationGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteReplicationGroup ( request ) ; }
public final CharBuffer decode ( ByteBuffer buffer ) { try { return newDecoder ( ) . onMalformedInput ( CodingErrorAction . REPLACE ) . onUnmappableCharacter ( CodingErrorAction . REPLACE ) . decode ( buffer ) ; } catch ( CharacterCodingException ex ) { throw new Error ( ex . getMessage ( ) , ex ) ; } }
public Distribution ( String id , String status , String domainName ) { setId ( id ) ; setStatus ( status ) ; setDomainName ( domainName ) ; }
public final double [ ] array ( ) { return protectedArray ( ) ; }
public DateWindow1904Record ( RecordInputStream in ) { field_1_window = in . readShort ( ) ; }
public DeleteDBSnapshotRequest ( String dBSnapshotIdentifier ) { setDBSnapshotIdentifier ( dBSnapshotIdentifier ) ; }
public final ParserExtension getExtension ( String key ) { return this . extensions . get ( key ) ; }
public void inform ( ResourceLoader loader ) { try { if ( chunkerModelFile != null ) { OpenNLPOpsFactory . getChunkerModel ( chunkerModelFile , loader ) ; } } catch ( IOException e ) { throw new IllegalArgumentException ( e ) ; } }
public CompleteVaultLockResult completeVaultLock ( CompleteVaultLockRequest request ) { request = beforeClientExecution ( request ) ; return executeCompleteVaultLock ( request ) ; }
public final int [ ] getCharIntervals ( ) { return points . clone ( ) ; }
public long ramBytesUsed ( ) { return values . ramBytesUsed ( ) + super . ramBytesUsed ( ) + Long . BYTES + RamUsageEstimator . NUM_BYTES_OBJECT_REF ; }
public RegisterInstancesWithLoadBalancerResult registerInstancesWithLoadBalancer ( RegisterInstancesWithLoadBalancerRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterInstancesWithLoadBalancer ( request ) ; }
public DescribeClusterUserKubeconfigRequest ( ) { super ( " CS " , " 2015 - 12 - 15 " , " DescribeClusterUserKubeconfig " , " csk " ) ; setUriPattern ( " / k8s / [ ClusterId ] / user □ config " ) ; setMethod ( MethodType . GET ) ; }
public PrecisionRecord ( RecordInputStream in ) { field_1_precision = in . readShort ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getLeftRowGutter ( ) ) ; out . writeShort ( getTopColGutter ( ) ) ; out . writeShort ( getRowLevelMax ( ) ) ; out . writeShort ( getColLevelMax ( ) ) ; }
public DeleteVirtualInterfaceResult deleteVirtualInterface ( DeleteVirtualInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVirtualInterface ( request ) ; }
public Entry getEntry ( String name ) throws FileNotFoundException { if ( excludes . contains ( name ) ) { throw new FileNotFoundException ( name ) ; } Entry entry = directory . getEntry ( name ) ; return wrapEntry ( entry ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ BACKUP ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . backup ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getBackup ( ) ) ) . append ( " \ n " ) ; buffer . append ( " [ / BACKUP ] \ n " ) ; return buffer . toString ( ) ; }
public DeleteVoiceConnectorOriginationResult deleteVoiceConnectorOrigination ( DeleteVoiceConnectorOriginationRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteVoiceConnectorOrigination ( request ) ; }
public Appendable append ( char c ) { write ( c ) ; return this ; }
public static long generationFromSegmentsFileName ( String fileName ) { if ( fileName . equals ( OLD_SEGMENTS_GEN ) ) { throw new IllegalArgumentException ( " \ " " + OLD_SEGMENTS_GEN + " \ " ▁ is ▁ not ▁ a ▁ valid ▁ segment ▁ file ▁ name ▁ since ▁ 4.0 " ) ; } else if ( fileName . equals ( IndexFileNames . SEGMENTS ) ) { return 0 ; } else if ( fileName . startsWith ( IndexFileNames . SEGMENTS ) ) { return Long . parseLong ( fileName . substring ( 1 + IndexFileNames . SEGMENTS . length ( ) ) , Character . MAX_RADIX ) ; } else { throw new IllegalArgumentException ( " fileName ▁ \ " " + fileName + " \ " ▁ is ▁ not ▁ a ▁ segments ▁ file " ) ; } }
public static TagOpt fromOption ( String o ) { if ( o == null || o . length ( ) == 0 ) return AUTO_FOLLOW ; for ( TagOpt tagopt : values ( ) ) { if ( tagopt . option ( ) . equals ( o ) ) return tagopt ; } throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . invalidTagOption , o ) ) ; }
public StartContentModerationResult startContentModeration ( StartContentModerationRequest request ) { request = beforeClientExecution ( request ) ; return executeStartContentModeration ( request ) ; }
public static String quoteReplacement ( String s ) { StringBuilder result = new StringBuilder ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == ' \\ ' ▁ || ▁ c ▁ == ▁ ' $ ' ) ▁ { result . append ( ' \\ ' ) ; } result . append ( c ) ; } return result . toString ( ) ; }
public final void set ( V newValue ) { value = newValue ; }
public QueryParserTokenManager ( CharStream stream ) { input_stream = stream ; }
public long valueFor ( double elapsed ) { double val ; if ( modBy == 0 ) val = elapsed / factor ; elseval = elapsed / factor % modBy ; if ( type == ' 0 ' ) return Math . round ( val ) ; else return ( long ) val ; }
public LongBuffer get ( long [ ] dst , int dstOffset , int longCount ) { byteBuffer . limit ( limit * SizeOf . LONG ) ; byteBuffer . position ( position * SizeOf . LONG ) ; if ( byteBuffer instanceof DirectByteBuffer ) { ( ( DirectByteBuffer ) byteBuffer ) . get ( dst , dstOffset , longCount ) ; } else { ( ( HeapByteBuffer ) byteBuffer ) . get ( dst , dstOffset , longCount ) ; } this . position += longCount ; return this ; }
public void removeErrorListeners ( ) { _listeners . clear ( ) ; }
public CommonTokenStream ( TokenSource tokenSource , int channel ) { this ( tokenSource ) ; this . channel = channel ; }
public ListObjectPoliciesResult listObjectPolicies ( ListObjectPoliciesRequest request ) { request = beforeClientExecution ( request ) ; return executeListObjectPolicies ( request ) ; }
public ObjectToPack ( AnyObjectId src , int type ) { super ( src ) ; flags = type << TYPE_SHIFT ; }
public int stem ( char s [ ] , int len ) { int numVowels = numVowels ( s , len ) ; for ( int i = 0 ; i < affixes . length ; i ++ ) { Affix affix = affixes [ i ] ; if ( numVowels > affix . vc && len >= affix . affix . length + 3 && endsWith ( s , len , affix . affix ) ) { len -= affix . affix . length ; return affix . palatalizes ? unpalatalize ( s , len ) : len ; } } return len ; }
public void recover ( Parser recognizer , RecognitionException e ) { if ( lastErrorIndex == recognizer . getInputStream ( ) . index ( ) && lastErrorStates != null && lastErrorStates . contains ( recognizer . getState ( ) ) ) { recognizer . consume ( ) ; } lastErrorIndex = recognizer . getInputStream ( ) . index ( ) ; if ( lastErrorStates == null ) lastErrorStates = new IntervalSet ( ) ; lastErrorStates . add ( recognizer . getState ( ) ) ; IntervalSet followSet = getErrorRecoverySet ( recognizer ) ; consumeUntil ( recognizer , followSet ) ; }
public String toFormulaString ( ) { String value = field_3_string ; int len = value . length ( ) ; StringBuilder sb = new StringBuilder ( len + 4 ) ; sb . append ( FORMULA_DELIMITER ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; if ( c == FORMULA_DELIMITER ) { sb . append ( FORMULA_DELIMITER ) ; } sb . append ( c ) ; } sb . append ( FORMULA_DELIMITER ) ; return sb . toString ( ) ; }
public UnlinkFaceRequest ( ) { super ( " LinkFace " , " 2018 - 07 - 20 " , " UnlinkFace " ) ; setProtocol ( ProtocolType . HTTPS ) ; setMethod ( MethodType . POST ) ; }
public ConfigurationOptionSetting ( String namespace , String optionName , String value ) { setNamespace ( namespace ) ; setOptionName ( optionName ) ; setValue ( value ) ; }
public CharSequence getFully ( CharSequence key ) { StringBuilder result = new StringBuilder ( tries . size ( ) * 2 ) ; for ( int i = 0 ; i < tries . size ( ) ; i ++ ) { CharSequence r = tries . get ( i ) . getFully ( key ) ; if ( r == null || ( r . length ( ) == 1 && r . charAt ( 0 ) == EOM ) ) { return result ; } result . append ( r ) ; } return result ; }
public DescribeMountTargetSecurityGroupsResult describeMountTargetSecurityGroups ( DescribeMountTargetSecurityGroupsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeMountTargetSecurityGroups ( request ) ; }
public GetApiMappingResult getApiMapping ( GetApiMappingRequest request ) { request = beforeClientExecution ( request ) ; return executeGetApiMapping ( request ) ; }
public HttpRequest ( String strUrl ) { super ( strUrl ) ; }
public MemFuncPtg ( int subExprLen ) { field_1_len_ref_subexpression = subExprLen ; }
public static TermStats [ ] getHighFreqTerms ( IndexReader reader , int numTerms , String field , Comparator < TermStats > comparator ) throws Exception { TermStatsQueue tiq = null ; if ( field != null ) { Terms terms = MultiTerms . getTerms ( reader , field ) ; if ( terms == null ) { throw new RuntimeException ( " field ▁ " + field + " ▁ not ▁ found " ) ; } TermsEnum termsEnum = terms . iterator ( ) ; tiq = new TermStatsQueue ( numTerms , comparator ) ; tiq . fill ( field , termsEnum ) ; } else { Collection < String > fields = FieldInfos . getIndexedFields ( reader ) ; if ( fields . size ( ) == 0 ) { throw new RuntimeException ( " no ▁ fields ▁ found ▁ for ▁ this ▁ index " ) ; } tiq = new TermStatsQueue ( numTerms , comparator ) ; for ( String fieldName : fields ) { Terms terms = MultiTerms . getTerms ( reader , fieldName ) ; if ( terms != null ) { tiq . fill ( fieldName , terms . iterator ( ) ) ; } } } TermStats [ ] result = new TermStats [ tiq . size ( ) ] ; int count = tiq . size ( ) - 1 ; while ( tiq . size ( ) != 0 ) { result [ count ] = tiq . pop ( ) ; count -- ; } return result ; }
public DeleteApnsVoipChannelResult deleteApnsVoipChannel ( DeleteApnsVoipChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApnsVoipChannel ( request ) ; }
public ListFacesResult listFaces ( ListFacesRequest request ) { request = beforeClientExecution ( request ) ; return executeListFaces ( request ) ; }
public ShapeFieldCacheDistanceValueSource ( SpatialContext ctx , ShapeFieldCacheProvider < Point > provider , Point from , double multiplier ) { this . ctx = ctx ; this . from = from ; this . provider = provider ; this . multiplier = multiplier ; }
public char get ( int index ) { checkIndex ( index ) ; return sequence . charAt ( index ) ; }
public UpdateConfigurationProfileResult updateConfigurationProfile ( UpdateConfigurationProfileRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateConfigurationProfile ( request ) ; }
public DescribeLifecycleHooksResult describeLifecycleHooks ( DescribeLifecycleHooksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLifecycleHooks ( request ) ; }
public DescribeHostReservationsResult describeHostReservations ( DescribeHostReservationsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeHostReservations ( request ) ; }
public static PredictionContext fromRuleContext ( ATN atn , RuleContext outerContext ) { if ( outerContext == null ) outerContext = RuleContext . EMPTY ; if ( outerContext . parent == null || outerContext == RuleContext . EMPTY ) { return PredictionContext . EMPTY ; } PredictionContext parent = EMPTY ; parent = PredictionContext . fromRuleContext ( atn , outerContext . parent ) ; ATNState state = atn . states . get ( outerContext . invokingState ) ; RuleTransition transition = ( RuleTransition ) state . transition ( 0 ) ; return SingletonPredictionContext . create ( parent , transition . followState . stateNumber ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SXVDEX ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbit1 ▁ = " ) . append ( HexDump . intToHex ( _grbit1 ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . grbit2 ▁ = " ) . append ( HexDump . byteToHex ( _grbit2 ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . citmShow ▁ = " ) . append ( HexDump . byteToHex ( _citmShow ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . isxdiSort ▁ = " ) . append ( HexDump . shortToHex ( _isxdiSort ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . isxdiShow ▁ = " ) . append ( HexDump . shortToHex ( _isxdiShow ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . subtotalName ▁ = " ) . append ( _subtotalName ) . append ( " \ n " ) ; buffer . append ( " [ / SXVDEX ] \ n " ) ; return buffer . toString ( ) ; }
public String toString ( ) { StringBuilder r = new StringBuilder ( ) ; r . append ( " BlameResult : ▁ " ) ; r . append ( getResultPath ( ) ) ; return r . toString ( ) ; }
public ListChangeSetsResult listChangeSets ( ListChangeSetsRequest request ) { request = beforeClientExecution ( request ) ; return executeListChangeSets ( request ) ; }
public boolean isAllowNonFastForwards ( ) { return allowNonFastForwards ; }
public FeatRecord ( ) { futureHeader = new FtrHeader ( ) ; futureHeader . setRecordType ( sid ) ; }
public ShortBuffer put ( short c ) { throw new ReadOnlyBufferException ( ) ; }
public void setQuery ( CharSequence query ) { this . query = query ; this . message = new MessageImpl ( QueryParserMessages . INVALID_SYNTAX_CANNOT_PARSE , query , " " ) ; }
public StashApplyCommand stashApply ( ) { return new StashApplyCommand ( repo ) ; }
public Set < String > nameSet ( ) { return Collections . unmodifiableSet ( dictionary . values ( ) ) ; }
public static int getEffectivePort ( String scheme , int specifiedPort ) { if ( specifiedPort != - 1 ) { return specifiedPort ; } if ( " http " . equalsIgnoreCase ( scheme ) ) { return 80 ; } else if ( " https " . equalsIgnoreCase ( scheme ) ) { return 443 ; } else { return - 1 ; } }
public ListAssessmentTemplatesResult listAssessmentTemplates ( ListAssessmentTemplatesRequest request ) { request = beforeClientExecution ( request ) ; return executeListAssessmentTemplates ( request ) ; }
public Cluster restoreFromClusterSnapshot ( RestoreFromClusterSnapshotRequest request ) { request = beforeClientExecution ( request ) ; return executeRestoreFromClusterSnapshot ( request ) ; }
public void addShape ( HSSFShape shape ) { shape . setPatriarch ( this . getPatriarch ( ) ) ; shape . setParent ( this ) ; shapes . add ( shape ) ; }
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; FacetEntry that = ( FacetEntry ) o ; if ( count != that . count ) return false ; if ( ! value . equals ( that . value ) ) return false ; return true ; }
public static final int prev ( byte [ ] b , int ptr , char chrA ) { if ( ptr == b . length ) -- ptr ; while ( ptr >= 0 ) { if ( b [ ptr -- ] == chrA ) return ptr ; } return ptr ; }
public final boolean isDeltaRepresentation ( ) { return deltaBase != null ; }
public Token emitEOF ( ) { int cpos = getCharPositionInLine ( ) ; int line = getLine ( ) ; Token eof = _factory . create ( _tokenFactorySourcePair , Token . EOF , null , Token . DEFAULT_CHANNEL , _input . index ( ) , _input . index ( ) - 1 , line , cpos ) ; emit ( eof ) ; return eof ; }
public UpdateUserRequest ( String userName ) { setUserName ( userName ) ; }
public RevFilter negate ( ) { return NotRevFilter . create ( this ) ; }
public void setTagger ( PersonIdent taggerIdent ) { tagger = taggerIdent ; }
public static BufferSize automatic ( ) { Runtime rt = Runtime . getRuntime ( ) ; final long max = rt . maxMemory ( ) ; final long total = rt . totalMemory ( ) ; final long free = rt . freeMemory ( ) ; final long totalAvailableBytes = max - total + free ; long sortBufferByteSize = free / 2 ; final long minBufferSizeBytes = MIN_BUFFER_SIZE_MB * MB ; if ( sortBufferByteSize < minBufferSizeBytes || totalAvailableBytes > 10 * minBufferSizeBytes ) { if ( totalAvailableBytes / 2 > minBufferSizeBytes ) { sortBufferByteSize = totalAvailableBytes / 2 ; } else { sortBufferByteSize = Math . max ( ABSOLUTE_MIN_SORT_BUFFER_SIZE , sortBufferByteSize ) ; } } return new BufferSize ( Math . min ( ( long ) Integer . MAX_VALUE , sortBufferByteSize ) ) ; }
public static int trimTrailingWhitespace ( byte [ ] raw , int start , int end ) { int ptr = end - 1 ; while ( start <= ptr && isWhitespace ( raw [ ptr ] ) ) ptr -- ; return ptr + 1 ; }
public TopMarginRecord ( RecordInputStream in ) { field_1_margin = in . readDouble ( ) ; }
public RetrieveEnvironmentInfoRequest ( EnvironmentInfoType infoType ) { setInfoType ( infoType . toString ( ) ) ; }
public CreatePlayerSessionsResult createPlayerSessions ( CreatePlayerSessionsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePlayerSessions ( request ) ; }
public CreateProxySessionResult createProxySession ( CreateProxySessionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateProxySession ( request ) ; }
public int getObjectType ( ) { return type ; }
public String getScheme ( ) { return scheme ; }
public void characters ( char [ ] ch , int start , int length ) { contents . append ( ch , start , length ) ; }
public FetchAlbumTagPhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " FetchAlbumTagPhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public DeleteMembersResult deleteMembers ( DeleteMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteMembers ( request ) ; }
public GetContactReachabilityStatusResult getContactReachabilityStatus ( GetContactReachabilityStatusRequest request ) { request = beforeClientExecution ( request ) ; return executeGetContactReachabilityStatus ( request ) ; }
@ Override public boolean remove ( Object o ) { return Impl . this . remove ( o ) != null ; }
public E last ( ) { return backingMap . lastKey ( ) ; }
public CreateStreamingDistributionResult createStreamingDistribution ( CreateStreamingDistributionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateStreamingDistribution ( request ) ; }
public boolean isAbsolute ( ) { return absolute ; }
public DisableAddOnResult disableAddOn ( DisableAddOnRequest request ) { request = beforeClientExecution ( request ) ; return executeDisableAddOn ( request ) ; }
public DescribeAliasResult describeAlias ( DescribeAliasRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeAlias ( request ) ; }
public void next ( int delta ) { while ( -- delta >= 0 ) { if ( currentSubtree != null ) ptr += currentSubtree . getEntrySpan ( ) ; elseptr ++ ; if ( eof ( ) ) break ; parseEntry ( ) ; } }
public RevFilter clone ( ) { return new Binary ( a . clone ( ) , b . clone ( ) ) ; }
public Reader create ( Reader input ) { return new PersianCharFilter ( input ) ; }
public String option ( ) { return option ; }
public String toString ( ) { final StringBuilder sb = new StringBuilder ( " [ " ) ; for ( Object item : this ) { if ( sb . length ( ) > 1 ) sb . append ( " , ▁ " ) ; if ( item instanceof char [ ] ) { sb . append ( ( char [ ] ) item ) ; } else { sb . append ( item ) ; } } return sb . append ( ' ] ' ) . toString ( ) ; }
public DescribeSignalingChannelResult describeSignalingChannel ( DescribeSignalingChannelRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSignalingChannel ( request ) ; }
public AttachStaticIpResult attachStaticIp ( AttachStaticIpRequest request ) { request = beforeClientExecution ( request ) ; return executeAttachStaticIp ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; CellReference crA = new CellReference ( _firstRowIndex , _firstColumnIndex , false , false ) ; CellReference crB = new CellReference ( _lastRowIndex , _lastColumnIndex , false , false ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( " ▁ [ " ) . append ( crA . formatAsString ( ) ) . append ( ' : ' ) . append ( crB . formatAsString ( ) ) . append ( " ] " ) ; return sb . toString ( ) ; }
public BloomFilteringPostingsFormat ( PostingsFormat delegatePostingsFormat , BloomFilterFactory bloomFilterFactory ) { super ( BLOOM_CODEC_NAME ) ; this . delegatePostingsFormat = delegatePostingsFormat ; this . bloomFilterFactory = bloomFilterFactory ; }
public ListTemplatesResult listTemplates ( ListTemplatesRequest request ) { request = beforeClientExecution ( request ) ; return executeListTemplates ( request ) ; }
public TimerThread ( long resolution , Counter counter ) { super ( THREAD_NAME ) ; this . resolution = resolution ; this . counter = counter ; this . setDaemon ( true ) ; }
public DrawingRecord ( ) { recordData = EMPTY_BYTE_ARRAY ; }
public ListDirectoriesResult listDirectories ( ListDirectoriesRequest request ) { request = beforeClientExecution ( request ) ; return executeListDirectories ( request ) ; }
public void decode ( byte [ ] blocks , int blocksOffset , int [ ] values , int valuesOffset , int iterations ) { for ( int j = 0 ; j < iterations ; ++ j ) { final byte block = blocks [ blocksOffset ++ ] ; values [ valuesOffset ++ ] = ( block >>> 7 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 6 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 5 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 4 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 3 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 2 ) & 1 ; values [ valuesOffset ++ ] = ( block >>> 1 ) & 1 ; values [ valuesOffset ++ ] = block & 1 ; } }
public GroupingSearch disableCaching ( ) { this . maxCacheRAMMB = null ; this . maxDocsToCache = null ; return this ; }
public static int idealByteArraySize ( int need ) { for ( int i = 4 ; i < 32 ; i ++ ) if ( need <= ( 1 << i ) - 12 ) return ( 1 << i ) - 12 ; return need ; }
public UpdateAssessmentTargetResult updateAssessmentTarget ( UpdateAssessmentTargetRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateAssessmentTarget ( request ) ; }
public ModifyVolumeResult modifyVolume ( ModifyVolumeRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyVolume ( request ) ; }
public Cell merge ( Cell m , Cell e ) { if ( m . cmd == e . cmd && m . ref == e . ref && m . skip == e . skip ) { Cell c = new Cell ( m ) ; c . cnt += e . cnt ; return c ; } else { return null ; } }
public ByteBuffer read ( int length , long position ) throws IOException { if ( position >= size ( ) ) { throw new IndexOutOfBoundsException ( " Position ▁ " + position + " ▁ past ▁ the ▁ end ▁ of ▁ the ▁ file " ) ; } ByteBuffer dst ; if ( writable ) { dst = channel . map ( FileChannel . MapMode . READ_WRITE , position , length ) ; buffersToClean . add ( dst ) ; } else { channel . position ( position ) ; dst = ByteBuffer . allocate ( length ) ; int worked = IOUtils . readFully ( channel , dst ) ; if ( worked == - 1 ) { throw new IndexOutOfBoundsException ( " Position ▁ " + position + " ▁ past ▁ the ▁ end ▁ of ▁ the ▁ file " ) ; } } dst . position ( 0 ) ; return dst ; }
public void respondActivityTaskCompleted ( RespondActivityTaskCompletedRequest request ) { request = beforeClientExecution ( request ) ; executeRespondActivityTaskCompleted ( request ) ; }
public synchronized final void incrementProgressBy ( int diff ) { setProgress ( mProgress + diff ) ; }
public MetadataDiff compareMetadata ( DirCacheEntry entry ) { if ( entry . isAssumeValid ( ) ) return MetadataDiff . EQUAL ; if ( entry . isUpdateNeeded ( ) ) return MetadataDiff . DIFFER_BY_METADATA ; if ( isModeDifferent ( entry . getRawMode ( ) ) ) return MetadataDiff . DIFFER_BY_METADATA ; int type = mode & FileMode . TYPE_MASK ; if ( type == FileMode . TYPE_TREE || type == FileMode . TYPE_GITLINK ) return MetadataDiff . EQUAL ; if ( ! entry . isSmudged ( ) && entry . getLength ( ) != ( int ) getEntryLength ( ) ) return MetadataDiff . DIFFER_BY_METADATA ; Instant cacheLastModified = entry . getLastModifiedInstant ( ) ; Instant fileLastModified = getEntryLastModifiedInstant ( ) ; if ( timestampComparator . compare ( cacheLastModified , fileLastModified , getOptions ( ) . getCheckStat ( ) == CheckStat . MINIMAL ) != 0 ) { return MetadataDiff . DIFFER_BY_TIMESTAMP ; } if ( entry . isSmudged ( ) ) { return MetadataDiff . SMUDGED ; } return MetadataDiff . EQUAL ; }
public static NumberRecord convertToNumberRecord ( RKRecord rk ) { NumberRecord num = new NumberRecord ( ) ; num . setColumn ( rk . getColumn ( ) ) ; num . setRow ( rk . getRow ( ) ) ; num . setXFIndex ( rk . getXFIndex ( ) ) ; num . setValue ( rk . getRKNumber ( ) ) ; return num ; }
public CharBuffer put ( char [ ] src , int srcOffset , int charCount ) { byteBuffer . limit ( limit * SizeOf . CHAR ) ; byteBuffer . position ( position * SizeOf . CHAR ) ; if ( byteBuffer instanceof ReadWriteDirectByteBuffer ) { ( ( ReadWriteDirectByteBuffer ) byteBuffer ) . put ( src , srcOffset , charCount ) ; } else { ( ( ReadWriteHeapByteBuffer ) byteBuffer ) . put ( src , srcOffset , charCount ) ; } this . position += charCount ; return this ; }
public int getCells ( ) { Iterator < Character > i = cells . keySet ( ) . iterator ( ) ; int size = 0 ; for ( ; i . hasNext ( ) ; ) { Character c = i . next ( ) ; Cell e = at ( c ) ; if ( e . cmd >= 0 || e . ref >= 0 ) { size ++ ; } } return size ; }
public BeiderMorseFilterFactory ( Map < String , String > args ) { super ( args ) ; NameType nameType = NameType . valueOf ( get ( args , " nameType " , NameType . GENERIC . toString ( ) ) ) ; RuleType ruleType = RuleType . valueOf ( get ( args , " ruleType " , RuleType . APPROX . toString ( ) ) ) ; boolean concat = getBoolean ( args , " concat " , true ) ; engine = new PhoneticEngine ( nameType , ruleType , concat ) ; Set < String > langs = getSet ( args , " languageSet " ) ; languageSet = ( null == langs || ( 1 == langs . size ( ) && langs . contains ( " auto " ) ) ) ? null : LanguageSet . from ( langs ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static double varp ( double [ ] v ) { double r = Double . NaN ; if ( v != null && v . length > 1 ) { r = devsq ( v ) / v . length ; } return r ; }
public PersianNormalizationFilterFactory ( Map < String , String > args ) { super ( args ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( " Unknown ▁ parameters : ▁ " + args ) ; } }
public static WeightedTerm [ ] getTerms ( Query query , boolean prohibited , String fieldName ) { HashSet < WeightedTerm > terms = new HashSet <> ( ) ; Predicate < String > fieldSelector = fieldName == null ? f -> true : fieldName :: equals ; query . visit ( new BoostedTermExtractor ( 1 , terms , prohibited , fieldSelector ) ) ; return terms . toArray ( new WeightedTerm [ 0 ] ) ; }
public DeleteDocumentationPartResult deleteDocumentationPart ( DeleteDocumentationPartRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDocumentationPart ( request ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ CHART ] \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ . x ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getX ( ) ) . append ( ' \ n ' ) ; sb . append ( " ▁ ▁ ▁ ▁ . y ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getY ( ) ) . append ( ' \ n ' ) ; sb . append ( " ▁ ▁ ▁ ▁ . width ▁ = ▁ " ) . append ( getWidth ( ) ) . append ( ' \ n ' ) ; sb . append ( " ▁ ▁ ▁ ▁ . height = ▁ " ) . append ( getHeight ( ) ) . append ( ' \ n ' ) ; sb . append ( " [ / CHART ] \ n " ) ; return sb . toString ( ) ; }
public final short get ( int index ) { checkIndex ( index ) ; return backingArray [ offset + index ] ; }
public String toString ( ) { return image ; }
public ValueEval evaluate ( int srcRowIndex , int srcColumnIndex , ValueEval arg0 , ValueEval arg1 ) { try { AreaEval reA = evaluateRef ( arg0 ) ; AreaEval reB = evaluateRef ( arg1 ) ; AreaEval result = resolveRange ( reA , reB ) ; if ( result == null ) { return ErrorEval . NULL_INTERSECTION ; } return result ; } catch ( EvaluationException e ) { return e . getErrorEval ( ) ; } }
public void clear ( ) { weightBySpanQuery . clear ( ) ; }
public int findEndOffset ( StringBuilder buffer , int start ) { if ( start > buffer . length ( ) || start < 0 ) return start ; bi . setText ( buffer . substring ( start ) ) ; return bi . next ( ) + start ; }
final public SrndQuery PrimaryQuery ( ) throws ParseException { SrndQuery q ; switch ( ( jj_ntk ==- 1 ) ? jj_ntk ( ) : jj_ntk ) { case LPAREN : jj_consume_token ( LPAREN ) ; q = FieldsQuery ( ) ; jj_consume_token ( RPAREN ) ; break ; case OR : case AND : case W : case N : q = PrefixOperatorQuery ( ) ; break ; case TRUNCQUOTED : case QUOTED : case SUFFIXTERM : case TRUNCTERM : case TERM : q = SimpleTerm ( ) ; break ; default : jj_la1 [ 5 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } OptionalWeights ( q ) ; { if ( true ) return q ; } throw new Error ( " Missing ▁ return ▁ statement ▁ in ▁ function " ) ; }
public DeleteApiKeyResult deleteApiKey ( DeleteApiKeyRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApiKey ( request ) ; }
public InsertTagsRequest ( ) { super ( " Ots " , " 2016 - 06 - 20 " , " InsertTags " , " ots " ) ; setMethod ( MethodType . POST ) ; }
public DeleteUserByPrincipalIdResult deleteUserByPrincipalId ( DeleteUserByPrincipalIdRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteUserByPrincipalId ( request ) ; }
public DescribeNetworkInterfacesResult describeNetworkInterfaces ( DescribeNetworkInterfacesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeNetworkInterfaces ( request ) ; }
public int serialize ( int offset , byte [ ] data , EscherSerializationListener listener ) { listener . beforeRecordSerialize ( offset , getRecordId ( ) , this ) ; LittleEndian . putShort ( data , offset , getOptions ( ) ) ; LittleEndian . putShort ( data , offset + 2 , getRecordId ( ) ) ; LittleEndian . putInt ( data , offset + 4 , 8 ) ; LittleEndian . putInt ( data , offset + 8 , field_1_numShapes ) ; LittleEndian . putInt ( data , offset + 12 , field_2_lastMSOSPID ) ; listener . afterRecordSerialize ( offset + 16 , getRecordId ( ) , getRecordSize ( ) , this ) ; return getRecordSize ( ) ; }
public CreateSecurityConfigurationResult createSecurityConfiguration ( CreateSecurityConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSecurityConfiguration ( request ) ; }
public DescribeClientVpnConnectionsResult describeClientVpnConnections ( DescribeClientVpnConnectionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeClientVpnConnections ( request ) ; }
public static void fill ( double [ ] array , double value ) { for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = value ; } }
public boolean hasNext ( ) { return nextId < cells . length ; }
public PostingsEnum reset ( int [ ] postings ) { this . postings = postings ; upto = - 2 ; freq = 0 ; return this ; }
public final boolean hasAll ( RevFlagSet set ) { return ( flags & set . mask ) == set . mask ; }
public ModifyAccountResult modifyAccount ( ModifyAccountRequest request ) { request = beforeClientExecution ( request ) ; return executeModifyAccount ( request ) ; }
public Token LT ( int k ) { lazyInit ( ) ; if ( k == 0 ) return null ; if ( k < 0 ) return LB ( - k ) ; int i = p + k - 1 ; sync ( i ) ; if ( i >= tokens . size ( ) ) { return tokens . get ( tokens . size ( ) - 1 ) ; } return tokens . get ( i ) ; }
public void removeSheet ( int sheetIndex ) { if ( boundsheets . size ( ) > sheetIndex ) { records . remove ( records . getBspos ( ) - ( boundsheets . size ( ) - 1 ) + sheetIndex ) ; boundsheets . remove ( sheetIndex ) ; fixTabIdRecord ( ) ; } int sheetNum1Based = sheetIndex + 1 ; for ( int i = 0 ; i < getNumNames ( ) ; i ++ ) { NameRecord nr = getNameRecord ( i ) ; if ( nr . getSheetNumber ( ) == sheetNum1Based ) { nr . setSheetNumber ( 0 ) ; } else if ( nr . getSheetNumber ( ) > sheetNum1Based ) { nr . setSheetNumber ( nr . getSheetNumber ( ) - 1 ) ; } } if ( linkTable != null ) { linkTable . removeSheet ( sheetIndex ) ; } }
public void removeName ( String name ) { int index = getNameIndex ( name ) ; removeName ( index ) ; }
public boolean equals ( final Object o ) { if ( ! ( o instanceof Property ) ) { return false ; } final Property p = ( Property ) o ; final Object pValue = p . getValue ( ) ; final long pId = p . getID ( ) ; if ( id != pId || ( id != 0 && ! typesAreEqual ( type , p . getType ( ) ) ) ) { return false ; } if ( value == null && pValue == null ) { return true ; } if ( value == null || pValue == null ) { return false ; } final Class <?> valueClass = value . getClass ( ) ; final Class <?> pValueClass = pValue . getClass ( ) ; if ( ! ( valueClass . isAssignableFrom ( pValueClass ) ) &&! ( pValueClass . isAssignableFrom ( valueClass ) ) ) { return false ; } if ( value instanceof byte [ ] ) { byte [ ] thisVal = ( byte [ ] ) value , otherVal = ( byte [ ] ) pValue ; int len = unpaddedLength ( thisVal ) ; if ( len != unpaddedLength ( otherVal ) ) { return false ; } for ( int i = 0 ; i < len ; i ++ ) { if ( thisVal [ i ] != otherVal [ i ] ) { return false ; } } return true ; } return value . equals ( pValue ) ; }
public GetRepoBuildListRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " GetRepoBuildList " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / build " ) ; setMethod ( MethodType . GET ) ; }
public MessageWriter ( ) { buf = new ByteArrayOutputStream ( ) ; enc = new OutputStreamWriter ( getRawStream ( ) , UTF_8 ) ; }
public void append ( RecordBase r ) { _recs . add ( r ) ; }
public void close ( ) throws IOException { if ( read ( skipBuffer ) != - 1 || actualSize != expectedSize ) { throw new CorruptObjectException ( MessageFormat . format ( JGitText . get ( ) . packfileCorruptionDetected , JGitText . get ( ) . wrongDecompressedLength ) ) ; } int used = bAvail - inf . getRemaining ( ) ; if ( 0 < used ) { onObjectData ( src , buf , p , used ) ; use ( used ) ; } inf . reset ( ) ; }
public DescribeModelPackageResult describeModelPackage ( DescribeModelPackageRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeModelPackage ( request ) ; }
public void construct ( CellValueRecordInterface rec , RecordStream rs , SharedValueManager sfh ) { if ( rec instanceof FormulaRecord ) { FormulaRecord formulaRec = ( FormulaRecord ) rec ; StringRecord cachedText ; Class <? extends Record > nextClass = rs . peekNextClass ( ) ; if ( nextClass == StringRecord . class ) { cachedText = ( StringRecord ) rs . getNext ( ) ; } else { cachedText = null ; } insertCell ( new FormulaRecordAggregate ( formulaRec , cachedText , sfh ) ) ; } else { insertCell ( rec ) ; } }
public Decompressor clone ( ) { return new DeflateDecompressor ( ) ; }
public UpdateS3ResourcesResult updateS3Resources ( UpdateS3ResourcesRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateS3Resources ( request ) ; }
public GroupQueryNode ( QueryNode query ) { if ( query == null ) { throw new QueryNodeError ( new MessageImpl ( QueryParserMessages . PARAMETER_VALUE_NOT_SUPPORTED , " query " , " null " ) ) ; } allocate ( ) ; setLeaf ( false ) ; add ( query ) ; }
public CharSequence toQueryString ( EscapeQuerySyntax escaper ) { StringBuilder path = new StringBuilder ( ) ; path . append ( " / " ) . append ( getFirstPathElement ( ) ) ; for ( QueryText pathelement : getPathElements ( 1 ) ) { CharSequence value = escaper . escape ( pathelement . value , Locale . getDefault ( ) , Type . STRING ) ; path . append ( " /\ " " ) . append ( value ) . append ( " \ " " ) ; } return path . toString ( ) ; }
public void removeCellComment ( ) { HSSFComment comment = _sheet . findCellComment ( _record . getRow ( ) , _record . getColumn ( ) ) ; _comment = null ; if ( null == comment ) { return ; } _sheet . getDrawingPatriarch ( ) . removeShape ( comment ) ; }
public void reset ( ) { arriving = - 1 ; leaving = - 1 ; }
public ActivateUserResult activateUser ( ActivateUserRequest request ) { request = beforeClientExecution ( request ) ; return executeActivateUser ( request ) ; }
public boolean isCharsetDetected ( ) { throw new UnsupportedOperationException ( ) ; }
public Cluster modifySnapshotCopyRetentionPeriod ( ModifySnapshotCopyRetentionPeriodRequest request ) { request = beforeClientExecution ( request ) ; return executeModifySnapshotCopyRetentionPeriod ( request ) ; }
public DeleteClusterSubnetGroupResult deleteClusterSubnetGroup ( DeleteClusterSubnetGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteClusterSubnetGroup ( request ) ; }
public static String decode ( byte [ ] buffer ) { return decode ( buffer , 0 , buffer . length ) ; }
public int getDefaultPort ( ) { return - 1 ; }
public StopTaskResult stopTask ( StopTaskRequest request ) { request = beforeClientExecution ( request ) ; return executeStopTask ( request ) ; }
public void seekExact ( BytesRef target , TermState otherState ) { assert otherState != null && otherState instanceof BlockTermState ; assert ! doOrd || ( ( BlockTermState ) otherState ) . ord < numTerms ; state . copyFrom ( otherState ) ; seekPending = true ; indexIsCurrent = false ; term . copyBytes ( target ) ; }
public SeriesToChartGroupRecord ( RecordInputStream in ) { field_1_chartGroupIndex = in . readShort ( ) ; }
public static void writeUnicodeStringFlagAndData ( LittleEndianOutput out , String value ) { boolean is16Bit = hasMultibyte ( value ) ; out . writeByte ( is16Bit ? 0x01 : 0x00 ) ; if ( is16Bit ) { putUnicodeLE ( value , out ) ; } else { putCompressedUnicode ( value , out ) ; } }
public AuthorizeSecurityGroupIngressResult authorizeSecurityGroupIngress ( AuthorizeSecurityGroupIngressRequest request ) { request = beforeClientExecution ( request ) ; return executeAuthorizeSecurityGroupIngress ( request ) ; }
public void addFile ( String file ) { checkFileNames ( Collections . singleton ( file ) ) ; setFiles . add ( namedForThisSegment ( file ) ) ; }
public void setSize ( int width , int height ) { mWidth = width ; mHeight = height ; }
public final void setPrecedenceFilterSuppressed ( boolean value ) { if ( value ) { this . reachesIntoOuterContext |= 0x40000000 ; } else { this . reachesIntoOuterContext &= ~ SUPPRESS_PRECEDENCE_FILTER ; } }
public IntervalSet LOOK ( ATNState s , RuleContext ctx ) { return LOOK ( s , null , ctx ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( getOptionFlags ( ) ) ; out . writeShort ( getRowHeight ( ) ) ; }
public Builder ( boolean dedup ) { this . dedup = dedup ; }
public Hashtable ( int capacity , float loadFactor ) { this ( capacity ) ; if ( loadFactor <= 0 || Float . isNaN ( loadFactor ) ) { throw new IllegalArgumentException ( " Load ▁ factor : ▁ " + loadFactor ) ; } }
public Object get ( CharSequence key ) { final int bucket = normalCompletion . getBucket ( key ) ; return bucket == - 1 ? null : Long . valueOf ( bucket ) ; }
public ListHyperParameterTuningJobsResult listHyperParameterTuningJobs ( ListHyperParameterTuningJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListHyperParameterTuningJobs ( request ) ; }
public DeleteTableResult deleteTable ( String tableName ) { return deleteTable ( new DeleteTableRequest ( ) . withTableName ( tableName ) ) ; }
public final boolean lessThan ( TextFragment fragA , TextFragment fragB ) { if ( fragA . getScore ( ) == fragB . getScore ( ) ) return fragA . fragNum > fragB . fragNum ; else return fragA . getScore ( ) < fragB . getScore ( ) ; }
public void freeBefore ( int pos ) { assert pos >= 0 ; assert pos <= nextPos ; final int newCount = nextPos - pos ; assert newCount <= count : " newCount = " + newCount + " ▁ count = " + count ; assert newCount <= buffer . length : " newCount = " + newCount + " ▁ buf . length = " + buffer . length ; count = newCount ; }
public UpdateHITTypeOfHITResult updateHITTypeOfHIT ( UpdateHITTypeOfHITRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateHITTypeOfHIT ( request ) ; }
public UpdateRecommenderConfigurationResult updateRecommenderConfiguration ( UpdateRecommenderConfigurationRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateRecommenderConfiguration ( request ) ; }
public int compareTo ( BytesRef other ) { return Arrays . compareUnsigned ( this . bytes , this . offset , this . offset + this . length , other . bytes , other . offset , other . offset + other . length ) ; }
public int stem ( char s [ ] , int len ) { if ( len > 4 && s [ len - 1 ] == ' s ' ) len -- ; if ( len > 5 && ( endsWith ( s , len , " ene " ) || ( endsWith ( s , len , " ane " ) && useNynorsk ) ) ) return len - 3 ; if ( len > 4 && ( endsWith ( s , len , " er " ) || endsWith ( s , len , " en " ) || endsWith ( s , len , " et " ) || ( endsWith ( s , len , " ar " ) && useNynorsk ) ) ) return len - 2 ; if ( len > 3 ) switch ( s [ len - 1 ] ) { case ' a ' : case ' e ' : return len - 1 ; } return len ; }
public DescribeDBSnapshotsResult describeDBSnapshots ( DescribeDBSnapshotsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeDBSnapshots ( request ) ; }
public SortedSetDocValuesFacetField ( String dim , String label ) { super ( " dummy " , TYPE ) ; FacetField . verifyLabel ( label ) ; FacetField . verifyLabel ( dim ) ; this . dim = dim ; this . label = label ; }
public CreateDocumentationPartResult createDocumentationPart ( CreateDocumentationPartRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDocumentationPart ( request ) ; }
public String getValue ( ) { return value ; }
public ShortBuffer asReadOnlyBuffer ( ) { return duplicate ( ) ; }
public UpdateDataSourcePermissionsResult updateDataSourcePermissions ( UpdateDataSourcePermissionsRequest request ) { request = beforeClientExecution ( request ) ; return executeUpdateDataSourcePermissions ( request ) ; }
public static org . apache . poi . hssf . record . Record createSingleRecord ( RecordInputStream in ) { I_RecordCreator constructor = _recordCreatorsById . get ( Integer . valueOf ( in . getSid ( ) ) ) ; if ( constructor == null ) { return new UnknownRecord ( in ) ; } return constructor . create ( in ) ; }
public int getCount ( ) { return mTabs . size ( ) ; }
public DeleteApplicationReferenceDataSourceResult deleteApplicationReferenceDataSource ( DeleteApplicationReferenceDataSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteApplicationReferenceDataSource ( request ) ; }
public CreateProjectVersionResult createProjectVersion ( CreateProjectVersionRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateProjectVersion ( request ) ; }
public IntBuffer slice ( ) { return new ReadOnlyIntArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public final byte get ( ) { if ( position == limit ) { throw new BufferUnderflowException ( ) ; } return this . block . peekByte ( offset + position ++ ) ; }
public LongBuffer put ( int index , long c ) { checkIndex ( index ) ; backingArray [ offset + index ] = c ; return this ; }
public StoredField ( String name , float value ) { super ( name , TYPE ) ; fieldsData = value ; }
public IntervalSet getExpectedTokensWithinCurrentRule ( ) { ATN atn = getInterpreter ( ) . atn ; ATNState s = atn . states . get ( getState ( ) ) ; return atn . nextTokens ( s ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ FILESHARING ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . readonly ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getReadOnly ( ) == 1 ? " true " : " false " ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . password ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( Integer . toHexString ( getPassword ( ) ) ) . append ( " \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . username ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getUsername ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / FILESHARING ] \ n " ) ; return buffer . toString ( ) ; }
public SubmoduleInitCommand ( Repository repo ) { super ( repo ) ; paths = new ArrayList <> ( ) ; }
public void include ( String name , AnyObjectId id ) { boolean validRefName = Repository . isValidRefName ( name ) || Constants . HEAD . equals ( name ) ; if ( ! validRefName ) throw new IllegalArgumentException ( MessageFormat . format ( JGitText . get ( ) . invalidRefName , name ) ) ; if ( include . containsKey ( name ) ) throw new IllegalStateException ( JGitText . get ( ) . duplicateRef + name ) ; include . put ( name , id . toObjectId ( ) ) ; }
public Cluster enableSnapshotCopy ( EnableSnapshotCopyRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableSnapshotCopy ( request ) ; }
public ValueFiller getValueFiller ( ) { return new ValueFiller ( ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeByte ( getPane ( ) ) ; out . writeShort ( getActiveCellRow ( ) ) ; out . writeShort ( getActiveCellCol ( ) ) ; out . writeShort ( getActiveCellRef ( ) ) ; int nRefs = field_6_refs . length ; out . writeShort ( nRefs ) ; for ( CellRangeAddress8Bit field_6_ref : field_6_refs ) { field_6_ref . serialize ( out ) ; } }
public static Counter newCounter ( ) { return newCounter ( false ) ; }
public boolean get ( String name , boolean dflt ) { boolean vals [ ] = ( boolean [ ] ) valByRound . get ( name ) ; if ( vals != null ) { return vals [ roundNumber % vals . length ] ; } String sval = props . getProperty ( name , " " + dflt ) ; if ( sval . indexOf ( " : " ) < 0 ) { return Boolean . valueOf ( sval ) . booleanValue ( ) ; } int k = sval . indexOf ( " : " ) ; String colName = sval . substring ( 0 , k ) ; sval = sval . substring ( k + 1 ) ; colForValByRound . put ( name , colName ) ; vals = propToBooleanArray ( sval ) ; valByRound . put ( name , vals ) ; return vals [ roundNumber % vals . length ] ; }
public void preSerialize ( ) { if ( records . getTabpos ( ) > 0 ) { TabIdRecord tir = ( TabIdRecord ) records . get ( records . getTabpos ( ) ) ; if ( tir . _tabids . length < boundsheets . size ( ) ) { fixTabIdRecord ( ) ; } } }
public LimitTokenCountAnalyzer ( Analyzer delegate , int maxTokenCount , boolean consumeAllTokens ) { super ( delegate . getReuseStrategy ( ) ) ; this . delegate = delegate ; this . maxTokenCount = maxTokenCount ; this . consumeAllTokens = consumeAllTokens ; }
public ExternalBookBlock ( int numberOfSheets ) { _externalBookRecord = SupBookRecord . createInternalReferences ( ( short ) numberOfSheets ) ; _externalNameRecords = new ExternalNameRecord [ 0 ] ; _crnBlocks = new CRNBlock [ 0 ] ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SCENARIOPROTECT ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . protect ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( getProtect ( ) ) . append ( " \ n " ) ; buffer . append ( " [ / SCENARIOPROTECT ] \ n " ) ; return buffer . toString ( ) ; }
public PushCommand setThin ( boolean thin ) { checkCallable ( ) ; this . thin = thin ; return this ; }
public int compareTo ( SearcherTracker other ) { return Double . compare ( other . recordTimeSec , recordTimeSec ) ; }
public ReverseStringFilter create ( TokenStream in ) { return new ReverseStringFilter ( in ) ; }
public BlockList ( ) { directory = BlockList . < T > newDirectory ( 256 ) ; directory [ 0 ] = BlockList . < T > newBlock ( ) ; tailBlock = directory [ 0 ] ; }
public QueryScorer ( WeightedSpanTerm [ ] weightedTerms ) { this . fieldWeightedSpanTerms = new HashMap <> ( weightedTerms . length ) ; for ( int i = 0 ; i < weightedTerms . length ; i ++ ) { WeightedSpanTerm existingTerm = fieldWeightedSpanTerms . get ( weightedTerms [ i ] . term ) ; if ( ( existingTerm == null ) || ( existingTerm . weight < weightedTerms [ i ] . weight ) ) { fieldWeightedSpanTerms . put ( weightedTerms [ i ] . term , weightedTerms [ i ] ) ; maxTermWeight = Math . max ( maxTermWeight , weightedTerms [ i ] . getWeight ( ) ) ; } } skipInitExtractor = true ; }
public boolean equals ( Object _other ) { assert neverEquals ( _other ) ; if ( _other instanceof MergedGroup ) { MergedGroup <?> other = ( MergedGroup <?> ) _other ; if ( groupValue == null ) { return other == null ; } else { return groupValue . equals ( other ) ; } } else { return false ; } }
public final Charset charset ( ) { return cs ; }
public DescribeExperimentResult describeExperiment ( DescribeExperimentRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeExperiment ( request ) ; }
public EscherGraphics ( HSSFShapeGroup escherGroup , HSSFWorkbook workbook , Color forecolor , float verticalPointsPerPixel ) { this . escherGroup = escherGroup ; this . workbook = workbook ; this . verticalPointsPerPixel = verticalPointsPerPixel ; this . verticalPixelsPerPoint = 1 / verticalPointsPerPixel ; this . font = new Font ( " Arial " , 0 , 10 ) ; this . foreground = forecolor ; }
public String pattern ( ) { return patternText ; }
public DeleteRouteTableResult deleteRouteTable ( DeleteRouteTableRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRouteTable ( request ) ; }
public AssociateVPCWithHostedZoneResult associateVPCWithHostedZone ( AssociateVPCWithHostedZoneRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateVPCWithHostedZone ( request ) ; }
public PutIntegrationResult putIntegration ( PutIntegrationRequest request ) { request = beforeClientExecution ( request ) ; return executePutIntegration ( request ) ; }
public SimpleEntry ( K theKey , V theValue ) { key = theKey ; value = theValue ; }
public void decode ( byte [ ] blocks , int blocksOffset , long [ ] values , int valuesOffset , int iterations ) { for ( int i = 0 ; i < iterations ; ++ i ) { final long byte0 = blocks [ blocksOffset ++ ] & 0xFF ; final long byte1 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( byte0 << 4 ) | ( byte1 >>> 4 ) ; final long byte2 = blocks [ blocksOffset ++ ] & 0xFF ; values [ valuesOffset ++ ] = ( ( byte1 & 15 ) << 8 ) | byte2 ; } }
public DisassociateConnectionFromLagResult disassociateConnectionFromLag ( DisassociateConnectionFromLagRequest request ) { request = beforeClientExecution ( request ) ; return executeDisassociateConnectionFromLag ( request ) ; }
public FileMode getOldMode ( ) { return oldMode ; }
@ Override public String toString ( ) { return m . toString ( ) ; }
public StopKeyPhrasesDetectionJobResult stopKeyPhrasesDetectionJob ( StopKeyPhrasesDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopKeyPhrasesDetectionJob ( request ) ; }
public String toString ( ) { return " [ Array ▁ Formula ▁ or ▁ Shared ▁ Formula ] \ n " + " row ▁ = ▁ " + getRow ( ) + " \ n " + " col ▁ = ▁ " + getColumn ( ) + " \ n " ; }
public ListDominantLanguageDetectionJobsResult listDominantLanguageDetectionJobs ( ListDominantLanguageDetectionJobsRequest request ) { request = beforeClientExecution ( request ) ; return executeListDominantLanguageDetectionJobs ( request ) ; }
public String toString ( ) { return " slice ▁ start = " + start + " ▁ length = " + length + " ▁ readerIndex = " + readerIndex ; }
public static final int parseHexInt4 ( final byte digit ) { final byte r = digits16 [ digit ] ; if ( r < 0 ) throw new ArrayIndexOutOfBoundsException ( ) ; return r ; }
public Attribute ( String name , String value ) { setName ( name ) ; setValue ( value ) ; }
public DescribeStackSetOperationResult describeStackSetOperation ( DescribeStackSetOperationRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeStackSetOperation ( request ) ; }
public HSSFCell getCell ( int cellnum ) { return getCell ( cellnum , book . getMissingCellPolicy ( ) ) ; }
public void write ( byte [ ] b ) { writeContinueIfRequired ( b . length ) ; _ulrOutput . write ( b ) ; }
public ResetImageAttributeRequest ( String imageId , ResetImageAttributeName attribute ) { setImageId ( imageId ) ; setAttribute ( attribute . toString ( ) ) ; }
public void discardResultContents ( ) { resultContents = null ; }
public ObjectId getPeeledObjectId ( ) { return getLeaf ( ) . getPeeledObjectId ( ) ; }
public void undeprecateDomain ( UndeprecateDomainRequest request ) { request = beforeClientExecution ( request ) ; executeUndeprecateDomain ( request ) ; }
public void write ( LittleEndianOutput out ) { out . writeByte ( sid + getPtgClass ( ) ) ; out . writeByte ( field_3_string . length ( ) ) ; out . writeByte ( _is16bitUnicode ? 0x01 : 0x00 ) ; if ( _is16bitUnicode ) { StringUtil . putUnicodeLE ( field_3_string , out ) ; } else { StringUtil . putCompressedUnicode ( field_3_string , out ) ; } }
public DeleteQueueResult deleteQueue ( String queueUrl ) { return deleteQueue ( new DeleteQueueRequest ( ) . withQueueUrl ( queueUrl ) ) ; }
public void setCheckEofAfterPackFooter ( boolean b ) { checkEofAfterPackFooter = b ; }
public void swap ( ) { final int sBegin = beginA ; final int sEnd = endA ; beginA = beginB ; endA = endB ; beginB = sBegin ; endB = sEnd ; }
public int getPackedGitWindowSize ( ) { return packedGitWindowSize ; }
public PutMetricDataResult putMetricData ( PutMetricDataRequest request ) { request = beforeClientExecution ( request ) ; return executePutMetricData ( request ) ; }
public GetCelebrityRecognitionResult getCelebrityRecognition ( GetCelebrityRecognitionRequest request ) { request = beforeClientExecution ( request ) ; return executeGetCelebrityRecognition ( request ) ; }
public CreateQueueRequest ( String queueName ) { setQueueName ( queueName ) ; }
public Area3DPxg ( int externalWorkbookNumber , SheetIdentifier sheetName , AreaReference arearef ) { super ( arearef ) ; this . externalWorkbookNumber = externalWorkbookNumber ; this . firstSheetName = sheetName . getSheetIdentifier ( ) . getName ( ) ; if ( sheetName instanceof SheetRangeIdentifier ) { this . lastSheetName = ( ( SheetRangeIdentifier ) sheetName ) . getLastSheetIdentifier ( ) . getName ( ) ; } else { this . lastSheetName = null ; } }
public void setBaseline ( long clockTime ) { t0 = clockTime ; timeout = t0 + ticksAllowed ; }
public MoveAddressToVpcResult moveAddressToVpc ( MoveAddressToVpcRequest request ) { request = beforeClientExecution ( request ) ; return executeMoveAddressToVpc ( request ) ; }
public String toString ( ) { String coll = collectionModel . getName ( ) ; if ( coll != null ) { return String . format ( Locale . ROOT , " LM ▁ % s ▁ - ▁ % s " , getName ( ) , coll ) ; } else { return String . format ( Locale . ROOT , " LM ▁ % s " , getName ( ) ) ; } }
public DescribeLagsResult describeLags ( DescribeLagsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLags ( request ) ; }
public AreaEval offset ( int relFirstRowIx , int relLastRowIx , int relFirstColIx , int relLastColIx ) { if ( _refEval == null ) { return _areaEval . offset ( relFirstRowIx , relLastRowIx , relFirstColIx , relLastColIx ) ; } return _refEval . offset ( relFirstRowIx , relLastRowIx , relFirstColIx , relLastColIx ) ; }
public ShortBuffer put ( short [ ] src , int srcOffset , int shortCount ) { byteBuffer . limit ( limit * SizeOf . SHORT ) ; byteBuffer . position ( position * SizeOf . SHORT ) ; if ( byteBuffer instanceof ReadWriteDirectByteBuffer ) { ( ( ReadWriteDirectByteBuffer ) byteBuffer ) . put ( src , srcOffset , shortCount ) ; } else { ( ( ReadWriteHeapByteBuffer ) byteBuffer ) . put ( src , srcOffset , shortCount ) ; } this . position += shortCount ; return this ; }
public void initialize ( final String cat ) { this . _cat = cat ; }
public void write ( int oneByte ) throws IOException { out . write ( oneByte ) ; written ++ ; }
public DescribeImportImageTasksResult describeImportImageTasks ( DescribeImportImageTasksRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeImportImageTasks ( request ) ; }
public ColumnInfoRecord ( RecordInputStream in ) { _firstCol = in . readUShort ( ) ; _lastCol = in . readUShort ( ) ; _colWidth = in . readUShort ( ) ; _xfIndex = in . readUShort ( ) ; _options = in . readUShort ( ) ; switch ( in . remaining ( ) ) { case 2 : field_6_reserved = in . readUShort ( ) ; break ; case 1 : field_6_reserved = in . readByte ( ) ; break ; case 0 : field_6_reserved = 0 ; break ; default : throw new RuntimeException ( " Unusual ▁ record ▁ size ▁ remaining = ( " + in . remaining ( ) + " ) " ) ; } }
public Status ( IndexDiff diff ) { super ( ) ; this . diff = diff ; hasUncommittedChanges = ! diff . getAdded ( ) . isEmpty ( ) || ! diff . getChanged ( ) . isEmpty ( ) || ! diff . getRemoved ( ) . isEmpty ( ) || ! diff . getMissing ( ) . isEmpty ( ) || ! diff . getModified ( ) . isEmpty ( ) || ! diff . getConflicting ( ) . isEmpty ( ) ; clean = ! hasUncommittedChanges && diff . getUntracked ( ) . isEmpty ( ) ; }
public CreateExperimentResult createExperiment ( CreateExperimentRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateExperiment ( request ) ; }
public UnknownRecord clone ( ) { return copy ( ) ; }
public FloatBuffer slice ( ) { byteBuffer . limit ( limit * SizeOf . FLOAT ) ; byteBuffer . position ( position * SizeOf . FLOAT ) ; ByteBuffer bb = byteBuffer . slice ( ) . order ( byteBuffer . order ( ) ) ; FloatBuffer result = new FloatToByteBufferAdapter ( bb ) ; byteBuffer . clear ( ) ; return result ; }
public DescribeSnapshotSchedulesResult describeSnapshotSchedules ( DescribeSnapshotSchedulesRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeSnapshotSchedules ( request ) ; }
public ListImagesResult listImages ( ListImagesRequest request ) { request = beforeClientExecution ( request ) ; return executeListImages ( request ) ; }
public Diff ( int ins , int del , int rep , int noop ) { INSERT = ins ; DELETE = del ; REPLACE = rep ; NOOP = noop ; }
public String toFormulaString ( String [ ] operands ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( operands [ 0 ] ) ; buffer . append ( " , " ) ; buffer . append ( operands [ 1 ] ) ; return buffer . toString ( ) ; }
public static void setupEnvironment ( String [ ] workbookNames , ForkedEvaluator [ ] evaluators ) { WorkbookEvaluator [ ] wbEvals = new WorkbookEvaluator [ evaluators . length ] ; for ( int i = 0 ; i < wbEvals . length ; i ++ ) { wbEvals [ i ] = evaluators [ i ] . _evaluator ; } CollaboratingWorkbooksEnvironment . setup ( workbookNames , wbEvals ) ; }
public ListPhotoTagsRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " ListPhotoTags " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public RandomSamplingFacetsCollector ( int sampleSize , long seed ) { super ( false ) ; this . sampleSize = sampleSize ; this . random = new XORShift64Random ( seed ) ; this . sampledDocs = null ; }
public AllocateStaticIpResult allocateStaticIp ( AllocateStaticIpRequest request ) { request = beforeClientExecution ( request ) ; return executeAllocateStaticIp ( request ) ; }
public FeatRecord ( RecordInputStream in ) { futureHeader = new FtrHeader ( in ) ; isf_sharedFeatureType = in . readShort ( ) ; reserved1 = in . readByte ( ) ; reserved2 = in . readInt ( ) ; int cref = in . readUShort ( ) ; cbFeatData = in . readInt ( ) ; reserved3 = in . readShort ( ) ; cellRefs = new CellRangeAddress [ cref ] ; for ( int i = 0 ; i < cellRefs . length ; i ++ ) { cellRefs [ i ] = new CellRangeAddress ( in ) ; } switch ( isf_sharedFeatureType ) { case FeatHdrRecord . SHAREDFEATURES_ISFPROTECTION : sharedFeature = new FeatProtection ( in ) ; break ; case FeatHdrRecord . SHAREDFEATURES_ISFFEC2 : sharedFeature = new FeatFormulaErr2 ( in ) ; break ; case FeatHdrRecord . SHAREDFEATURES_ISFFACTOID : sharedFeature = new FeatSmartTag ( in ) ; break ; default : logger . log ( POILogger . ERROR , " Unknown ▁ Shared ▁ Feature ▁ " + isf_sharedFeatureType + " ▁ found ! " ) ; } }
public RevCommit tryFastForward ( RevCommit newCommit ) throws IOException , GitAPIException { Ref head = getHead ( ) ; ObjectId headId = head . getObjectId ( ) ; if ( headId == null ) throw new RefNotFoundException ( MessageFormat . format ( JGitText . get ( ) . refNotResolved , Constants . HEAD ) ) ; RevCommit headCommit = walk . lookupCommit ( headId ) ; if ( walk . isMergedInto ( newCommit , headCommit ) ) return newCommit ; String headName = getHeadName ( head ) ; return tryFastForward ( headName , headCommit , newCommit ) ; }
public CreateSnapshotScheduleResult createSnapshotSchedule ( CreateSnapshotScheduleRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateSnapshotSchedule ( request ) ; }
public Record getNext ( ) { if ( ! hasNext ( ) ) { throw new RuntimeException ( " Attempt ▁ to ▁ read ▁ past ▁ end ▁ of ▁ record ▁ stream " ) ; } _countRead ++ ; return _list . get ( _nextIndex ++ ) ; }
public String toString ( ) { return RawParseUtils . decode ( buf . toByteArray ( ) ) ; }
public ListTablesRequest ( String exclusiveStartTableName ) { setExclusiveStartTableName ( exclusiveStartTableName ) ; }
public EnableAlarmActionsResult enableAlarmActions ( EnableAlarmActionsRequest request ) { request = beforeClientExecution ( request ) ; return executeEnableAlarmActions ( request ) ; }
public Builder ( ) { this ( true ) ; }
public boolean equals ( Object obj ) { final State other = ( State ) obj ; return is_final == other . is_final && Arrays . equals ( this . labels , other . labels ) && referenceEquals ( this . states , other . states ) ; }
public TokenStream create ( TokenStream input ) { return new EnglishPossessiveFilter ( input ) ; }
public void clearFormatting ( ) { _string = cloneStringIfRequired ( ) ; _string . clearFormatting ( ) ; addToSSTIfRequired ( ) ; }
public int get ( int index , long [ ] arr , int off , int len ) { assert len > 0 : " len ▁ must ▁ be ▁ > ▁ 0 ▁ ( got ▁ " + len + " ) " ; assert index >= 0 && index < valueCount ; len = Math . min ( len , valueCount - index ) ; Arrays . fill ( arr , off , off + len , 0 ) ; return len ; }
public DeleteRouteResponseResult deleteRouteResponse ( DeleteRouteResponseRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteRouteResponse ( request ) ; }
public String toPrivateString ( ) { return format ( true , false ) ; }
public CreatePresignedDomainUrlResult createPresignedDomainUrl ( CreatePresignedDomainUrlRequest request ) { request = beforeClientExecution ( request ) ; return executeCreatePresignedDomainUrl ( request ) ; }
public void write ( int oneChar ) { doWrite ( new char [ ] { ( char ) oneChar } , 0 , 1 ) ; }
public SSTRecord getSSTRecord ( ) { return sstRecord ; }
public String toString ( ) { return " term = " + term + " , field = " + field + " , value = " + valueToString ( ) + " , docIDUpto = " + docIDUpto ; }
public boolean isSaturated ( FuzzySet bloomFilter , FieldInfo fieldInfo ) { return bloomFilter . getSaturation ( ) > 0.9f ; }
public Builder ( boolean ignoreCase ) { this . ignoreCase = ignoreCase ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " ( maxBasicQueries : ▁ " + maxBasicQueries + " , ▁ queriesMade : ▁ " + queriesMade + " ) " ; }
public DeleteDataSourceResult deleteDataSource ( DeleteDataSourceRequest request ) { request = beforeClientExecution ( request ) ; return executeDeleteDataSource ( request ) ; }
public RebootNodeResult rebootNode ( RebootNodeRequest request ) { request = beforeClientExecution ( request ) ; return executeRebootNode ( request ) ; }
public void processChildRecords ( ) { convertRawBytesToEscherRecords ( ) ; }
public CreateOrUpdateTagsResult createOrUpdateTags ( CreateOrUpdateTagsRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateOrUpdateTags ( request ) ; }
public FileSnapshot getSnapShot ( ) { return snapShot ; }
public InputStream openResource ( String resource ) throws IOException { final InputStream stream = ( clazz != null ) ? clazz . getResourceAsStream ( resource ) : loader . getResourceAsStream ( resource ) ; if ( stream == null ) throw new IOException ( " Resource ▁ not ▁ found : ▁ " + resource ) ; return stream ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( 64 ) ; sb . append ( getClass ( ) . getName ( ) ) . append ( " ▁ [ " ) ; sb . append ( " sid = " ) . append ( HexDump . shortToHex ( _sid ) ) ; sb . append ( " ▁ size = " ) . append ( _data . length ) ; sb . append ( " ▁ : ▁ " ) . append ( HexDump . toHex ( _data ) ) ; sb . append ( " ] \ n " ) ; return sb . toString ( ) ; }
public int nextIndex ( ) { return index ; }
public CharSequence toQueryString ( EscapeQuerySyntax escaper ) { if ( isDefaultField ( this . field ) ) { return " \ " " + getTermEscapeQuoted ( escaper ) + " \ " " ; } else { return this . field + " : " + " \ " " + getTermEscapeQuoted ( escaper ) + " \ " " ; } }
public CalcModeRecord clone ( ) { return copy ( ) ; }
public boolean isOutput ( ) { return output ; }
public CreateNetworkInterfaceResult createNetworkInterface ( CreateNetworkInterfaceRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateNetworkInterface ( request ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_password ) ; }
public StopDominantLanguageDetectionJobResult stopDominantLanguageDetectionJob ( StopDominantLanguageDetectionJobRequest request ) { request = beforeClientExecution ( request ) ; return executeStopDominantLanguageDetectionJob ( request ) ; }
public ECSMetadataServiceCredentialsFetcher withConnectionTimeout ( int milliseconds ) { this . connectionTimeoutInMilliseconds = milliseconds ; return this ; }
public GetGatewayGroupResult getGatewayGroup ( GetGatewayGroupRequest request ) { request = beforeClientExecution ( request ) ; return executeGetGatewayGroup ( request ) ; }
public FloatBuffer slice ( ) { return new ReadOnlyFloatArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public static String join ( Collection < String > parts , String separator , String lastSeparator ) { StringBuilder sb = new StringBuilder ( ) ; int i = 0 ; int lastIndex = parts . size ( ) - 1 ; for ( String part : parts ) { sb . append ( part ) ; if ( i == lastIndex - 1 ) { sb . append ( lastSeparator ) ; } else if ( i != lastIndex ) { sb . append ( separator ) ; } i ++ ; } return sb . toString ( ) ; }
public String toString ( ) { return " ( " + a . toString ( ) + " ▁ AND ▁ " + b . toString ( ) + " ) " ; }
public ListSubscriptionsByTopicRequest ( String topicArn , String nextToken ) { setTopicArn ( topicArn ) ; setNextToken ( nextToken ) ; }
public byte readByte ( ) { return bytes [ pos -- ] ; }
public TerminateClientVpnConnectionsResult terminateClientVpnConnections ( TerminateClientVpnConnectionsRequest request ) { request = beforeClientExecution ( request ) ; return executeTerminateClientVpnConnections ( request ) ; }
public ReceiveMessageRequest ( String queueUrl ) { setQueueUrl ( queueUrl ) ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_barSpace ) ; out . writeShort ( field_2_categorySpace ) ; out . writeShort ( field_3_formatFlags ) ; }
public Object common ( Object output1 , Object output2 ) { return outputs . common ( ( T ) output1 , ( T ) output2 ) ; }
public CreateVariableResult createVariable ( CreateVariableRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVariable ( request ) ; }
public static final int match ( byte [ ] b , int ptr , byte [ ] src ) { if ( ptr + src . length > b . length ) return - 1 ; for ( int i = 0 ; i < src . length ; i ++ , ptr ++ ) if ( b [ ptr ] != src [ i ] ) return - 1 ; return ptr ; }
public int fillFields ( byte [ ] data , int offset , EscherRecordFactory recordFactory ) { int bytesRemaining = readHeader ( data , offset ) ; int pos = offset + 8 ; int size = 0 ; field_1_rectX1 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_2_rectY1 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_3_rectX2 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; field_4_rectY2 = LittleEndian . getInt ( data , pos + size ) ; size += 4 ; bytesRemaining -= size ; if ( bytesRemaining != 0 ) { throw new RecordFormatException ( " Expected ▁ no ▁ remaining ▁ bytes ▁ but ▁ got ▁ " + bytesRemaining ) ; } return 8 + size + bytesRemaining ; }
public CreateCloudFrontOriginAccessIdentityResult createCloudFrontOriginAccessIdentity ( CreateCloudFrontOriginAccessIdentityRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateCloudFrontOriginAccessIdentity ( request ) ; }
public boolean isNamespaceAware ( ) { return getFeature ( XmlPullParser . FEATURE_PROCESS_NAMESPACES ) ; }
public void setOverridable ( boolean on ) { overridable = on ; }
public String getClassName ( ) { return className ; }
public synchronized DirectoryReader getIndexReader ( ) { if ( indexReader != null ) { indexReader . incRef ( ) ; } return indexReader ; }
public int indexOfKey ( int key ) { return binarySearch ( mKeys , 0 , mSize , key ) ; }
public BlankRecord ( RecordInputStream in ) { field_1_row = in . readUShort ( ) ; field_2_col = in . readShort ( ) ; field_3_xf = in . readShort ( ) ; }
public long length ( ) { return length ; }
public PasswordRecord ( RecordInputStream in ) { field_1_password = in . readShort ( ) ; }
public HashMap ( int capacity , float loadFactor ) { this ( capacity ) ; if ( loadFactor <= 0 || Float . isNaN ( loadFactor ) ) { throw new IllegalArgumentException ( " Load ▁ factor : ▁ " + loadFactor ) ; } }
public void run ( ) { long lastReopenStartNS = System . nanoTime ( ) ; while ( ! finish ) { while ( ! finish ) { reopenLock . lock ( ) ; try { boolean hasWaiting = waitingGen > searchingGen ; final long nextReopenStartNS = lastReopenStartNS + ( hasWaiting ? targetMinStaleNS : targetMaxStaleNS ) ; final long sleepNS = nextReopenStartNS - System . nanoTime ( ) ; if ( sleepNS > 0 ) { reopenCond . awaitNanos ( sleepNS ) ; } else { break ; } } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; return ; } finally { reopenLock . unlock ( ) ; } } if ( finish ) { break ; } lastReopenStartNS = System . nanoTime ( ) ; refreshStartGen = writer . getMaxCompletedSequenceNumber ( ) ; try { manager . maybeRefreshBlocking ( ) ; } catch ( IOException ioe ) { throw new RuntimeException ( ioe ) ; } } }
public DeleteLoginProfileRequest ( String userName ) { setUserName ( userName ) ; }
public E pollFirst ( ) { return ( size == 0 ) ? null : removeFirstImpl ( ) ; }
public CreatePhotoRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " CreatePhoto " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public String getName ( ) { return " resolve " ; }
public int findEndOffset ( StringBuilder buffer , int start ) { if ( start > buffer . length ( ) || start < 0 ) return start ; int offset , count = maxScan ; for ( offset = start ; offset < buffer . length ( ) && count > 0 ; count -- ) { if ( boundaryChars . contains ( buffer . charAt ( offset ) ) ) return offset ; offset ++ ; } return start ; }
public void setObjectChecker ( ObjectChecker oc ) { objCheck = oc ; }
public BaseRef ( AreaEval ae ) { _refEval = null ; _areaEval = ae ; _firstRowIndex = ae . getFirstRow ( ) ; _firstColumnIndex = ae . getFirstColumn ( ) ; _height = ae . getLastRow ( ) - ae . getFirstRow ( ) + 1 ; _width = ae . getLastColumn ( ) - ae . getFirstColumn ( ) + 1 ; }
public CreateVpcEndpointResult createVpcEndpoint ( CreateVpcEndpointRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateVpcEndpoint ( request ) ; }
public DeregisterWorkspaceDirectoryResult deregisterWorkspaceDirectory ( DeregisterWorkspaceDirectoryRequest request ) { request = beforeClientExecution ( request ) ; return executeDeregisterWorkspaceDirectory ( request ) ; }
public ChartFRTInfoRecord ( RecordInputStream in ) { rt = in . readShort ( ) ; grbitFrt = in . readShort ( ) ; verOriginator = in . readByte ( ) ; verWriter = in . readByte ( ) ; int cCFRTID = in . readShort ( ) ; rgCFRTID = new CFRTID [ cCFRTID ] ; for ( int i = 0 ; i < cCFRTID ; i ++ ) { rgCFRTID [ i ] = new CFRTID ( in ) ; } }
public Merger newMerger ( Repository db ) { return new OneSide ( db , treeIndex ) ; }
public CreateDataSourceFromRedshiftResult createDataSourceFromRedshift ( CreateDataSourceFromRedshiftRequest request ) { request = beforeClientExecution ( request ) ; return executeCreateDataSourceFromRedshift ( request ) ; }
public void clearDFA ( ) { for ( int d = 0 ; d < decisionToDFA . length ; d ++ ) { decisionToDFA [ d ] = new DFA ( atn . getDecisionState ( d ) , d ) ; } }
public void removeName ( String name ) { int index = getNameIndex ( name ) ; removeName ( index ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ RightMargin ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . margin ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " ) . append ( " ▁ ( " ) . append ( getMargin ( ) ) . append ( " ▁ ) \ n " ) ; buffer . append ( " [ / RightMargin ] \ n " ) ; return buffer . toString ( ) ; }
public RefreshAllRecord clone ( ) { return copy ( ) ; }
public StandardQueryNodeProcessorPipeline ( QueryConfigHandler queryConfig ) { super ( queryConfig ) ; add ( new WildcardQueryNodeProcessor ( ) ) ; add ( new MultiFieldQueryNodeProcessor ( ) ) ; add ( new FuzzyQueryNodeProcessor ( ) ) ; add ( new RegexpQueryNodeProcessor ( ) ) ; add ( new MatchAllDocsQueryNodeProcessor ( ) ) ; add ( new OpenRangeQueryNodeProcessor ( ) ) ; add ( new PointQueryNodeProcessor ( ) ) ; add ( new PointRangeQueryNodeProcessor ( ) ) ; add ( new TermRangeQueryNodeProcessor ( ) ) ; add ( new AllowLeadingWildcardProcessor ( ) ) ; add ( new AnalyzerQueryNodeProcessor ( ) ) ; add ( new PhraseSlopQueryNodeProcessor ( ) ) ; add ( new BooleanQuery2ModifierNodeProcessor ( ) ) ; add ( new NoChildOptimizationQueryNodeProcessor ( ) ) ; add ( new RemoveDeletedQueryNodesProcessor ( ) ) ; add ( new RemoveEmptyNonLeafQueryNodeProcessor ( ) ) ; add ( new BooleanSingleChildOptimizationQueryNodeProcessor ( ) ) ; add ( new DefaultPhraseSlopQueryNodeProcessor ( ) ) ; add ( new BoostQueryNodeProcessor ( ) ) ; add ( new MultiTermRewriteMethodProcessor ( ) ) ; }
public String formatAsString ( String sheetName , boolean useAbsoluteAddress ) { StringBuilder sb = new StringBuilder ( ) ; if ( sheetName != null ) { sb . append ( SheetNameFormatter . format ( sheetName ) ) ; sb . append ( " ! " ) ; } CellReference cellRefFrom = new CellReference ( getFirstRow ( ) , getFirstColumn ( ) , useAbsoluteAddress , useAbsoluteAddress ) ; CellReference cellRefTo = new CellReference ( getLastRow ( ) , getLastColumn ( ) , useAbsoluteAddress , useAbsoluteAddress ) ; sb . append ( cellRefFrom . formatAsString ( ) ) ; if ( ! cellRefFrom . equals ( cellRefTo ) || isFullColumnRange ( ) || isFullRowRange ( ) ) { sb . append ( ' : ' ) ; sb . append ( cellRefTo . formatAsString ( ) ) ; } return sb . toString ( ) ; }
public ByteBuffer put ( int index , byte value ) { throw new ReadOnlyBufferException ( ) ; }
public void mode ( int m ) { _mode = m ; }
public ShortBuffer slice ( ) { return new ReadWriteShortArrayBuffer ( remaining ( ) , backingArray , offset + position ) ; }
public void set ( int index , long n ) { if ( count < index ) throw new ArrayIndexOutOfBoundsException ( index ) ; else if ( count == index ) add ( n ) ; elseentries [ index ] = n ; }
public ByteBuffer putFloat ( float value ) { throw new ReadOnlyBufferException ( ) ; }
public static double max ( double [ ] values ) { double max = Double . NEGATIVE_INFINITY ; for ( double value : values ) { max = Math . max ( max , value ) ; } return max ; }
public UpdateRepoWebhookRequest ( ) { super ( " cr " , " 2016 - 06 - 07 " , " UpdateRepoWebhook " , " cr " ) ; setUriPattern ( " / repos / [ RepoNamespace ] / [ RepoName ] / webhooks / [ WebhookId ] " ) ; setMethod ( MethodType . POST ) ; }
public DeleteAttributesRequest ( String domainName , String itemName , java . util . List < Attribute > attributes , UpdateCondition expected ) { setDomainName ( domainName ) ; setItemName ( itemName ) ; setAttributes ( attributes ) ; setExpected ( expected ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ SXPI ] \ n " ) ; for ( int i = 0 ; i < _fieldInfos . length ; i ++ ) { sb . append ( " ▁ ▁ ▁ ▁ item [ " ) . append ( i ) . append ( " ] = " ) ; _fieldInfos [ i ] . appendDebugInfo ( sb ) ; sb . append ( ' \ n ' ) ; } sb . append ( " [ / SXPI ] \ n " ) ; return sb . toString ( ) ; }
public boolean isSuccessful ( ) { if ( mergeResult != null ) return mergeResult . getMergeStatus ( ) . isSuccessful ( ) ; else if ( rebaseResult != null ) return rebaseResult . getStatus ( ) . isSuccessful ( ) ; return true ; }
public void setBytesValue ( byte [ ] value ) { setBytesValue ( new BytesRef ( value ) ) ; }
public DescribeConnectionsResult describeConnections ( DescribeConnectionsRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeConnections ( request ) ; }
public DeletePhotosRequest ( ) { super ( " CloudPhoto " , " 2017 - 07 - 11 " , " DeletePhotos " , " cloudphoto " ) ; setProtocol ( ProtocolType . HTTPS ) ; }
public void add ( E object ) { iterator . add ( object ) ; subList . sizeChanged ( true ) ; end ++ ; }
public static ByteBuffer allocate ( int capacity ) { if ( capacity < 0 ) { throw new IllegalArgumentException ( ) ; } return new ReadWriteHeapByteBuffer ( capacity ) ; }
public SrndQuery getSubQuery ( int qn ) { return queries . get ( qn ) ; }
public float currentScore ( int docId , String field , int start , int end , int numPayloadsSeen , float currentScore , float currentPayloadScore ) { if ( numPayloadsSeen == 0 ) { return currentPayloadScore ; } else { return Math . min ( currentPayloadScore , currentScore ) ; } }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " [ BLANK ] \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ row = ▁ " ) . append ( HexDump . shortToHex ( getRow ( ) ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ col = ▁ " ) . append ( HexDump . shortToHex ( getColumn ( ) ) ) . append ( " \ n " ) ; sb . append ( " ▁ ▁ ▁ ▁ xf ▁ = ▁ " ) . append ( HexDump . shortToHex ( getXFIndex ( ) ) ) . append ( " \ n " ) ; sb . append ( " [ / BLANK ] \ n " ) ; return sb . toString ( ) ; }
public DescribeLogPatternResult describeLogPattern ( DescribeLogPatternRequest request ) { request = beforeClientExecution ( request ) ; return executeDescribeLogPattern ( request ) ; }
public RegisterTransitGatewayMulticastGroupMembersResult registerTransitGatewayMulticastGroupMembers ( RegisterTransitGatewayMulticastGroupMembersRequest request ) { request = beforeClientExecution ( request ) ; return executeRegisterTransitGatewayMulticastGroupMembers ( request ) ; }
public GetPhoneNumberSettingsResult getPhoneNumberSettings ( GetPhoneNumberSettingsRequest request ) { request = beforeClientExecution ( request ) ; return executeGetPhoneNumberSettings ( request ) ; }
public ObjectId getData ( ) { return data ; }
public boolean isDirect ( ) { return false ; }
public DeleteServerCertificateRequest ( String serverCertificateName ) { setServerCertificateName ( serverCertificateName ) ; }
public StringBuffer append ( double d ) { RealToString . getInstance ( ) . appendDouble ( this , d ) ; return this ; }
public GetEvaluationResult getEvaluation ( GetEvaluationRequest request ) { request = beforeClientExecution ( request ) ; return executeGetEvaluation ( request ) ; }
public LinkedDataRecord getDataName ( ) { return dataName ; }
public boolean find ( int start ) { findPos = start ; if ( findPos < regionStart ) { findPos = regionStart ; } else if ( findPos >= regionEnd ) { matchFound = false ; return false ; } matchFound = findImpl ( address , input , findPos , matchOffsets ) ; if ( matchFound ) { findPos = matchOffsets [ 1 ] ; } return matchFound ; }
public GetLifecyclePolicyPreviewResult getLifecyclePolicyPreview ( GetLifecyclePolicyPreviewRequest request ) { request = beforeClientExecution ( request ) ; return executeGetLifecyclePolicyPreview ( request ) ; }
public SinglePositionTokenStream ( String word ) { termAtt = addAttribute ( CharTermAttribute . class ) ; posIncrAtt = addAttribute ( PositionIncrementAttribute . class ) ; this . word = word ; returned = true ; }
public void serialize ( LittleEndianOutput out ) { out . writeShort ( field_1_print_gridlines ) ; }
public String toString ( ) { final StringBuilder s = new StringBuilder ( ) ; s . append ( Constants . typeString ( getType ( ) ) ) ; s . append ( ' ▁ ' ) ; s . append ( name ( ) ) ; s . append ( ' ▁ ' ) ; s . append ( commitTime ) ; s . append ( ' ▁ ' ) ; appendCoreFlags ( s ) ; return s . toString ( ) ; }
public LsRemoteCommand setRemote ( String remote ) { checkCallable ( ) ; this . remote = remote ; return this ; }
public void collapseRow ( int rowNumber ) { int startRow = findStartOfRowOutlineGroup ( rowNumber ) ; RowRecord rowRecord = getRow ( startRow ) ; int nextRowIx = writeHidden ( rowRecord , startRow ) ; RowRecord row = getRow ( nextRowIx ) ; if ( row == null ) { row = createRow ( nextRowIx ) ; insertRow ( row ) ; } row . setColapsed ( true ) ; }
public AssociateSkillGroupWithRoomResult associateSkillGroupWithRoom ( AssociateSkillGroupWithRoomRequest request ) { request = beforeClientExecution ( request ) ; return executeAssociateSkillGroupWithRoom ( request ) ; }
public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( " [ SERIESLIST ] \ n " ) ; buffer . append ( " ▁ ▁ ▁ ▁ . seriesNumbers = ▁ " ) . append ( " ▁ ( " ) . append ( Arrays . toString ( getSeriesNumbers ( ) ) ) . append ( " ▁ ) " ) ; buffer . append ( " \ n " ) ; buffer . append ( " [ / SERIESLIST ] \ n " ) ; return buffer . toString ( ) ; }
public QueryConfigHandler getQueryConfigHandler ( ) { return this . queryConfig ; }
public String getClassArg ( ) { if ( null != originalArgs ) { String className = originalArgs . get ( CLASS_NAME ) ; if ( null != className ) { return className ; } } return getClass ( ) . getName ( ) ; }
int changeEvenBits ( int n ) { int to_subtract = 0 ; int m = 0 ; for ( int x = n ; x > 0 ; x >>= 2 ) { if ( ( x & 1 ) > 0 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
boolean checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
void FindPairs ( int n , int k ) { System . out . print ( 1 + " ▁ " + n + "NEW_LINE"); k -- ; for ( long i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { System . out . print ( 1 + " ▁ " + i + "NEW_LINE"); k -- ; if ( k == 0 ) break ; if ( i != n / i ) { System . out . print ( 1 + " ▁ " + n / i + "NEW_LINE"); k -- ; } if ( k == 0 ) break ; } } }
void decrypt ( String Str , int Start , int End ) { if ( Start > End ) { return ; } int mid = ( Start + End ) >> 1 ; System . out . print ( Str . charAt ( mid ) ) ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
boolean prefixDivisble ( int n ) { int i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = n / 10 ; i ++ ; } return true ; }
int minimum_required_operations ( int arr [ ] , int n , int k ) { int answer = 0 ; long mod = 1000000007 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
void transpose ( int A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } }
void checkFactors ( long N ) { long ev_count = 0 , od_count = 0 ; for ( long i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) System . out . print ( " Yes " + "NEW_LINE"); else System . out . print ( " No " + "NEW_LINE"); }
int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; }
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
int enneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; }
int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
void main ( String [ ] args ) { int n = 8 ; int [ ] v = Findpermutation ( n ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( v [ i ] + " ▁ " ) ; } }
int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; HashMap < Integer , Integer > count = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( arr [ i ] ) ) { ans += count . get ( arr [ i ] ) ; count . put ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; } else { count . put ( arr [ i ] , 1 ) ; } } return ans ; }
double findRadius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . sqrt ( a3 / 3.14 ) ; return r3 ; }
void BeattySequence ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int ans = ( int ) Math . floor ( i * Math . sqrt ( 2 ) ) ; System . out . print ( ans + " , ▁ " ) ; } }
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = ( int ) ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; double c = Math . pow ( pow_sum , 1.0 / n ) ; int c_pow = ( int ) Math . pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { System . out . println ( " Count ▁ example ▁ found " ) ; return ; } } System . out . println ( " No ▁ counter ▁ example ▁ within ▁ given " + " ▁ range ▁ and ▁ data " ) ; }
void freq ( int ar [ ] [ ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } System . out . print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " + odd + " NEW_LINE"); System . out . print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ " + even + " NEW_LINE"); }
int findSum ( int [ ] arr , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = Math . min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
int countSubStr ( char str [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
void findPairs ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; Arrays . sort ( arr ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } System . out . print ( ans ) ; }
int possibleStrings ( int n , int r , int b , int g ) { int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
void pairStar ( String input , int i ) { output = output + input . charAt ( i ) ; if ( i == input . length ( ) - 1 ) return ; if ( input . charAt ( i ) == input . charAt ( i + 1 ) ) output = output + ' * ' ; pairStar ( input , i + 1 ) ; }
int findLCMPrime ( int a , int b ) { if ( a == b ) { return a ; } return a * b ; }
long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
int get ( int x , int y , int z ) { if ( x > z ) return - 1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; }
boolean checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
void printModulus ( int X , int Y ) { int n = Math . max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) System . out . print ( i + " ▁ " ) ; } }
int findMinLength ( int [ ] arr ) { int index = ( int ) arr . length - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }
int countCon ( int ar [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
int largestNum ( int a , int b ) { return a * ( ( a / b ) > 0 ? 1 : 0 ) + b * ( ( b / a ) > 0 ? 1 : 0 ) ; }
long factorial ( int n ) { long M = 1000000007 ; long f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) return f ; }
void possibleToReach ( int x , int y , int z ) { if ( z < Math . abs ( x ) + Math . abs ( y ) || ( z - Math . abs ( x ) - Math . abs ( y ) ) % 2 == 1 ) { System . out . print ( " Not ▁ Possible " + "NEW_LINE"); } else System . out . print ( " Possible " + "NEW_LINE"); }
int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; }
void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; System . out . print ( A + " ▁ " + B ) ; }
int countStrings ( String s ) { int cnt = 0 ; for ( int i = 1 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { cnt ++ ; } } return cnt ; }
int findLargestString ( String s , int i , int r ) { if ( i == s . length ( ) ) { if ( r == 0 ) return 0 ; else return INT_MIN ; } if ( v [ i ] [ r ] == 1 ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = Math . max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s . charAt ( i ) - '0' ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
int getCount ( int arr [ ] , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
int minimumX ( int n , int k ) { int mini = Integer . MAX_VALUE ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }
int NumberofTimes ( String str ) { int temporary_sum = 0 , count = 0 ; while ( str . length ( ) > 1 ) { temporary_sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) temporary_sum += ( str . charAt ( i ) - '0' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
double ReuleauxArea ( double r ) { if ( r < 0 ) return - 1 ; double A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }
int findMinRooms ( String slots [ ] , int n , int m ) { int counts [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; System . out . printf ( " The ▁ third ▁ Largest ▁ " + "element is %dNEW_LINE", third); }
boolean isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
void printSeriesSum ( int N ) { long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += Math . pow ( i , i - 1 ) ; } System . out . print ( sum + "NEW_LINE"); }
boolean validQuadruple ( int arr [ ] , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
long hexadecagonalNum ( long n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
boolean isDivisibleBy5 ( String str ) { int n = str . length ( ) ; return ( ( ( str . charAt ( n - 1 ) - '0' ) == 0 ) || ( ( str . charAt ( n - 1 ) - '0' ) == 5 ) ) ; }
int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ ] = new int [ N + 1 ] ; dp [ 1 ] = insert ; for ( int i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
int numberSequence ( int n ) { int num = ( int ) ( Math . pow ( 4 , n ) - Math . pow ( 2 , n ) ) - 1 ; return num ; }
int findSubarrays ( int arr [ ] , int N , int K ) { return N - K + 1 ; }
void FindTrip ( int arr [ ] , int N ) { for ( int i = 1 ; i < N - 1 ; i ++ ) { int p = arr [ i - 1 ] ; int q = arr [ i ] ; int r = arr [ i + 1 ] ; if ( p < q && q > r ) { System . out . println ( ( i - 1 ) + " ▁ " + ( i ) + " ▁ " + ( i + 1 ) ) ; return ; } } System . out . println ( - 1 ) ; }
double polyapothem ( double n , double a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * java . lang . Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
String reverse ( char [ ] str , int len , int l , int r ) { if ( l < 0 r >= len l > r ) return " Invalid ▁ range ! " ; while ( l < r ) { char c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } String string = new String ( str ) ; return string ; }
long divide ( long dividend , long divisor ) { long sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1L << i ; } } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
int MinimumMoves ( int a [ ] , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
int subsequence ( int [ ] S , int [ ] T , int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; int mod = 1000000007 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j <= m ; j ++ ) dp [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; dp [ i ] [ j ] += mod ; dp [ i ] [ j ] %= mod ; } } return dp [ n ] [ m ] ; }
int findMaxSum ( int [ ] arr , int n ) { int [ ] preSum = new int [ n ] ; int [ ] suffSum = new int [ n ] ; int ans = Integer . MIN_VALUE ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }
int minMoves ( int [ ] arr ) { int N = arr . length ; if ( N <= 2 ) return 0 ; int ans = Integer . MAX_VALUE ; for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . abs ( i ) + Math . abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; }
void length_of_chord ( double r , double x ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ chord " + " ▁ of ▁ the ▁ circle ▁ is ▁ " + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) ) ; }
int max_min ( int a [ ] , int n ) { Arrays . sort ( a ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
void Permutation ( int n , int k ) { int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( p [ i ] + " ▁ " ) ; }
void countElement ( int A [ ] , int N , int B [ ] , int M , int K ) { int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int currentElement = B [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { int diff = Math . abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } System . out . print ( cnt ) ; }
void findFreq ( String str , int N ) { int [ ] freq = new int [ 256 ] ; int max = 0 ; char charMax = '0' ; for ( int i = 0 ; i < N ; i ++ ) { char ch = str . charAt ( i ) ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; charMax = ch ; } System . out . println ( charMax + " ▁ - > ▁ " + max ) ; } }
int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
void evenXorSubarray ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int XOR = 0 ; for ( int j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } System . out . println ( ans ) ; }
int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
int countSubStr ( String str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
void PrintBothArrays ( int a [ ] , int n ) { Vector < Integer > v1 = new Vector < Integer > ( ) , v2 = new Vector < Integer > ( ) ; HashMap < Integer , Integer > mpp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mpp . put ( a [ i ] , ( mpp . get ( a [ i ] ) == null ? 0 : mpp . get ( a [ i ] ) ) + 1 ) ; if ( mpp . get ( a [ i ] ) == 1 ) v1 . add ( a [ i ] ) ; else if ( mpp . get ( a [ i ] ) == 2 ) v2 . add ( a [ i ] ) ; else { System . out . println ( " Not ▁ possible " ) ; return ; } } Collections . sort ( v1 ) ; System . out . println ( " Strictly ▁ increasing ▁ array ▁ is : " ) ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) System . out . print ( v1 . get ( i ) + " ▁ " ) ; Collections . sort ( v2 ) ; Collections . reverse ( v2 ) ; System . out . println ( " Strictly decreasing array is : "); for ( int i = 0 ; i < v2 . size ( ) ; i ++ ) System . out . print ( v2 . get ( i ) + " ▁ " ) ; }
int findTrailingZeros ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; else { int ans = 0 ; n /= 2 ; while ( n != 0 ) { ans += n / 5 ; n /= 5 ; } return ans ; } }
boolean checkWord ( char [ ] [ ] board , String word , int index , int row , int col ) { if ( row < 0 col < 0 row >= board . length col >= board [ 0 ] . length ) return false ; if ( board [ row ] [ col ] != word . charAt ( index ) ) return false ; else if ( index == word . length ( ) - 1 ) return true ; char temp = board [ row ] [ col ] ; board [ row ] [ col ] = ' * ' ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row ] [ col ] = temp ; return true ; } board [ row ] [ col ] = temp ; return false ; }
void printRoots ( long a , long b , long c ) { System . out . println ( 1 + " , ▁ " + c / ( a * 1.0 ) ) ; }
int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
double hexDiagonal ( float a ) { if ( a < 0 ) return - 1 ; double d = ( double ) 1.73 * a ; return d ; }
int countDigit ( long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; }
void printLastElement ( int arr [ ] , int N ) { boolean leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } System . out . print ( arr [ head - 1 ] ) ; }
int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
void countFreq ( int arr [ ] , int n ) { boolean [ ] visited = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } System . out . println ( arr [ i ] + " ▁ " + count ) ; } }
int calc_distance ( int A [ ] , int B [ ] , int n ) { int distance_traveled_A = 0 ; int distance_traveled_B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
int pairs ( int n ) { int [ ] [ ] c = new int [ 10 ] [ 10 ] ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp ] [ i % 10 ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
int minOperations ( String str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( i + 1 ) ) count ++ ; } return ( count + 1 ) / 2 ; }
int minOperation ( int [ ] arr ) { int minOp = Integer . MIN_VALUE ; int minNeg = 0 , maxPos = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return Math . abs ( minNeg ) + maxPos ; }
int maxHamming ( int arr [ ] , int n ) { int brr [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = Math . max ( maxHam , currHam ) ; } return maxHam ; }
int mod ( int a , int m ) { return ( a % m + m ) % m ; }
void check ( int arr [ ] , int N ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
void count ( int n , int k ) { long count = ( long ) ( Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ) ; System . out . print ( count ) ; }
int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( ( n - 2 ) * 180 ) ; }
int countNumbers ( int N ) { return ( int ) ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; }
int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return result ; }
String check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Map < Integer , Integer > hm = new HashMap < > ( ) ; int count = 0 ; for ( int j = i ; j < n ; j ++ ) { hm . put ( arr [ j ] , hm . getOrDefault ( arr [ j ] , 0 ) + 1 ) ; if ( hm . get ( arr [ j ] ) == 1 ) count ++ ; if ( hm . get ( arr [ j ] ) == 2 ) count -- ; if ( count == 0 ) return " No " ; } } return " Yes " ; }
int findSubstringCount ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) + 1 == str . charAt ( i + 1 ) ) { result ++ ; while ( str . charAt ( i ) + 1 == str . charAt ( i + 1 ) ) { i ++ ; } } } return result ; }
int countDigits ( int n ) { return ( int ) ( n * Math . log10 ( 2 ) + 1 ) ; }
int findPeak ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } return 0 ; }
long countNumberOfStrings ( String s ) { int n = s . length ( ) - 1 ; long count = ( long ) ( Math . pow ( 2 , n ) ) ; return count ; }
int posOfRightMostSameBit ( int m , int n ) { int loopCounter = 1 ; while ( m > 0 n > 0 ) { boolean a = m % 2 == 1 ; boolean b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return - 1 ; }
int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }
boolean pairExists ( int [ ] arr1 , int m , int [ ] arr2 , int n ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s . contains ( arr2 [ j ] - arr1 [ i ] ) ) return true ; } s . add ( arr1 [ i ] ) ; } return false ; }
int largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] ; }
int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
void findEquation ( int A , int B , int C ) { System . out . print ( " ( " + C + " ) " + " x ^ 2 ▁ + ( " + B + " ) x ▁ + ▁ ( " + A + " ) ▁ = ▁ 0" ) ; }
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
int getM ( int n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
void subtract ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + n - 3 ; }
double volumeRec ( double a , double b , double e , double h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
long findNthNumber ( long N ) { long result = 0 ; long p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = N / 9 ; p = p * 10 ; } return result ; }
int countSquares ( int n ) { return ( int ) ( Math . pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
boolean isPossible ( int a [ ] , int n ) { int cur = a [ 0 ] ; cur -- ; for ( int i = 1 ; i < n ; i ++ ) { int nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }
double circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; }
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
int getMin ( int arr [ ] , int n ) { int minVal = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; return minVal ; }
int colMaxDiff ( int mat [ ] [ ] ) { int max_diff = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; }
int findSmallestNumK ( int n ) { int cummAnd = n ; int i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
double area ( double d1 , double a ) { double d2 = Math . sqrt ( 4 * ( a * a ) - d1 * d1 ) ; double area = 0.5 * d1 * d2 ; return area ; }
int evenNumSubstring ( String str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str . charAt ( i ) - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
void printChar ( String str , int n ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 1 ) { System . out . print ( str . charAt ( i ) ) ; } } }
boolean isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
int getMinOps ( int [ ] arr ) { int ans = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { ans += Math . max ( arr [ i ] - arr [ i + 1 ] , 0 ) ; } return ans ; }
double MinimumMail ( int n , int k , int x ) { double m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
boolean can_empty ( int a , int b , int c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = Math . min ( a , Math . min ( b , c ) ) ; if ( m < ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . println ( removeDuplicatesFromString ( str ) ) ; } }
long centeredDodecagonal ( long n ) { return 6 * n * ( n - 1 ) + 1 ; }
int summation ( int N ) { int co = ( N + 1 ) / 2 ; int ce = ( N ) / 2 ; int se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; int so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . pow ( 10 , n - 1 ) ) ; }
long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
int countUnique ( int mat [ ] [ ] , int n , int m ) { int [ ] rowsum = new int [ n ] ; int [ ] colsum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . min ( x , Math . min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
int center_octadecagon_num ( int n ) { return 9 * n * n - 9 * n + 1 ; }
long polynomialRollingHash ( String str ) { int p = 31 ; int m = ( int ) ( 1e9 + 9 ) ; long power_of_p = 1 ; long hash_val = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { hash_val = ( hash_val + ( str . charAt ( i ) - ' a ' + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
boolean isFibbinaryNum ( int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) Math . pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }
void maxPossibleSum ( int [ ] arr , int N ) { Arrays . sort ( arr ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } System . out . println ( sum ) ; }
int maxWater ( int [ ] arr , int n ) { int left = 0 ; int right = n - 1 ; int l_max = 0 ; int r_max = 0 ; int result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += Math . max ( 0 , r_max - arr [ right ] ) ; r_max = Math . max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += Math . max ( 0 , l_max - arr [ left ] ) ; l_max = Math . max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
void maxArea ( int [ ] point_x , int [ ] point_y , int n , int length , int width ) { Arrays . sort ( point_x ) ; Arrays . sort ( point_y ) ; int dx = point_x [ 0 ] ; int dy = point_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = Math . max ( dx , point_x [ i ] - point_x [ i - 1 ] ) ; dy = Math . max ( dy , point_y [ i ] - point_y [ i - 1 ] ) ; } dx = Math . max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) ; dy = Math . max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) ; System . out . println ( ( dx - 1 ) * ( dy - 1 ) ) ; }
double sumNodes ( int l ) { double leafNodeCount = Math . pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; }
double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; }
void Kroneckerproduct ( int A [ ] [ ] , int B [ ] [ ] ) { int [ ] [ ] C = new int [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; System . out . print ( C [ i + l + 1 ] [ j + k + 1 ] + " ▁ " ) ; } } System . out . println ( ) ; } } }
boolean Survives ( int n ) { for ( int i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= n / i ; } }
int countSwaps ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int max_frequency = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } max_frequency = Math . max ( max_frequency , mp . get ( arr [ i ] ) ) ; } return n - max_frequency ; }
int maxLength ( int arr [ ] , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
boolean isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int No_of_cubes ( int N , int K ) { int No = 0 ; No = ( N - K + 1 ) ; No = ( int ) Math . pow ( No , 3 ) ; return No ; }
void maxModProdSubarr ( int arr [ ] , int n , int M ) { int ans = 0 ; int length = n ; for ( int i = 0 ; i < n ; i ++ ) { int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } System . out . println ( " Maximum ▁ subarray ▁ product ▁ is ▁ " + ans ) ; System . out . println ( " Minimum ▁ length ▁ of ▁ the ▁ maximum ▁ " + " product ▁ subarray ▁ is ▁ " + length ) ; }
void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " ▁ - - ▁ " + next ) ; } }
boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
float computeMaxValue ( float arr [ ] , int n ) { float ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { float val = Math . max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = Math . max ( ans , val ) ; } } return ans ; }
void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { double d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; System . out . println ( " Distance ▁ is ▁ " + d ) ; return ; }
boolean isLoeschian ( int n ) { for ( int x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { for ( int y = 1 ; y <= Math . sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
float heightCalculate ( int H , int n , int m ) { float N = ( float ) ( n * 1.0 ) ; float M = ( float ) ( m * 1.0 ) ; float h = H * ( float ) Math . sqrt ( N / ( N + M ) ) ; return h ; }
void Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( i * ( 7 * i - 5 ) / 2 ) ; System . out . print ( " ▁ " ) ; } }
int eulerian ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
void findDecimal ( double arr [ ] , int N ) { int bit , power = 0 , result = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { bit = Math . abs ( ( int ) Math . floor ( arr [ i ] ) - ( int ) Math . round ( arr [ i ] ) ) ; if ( bit != 0 ) result += Math . pow ( 2 , power ) ; power ++ ; } System . out . print ( result ) ; }
int MatrixChainOrder ( int p [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
int findOccurrences ( String str1 , String substr1 ) { int counter = 0 ; char [ ] str = str1 . toCharArray ( ) ; char [ ] substr = substr1 . toCharArray ( ) ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) { for ( int j = i + 1 ; j < str1 . length ( ) ; j ++ ) { if ( str [ j ] == substr [ 1 ] ) { for ( int k = j + 1 ; k < str1 . length ( ) ; k ++ ) { if ( str [ k ] == substr [ 2 ] ) counter ++ ; } } } } } return counter ; }
int lenOfLongSubarr ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . max ( maxVal , x + y + ( int ) z ) ; } } return maxVal ; }
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] == 1 ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
boolean isTwoAlter ( String s ) { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i + 2 ) ) { return false ; } } if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) return false ; return true ; }
int count9s ( String number ) { int count = 0 ; int n = number . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = number . charAt ( i ) - '0' ; if ( number . charAt ( i ) == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number . charAt ( j ) - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; }
void printDuplicates ( int arr [ ] , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { System . out . print ( arr [ i ] % n + " ▁ " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! ( fl > 0 ) ) System . out . println ( " - 1" ) ; }
int countSubsequences ( int arr [ ] , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) % 2 == 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; }
int getPairsCount ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . abs ( i - j ) ) count ++ ; } } return count ; }
void answer ( int L , int R ) { if ( 2 * L <= R ) System . out . println ( L + " , ▁ " + ( 2 * L ) ) ; else System . out . println ( " - 1" ) ; }
void precompute ( String s , String K ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] ; if ( s . substring ( i , i + K . length ( ) ) . equals ( K ) ) { cnt [ i + 1 ] += 1 ; } } cnt [ n - 2 + 1 ] = cnt [ n - 2 ] ; }
int check ( int n , int m ) { if ( m % n == 0 ) { System . out . print ( " YES " ) ; } else { System . out . print ( " NO " ) ; } return 0 ; }
int det ( int [ ] [ ] d ) { int Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) ; Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) ; Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) ; return Sum ; }
int countEvenPairs ( int N , int M ) { int count = 0 ; int nEven = ( int ) Math . floor ( ( double ) N / 2 ) ; int nOdd = ( int ) Math . ceil ( ( double ) N / 2 ) ; int mEven = ( int ) Math . floor ( ( double ) M / 2 ) ; int mOdd = ( int ) Math . ceil ( ( double ) M / 2 ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
void solve ( int n , int d , int input [ ] ) { int [ ] a = new int [ N ] ; int [ ] cnt = new int [ V + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) a [ i ] = input [ i ] ; int answer = 0 ; for ( int i = 0 ; i < d ; ++ i ) cnt [ a [ i ] ] ++ ; for ( int i = d ; i <= n - 1 ; ++ i ) { int acc = 0 ; int low_median = - 1 , high_median = - 1 ; for ( int v = 0 ; v <= V ; ++ v ) { acc += cnt [ v ] ; if ( low_median == - 1 && acc >= ( int ) ( Math . floor ( ( d + 1 ) / 2.0 ) ) ) low_median = v ; if ( high_median == - 1 && acc >= ( int ) ( Math . ceil ( ( d + 1 ) / 2.0 ) ) ) high_median = v ; } int double_median = low_median + high_median ; if ( a [ i ] >= double_median ) answer ++ ; cnt [ a [ i - d ] ] -- ; cnt [ a [ i ] ] ++ ; } System . out . print ( answer + "NEW_LINE"); }
void maximumValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = Math . max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } System . out . println ( ans ) ; }
int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) System . out . println ( arr1 [ i ] + " ▁ " + arr2 [ j ] ) ; }
int smallest_pair ( int [ ] a , int n ) { int min = Integer . MAX_VALUE , secondMin = Integer . MAX_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
int maxSum ( int N ) { int ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; }
void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; System . out . println ( " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ " + Perimeter ) ; }
long sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( long ) Math . pow ( n , n ) + sum ( n - 1 ) ) ; }
void path_to_root ( int node ) { while ( node >= 1 ) { System . out . print ( node + " ▁ " ) ; node /= 2 ; } }
String check ( int current_row , int current_col , int destination_row , int destination_col ) { if ( current_row == destination_row ) return " POSSIBLE " ; else if ( current_col == destination_col ) return " POSSIBLE " ; else return " NOT ▁ POSSIBLE " ; }
void findSumOfAllSubsets ( int [ ] arr , int n , int k ) { int factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( int i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( int i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; int freq = factorial_N / ( factorial_d * factorial_D ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; System . out . println ( " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " + k + " ▁ is ▁ = > ▁ " + sum ) ; }
int maximumCandy ( int [ ] candies , int [ ] safety , int N , int M ) { int total = 0 ; int ans = Integer . MAX_VALUE ; boolean all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . min ( ans , safety [ i ] ) ; } else { ans = Math . min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n != 0 ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
float sphere ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; return r ; }
float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . round ( fn * PHI ) ; t ++ ; } return fn ; }
void bin ( long n ) { long i ; System . out . print ( "0" ) ; for ( i = 1 << 30 ; i > 0 ; i = i / 2 ) { if ( ( n & i ) != 0 ) { System . out . print ( "1" ) ; } else { System . out . print ( "0" ) ; } } }
boolean ispalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s . charAt ( i ) != s . charAt ( j ) ) { return false ; } } return true ; }
void main ( String [ ] args ) { int A = 6 ; double theta = 45 ; double [ ] ans = Length_Diagonals ( A , theta ) ; System . out . printf ( " % .2f " + " ▁ " + " % .2f " , ans [ 0 ] , ans [ 1 ] ) ; } }
void solve ( int n ) { int ans = 0 ; for ( int y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } System . out . print ( ans ) ; }
int maximizeFinalElement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; }
int nthTerm ( int n ) { return 4 * ( int ) Math . pow ( n , 2 ) - 3 * n + 2 ; }
int findOddPair ( int A [ ] , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
String fractionToDecimal ( int numr , int denr ) { String res = " " ; HashMap < Integer , Integer > mp = new HashMap < > ( ) ; mp . clear ( ) ; int rem = numr % denr ; while ( ( rem != 0 ) && ( ! mp . containsKey ( rem ) ) ) { mp . put ( rem , res . length ( ) ) ; rem = rem * 10 ; int res_part = rem / denr ; res += String . valueOf ( res_part ) ; rem = rem % denr ; } if ( rem == 0 ) return " " ; else if ( mp . containsKey ( rem ) ) return res . substring ( mp . get ( rem ) ) ; return " " ; }
int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
int closetAND ( int arr [ ] , int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; }
int minSteps ( int arr [ ] , int n , int k ) { int i , cnt = 0 ; int flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
int waysOfDecoding ( String s ) { long [ ] dp = new long [ s . length ( ) + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = s . charAt ( 0 ) == ' * ' ? 9 : s . charAt ( 0 ) == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s . charAt ( i - 1 ) == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s . charAt ( i - 1 ) == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s . charAt ( i - 1 ) == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s . charAt ( i ) != '0' ? dp [ i ] : 0 ; if ( s . charAt ( i - 1 ) == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s . charAt ( i - 1 ) == '2' && s . charAt ( i ) <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s . charAt ( i - 1 ) == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s . charAt ( i ) <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return ( int ) dp [ s . length ( ) ] ; }
void lengtang ( double r1 , double r2 , double d ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ direct " + " ▁ common ▁ tangent ▁ is ▁ " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }
int majorityNumber ( int arr [ ] , int n ) { int ans = - 1 ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } if ( freq . get ( arr [ i ] ) > n / 2 ) ans = arr [ i ] ; } return ans ; }
int minCost ( int [ ] cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
int countCubes ( int a , int b ) { return ( int ) ( Math . floor ( Math . cbrt ( b ) ) - Math . ceil ( Math . cbrt ( a ) ) + 1 ) ; }
String largestSubStr ( String s ) { while ( s . length ( ) != 0 && s . charAt ( s . length ( ) - 1 ) == '1' ) s = s . substring ( 0 , s . length ( ) - 1 ) ; if ( s . length ( ) == 0 ) return " - 1" ; else return s ; }
int maxSum ( int [ ] [ ] mat , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int maxSum = Integer . MIN_VALUE , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
int getSum ( int arr [ ] , int p ) { return arr . length ; }
long fun ( int marks [ ] , int n ) { long dp [ ] = new long [ n ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( int ) ( sum / n ) + 1 ) ; }
int count ( int a [ ] , int n ) { int countElements = 0 ; for ( int i = 0 ; i < n ; i ++ ) { boolean flag = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; }
int countDigit ( double n ) { return ( ( int ) Math . floor ( Math . log10 ( n ) + 1 ) ) ; }
void line ( double x0 , double y0 ) { double c = ( int ) ( 2 * y0 * x0 ) ; System . out . println ( y0 + " x " + " ▁ + ▁ " + x0 + " y ▁ = ▁ " + c ) ; }
float find_angle ( int x , int y , int z ) { int volume = x * x * y ; float ans = 0 ; if ( z < volume / 2 ) { float d = ( float ) ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = ( float ) Math . atan ( d ) ; } else { z = volume - z ; float d = ( 2 * z ) / ( float ) ( x * x * x ) ; ans = ( float ) Math . atan ( d ) ; } ans = ( float ) ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }
int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
void asciiToSentence ( String str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str . charAt ( i ) - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; System . out . print ( ch ) ; num = 0 ; } } }
int countWords ( String str ) { int count = 1 ; for ( int i = 1 ; i < str . length ( ) - 1 ; i ++ ) { if ( str . charAt ( i ) >= 65 && str . charAt ( i ) <= 90 ) count ++ ; } return count ; }
void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) System . out . print ( 1 ) ; else System . out . print ( 0 ) ; } System . out . println ( ) ; } }
boolean isPossible ( int x , int y ) { if ( ( x - y ) == 1 ) return false ; return true ; }
int maxSumArray ( int arr [ ] , int n ) { int sum = 0 ; Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } int minimum = Integer . MAX_VALUE ; for ( Map . Entry < Integer , Integer > x : m . entrySet ( ) ) minimum = Math . min ( minimum , x . getValue ( ) * x . getKey ( ) ) ; return ( sum - minimum ) ; }
int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }
void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; System . out . println ( real + " ▁ + ▁ " + imag + " i " ) ; }
int numSeq ( int n ) { return ( int ) ( ( Math . pow ( 3 , n ) + 3 * Math . pow ( - 1 , n ) ) / 4 ) ; }
int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * ( int ) Math . pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; Arrays . sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( ( i < j ) && ( arr [ i ] == x ) ) i ++ ; int y = arr [ j ] , yy = j ; while ( ( j >= i ) && ( arr [ j ] == y ) ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
int DecakismyriagonNum ( int N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
void insertAfter ( Node prev_node , int new_data ) { if ( prev_node == null ) { System . out . println ( " The ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ null " ) ; return ; } Node new_node = new Node ( new_data ) ; new_node . next = prev_node . next ; prev_node . next = new_node ; }
boolean judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
void LeftRightNode ( int preorder [ ] , int n ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > preorder [ i ] ) min = preorder [ i ] ; if ( max < preorder [ i ] ) max = preorder [ i ] ; } System . out . println ( " Leftmost ▁ node ▁ is ▁ " + min ) ; System . out . println ( " Rightmost ▁ node ▁ is ▁ " + max ) ; }
float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int Substring ( String s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
void RightRotate ( int a [ ] , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { System . out . print ( a [ n + i - k ] + " ▁ " ) ; } else { System . out . print ( a [ i - k ] + " ▁ " ) ; } } System . out . println ( ) ; }
float squareSide ( float a ) { if ( a < 0 ) return - 1 ; float x = ( 0.423f * a ) ; return x ; }
boolean solve ( String s1 , String s2 ) { boolean flag1 = false , flag2 = false ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; int l = s1 . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s1 . charAt ( i ) == '1' ) flag1 = true ; if ( s2 . charAt ( i ) == '1' ) flag2 = true ; if ( flag1 == true && flag2 == true ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
int getPosition ( int N , int M ) { if ( M > ( N / 2 ) ) { return ( M - ( N / 2 ) ) ; } return ( M + ( N / 2 ) ) ; }
void distributeN ( int A , int B , int C , int n ) { int max1 = Math . max ( A , B ) ; int max2 = Math . max ( B , C ) ; int maximum = Math . max ( max1 , max2 ) ; int sum = A + B + C ; int p = ( 3 * maximum ) - sum ; int diff = n - p ; if ( diff < 0 diff % 3 == 0 ) System . out . print ( " No " ) ; else System . out . print ( " Yes " ) ; }
void findSum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; int expSum = ( int ) ( Math . pow ( 2 , r ) ) - 1 ; System . out . println ( sum - expSum ) ; }
void printMissingElements ( int arr [ ] , int N ) { int diff = arr [ 0 ] - 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { System . out . print ( ( i + diff ) + " ▁ " ) ; diff ++ ; } } } }
int maxsubStringLength ( char [ ] S , int N ) { int arr [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; int maxLen = 0 ; int curr_sum = 0 ; HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = Math . max ( maxLen , i + 1 ) ; if ( hash . containsKey ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ; else hash . put ( curr_sum , i ) ; } return maxLen ; }
void countSubString ( String S , char C ) { int count = 0 ; int conCount = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { char ch = S . charAt ( i ) ; if ( ch == C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; System . out . println ( count ) ; }
float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
boolean findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; }
String check ( int [ ] a , int [ ] b , int Na , int Nb , int k , int m ) { if ( Na < k Nb < m ) return " No " ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return " Yes " ; } return " No " ; }
void completeSequence ( String s ) { int n = s . length ( ) ; int open = 0 , close = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) open ++ ; else close ++ ; if ( close > open ) { System . out . print ( " IMPOSSIBLE " ) ; return ; } } System . out . print ( s ) ; for ( int i = 0 ; i < open - close ; i ++ ) System . out . print ( " ) " ) ; }
void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; System . out . print ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }
void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) System . out . print ( i + " ▁ " ) ; } }
int averageRuns ( int runs , int matches , int notout ) { int out = matches - notout ; if ( out == 0 ) return - 1 ; int avg = ( runs ) / out ; return avg ; }
int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; }
int maxSelectionCount ( int a [ ] , int n ) { int res = 0 ; Arrays . sort ( a ) ; int select = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
int calculateSum ( int n ) { return ( ( int ) Math . pow ( 2 , n + 1 ) + n - 2 ) ; }
int minParentheses ( String p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . length ( ) ; ++ i ) { bal += p . charAt ( i ) == ' ( ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
int minSwaps ( int N , int M , int A [ ] [ ] , int B [ ] [ ] ) { int count01 = 0 ; int count10 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return - 1 ; }
int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
int countNum ( int [ ] arr , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
void printModulus ( int X , int Y ) { int d = Math . abs ( X - Y ) ; int i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { System . out . print ( i + " ▁ " ) ; if ( d / i != i ) System . out . print ( d / i + " ▁ " ) ; } i ++ ; } }
int SubseqWidths ( int [ ] A , int n ) { Arrays . sort ( A ) ; int [ ] pow2 = new int [ n ] ; pow2 [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }
int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = ( int ) Math . pow ( 4 , odd_indices ) ; int arr_even = ( int ) Math . pow ( 5 , even_indices ) ; return arr_odd * arr_even ; }
String balancedTernary ( int n ) { String output = " " ; while ( n > 0 ) { int rem = n % 3 ; n = n / 3 ; if ( rem == 2 ) { rem = - 1 ; n ++ ; } output = ( rem == 0 ? '0' : ( rem == 1 ) ? '1' : ' Z ' ) + output ; } return output ; }
int MinOfCubedDP ( int k ) { int [ ] DP = new int [ k + 1 ] ; int j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = Integer . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
double Mixture ( int X , int Y , int Z ) { double result1 = 0.0 , result = 0.0 ; result1 = ( ( X - Y ) / ( float ) X ) ; result = Math . pow ( result1 , Z ) ; result = result * X ; return result ; }
int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
double SumofInverseDivisors ( int N , int Sum ) { double ans = ( double ) ( Sum ) * 1.0 / ( double ) ( N ) ; return ans ; }
double vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return Math . sqrt ( sum ) ; }
int countSubSeq ( String str , int len ) { int ans = 0 ; int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) ans += mul ; mul *= 2 ; } return ans ; }
boolean isPentadecagon ( int N ) { double n = ( 11 + Math . sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; }
boolean isSubSeqDivisible ( String str ) { int i , j , k , l = str . length ( ) ; int arr [ ] = new int [ l ] ; for ( i = 0 ; i < l ; i ++ ) arr [ i ] = str . charAt ( i ) - '0' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
boolean EqualNumber ( int A , int B ) { if ( ( A ^ B ) != 0 ) return true ; else return false ; }
String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return " Yes " ; return " No " ; }
int findUnique ( int a [ ] , int n , int k ) { byte sizeof_int = 4 ; int INT_SIZE = 8 * sizeof_int ; int count [ ] = new int [ INT_SIZE ] ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; int res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
int Maxcost ( String s , int [ ] cost ) { ' ' ▁ Initialize ▁ the ▁ count ' '' int maxcost = 0 ; int i = 0 ; while ( i < s . length ( ) - 1 ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { if ( cost [ i ] > cost [ i + 1 ] ) maxcost += cost [ i ] ; else { maxcost += cost [ i + 1 ] ; cost [ i + 1 ] = cost [ i ] ; } } i ++ ; } return maxcost ; }
double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
void GenerateArray ( int N , int X ) { int prev_xor = X ; for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( i ^ prev_xor ) ; if ( i != N ) { System . out . print ( " ▁ " ) ; } prev_xor = i ; } }
int MinOperation ( int a [ ] , int b [ ] , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
int distinctCount ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( Math . abs ( arr [ i ] ) ) ; return s . size ( ) ; }
int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
void countWays ( int n ) { if ( n <= 2 ) { System . out . print ( " - 1" ) ; } else { int ans = ( n - 1 ) * ( n - 2 ) / 2 ; System . out . print ( ans ) ; } }
void findMinLength ( int arr [ ] , int N ) { int front = 0 , back = N - 1 ; while ( front < back ) { int x = arr [ front ] ; if ( arr [ front ] != arr [ back ] ) break ; while ( arr [ front ] == x && front <= back ) front ++ ; while ( arr [ back ] == x && front <= back ) back -- ; } System . out . println ( back - front + 1 ) ; }
int TetracontaoctagonalNum ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
int sumBitDifferences ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
double distance ( int r , int R ) { double d = Math . sqrt ( Math . pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
void findMinimumTime ( String tasks , int K ) { Map < Character , Integer > map = new HashMap < > ( ) ; int curr_time = 0 ; for ( char c : tasks . toCharArray ( ) ) { if ( map . containsKey ( c ) ) { if ( curr_time - map . get ( c ) <= K ) { curr_time += K - ( curr_time - map . get ( c ) ) + 1 ; } } map . put ( c , curr_time ) ; curr_time ++ ; } System . out . println ( curr_time ) ; }
long centered_heptagonal_num ( long n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
void smallestNumber ( int N ) { System . out . print ( N * Math . ceil ( Math . pow ( 2 , ( N - 1 ) ) / N ) ) ; }
int findRepeatFirstN2 ( String s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
boolean isStar ( int N ) { double n = ( 6 + Math . sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
boolean solve ( int a [ ] , int n ) { int mx = Integer . MIN_VALUE ; for ( int j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = Math . max ( mx , a [ j - 1 ] ) ; } return true ; }
int longestSubstring ( String s ) { int cnt = 1 , maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
char Colour_Combination ( String s ) { char temp = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( temp != s . charAt ( i ) ) { if ( ( temp == ' B ' temp == ' G ' ) && ( s . charAt ( i ) == ' G ' || s . charAt ( i ) == ' B ' ) ) temp = ' Y ' ; else if ( ( temp == ' B ' temp == ' Y ' ) && ( s . charAt ( i ) == ' Y ' || s . charAt ( i ) == ' B ' ) ) temp = ' G ' ; else temp = ' B ' ; } } return temp ; }
int totalTriangles ( int h , int v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; int total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
int lucas ( int n ) { int a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
boolean checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
void createArray ( int n , int s ) { if ( 2 * n <= s ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { System . out . print ( 2 + " ▁ " ) ; s -= 2 ; } System . out . println ( s ) ; System . out . println ( 1 ) ; } else System . out . print ( " - 1" ) ; }
void solve ( int arr [ ] , int n ) { int countzeroes = 0 ; int countones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( Math . abs ( countzeroes - countones ) == 1 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
int sumoflength ( int [ ] arr , int n ) { Set < Integer > s = new HashSet < > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; }
boolean prodSquare ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
boolean isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) System . out . println ( " odd " ) ; else System . out . println ( " even " ) ; }
boolean sumSquare ( int n ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i * i <= n ; ++ i ) { s . put ( i * i , 1 ) ; if ( s . containsKey ( n - i * i ) ) { System . out . println ( ( int ) Math . sqrt ( n - i * i ) + " ^ 2 ▁ + ▁ " + i + " ^ 2" ) ; return true ; } } return false ; }
boolean isCentereddecagonal ( int N ) { double n = ( 5 + Math . sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
void isConversionPossible ( String s1 , String s2 , int x ) { int diff = 0 , n ; n = s1 . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 . charAt ( i ) == s2 . charAt ( i ) ) continue ; diff = ( ( int ) ( s2 . charAt ( i ) - s1 . charAt ( i ) ) + 26 ) % 26 ; if ( diff > x ) { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; }
boolean isDefeat ( String s1 , String s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) || ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) ) continue ; else if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == ' Z ' ) || ( s1 . charAt ( i ) == ' Z ' && s2 . charAt ( i ) == '0' ) ) continue ; else { return true ; } } return false ; }
int nearest ( int n ) { int prevSquare = ( int ) Math . sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; }
void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . print ( get_min + " ▁ " + get_mid + " ▁ " + get_max ) ; }
int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; }
int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
int totalSubSets ( int n , int l , int r ) { int zero = ( int ) Math . floor ( ( double ) r / 3 ) - ( int ) Math . ceil ( ( double ) l / 3 ) + 1 ; int one = ( int ) Math . floor ( ( double ) ( r - 1 ) / 3 ) - ( int ) Math . ceil ( ( double ) ( l - 1 ) / 3 ) + 1 ; int two = ( int ) Math . floor ( ( double ) ( r - 2 ) / 3 ) - ( int ) Math . ceil ( ( double ) ( l - 2 ) / 3 ) + 1 ; int [ ] [ ] dp = new int [ n ] [ 3 ] ; dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( int i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
void findLast ( int mat [ ] [ ] ) { int m = 3 ; int n = 3 ; Set < Integer > rows = new HashSet < Integer > ( ) ; Set < Integer > cols = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( mat [ i ] [ j ] > 0 ) ) { rows . add ( i ) ; cols . add ( j ) ; } } } int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ; int choices = Math . min ( avRows , avCols ) ; if ( ( choices & 1 ) != 0 ) System . out . println ( " P1" ) ; else System . out . println ( " P2" ) ; }
int count ( String N , int X , String subStr , int index , int n ) { if ( index == n ) return 0 ; String a = subStr + N . charAt ( index ) ; int b = 0 ; if ( Long . valueOf ( a ) % X == 0 ) b = 1 ; int m1 = count ( N , X , a , index + 1 , n ) ; int m2 = b + count ( N , X , " " , index + 1 , n ) ; return Math . max ( m1 , m2 ) ; }
long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
int permutationCoeff ( int n , int k ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }
int Centered_Triangular_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
double findMedian ( int a [ ] , int n ) { Arrays . sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
int count ( Node head , int key ) { if ( head == null ) return 0 ; if ( head . data == key ) return 1 + count ( head . next , key ) ; return count ( head . next , key ) ; }
float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float radius = ( float ) Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
int longestSubArray ( int arr [ ] , int n ) { boolean isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
void checkSolution ( int a , int b , int c ) { if ( a == c ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
void mulsum ( int arr [ ] , int n , int N ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } System . out . println ( sum ) ; }
boolean divisibleBy36 ( String num ) { int l = num . length ( ) ; if ( l == 0 ) return false ; if ( l == 1 && num . charAt ( 0 ) != '0' ) return false ; int two_digit_num = ( num . charAt ( l - 2 ) - '0' ) * 10 + ( num . charAt ( l - 1 ) - '0' ) ; if ( two_digit_num % 4 != 0 ) return false ; int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) sum += ( num . charAt ( i ) - '0' ) ; if ( sum % 9 != 0 ) return false ; return true ; }
boolean isRepdigit ( int num , int b ) { int prev = - 1 ; while ( num != 0 ) { int digit = num % b ; num /= b ; if ( prev != - 1 && digit != prev ) return false ; prev = digit ; } return true ; }
int CountTriplets ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int first = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
int findAns ( int [ ] [ ] mat , int x , int y , int n , int m ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += Math . abs ( x - i ) + Math . abs ( y - j ) ; } } } return ans ; }
int maxRepeating ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ ( arr [ i ] % k ) ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
int FindMaxS ( int X , int Y , int Z , int n , int [ ] A , int [ ] B , int [ ] C ) { if ( X < 0 Y < 0 Z < 0 ) return Integer . MIN_VALUE ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = Math . max ( ch , Math . max ( ca , Math . max ( co , no ) ) ) ; return dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; }
int count ( int n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; int table [ ] = new int [ n + 1 ] ; int i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; }
int maxTripletSum ( int arr [ ] , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
boolean adjacentSet ( int n ) { int x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }
void maxGcd ( int a , int b ) { System . out . println ( Math . abs ( a - b ) ) ; }
void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod ) { if ( n == 1 ) { System . out . println ( " Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; }
void sortExceptUandL ( int a [ ] , int l , int u , int n ) { int b [ ] = new int [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; Arrays . sort ( b ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
int maxOR ( int [ ] arr , int n ) { int max_value = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; }
boolean inProportion ( int [ ] arr ) { int n = 4 ; Arrays . sort ( arr ) ; long extremes = ( long ) arr [ 0 ] * ( long ) arr [ 3 ] ; long means = ( long ) arr [ 1 ] * ( long ) arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
int findWaysToPair ( int p ) { int dp [ ] = new int [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }
double decdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.902 * a ; return d ; }
int doMatch ( String A , String B ) { for ( int i = 0 ; i < A . length ( ) ; i ++ ) { if ( A . charAt ( i ) != ' * ' && B . charAt ( i ) != ' * ' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }
int countTriplets ( int N ) { int cnt = 0 ; for ( int A = 1 ; A <= N ; ++ A ) { for ( int B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
int findMinSum ( int mat [ ] [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }
void generatepermutation ( int N ) { Vector < Integer > answer = new Vector < Integer > ( ) ; answer . add ( N ) ; for ( int i = 1 ; i < N ; i ++ ) { answer . add ( i ) ; } for ( int i : answer ) System . out . print ( i + " ▁ " ) ; }
int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
int countSubstrs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; }
int lastDigit2PowerN ( int n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
boolean IsPrime ( int i ) { if ( i % 2 == 0 && i != 2 ) return false ; else { for ( int j = 3 ; j <= Math . sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) return false ; } return true ; } }
int MaximumPath ( int Mat [ ] [ ] ) { int result = 0 ; int dp [ ] [ ] = new int [ N ] [ N + 2 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
boolean allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
void findTemperature ( int x , int y , int s ) { double Day1 , Day2 ; double diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; System . out . println ( " Day1 ▁ : ▁ " + Day1 ) ; System . out . println ( " Day2 ▁ : ▁ " + Day2 ) ; }
double numberOfTriangles ( int n ) { double ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }
int areaSquare ( int side ) { int area = side * side ; return area ; }
int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
int findNumber ( int N ) { int [ ] ans = { 1 , 2 , 4 , 8 , 7 , 5 } ; return ans [ N % 6 ] ; }
void shuffle ( int N , int key ) { int NO_OF_BITS = N ; int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } System . out . print ( reverse_num ) ; }
void FindSub ( String str , String res , int i ) { if ( i == str . length ( ) ) { if ( res . length ( ) > 0 ) { System . out . print ( res + " ▁ " ) ; } return ; } char ch = str . charAt ( i ) ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + ( int ) ch , i + 1 ) ; ; }
void findAngle ( double M1 , double M2 ) { double angle = Math . abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; double ret = Math . atan ( angle ) ; double val = ( ret * 180 ) / PI ; System . out . println ( val ) ; }
int binary_searched_find_x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( Math . pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; }
boolean sentencePalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { char getAtl = str . charAt ( l ) ; char getAth = str . charAt ( h ) ; if ( ! ( getAtl >= ' a ' && getAtl <= ' z ' ) ) l ++ ; else if ( ! ( getAth >= ' a ' && getAth <= ' z ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; }
int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; }
int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
int maxbalancedprefix ( String str , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
boolean productOfSingelDgt ( int n ) { if ( n >= 0 && n <= 9 ) return true ; int [ ] prime = { 2 , 3 , 5 , 7 } ; for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
int minimumStepReqArr ( int [ ] arr , int N ) { int cntStep = 0 ; N += 1 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }
void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }
void minimumIncreasingSubsequences ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int count = 0 ; int i = 0 ; while ( i < N ) { int x = arr [ i ] ; int freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = Math . max ( count , freqX ) ; } System . out . print ( count ) ; }
int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) { int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Integer . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }
long increment ( long i ) { i = - ( ~ i ) ; return i ; }
float squareArea ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; }
int findMin ( int [ ] arr , int N , int k ) { int pairs = 0 ; for ( int i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return - 1 ; else return 2 * k + N - 1 ; }
void nearestPerfectSquare ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = ( int ) Math . sqrt ( arr [ i ] ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) System . out . print ( a + " ▁ " ) ; else System . out . print ( b + " ▁ " ) ; } }
int printNthElement ( int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
float weightedMean ( int X [ ] , int W [ ] , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) ( numWeight ) / sum ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int smallestNum ( int n ) { int res = 1 ; for ( int i = 2 ; ; i *= 2 ) { int length = ( int ) ( Math . log10 ( i ) ) + 1 ; if ( length == n ) return ( int ) ( Math . log ( i ) / Math . log ( 2 ) ) ; } }
int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
int findOddPair ( int A [ ] , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
void maximizeProduct ( int N ) { int MSB = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) { X += 1 << i ; Y += 1 << i ; } } System . out . println ( X + " ▁ " + Y ) ; }
int kthNonDivisible ( int N , int K ) { return ( int ) ( K + Math . floor ( ( K - 1 ) / ( N - 1 ) ) ) ; }
int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
void precompute ( ) { int fact = 1 ; for ( int i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m . put ( fact , i ) ; } }
int maxPointCount ( int arr [ ] , int K , int size ) { int curr_points = 0 ; int max_points = 0 ; for ( int i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; int j = size - 1 ; for ( int i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = Math . max ( curr_points , max_points ) ; j -- ; } return max_points ; }
int CountSubarray ( int arr [ ] , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
int findLCS ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } return mp . size ( ) ; }
int findDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
StringBuilder findMaximumNum ( StringBuilder str , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str . charAt ( i ) != '9' ) { str . setCharAt ( i , '9' ) ; k -- ; } } return str ; }
char FindKthChar ( String str , int K , int X ) { char ans = ' ▁ ' ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int digit = ( int ) str . charAt ( i ) - 48 ; int range = ( int ) Math . pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str . charAt ( i ) ; break ; } } return ans ; }
void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) System . out . print ( " - 1" ) ; else { System . out . print ( d ) ; k -- ; while ( k -- > 0 ) System . out . print ( "0" ) ; } }
int gonNum257 ( int n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
boolean isTidy ( int num ) { int prev = 10 ; while ( num != 0 ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
void minimumDiff ( int [ ] arr , int N ) { int res = arr [ 0 ] , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min_diff = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( Math . abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = Math . abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } System . out . println ( res ) ; }
int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
int largestNum ( int n ) { int num = 0 ; for ( int i = 0 ; i <= 32 ; i ++ ) { int x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
void gcdMax ( int [ ] a , int [ ] b , int n , int N ) { int [ ] cnt = new int [ N ] ; int [ ] first = new int [ N ] ; int [ ] second = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; int x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; System . out . println ( first [ x ] + " ▁ " + second [ x ] ) ; }
void canMakeEqual ( String S ) { int N = S . length ( ) ; int weightOfString = 0 ; for ( int i = 0 ; i < N ; i ++ ) { weightOfString += S . charAt ( i ) - ' a ' + 1 ; } if ( weightOfString % N == 0 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
int Max_Sum ( int arr1 [ ] , int arr2 [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) { if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) System . out . print ( A [ i ] + " ▁ " + A [ j ] + " ▁ " + A [ k ] + " ▁ " + A [ l ] ) ; } } } } }
int findK ( int A [ ] [ ] , int i , int j , int n , int m , int k ) { if ( n < 1 m < 1 ) return - 1 ; if ( k <= m ) return A [ i + 0 ] [ j + k - 1 ] ; if ( k <= ( m + n - 1 ) ) return A [ i + ( k - m ) ] [ j + m - 1 ] ; if ( k <= ( m + n - 1 + m - 1 ) ) return A [ i + n - 1 ] [ j + m - 1 - ( k - ( m + n - 1 ) ) ] ; if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) return A [ i + n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ j + 0 ] ; return findK ( A , i + 1 , j + 1 , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) ; }
void maximumSumPermutation ( int [ ] arr ) { int N = arr . length ; Arrays . sort ( arr ) ; int temp = arr [ 0 ] ; arr [ 0 ] = arr [ N - 1 ] ; arr [ N - 1 ] = temp ; for ( int i : arr ) { System . out . print ( i + " ▁ " ) ; } }
int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }
int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
int minOps ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int max = arr [ arr . length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
int LIS ( int a [ ] , int n ) { int dp [ ] = new int [ N ] , d [ ] = new int [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
void findSide ( double a , double B , double C ) { double A = 180 - C - B ; double radA = ( Math . PI * ( A / 180 ) ) ; double radB = ( Math . PI * ( B / 180 ) ) ; double radC = ( Math . PI * ( C / 180 ) ) ; double b = ( a / Math . sin ( radA ) * Math . sin ( radB ) ) ; double c = ( a / Math . sin ( radA ) * Math . sin ( radC ) ) ; System . out . printf ( " % .15f " , b ) ; System . out . printf ( " ▁ % .15f " , c ) ; }
void first_digit ( int x , int y ) { int length = ( int ) ( Math . log ( x ) / Math . log ( y ) + 1 ) ; int first_digit = ( int ) ( x / Math . pow ( y , length - 1 ) ) ; System . out . println ( first_digit ) ; }
int maxOperations ( int X , int Y ) { if ( X > Y ) return - 1 ; int diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
void findPoint ( int n , int h ) { for ( int i = 1 ; i < n ; i ++ ) System . out . printf ( " % .2f ▁ " , Math . sqrt ( i / ( n * 1.0 ) ) * h ) ; }
long minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
String find_number ( int N , int K ) { String r ; if ( N % 100 == 0 ) { N += 1 ; r = String . valueOf ( N ) ; } else { r = String . valueOf ( N ) ; } for ( int i = 1 ; i <= K ; i ++ ) r += "00" ; return r ; }
long computeXOR ( int n ) { int x = n & 3 ; switch ( x ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } return 0 ; }
int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
int countSubStr ( char str [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) res ++ ; } } } return res ; }
boolean possibleToReach ( int a , int b ) { int c = ( int ) Math . cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
int findSubsequenceCount ( String S , String T ) { int m = T . length ( ) ; int n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
void minNum ( int n ) { if ( n < 3 ) System . out . println ( - 1 ) ; else System . out . println ( 210 * ( ( int ) ( Math . pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; }
int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' a ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s . charAt ( i ) == ' b ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s . charAt ( i ) == ' c ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
int SubArrayProdct ( int arr [ ] , int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result *= Math . pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; return result ; }
int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; Arrays . sort ( arr ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
int countTotalDistinct ( String str ) { int cnt = 0 ; HashSet < String > items = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { String temp = " " ; HashSet < Character > ans = new HashSet < > ( ) ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str . charAt ( j ) ; ans . add ( str . charAt ( j ) ) ; if ( ! items . contains ( temp ) ) { items . add ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; }
void canBreakN ( long n ) { for ( long i = 2 ; ; i ++ ) { long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long k = n - m ; if ( k % i != 0 ) continue ; System . out . println ( i ) ; return ; } System . out . println ( " - 1" ) ; }
int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
int countPairs ( int X [ ] , int Y [ ] , int m , int n ) { int [ ] suffix = new int [ 1005 ] ; long total_pairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( int i = ( int ) 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return ( int ) total_pairs ; }
double solve ( int s ) { double area = ( 1.732 * Math . pow ( s , 2 ) ) / 8 ; return area ; }
void print ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j ) System . out . println ( a [ i ] + " ▁ " + a [ j ] ) ; } } }
int nth_group ( int n ) { return n * ( 2 * ( int ) Math . pow ( n , 2 ) + 1 ) ; }
int minCostToMakeElementEqual ( int a [ ] , int n ) { int y ; if ( n % 2 == 1 ) y = a [ n / 2 ] ; else y = ( a [ n / 2 ] + a [ ( n - 2 ) / 2 ] ) / 2 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) s += Math . abs ( a [ i ] - y ) ; return s ; }
boolean isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
int countOddSquares ( int n , int m ) { return ( int ) Math . pow ( ( double ) m , 0.5 ) - ( int ) Math . pow ( ( double ) n - 1 , 0.5 ) ; }
int properDivisorSum ( int n ) { int sum = 0 ; int i ; for ( i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; }
int HexacontatetragonNum ( int n ) { return ( 62 * n * n - 60 * n ) / 2 ; }
int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 0 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; }
void no_of_moves ( int [ ] [ ] Matrix , int x , int y ) { int moves = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += Math . abs ( x - i ) ; moves += Math . abs ( y - j ) ; } } } System . out . println ( moves ) ; }
int findSteps ( int n , int m , int a [ ] ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
int count ( int arr [ ] , int low , int high , int x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , ( low + high ) / 2 , x ) + count ( arr , 1 + ( low + high ) / 2 , high , x ) ; }
void printOdds ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; int set_bit = res & ( ~ ( res - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit ) != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( x + " ▁ " + y ) ; }
float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
int solve ( Vector < Integer > values , Vector < Integer > salary ) { int ret = 1 ; int amt = 0 ; Collections . sort ( values ) ; Collections . sort ( salary ) ; while ( salary . size ( ) > 0 ) { while ( values . size ( ) > 0 && values . get ( values . size ( ) - 1 ) >= salary . get ( salary . size ( ) - 1 ) ) { amt ++ ; values . remove ( values . size ( ) - 1 ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . remove ( salary . size ( ) - 1 ) ; } return ret ; }
void string ( int l , int x , int y ) { int p = 97 ; for ( int j = 0 ; j < l ; j ++ ) { char ans = ( char ) ( p + ( j % y ) ) ; System . out . print ( ans ) ; } }
int numberOfWays ( int n , int k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= ( int ) Math . pow ( 2 , k ) ) { int curr_val = ( int ) Math . pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; }
void equation_ellipse ( float x1 , float y1 , float a , float b , float c , float e ) { float t = a * a + b * b ; float a1 = t - e * ( a * a ) ; float b1 = t - e * ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; float e1 = - 2 * e * a * b ; float f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; System . out . println ( " Equation ▁ of ▁ ellipse ▁ is ▁ " ) ; System . out . print ( a1 + " ▁ x ^ 2 ▁ + ▁ " + b1 + " ▁ y ^ 2 ▁ + ▁ " + c1 + " ▁ x ▁ + ▁ " + d1 + " ▁ y ▁ + ▁ " + e1 + " ▁ xy ▁ + ▁ " + f1 + " ▁ = ▁ 0" ) ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
int find_max ( int i , int sum , int [ ] v , int k ) { if ( i == v . length ) return 0 ; if ( dp [ i ] [ sum ] != - 1 ) return dp [ i ] [ sum ] ; int ans = 0 ; if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) ans = find_max ( i + 1 , sum , v , k ) ; if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) ans = Math . max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) ; return dp [ i ] [ sum ] = ans ; }
int getCount ( int rows , int columns , int [ ] [ ] A ) { int res = 0 ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = i + 1 ; j < rows ; j ++ ) { if ( A [ i ] [ 0 ] * A [ j ] [ 1 ] == A [ i ] [ 1 ] * A [ j ] [ 0 ] ) { res ++ ; } } } return res ; }
void SubMasks ( int N ) { for ( int S = N ; S > 0 ; S = ( S - 1 ) & N ) { System . out . print ( S + " ▁ " ) ; } }
int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
void sortArray ( int A [ ] , int N ) { int x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } System . out . print ( " Sorted ▁ Array : ▁ " ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } else { System . out . print ( " - 1" ) ; } }
int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }
long largestNumber ( int N ) { if ( N > 45 ) return - 1 ; int num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
void printFourSquares ( int a ) { for ( int i = 0 ; i * i <= a ; i ++ ) { for ( int j = i ; j * j <= a ; j ++ ) { for ( int k = j ; k * k <= a ; k ++ ) { for ( int l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { System . out . print ( a + " ▁ = ▁ " + i + " * " + i + " ▁ + ▁ " + j + " * " + j + " ▁ + ▁ " ) ; System . out . println ( k + " * " + k + " ▁ + ▁ " + l + " * " + l ) ; } } } } } }
int countBuildings ( int arr [ ] , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
int minimumSteps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
char lastRemovedCharacter ( char [ ] str ) { int n = str . length ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == '0' ) { return ( char ) ( '1' - str [ n - 1 ] + '0' ) ; } else return str [ n - 1 ] ; }
String updateString ( String S , String A , String B ) { int l = A . length ( ) ; for ( int i = 0 ; i + l <= S . length ( ) ; i ++ ) { String curr = S . substring ( i , i + l ) ; if ( curr . equals ( A ) ) { String new_string = S . substring ( 0 , i ) + B + S . substring ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } else { String new_string = S . substring ( 0 , i ) + A + S . substring ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } } return S ; }
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) System . out . println ( "1" ) ; else System . out . println ( "0" ) ; } int mul = ( int ) Math . pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; System . out . println ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
void minimumMEX ( int arr [ ] , int N , int K ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s . add ( i ) ; for ( int i = 0 ; i < K ; i ++ ) s . remove ( arr [ i ] ) ; int mex = s . iterator ( ) . next ( ) ; for ( int i = K ; i < N ; i ++ ) { s . remove ( arr [ i ] ) ; s . add ( arr [ i - K ] ) ; int firstElem = s . iterator ( ) . next ( ) ; mex = Math . min ( mex , firstElem ) ; } System . out . print ( mex + " ▁ " ) ; }
void findSolutions ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( ( i + N / i ) % 2 == 0 ) { count ++ ; } } } System . out . print ( 4 * count ) ; }
int leastValue ( int P , int A , int N , int a [ ] ) { int ans = - 1 ; float tmp = Float . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { float t = ( float ) ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
int area_fun ( int side ) { int area = side * side ; return area ; }
boolean checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
void group_formed ( String S ) { int count = 1 ; for ( int i = 0 ; i < S . length ( ) - 1 ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i + 1 ) ) count += 1 ; } System . out . println ( count ) ; }
void solve ( int N ) { int ans = 0 ; while ( N != 0 ) { ans += N ; N /= 2 ; } System . out . println ( ans ) ; }
void segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
void removeAll ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; }
void printPairs ( int arr [ ] , int n ) { Set < Integer > pairs = new HashSet < Integer > ( ) ; boolean pair_exists = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) pairs . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) if ( pairs . contains ( - arr [ i ] ) ) { System . out . println ( arr [ i ] + " , ▁ " + - arr [ i ] ) ; pair_exists = true ; } } if ( pair_exists == false ) System . out . println ( " No ▁ such ▁ pair ▁ exists " ) ; }
int lenghtOfLongestAP ( int A [ ] , int n ) { Map < Integer , Map < Integer , Integer > > dp = new HashMap < Integer , Map < Integer , Integer > > ( ) ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; Map < Integer , Integer > temp ; if ( dp . containsKey ( d ) ) { temp = dp . get ( d ) ; if ( temp . containsKey ( i ) ) temp . put ( j , temp . get ( i ) + 1 ) ; else temp . put ( j , 2 ) ; } else { temp = new HashMap < Integer , Integer > ( ) ; temp . put ( j , 2 ) ; } dp . put ( d , temp ) ; res = Math . max ( res , temp . get ( j ) ) ; } } return res ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
int calculateWays ( int arr1 [ ] , int arr2 [ ] , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( int c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( int d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
int areaOfSquare ( int S ) { int area = S * S ; return area ; }
float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; }
boolean graphExists ( ArrayList a , int n ) { while ( true ) { Collections . sort ( a , Collections . reverseOrder ( ) ) ; if ( ( int ) a . get ( 0 ) == 0 ) return true ; int v = ( int ) a . get ( 0 ) ; a . remove ( a . get ( 0 ) ) ; if ( v > a . size ( ) ) return false ; for ( int i = 0 ; i < v ; i ++ ) { a . set ( i , ( int ) a . get ( i ) - 1 ) ; if ( ( int ) a . get ( i ) < 0 ) return false ; } } }
void solve ( String s , int k ) { int count = 0 , length = 0 , pos = 0 ; HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; length ++ ; if ( length > k ) { m . put ( s . charAt ( pos ) , m . get ( s . charAt ( pos ) ) - 1 ) ; pos ++ ; length -- ; } if ( length == k && m . get ( s . charAt ( i ) ) == length ) count ++ ; } System . out . println ( count ) ; }
int findCnt ( int [ ] arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = true ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
boolean isPossible ( int x , int y , int k ) { int minMoves = Math . abs ( x ) + Math . abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
int ceilDifference ( int arr [ ] , int n , int x ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += Math . ceil ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int totalCeilSum = ( int ) Math . ceil ( ( double ) ( totalSum ) / ( double ) ( x ) ) ; return Math . abs ( perElementSum - totalCeilSum ) ; }
void print ( String str1 ) { char str [ ] = str1 . toCharArray ( ) ; System . out . print ( str [ 0 ] ) ; for ( int i = 1 ; i < str . length ; i ++ ) { if ( ( str [ i ] == str [ i - 1 ] + 1 ) || ( str [ i ] == str [ i - 1 ] - 1 ) ) { System . out . print ( str [ i ] ) ; } else { System . out . print ( "NEW_LINE" + str[i]); } } }
void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; System . out . println ( " A ▁ = ▁ " + A + " B = " + B); }
void minimumCost ( int [ ] cost , int n , int x ) { int [ ] dp = new int [ n + 2 ] ; dp [ 0 ] = cost [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , Math . min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } System . out . println ( dp [ n - 1 ] ) ; }
int numOfWays ( int a [ ] [ ] , int n , int i , HashSet < Integer > blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && ! blue . contains ( j ) ) { blue . add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . remove ( j ) ; } } return count ; }
boolean isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; }
int countSticks ( String str , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str . charAt ( i ) - '0' ] ) ; } return cnt ; }
int maxOR ( int arr [ ] , int n ) { int max_value = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int number_of_bits = ( int ) ( ( Math . log ( max_value ) ) ) + 2 ; int complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = Math . max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
void check ( int n , int m ) { if ( n == 2 m == 2 n % m == 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
long fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
int getMinCost ( int [ ] A , int [ ] B , int N ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
float findRadiusOfcircumcircle ( float n , float a ) { if ( n < 0 a < 0 ) return - 1 ; float radius = ( float ) ( a / Math . sqrt ( 2 - ( 2 * Math . cos ( 360 / n ) ) ) ) ; return radius ; }
int getCount ( int N , int M ) { int total_count = 0 ; total_count += ( N / 10 ) ; int x = ( N / 10 ) * 10 ; if ( ( N - x ) >= M ) { total_count = total_count + 1 ; } return total_count ; }
int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
int getDivisors ( int min , int n ) { int total = 0 ; for ( int i = min ; i < n ; ++ i ) if ( n % i == 0 && n / i >= i ) { ++ total ; if ( n / i > i ) total += getDivisors ( i , n / i ) ; } return total ; }
void findNum ( int n , int k ) { int q = k / ( n - 1 ) ; int r = k % ( n - 1 ) ; int a = 0 ; if ( r != 0 ) a = ( n * q ) + r ; else a = ( n * q ) - 1 ; System . out . println ( a ) ; }
double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; }
void printOriginalMatrix ( int a [ ] , int b [ ] , int [ ] [ ] mat ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) System . out . print ( Math . min ( a [ i ] , b [ j ] ) + " ▁ " ) ; else System . out . print ( "0" + " ▁ " ) ; } System . out . println ( ) ; } }
boolean prodSquare ( int n ) { HashMap < Float , Float > s = new HashMap < Float , Float > ( ) ; for ( int i = 2 ; i * i <= n ; ++ i ) { s . put ( ( float ) ( i * i ) , ( float ) 1 ) ; if ( s . containsKey ( ( float ) n / ( i * i ) ) ) return true ; } return false ; }
double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = Math . toRadians ( lat2 - lat1 ) ; double dLon = Math . toRadians ( lon2 - lon1 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; double rad = 6371 ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; }
double findRadius ( double r1 , double r2 , double r3 ) { double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * Math . sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 ; }
double areaCircle ( double b ) { double area = ( double ) 3.1415926 * b * b ; return area ; }
void sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } }
String printBinary ( double num ) { if ( num >= 1 num <= 0 ) return " ERROR " ; StringBuilder binary = new StringBuilder ( ) ; double frac = 0.5 ; binary . append ( " . " ) ; while ( num > 0 ) { if ( binary . length ( ) >= 32 ) return " ERROR " ; if ( num >= frac ) { binary . append ( 1 ) ; num -= frac ; } else binary . append ( 0 ) ; frac /= 2 ; } return binary . toString ( ) ; }
void countSamePrefixSuffix ( String s , int n ) { String prefix = " " ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix += s . charAt ( i ) ; String suffix = s . substring ( n - 1 - i , n ) ; if ( prefix . equals ( suffix ) ) { System . out . print ( prefix . length ( ) + " ▁ " ) ; } } }
int findMin ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; int x = ( int ) Math . exp ( sum / n ) ; return x + 1 ; }
String getWinner ( String str , int len ) { int total = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' S ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " First " ; return " Second " ; }
int FindElement ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { int m = sum / n ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return - 1 ; }
float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; }
int solution ( int arr [ ] , int x ) { int closestSum = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = i + 1 ; j < arr . length ; j ++ ) { for ( int k = j + 1 ; k < arr . length ; k ++ ) { if ( Math . abs ( x - closestSum ) > Math . abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) ; } } } return closestSum ; }
void printSubstrings ( int n ) { int s = ( int ) Math . log10 ( n ) ; int d = ( int ) ( Math . pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { System . out . println ( n / d ) ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } }
int minsteps ( int n , int m ) { if ( m > n ) { return - 1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }
String xoring ( String a , String b , int n ) { String ans = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( a . charAt ( i ) == b . charAt ( i ) ) ans += "0" ; else ans += "1" ; } return ans ; }
int distinctRemainders ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) ; return ( 1 + ( n / 2 ) ) ; }
void radius ( double n , double d ) { System . out . print ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " + d / ( ( n - 1 ) * Math . sqrt ( 2 ) ) ) ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
void decode_String ( String str , int K ) { String ans = " " ; for ( int i = 0 ; i < str . length ( ) ; i += K ) ans += str . charAt ( i ) ; for ( int i = str . length ( ) - ( K - 1 ) ; i < str . length ( ) ; i ++ ) ans += str . charAt ( i ) ; System . out . println ( ans ) ; }
int HogbenNumber ( int a ) { int p = ( int ) ( Math . pow ( a , 2 ) - a + 1 ) ; return p ; }
int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) { int i = 0 , j = 0 ; Arrays . sort ( set1 ) ; Arrays . sort ( set2 ) ; while ( i < set1 . length && j < set2 . length ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } return true ; }
int count_required_sequence ( int n , int arr [ ] ) { int total_required_subsequence = 0 ; int total_n_required_subsequence = 0 ; int [ ] [ ] dp = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { int turn_required = 0 ; for ( int j = - 1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j ] [ 0 ] ; int required_end_i = ( total_required_subsequence + turn_required ) ; int n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] ] [ 1 ] += required_end_i ; dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; } return total_required_subsequence ; }
int findkthElement ( int arr [ ] , int n , int K ) { int l = 0 ; int h = n - 1 , r ; while ( l + 1 < h ) { int mid = ( l + h ) / 2 ; if ( arr [ l ] >= arr [ mid ] ) l = mid ; else h = mid ; } if ( arr [ l ] < arr [ h ] ) r = l ; else r = h ; if ( K <= r + 1 ) return arr [ r + 1 - K ] ; else return arr [ n - ( K - ( r + 1 ) ) ] ; }
int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }
int calculateSum ( int n ) { return ( ( int ) Math . pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / ( int ) Math . pow ( 9 , 3 ) - n * ( n + 1 ) / 18 ; }
long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . floor ( x ) + 1 ; }
void countDigits ( String st , int n ) { if ( n > 0 ) { int cnt = 1 , i ; String st2 = " " ; for ( i = 1 ; i < st . length ( ) ; i ++ ) { if ( st . charAt ( i ) == st . charAt ( i - 1 ) ) cnt ++ ; else { st2 += ( ( char ) 0 + ( char ) cnt ) ; st2 += st . charAt ( i - 1 ) ; cnt = 1 ; } } st2 += ( ( char ) 0 + ( char ) cnt ) ; st2 += st . charAt ( i - 1 ) ; countDigits ( st2 , -- n ) ; } else System . out . print ( st ) ; }
void radius ( int n , int d ) { System . out . print ( " The ▁ radius ▁ of ▁ each ▁ circle ▁ is ▁ " + d / ( 2 * n - 2 ) ) ; }
int minimiseMedian ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return Math . abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
void generateString ( int n ) { String s = " " ; for ( int i = 0 ; i < n ; i ++ ) s += ( ( i & 2 ) > 1 ? ' b ' : ' a ' ) ; System . out . println ( s ) ; }
void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
boolean checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( Math . sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
int centeredTetrahedralNumber ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
void isValid ( String s ) { int n = ( int ) Math . sqrt ( s . length ( ) ) ; char check = s . charAt ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = i , y = i ; while ( x >= 0 && y < n ) { if ( s . charAt ( ( n * x ) + y ) != check || s . charAt ( ( n * y ) + x ) != check ) { System . out . print ( " No " ) ; return ; } x -- ; y ++ ; } } System . out . print ( " Yes " ) ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; + count [ i - 1 ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; }
void findNumbers ( int n ) { String ans = " " ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans += '7' ; String even = ans + '6' ; String odd = ans + '7' ; System . out . println ( " Even ▁ : ▁ " + even ) ; System . out . println ( " Odd ▁ : ▁ " + odd ) ; }
boolean DivisibleBy41 ( int first , int second , int c , int n ) { int digit [ ] = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; }
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + " ▁ , ▁ " + ( y1 + y2 ) / 2 ) ; }
int term ( int n ) { return n * ( n + 1 ) / 2 ; }
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
float kPresentProbability ( int a [ ] , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; }
int findDivisor ( int x , int y ) { if ( x == y ) return y ; return 2 ; }
long countTriplets ( int A , int B , int C ) { long ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; }
int LISusingLCS ( Vector < Integer > seq ) { int n = seq . size ( ) ; int L [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; Vector < Integer > sortedseq = new Vector < Integer > ( seq ) ; Collections . sort ( sortedseq ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq . get ( i - 1 ) == sortedseq . get ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }
int maxBottles ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
int minCost ( int cost [ ] , int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int min_cost = Integer . MAX_VALUE ; for ( int j = 0 ; j < i ; j ++ ) if ( j < cost . length && cost [ j ] != - 1 ) { min_cost = Math . min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; } dp [ i ] = min_cost ; } return dp [ n ] ; }
void product_subarrays ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } System . out . print ( product + "NEW_LINE"); }
int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; System . out . print ( ith_term + " , ▁ " ) ; } }
int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
char nextGreatestAlphabet ( char alphabets [ ] , char K ) { int n = alphabets . length ; if ( K >= alphabets [ n - 1 ] ) return alphabets [ 0 ] ; int l = 0 , r = alphabets . length - 1 ; int ans = - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { r = mid - 1 ; ans = mid ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
double innerCirclearea ( double radius ) { if ( radius < 0 ) { return - 1 ; } double r = radius / 2 ; double Area = ( 3.14 * Math . pow ( r , 2 ) ) ; return Area ; }
double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
void getIndex ( int n , int shuffle [ ] [ ] ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i ] [ 0 ] == n ) n = shuffle [ i ] [ 1 ] ; else if ( shuffle [ i ] [ 1 ] == n ) n = shuffle [ i ] [ 0 ] ; } System . out . println ( n ) ; }
void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { System . out . print ( i + " , ▁ " + j + " , ▁ " + k ) ; return ; } } } System . out . print ( " No ▁ Triplet " ) ; }
int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
int findDuplicate ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < n ) { int j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; }
long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
char first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return 0 ; }
String check ( int S , int prices [ ] , int type [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return " Yes " ; } } } } return " No " ; }
void findAngles ( double a , double b , double c , double d ) { double numerator = a * a + d * d - b * b - c * c ; double denominator = 2 * ( a * b + c * d ) ; double x = numerator / denominator ; System . out . println ( " A : ▁ " + Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; numerator = a * a + b * b - c * c - d * d ; x = numerator / denominator ; System . out . println ( " B : ▁ " + Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; numerator = c * c + b * b - a * a - d * d ; x = numerator / denominator ; System . out . println ( " C : ▁ " + Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; numerator = d * d + c * c - a * a - b * b ; x = numerator / denominator ; System . out . println ( " D : ▁ " + Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; }
int minimumAdjacentDifference ( int a [ ] , int n , int k ) { int minDiff = Integer . MAX_VALUE ; for ( int i = 0 ; i <= k ; i ++ ) { int maxDiff = Integer . MIN_VALUE ; for ( int j = 0 ; j < n - k - 1 ; j ++ ) { for ( int p = i ; p <= i + j ; p ++ ) { maxDiff = Math . max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; } } minDiff = Math . min ( minDiff , maxDiff ) ; } return minDiff ; }
int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m > 0 ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m /= 2 ; } return ans ; }
void checkCount ( int A [ ] , int Q [ ] [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ; L -- ; R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
void maxSide ( int a [ ] , int n ) { int sideLength = 0 ; Arrays . sort ( a ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } System . out . println ( sideLength ) ; }
boolean check ( int a [ ] , int n ) { int ma = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = Math . max ( ma , Math . abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } System . out . print ( " Amplitude ▁ = ▁ " + ma ) ; System . out . println ( ) ; return true ; }
void printPalindrome ( int n ) { if ( n == 1 ) { System . out . println ( " Smallest ▁ Palindrome : ▁ 0" ) ; System . out . println ( " Largest ▁ Palindrome : ▁ 9" ) ; } else { System . out . println ( " Smallest ▁ Palindrome : ▁ " + ( int ) ( Math . pow ( 10 , n - 1 ) ) + 1 ) ; System . out . println ( " Largest ▁ Palindrome : ▁ " + ( ( int ) ( Math . pow ( 10 , n ) ) - 1 ) ) ; } }
int countP ( int n , int k ) { int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
void findAngle ( int n ) { int interiorAngle , exteriorAngle ; interiorAngle = ( n - 2 ) * 180 / n ; exteriorAngle = 360 / n ; System . out . println ( " Interior ▁ angle : ▁ " + interiorAngle ) ; System . out . println ( " Exterior ▁ angle : ▁ " + exteriorAngle ) ; }
int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) count += 1 ; } return count ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) - 4 * n + 2 ; }
void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { System . out . print ( fact + " ▁ " ) ; fact = fact * x ; x ++ ; } }
int getPairs ( int a [ ] ) { int n = a . length ; int count = ( n * ( n - 1 ) ) / 2 ; return count ; }
int CountWays ( int r , int b , int l , int R , int B , int W , int [ ] [ ] [ ] dp ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r ] [ b ] [ l ] != - 1 ) return dp [ r ] [ b ] [ l ] ; int ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r ] [ b ] [ l ] = ans ; }
int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
int lbs ( int arr [ ] , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
int minJumps ( int arr [ ] , int N ) { int MAX = 1000000 ; int [ ] fib = new int [ 30 ] ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int [ ] DP = new int [ N + 2 ] ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { for ( int j = 1 ; j < 30 ; j ++ ) { if ( ( i == N + 1 arr [ i - 1 ] == 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = Math . min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return - 1 ; }
void main ( String [ ] args ) { int n = 5 , k = 42 ; char arr [ ] = lexo_small ( n , k ) ; System . out . print ( new String ( arr ) ) ; } }
boolean isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
int difference ( int n ) { int S , res ; S = ( n * ( n + 1 ) ) / 2 ; res = S * ( S - 1 ) ; return res ; }
float harmonicMean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }
boolean isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) return true ; return false ; }
void printSumSimple ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; } }
boolean isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
void printIntersection ( int A [ ] [ ] , int B [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) System . out . print ( A [ i ] [ j ] + " ▁ " ) ; else System . out . print ( " * ▁ " ) ; } System . out . println ( " ▁ " ) ; } }
int findMaxSum ( int [ ] arr , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }
int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans1 = 0 , ans2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( int i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
int xorOfSum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
int maxArea ( int [ ] a ) { int Area = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = i + 1 ; j < a . length ; j ++ ) { Area = Math . max ( Area , Math . min ( a [ i ] , a [ j ] ) * ( j - i ) ) ; } } return Area ; }
void alter ( long x , long y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } System . out . println ( " X ▁ = ▁ " + x + " , ▁ " + " Y ▁ = ▁ " + y ) ; }
float sumOfSeries ( int x , int k ) { float y = ( float ) ( ( ( float ) ( x ) / 81 ) * ( 9 * k - 1 + Math . pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }
float avgOfFirstN ( int n ) { return ( float ) ( 1 + n ) / 2 ; }
int highestPower ( int n ) { return ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; }
boolean ishexadecagonal ( int N ) { double n = ( 12 + Math . sqrt ( 112 * N + 144 ) ) / 28 ; return ( n - ( int ) n ) == 0 ; }
int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
int Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / N1 ; return ( int ) rate ; }
int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int a = 0 , b = 0 ; int result = Integer . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
int getTotalNumberOfSequences ( int m , int n ) { int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; }
void newvol ( double x ) { System . out . print ( " percentage ▁ increase ▁ " + " in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) ) ; System . out . print ( " % " ) ; }
void positions ( String str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ( str . charAt ( i ) & NUM ) + " ▁ " ) ; } }
void leastBricks ( ArrayList < ArrayList < Integer > > wall ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int res = 0 ; for ( ArrayList < Integer > list : wall ) { int width = 0 ; for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { width += list . get ( i ) ; map . put ( width , map . getOrDefault ( width , 0 ) + 1 ) ; res = Math . max ( res , map . getOrDefault ( width , 0 ) ) ; } } System . out . println ( wall . size ( ) - res ) ; }
int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
int tripletAndSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & ( 1 << bit ) ) != 0 ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; }
int evenDecimalValue ( String str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str . charAt ( k ) - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
boolean isValid ( String str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) return false ; } return true ; }
String perfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int p = ( int ) Math . sqrt ( arr [ i ] ) ; if ( p * p != arr [ i ] ) { return " No " ; } } return " Yes " ; }
int largestCoprime ( int N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
void oppositeFaceOfDice ( int N ) { int ans = 7 - N ; System . out . println ( ans ) ; }
int countPaths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
void findBalance ( int x , float bal ) { if ( x % 10 == 0 && ( ( float ) x + 1.50 ) <= bal ) { System . out . printf ( "%.2fNEW_LINE", bal - x - 1.50); } else { System . out . printf ( "%.2fNEW_LINE", bal); } }
int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; }
boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) { for ( int i = 0 ; i < set1 . length ; i ++ ) { for ( int j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; }
boolean IsRedundantBraces ( String A ) { int a = 0 , b = 0 ; for ( int i = 0 ; i < A . length ( ) ; i ++ ) { if ( A . charAt ( i ) == ' ( ' && A . charAt ( i + 2 ) == ' ) ' ) return true ; if ( A . charAt ( i ) == ' * ' || A . charAt ( i ) == ' + ' || A . charAt ( i ) == ' - ' || A . charAt ( i ) == ' / ' ) a ++ ; if ( A . charAt ( i ) == ' ( ' ) b ++ ; } if ( b > a ) return true ; return false ; }
int cntCells ( int n ) { int cells = ( int ) Math . pow ( n , 2 ) + ( int ) Math . pow ( n - 1 , 2 ) ; return cells ; }
boolean isPossible ( int arr [ ] , int p , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
int minOperation ( int k ) { int dp [ ] = new int [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( " Angle ▁ cannot " + " ▁ be ▁ formed " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
double getTime ( int u , int v , int x ) { double speed = u + v ; double time = x / speed ; return time ; }
int maxSumBitonicSubArr ( int arr [ ] , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = Integer . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
int Divisible ( int arr [ ] , int n ) { int count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) count_even ++ ; return count_even + ( n - count_even ) / 2 ; }
int minSum ( int [ ] A , int n ) { int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ; return ( min_val * ( n - 1 ) ) ; }
int NthComposite ( int N ) { int MAX_SIZE = 1000005 ; boolean [ ] IsPrime = new boolean [ MAX_SIZE ] ; Arrays . fill ( IsPrime , true ) ; for ( int p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( int i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } Vector < Integer > Composites = new Vector < Integer > ( ) ; for ( int p = 4 ; p < MAX_SIZE ; p ++ ) if ( ! IsPrime [ p ] ) Composites . add ( p ) ; return Composites . get ( N - 1 ) ; }
int minimumRectangleArea ( int A [ ] , int N ) { int ans ; Arrays . sort ( A ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = Math . min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
void nDigitPerfectCubes ( int n ) { int smallest = ( int ) Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n - 1 ) ) ) ) , 3 ) ; System . out . print ( smallest + " ▁ " ) ; int largest = ( int ) Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ; System . out . print ( largest ) ; }
int countNestedPolygons ( int sides ) { int count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; }
int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; }
int minSum ( int arr [ ] , int n , int x ) { int sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; int sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; }
void flippingBits ( long N , long K ) { long X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; System . out . print ( N ) ; }
int CountWays ( int N , int M ) { int count = 1 ; count = ( int ) Math . pow ( 3 , M + N ) ; count *= ( int ) Math . pow ( 2 , M * N ) ; return count ; }
int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
boolean canBeSumofConsec ( int n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; }
int findMaxPoints ( int A [ ] [ ] ) { int [ ] [ ] P1S = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P1E = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P2S = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P2E = new int [ M + 2 ] [ N + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = M ; j >= 1 ; j -- ) P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ; int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ; ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ; } } return ans ; }
String isDivisibleByDivisor ( int S , int D ) { S %= D ; Set < Integer > hashMap = new HashSet < > ( ) ; hashMap . add ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . contains ( S ) ) { if ( S == 0 ) { return " Yes " ; } return " No " ; } else hashMap . add ( S ) ; } return " Yes " ; }
void findNumbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( "1" + " ▁ " ) ; System . out . print ( "2" + " ▁ " ) ; System . out . println ( n + d ) ; }
void singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } System . out . print ( res ) ; }
void search ( String txt , String pat ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } }
int maxScore ( int [ ] arr ) { int N = arr . length ; N ++ ; int [ ] [ ] dp = new int [ N + 1 ] [ 2 * ( N - 1 ) + 1 ] ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int s = 1 ; s <= 2 * ( N - 1 ) ; s ++ ) { for ( int j = 1 ; j <= N - 1 && j <= s ; j ++ ) { dp [ i ] [ s ] = Math . max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) ; } } } return dp [ N ] [ 2 * ( N - 1 ) ] - 1 ; }
void checkPascaltriangle ( int N ) { double x = ( Math . sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( Math . ceil ( x ) - x == 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
void isCycleExists ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { System . out . println ( " Yes " ) ; return ; } } System . out . println ( " No " ) ; }
boolean findPair ( int arr [ ] , int n ) { int size = arr . length ; int i = 0 , j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { System . out . print ( " Pair ▁ Found : ▁ " + " ( ▁ " + arr [ i ] + " , ▁ " + arr [ j ] + " ▁ ) " ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } System . out . print ( " No ▁ such ▁ pair " ) ; return false ; }
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( float ) Math . pow ( h , 3 ) ; return a ; }
void minOpsToEmptyString ( String s ) { int ans = Integer . MIN_VALUE ; int cn0 = 0 ; int cn1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . max ( ans , Math . max ( cn0 , cn1 ) ) ; } System . out . print ( ans ) ; }
boolean isdecagonal ( int N ) { double n = ( 3 + Math . sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - ( int ) n ) == 0 ; }
int reduceZero ( int N ) { int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) dp [ i ] = ( int ) 1e9 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( char c : String . valueOf ( i ) . toCharArray ( ) ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i - ( c - '0' ) ] + 1 ) ; } } return dp [ N ] ; }
int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( int ) ( ( first_term * ( Math . pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . pow ( 2 , N - 1 ) ) - 1 ) ) ; return nth ; }
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
int sameEulerTotient ( int N ) { return ( N & 1 ) ; }
void isEqualSubstring ( String str , int x ) { int n = str . length ( ) ; int i = 0 ; while ( i < n && i < x ) { if ( str . charAt ( i ) != str . charAt ( n - i - 1 ) ) { System . out . println ( " false " ) ; return ; } i ++ ; } System . out . println ( " true " ) ; }
int countTriplets ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } int c1 = odd * ( even * ( even - 1 ) ) / 2 ; int c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ; return c1 + c2 ; }
void waysToPaint ( int n ) { long same = 6 ; long diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } System . out . println ( same + diff ) ; }
int find_and ( int arr [ ] ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { ans = ( ans & arr [ i ] ) ; } return ans ; }
String findString ( String arr [ ] , int N ) { String ans = " " ; for ( int i = 0 ; i < N ; i ++ ) { ans += arr [ i ] . charAt ( i ) == '0' ? '1' : '0' ; } return ans ; }
void find_rectangle ( int area ) { int l = 0 , b = 0 ; int M = ( int ) Math . sqrt ( area ) , ans ; for ( int i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } System . out . println ( " l ▁ = ▁ " + l + " , ▁ b ▁ = ▁ " + b ) ; }
int xorPairSum ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; }
double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }
int NoCarrySum ( int N , int M ) { return N ^ M ; }
int findMinSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
boolean isPossible ( int n ) { int fac [ ] = new int [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; }
void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " ▁ " ) ; }
int findCount ( int mat [ ] [ ] , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
void linearCongruentialMethod ( int Xo , int m , int a , int c , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } }
void hasEqualBlockFrequency ( int N ) { String S = Integer . toString ( N , 2 ) ; HashSet < Integer > p = new HashSet < Integer > ( ) ; int c = 1 ; for ( int i = 0 ; i < S . length ( ) - 1 ; i ++ ) { if ( S . charAt ( i ) == S . charAt ( i + 1 ) ) c += 1 ; else { p . add ( c ) ; c = 1 ; } p . add ( c ) ; } if ( p . size ( ) == 1 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
void findMaximumProfit ( int [ ] arr , int M , int N ) { PriorityQueue < Integer > max_heap = new PriorityQueue < > ( ( a , b ) -> b - a ) ; int maxProfit = 0 ; for ( int i = 0 ; i < N ; i ++ ) max_heap . add ( arr [ i ] ) ; while ( M > 0 ) { M -- ; int X = max_heap . poll ( ) ; maxProfit += X ; max_heap . add ( X - 1 ) ; } System . out . println ( maxProfit ) ; }
int squares ( int l , int b , int a ) { return ( int ) ( Math . ceil ( l / ( double ) a ) * Math . ceil ( b / ( double ) a ) ) ; }
int cntSubArrays ( int [ ] arr , int n , int k ) { int res = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; res += Math . max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }
void printFreq ( int arr [ ] , int N ) { int freq = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { freq ++ ; } else { System . out . println ( " Frequency ▁ of ▁ " + arr [ i - 1 ] + " ▁ is : ▁ " + freq ) ; freq = 1 ; } } System . out . println ( " Frequency ▁ of ▁ " + arr [ N - 1 ] + " ▁ is : ▁ " + freq ) ; }
boolean ToCheckPowerofX ( int n , int x ) { while ( n > 0 ) { int rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; }
String isPossible ( int arr [ ] , int n ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mini = Math . min ( mini , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; int Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return " No " ; } return " Yes " ; }
boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
void constructXOR ( int A [ ] , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
int subsetXOR ( int [ ] arr , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 ) ) - 1 ; if ( k > m ) { return 0 ; } int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
double findsolution ( double d , double h , double m , double n ) { double k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return - 1 ; double ans = ( h / ( k - n ) ) ; return ans ; }
double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ; t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
void convertToASCII ( int N ) { String num = Integer . toString ( N ) ; for ( char ch : num . toCharArray ( ) ) { System . out . print ( ch + " ▁ ( " + ( int ) ch + ")NEW_LINE"); } }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int count ( int n ) { return ( int ) ( - 1 + Math . sqrt ( 1 + 8 * n ) ) / 2 ; }
void subString ( char str [ ] , int n ) { for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; for ( int k = i ; k <= j ; k ++ ) { System . out . print ( str [ k ] ) ; } System . out . println ( ) ; } } }
double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / Math . pow ( i , i ) ; sums += ser ; } return sums ; }
int linearCheck ( int ar [ ] [ ] , int arr [ ] ) { for ( int i = 0 ; i < m ; i ++ ) { boolean matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; }
boolean isOctadecagon ( int N ) { double n = ( 14 + Math . sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - ( int ) n ) == 0 ; }
int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; }
int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == ' ( ' ) level ++ ; else if ( tree . charAt ( i ) == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; }
int countPoints ( int n , int m , int a [ ] , int [ ] b , int x , int y ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int j = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; }
int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
void performQueries ( String str , int n , int queries [ ] [ ] , int q ) { int ptr = 0 ; for ( int i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 1 ) { ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; } else { int k = queries [ i ] [ 1 ] ; int index = ( ptr + k - 1 ) % n ; System . out . println ( str . charAt ( index ) ) ; } } }
long evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
boolean is_Chiliagon ( int N ) { float n = ( float ) ( 996 + Math . sqrt ( 7984 * N + 992016 ) ) / 1996 ; return ( n - ( int ) n ) == 0 ; }
String even_or_odd ( String N ) { int len = N . length ( ) ; if ( N . charAt ( len - 1 ) == '0' || N . charAt ( len - 1 ) == '2' || N . charAt ( len - 1 ) == '4' || N . charAt ( len - 1 ) == '6' || N . charAt ( len - 1 ) == '8' || N . charAt ( len - 1 ) == ' A ' || N . charAt ( len - 1 ) == ' C ' || N . charAt ( len - 1 ) == ' E ' ) return ( " Even " ) ; else return ( " Odd " ) ; }
int minimumHammingDistance ( String S , int K ) { int n = S . length ( ) ; int [ ] pref = new int [ n ] ; pref [ 0 ] = S . charAt ( 0 ) - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S . charAt ( i ) - '0' ) ; int cnt = pref [ n - 1 ] ; int ans = cnt ; for ( int i = 0 ; i < n - K ; i ++ ) { int value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = Math . min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
double circumference ( double r ) { double PI = 3.1415 ; double cir = 2 * PI * r ; return cir ; }
void checkArrays ( int arr1 [ ] , int arr2 [ ] , int N ) { int count = 0 ; boolean flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = false ; break ; } } } } if ( ( flag && ( count == 0 ) ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
void checkSolution ( int a , int b , int c ) { if ( b == 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
int numberOfElements ( int height [ ] , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
int findK ( int arr [ ] , int size , int N ) { Arrays . sort ( arr ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; }
void factors ( int n , int i ) { if ( i <= n ) { if ( n % i == 0 ) { System . out . print ( i + " ▁ " ) ; } factors ( n , i + 1 ) ; } }
long moduloMultiplication ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; }
void findRemainders ( long n ) { HashSet < Long > vc = new HashSet < Long > ( ) ; for ( long i = 1 ; i <= Math . ceil ( Math . sqrt ( n ) ) ; i ++ ) vc . add ( n / i ) ; for ( long i = ( long ) ( n / Math . ceil ( Math . sqrt ( n ) ) - 1 ) ; i >= 0 ; i -- ) vc . add ( i ) ; for ( long it : vc ) System . out . print ( it + " ▁ " ) ; }
int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . abs ( sumSet1 - sumSet2 ) ; }
void minimumDifference ( int N ) { int sum1 = ( 1 << N ) , sum2 = 0 ; for ( int i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( int i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; System . out . println ( sum1 - sum2 ) ; }
int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; }
void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; System . out . println ( num ) ; ; }
int sum_star_num ( int n ) { int summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }
int checkValidity ( int a , int b , int c ) { if ( a + b <= c a + c <= b b + c <= a ) return 0 ; else return 1 ; }
int maximumTurns ( int arr [ ] , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; }
long findWays ( int f , int d , int s ) { long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
int optimalStrategyOfGame ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
void leftRotate ( int arr [ ] , int d , int n ) { int i , j ; if ( d == 0 d == n ) return ; i = d ; j = n - d ; while ( i != j ) { if ( i < j ) { swap ( arr , d - i , d + j - i , i ) ; j -= i ; } else { swap ( arr , d - i , d , j ) ; i -= j ; } } swap ( arr , d - i , d , i ) ; }
boolean canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Arrays . sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
int countPoints ( int D ) { int count = 0 ; for ( int x = 1 ; x * x < D * D ; x ++ ) { int y = ( int ) Math . sqrt ( ( D * D - x * x ) ) ; if ( x * x + y * y == D * D ) { count += 4 ; } } count += 4 ; return count ; }
int countChar ( String str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) count ++ ; int repetitions = n / str . length ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == x ) count ++ ; } return count ; }
float getPercentile ( int rank , int students ) { float result = ( float ) ( students - rank ) / students * 100 ; return result ; }
int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = ( int ) Math . pow ( 10 , digit - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
void check_euler_four_square_identity ( int a , int b , int ab ) { int s = 0 ; for ( int i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( int j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( int k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( int l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { System . out . print ( " i ▁ = ▁ " + i + "NEW_LINE"); System . out . print ( " j ▁ = ▁ " + j + "NEW_LINE"); System . out . print ( " k ▁ = ▁ " + k + "NEW_LINE"); System . out . print ( " l ▁ = ▁ " + l + "NEW_LINE"); System . out . print ( " Product ▁ of ▁ " + a + " ▁ and ▁ " + b ) ; System . out . print ( " ▁ can ▁ be ▁ written " + " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " + "j, k, lNEW_LINE"); System . out . print ( ab + " ▁ = ▁ " ) ; System . out . print ( i + " * " + i + " ▁ + ▁ " ) ; System . out . print ( j + " * " + j + " ▁ + ▁ " ) ; System . out . print ( k + " * " + k + " ▁ + ▁ " ) ; System . out . print ( l + " * " + l + "NEW_LINE"); System . out . println ( ) ; } } } } } }
int minCount ( int arr [ ] , int n , int k ) { int ans = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; int l = 0 ; int r = 0 ; int tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = Math . max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
int clearBit ( int num , int i ) { int mask = ~ ( 1 << i ) ; return num & mask ; }
void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
void TowerOfHanoi ( int N ) { for ( int x = 1 ; x <= Math . pow ( 2 , N ) - 1 ; x ++ ) { System . out . print ( " Move ▁ from ▁ Rod ▁ " + ( ( x & x - 1 ) % 3 + 1 ) + " ▁ to ▁ Rod ▁ " + ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) + "NEW_LINE"); } }
void printSumSeries ( int N ) { float sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 1.0 / ( 2 * i - 1 ) ; } System . out . println ( sum ) ; }
void contain ( int L , int U , int M ) { int count = 0 ; for ( int j = L ; j < U ; j ++ ) { HashSet < String > num = new HashSet < > ( ) ; String str = Integer . toString ( j ) ; num . add ( str ) ; if ( j % M == 0 && ! num . contains ( Integer . toString ( M ) ) ) { count += 1 ; } } System . out . println ( count - 2 ) ; }
int countDigits ( int a , int b ) { double digits = Math . log10 ( Math . abs ( a ) ) - Math . log10 ( Math . abs ( b ) ) + 1 ; return ( int ) Math . floor ( digits ) ; }
boolean isStraighLineNum ( int N ) { if ( N <= 99 ) return false ; String s = Integer . toString ( N ) ; int d = s . charAt ( 1 ) - s . charAt ( 0 ) ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) - s . charAt ( i - 1 ) != d ) return false ; return true ; }
void replace_elements ( int arr [ ] , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " No " ; n = n >> 1 ; } return " Yes " ; }
int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
void rearrange ( int [ ] arr , int n ) { int temp [ ] = arr . clone ( ) ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) arr [ i ] = temp [ large -- ] ; else arr [ i ] = temp [ small ++ ] ; flag = ! flag ; } }
String removeDuplicates ( String str ) { int n = str . length ( ) ; String res = " " ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) break ; if ( j == n ) res = res + str . charAt ( i ) ; } return res ; }
boolean checkCentrosymmetricted ( int n , int m [ ] [ ] ) { int mid_row ; if ( ( n & 1 ) > 0 ) mid_row = n / 2 + 1 ; else mid_row = n / 2 ; for ( int i = 0 ; i < mid_row ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
long count_triples ( int n , int k ) { int i = 0 , j = 0 , l = 0 ; int count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { for ( l = 1 ; l <= n ; l ++ ) { if ( ( i + j ) % k == 0 && ( i + l ) % k == 0 && ( j + l ) % k == 0 ) count ++ ; } } } return count ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) - n - 1 ; }
boolean checkEquilibrium ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int resx = x1 + x2 + x3 ; int resy = y1 + y2 + y3 ; int resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; }
double findAverage ( int N ) { double avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
void reorder ( ) { for ( int i = 0 ; i < arr . length ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; char oldTargetE = ( char ) arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }
boolean isCenterednonadecagonal ( int N ) { float n = ( float ) ( ( 19 + Math . sqrt ( 152 * N + 209 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; }
void check ( int n ) { HashSet < Integer > digits = new HashSet < Integer > ( ) ; int temp = n ; int sum = 0 ; int count = 0 ; while ( temp > 0 ) { sum += temp % 10 ; digits . add ( temp % 10 ) ; count ++ ; temp = temp / 10 ; } if ( sum % count == 0 && digits . contains ( sum / count ) ) System . out . print ( " Yes " + "NEW_LINE"); else System . out . print ( " No " + "NEW_LINE"); }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
void printValueOfPi ( int N ) { double pi = 2 * Math . acos ( 0.0 ) ; System . out . println ( pi ) ; }
int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; }
boolean canVote ( int [ ] a , int n , int x ) { int [ ] [ ] dp = new int [ n + 1 ] [ x + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < x + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; return ( sum - dp [ n ] [ x ] >= x ) ; }
double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; }
int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
int minCost ( int a [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
int minimum_sum ( int [ ] A , int N ) { Arrays . sort ( A ) ; int sum = 2147483647 ; for ( int i = 0 ; i <= N - 3 ; i ++ ) { sum = Math . min ( sum , Math . abs ( A [ i ] - A [ i + 1 ] ) + Math . abs ( A [ i + 1 ] - A [ i + 2 ] ) ) ; } return sum ; }
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( int ) ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ; Arrays . sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double median1 = arr [ size / 2 ] ; return median1 ; }
int changeTheArray ( int arr [ ] , int n ) { int minEle = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int maxEle = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int minOperations = Integer . MAX_VALUE ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . min ( minOperations , operations ) ; } return minOperations ; }
void dupLastIndex ( int arr [ ] , int n ) { if ( arr == null n <= 0 ) return ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { System . out . println ( " Last ▁ index : " + i ) ; System . out . println ( " Last ▁ duplicate ▁ item : ▁ " + arr [ i ] ) ; return ; } } System . out . print ( " no ▁ duplicate ▁ found " ) ; }
int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; }
int Remainder ( String str , int R ) { int len = str . length ( ) ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str . charAt ( i ) - '0' ) ; Rem = Num % R ; } return Rem ; }
boolean check ( int arr [ ] , int x , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double y = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( y ) == Math . ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; }
int getMinSteps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; }
void findSides ( double A , double C , double c ) { double B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; double a = ( c / Math . sin ( C ) ) * Math . sin ( A ) ; double b = ( c / Math . sin ( C ) ) * Math . sin ( B ) ; System . out . println ( String . format ( " % .2f " , a ) ) ; System . out . println ( String . format ( " % .2f " , b ) ) ; }
void makeZero ( int x , int y , int a , int b ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int tot_cost = ( y - x ) * a ; int cost1 = 2 * x * a ; int cost2 = x * b ; tot_cost += Math . min ( cost1 , cost2 ) ; System . out . print ( tot_cost ) ; }
int countways ( int n ) { int [ ] A = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( h * r * ( float ) Math . sqrt ( 2 ) ) / ( h + ( float ) Math . sqrt ( 2 ) * r ) ; return a ; }
int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
int FindMaxSum ( int arr [ ] , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }
int countGroups ( int position , int previous_sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num . charAt ( i ) - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
void printRepeating ( int arr [ ] , int size ) { int i , j ; System . out . println ( " Repeated ▁ Elements ▁ are ▁ : " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } } }
> Diagonals ( int a , int b , int c , int d ) { Vector < Float > ans = new Vector < Float > ( ) ; ans . add ( ( float ) Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; ans . add ( ( float ) Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return ans ; }
void findRightAngle ( double A , double H ) { double D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { double root1 = ( H * H + Math . sqrt ( D ) ) / 2 ; double root2 = ( H * H - Math . sqrt ( D ) ) / 2 ; double a = Math . sqrt ( root1 ) ; double b = Math . sqrt ( root2 ) ; if ( b >= a ) System . out . print ( a + " ▁ " + b + " ▁ " + H ) ; else System . out . print ( b + " ▁ " + a + " ▁ " + H ) ; } else System . out . print ( " - 1" ) ; }
int minOperations ( String s ) { int len = s . length ( ) ; int result = 0 ; for ( int i = 0 ; i < len / 2 ; i ++ ) { int D1 = Math . max ( s . charAt ( i ) , s . charAt ( len - 1 - i ) ) - Math . min ( s . charAt ( i ) , s . charAt ( len - 1 - i ) ) ; int D2 = 26 - D1 ; result += Math . min ( D1 , D2 ) ; } return result ; }
int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }
boolean isPossible ( int a [ ] , int n ) { int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != i + 1 ) k ++ ; } if ( k <= 2 ) return true ; return false ; }
long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
int countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( N / i != i ) { count ++ ; } } } return count ; }
void findMax ( int arr [ ] [ ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( j >= 0 && arr [ i ] [ j ] == 1 ) { row = i ; j -- ; } } System . out . print ( " Row ▁ number ▁ = ▁ " + ( row + 1 ) ) ; System . out . print ( " , ▁ MaxCount ▁ = ▁ " + ( N - 1 - j ) ) ; }
int minDiffSubArray ( int arr [ ] , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int [ ] suffix_sum = new int [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int minDiff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = Math . abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
int minimumBox ( int [ ] arr , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; Arrays . sort ( arr ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . element ( ) ; if ( arr [ i ] >= 2 * now ) q . remove ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; }
String findPrefix ( String str1 , String str2 ) { boolean pos = false ; while ( str1 . length ( ) > 0 ) { if ( ! str2 . contains ( str1 ) ) str1 = str1 . substring ( 0 , str1 . length ( ) - 1 ) ; else { pos = str2 . contains ( str1 ) ; break ; } } if ( pos == false ) return " - 1" ; return str1 ; }
int getCount ( int arr [ ] , int N ) { int count = 0 ; if ( N < 3 ) return 0 ; for ( int b = 0 ; b < N ; b ++ ) { for ( int a = 0 ; a < N ; a ++ ) { if ( a == b ) continue ; for ( int c = 0 ; c < N ; c ++ ) { if ( c == a c == b ) continue ; int d = arr [ b ] * arr [ b ] / 4 ; if ( arr [ a ] * arr <= d ) count ++ ; } } } return count ; }
boolean permutation ( int [ ] arr , int n ) { Set < Integer > hash = new HashSet < Integer > ( ) ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . add ( arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; }
void XOROfElements ( int arr [ ] , int n ) { int FirstHalfXOR = 0 ; int SecondHalfXOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } System . out . print ( FirstHalfXOR + " , " + SecondHalfXOR + "NEW_LINE"); }
int sum ( int a [ ] , int n ) { int maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) maxSum = Math . max ( maxSum , a [ i ] + a [ j ] ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; }
int findpos ( String n ) { int pos = 0 ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { switch ( n . charAt ( i ) ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; }
void reorder ( ) { int temp [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
void sieve ( ) { int arr [ ] = new int [ N + 1 ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) if ( arr [ i ] == 0 ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; long runningPrimeSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
boolean findPair ( int a [ ] , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
int findMinCost ( int [ ] [ ] arr , int X , int n , int i ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return Integer . MAX_VALUE ; int inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) ; if ( inc != Integer . MAX_VALUE ) inc += arr [ i ] [ 1 ] ; int exc = findMinCost ( arr , X , n , i + 1 ) ; return Math . min ( inc , exc ) ; }
int maxlength ( String s ) { int n = s . length ( ) , i , j ; int ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s . charAt ( i ) == '1' ) { int count = 1 ; for ( j = i + 1 ; j <= n - 1 && s . charAt ( j ) == '1' ; j ++ ) count ++ ; ans = Math . max ( ans , count ) ; } } return ans ; }
boolean Check_is_possible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return ( count > 1 ) ; }
int count_pairs ( int arr [ ] , int brr [ ] , int N , int M , int K ) { int i = 0 ; int j = 0 ; int cntPairs = 0 ; Arrays . sort ( arr ) ; Arrays . sort ( brr ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
int MaxSubsetlength ( String arr [ ] , int A , int B ) { int dp [ ] [ ] = new int [ A + 1 ] [ B + 1 ] ; for ( String str : arr ) { int zeros = 0 , ones = 0 ; for ( char ch : str . toCharArray ( ) ) { if ( ch == '0' ) zeros ++ ; else ones ++ ; } for ( int i = A ; i >= zeros ; i -- ) for ( int j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } return dp [ A ] [ B ] ; }
int findSum ( String s ) { int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { sum += ( j - i ) ; } } } return sum ; }
int Count ( String s , int pos ) { int c = s . charAt ( pos - 1 ) ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s . charAt ( i ) == c ) counter = counter + 1 ; } return counter ; }
int productSum ( int [ ] arr ) { int cntOne = 0 ; int N = arr . length ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) cntOne ++ ; } return cntOne * ( cntOne - 1 ) / 2 ; }
int two_sets ( int a [ ] , int n ) { Arrays . sort ( a ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; }
void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; }
void findWays ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } System . out . print ( dp [ N ] ) ; }
int longestSubsequenceCommonSegment ( int k , String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int lcs [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; int cnt [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . pow ( r , 2 ) / 5 ) ; return a ; }
void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } System . out . print ( sum + " ▁ " ) ; } }
int findsubArray ( int arr [ ] , int N , int K ) { int res = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { int curr_prod = 1 ; for ( int j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = Math . min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
int missingNumber ( int arr1 [ ] , int arr2 [ ] , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ ] = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
int numberOfUniqueOutcomes ( int N , int S ) { if ( S < N ) return 0 ; if ( N == 1 N == S ) return 1 ; return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) ; }
int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
boolean findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } }
int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }
int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; }
boolean check ( char s [ ] ) { int l = s . length ; Arrays . sort ( s ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; }
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) <= 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
int findMinDiff ( int [ ] arr , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
double surface_area_octahedron ( double side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
int countPairs ( int [ ] A , int [ ] B ) { int n = A . length ; int ans = 0 ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
void smallestNumber ( int N ) { System . out . print ( ( N % 9 + 1 ) * Math . pow ( 10 , ( N / 9 ) ) - 1 ) ; }
int calculate ( int n , int k , int m , int power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
void LargestString ( String na [ ] ) { int N = na . length ; int c [ ] = new int [ N ] ; int m = 0 ; for ( int j = 0 ; j < N ; j ++ ) { boolean character [ ] = new boolean [ 26 ] ; for ( int k = 0 ; k < na [ j ] . length ( ) ; k ++ ) { int x = na [ j ] . charAt ( k ) - ' A ' ; if ( ( na [ j ] . charAt ( k ) != ' ▁ ' ) && ( character [ x ] == false ) ) { c [ j ] ++ ; character [ x ] = true ; } } if ( c [ j ] > c [ m ] ) m = j ; } System . out . println ( na [ m ] ) ; }
void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
int longCommomAnagramSubseq ( String str1 , String str2 , int n1 , int n2 ) { int [ ] freq1 = new int [ SIZE ] ; int [ ] freq2 = new int [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ ( int ) str1 . charAt ( i ) - ( int ) ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ ( int ) str2 . charAt ( i ) - ( int ) ' a ' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
int checkArray ( int arr [ ] , int N , int k ) { if ( N < 3 ) return - 1 ; int i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; int R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; int Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
void kth_String ( int n , int k ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( k <= ( n - i - 1 ) ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == i j == n - k ) System . out . print ( ' Y ' ) ; else System . out . print ( ' X ' ) ; } break ; } k -= ( n - i - 1 ) ; } }
void printNumberOfPairs ( int N ) { HashSet < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { int x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . add ( x ) ; } } } System . out . println ( st . size ( ) ) ; }
int countSetBits ( int N ) { int count = 0 ; while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; } return count ; }
int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }
int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
boolean checkSentence ( char [ ] str ) { int len = str . length ; if ( str [ 0 ] < ' A ' str [ 0 ] > ' Z ' ) return false ; if ( str [ len - 1 ] != ' . ' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( index <= str . length ) { if ( str [ index ] >= ' A ' && str [ index ] <= ' Z ' ) curr_state = 0 ; else if ( str [ index ] == ' ▁ ' ) curr_state = 1 ; else if ( str [ index ] >= ' a ' && str [ index ] <= ' z ' ) curr_state = 2 ; else if ( str [ index ] == ' . ' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . length ) ; index ++ ; prev_state = curr_state ; } return false ; }
int findCost ( Integer [ ] a , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
int minSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int x = arr [ ( int ) n / 2 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . abs ( arr [ i ] - x ) ; return sum ; }
int longLenSub ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . put ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; }
int swapBits ( int n , int p1 , int p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
int subsetCount ( int arr [ ] , int n ) { return 1 << n ; }
boolean isValidSeq ( int [ ] a , int n ) { int nodes = n + 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 a [ i ] > nodes ) return false ; } return true ; }
void LowerHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) System . out . print ( '0' + " ▁ " ) ; else { System . out . printf ( " % .0f " , Math . random ( ) * 10 ) ; System . out . print ( " ▁ " ) ; } } System . out . println ( "NEW_LINE"); } }
void CountPair ( int L , int R ) { int x = ( R - L + 1 ) ; System . out . println ( x / 2 + "NEW_LINE"); }
boolean isEven ( int n ) { return ( n % 2 == 0 ) ; }
int findTripleSum ( int A , int B , int C ) { int sum = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { int prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
int countWays ( int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
int swapBits ( int n , int p1 , int p2 ) { int bit1 = ( n >> p1 ) & 1 ; int bit2 = ( n >> p2 ) & 1 ; int x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; int result = n ^ x ; return result ; }
boolean powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
int get_permutation ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += Math . abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . max ( l , a ) ; int R = Math . min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int countNums ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { int lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
boolean isAnyNotPalindrome ( String s ) { Set < Character > unique = new HashSet < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) unique . add ( s . charAt ( i ) ) ; if ( unique . size ( ) > 1 ) return true ; else return false ; }
double findAverage ( int N ) { double S = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { S += i * i * i * i ; } return S / N ; }
void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } System . out . println ( res ) ; }
void atleastkDistinctChars ( String s , int k ) { int n = s . length ( ) ; Map < Character , Integer > mp = new HashMap < > ( ) ; int begin = 0 , end = 0 ; int ans = 0 ; while ( end < n ) { char c = s . charAt ( end ) ; mp . put ( c , mp . getOrDefault ( c , 0 ) + 1 ) ; end ++ ; while ( mp . size ( ) >= k ) { char pre = s . charAt ( begin ) ; mp . put ( pre , mp . getOrDefault ( pre , 0 ) - 1 ) ; if ( mp . get ( pre ) == 0 ) { mp . remove ( pre ) ; } ans += s . length ( ) - end + 1 ; begin ++ ; } } System . out . println ( ans ) ; }
int findProduct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int prod = 1 * arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; }
int hIndex ( int [ ] citations , int n ) { int hindex = 0 ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } System . out . println ( hindex ) ; return hindex ; }
double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
int magicOfSequence ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
void countPairs ( int A [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } System . out . println ( count ) ; }
void check_position ( int a , int b , int c , int d , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int value_1 = a * x1 + b * y1 + c * z1 + d ; int value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) System . out . print ( " On ▁ same ▁ side " ) ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) System . out . print ( " On ▁ different ▁ sides " ) ; if ( value_1 == 0 && value_2 == 0 ) System . out . print ( " Both ▁ on ▁ the ▁ plane " ) ; if ( value_1 == 0 && value_2 != 0 ) System . out . print ( " Point ▁ 1 ▁ on ▁ the ▁ plane " ) ; if ( value_1 != 0 && value_2 == 0 ) System . out . print ( " Point ▁ 2 ▁ on ▁ the ▁ plane " ) ; }
void generateArray ( int n , int k ) { int [ ] array = new int [ k ] ; int remaining = n - ( k * ( k + 1 ) / 2 ) ; if ( remaining < 0 ) System . out . print ( " NO " ) ; int right_most = remaining % k ; int high = ( int ) Math . ceil ( remaining / ( k * 1.0 ) ) ; int low = ( int ) Math . floor ( remaining / ( k * 1.0 ) ) ; for ( int i = k - right_most ; i < k ; i ++ ) array [ i ] = high ; for ( int i = 0 ; i < ( k - right_most ) ; i ++ ) array [ i ] = low ; for ( int i = 0 ; i < k ; i ++ ) array [ i ] += i + 1 ; if ( k - 1 != remaining k == 1 ) { for ( int u : array ) System . out . print ( u + " ▁ " ) ; } else if ( k == 2 k == 3 ) System . out . printf ( "-1NEW_LINE"); else { array [ 1 ] -= 1 ; array [ k - 1 ] += 1 ; for ( int u : array ) System . out . print ( u + " ▁ " ) ; } }
int nthSHN ( int n , int dp [ ] ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
int calcCount ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 ) count ++ ; } return count ; }
boolean checkIfAllTogether ( String s , char c ) { boolean oneSeen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s . charAt ( i ) == c ) { if ( oneSeen == true ) return false ; while ( i < n && s . charAt ( i ) == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }
int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
int countPairs ( int [ ] P , int [ ] Q , int N , int M ) { int [ ] A = new int [ 2 ] , B = new int [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
int minDel ( String s1 , String s2 ) { int i = s1 . length ( ) ; int j = s2 . length ( ) ; while ( i > 0 && j > 0 ) { if ( s1 . charAt ( i - 1 ) != s2 . charAt ( j - 1 ) ) { break ; } i -- ; j -- ; } return i + j ; }
void printAllAPTriplets ( int [ ] arr , int n ) { ArrayList < Integer > s = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; boolean exists = s . contains ( arr [ i ] - diff ) ; if ( exists ) System . out . println ( arr [ i ] - diff + " ▁ " + arr [ i ] + " ▁ " + arr [ j ] ) ; } s . add ( arr [ i ] ) ; } }
int maxPathSum ( int tri [ ] [ ] ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) System . out . print ( j + " ▁ " ) ; }
int find_index ( int [ ] arr , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
boolean isHexagonal ( int N ) { float val = 8 * N + 1 ; float x = 1 + ( float ) Math . sqrt ( val ) ; float n = ( x ) / 4 ; if ( ( n - ( int ) n ) == 0 ) return true ; else return false ; }
boolean checkSequence ( String a , String b ) { if ( b . length ( ) == 0 ) return true ; if ( a . length ( ) == 0 ) return false ; if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) return checkSequence ( a . substring ( 1 ) , b . substring ( 1 ) ) ; else return checkSequence ( a . substring ( 1 ) , b ) ; }
String longestCommonPrefix ( String [ ] a ) { int size = a . length ; if ( size == 0 ) return " " ; if ( size == 1 ) return a [ 0 ] ; Arrays . sort ( a ) ; int end = Math . min ( a [ 0 ] . length ( ) , a [ size - 1 ] . length ( ) ) ; int i = 0 ; while ( i < end && a [ 0 ] . charAt ( i ) == a [ size - 1 ] . charAt ( i ) ) i ++ ; String pre = a [ 0 ] . substring ( 0 , i ) ; return pre ; }
int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
void printRect ( Integer X [ ] , Integer Y [ ] , int n ) { int Xmax = Collections . max ( Arrays . asList ( X ) ) ; int Xmin = Collections . min ( Arrays . asList ( X ) ) ; int Ymax = Collections . max ( Arrays . asList ( Y ) ) ; int Ymin = Collections . min ( Arrays . asList ( Y ) ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymin + " } " ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymax + " } " ) ; System . out . println ( " { " + Xmax + " , ▁ " + Ymax + " } " ) ; System . out . println ( " { " + Xmax + " , ▁ " + Ymin + " } " ) ; }
int setleftmostunsetbit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
String to_upper ( char [ ] in ) { for ( int i = 0 ; i < in . length ; i ++ ) if ( ' a ' <= in [ i ] && in [ i ] <= ' z ' ) in [ i ] &= ~ ( 1 << 5 ) ; return String . valueOf ( in ) ; }
void pairwiseDifference ( int arr [ ] , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; System . out . print ( diff + " ▁ " ) ; } }
int product ( int N ) { int ans = 1 ; int val = ( int ) Math . pow ( 2 , N - 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { ans *= ( int ) Math . pow ( i , val ) ; } return ans ; }
int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; char c [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s . charAt ( i ) ; } Arrays . sort ( c ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s . charAt ( i ) ) return false ; return true ; }
void findPairs ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { System . out . print ( " ( " + i + " , ▁ " + ( N - i ) + " ) , ▁ " ) ; } }
double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
int findMinMax ( int [ ] a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . length ; ++ i ) { min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
boolean hasAllcodes ( String s , int k ) { Set < String > us = new HashSet < String > ( ) ; for ( int i = 0 ; i + k <= s . length ( ) ; i ++ ) { us . add ( s . substring ( i , i + k ) ) ; } return ( us . size ( ) == ( 1 << k ) ) ; }
int minimumSizeArr ( int A , int B ) { int currXor = 0 ; int reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; int minSize = A ; if ( currXor == B ) return minSize ; else if ( ( currXor ^ B ) == A ) return minSize + 2 ; else return minSize + 1 ; }
double maxEdges ( double N ) { double edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
boolean checkSolution ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { return ( ( a1 / a2 ) == ( b1 / b2 ) && ( b1 / b2 ) == ( c1 / c2 ) ) ; }
int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
boolean isSuffix ( String s1 , String s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 . charAt ( n1 - i - 1 ) != s2 . charAt ( n2 - i - 1 ) ) return false ; return true ; }
int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
void lastTwoDigits ( double N ) { if ( N >= 10 ) { System . out . print ( "00" ) ; return ; } double fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; System . out . print ( fac ) ; }
void maxValue ( int a ) { String c = Integer . toBinaryString ( a ) ; String b = " " ; for ( int i = 0 ; i < c . length ( ) ; i ++ ) { if ( ( c . charAt ( i ) - '0' ) == 1 ) b += '0' ; else b += '1' ; } System . out . print ( Integer . parseInt ( b , 2 ) ) ; }
double kthRoot ( double n , int k ) { return Math . pow ( k , ( 1.0 / k ) * ( Math . log ( n ) / Math . log ( k ) ) ) ; }
int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Arrays . sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
int CountCharacters ( String str , int l , int r ) { int cnt = 0 ; Map < Character , Integer > m = new HashMap < Character , Integer > ( ) ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str . charAt ( i ) && str . charAt ( i ) <= r ) ) { cnt ++ ; if ( m . get ( str . charAt ( i ) ) != null ) if ( m . get ( str . charAt ( i ) ) != 1 ) { System . out . print ( str . charAt ( i ) + " ▁ " ) ; m . put ( str . charAt ( i ) , m . get ( str . charAt ( i ) ) == null ? 0 : m . get ( str . charAt ( i ) ) + 1 ) ; } } } return cnt ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = ( int ) ( Math . pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) System . out . print ( ans ) ; else System . out . print ( 2 * ans ) ; }
void findXOR ( int mat [ ] [ ] [ ] , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i ] [ j ] [ k ] ; XOR ^= mat [ i ] [ j ] [ N - k - 1 ] ; } } } } System . out . println ( XOR ) ; }
int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; }
boolean checkSorted ( int n , int arr [ ] ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; Arrays . sort ( b , 0 , n ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; }
int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
void reArrange ( String words [ ] , int n ) { HashMap < String , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( words [ i ] , ( i + 1 ) ) ; } Arrays . sort ( words ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( freq . get ( words [ i ] ) + " ▁ " ) ; }
int findSum ( int n ) { return n * ( n + 1 ) / 2 ; }
float find_Area ( float a ) { float R = a * ( float ) ( 2.0 - Math . sqrt ( 2 ) ) ; float area = ( float ) ( ( 3.14 * R * R ) / 2.0 ) ; return area ; }
int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( int ) ( Math . ceil ( val ) - x ) ; }
float knapSack ( int W , float wt [ ] , float val [ ] , int n ) { float maxratio = Integer . MIN_VALUE ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
void findTriangles ( int n ) { int num = n ; System . out . print ( num + " ▁ " ) ; System . out . print ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }
double sum ( int n ) { double sum = 0 ; int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum ; }
int k_nonzero_numbers ( String s , int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ 2 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) for ( int x = 0 ; x <= k ; x ++ ) dp [ i ] [ j ] [ x ] = 0 ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; ++ i ) { int sm = 0 ; while ( sm < 2 ) { for ( int j = 0 ; j < k + 1 ; ++ j ) { int x = 0 ; while ( x <= ( sm != 0 ? 9 : s . charAt ( i ) - '0' ) ) { if ( j + ( x > 0 ? 1 : 0 ) < k + 1 ) { dp [ i + 1 ] [ ( sm != 0 x < ( s . charAt ( i ) - '0' ) ) ? 1 : 0 ] [ j + ( x > 0 ? 1 : 0 ) ] += dp [ i ] [ sm ] [ j ] ; } ++ x ; } } ++ sm ; } } return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] ; }
int number_of_tower ( int house [ ] , int range , int n ) { Arrays . sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
boolean is_possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }
long countOfMultiples ( long n ) { return ( n / 3 + n / 5 - n / 15 ) ; }
boolean Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
double square ( double a ) { if ( a < 0 ) return - 1 ; double x = 0.464 * a ; return x ; }
int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
void findPoint ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( " ( " + ( int ) ( 2 * x2 - x1 ) + " , " + ( int ) ( 2 * y2 - y1 ) + " ▁ ) " ) ; }
int FirstDigit ( int arr [ ] , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . floor ( S ) ; int ans = ( int ) Math . pow ( 10 , fract_S ) ; return ans ; }
int findIndex ( int [ ] arr ) { int maxIndex = 0 ; for ( int i = 0 ; i < arr . length ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( int i = 0 ; i < arr . length ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return - 1 ; return maxIndex ; }
double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / Math . pow ( 2 , fold ) ; }
int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
int countPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
void findIntersection ( int intervals [ ] [ ] , int N ) { int l = intervals [ 0 ] [ 0 ] ; int r = intervals [ 0 ] [ 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { System . out . println ( - 1 ) ; return ; } else { l = Math . max ( l , intervals [ i ] [ 0 ] ) ; r = Math . min ( r , intervals [ i ] [ 1 ] ) ; } } System . out . println ( " [ " + l + " , ▁ " + r + " ] " ) ; }
void movesRequired ( int a , int b ) { int total_moves = a % b ; System . out . println ( total_moves ) ; }
int countDigits ( int a , int b ) { if ( a == 0 b == 0 ) return 1 ; return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
int PointInKSquares ( int n , int a [ ] , int k ) { Arrays . sort ( a ) ; return a [ n - k ] ; }
int findCount ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int result = 1 ; int cur_max = arr [ 0 ] ; int cur_min = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
float findRadiusOfIncircle ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; float p = ( a + b + c ) / 2 ; float area = ( float ) Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float radius = area / p ; return radius ; }
int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
int nCycle ( int N ) { return ( N ) * ( N - 1 ) + 1 ; }
double area_cicumscribed ( double c ) { return ( c * c * ( PI / 4 ) ) ; }
int maxLen ( int [ ] arr , int n ) { int c_sum = 0 ; Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { c_sum += arr [ i ] ; if ( c_sum < 0 ) return i ; } return n ; }
void findArea ( float a , float b ) { float Area ; Area = ( float ) 3.142 * a * b ; System . out . println ( " Area : ▁ " + Area ) ; }
int right_angled ( int n ) { int count = 0 ; for ( int z = 1 ; z <= n ; z ++ ) { for ( int y = 1 ; y <= z ; y ++ ) { for ( int x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
Boolean isUpperTriangularMatrix ( int mat [ ] [ ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
void findPairs ( int arr [ ] , int n ) { int cntEven = 0 , cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; System . out . println ( " Odd ▁ pairs ▁ = ▁ " + oddPairs ) ; System . out . println ( " Even ▁ pairs ▁ = ▁ " + evenPairs ) ; }
int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
int Division ( int a [ ] , int n ) { int maxi = Integer . MIN_VALUE , mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { maxi = Math . max ( a [ i ] , maxi ) ; mini = Math . min ( a [ i ] , mini ) ; } return maxi / mini ; }
double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
void maxSubmatrixSum ( int [ ] [ ] matrix ) { int r = matrix . length ; int c = matrix [ 0 ] . length ; int maxSubmatrix = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int k = i ; k < r ; k ++ ) { for ( int l = j ; l < c ; l ++ ) { int sumSubmatrix = 0 ; for ( int m = i ; m <= k ; m ++ ) { for ( int n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m ] [ n ] ; } } maxSubmatrix = Math . max ( maxSubmatrix , sumSubmatrix ) ; } } } } System . out . println ( maxSubmatrix ) ; }
char bs ( char ar [ ] , int n , int ele ) { int start = 0 ; int end = n - 1 ; char ch = ' @ ' ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
int maxSum ( int arr [ ] , int n ) { if ( n < 2 ) return - 1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
boolean checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; int [ ] v = new int [ k ] ; Arrays . fill ( v , 0 ) ; v [ m ] = 1 ; while ( 1 != 0 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } }
float Area ( float r ) { if ( r < 0 ) return - 1 ; float x = ( 2 * r ) / ( float ) ( Math . sqrt ( 5 ) ) ; float A = 0.70477f * ( float ) ( Math . pow ( x , 2 ) ) ; return A ; }
String to_upper ( char [ ] in ) { for ( int i = 0 ; i < in . length ; i ++ ) { if ( ' a ' <= in [ i ] & in [ i ] <= ' z ' ) { in [ i ] = ( char ) ( in [ i ] - ' a ' + ' A ' ) ; } } return String . valueOf ( in ) ; }
int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - ( int ) Math . pow ( i , 2 ) ; else result = result + ( int ) Math . pow ( i , 2 ) ; } return result ; }
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
void Perimeter ( double a , double b ) { double Perimeter ; Perimeter = ( double ) 2 * 3.14 * Math . sqrt ( ( a * a + b * b ) / ( 2 * 1.0 ) ) ; System . out . println ( " Perimeter : ▁ " + Perimeter ) ; }
int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
void findDirection ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) System . out . print ( "UpNEW_LINE"); else System . out . print ( "DownNEW_LINE"); } else { if ( n % 2 == 0 ) System . out . print ( "LeftNEW_LINE"); else System . out . print ( "RightNEW_LINE"); } }
int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; }
void maximum_inversion ( int n , int k ) { int answer = 0 ; k = Math . min ( k , n / 2 ) ; int left = 1 ; int right = n ; while ( k != 0 ) { k -- ; answer += 2 * ( right - left ) - 1 ; left ++ ; right -- ; } System . out . println ( answer ) ; }
int maxXOR ( int mat [ ] [ ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 ; c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . max ( max_sum , i + j ) ; } } return max_sum ; }
int MinOp ( int N ) { if ( N <= 1 ) return N ; int bit = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; }
int MinimumOperations ( int [ ] A , int N , int K ) { int Count = 0 ; int i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
void sumOfMedians ( int arr [ ] , int N , int K ) { int selectMedian = ( K + 1 ) / 2 ; int totalArrays = N / K ; int minSum = 0 ; int i = selectMedian - 1 ; while ( i < N && totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } System . out . println ( minSum ) ; }
int strScore ( String str [ ] , String s , int n ) { int score = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) score += s . charAt ( j ) - ' a ' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }
long answer ( long n ) { long m = 2 ; long ans = 1 ; long r = 1 ; while ( r < n ) { r = ( ( long ) Math . pow ( 2 , m ) - 1 ) * ( ( long ) Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
int stirlingFactorial ( double n ) { if ( n == 1 ) return 1 ; double z ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; }
void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } System . out . print ( sum + " ▁ " ) ; } }
int minLength ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; }
int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
