int changeEvenBits ( int n ) { int to_subtract = 0 ; int m = 0 ; for ( int x = n ; x > 0 ; x >>= 2 ) { if ( ( x & 1 ) > 0 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
bool checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
void FindPairs ( int n , int k ) { Console . Write ( 1 + " ▁ " + n + " STRNEWLINE " ) ; k -- ; for ( long i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { Console . Write ( 1 + " ▁ " + i + " STRNEWLINE " ) ; k -- ; if ( k == 0 ) break ; if ( i != n / i ) { Console . Write ( 1 + " ▁ " + n / i + " STRNEWLINE " ) ; k -- ; } if ( k == 0 ) break ; } } }
void decrypt ( String Str , int Start , int End ) { if ( Start > End ) { return ; } int mid = ( Start + End ) >> 1 ; Console . Write ( Str [ mid ] ) ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
bool prefixDivisble ( int n ) { int i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = n / 10 ; i ++ ; } return true ; }
int minimum_required_operations ( int [ ] arr , int n , int k ) { int answer = 0 ; long mod = 1000000007 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer = ( int ) ( answer % mod ) ; } } return answer ; }
void transpose ( int [ , ] A ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i , j ] ; A [ i , j ] = A [ j , i ] ; A [ j , i ] = temp ; } }
void checkFactors ( long N ) { long ev_count = 0 , od_count = 0 ; for ( long i = 1 ; i <= Math . Sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) Console . Write ( " Yes " + " STRNEWLINE " ) ; else Console . Write ( " No " + " STRNEWLINE " ) ; }
int findevenPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; }
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
int enneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; }
int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
void Main ( String [ ] args ) { int n = 8 ; int [ ] v = Findpermutation ( n ) ; for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( v [ i ] + " ▁ " ) ; } }
int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
int minTime ( int [ ] arr , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . Min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . Min ( incl , excl ) ; }
int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; }
int countPairs ( int [ ] arr , int n ) { int ans = 0 ; Dictionary < int , int > count = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . ContainsKey ( arr [ i ] ) ) { ans += count [ arr [ i ] ] ; count [ arr [ i ] ] = count [ arr [ i ] ] + 1 ; } else { count . Add ( arr [ i ] , 1 ) ; } } return ans ; }
double findRadius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . Sqrt ( a3 / 3.14 ) ; return r3 ; }
void BeattySequence ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { double ans = Math . Floor ( i * Math . Sqrt ( 2 ) ) ; Console . Write ( ans + " , ▁ " ) ; } }
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = ( int ) ( Math . Pow ( a , n ) + Math . Pow ( b , n ) ) ; double c = Math . Pow ( pow_sum , 1.0 / n ) ; int c_pow = ( int ) Math . Pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { Console . WriteLine ( " Count ▁ example ▁ found " ) ; return ; } } Console . WriteLine ( " No ▁ counter ▁ example ▁ within " + " ▁ given ▁ range ▁ and ▁ data " ) ; }
void freq ( int [ , ] ar , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i , j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } Console . WriteLine ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " + odd ) ; Console . WriteLine ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ " + even ) ; }
int findSum ( int [ ] arr , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = Math . Min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
int countSubStr ( char [ ] str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
int search ( int [ ] arr , int x ) { int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
void findPairs ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = Math . Abs ( arr [ i ] ) ; Array . Sort ( arr ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } Console . Write ( ans ) ; }
int possibleStrings ( int n , int r , int b , int g ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
void pairStar ( String input , int i ) { output = output + input [ i ] ; if ( i == input . Length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' * ' ; pairStar ( input , i + 1 ) ; }
int findLCMPrime ( int a , int b ) { if ( a == b ) { return a ; } return a * b ; }
long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
int get ( int x , int y , int z ) { if ( x > z ) return - 1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; }
bool checkForSorting ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { else return false ; } } return true ; }
void printModulus ( int X , int Y ) { int n = Math . Max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) Console . Write ( i + " ▁ " ) ; } }
int findMinLength ( int [ ] arr ) { int index = ( int ) arr . Length - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }
int countCon ( int [ ] ar , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
int largestNum ( int a , int b ) { return a * ( ( a / b ) > 0 ? 1 : 0 ) + b * ( ( b / a ) > 0 ? 1 : 0 ) ; }
long factorial ( int n ) { long M = 1000000007 ; long f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) return f ; }
void possibleToReach ( int x , int y , int z ) { if ( z < Math . Abs ( x ) + Math . Abs ( y ) || ( z - Math . Abs ( x ) - Math . Abs ( y ) ) % 2 == 1 ) { Console . Write ( " Not ▁ Possible " + " STRNEWLINE " ) ; } else Console . Write ( " Possible " + " STRNEWLINE " ) ; }
int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . Pow ( x , 2 ) * ( Math . Pow ( x , 2 * n ) - 1 ) ) / ( Math . Pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . Pow ( x , n ) * Math . Pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; }
void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; Console . Write ( A + " ▁ " + B ) ; }
int countStrings ( String s ) { int cnt = 0 ; for ( int i = 1 ; i < s . Length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
int findLargestString ( String s , int i , int r ) { if ( i == s . Length ) { if ( r == 0 ) return 0 ; else return INT_MIN ; } if ( v [ i , r ] == 1 ) return dp [ i , r ] ; v [ i , r ] = 1 ; dp [ i , r ] = Math . Max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i , r ] ; }
int productPairs ( int [ ] arr , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = int . MinValue ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . Max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
int getCount ( int [ ] arr , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
int minimumX ( int n , int k ) { int mini = int . MaxValue ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . Min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . Min ( num2 , mini ) ; } } return mini ; }
int NumberofTimes ( String str ) { int temporary_sum = 0 , count = 0 ; while ( str . Length > 1 ) { temporary_sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) temporary_sum += ( str [ i ] - '0' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
double ReuleauxArea ( double r ) { if ( r < 0 ) return - 1 ; double A = 0.70477 * 2 * Math . Pow ( r , 2 ) ; return A ; }
int findMinRooms ( string [ ] slots , int n , int m ) { int [ ] counts = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
void thirdLargest ( int [ ] arr , int arr_size ) { if ( arr_size < 3 ) { Console . Write ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = - int . MaxValue ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = - int . MaxValue ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; Console . Write ( " The ▁ third ▁ Largest ▁ " + " element ▁ is ▁ " + third ) ; }
bool isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
void printSeriesSum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += Math . Pow ( i , i - 1 ) ; } Console . Write ( sum + " STRNEWLINE " ) ; }
Boolean validQuadruple ( int [ ] arr , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
long hexadecagonalNum ( long n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
bool isDivisibleBy5 ( String str ) { int n = str . Length ; return ( ( ( str [ n - 1 ] - '0' ) == 0 ) || ( ( str [ n - 1 ] - '0' ) == 5 ) ) ; }
int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 1 ] = insert ; for ( int i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . Min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = Math . Min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
int numberSequence ( int n ) { int num = ( int ) ( Math . Pow ( 4 , n ) - Math . Pow ( 2 , n ) ) - 1 ; return num ; }
int findSubarrays ( int [ ] arr , int N , int K ) { return N - K + 1 ; }
void FindTrip ( int [ ] arr , int N ) { for ( int i = 1 ; i < N - 1 ; i ++ ) { int p = arr [ i - 1 ] ; int q = arr [ i ] ; int r = arr [ i + 1 ] ; if ( p < q && q > r ) { Console . WriteLine ( ( i - 1 ) + " ▁ " + ( i ) + " ▁ " + ( i + 1 ) ) ; return ; } } Console . WriteLine ( - 1 ) ; }
double polyapothem ( double n , double a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . Tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
String reverse ( char [ ] str , int len , int l , int r ) { if ( l < 0 r >= len l > r ) return " Invalid ▁ range ! " ; while ( l < r ) { char c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } return String . Join ( " " , str ) ; }
long divide ( long dividend , long divisor ) { long sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . Abs ( dividend ) ; divisor = Math . Abs ( divisor ) ; long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1L L << i ; } } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
int MinimumMoves ( int [ ] a , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
int subsequence ( int [ ] S , int [ ] T , int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; int mod = 1000000007 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = 1 ; for ( int j = 0 ; j <= m ; j ++ ) dp [ 0 , j ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] - dp [ i - 1 , j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i , j ] += dp [ i - 1 , j - 1 ] ; dp [ i , j ] += mod ; dp [ i , j ] %= mod ; } } return dp [ n , m ] ; }
int findMaxSum ( int [ ] arr , int n ) { int [ ] preSum = new int [ n ] ; int [ ] suffSum = new int [ n ] ; int ans = int . MinValue ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . Max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . Max ( ans , preSum [ i ] ) ; } return ans ; }
int minMoves ( List < int > arr ) { int N = arr . Count ; if ( N <= 2 ) return 0 ; int ans = Int32 . MaxValue ; for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . Abs ( i ) + Math . Abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( Math . Abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . Abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag != 0 ) ans = Math . Min ( ans , moves ) ; } } if ( ans == Int32 . MaxValue ) return - 1 ; return ans ; }
void length_of_chord ( double r , double x ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ chord " + " ▁ of ▁ the ▁ circle ▁ is ▁ " + 2 * r * Math . Sin ( x * ( 3.14 / 180 ) ) ) ; }
int max_min ( int [ ] a , int n ) { Array . Sort ( a ) ; return Math . Min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
void Permutation ( int n , int k ) { int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( p [ i ] + " ▁ " ) ; }
void countElement ( int [ ] A , int N , int [ ] B , int M , int K ) { int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int currentElement = B [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { int diff = Math . Abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } Console . Write ( cnt ) ; }
void findFreq ( String str , int N ) { int [ ] freq = new int [ 256 ] ; int max = 0 ; char charMax = '0' ; for ( int i = 0 ; i < N ; i ++ ) { char ch = str [ i ] ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; charMax = ch ; } Console . WriteLine ( charMax + " ▁ - > ▁ " + max ) ; } }
int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . Max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
void evenXorSubarray ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int XOR = 0 ; for ( int j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } Console . WriteLine ( ans ) ; }
int equilibrium ( int [ ] arr , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
int countSubStr ( String str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
void PrintBothArrays ( int [ ] a , int n ) { List < int > v1 = new List < int > ( ) ; List < int > v2 = new List < int > ( ) ; Dictionary < int , int > mpp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mpp . ContainsKey ( a [ i ] ) ) mpp [ a [ i ] ] = mpp [ a [ i ] ] + 1 ; else mpp [ a [ i ] ] = 1 ; if ( mpp [ a [ i ] ] == 1 ) v1 . Add ( a [ i ] ) ; else if ( mpp [ a [ i ] ] == 2 ) v2 . Add ( a [ i ] ) ; else { Console . WriteLine ( " Not ▁ possible " ) ; return ; } } v1 . Sort ( ) ; Console . WriteLine ( " Strictly ▁ increasing ▁ array ▁ is : " ) ; for ( int i = 0 ; i < v1 . Count ; i ++ ) Console . Write ( v1 [ i ] + " ▁ " ) ; v2 . Sort ( ) ; v2 . Reverse ( ) ; Console . WriteLine ( " STRNEWLINE Strictly ▁ decreasing ▁ array ▁ is : " ) ; for ( int i = 0 ; i < v2 . Count ; i ++ ) Console . Write ( v2 [ i ] + " ▁ " ) ; }
int findTrailingZeros ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; else { int ans = 0 ; n /= 2 ; while ( n != 0 ) { ans += n / 5 ; n /= 5 ; } return ans ; } }
bool checkWord ( char [ , ] board , String word , int index , int row , int col ) { if ( row < 0 || col < 0 || row >= board . GetLength ( 0 ) || col >= board . GetLength ( 1 ) ) return false ; if ( board [ row , col ] != word [ index ] ) return false ; else if ( index == word . Length - 1 ) return true ; char temp = board [ row , col ] ; board [ row , col ] = ' * ' ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row , col ] = temp ; return true ; } board [ row , col ] = temp ; return false ; }
void printRoots ( long a , long b , long c ) { Console . WriteLine ( "1 , ▁ " + c / ( a * 1.0 ) ) ; }
int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
double hexDiagonal ( float a ) { if ( a < 0 ) return - 1 ; double d = ( double ) 1.73 * a ; return d ; }
int countDigit ( long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; }
void printLastElement ( int [ ] arr , int N ) { bool leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } Console . Write ( arr [ head - 1 ] ) ; }
int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
void countFreq ( int [ ] arr , int n ) { Boolean [ ] visited = new Boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } Console . WriteLine ( arr [ i ] + " ▁ " + count ) ; } }
int calc_distance ( int [ ] A , int [ ] B , int n ) { int distance_traveled_A = 0 ; int distance_traveled_B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
int pairs ( int n ) { int [ , ] c = new int [ 10 , 10 ] ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp , i % 10 ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += c [ i , j ] * c [ j , i ] ; return ans ; }
int linearSearch ( int [ ] arr , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
int minOperations ( string str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ ( i ) ] != str [ ( i + 1 ) ] ) count ++ ; } return ( count + 1 ) / 2 ; }
int minOperation ( int [ ] arr ) { int minOp = int . MinValue ; int minNeg = 0 , maxPos = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return Math . Abs ( minNeg ) + maxPos ; }
int maxHamming ( int [ ] arr , int n ) { int [ ] brr = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = Math . Max ( maxHam , currHam ) ; } return maxHam ; }
int mod ( int a , int m ) { return ( a % m + m ) % m ; }
void check ( int [ ] arr , int N ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
void count ( int n , int k ) { long count = ( long ) ( Math . Pow ( 10 , k ) - Math . Pow ( 10 , k - 1 ) ) ; Console . Write ( count ) ; }
int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( ( n - 2 ) * 180 ) ; }
int countNumbers ( int N ) { return ( int ) ( Math . Pow ( 10 , N ) - Math . Pow ( 8 , N ) ) / 2 ; }
int countToMake0lternate ( string s ) { int result = 0 ; for ( int i = 0 ; i < ( s . Length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
String check ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Dictionary < int , int > hm = new Dictionary < int , int > ( ) ; int count = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( hm . ContainsKey ( ( arr [ j ] ) ) ) hm [ arr [ j ] ] ++ ; else hm . Add ( arr [ j ] , 1 ) ; if ( hm [ arr [ j ] ] == 1 ) count ++ ; if ( hm [ arr [ j ] ] == 2 ) count -- ; if ( count == 0 ) return " No " ; } } return " Yes " ; }
int findSubstringCount ( string str ) { int result = 0 ; int n = str . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( char ) ( str [ i ] + 1 ) == str [ i + 1 ] ) { result ++ ; while ( ( char ) ( str [ i ] + 1 ) == str [ i + 1 ] ) { i ++ ; } } } return result ; }
int countDigits ( int n ) { return ( int ) ( n * Math . Log10 ( 2 ) + 1 ) ; }
int findPeak ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } return 0 ; }
long countNumberOfStrings ( String s ) { int n = s . Length - 1 ; long count = ( long ) ( Math . Pow ( 2 , n ) ) ; return count ; }
int posOfRightMostSameBit ( int m , int n ) { int loopCounter = 1 ; while ( m > 0 n > 0 ) { Boolean a = m % 2 == 1 ; Boolean b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return - 1 ; }
int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }
bool pairExists ( int [ ] arr1 , int m , int [ ] arr2 , int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s . Contains ( arr2 [ j ] - arr1 [ i ] ) ) return true ; } s . Add ( arr1 [ i ] ) ; } return false ; }
int largest ( int [ ] arr , int n ) { return arr . Max ( ) ; }
int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
void findEquation ( int A , int B , int C ) { Console . Write ( " ( " + C + " ) " + " x ^ 2 ▁ + ( " + B + " ) x ▁ + ▁ ( " + A + " ) ▁ = ▁ 0" ) ; }
int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
int getM ( int n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
void subtract ( int [ ] [ ] A , int [ ] [ ] B , int [ , ] C ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { C [ i , j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } } }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + n - 3 ; }
double volumeRec ( double a , double b , double e , double h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
long findNthNumber ( long N ) { long result = 0 ; long p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = N / 9 ; p = p * 10 ; } return result ; }
int countSquares ( int n ) { return ( int ) ( Math . Pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
int lis ( int [ ] arr , int n ) { int [ ] lis = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
Boolean isPossible ( int [ ] a , int n ) { int cur = a [ 0 ] ; cur -- ; for ( int i = 1 ; i < n ; i ++ ) { int nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }
double circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; }
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
int getMin ( int [ ] arr , int n ) { int minVal = arr . Min ( ) ; return minVal ; }
int colMaxDiff ( int [ , ] mat ) { int max_diff = int . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 , i ] , min_val = mat [ 0 , i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = Math . Max ( max_val , mat [ j , i ] ) ; min_val = Math . Min ( min_val , mat [ j , i ] ) ; } max_diff = Math . Max ( max_diff , max_val - min_val ) ; } return max_diff ; }
int findSmallestNumK ( int n ) { int cummAnd = n ; int i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
double area ( double d1 , double a ) { double d2 = Math . Sqrt ( 4 * ( a * a ) - d1 * d1 ) ; double area = 0.5 * d1 * d2 ; return area ; }
int evenNumSubstring ( string str ) { int len = str . Length ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
void printChar ( String str , int n ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 1 ) { Console . Write ( str [ i ] ) ; } } }
bool isPossible ( int [ ] A , int [ ] B , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Array . Sort ( A ) ; Array . Sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
int getMinOps ( int [ ] arr ) { int ans = 0 ; for ( int i = 0 ; i < arr . Length - 1 ; i ++ ) { ans += Math . Max ( arr [ i ] - arr [ i + 1 ] , 0 ) ; } return ans ; }
double MinimumMail ( int n , int k , int x ) { double m = ( n - 1 ) + Math . Ceiling ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . Ceiling ( n * 1.0 / x ) * ( k - n ) ; return m ; }
bool can_empty ( int a , int b , int c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = Math . Min ( a , Math . Min ( b , c ) ) ; if ( m < ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
string removeDuplicatesFromString ( string string1 ) { int counter = 0 ; char [ ] str = string1 . ToCharArray ( ) ; int i = 0 ; int size = str . Length ; int x ; int length = 0 ; while ( i < size ) { x = str [ i ] - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = ( char ) ( ' a ' + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return ( new string ( str ) ) . Substring ( 0 , length ) ; }
long centeredDodecagonal ( long n ) { return 6 * n * ( n - 1 ) + 1 ; }
int summation ( int N ) { int co = ( N + 1 ) / 2 ; int ce = ( N ) / 2 ; int se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; int so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . Pow ( 10 , n - 1 ) ) ; }
long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
int countUnique ( int [ , ] mat , int n , int m ) { int [ ] rowsum = new int [ n ] ; int [ ] colsum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i , j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i , j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . Min ( x , Math . Min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
int center_octadecagon_num ( int n ) { return 9 * n * n - 9 * n + 1 ; }
long polynomialRollingHash ( String str ) { int p = 31 ; int m = ( int ) ( 1e9 + 9 ) ; long power_of_p = 1 ; long hash_val = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { hash_val = ( hash_val + ( str [ i ] - ' a ' + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
bool isFibbinaryNum ( int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) Math . Pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }
void maxPossibleSum ( int [ ] arr , int N ) { Array . Sort ( arr ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } Console . WriteLine ( sum ) ; }
int maxWater ( int [ ] arr , int n ) { int left = 0 ; int right = n - 1 ; int l_max = 0 ; int r_max = 0 ; int result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += Math . Max ( 0 , r_max - arr [ right ] ) ; r_max = Math . Max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += Math . Max ( 0 , l_max - arr [ left ] ) ; l_max = Math . Max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
void maxArea ( int [ ] point_x , int [ ] point_y , int n , int length , int width ) { Array . Sort ( point_x ) ; Array . Sort ( point_y ) ; int dx = point_x [ 0 ] ; int dy = point_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = Math . Max ( dx , point_x [ i ] - point_x [ i - 1 ] ) ; dy = Math . Max ( dy , point_y [ i ] - point_y [ i - 1 ] ) ; } dx = Math . Max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) ; dy = Math . Max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) ; Console . WriteLine ( ( dx - 1 ) * ( dy - 1 ) ) ; }
double sumNodes ( int l ) { double leafNodeCount = Math . Pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; }
double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return Math . Sqrt ( r ) ; }
void Kroneckerproduct ( int [ , ] A , int [ , ] B ) { int [ , ] C = new int [ rowa * rowb , cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 , j + k + 1 ] = A [ i , j ] * B [ k , l ] ; Console . Write ( C [ i + l + 1 , j + k + 1 ] + " ▁ " ) ; } } Console . WriteLine ( ) ; } } }
bool Survives ( int n ) { for ( int i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= n / i ; } }
int countSwaps ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int max_frequency = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } max_frequency = Math . Max ( max_frequency , mp [ arr [ i ] ] ) ; } return n - max_frequency ; }
int maxLength ( int [ ] arr , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . Max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . Max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
bool isSubsetSum ( int [ ] set , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int No_of_cubes ( int N , int K ) { int No = 0 ; No = ( N - K + 1 ) ; No = ( int ) Math . Pow ( No , 3 ) ; return No ; }
void maxModProdSubarr ( int [ ] arr , int n , int M ) { int ans = 0 ; int length = n ; for ( int i = 0 ; i < n ; i ++ ) { int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } Console . WriteLine ( " Maximum ▁ subarray ▁ product ▁ is ▁ " + ans ) ; Console . WriteLine ( " Minimum ▁ length ▁ of ▁ the ▁ maximum ▁ " + " product ▁ subarray ▁ is ▁ " + length ) ; }
void printNSE ( int [ ] arr , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } Console . WriteLine ( arr [ i ] + " ▁ - - ▁ " + next ) ; } }
bool isPowerOfK ( int n , int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
float computeMaxValue ( float [ ] arr , int n ) { float ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { float val = Math . Max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = Math . Max ( ans , val ) ; } } return ans ; }
void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { double d = Math . Pow ( ( Math . Pow ( x2 - x1 , 2 ) + Math . Pow ( y2 - y1 , 2 ) + Math . Pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; Console . WriteLine ( " Distance ▁ is ▁ STRNEWLINE " + d ) ; return ; }
bool isLoeschian ( int n ) { for ( int x = 1 ; x <= Math . Sqrt ( n ) ; x ++ ) { for ( int y = 1 ; y <= Math . Sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
int countNegative ( int [ , ] M , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i , j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
float heightCalculate ( int H , int n , int m ) { float N = ( float ) ( n * 1.0 ) ; float M = ( float ) ( m * 1.0 ) ; float h = H * ( float ) Math . Sqrt ( N / ( N + M ) ) ; return h ; }
void Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( i * ( 7 * i - 5 ) / 2 ) ; Console . Write ( " ▁ " ) ; } }
int eulerian ( int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i , j ] = 1 ; else dp [ i , j ] = ( ( i - j ) * dp [ i - 1 , j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 , j ] ) ; } } } return dp [ n , m ] ; }
void findDecimal ( double [ ] arr , int N ) { int bit , power = 0 , result = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { bit = Math . Abs ( ( int ) Math . Floor ( arr [ i ] ) - ( int ) Math . Round ( arr [ i ] ) ) ; if ( bit != 0 ) result += ( int ) Math . Pow ( 2 , power ) ; power ++ ; } Console . WriteLine ( result ) ; }
int MatrixChainOrder ( int [ ] p , int n ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i , i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i , i + L ] = Math . Min ( dp [ i + 1 , i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i , i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 , n - 1 ] ; }
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
int findOccurrences ( string str1 , string substr1 ) { int counter = 0 ; for ( int i = 0 ; i < str1 . Length ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) { for ( int j = i + 1 ; j < str1 . Length ; j ++ ) { if ( str1 [ j ] == substr1 [ 1 ] ) { for ( int k = j + 1 ; k < str1 . Length ; k ++ ) { if ( str1 [ k ] == substr1 [ 2 ] ) counter ++ ; } } } } } return counter ; }
int lenOfLongSubarr ( int [ ] arr , int n ) { Dictionary < int , int > um = new Dictionary < int , int > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . ContainsKey ( sum ) ) um . Add ( sum , i ) ; if ( um . ContainsKey ( sum - 1 ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) c ; if ( Math . Floor ( z ) == Math . Ceiling ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . Max ( maxVal , x + y + ( int ) z ) ; } } return maxVal ; }
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] == 1 ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
bool isTwoAlter ( string s ) { for ( int i = 0 ; i < s . Length - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }
int count9s ( String number ) { int count = 0 ; int n = number . Length ; for ( int i = 0 ; i < n ; i ++ ) { int sum = number [ i ] - '0' ; if ( number [ i ] == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; }
void printDuplicates ( int [ ] arr , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { Console . Write ( arr [ i ] % n + " ▁ " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! ( fl > 0 ) ) Console . Write ( " - 1" ) ; }
int countSubsequences ( int [ ] arr , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) % 2 == 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; }
int getPairsCount ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . Abs ( i - j ) ) count ++ ; } } return count ; }
void answer ( int L , int R ) { if ( 2 * L <= R ) Console . WriteLine ( L + " , ▁ " + ( 2 * L ) ) ; else Console . WriteLine ( " - 1" ) ; }
void precompute ( string s , string K ) { int n = s . Length ; for ( int i = 0 ; i < n - 2 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] ; if ( s . Substring ( i , K . Length ) . Equals ( K ) ) { cnt [ i + 1 ] += 1 ; } } cnt [ n - 2 + 1 ] = cnt [ n - 2 ] ; }
int check ( int n , int m ) { if ( m % n == 0 ) { Console . Write ( " YES " ) ; } else { Console . Write ( " NO " ) ; } return 0 ; }
int det ( int [ , ] d ) { int Sum = d [ 0 , 0 ] * ( ( d [ 1 , 1 ] * d [ 2 , 2 ] ) - ( d [ 2 , 1 ] * d [ 1 , 2 ] ) ) ; Sum -= d [ 0 , 1 ] * ( ( d [ 1 , 0 ] * d [ 2 , 2 ] ) - ( d [ 1 , 2 ] * d [ 2 , 0 ] ) ) ; Sum += d [ 0 , 2 ] * ( ( d [ 0 , 1 ] * d [ 1 , 2 ] ) - ( d [ 0 , 2 ] * d [ 1 , 1 ] ) ) ; return Sum ; }
int countEvenPairs ( int N , int M ) { int count = 0 ; int nEven = ( int ) Math . Floor ( ( double ) N / 2 ) ; int nOdd = ( int ) Math . Ceiling ( ( double ) N / 2 ) ; int mEven = ( int ) Math . Floor ( ( double ) M / 2 ) ; int mOdd = ( int ) Math . Ceiling ( ( double ) M / 2 ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
void solve ( int n , int d , int [ ] input ) { int [ ] a = new int [ N ] ; int [ ] cnt = new int [ V + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) a [ i ] = input [ i ] ; int answer = 0 ; for ( int i = 0 ; i < d ; ++ i ) cnt [ a [ i ] ] ++ ; for ( int i = d ; i <= n - 1 ; ++ i ) { int acc = 0 ; int low_median = - 1 , high_median = - 1 ; for ( int v = 0 ; v <= V ; ++ v ) { acc += cnt [ v ] ; if ( low_median == - 1 && acc >= ( int ) ( Math . Floor ( ( d + 1 ) / 2.0 ) ) ) low_median = v ; if ( high_median == - 1 && acc >= ( int ) ( Math . Ceiling ( ( d + 1 ) / 2.0 ) ) ) high_median = v ; } int double_median = low_median + high_median ; if ( a [ i ] >= double_median ) answer ++ ; cnt [ a [ i - d ] ] -- ; cnt [ a [ i ] ] ++ ; } Console . Write ( answer + " STRNEWLINE " ) ; }
void maximumValue ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = Math . Max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } Console . Write ( ans ) ; }
int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i , curr ] = l ; if ( r != - 1 ) dp [ i , curr ] = Math . Max ( dp [ i , curr ] , r + 1 ) ; return dp [ i , curr ] ; }
void findPairs ( int [ ] arr1 , int [ ] arr2 , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) Console . WriteLine ( arr1 [ i ] + " ▁ " + arr2 [ j ] ) ; }
int smallest_pair ( int [ ] a , int n ) { int min = int . MaxValue , secondMin = int . MaxValue ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
int maxSum ( int N ) { int ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum ; int max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
int minMovesToSort ( int [ ] arr , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; }
void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; Console . WriteLine ( " The ▁ Perimeter ▁ of ▁ " + " Decagon ▁ is ▁ : ▁ " + Perimeter ) ; }
long sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( long ) Math . Pow ( n , n ) + sum ( n - 1 ) ) ; }
void path_to_root ( int node ) { while ( node >= 1 ) { Console . Write ( node + " ▁ " ) ; node /= 2 ; } }
string check ( int current_row , int current_col , int destination_row , int destination_col ) { if ( current_row == destination_row ) return " POSSIBLE " ; else if ( current_col == destination_col ) return " POSSIBLE " ; else return " NOT ▁ POSSIBLE " ; }
void findSumOfAllSubsets ( int [ ] arr , int n , int k ) { int factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( int i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( int i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; int freq = factorial_N / ( factorial_d * factorial_D ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; Console . WriteLine ( " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " + k + " ▁ is ▁ = > ▁ " + sum ) ; }
int maximumCandy ( int [ ] candies , int [ ] safety , int N , int M ) { int total = 0 ; int ans = Int32 . MaxValue ; bool all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . Min ( ans , safety [ i ] ) ; } else { ans = Math . Min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n != 0 ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
float sphere ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; return r ; }
float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
