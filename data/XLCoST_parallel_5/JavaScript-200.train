function checkPowerof8 ( n ) { let i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; }
function alternatingSumOfFirst_N ( N ) { var alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
function centeredHexagonalNumber ( n ) { return 3 * n * ( n - 1 ) + 1 ; }
function sumFib ( N ) { var num = Math . round ( Math . pow ( ( Math . sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / Math . sqrt ( 5 ) ) ; document . write ( num - 1 ) ; }
function findEquation ( a , b ) { var sum = ( a + b ) ; var product = ( a * b ) ; document . write ( " " + sum + " " + product + " " ) ; }
function count ( n ) { var cnt = 0 ; var p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
function maxPeople ( p ) { var tmp = 0 , count = 0 ; for ( var i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
function maxDistance ( arr , n ) { let map = new Map ( ) ; let max_dist = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! map . has ( arr [ i ] ) ) map . set ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ; } return max_dist ; }
function getIndexInSortedArray ( arr , n , idx ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
function Last_set_bit ( n ) { let p = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) { return p ; } p ++ ; n = n >> 1 ; } return - 1 ; } let n = 18 ; let pos = Last_set_bit ( n ) ; if ( pos != - 1 ) { document . write ( pos ) ; } else { document . write ( 0 ) ; }
function calculateSum ( n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
function sumofsquare ( n ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } let sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
function maxEvenIntegers ( arr , N , M ) { let ans = 0 ; for ( let i = 0 ; i <= N - M ; i ++ ) { let cnt = 0 ; for ( let j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . max ( ans , cnt ) ; } return ans ; }
function poorPigs ( buckets , minutesToDie , minutesToTest ) { document . write ( Math . ceil ( Math . log ( buckets ) / Math . log ( ( minutesToTest / minutesToDie ) + 1 ) ) ) ; }
function find ( arr , N ) { let Sum = 0 ; let i = 0 ; let ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { Sum += arr [ i ] ; } if ( Sum % N ) { return - 1 ; } else { k = Math . floor ( Sum / N ) ; ans = 0 ; i = 0 ; while ( i < N ) { ans = ans + Math . abs ( k - arr [ i ] ) ; i += 1 ; } } return Math . floor ( ans / 2 ) ; }
function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function dist ( x1 , y1 , x2 , y2 , r ) { document . write ( " " + " " + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) . toFixed ( 5 ) ) ; }
function countSquares ( m , n ) { if ( n < m ) { var temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
function checkSolution ( a , b , c ) { if ( a == c ) document . write ( " " ) ; else document . write ( " " ) ; }
function areVowelsInOrder ( s ) { var n = s . length ; var c = String . fromCharCode ( 64 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }
function checkEVENodd ( arr , n , l , r ) { if ( arr [ r ] == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function countways ( n ) { let A = new Array ( n + 1 ) . fill ( 0 ) ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( let i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; }
function MaxRearrngeSum ( A , B , N ) { A . sort ( ) ; B . sort ( ) ; B . reverse ( ) ; let maxSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { maxSum += Math . abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
function product ( mat , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return d1 * d2 ; }
function checkVantieghemsTheorem ( limit ) { let prod = 1 ; for ( let n = 2 ; n < limit ; n ++ ) { if ( n == 2 ) document . write ( 2 + " " + " " ) ; if ( ( ( prod - n ) % ( ( 1 << n ) - 1 ) ) == 0 ) document . write ( n + " " + " " ) ; prod *= ( ( 1 << n ) - 1 ) ; } }
function findMean ( arr , l , r ) { let sum = 0 , count = 0 ; for ( let i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } let mean = Math . floor ( sum / count ) ; return mean ; }
function countSubset ( arr , n , diff ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum += diff ; sum = sum / 2 ; var t = new Array ( n + 1 ) ; for ( var i = 0 ; i < t . length ; i ++ ) { t [ i ] = new Array ( sum + 1 ) ; } for ( var i = 0 ; i < t . length ; i ++ ) { for ( var j = 0 ; j < t [ i ] . length ; j ++ ) { t [ i ] [ j ] = 0 ; } } for ( var j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( var i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; }
function fun ( n ) { return n & ( n - 1 ) ; }
function hIndex ( citations , n ) { let hindex = 0 ; let low = 0 , high = n - 1 ; while ( low <= high ) { let mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } document . write ( hindex ) ; return hindex ; }
function allCharactersSame ( s ) { let s1 = new Set ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { s1 . add ( s [ i ] ) ; } if ( s1 . size == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function getTotalXorOfSubarrayXors ( arr , N ) { if ( N % 2 == 0 ) return 0 ; let res = 0 ; for ( let i = 0 ; i < N ; i += 2 ) { res ^= arr [ i ] ; } return res ; }
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
function no_of_ways ( a , n ) { let count_0 = 0 , count_1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
function countTotalFrequencies ( S1 , S2 ) { var bset = new Set ( ) ; for ( var i = 0 ; i < S1 . length ; i ++ ) { bset . add ( S1 [ i ] ) ; } var count = 0 ; for ( var i = 0 ; i < S2 . length ; i ++ ) { if ( bset . has ( S2 [ i ] ) ) count += 1 ; } document . write ( count ) ; }
function checkIsFibonacci ( arr , n ) { if ( n == 1 n == 2 ) return true ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 2 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; } return true ; }
function numbers ( n ) { return ( Math . pow ( 2 , n + 1 ) ) - 2 ; }
function maximumResult ( a , b , c ) { let countOfNegative = 0 ; let sum = a + b + c ; let product = a * b * c ; let largest = Math . max ( a , Math . max ( b , c ) ) ; let smallest = Math . min ( a , Math . min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } }
function findSmallestNumK ( n ) { let cummAnd = n ; let i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
function getParity ( n ) { var parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
function isEven ( n ) { if ( n ^ 1 == n + 1 ) return true ; else return false ; }
function minimumMoves ( k , l , r ) { let count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
function findSum ( n ) { let sum = 0 ; for ( x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
function term ( n ) { return parseInt ( n * ( n + 1 ) / 2 ) ; }
function check ( n , m ) { if ( n == 2 m == 2 n % m == 0 ) { document . write ( " " + " " ) ; } else { document . write ( " " + " " ) ; } }
function getX ( a , b , c , d ) { var X = ( b * c - a * d ) / ( d - c ) ; return X ; }
function countDigit ( n ) { let temp = n , count = 0 ; while ( temp != 0 ) { let d = temp % 10 ; temp = Math . floor ( temp / 10 ) ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
function EqualNumbers ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; }
function minimumTime ( arr , n ) { var sum = 0 ; var T = Math . max ( ... arr ) ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } document . write ( Math . max ( 2 * T , sum ) ) ; }
function findWinner ( x , y , n ) { var dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( var i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 && ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 && ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
function isConvertible ( str1 , str2 , k ) { if ( ( str1 . length + str2 . length ) < k ) return true ; var commonLength = 0 ; for ( var i = 0 ; i < Math . min ( str1 . length , str2 . length ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length - str2 . length + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
function prletMissingElements ( arr , N ) { let diff = arr [ 0 ] - 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { document . write ( ( i + diff ) + " " ) ; diff ++ ; } } } }
function countNums ( n , x , y ) { arr = Array ( n + 1 ) . fill ( false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; var result = 0 ; for ( i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
function odd_even ( arr , n ) { var odd_indexes = [ ] ; var even_indexes = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . push ( arr [ i ] ) ; else even_indexes . push ( arr [ i ] ) ; } odd_indexes . sort ( ) ; even_indexes . sort ( ) ; for ( var i = 0 ; i < odd_indexes . length ; i ++ ) document . write ( odd_indexes [ i ] + " " ) ; for ( var i = 0 ; i < even_indexes . length ; i ++ ) document . write ( even_indexes [ i ] + " " ) ; }
function Area ( a ) { if ( a < 0 ) return - 1 ; let x = 0.464 * a ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
function possibleNumbers ( numbers , N , M , A , B ) { if ( M == 0 ) { numbers . add ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; } var N = 5 , M = 3 , A = 4 , B = 6 ; var numbers = new Set ( ) ; possibleNumbers ( numbers , N , M , A , B ) ; for ( let x of numbers ) { document . write ( x + ' ' ) ; }
function clearLastBit ( N , K ) { var mask = ( - 1 << K + 1 ) ; return N = N & mask ; }
function Digits ( n ) { let largest = 0 ; let smallest = 9 ; while ( n ) { let r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = parseInt ( n / 10 ) ; } document . write ( largest + " " + smallest ) ; }
function smallest ( s ) { var a = Array ( s . length ) ; for ( var i = 0 ; i < s . length ; i ++ ) a [ i ] = s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; var b = [ ] ; for ( var i = 0 ; i < a . length ; i ++ ) { if ( ( a [ i ] ) % 2 != 0 ) b . push ( a [ i ] ) ; } b . sort ( ( a , b ) => a - b ) ; if ( b . length > 1 ) return ( b [ 0 ] ) * 10 + ( b [ 1 ] ) ; return - 1 ; }
function rankLessThanK ( arr , k , n ) { let rank = 1 ; let position = 1 ; arr . sort ( ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
function search ( arr , n , x ) { let res = - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; let temp = arr [ res ] ; for ( let i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
function countStr ( n , bCount , cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; let res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
function printDuplicates ( arr , n ) { let i ; let fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { document . write ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) document . write ( " " ) ; }
function linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( let i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } } let Xo = 5 ; let m = 7 ; let a = 3 ; let c = 3 ; let noOfRandomNums = 10 ; let randomNums = new Array ( noOfRandomNums ) . fill ( 0 ) ; linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) ; for ( let i = 0 ; i < noOfRandomNums ; i ++ ) { document . write ( randomNums [ i ] + " " ) ; }
function countMultiples ( n ) { return Math . floor ( n / 3 + n / 7 - n / 21 ) ; }
function countDigit ( n ) { let temp = n ; let sum = 0 ; let product = 1 ; while ( temp != 0 ) { let d = temp % 10 ; temp = parseInt ( temp / 10 ) ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } document . write ( " " + sum ) ; document . write ( " " + product ) ; }
function hectagonNum ( n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
function binarySearch ( arr , x ) { let l = 0 , r = arr . length - 1 ; while ( l <= r ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; let res = x . localeCompare ( arr [ m ] ) ; if ( res == 0 ) return m ; if ( res > 0 ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
function findKHCF ( x , y , k ) { let small = Math . min ( x , y ) ; let count = 1 ; for ( let i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; }
function countWays ( N ) { let E = parseInt ( ( N * ( N - 1 ) ) / 2 , 10 ) ; if ( N == 1 ) return 0 ; return Math . pow ( 2 , E - 1 ) ; }
function maxSumWO3Consec ( n ) { if ( sum [ n ] != - 1 ) { return sum [ n ] ; } if ( n == 0 ) { return sum [ n ] = 0 ; } if ( n == 1 ) { return sum [ n ] = arr [ 0 ] ; } if ( n == 2 ) { return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; } return sum [ n ] = 500 + Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
function contain ( L , U , M ) { let count = 0 ; for ( let j = L ; j < U ; j ++ ) { let num = new Set ( ) ; let str = String ( j ) ; num . add ( str ) ; if ( j % M == 0 && ! num . has ( String ( M ) ) ) { count += 1 ; } } document . write ( count - 2 ) ; }
function totalTriangles ( h , v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; var total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
function getM ( n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
function countStrings ( n , m , s ) { let ind = new Set ( ) ; for ( let j = 0 ; j < m ; j ++ ) { let mx = 0 ; for ( let i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , ( s [ i ] [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) == mx ) ind . add ( i ) ; } return ind . size ; }
function isPowerOfK ( n , k ) { let oneSeen = false ; while ( n > 0 ) { let digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n = Math . floor ( n / k ) ; } return true ; }
function completeSequence ( s ) { let n = s . length ; let open = 0 , close = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) open ++ ; else close ++ ; if ( close > open ) { document . write ( " " ) ; return ; } } document . write ( s ) ; for ( let i = 0 ; i < open - close ; i ++ ) document . write ( " " ) ; }
function countRhombi ( h , w ) { let ct = 0 ; for ( let i = 2 ; i <= h ; i += 2 ) for ( let j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
function center_hexadecagonal_num ( n ) { return 8 * n * n - 8 * n + 1 ; }
function prevGreater ( arr , n ) { document . write ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { let j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { document . write ( arr [ j ] + " " ) ; break ; } } if ( j == - 1 ) document . write ( " " ) ; } }
function printNonConsecutive ( n ) { let p = ( 1 << n ) ; for ( let i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) document . write ( i + " " ) ; }
function compute ( a , b ) { var AM = ( a + b ) / 2 ; var GM = Math . sqrt ( a * b ) ; var HM = ( GM * GM ) / AM ; return HM ; }
function countOccurrences ( arr , n , x ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x == arr [ i ] ) res ++ ; } return res ; }
function harmonicMean ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + ( 1 / arr [ i ] ) ; return n / sum ; }
function findNthTerm ( n ) { document . write ( ( Math . pow ( 2 , n ) ) - ( 2 * n ) ) ; }
function minOperation ( N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } let k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
function odd_digits ( n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , parseInt ( y / 2 ) ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
function temp_convert ( F1 , B1 , F2 , B2 , T ) { var t2 ; t2 = F2 + ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
function findCountOfSolutions ( n , p ) { let ans = 0 ; for ( let x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { let last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
function perfectPowerOf2 ( n ) { let per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
function isSumEqual ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
function countSetBits ( n ) { let i = 0 ; let ans = 0 ; while ( ( 1 << i ) <= n ) { let k = 0 ; let change = 1 << i ; for ( let j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
function pow ( a , b ) { if ( b == 0 ) return 1 ; var answer = a ; var increment = a ; var i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
function area_of_segment ( radius , angle ) { let area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; let area_of_triangle = 1 / 2 * ( radius * radius ) * Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
function cal_cos ( n ) { let accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; let i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; document . write ( cosx . toFixed ( 5 ) ) ; }
function findPolet ( n , h ) { for ( let i = 1 ; i < n ; i ++ ) document . write ( Math . sqrt ( i / ( n * 1.0 ) ) * h + " " ) ; }
function find ( index , openbrk , n , adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
function countSubarrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let product = 1 ; for ( let x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
function canMakeEqual ( S ) { var N = S . length ; var weightOfString = 0 ; for ( var i = 0 ; i < N ; i ++ ) { weightOfString += S . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ; } if ( weightOfString % N == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function minSumDifference ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; let rem = sum % n ; return rem * ( n - rem ) ; }
function singleNumber ( nums , n ) { let m = new Map ( ) ; let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! m . has ( nums [ i ] ) ) { sum1 += nums [ i ] ; m . set ( nums [ i ] , 1 ) ; } sum2 += nums [ i ] ; } return ( 2 * ( sum1 ) - sum2 ) ; }
function areaSquare ( L , B ) { let large = Math . max ( L , B ) ; let small = Math . min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } }
function LIS ( a , n ) { let dp = new Array ( ) ; let d = new Array ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
function Regions ( Vertices , Edges ) { var R = Edges + 2 - Vertices ; return R ; }
function findMinDiff ( arr , n ) { let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
function isSymmetric ( mat , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
function countOfMultiples ( n ) { return ( parseInt ( n / 3 , 10 ) + parseInt ( n / 5 , 10 ) - parseInt ( n / 15 , 10 ) ) ; }
function minSteps ( str , n , k ) { if ( str [ n - 1 ] == ' ' ) return - 1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; var dp = Array ( n ) ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( var i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) continue ; var steps = 1000000000 ; if ( i + k < n && str [ i + k ] == ' ' ) steps = Math . min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == ' ' ) steps = Math . min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == ' ' ) steps = Math . min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == 1000000000 ) ? steps : 1 + steps ; } if ( dp [ 0 ] == 1000000000 ) return - 1 ; return dp [ 0 ] ; }
function totalSubSets ( n , l , r ) { let zero = Math . floor ( r / 3 ) - Math . ceil ( l / 3 ) + 1 ; let one = Math . floor ( ( r - 1 ) / 3 ) - Math . ceil ( ( l - 1 ) / 3 ) + 1 ; let two = Math . floor ( ( r - 2 ) / 3 ) - Math . ceil ( ( l - 2 ) / 3 ) + 1 ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( let i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
function matrixSum ( arr ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
function isPentagonal ( N ) { var i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
function compute ( str , n ) { let reverseAlphabet = " " ; let l = str . length ; let answer = " " ; for ( let i = 0 ; i < n ; i ++ ) answer = answer + str [ i ] ; for ( let i = n ; i < l ; i ++ ) answer = answer + reverseAlphabet [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ; return answer ; }
function CountTriplets ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let first = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
function cntSubsets ( arr , n ) { var a = Array ( n ) ; var b = Array ( n ) ; a [ 0 ] = b [ 0 ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } var result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
function findOddPair ( A , N ) { var i , j ; var oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
function minimumAdjacentDifference ( a , n , k ) { let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i <= k ; i ++ ) { let maxDiff = Number . MIN_VALUE ; for ( let j = 0 ; j < n - k - 1 ; j ++ ) { for ( let p = i ; p <= i + j ; p ++ ) { maxDiff = Math . max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; } } minDiff = Math . min ( minDiff , maxDiff ) ; } return minDiff ; }
function divisible ( num ) { let n = num . length ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - ' ' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
function findSum ( n ) { let ans = 0 , temp = 0 , num ; for ( let i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
function printCombination ( n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( let j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( let k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { document . write ( i + " " + j + " " + k ) ; return ; } } } } } } }
function MinOperation ( a , b , n ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
function ceilDifference ( arr , n , x ) { var totalSum = 0 ; var perElementSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += parseInt ( Math . ceil ( ( arr [ i ] ) / ( x ) ) ) ; } var totalCeilSum = parseInt ( Math . ceil ( ( totalSum ) / ( x ) ) ) ; return Math . abs ( perElementSum - totalCeilSum ) ; }
function checkArrangement ( A1 , A2 , n , k ) { A1 . sort ( ) ; A2 . sort ( ) ; A2 . reverse ( ) ; let flag = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findEletobeInserted ( A , n , k ) { var ans = k ; for ( var i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; }
function deleteElement ( A , L , R , N ) { let i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
function compareVal ( x , y ) { let a = y * Math . log ( x ) ; let b = x * Math . log ( y ) ; if ( a > b ) document . write ( x + " " + y + " " + y + " " + x ) ; else if ( a < b ) document . write ( x + " " + y + " " + y + " " + x ) ; else if ( a == b ) document . write ( x + " " + y + " " + y + " " + x ) ; }
function countStrings ( n ) { let a = [ ] , b = [ ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
function countSubString ( s ) { let res = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { let x = 0 ; for ( let j = i ; j < s . length ; j ++ ) { let temp = 1 << s [ j ] - ' ' ; x ^= temp ; if ( ( x & ( x - 1 ) ) == 0 ) res ++ ; } } document . write ( res ) ; }
function noOfTriangles ( n ) { return Math . floor ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
function findAandB ( N ) { let K = Math . log2 ( N ) ; let B = ( 1 << K ) ; let A = B ^ N ; document . write ( A + ' ' + B ) ; }
function setBitNumber ( n ) { if ( n == 0 ) return 0 ; let msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = $n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
function minServerLoads ( n , servers ) { var totalLoad = 0 ; servers . forEach ( i => { totalLoad += i ; } ) ; var requiredLoad = parseInt ( totalLoad / 2 ) ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( requiredLoad + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i < n + 1 ; i ++ ) { for ( var j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n ] [ requiredLoad ] ; }
function minimumOperations ( arr , N ) { let mx = 0 , pos = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } document . write ( ( mx - 1 ) * N + pos + 1 ) ; }
function day_of_the_week ( y , m , d ) { let t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
function countPairsBruteForce ( X , Y , m , n ) { let ans = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( ( Math . pow ( X [ i ] , Y [ j ] ) > Math . pow ( Y [ j ] , X [ i ] ) ) ) { ans += 1 ; } } } return ans ; }
function sumSquare ( n ) { for ( i = 1 ; i * i <= n ; i ++ ) for ( j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { document . write ( i + " " + j + " " + " " ) ; return true ; } return false ; }
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i ; j < N ; j ++ ) for ( let k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
function term ( n ) { let x = parseInt ( ( ( 1 ) + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
function CountMaximum ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
function findCnt ( s , i , r ) { if ( i == s . length ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - ' ' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i ] [ r ] ; }
function fnMod ( n ) { var rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
function insertNames ( arr , n ) { let set = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! set . has ( arr [ i ] ) ) { document . write ( " " + " " ) ; set . add ( arr [ i ] ) ; } else { document . write ( " " + " " ) ; } } }
function solve ( a , n ) { let ones = 0 , twos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } let ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; let evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( let i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + " " ) ; }
function countPS ( i , j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
function countStrings ( s ) { let cnt = 0 ; for ( let i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
function isReversible ( str ) { var i = 0 , j = str . length - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
function longestAlternating ( arr , n ) { let count = new Array ( n ) ; count [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count [ i ] + " " ) ; }
function constructArray ( N ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( i + " " ) ; } }
function distancesum ( x , y , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
function findExtraCharcter ( strA , strB ) { let m1 = new Array ( 256 ) ; for ( let i = 0 ; i < 256 ; i ++ ) m1 [ i ] = 0 ; for ( let i = 0 ; i < strB . length ; i ++ ) m1 [ strB [ i ] . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < strA . length ; i ++ ) m1 [ strA [ i ] . charCodeAt ( 0 ) ] -- ; for ( let i = 0 ; i < m1 . length ; i ++ ) { if ( m1 [ i ] == 1 ) return String . fromCharCode ( i ) ; } return Number . MIN_VALUE ; }
function generatepermutation ( N ) { var answer = [ ] ; answer . push ( N ) ; console . log ( answer ) ; for ( var i = 1 ; i < N ; i ++ ) { console . log ( answer ) ; answer . push ( i ) ; } for ( var i in answer ) document . write ( answer [ i ] + " " ) ; }
function EditDistDP ( str1 , str2 ) { let len1 = str1 . length ; let len2 = str2 . length ; let DP = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { DP [ i ] = new Array ( len1 + 1 ) ; for ( let j = 0 ; j < len1 + 1 ; j ++ ) DP [ i ] [ j ] = 0 ; } for ( let i = 0 ; i <= len1 ; i ++ ) DP [ 0 ] [ i ] = i ; for ( let i = 1 ; i <= len2 ; i ++ ) { for ( let j = 0 ; j <= len1 ; j ++ ) { if ( j == 0 ) DP [ i % 2 ] [ j ] = i ; else if ( str1 [ j - 1 ] == str2 [ i - 1 ] ) { DP [ i % 2 ] [ j ] = DP [ ( i - 1 ) % 2 ] [ j - 1 ] ; } else { DP [ i % 2 ] [ j ] = 1 + Math . min ( DP [ ( i - 1 ) % 2 ] [ j ] , Math . min ( DP [ i % 2 ] [ j - 1 ] , DP [ ( i - 1 ) % 2 ] [ j - 1 ] ) ) ; } } } document . write ( DP [ len2 % 2 ] [ len1 ] + " " ) ; }
function printPairs ( arr , n , sum ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; }
function aliquotSum ( n ) { let sum = 0 ; for ( let i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
function largest ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] ; }
function pythagorean_quadruple ( a , b , c , d ) { let sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
function centeredDodecagonal ( n ) { return 6 * n * ( n - 1 ) + 1 ; }
function printString ( str , n ) { let ones = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( str [ i ] == ' ' ) ones ++ ; let used = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' && ! used ) { used = true ; for ( let j = 0 ; j < ones ; j ++ ) document . write ( " " ) ; } if ( str [ i ] != ' ' ) document . write ( str [ i ] ) ; } if ( ! used ) for ( let j = 0 ; j < ones ; j ++ ) document . write ( " " ) ; }
function countTriangles ( a , n ) { var cnt = 0 ; var pairs = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += parseInt ( ( 2 * pairs ) / 3 ) ; return cnt ; }
function mod ( num , a ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) res = ( res * 10 + num [ i ] - ' ' ) % a ; return res ; }
function isKPartitionPossible ( arr , N , K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; let target = sum / K ; let dp = Array . from ( { length : ( 1 << 15 ) } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == - 1 ) continue ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( ( mask & ( 1 << i ) ) == 0 ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; } let arr = [ 2 , 1 , 4 , 5 , 3 , 3 ] ; let N = arr . length ; let K = 3 ; if ( isKPartitionPossible ( arr , N , K ) ) { document . write ( " " ) ; document . write ( " " ) ; } else { document . write ( " " ) ; document . write ( " " ) ; }
function maxSum ( a , n ) { var maxAnd = Math . max ( ... a ) ; var maxOR = 0 ; for ( var i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } document . write ( ( maxAnd + maxOR ) ) ; }
function deleteElement ( arr , n , x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; let prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { let curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
function isNumber ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] < ' ' s [ i ] > ' ' ) return false ; return true ; }
function check ( current_row , current_col , destination_row , destination_col ) { if ( current_row == destination_row ) return " " ; else if ( current_col == destination_col ) return " " ; else return " " ; }
function minimumOperations ( arr , N ) { let oddCnt = 0 , evenCnt = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } document . write ( Math . min ( oddCnt , evenCnt ) ) ; }
function highestPowerOfTwo ( num ) { var s = num . toString ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] === " " ) { document . write ( " " ) ; continue ; } var lg = parseInt ( Math . log2 ( s [ i ] . charCodeAt ( 0 ) - 48 ) ) ; var p = Math . pow ( 2 , lg ) ; document . write ( String . fromCharCode ( p + 48 ) ) ; } }
function countPairs ( arr , N ) { let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } let ans = ( N - odd + Math . floor ( odd / 2 ) - 1 ) + Math . floor ( odd / 2 ) ; return ans ; }
function minAnglRot ( N ) { let res ; res = 360 / N ; return res ; }
function pointIsOnLine ( m , c , x , y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
function isAnBn ( str ) { let n = str . length ; if ( ( n & 1 ) != 0 ) return " " ; let i ; for ( i = 0 ; i < n / 2 ; i ++ ) if ( str [ i ] != ' ' str [ n - i - 1 ] != ' ' ) return " " ; return " " ; }
function reduceZero ( N ) { var dp = Array ( N + 1 ) . fill ( 1000000000 ) ; dp [ 0 ] = 0 ; for ( var i = 0 ; i <= N ; i ++ ) { for ( var j = 0 ; j < i . toString ( ) . length ; j ++ ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i - ( i . toString ( ) [ j ] - ' ' ) ] + 1 ) ; } } return dp [ N ] ; }
function findbitwiseOR ( a , n ) { var res = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; document . write ( res ) ; }
function angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) { let num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; let den = Math . sqrt ( Math . pow ( ( x2 - x1 ) , 2 ) + Math . pow ( ( y2 - y1 ) , 2 ) + Math . pow ( ( z2 - z1 ) , 2 ) ) * Math . sqrt ( Math . pow ( ( x3 - x1 ) , 2 ) + Math . pow ( ( y3 - y1 ) , 2 ) + Math . pow ( ( z3 - z1 ) , 2 ) ) ; let angle = Math . acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
function getProbability ( p , q ) { p /= 100 ; q /= 100 ; let probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
function areChractersUnique ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
function findNum ( N , K ) { var rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
function absSumDidd ( a ) { a . sort ( ( a , b ) => a - b ) ; var midValue = a [ a . length / 2 ] ; var sum = 0 ; for ( var i = 0 ; i < a . length ; i ++ ) { sum = sum + Math . abs ( a [ i ] - midValue ) ; } return sum ; }
function possibleTriplets ( arr , N ) { var freq = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( freq * 1 * ( freq - 1 ) * ( freq - 2 ) ) / 6 ; }
function checkSolveable ( n , m ) { if ( n == 1 m == 1 ) document . write ( " " ) ; else if ( m == 2 && n == 2 ) document . write ( " " ) ; else document . write ( " " ) ; }
function lastRemaining ( n , dp ) { if ( dp . hasOwnProperty ( n ) ) return dp [ n ] ; if ( n === 1 ) return 1 ; else dp [ n ] = 2 * ( 1 + parseInt ( n / 2 ) - lastRemaining ( parseInt ( n / 2 ) , dp ) ) ; return dp [ n ] ; } var N = 5 ; var dp = { }
function findSteps ( n , m , a ) { var cur = 1 ; var steps = 0 ; for ( var i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
function checksum ( n ) { if ( n % 3 == 0 ) document . write ( n / 3 - 1 + " " + n / 3 + " " + ( n / 3 + 1 ) ) ; else document . write ( " " ) ; }
function minOpsToEmptyString ( S , N ) { let one = 0 , zero = 0 ; let x0 = 0 , x1 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' ' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = Math . max ( x0 , zero ) ; one = Math . max ( x1 , one ) ; } document . write ( Math . max ( one , zero ) ) ; }
function smallestOdd ( n ) { if ( n == 1 ) return 1 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
function largestSubStr ( s ) { while ( s . length && s [ s . length - 1 ] == ' ' ) s = s . substring ( 0 , s . length - 1 ) ; ; if ( s . length == 0 ) return " " ; else return s ; }
function areacircumscribed ( a ) { return ( a * a * ( 3.1415 / 2 ) ) ; }
function minimumLength ( x , y , z ) { return 1 + Math . abs ( x - y ) + Math . abs ( y - z ) ; }
function nth_term ( a , b , n ) { var z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
function check ( n ) { let sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = Math . floor ( n / 10 ) ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
function minMaxProduct ( arr1 , arr2 , n1 , n2 ) { arr1 . sort ( ( a , b ) => a - b ) ; arr2 . sort ( ( a , b ) => a - b ) ; return ( arr1 [ n1 - 1 ] * arr2 [ 0 ] ) ; }
function countPairs ( P , Q , N , M ) { var A = [ 0 , 0 ] , B = [ 0 , 0 ] ; for ( var i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( var i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
function distinctCount ( arr , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) s . add ( Math . abs ( arr [ i ] ) ) ; return s . size ; }
function findAllSequence ( N ) { if ( N % 2 == 0 ) { return ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
function checkArray ( arr , N , k ) { if ( N < 3 ) return - 1 ; let i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; let R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; let Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
function solve ( A , N ) { let i = 0 ; let k = 0 ; for ( let j = 1 ; j < N ; j ++ ) { let tempK = Math . min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
function longestSubsequenceCommonSegment ( k , s1 , s2 ) { var n = s1 . length ; var m = s2 . length ; var lcs = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; var cnt = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( var a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
function cntPairs ( a , n ) { var odd = 0 , even = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } var ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
function icosikaipentagonNum ( N ) { return parseInt ( ( 23 * N * N - 21 * N ) / 2 ) ; }
function smallestNth ( A , B , N ) { let res = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { for ( let j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { let D = ( B - A ) / ( j - i ) ; let FirstTerm = A - ( i - 1 ) * D ; let NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = Math . min ( res , NthTerm ) ; } } } return res ; }
