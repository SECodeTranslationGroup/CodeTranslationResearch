function checkPowerof8 ( n ) { let i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; }
function alternatingSumOfFirst_N ( N ) { var alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
function centeredHexagonalNumber ( n ) { return 3 * n * ( n - 1 ) + 1 ; }
function sumFib ( N ) { var num = Math . round ( Math . pow ( ( Math . sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / Math . sqrt ( 5 ) ) ; document . write ( num - 1 ) ; }
function findEquation ( a , b ) { var sum = ( a + b ) ; var product = ( a * b ) ; document . write ( " " + sum + " " + product + " " ) ; }
function count ( n ) { var cnt = 0 ; var p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
function maxPeople ( p ) { var tmp = 0 , count = 0 ; for ( var i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
function maxDistance ( arr , n ) { let map = new Map ( ) ; let max_dist = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! map . has ( arr [ i ] ) ) map . set ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ; } return max_dist ; }
function getIndexInSortedArray ( arr , n , idx ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
function Last_set_bit ( n ) { let p = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) { return p ; } p ++ ; n = n >> 1 ; } return - 1 ; } let n = 18 ; let pos = Last_set_bit ( n ) ; if ( pos != - 1 ) { document . write ( pos ) ; } else { document . write ( 0 ) ; }
function calculateSum ( n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
function sumofsquare ( n ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } let sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
function maxEvenIntegers ( arr , N , M ) { let ans = 0 ; for ( let i = 0 ; i <= N - M ; i ++ ) { let cnt = 0 ; for ( let j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . max ( ans , cnt ) ; } return ans ; }
function poorPigs ( buckets , minutesToDie , minutesToTest ) { document . write ( Math . ceil ( Math . log ( buckets ) / Math . log ( ( minutesToTest / minutesToDie ) + 1 ) ) ) ; }
function find ( arr , N ) { let Sum = 0 ; let i = 0 ; let ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { Sum += arr [ i ] ; } if ( Sum % N ) { return - 1 ; } else { k = Math . floor ( Sum / N ) ; ans = 0 ; i = 0 ; while ( i < N ) { ans = ans + Math . abs ( k - arr [ i ] ) ; i += 1 ; } } return Math . floor ( ans / 2 ) ; }
function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function dist ( x1 , y1 , x2 , y2 , r ) { document . write ( " " + " " + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) . toFixed ( 5 ) ) ; }
function countSquares ( m , n ) { if ( n < m ) { var temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
function checkSolution ( a , b , c ) { if ( a == c ) document . write ( " " ) ; else document . write ( " " ) ; }
function areVowelsInOrder ( s ) { var n = s . length ; var c = String . fromCharCode ( 64 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }
function checkEVENodd ( arr , n , l , r ) { if ( arr [ r ] == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function countways ( n ) { let A = new Array ( n + 1 ) . fill ( 0 ) ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( let i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; }
function MaxRearrngeSum ( A , B , N ) { A . sort ( ) ; B . sort ( ) ; B . reverse ( ) ; let maxSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { maxSum += Math . abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
function product ( mat , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return d1 * d2 ; }
function checkVantieghemsTheorem ( limit ) { let prod = 1 ; for ( let n = 2 ; n < limit ; n ++ ) { if ( n == 2 ) document . write ( 2 + " " + " " ) ; if ( ( ( prod - n ) % ( ( 1 << n ) - 1 ) ) == 0 ) document . write ( n + " " + " " ) ; prod *= ( ( 1 << n ) - 1 ) ; } }
function findMean ( arr , l , r ) { let sum = 0 , count = 0 ; for ( let i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } let mean = Math . floor ( sum / count ) ; return mean ; }
function countSubset ( arr , n , diff ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum += diff ; sum = sum / 2 ; var t = new Array ( n + 1 ) ; for ( var i = 0 ; i < t . length ; i ++ ) { t [ i ] = new Array ( sum + 1 ) ; } for ( var i = 0 ; i < t . length ; i ++ ) { for ( var j = 0 ; j < t [ i ] . length ; j ++ ) { t [ i ] [ j ] = 0 ; } } for ( var j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( var i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; }
function fun ( n ) { return n & ( n - 1 ) ; }
function hIndex ( citations , n ) { let hindex = 0 ; let low = 0 , high = n - 1 ; while ( low <= high ) { let mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } document . write ( hindex ) ; return hindex ; }
function allCharactersSame ( s ) { let s1 = new Set ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { s1 . add ( s [ i ] ) ; } if ( s1 . size == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function getTotalXorOfSubarrayXors ( arr , N ) { if ( N % 2 == 0 ) return 0 ; let res = 0 ; for ( let i = 0 ; i < N ; i += 2 ) { res ^= arr [ i ] ; } return res ; }
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
function no_of_ways ( a , n ) { let count_0 = 0 , count_1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
function countTotalFrequencies ( S1 , S2 ) { var bset = new Set ( ) ; for ( var i = 0 ; i < S1 . length ; i ++ ) { bset . add ( S1 [ i ] ) ; } var count = 0 ; for ( var i = 0 ; i < S2 . length ; i ++ ) { if ( bset . has ( S2 [ i ] ) ) count += 1 ; } document . write ( count ) ; }
function checkIsFibonacci ( arr , n ) { if ( n == 1 n == 2 ) return true ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 2 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; } return true ; }
function numbers ( n ) { return ( Math . pow ( 2 , n + 1 ) ) - 2 ; }
function maximumResult ( a , b , c ) { let countOfNegative = 0 ; let sum = a + b + c ; let product = a * b * c ; let largest = Math . max ( a , Math . max ( b , c ) ) ; let smallest = Math . min ( a , Math . min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } }
function findSmallestNumK ( n ) { let cummAnd = n ; let i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
function getParity ( n ) { var parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
function isEven ( n ) { if ( n ^ 1 == n + 1 ) return true ; else return false ; }
function minimumMoves ( k , l , r ) { let count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
function findSum ( n ) { let sum = 0 ; for ( x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
function term ( n ) { return parseInt ( n * ( n + 1 ) / 2 ) ; }
function check ( n , m ) { if ( n == 2 m == 2 n % m == 0 ) { document . write ( " " + " " ) ; } else { document . write ( " " + " " ) ; } }
function getX ( a , b , c , d ) { var X = ( b * c - a * d ) / ( d - c ) ; return X ; }
function countDigit ( n ) { let temp = n , count = 0 ; while ( temp != 0 ) { let d = temp % 10 ; temp = Math . floor ( temp / 10 ) ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
function EqualNumbers ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; }
function minimumTime ( arr , n ) { var sum = 0 ; var T = Math . max ( ... arr ) ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } document . write ( Math . max ( 2 * T , sum ) ) ; }
function findWinner ( x , y , n ) { var dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( var i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 && ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 && ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
function isConvertible ( str1 , str2 , k ) { if ( ( str1 . length + str2 . length ) < k ) return true ; var commonLength = 0 ; for ( var i = 0 ; i < Math . min ( str1 . length , str2 . length ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length - str2 . length + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
function prletMissingElements ( arr , N ) { let diff = arr [ 0 ] - 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { document . write ( ( i + diff ) + " " ) ; diff ++ ; } } } }
function countNums ( n , x , y ) { arr = Array ( n + 1 ) . fill ( false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; var result = 0 ; for ( i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
function odd_even ( arr , n ) { var odd_indexes = [ ] ; var even_indexes = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . push ( arr [ i ] ) ; else even_indexes . push ( arr [ i ] ) ; } odd_indexes . sort ( ) ; even_indexes . sort ( ) ; for ( var i = 0 ; i < odd_indexes . length ; i ++ ) document . write ( odd_indexes [ i ] + " " ) ; for ( var i = 0 ; i < even_indexes . length ; i ++ ) document . write ( even_indexes [ i ] + " " ) ; }
function Area ( a ) { if ( a < 0 ) return - 1 ; let x = 0.464 * a ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
function possibleNumbers ( numbers , N , M , A , B ) { if ( M == 0 ) { numbers . add ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; } var N = 5 , M = 3 , A = 4 , B = 6 ; var numbers = new Set ( ) ; possibleNumbers ( numbers , N , M , A , B ) ; for ( let x of numbers ) { document . write ( x + ' ' ) ; }
function clearLastBit ( N , K ) { var mask = ( - 1 << K + 1 ) ; return N = N & mask ; }
function Digits ( n ) { let largest = 0 ; let smallest = 9 ; while ( n ) { let r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = parseInt ( n / 10 ) ; } document . write ( largest + " " + smallest ) ; }
function smallest ( s ) { var a = Array ( s . length ) ; for ( var i = 0 ; i < s . length ; i ++ ) a [ i ] = s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; var b = [ ] ; for ( var i = 0 ; i < a . length ; i ++ ) { if ( ( a [ i ] ) % 2 != 0 ) b . push ( a [ i ] ) ; } b . sort ( ( a , b ) => a - b ) ; if ( b . length > 1 ) return ( b [ 0 ] ) * 10 + ( b [ 1 ] ) ; return - 1 ; }
function rankLessThanK ( arr , k , n ) { let rank = 1 ; let position = 1 ; arr . sort ( ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
function search ( arr , n , x ) { let res = - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; let temp = arr [ res ] ; for ( let i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
function countStr ( n , bCount , cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; let res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
function printDuplicates ( arr , n ) { let i ; let fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { document . write ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) document . write ( " " ) ; }
function linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( let i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } } let Xo = 5 ; let m = 7 ; let a = 3 ; let c = 3 ; let noOfRandomNums = 10 ; let randomNums = new Array ( noOfRandomNums ) . fill ( 0 ) ; linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) ; for ( let i = 0 ; i < noOfRandomNums ; i ++ ) { document . write ( randomNums [ i ] + " " ) ; }
function countMultiples ( n ) { return Math . floor ( n / 3 + n / 7 - n / 21 ) ; }
function countDigit ( n ) { let temp = n ; let sum = 0 ; let product = 1 ; while ( temp != 0 ) { let d = temp % 10 ; temp = parseInt ( temp / 10 ) ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } document . write ( " " + sum ) ; document . write ( " " + product ) ; }
function hectagonNum ( n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
function binarySearch ( arr , x ) { let l = 0 , r = arr . length - 1 ; while ( l <= r ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; let res = x . localeCompare ( arr [ m ] ) ; if ( res == 0 ) return m ; if ( res > 0 ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
function findKHCF ( x , y , k ) { let small = Math . min ( x , y ) ; let count = 1 ; for ( let i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; }
function countWays ( N ) { let E = parseInt ( ( N * ( N - 1 ) ) / 2 , 10 ) ; if ( N == 1 ) return 0 ; return Math . pow ( 2 , E - 1 ) ; }
function maxSumWO3Consec ( n ) { if ( sum [ n ] != - 1 ) { return sum [ n ] ; } if ( n == 0 ) { return sum [ n ] = 0 ; } if ( n == 1 ) { return sum [ n ] = arr [ 0 ] ; } if ( n == 2 ) { return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; } return sum [ n ] = 500 + Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
function contain ( L , U , M ) { let count = 0 ; for ( let j = L ; j < U ; j ++ ) { let num = new Set ( ) ; let str = String ( j ) ; num . add ( str ) ; if ( j % M == 0 && ! num . has ( String ( M ) ) ) { count += 1 ; } } document . write ( count - 2 ) ; }
function totalTriangles ( h , v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; var total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
function getM ( n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
function countStrings ( n , m , s ) { let ind = new Set ( ) ; for ( let j = 0 ; j < m ; j ++ ) { let mx = 0 ; for ( let i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , ( s [ i ] [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) == mx ) ind . add ( i ) ; } return ind . size ; }
function isPowerOfK ( n , k ) { let oneSeen = false ; while ( n > 0 ) { let digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n = Math . floor ( n / k ) ; } return true ; }
function completeSequence ( s ) { let n = s . length ; let open = 0 , close = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) open ++ ; else close ++ ; if ( close > open ) { document . write ( " " ) ; return ; } } document . write ( s ) ; for ( let i = 0 ; i < open - close ; i ++ ) document . write ( " " ) ; }
function countRhombi ( h , w ) { let ct = 0 ; for ( let i = 2 ; i <= h ; i += 2 ) for ( let j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
function center_hexadecagonal_num ( n ) { return 8 * n * n - 8 * n + 1 ; }
function prevGreater ( arr , n ) { document . write ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { let j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { document . write ( arr [ j ] + " " ) ; break ; } } if ( j == - 1 ) document . write ( " " ) ; } }
function printNonConsecutive ( n ) { let p = ( 1 << n ) ; for ( let i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) document . write ( i + " " ) ; }
function compute ( a , b ) { var AM = ( a + b ) / 2 ; var GM = Math . sqrt ( a * b ) ; var HM = ( GM * GM ) / AM ; return HM ; }
function countOccurrences ( arr , n , x ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x == arr [ i ] ) res ++ ; } return res ; }
function harmonicMean ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + ( 1 / arr [ i ] ) ; return n / sum ; }
function findNthTerm ( n ) { document . write ( ( Math . pow ( 2 , n ) ) - ( 2 * n ) ) ; }
function minOperation ( N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } let k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
function odd_digits ( n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , parseInt ( y / 2 ) ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
function temp_convert ( F1 , B1 , F2 , B2 , T ) { var t2 ; t2 = F2 + ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
function findCountOfSolutions ( n , p ) { let ans = 0 ; for ( let x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { let last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
function perfectPowerOf2 ( n ) { let per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
function isSumEqual ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
function countSetBits ( n ) { let i = 0 ; let ans = 0 ; while ( ( 1 << i ) <= n ) { let k = 0 ; let change = 1 << i ; for ( let j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
function pow ( a , b ) { if ( b == 0 ) return 1 ; var answer = a ; var increment = a ; var i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
function area_of_segment ( radius , angle ) { let area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; let area_of_triangle = 1 / 2 * ( radius * radius ) * Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
function cal_cos ( n ) { let accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; let i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; document . write ( cosx . toFixed ( 5 ) ) ; }
function findPolet ( n , h ) { for ( let i = 1 ; i < n ; i ++ ) document . write ( Math . sqrt ( i / ( n * 1.0 ) ) * h + " " ) ; }
function find ( index , openbrk , n , adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
function countSubarrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let product = 1 ; for ( let x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
function canMakeEqual ( S ) { var N = S . length ; var weightOfString = 0 ; for ( var i = 0 ; i < N ; i ++ ) { weightOfString += S . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ; } if ( weightOfString % N == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function minSumDifference ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; let rem = sum % n ; return rem * ( n - rem ) ; }
function singleNumber ( nums , n ) { let m = new Map ( ) ; let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! m . has ( nums [ i ] ) ) { sum1 += nums [ i ] ; m . set ( nums [ i ] , 1 ) ; } sum2 += nums [ i ] ; } return ( 2 * ( sum1 ) - sum2 ) ; }
function areaSquare ( L , B ) { let large = Math . max ( L , B ) ; let small = Math . min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } }
function LIS ( a , n ) { let dp = new Array ( ) ; let d = new Array ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
function Regions ( Vertices , Edges ) { var R = Edges + 2 - Vertices ; return R ; }
function findMinDiff ( arr , n ) { let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
function isSymmetric ( mat , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
function countOfMultiples ( n ) { return ( parseInt ( n / 3 , 10 ) + parseInt ( n / 5 , 10 ) - parseInt ( n / 15 , 10 ) ) ; }
function minSteps ( str , n , k ) { if ( str [ n - 1 ] == ' ' ) return - 1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; var dp = Array ( n ) ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( var i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) continue ; var steps = 1000000000 ; if ( i + k < n && str [ i + k ] == ' ' ) steps = Math . min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == ' ' ) steps = Math . min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == ' ' ) steps = Math . min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == 1000000000 ) ? steps : 1 + steps ; } if ( dp [ 0 ] == 1000000000 ) return - 1 ; return dp [ 0 ] ; }
function totalSubSets ( n , l , r ) { let zero = Math . floor ( r / 3 ) - Math . ceil ( l / 3 ) + 1 ; let one = Math . floor ( ( r - 1 ) / 3 ) - Math . ceil ( ( l - 1 ) / 3 ) + 1 ; let two = Math . floor ( ( r - 2 ) / 3 ) - Math . ceil ( ( l - 2 ) / 3 ) + 1 ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( let i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
function matrixSum ( arr ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
function isPentagonal ( N ) { var i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
function compute ( str , n ) { let reverseAlphabet = " " ; let l = str . length ; let answer = " " ; for ( let i = 0 ; i < n ; i ++ ) answer = answer + str [ i ] ; for ( let i = n ; i < l ; i ++ ) answer = answer + reverseAlphabet [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ; return answer ; }
function CountTriplets ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let first = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
function cntSubsets ( arr , n ) { var a = Array ( n ) ; var b = Array ( n ) ; a [ 0 ] = b [ 0 ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } var result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
function findOddPair ( A , N ) { var i , j ; var oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
function minimumAdjacentDifference ( a , n , k ) { let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i <= k ; i ++ ) { let maxDiff = Number . MIN_VALUE ; for ( let j = 0 ; j < n - k - 1 ; j ++ ) { for ( let p = i ; p <= i + j ; p ++ ) { maxDiff = Math . max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; } } minDiff = Math . min ( minDiff , maxDiff ) ; } return minDiff ; }
function divisible ( num ) { let n = num . length ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - ' ' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
function findSum ( n ) { let ans = 0 , temp = 0 , num ; for ( let i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
function printCombination ( n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( let j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( let k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { document . write ( i + " " + j + " " + k ) ; return ; } } } } } } }
function MinOperation ( a , b , n ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
function ceilDifference ( arr , n , x ) { var totalSum = 0 ; var perElementSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += parseInt ( Math . ceil ( ( arr [ i ] ) / ( x ) ) ) ; } var totalCeilSum = parseInt ( Math . ceil ( ( totalSum ) / ( x ) ) ) ; return Math . abs ( perElementSum - totalCeilSum ) ; }
function checkArrangement ( A1 , A2 , n , k ) { A1 . sort ( ) ; A2 . sort ( ) ; A2 . reverse ( ) ; let flag = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findEletobeInserted ( A , n , k ) { var ans = k ; for ( var i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; }
function deleteElement ( A , L , R , N ) { let i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
function compareVal ( x , y ) { let a = y * Math . log ( x ) ; let b = x * Math . log ( y ) ; if ( a > b ) document . write ( x + " " + y + " " + y + " " + x ) ; else if ( a < b ) document . write ( x + " " + y + " " + y + " " + x ) ; else if ( a == b ) document . write ( x + " " + y + " " + y + " " + x ) ; }
function countStrings ( n ) { let a = [ ] , b = [ ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
function countSubString ( s ) { let res = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { let x = 0 ; for ( let j = i ; j < s . length ; j ++ ) { let temp = 1 << s [ j ] - ' ' ; x ^= temp ; if ( ( x & ( x - 1 ) ) == 0 ) res ++ ; } } document . write ( res ) ; }
function noOfTriangles ( n ) { return Math . floor ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
function findAandB ( N ) { let K = Math . log2 ( N ) ; let B = ( 1 << K ) ; let A = B ^ N ; document . write ( A + ' ' + B ) ; }
function setBitNumber ( n ) { if ( n == 0 ) return 0 ; let msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = $n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
function minServerLoads ( n , servers ) { var totalLoad = 0 ; servers . forEach ( i => { totalLoad += i ; } ) ; var requiredLoad = parseInt ( totalLoad / 2 ) ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( requiredLoad + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i < n + 1 ; i ++ ) { for ( var j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n ] [ requiredLoad ] ; }
function minimumOperations ( arr , N ) { let mx = 0 , pos = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } document . write ( ( mx - 1 ) * N + pos + 1 ) ; }
function day_of_the_week ( y , m , d ) { let t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
function countPairsBruteForce ( X , Y , m , n ) { let ans = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( ( Math . pow ( X [ i ] , Y [ j ] ) > Math . pow ( Y [ j ] , X [ i ] ) ) ) { ans += 1 ; } } } return ans ; }
function sumSquare ( n ) { for ( i = 1 ; i * i <= n ; i ++ ) for ( j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { document . write ( i + " " + j + " " + " " ) ; return true ; } return false ; }
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i ; j < N ; j ++ ) for ( let k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
function term ( n ) { let x = parseInt ( ( ( 1 ) + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
function CountMaximum ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
function findCnt ( s , i , r ) { if ( i == s . length ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - ' ' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i ] [ r ] ; }
function fnMod ( n ) { var rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
function insertNames ( arr , n ) { let set = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! set . has ( arr [ i ] ) ) { document . write ( " " + " " ) ; set . add ( arr [ i ] ) ; } else { document . write ( " " + " " ) ; } } }
function solve ( a , n ) { let ones = 0 , twos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } let ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; let evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( let i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + " " ) ; }
function countPS ( i , j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
function countStrings ( s ) { let cnt = 0 ; for ( let i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
function isReversible ( str ) { var i = 0 , j = str . length - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
function longestAlternating ( arr , n ) { let count = new Array ( n ) ; count [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count [ i ] + " " ) ; }
function constructArray ( N ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( i + " " ) ; } }
function distancesum ( x , y , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
function findExtraCharcter ( strA , strB ) { let m1 = new Array ( 256 ) ; for ( let i = 0 ; i < 256 ; i ++ ) m1 [ i ] = 0 ; for ( let i = 0 ; i < strB . length ; i ++ ) m1 [ strB [ i ] . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < strA . length ; i ++ ) m1 [ strA [ i ] . charCodeAt ( 0 ) ] -- ; for ( let i = 0 ; i < m1 . length ; i ++ ) { if ( m1 [ i ] == 1 ) return String . fromCharCode ( i ) ; } return Number . MIN_VALUE ; }
function generatepermutation ( N ) { var answer = [ ] ; answer . push ( N ) ; console . log ( answer ) ; for ( var i = 1 ; i < N ; i ++ ) { console . log ( answer ) ; answer . push ( i ) ; } for ( var i in answer ) document . write ( answer [ i ] + " " ) ; }
function EditDistDP ( str1 , str2 ) { let len1 = str1 . length ; let len2 = str2 . length ; let DP = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { DP [ i ] = new Array ( len1 + 1 ) ; for ( let j = 0 ; j < len1 + 1 ; j ++ ) DP [ i ] [ j ] = 0 ; } for ( let i = 0 ; i <= len1 ; i ++ ) DP [ 0 ] [ i ] = i ; for ( let i = 1 ; i <= len2 ; i ++ ) { for ( let j = 0 ; j <= len1 ; j ++ ) { if ( j == 0 ) DP [ i % 2 ] [ j ] = i ; else if ( str1 [ j - 1 ] == str2 [ i - 1 ] ) { DP [ i % 2 ] [ j ] = DP [ ( i - 1 ) % 2 ] [ j - 1 ] ; } else { DP [ i % 2 ] [ j ] = 1 + Math . min ( DP [ ( i - 1 ) % 2 ] [ j ] , Math . min ( DP [ i % 2 ] [ j - 1 ] , DP [ ( i - 1 ) % 2 ] [ j - 1 ] ) ) ; } } } document . write ( DP [ len2 % 2 ] [ len1 ] + " " ) ; }
function printPairs ( arr , n , sum ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; }
function aliquotSum ( n ) { let sum = 0 ; for ( let i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
function largest ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] ; }
function pythagorean_quadruple ( a , b , c , d ) { let sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
function centeredDodecagonal ( n ) { return 6 * n * ( n - 1 ) + 1 ; }
function printString ( str , n ) { let ones = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( str [ i ] == ' ' ) ones ++ ; let used = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' && ! used ) { used = true ; for ( let j = 0 ; j < ones ; j ++ ) document . write ( " " ) ; } if ( str [ i ] != ' ' ) document . write ( str [ i ] ) ; } if ( ! used ) for ( let j = 0 ; j < ones ; j ++ ) document . write ( " " ) ; }
function countTriangles ( a , n ) { var cnt = 0 ; var pairs = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += parseInt ( ( 2 * pairs ) / 3 ) ; return cnt ; }
function mod ( num , a ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) res = ( res * 10 + num [ i ] - ' ' ) % a ; return res ; }
function isKPartitionPossible ( arr , N , K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; let target = sum / K ; let dp = Array . from ( { length : ( 1 << 15 ) } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == - 1 ) continue ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( ( mask & ( 1 << i ) ) == 0 ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; } let arr = [ 2 , 1 , 4 , 5 , 3 , 3 ] ; let N = arr . length ; let K = 3 ; if ( isKPartitionPossible ( arr , N , K ) ) { document . write ( " " ) ; document . write ( " " ) ; } else { document . write ( " " ) ; document . write ( " " ) ; }
function maxSum ( a , n ) { var maxAnd = Math . max ( ... a ) ; var maxOR = 0 ; for ( var i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } document . write ( ( maxAnd + maxOR ) ) ; }
function deleteElement ( arr , n , x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; let prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { let curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
function isNumber ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] < ' ' s [ i ] > ' ' ) return false ; return true ; }
function check ( current_row , current_col , destination_row , destination_col ) { if ( current_row == destination_row ) return " " ; else if ( current_col == destination_col ) return " " ; else return " " ; }
function minimumOperations ( arr , N ) { let oddCnt = 0 , evenCnt = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } document . write ( Math . min ( oddCnt , evenCnt ) ) ; }
function highestPowerOfTwo ( num ) { var s = num . toString ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] === " " ) { document . write ( " " ) ; continue ; } var lg = parseInt ( Math . log2 ( s [ i ] . charCodeAt ( 0 ) - 48 ) ) ; var p = Math . pow ( 2 , lg ) ; document . write ( String . fromCharCode ( p + 48 ) ) ; } }
function countPairs ( arr , N ) { let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } let ans = ( N - odd + Math . floor ( odd / 2 ) - 1 ) + Math . floor ( odd / 2 ) ; return ans ; }
function minAnglRot ( N ) { let res ; res = 360 / N ; return res ; }
function pointIsOnLine ( m , c , x , y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
function isAnBn ( str ) { let n = str . length ; if ( ( n & 1 ) != 0 ) return " " ; let i ; for ( i = 0 ; i < n / 2 ; i ++ ) if ( str [ i ] != ' ' str [ n - i - 1 ] != ' ' ) return " " ; return " " ; }
function reduceZero ( N ) { var dp = Array ( N + 1 ) . fill ( 1000000000 ) ; dp [ 0 ] = 0 ; for ( var i = 0 ; i <= N ; i ++ ) { for ( var j = 0 ; j < i . toString ( ) . length ; j ++ ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i - ( i . toString ( ) [ j ] - ' ' ) ] + 1 ) ; } } return dp [ N ] ; }
function findbitwiseOR ( a , n ) { var res = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; document . write ( res ) ; }
function angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) { let num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; let den = Math . sqrt ( Math . pow ( ( x2 - x1 ) , 2 ) + Math . pow ( ( y2 - y1 ) , 2 ) + Math . pow ( ( z2 - z1 ) , 2 ) ) * Math . sqrt ( Math . pow ( ( x3 - x1 ) , 2 ) + Math . pow ( ( y3 - y1 ) , 2 ) + Math . pow ( ( z3 - z1 ) , 2 ) ) ; let angle = Math . acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
function getProbability ( p , q ) { p /= 100 ; q /= 100 ; let probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
function areChractersUnique ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
function findNum ( N , K ) { var rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
function absSumDidd ( a ) { a . sort ( ( a , b ) => a - b ) ; var midValue = a [ a . length / 2 ] ; var sum = 0 ; for ( var i = 0 ; i < a . length ; i ++ ) { sum = sum + Math . abs ( a [ i ] - midValue ) ; } return sum ; }
function possibleTriplets ( arr , N ) { var freq = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( freq * 1 * ( freq - 1 ) * ( freq - 2 ) ) / 6 ; }
function checkSolveable ( n , m ) { if ( n == 1 m == 1 ) document . write ( " " ) ; else if ( m == 2 && n == 2 ) document . write ( " " ) ; else document . write ( " " ) ; }
function lastRemaining ( n , dp ) { if ( dp . hasOwnProperty ( n ) ) return dp [ n ] ; if ( n === 1 ) return 1 ; else dp [ n ] = 2 * ( 1 + parseInt ( n / 2 ) - lastRemaining ( parseInt ( n / 2 ) , dp ) ) ; return dp [ n ] ; } var N = 5 ; var dp = { }
function findSteps ( n , m , a ) { var cur = 1 ; var steps = 0 ; for ( var i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
function checksum ( n ) { if ( n % 3 == 0 ) document . write ( n / 3 - 1 + " " + n / 3 + " " + ( n / 3 + 1 ) ) ; else document . write ( " " ) ; }
function minOpsToEmptyString ( S , N ) { let one = 0 , zero = 0 ; let x0 = 0 , x1 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' ' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = Math . max ( x0 , zero ) ; one = Math . max ( x1 , one ) ; } document . write ( Math . max ( one , zero ) ) ; }
function smallestOdd ( n ) { if ( n == 1 ) return 1 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
function largestSubStr ( s ) { while ( s . length && s [ s . length - 1 ] == ' ' ) s = s . substring ( 0 , s . length - 1 ) ; ; if ( s . length == 0 ) return " " ; else return s ; }
function areacircumscribed ( a ) { return ( a * a * ( 3.1415 / 2 ) ) ; }
function minimumLength ( x , y , z ) { return 1 + Math . abs ( x - y ) + Math . abs ( y - z ) ; }
function nth_term ( a , b , n ) { var z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
function check ( n ) { let sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = Math . floor ( n / 10 ) ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
function minMaxProduct ( arr1 , arr2 , n1 , n2 ) { arr1 . sort ( ( a , b ) => a - b ) ; arr2 . sort ( ( a , b ) => a - b ) ; return ( arr1 [ n1 - 1 ] * arr2 [ 0 ] ) ; }
function countPairs ( P , Q , N , M ) { var A = [ 0 , 0 ] , B = [ 0 , 0 ] ; for ( var i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( var i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
function distinctCount ( arr , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) s . add ( Math . abs ( arr [ i ] ) ) ; return s . size ; }
function findAllSequence ( N ) { if ( N % 2 == 0 ) { return ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
function checkArray ( arr , N , k ) { if ( N < 3 ) return - 1 ; let i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; let R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; let Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
function solve ( A , N ) { let i = 0 ; let k = 0 ; for ( let j = 1 ; j < N ; j ++ ) { let tempK = Math . min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
function longestSubsequenceCommonSegment ( k , s1 , s2 ) { var n = s1 . length ; var m = s2 . length ; var lcs = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; var cnt = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( var a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
function cntPairs ( a , n ) { var odd = 0 , even = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } var ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
function icosikaipentagonNum ( N ) { return parseInt ( ( 23 * N * N - 21 * N ) / 2 ) ; }
function smallestNth ( A , B , N ) { let res = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { for ( let j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { let D = ( B - A ) / ( j - i ) ; let FirstTerm = A - ( i - 1 ) * D ; let NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = Math . min ( res , NthTerm ) ; } } } return res ; }
function sumSquare ( n ) { let s = new Map ( ) ; for ( let i = 0 ; i * i <= n ; ++ i ) { s . set ( i * i , 1 ) ; if ( s . has ( n - i * i ) ) { document . write ( Math . sqrt ( n - i * i ) + " " + i + " " ) ; return true ; } } return false ; }
function largestSumOfAverages ( A , K ) { var n = A . length ; var pre_sum = Array ( n + 1 ) . fill ( - 1 ) ; pre_sum [ 0 ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; var dp = Array ( n ) . fill ( - 1 ) ; var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( k = 0 ; k < K - 1 ; k ++ ) for ( i = 0 ; i < n ; i ++ ) for ( j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
function findThirdDigit ( n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; }
function minAbsDiff ( n ) { let left = 1 << ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; let right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }
function noOfTriples ( arr , n ) { arr . sort ( ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
function isTidy ( num ) { let prev = 10 ; while ( num != 0 ) { let rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
function findSum ( N , K ) { var ans = 0 ; var i = 1 ; while ( i <= N ) { ans += Math . floor ( N / i ) ; i = i * K ; } document . write ( ans ) ; }
function findNumbers ( n ) { var i = 0 ; while ( i <= n ) { document . write ( 2 * i * i + 4 * i + 1 + i % 2 + " " ) ; i ++ ; } }
function getPairs ( a ) { let n = a . length ; let count = parseInt ( ( n * ( n - 1 ) ) / 2 , 10 ) ; return count ; }
function minSum ( arr , n ) { let sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
function fib ( n ) { let term = new Array ( 1000 ) ; term . fill ( 0 ) ; if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } }
function findRightAngle ( A , H ) { let D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { let root1 = ( H * H + Math . sqrt ( D ) ) / 2 ; let root2 = ( H * H - Math . sqrt ( D ) ) / 2 ; let a = Math . sqrt ( root1 ) ; let b = Math . sqrt ( root2 ) ; if ( b >= a ) document . write ( a + " " + b + " " + H + " " ) ; else document . write ( b + " " + a + " " + H + " " ) ; } else document . write ( " " ) ; }
function count_setbit ( N ) { let result = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & N ) > 0 ) { result ++ ; } } document . write ( result ) ; }
function kthRoot ( n , k ) { return Math . pow ( k , ( ( 1.0 / k ) * ( Math . log ( n ) / Math . log ( k ) ) ) ) ; }
function maxArea ( a , b , c , d ) { let semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
function find_composite_nos ( n ) { document . write ( 9 * n + " " + 8 * n ) ; }
function Length_Diagonal ( a , b , theta ) { var diagonal = Math . sqrt ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) - 2 * a * b * Math . cos ( theta * ( Math . PI / 180 ) ) ) ; return diagonal ; }
function findTriangles ( n ) { var num = n ; document . write ( num + " " ) ; document . write ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }
function SubArraySum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
function positions ( str , n ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( ( str [ i ] . charCodeAt ( 0 ) & NUM ) + " " ) ; } }
function count_pairs ( x ) { var ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = parseInt ( x / 2 ) ; } return ans ; }
function countOccurrences ( N , X ) { var count = 0 ; for ( var i = 1 ; i < Math . sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { var a = i ; var b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; }
function checkWinner ( N , K ) { if ( N % ( K + 1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function getTotalNumberOfSequences ( m , n ) { let T = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { T [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ parseInt ( i / 2 , 10 ) ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
function maxDistance ( array ) { let max1 = Number . MIN_VALUE ; let min1 = Number . MAX_VALUE ; let max2 = Number . MIN_VALUE ; let min2 = Number . MAX_VALUE ; for ( let i = 0 ; i < array . length ; i ++ ) { max1 = Math . max ( max1 , array [ i ] + i ) ; min1 = Math . min ( min1 , array [ i ] + i ) ; max2 = Math . max ( max2 , array [ i ] - i ) ; min2 = Math . min ( min2 , array [ i ] - i ) ; } return Math . max ( max1 - min1 , max2 - min2 ) ; }
function setbitsfromLtoR ( L , R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
function times ( steps , n ) { let current_level = 0 ; let previous_level = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; }
function maxValue ( a , n , pos , moves , left , dp ) { if ( moves == 0 || ( pos > n - 1 pos < 0 ) ) return 0 ; if ( dp [ pos ] [ left ] != - 1 ) return dp [ pos ] [ left ] ; let value = 0 ; if ( left > 0 && pos >= 1 ) value = Math . max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) ; if ( pos <= n - 1 ) value = Math . max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) ; return dp [ pos ] [ left ] = value ; } let n = 5 ; let a = [ 1 , 5 , 4 , 3 , 2 ] ; let k = 1 ; let m = 4 ; let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }
function checkLuhn ( cardNo ) { let nDigits = cardNo . length ; let nSum = 0 ; let isSecond = false ; for ( let i = nDigits - 1 ; i >= 0 ; i -- ) { let d = cardNo [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; if ( isSecond == true ) d = d * 2 ; nSum += parseInt ( d / 10 , 10 ) ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; }
function maxiConsecutiveSubarray ( arr , N ) { let maxi = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { let cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . max ( maxi , cnt ) ; i = j ; } return maxi ; }
function isAnyNotPalindrome ( s ) { var unique = new Set ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) unique . add ( s [ i ] ) ; if ( unique . size > 1 ) return true ; else return false ; }
function lastDigitFactorial ( n ) { if ( n == 0 ) return 1 ; else if ( n <= 2 ) return n ; else if ( n == 3 ) return 6 ; else if ( n == 4 ) return 4 ; else return 0 ; }
function findCount ( s , n , a , b ) { var res = 0 ; for ( var i = 0 ; i < b ; i ++ ) { if ( i == a ) res += ( s [ n - i - 1 ] != ' ' ) ; else res += ( s [ n - i - 1 ] != ' ' ) ; } return res ; }
function CountWays ( N , M ) { var count = 1 ; count = Math . pow ( 3 , M + N ) ; count *= Math . pow ( 2 , M * N ) ; return count ; }
function countIntgralPoints ( x1 , y1 , x2 , y2 ) { document . write ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }
function minimumCost ( cost , n , x ) { let dp = [ ] ; dp [ 0 ] = cost [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , Math . min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } document . write ( dp [ n - 1 ] ) ; }
function nthElement ( a , b , n ) { let seq = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) seq . push ( a * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . includes ( b * i ) ) { seq . push ( b * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; k -- ; } } return seq [ n - 1 ] ; }
function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
function hendecagonal_num ( n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
function findIndex ( n ) { let x = Math . sqrt ( 2 * Math . pow ( 10 , ( n - 1 ) ) ) ; return Math . round ( x ) ; }
function LCMPairs ( arr , N ) { var total_pairs = ( N * ( N - 1 ) ) / 2 ; var odd = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; document . write ( " " + ( total_pairs - odd ) + " " + odd ) ; }
function PrintMinNumberForPattern ( seq ) { let result = " " ; let stk = [ ] ; for ( let i = 0 ; i <= seq . length ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length seq [ i ] == ' ' ) { while ( stk . length != 0 ) { result += ( stk [ stk . length - 1 ] ) . toString ( ) ; result += " " ; stk . pop ( ) ; } } } document . write ( result + " " ) ; }
function findpair ( l , r ) { let c = 0 ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { document . write ( i + " " + j + " " ) ; c = 1 ; break ; } } if ( c == 1 ) break ; } }
function isAMultipleOf4 ( n ) { if ( ( n & 3 ) == 0 ) return true ; return false ; }
function isSubsetSum ( arr , n , sum ) { let subset = new Array ( 2 ) ; for ( var i = 0 ; i < subset . length ; i ++ ) { subset [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
function maxLen ( arr , n ) { var min_val = arr . reduce ( ( a , b ) => Math . min ( a , b ) ) var freq = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
function findSumSubsets ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
function ellipse ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var x = ( 3.14 * l * b ) / 4 ; return x ; }
function isSequenceValid ( B , N ) { for ( let i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function makeArray ( n ) { for ( var i = 1 ; i <= n ; i ++ ) document . write ( i * n + " " ) ; }
function evenFib ( n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
function CountPairs ( arr , n ) { var count = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
function redistribute ( arr , n , x ) { arr . sort ( ) ; arr . reverse ( ) ; let i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( ( sum / ( i + 1 ) ) < x ) { document . write ( i ) ; break ; } } if ( i == n ) document . write ( n ) ; }
function FindPairs ( n , k ) { document . write ( 1 + " " + n + " " ) ; k -- ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { document . write ( 1 + " " + i + " " ) ; k -- ; if ( k == 0 ) break ; if ( i != n / i ) { document . write ( 1 + " " + n / i + " " ) ; k -- ; } if ( k == 0 ) break ; } } }
function countElements ( N ) { var Cur_Ele = 1 ; var Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } document . write ( N - Count ) ; }
function nearestPowerOfTwo ( arr , N ) { for ( i = 0 ; i < N ; i ++ ) { var lg = parseInt ( ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ) ; var a = parseInt ( ( Math . pow ( 2 , lg ) ) ) ; var b = parseInt ( ( Math . pow ( 2 , lg + 1 ) ) ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) document . write ( a + " " ) ; else document . write ( b + " " ) ; } }
function getPairs ( arr , N , K ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } document . write ( count ) ; }
function min_elimination ( n , arr ) { let count = 0 ; let prev_val = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { let curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
function printSumSimple ( mat , k ) { if ( k > n ) return ; for ( let i = 0 ; i < n - k + 1 ; i ++ ) { for ( let j = 0 ; j < n - k + 1 ; j ++ ) { let sum = 0 ; for ( let p = i ; p < k + i ; p ++ ) for ( let q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; document . write ( sum + " " ) ; } document . write ( " " ) ; } }
function findMin ( arr , N , k ) { let pairs = 0 ; for ( let i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return - 1 ; else return 2 * k + N - 1 ; }
function canBecomeEmpty ( str , sub_str ) { while ( str . length > 0 ) { let idx = str . indexOf ( sub_str ) ; if ( idx == - 1 ) { break ; } str = str . replace ( sub_str , " " ) ; } return ( str . length == 0 ) ; } let str = " " , sub_str = " " ; if ( canBecomeEmpty ( str , sub_str ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function rectCount ( n , m ) { return parseInt ( ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 , 10 ) ; }
function TotalHammingDistance ( n ) { let i = 1 , sum = 0 ; while ( Math . floor ( n / i ) > 0 ) { sum = sum + Math . floor ( n / i ) ; i = i * 2 ; } return sum ; }
function countChars ( str , n ) { let i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == ' ' ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; }
function minimumChar ( S1 , S2 ) { let n = S1 . length ; let m = S2 . length ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < m - n + 1 ; i ++ ) { let minRemovedChar = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . min ( minRemovedChar , ans ) ; } return ans ; }
function minNumber ( a , n , x ) { let l = 0 , h = 0 , e = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } let ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
function findkth ( n , k ) { let v1 = [ ] ; let v2 = [ ] ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . push ( i ) ; if ( i != Math . sqrt ( n ) ) v2 . push ( n / i ) ; } } v2 . reverse ( ) ; if ( k > ( v1 . length + v2 . length ) ) document . write ( " " ) ; else { if ( k <= v1 . length ) document . write ( v1 [ k - 1 ] ) ; else document . write ( v2 [ k - v1 . length - 1 ] ) ; } }
function removeSpecialCharacter ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] < ' ' s [ i ] > ' ' && s [ i ] < ' ' s [ i ] > ' ' ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; i -- ; } } document . write ( s ) ; }
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
function sortSquares ( arr ) { let n = arr . length ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] * arr [ i ] ; arr . sort ( ) ; }
function downToZero ( n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; }
function bitwiseOrTillN ( n ) { var result = 2 ; for ( var i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; }
function center_pentadecagonal_num ( n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
function stringToInt ( str ) { if ( str . length == 1 ) return ( str [ 0 ] - ' ' ) ; var y = stringToInt ( str . substring ( 1 ) ) ; var x = str [ 0 ] - ' ' ; x = x * Math . pow ( 10 , str . Length - 1 ) + y ; return ( x ) ; }
function evenbitsetnumber ( n ) { let count = 0 , res = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
function swap ( a , b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; document . write ( " " + a + " " + b ) ; }
function calSum ( n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
function longestSubarray ( arr , n ) { var maxMean = 0 ; for ( var i = 1 ; i < n ; i ++ ) maxMean = Math . max ( maxMean , parseInt ( ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ) ; var ans = 0 ; var subarrayLength = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = Math . max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; }
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { var distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; var radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }
function Occurrence ( s , position ) { let count = 0 ; for ( let i = 0 ; i < position - 1 ; i ++ ) if ( s [ i ] == s [ position - 1 ] ) count ++ ; return count ; }
function cal_minimum_time ( X ) { let t = 0 ; let sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
function maxCost ( a , n , l , r ) { var mx = 0 , k ; for ( var i = 0 ; i < n ; ++ i ) mx = Math . max ( mx , a [ i ] ) ; var count = new Array ( mx + 1 ) ; count . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; var res = new Array ( mx + 1 ) ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( var num = 1 ; num <= mx ; num ++ ) { k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
function printMaxOfMin ( n ) { for ( k = 1 ; k <= n ; k ++ ) { var maxOfMin = Number . MIN_VALUE ; for ( i = 0 ; i <= n - k ; i ++ ) { var min = arr [ i ] ; for ( j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } document . write ( maxOfMin + " " ) ; } }
function addOne ( x ) { return ( - ( ~ x ) ) ; }
function nDigitPerfectSquares ( n ) { document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) + " " ) ; document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ) ; }
function nearestPerfectSquare ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let sr = parseInt ( Math . sqrt ( arr [ i ] ) ) ; let a = sr * sr ; let b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) document . write ( a + " " ) ; else document . write ( b + " " ) ; } }
function countPS ( str ) { let N = str . length ; let cps = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { cps [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { cps [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( let L = 2 ; L <= N ; L ++ ) { for ( let i = 0 ; i <= N - L ; i ++ ) { let k = L + i - 1 ; if ( str [ i ] == str [ k ] ) { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; } else { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; }
function Cells ( n , x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; var i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }
function isCycleExists ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function countDigitsToBeRemoved ( N , K ) { var s = N . toString ( ) ; var res = 0 ; var f_zero = 0 ; for ( var i = s . length - 1 ; i >= 0 ; i -- ) { if ( K === 0 ) return res ; if ( s [ i ] === " " ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K === 0 ) return res ; else if ( f_zero === 1 ) return s . length - 1 ; return - 1 ; }
function longestSubArray ( arr , n ) { var isZeroPresent = false ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
function check ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return true ; } return false ; }
function areSame ( a , b ) { if ( ( a - b ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function count ( n ) { return 15 * Math . pow ( 16 , n - 1 ) ; }
function solve ( n , k , mod , dp ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; let cnt = 0 ; for ( let i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; }
function SieveOfSundaram ( n ) { let nNew = ( n - 1 ) / 2 ; let marked = [ ] ; for ( let i = 0 ; i < nNew + 1 ; i ++ ) marked [ i ] = false ; for ( let i = 1 ; i <= nNew ; i ++ ) for ( let j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) document . write ( 2 + " " ) ; for ( let i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) document . write ( 2 * i + 1 + " " ) ; return - 1 ; }
function sumOfSeries ( n ) { x = 0 if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) else x = ( ( n + 1 ) / 2 ) * n return ( x * x ) }
function seriesSum ( n ) { let sum = 0 ; let currProd = 1 ; let currSum = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; }
function IsPrime ( i ) { if ( i % 2 == 0 && i != 2 ) return false ; else { for ( j = 3 ; j <= Math . sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) return false ; } return true ; } } var c = 0 ; var N = 72 ; for ( i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( IsPrime ( i ) ) { if ( N % i == 0 ) { c ++ ; if ( IsPrime ( N / i ) && i != ( N / i ) ) c ++ ; } } }
function equal_xor_sum ( arr , n ) { let Sum = 0 ; let Xor = 0 ; for ( let i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum === Xor ) document . write ( " " ) ; else document . write ( " " ) ; }
function maxSum ( arr , n ) { let sum = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
function countOfSubarray ( arr , N ) { var mp = new Map ( ) ; var answer = 0 ; var sum = 0 ; if ( ! mp . has ( 1 ) ) mp . set ( 1 , 1 ) else mp . set ( 1 , mp . get ( 1 ) + 1 ) for ( var i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp . has ( sum - i ) ? mp . get ( sum - i ) : 0 ; if ( mp . has ( sum - i ) ) mp . set ( sum - i , mp . get ( sum - i ) + 1 ) else mp . set ( sum - i , 1 ) } document . write ( answer ) ; }
function generateString ( K ) { var s = " " ; for ( var i = 97 ; i < 97 + K ; i ++ ) { s = s + String . fromCharCode ( i ) ; for ( var j = i + 1 ; j < 97 + K ; j ++ ) { s += String . fromCharCode ( i ) ; s += String . fromCharCode ( j ) ; } } s += String . fromCharCode ( 97 ) ; document . write ( s ) ; }
function totalCircles ( L , B ) { if ( L > B ) { var temp = L ; L = B ; B = temp ; } return B / L ; }
function countQuadruples ( A , N ) { let ans = 0 ; let freq = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( freq . has ( arr [ i ] ) ) { ans += freq . get ( A [ i ] ) ; } for ( let j = 0 ; j < i ; j ++ ) { for ( let k = 0 ; k < j ; k ++ ) { if ( freq . has ( A [ i ] * A [ j ] * A [ k ] ) ) { freq . set ( freq . get ( A [ i ] * A [ j ] * A [ k ] ) , freq . get ( [ A [ i ] * A [ j ] * A [ k ] ] ) + 1 ) ; } else { freq . set ( A [ i ] * A [ j ] * A [ k ] , 1 ) ; } } } } return ans ; }
function LexicographicalMaxString ( str ) { var mx = " " ; for ( var i = 0 ; i < str . length ; ++ i ) { if ( mx . localeCompare ( str . substring ( i ) ) <= 0 ) { mx = str . substring ( i ) ; } } return mx ; }
function leastBricks ( wall ) { let map = new Map ( ) ; let res = 0 ; for ( let list of wall ) { let width = 0 ; for ( let i = 0 ; i < list . length - 1 ; i ++ ) { width += list [ i ] ; if ( map . has ( width ) ) { map . set ( width , map . get ( width ) + 1 ) ; } else { map . set ( width , 1 ) } res = Math . max ( res , map . get ( width ) ) ; } } document . write ( wall . length - res ) ; }
function findFactors ( a , b ) { let c ; c = a + b - 1 ; document . write ( c ) ; }
function rev ( n , temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( Math . floor ( n / 10 ) , temp ) ; }
function lexNumbers ( n ) { let s = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) { s . push ( i . toString ( ) ) ; } s . sort ( ) ; let ans = [ ] ; for ( let i = 0 ; i < n ; i ++ ) ans . push ( parseInt ( s [ i ] ) ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( ans [ i ] + " " ) ; }
function calcScore ( str ) { var score = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; ) { var chunkSize = 1 ; var currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == ' ' ) score += Math . pow ( chunkSize , 2 ) ; else score -= Math . pow ( chunkSize , 2 ) ; } return score ; }
function countNestedPolygons ( sides ) { var count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
function minCount ( arr , n , k ) { var ans = 0 ; var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; var l = 0 ; var r = 0 ; var tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = Math . max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
function findSum ( N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
function prletORSumforEachElement ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let req_sum = 0 ; for ( let j = 0 ; j < N ; j ++ ) { req_sum += ( arr [ i ] arr [ j ] ) ; } document . write ( req_sum + " " ) ; } }
function countPairs ( A , B ) { var countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; }
function subsetXOR ( arr , n , k ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; if ( k > m ) { return 0 ; } let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
function tripletAndSum ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } document . write ( ans ) ; }
function maxProfit ( arr ) { arr . sort ( ) ; arr . reverse ( ) ; let ans = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] - ( 1 * i ) ) > 0 ) ans += ( arr [ i ] - ( 1 * i ) ) ; if ( ( arr [ i ] - ( 1 * i ) ) == 0 ) break ; } return ans ; }
function findCycles ( N ) { let res = 0 ; let finalResult = 0 ; let val = 2 * N - 1 ; let s = val ; res = ( N - 1 ) * ( N - 2 ) ; finalResult = res + s ; return finalResult ; }
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ; return a ; }
function minFlips ( mat , s ) { let N = mat . length ; let M = mat [ 0 ] . length ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != s [ ( i + j ) ] - ' ' ) { count ++ ; } } } return count ; }
function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function diameter ( r ) { document . write ( " " + " " + 2 * r ) ; }
function centeredNonagonal ( n ) { return parseInt ( ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ) ; }
function printMedian ( arr , n , K ) { arr . sort ( ) ; document . write ( arr [ Math . floor ( ( n + K ) / 2 ) ] ) ; }
function numberOfDistinct ( n ) { var ans = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
function generate_derangement ( N ) { let S = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) S [ i ] = i ; let D = [ ] ; for ( let i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( let i = 1 ; i <= N ; i ++ ) document . write ( D [ i ] + " " ) ; document . write ( " " ) ; }
function PossibleValues ( b , x , n ) { let leastdivisible = ( Math . floor ( b / x ) + 1 ) * x ; let flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { document . write ( leastdivisible - b + " " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) document . write ( - 1 + " " ) ; }
function longestEvenOddSubarray ( a , n ) { let longest = 1 ; let cnt = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = Math . max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return Math . max ( cnt , longest ) ; }
function LCIS ( arr1 , n , arr2 , m ) { let table = [ ] ; for ( let j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let current = 0 ; for ( let j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } let result = 0 ; for ( let i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
function lds ( arr , n ) { let lds = new Array ( n ) ; let i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
function F ( A , B ) { if ( A == 1 ) return ( 4 % B ) ; else { var temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
function get_concentration ( mass , volume ) { if ( volume == 0 ) return - 1 ; else return ( mass / volume ) * 1000 ; }
function findNumber ( n ) { n -- ; let i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
function check_order ( arr ) { var cnt = 0 ; for ( i = 0 ; i < arr . length - 1 ; i ++ ) { if ( Math . abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( Math . abs ( arr [ 0 ] - arr [ arr . length - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; }
function trianglearea ( r ) { if ( r < 0 ) return - 1 ; return r * r ; }
function isDivisibleByDivisor ( S , D ) { S %= D ; var hashMap = [ ] ; hashMap . push ( S ) ; for ( var i = 0 ; i <= D ; i ++ ) { S += S % D ; S %= D ; if ( hashMap . includes ( S ) ) { if ( S == 0 ) { return " " ; } return " " ; } else hashMap . push ( S ) ; } return " " ; }
function area_of_tetrahedron ( side ) { return ( Math . sqrt ( 3 ) * ( side * side ) ) ; }
function findInGrid ( i , j ) { if ( i == j ) return ( i * i - ( i - 1 ) ) ; else if ( i > j ) { if ( i % 2 == 0 ) return i * i - ( j - 1 ) ; else return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ; } else { if ( j % 2 == 0 ) return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ; else return j * j - ( i - 1 ) ; } }
function findBucketNo ( p ) { return Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
function countCrossLine ( arr , n ) { let count_crossline = 0 ; let i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
function maxOnesIndex ( arr , n ) { let max_count = 0 ; let max_index = 0 ; let prev_zero = - 1 ; let prev_prev_zero = - 1 ; for ( let curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
function distinctSubstring ( P , N ) { var S = new Set ( ) ; for ( var i = 0 ; i < N ; ++ i ) { var freq = Array ( 26 ) . fill ( false ) ; var s = " " ; for ( var j = i ; j < N ; ++ j ) { var pos = P [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( freq [ pos ] == true ) break ; freq [ pos ] = true ; s += P [ j ] ; S . add ( s ) ; } } return S . size ; }
function flippingBits ( N , K ) { let X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; document . write ( N ) ; }
function check ( str ) { let n = str . length ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - ' ' ) * 100 + ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 16 == 0 ) ; let last = str [ n - 1 ] - ' ' ; let second_last = str [ n - 2 ] - ' ' ; let third_last = str [ n - 3 ] - ' ' ; let fourth_last = str [ n - 4 ] - ' ' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
function minCountOfNumbers ( N ) { let k = N % 10 ; let z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else { return - 1 ; } }
function factorsOf3 ( arr , N ) { let a = 0 , b = 0 , c = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 3 == 0 ) a ++ ; else if ( arr [ i ] % 3 == 1 ) b ++ ; else if ( arr [ i ] % 3 == 2 ) c ++ ; } if ( a >= 1 && a <= b + c + 1 ) document . write ( " " + " " ) ; else if ( a == 0 && b == 0 && c > 0 ) document . write ( " " + " " ) ; else if ( a == 0 && c == 0 && b > 0 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function getParity ( n , A ) { for ( let x in A ) { if ( ( x & 1 ) == 1 ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function findsubArray ( arr , N , K ) { var res = N + 1 ; for ( i = 0 ; i < N ; i ++ ) { var curr_prod = 1 ; for ( j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = Math . min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
function sumOfSeries ( n ) { let ans = Math . pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
function getSum ( n ) { let sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum = sum + n % 10 ; n = Math . floor ( n / 10 ) ; } return sum ; }
function countChar ( str , x ) { let count = 0 ; let n = 10 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) count ++ ; let repetitions = n / str . length ; count = count * repetitions ; for ( let i = 0 ; i < n % str . length ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; }
function countPairs ( arr , n ) { var map = { } ; for ( var i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; var res = 0 ; for ( const [ key , value ] of Object . entries ( map ) ) { var cnt = value ; res += ( cnt * ( cnt - 1 ) ) / 2 ; } return res ; }
function numOfWays ( a , n , i , blue ) { if ( i == n ) return 1 ; let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && ! blue . has ( j ) ) { blue . add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . delete ( j ) ; } } return count ; }
function maximum_middle_value ( n , k , arr ) { let ans = - 1 ; let low = Math . floor ( ( n + 1 - k ) / 2 ) ; let high = Math . floor ( ( ( n + 1 - k ) / 2 ) + k ) ; for ( let i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; }
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; var op = [ ... Array ( n ) ] ; var mid = parseInt ( ( n - 1 ) / 2 ) ; var j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( op [ i ] + " " ) ; document . write ( " " ) ; }
function solve ( M , N , s ) { let ans = Math . floor ( ( ( Math . ceil ( M / s ) ) * ( Math . ceil ( N / s ) ) ) ) ; return ans ; }
function maxRepeating ( str ) { var n = str . length ; var count = 0 ; var res = str [ 0 ] ; var cur_count = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
function No_of_Triangle ( N , K ) { if ( N < K ) return - 1 ; else { let Tri_up = 0 ; Tri_up = Math . floor ( ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ) ; let Tri_down = 0 ; Tri_down = Math . floor ( ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ) ; return Tri_up + Tri_down ; } }
function CalculateValues ( N ) { var A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { var A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { document . write ( " " + A / 3 + " " + B + " " + C ) ; return ; } } } document . write ( - 1 ) ; }
function maxSum ( arr , i , n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
function maxFreq ( s , a , b ) { var fre = new Array ( 10 ) . fill ( 0 ) ; var n = s . length ; if ( a > b ) { var temp = a ; a = b ; b = temp ; } for ( var i = 0 ; i < n ; i ++ ) fre [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; if ( fre [ a ] === 0 && fre [ b ] === 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
function minOperation ( s , i , j , count ) { if ( ( i >= s . length && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] ) return count ; if ( i >= s . length ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return Math . min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; }
function isMajorityElement ( arr , n , key ) { if ( arr [ parseInt ( n / 2 , 10 ) ] == key ) return true ; else return false ; }
function findSquareSum ( Coordinates , N ) { let xq = 0 , yq = 0 ; let xs = 0 , ys = 0 ; let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let a , b ; a = Coordinates [ i ] [ 0 ] ; b = Coordinates [ i ] [ 1 ] ; res += xq ; res -= 2 * xs * a ; res += i * ( a * a ) ; xq += a * a ; xs += a ; res += yq ; res -= 2 * ys * b ; res += i * b * b ; yq += b * b ; ys += b ; } document . write ( res ) ; }
function isvalid ( s ) { let k = ( - 1.0 + Math . sqrt ( 1 + 8 * s ) ) / 2 ; if ( Math . ceil ( k ) == Math . floor ( k ) ) return k ; else return - 1 ; }
function isicosihenagonal ( N ) { var n = ( 17 + Math . sqrt ( 152 * N + 289 ) ) / 38 ; return ( n - parseInt ( n ) ) == 0 ; } var i = 21 ; if ( isicosihenagonal ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function countPairs ( arr , N ) { let count = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; }
function countPairs ( a , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; }
function getPairs ( a ) { let count = 0 ; for ( let i = 0 ; i < a . length ; i ++ ) { for ( let j = 0 ; j < a . length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; }
function icosidigonal_num ( n ) { return parseInt ( ( 20 * n * n - 18 * n ) / 2 ) ; }
function findMinCost ( a , k ) { var n = a . length ; var max_ele = a . reduce ( ( a , b ) => Math . max ( a , b ) ) var dp = Array ( n + 1 ) . fill ( 1000000000 ) ; dp [ 0 ] = 0 ; for ( var i = 0 ; i < n ; ++ i ) { var freq = Array ( max_ele + 1 ) . fill ( 0 ) ; for ( var j = i ; j < n ; ++ j ) { freq [ a [ j ] ] ++ ; var cost = 0 ; for ( var x = 0 ; x <= max_ele ; ++ x ) { cost += ( freq [ x ] == 1 ) ? 0 : freq [ x ] ; } dp [ j + 1 ] = Math . min ( dp [ i ] + cost + k , dp [ j + 1 ] ) ; } } return dp [ n ] ; }
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
function findMaxValue ( N , K ) { let packages ; let maxi = 1 ; for ( let i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = Math . max ( maxi , i ) ; } packages = parseInt ( N / maxi ) ; document . write ( packages ) ; }
function isMultipleOf10 ( n ) { return ( n % 15 == 0 ) ; }
function countWays ( s ) { let count = new Array ( 26 ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < s . length ; i ++ ) count [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; count [ s [ 0 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] = 1 ; let ans = 1 ; for ( let i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
function seiresSum ( n , a ) { let res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
function parallel ( a1 , b1 , c1 , a2 , b2 , c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function Balanced_Substring ( str , n ) { let ans = 0 ; let arr = new Array ( n / 2 + 1 ) . fill ( 0 ) ; let d = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) d ++ ; else { if ( d == 1 ) { for ( let j = 2 ; j <= parseInt ( n / 2 ) + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; }
function nthPalindrome ( n , k ) { let temp = ( k & 1 ) != 0 ? parseInt ( k / 2 , 10 ) : ( parseInt ( k / 2 , 10 ) - 1 ) ; let palindrome = parseInt ( Math . pow ( 10 , temp ) , 10 ) ; palindrome += n - 1 ; document . write ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome = parseInt ( palindrome / 10 , 10 ) ; while ( palindrome > 0 ) { document . write ( palindrome % 10 ) ; palindrome = parseInt ( palindrome / 10 , 10 ) ; } document . write ( " " + " " ) ; }
function firstkdigits ( n , k ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) product *= n ; while ( Math . floor ( product / Math . pow ( 10 , k ) ) != 0 ) product = Math . floor ( product / 10 ) ; return product ; }
function waysToPaint ( n ) { var same = 6 ; var diff = 6 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { var sameTmp = 3 * same + 2 * diff ; var diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } document . write ( same + diff ) ; }
function calculate_angle ( n ) { var total_angle = 360 ; return total_angle / n ; }
function pentagon_pyramidal ( n ) { return n * n * ( n + 1 ) / 2 ; }
function printDivisors ( n ) { for ( i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + " " ) ; }
function countWords ( str , len ) { let count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( let j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
function count ( n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; let table = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; let i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
function IcosihexagonalNum ( n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
function print ( str1 ) { let str = str1 . split ( " " ) ; document . write ( str [ 0 ] ) ; for ( let i = 1 ; i < str . length ; i ++ ) { if ( ( str [ i ] . charCodeAt ( 0 ) == str [ i - 1 ] . charCodeAt ( 0 ) + 1 ) || ( str [ i ] . charCodeAt ( 0 ) == str [ i - 1 ] . charCodeAt ( 0 ) - 1 ) ) { document . write ( str [ i ] ) ; } else { document . write ( " " + str [ i ] ) ; } } }
function findBalance ( x , bal ) { if ( x % 10 == 0 && ( x + 1.50 ) <= bal ) { document . write ( ( bal - x - 1.50 ) . toFixed ( 2 ) ) ; } else { document . write ( ( bal ) . toFixed ( 2 ) ) ; } }
function findMinAvgSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; let min_sum = curr_sum ; for ( let i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } document . write ( " " + res_index + " " + ( res_index + k - 1 ) + " " ) ; }
function minCut ( a ) { var cut = new Array ( a . length ) ; var palindrome = new Array ( a . length ) ; for ( var i = 0 ; i < a . length ; i ++ ) { var minCut = i ; for ( var j = 0 ; j <= i ; j ++ ) { if ( a . charAt ( i ) == a . charAt ( j ) && ( i - j < 5 palindrome [ j + 1 ] [ i - 1 ] ) ) { palindrome [ j , i ] = true ; minCut = Math . min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . length - 1 ] ; }
function countSequences ( arr , n ) { let count = 1 ; arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
function precompute ( s , K ) { var n = s . length ; for ( var i = 0 ; i < n - 1 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] + ( s . substring ( i , i + K . length ) == K ) ; } } var s = " " ; var K = " " ; precompute ( s , K ) ; var Q = [ [ 1 , 6 ] , [ 5 , 11 ] ] ; Q . forEach ( ( it ) => { document . write ( cnt [ it [ 1 ] - 1 ] - cnt [ it [ 0 ] - 1 ] + " " ) ; }
function solve ( n ) { let n_2 = parseInt ( n / 2 , 10 ) ; let den ; den = " " ; while ( n_2 -- > 0 ) den += ' ' ; document . write ( 1 + " " + den + " " ) ; }
function convertXintoY ( X , Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y = parseInt ( Y / 2 ) ; else if ( Y % 10 == 1 ) Y = parseInt ( Y /= 10 ) ; else break ; } if ( X == Y ) document . write ( " " ) ; else document . write ( " " ) ; }
function find ( N , sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( 1.0 / 6 ) ; else return 0 ; } for ( var i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; }
function haversine ( lat1 , lon1 , lat2 , lon2 ) { let dLat = ( lat2 - lat1 ) * Math . PI / 180.0 ; let dLon = ( lon2 - lon1 ) * Math . PI / 180.0 ; lat1 = ( lat1 ) * Math . PI / 180.0 ; lat2 = ( lat2 ) * Math . PI / 180.0 ; let a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; let rad = 6371 ; let c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; }
function sumOfTheSeries ( n ) { let sum_n = ( n * ( n + 1 ) / 2 ) ; let sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
function countWays ( n ) { let dp = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
function rad ( d , h ) { document . write ( " " + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; }
function findMissing ( arr , n , k , avg ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } var num = ( avg * ( n + k ) ) - sum ; var den = k ; if ( num % den != 0 ) return - 1 ; return ( Math . floor ( num / den ) ) ; }
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; let us = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) us . add ( arr1 [ i ] ) ; for ( let j = 0 ; j < n ; j ++ ) if ( us . has ( x - arr2 [ j ] ) ) count ++ ; return count ; }
function findCount ( arr , n ) { let count = 0 , ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count ++ ; else ans = ans + count ; } return ans ; }
function flip ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) { while ( s [ i ] == ' ' ) { s [ i ] = ' ' ; i ++ ; } break ; } } return s . join ( " " ) ; }
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) sum += Math . floor ( n / i ) * i ; return sum ; }
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
function binarySearch ( arr , low , high ) { if ( high >= low ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
function printModulus ( X , Y ) { var n = Math . max ( X , Y ) ; for ( var i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) document . write ( i + " " ) ; } }
function maxvolume ( s ) { let length = parseInt ( s / 3 ) ; s -= length ; let breadth = parseInt ( s / 2 ) ; let height = s - breadth ; return length * breadth * height ; }
function maxGCD ( n ) { return parseInt ( n / 2 ) ; }
function stirlingFactorial ( n ) { if ( n == 1 ) return 1 ; let z ; let e = 2.71 ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return Math . floor ( z ) ; }
function firstDigit ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return ( Math . round ( fact ) ) ; }
function missing4 ( arr ) { let helper = [ ] ; for ( let i = 0 ; i < 4 ; i ++ ) { helper [ i ] = 0 ; } for ( let i = 0 ; i < arr . length ; i ++ ) { let temp = Math . abs ( arr [ i ] ) ; if ( temp <= arr . length ) arr [ temp - 1 ] = Math . floor ( arr [ temp - 1 ] * ( - 1 ) ) ; else if ( temp > arr . length ) { if ( temp % arr . length != 0 ) helper [ temp % arr . length - 1 ] = - 1 ; else helper [ ( temp % arr . length ) + arr . length - 1 ] = - 1 ; } } for ( let i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] > 0 ) document . write ( i + 1 + " " ) ; for ( let i = 0 ; i < helper . length ; i ++ ) if ( helper [ i ] >= 0 ) document . write ( arr . length + i + 1 + " " ) ; return ; }
function superSeq ( X , Y , m , n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
function maxORminusXOR ( N ) { let MSB = Math . ceil ( Math . log ( N ) ) ; let M = 0 ; for ( let i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; }
function countXorPartition ( N ) { let a = Math . pow ( 2 , Math . floor ( N - Math . log ( N + 1 ) / Math . log ( 2 ) ) ) ; document . write ( a ) ; }
function record_sum ( record , l , r , n , adder ) { for ( let i = l ; i <= r ; i ++ ) { record [ i ] += adder ; } } let n = 5 , m = 5 ; let arr = new Array ( n ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = 0 ; } let query = [ [ 1 , 1 , 2 ] , [ 1 , 4 , 5 ] , [ 2 , 1 , 2 ] , [ 2 , 1 , 3 ] , [ 2 , 3 , 4 ] ] ; let record = new Array ( m ) ; for ( let i = 0 ; i < record . length ; i ++ ) { record [ i ] = 0 ; } for ( let i = m - 1 ; i >= 0 ; i -- ) { if ( query [ i ] [ 0 ] == 2 ) { record_sum ( record , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , m , record [ i ] + 1 ) ; } else { record_sum ( record , i , i , m , 1 ) ; } } for ( let i = 0 ; i < m ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) { record_sum ( arr , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , n , record [ i ] ) ; } } for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + " " ) ; }
function calculateTriangles ( sides ) { let count = Math . pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= Math . pow ( sides [ 0 ] , 2 ) ; count -= Math . pow ( sides [ 2 ] , 2 ) ; count -= Math . pow ( sides [ 4 ] , 2 ) ; return ( count ) ; }
function polyapothem ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
function oddSum ( n ) { return ( n * n ) ; }
function difference ( arr , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }
function sph ( r , R , h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; var x = r ; var V = ( ( 4 * 3.14 * Math . pow ( r , 3 ) ) / 3 ) ; return V ; }
function numberOfSolutions ( n ) { let c = 0 ; for ( let x = 0 ; x <= n ; ++ x ) if ( n == x + n ^ x ) ++ c ; return c ; }
function LastTwoDigit ( num ) { let one = num % 10 ; num = Math . floor ( num / 10 ) ; let tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
function printCase ( n ) { if ( n <= 2 ) { document . write ( - 1 ) ; return ; } for ( let i = n ; i >= 1 ; i -- ) document . write ( i + " " ) ; }
function length_substring ( S , K ) { let curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( let i = 0 ; i < S . length ; i ++ ) { if ( S [ i ] == K ) { curr_cnt += 1 ; } else { prev_cnt = Math . max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = Math . max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; }
function findMaxNumbers ( arr , n , k ) { arr . sort ( ) ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let opr = Math . ceil ( Math . log2 ( arr [ i ] ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } document . write ( cnt ) ; }
function minStepToDeleteString ( str ) { let N = str . length ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i <= N ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let len = 1 ; len <= N ; len ++ ) { for ( let i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( let K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
function findDistinctSums ( n ) { s = new Set ( ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = i ; j <= n ; j ++ ) { s . add ( i + j ) ; } } return s . size ; }
function checkSumOfNatural ( n ) { var i = 1 ; var flag = false ; while ( i * ( i + 1 ) < n * 2 ) { var X = i * ( i + 1 ) ; var t = n * 2 - X ; var k = parseInt ( Math . sqrt ( t ) ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) document . write ( " " ) ; else document . write ( " " ) ; }
function substrDeletion ( str , len ) { let count0 = 0 , count1 = 0 ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) count0 ++ ; else count1 ++ ; } return Math . min ( count0 , count1 ) ; }
function count ( N ) { var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; }
function findSum ( n ) { var sum2 , sum5 , sum10 ; sum2 = parseInt ( ( parseInt ( n / 2 ) * ( 4 + ( parseInt ( n / 2 ) - 1 ) * 2 ) ) / 2 ) ; sum5 = parseInt ( ( parseInt ( n / 5 ) * ( 10 + ( parseInt ( n / 5 ) - 1 ) * 5 ) ) / 2 ) ; sum10 = parseInt ( ( parseInt ( n / 10 ) * ( 20 + ( parseInt ( n / 10 ) - 1 ) * 10 ) ) / 2 ) ; return sum2 + sum5 - sum10 ; }
function maxConsecutiveRopes ( ropes , N ) { let curSize = 0 ; ropes . sort ( ( a , b ) => a - b ) for ( let i = 0 ; i < N ; i ++ ) { if ( ropes [ i ] <= curSize + 1 ) { curSize = curSize + ropes [ i ] ; } else break ; } return curSize ; }
function FirstDigit ( arr , n ) { let S = 0 ; for ( let i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; let fract_S = S - Math . floor ( S ) ; let ans = parseInt ( Math . pow ( 10 , fract_S ) , 10 ) ; return ans ; }
function count ( N , X , subStr , index , n ) { if ( index == n ) return 0 ; let a = subStr + N [ index ] ; let b = 0 ; if ( parseInt ( a ) % X == 0 ) b = 1 ; let m1 = count ( N , X , a , index + 1 , n ) ; let m2 = b + count ( N , X , " " , index + 1 , n ) ; return Math . max ( m1 , m2 ) ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
function MinRemove ( a , n , k ) { let cnt = new Array ( k ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }
function isPossible ( x , y , z ) { let a = Math . round ( x * x + y * y + z * z ) ; if ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) return true ; return false ; }
function subtract ( x , y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
function compute ( query ) { var v = Array ( 100001 ) . fill ( 0 ) ; var dp = Array ( 100001 ) . fill ( 0 ) ; v [ 1 ] = 1 , v [ 2 ] = 0 ; dp [ 1 ] = 0 , dp [ 2 ] = 0 ; for ( var i = 3 ; i < 100001 ; i ++ ) { if ( i % 2 != 0 ) { if ( parseInt ( i / 2 ) % 2 == 0 ) { v [ i ] = 1 ; dp [ i ] = dp [ i - 1 ] ; } else { v [ i ] = v [ parseInt ( i / 2 ) ] + 1 ; dp [ i ] = dp [ i - 1 ] + v [ i ] - 1 ; } } else { v [ i ] = 0 ; dp [ i ] = dp [ i - 1 ] ; } } query . forEach ( x => { document . write ( dp [ x ] + " " ) ; } ) ; }
function remainder ( str ) { let len = str . length ; let num ; let rem = 0 ; for ( let i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - ' ' ) ; rem = num % 11 ; } return rem ; }
function minsteps ( n , m ) { if ( m > n ) { return - 1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
function minModulo ( L , R , N ) { if ( R - L < N ) { let ans = Number . MAX_VALUE ; for ( let i = L ; i <= R ; i ++ ) for ( let j = L ; j <= R ; j ++ ) if ( i != j ) ans = Math . min ( ans , ( i * j ) % N ) ; document . write ( ans ) ; } else { document . write ( 0 ) ; } }
function minCost ( N , P , Q ) { var cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { var temp = parseInt ( N / 2 ) ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N = parseInt ( N / 2 ) ; } } return cost ; }
function isPanalphabeticWindow ( s , n ) { var ch = ' ' ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; if ( ch == String . fromCharCode ( ' ' . charCodeAt ( 0 ) + 1 ) ) return true ; } return false ; }
function printFactorialNums ( n ) { let fact = 1 ; let x = 2 ; while ( fact <= n ) { document . write ( fact + " " ) ; fact = fact * x ; x ++ ; } }
function minimum_sum ( n , k ) { if ( k % n == 0 ) return 0 ; return 1 ; }
function calculateSum ( n ) { return ( parseInt ( Math . pow ( 10 , n + 1 ) ) * ( 9 * n - 1 ) + 10 ) / parseInt ( Math . pow ( 9 , 3 ) ) - n * ( n + 1 ) / 18 ; }
function findAandB ( N ) { let val = N * N - 4.0 * N ; if ( val < 0 ) { document . write ( " " ) ; return ; } let a = ( N + Math . sqrt ( val ) ) / 2.0 ; let b = ( N - Math . sqrt ( val ) ) / 2.0 ; document . write ( " " + a . toFixed ( 4 ) + " " ) ; document . write ( " " + b . toFixed ( 5 ) ) ; }
function findSymPairs ( arr ) { let hM = new Map ( ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { let first = arr [ i ] [ 0 ] ; let sec = arr [ i ] [ 1 ] ; let val = hM . get ( sec ) ; if ( val != null && val == first ) document . write ( " " + sec + " " + first + " " ) ; else hM . set ( first , sec ) ; } } let arr = new Array ( 5 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { arr [ i ] [ j ] = 0 ; } }
function isEqualSubstring ( str , x ) { let n = str . length ; let i = 0 ; while ( i < n && i < x ) { if ( str [ i ] !== str [ n - i - 1 ] ) { document . write ( " " ) ; return ; } i ++ ; } document . write ( " " ) ; }
function evenproduct ( arr , length ) { var count = 0 ; var i , j ; for ( i = 0 ; i < length + 1 ; i ++ ) { var product = 1 ; for ( j = i ; j < length + 1 ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } document . write ( count ) ; }
function find_index ( arr , n , K ) { let start = 0 ; let end = n - 1 ; while ( start <= end ) { let mid = Math . floor ( ( start + end ) / 2 ) ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
function getValue ( arr , N ) { let dp = Array . from ( { length : N } , ( _ , i ) => 0 ) ; dp [ 0 ] = 0 ; for ( let i = 1 ; i < N ; i ++ ) { let min = arr [ i ] ; let max = arr [ i ] ; for ( let j = i ; j >= 0 ; j -- ) { min = Math . min ( arr [ j ] , min ) ; max = Math . max ( arr [ j ] , max ) ; dp [ i ] = Math . max ( dp [ i ] , max - min + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; }
function GIF ( n ) { return Math . floor ( n ) ; }
function check ( a , n ) { flag = false ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = true ; } if ( flag ) return false ; else return true ; }
function maxLength ( a , n ) { let maxLen = 0 ; let prev_cnt = 0 , curr_cnt = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = Math . max ( maxLen , Math . min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; }
function MinDistK ( arr , N , K ) { let res = Number . MAX_VALUE ; let dist = 0 ; for ( let i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = Math . max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = Math . abs ( arr [ i ] ) + Math . abs ( arr [ i + K - 1 ] ) + Math . min ( Math . abs ( arr [ i ] ) , Math . abs ( arr [ i + K - 1 ] ) ) ; } res = Math . min ( res , dist ) ; } return res ; }
function search ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
function count ( arr , n , k ) { arr . sort ( ) ; var cnt = 0 ; var i = 0 ; var j = 1 ; while ( i < n && j < n ) { if ( j <= i ) j = i + 1 else j = j while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j += 1 ; cnt += ( n - j ) ; i += 1 ; } return cnt ; }
function smallestSumSubarr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; let sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum_here = Math . max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; }
function conVowUpp ( str ) { var N = str . length ; for ( var i = 0 ; i < N ; i ++ ) { if ( str [ i ] === " " str [ i ] === " " str [ i ] === " " str [ i ] === " " str [ i ] === " " ) { document . write ( str [ i ] . toUpperCase ( ) ) ; } else { document . write ( str [ i ] ) ; } } }
function count_of_ways ( n ) { var count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
function minOperations ( a , b , n ) { var minA = Math . max . apply ( Math , a ) ; ; for ( x = minA ; x >= 0 ; x -- ) { var check = true ; var operations = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; }
function even_or_odd ( N ) { let len = N . length ; if ( N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' ) return ( " " ) ; else return ( " " ) ; }
function find_sum_of_two_squares ( a , b ) { let ab = a * b ; for ( let i = 0 ; i * i <= ab ; i ++ ) { for ( let j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) document . write ( i + " " + j + " " + ab + " " ) ; } } }
function isOctadecagon ( N ) { let n = ( 14 + Math . sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 18 ; if ( isOctadecagon ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function minimumCostOfBreaking ( X , Y , m , n ) { let res = 0 ; X . sort ( ) ; X . reverse ( ) ; Y . sort ( ) ; Y . reverse ( ) ; let hzntl = 1 , vert = 1 ; let i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } let total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
function eccHyperbola ( A , B ) { let r = B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; }
function subtractOne ( x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
function smallestNumber ( N ) { document . write ( N * Math . floor ( ( Math . pow ( 10 , N ) - 1 ) / N ) ) ; }
function maxDiff ( arr , n ) { let maxDiff = - 1 ; let maxRight = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { let diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
function printDiagonalSums ( mat , n ) { let principal = 0 , secondary = 0 ; for ( let i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } document . write ( " " + principal + " " ) ; document . write ( " " + secondary ) ; }
function MaxXOR ( arr , N ) { var res = 0 ; for ( var i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; }
function checkFittingArrays ( A , B , N ) { A . sort ( function ( a , b ) { return a - b ; } ) ; B . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
function removeDuplicatesFromString ( string ) { let table = new Array ( 256 ) ; for ( let i = 0 ; i < table . length ; i ++ ) table [ i ] = 0 ; let chars = string . split ( " " ) ; let endIndex = 0 ; for ( let i = 0 ; i < chars . length ; i ++ ) { if ( table [ chars [ i ] . charCodeAt ( 0 ) ] == 0 ) { table [ chars [ i ] . charCodeAt ( 0 ) ] = - 1 ; chars [ endIndex ++ ] = chars [ i ] ; } } let ans = " " ; for ( let i = 0 ; i < endIndex ; i ++ ) ans += chars [ i ] return ans ; }
function AreaofRectangle ( L , W ) { var area = parseFloat ( ( ( W + L ) * ( W + L ) ) / 2 ) . toFixed ( 1 ) ; return area ; }
function TotalXorPair ( arr , N ) { let totalXOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; }
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
function sumOfDigitsFrom1ToN ( n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; let d = parseInt ( Math . log ( n ) / Math . log ( 10 ) , 10 ) ; let a = new Array ( d + 1 ) ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( let i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * parseInt ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) , 10 ) ; let p = parseInt ( Math . ceil ( Math . pow ( 10 , d ) ) , 10 ) ; let msd = parseInt ( n / p , 10 ) ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
function countP ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
function checkPalindrome ( num ) { let str = num . toString ( ) ; let l = 0 , r = str . length - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { document . write ( " " ) ; return ; } l ++ ; r -- ; } document . write ( " " ) ; return ; }
function countNumbers ( n , d ) { let total = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } document . write ( total ) ; }
function count ( N , B ) { var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { sum += ( B - 1 ) * Math . pow ( B , i - 1 ) ; } return sum ; }
function print_product ( a , b , c , d ) { let prod1 = a * c ; let prod2 = b * d ; let prod3 = ( a + b ) * ( c + d ) ; let real = prod1 - prod2 ; let imag = prod3 - ( prod1 + prod2 ) ; document . write ( real + " " + imag + " " ) ; }
function leftRotate ( arr , n , k ) { for ( let i = k ; i < k + n ; i ++ ) document . write ( arr [ i % n ] + " " ) ; }
function removeSpecialCharacter ( str ) { let s = str . split ( " " ) ; let j = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( ( s [ i ] >= ' ' && s [ i ] <= ' ' ) || ( s [ i ] >= ' ' && s [ i ] <= ' ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } document . write ( ( s ) . join ( " " ) . substring ( 0 , j ) ) ; }
function convertToASCII ( N ) { let num = N . toString ( ) ; for ( let ch = 0 ; ch < num . length ; ch ++ ) { document . write ( num [ ch ] + " " + num [ ch ] . charCodeAt ( 0 ) + " " ) ; } }
function minOperation ( arr ) { let minOp = Number . MIN_VALUE ; let minNeg = 0 , maxPos = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return Math . abs ( minNeg ) + maxPos ; }
function CountCharacters ( str , l , r ) { let cnt = 0 ; let m = new Map ( ) ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) ) { cnt ++ ; if ( ! m . has ( str [ i ] ) ) { m . set ( str [ i ] , 0 ) ; document . write ( str [ i ] + " " ) ; } m . set ( str [ i ] , m . get ( str [ i ] + 1 ) ) ; } } return cnt ; }
function truncMod ( a , n ) { let q = Math . round ( a / n ) ; return a - ( n * q ) ; }
function maxPrimes ( n ) { return parseInt ( n / 2 ) ; }
function CountMaximum ( arr , n , k ) { arr . sort ( ) ; let sum = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
function squareSum ( n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
function alter ( x , y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } document . write ( " " + x + " " + " " + y ) ; }
function is_possible ( s ) { let l = s . length ; let one = 0 , zero = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' ' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . abs ( one - zero ) == 1 ) ; }
function MinOfCubedDP ( k ) { let DP = new Array ( k + 1 ) ; DP . fill ( 0 ) ; let j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= k ; i ++ ) { DP [ i ] = Number . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
function gcd ( a , b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }
function printMaxSum ( arr , n ) { let dp = new Array ( n ) ; dp . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; let maxi = 0 ; for ( let j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ parseInt ( ( i + 1 ) / j , 10 ) - 1 ] > maxi && j != 1 ) maxi = dp [ parseInt ( ( i + 1 ) / j , 10 ) - 1 ] ; } } dp [ i ] += maxi ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( dp [ i ] + " " ) ; }
function singleelement ( arr , n ) { let low = 0 , high = n - 2 ; let mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; }
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 7 * n + 3 ; }
function CountSubSet ( arr , n , X ) { let N = Math . pow ( 2 , n ) ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
function reachTarget ( target ) { target = Math . abs ( target ) ; let sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
function findMaxGuests ( arrl , exit , n ) { arrl . sort ( function ( a , b ) { return a - b } ) ; exit . sort ( function ( a , b ) { return a - b } ) ; let guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; let i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } document . write ( " " + max_guests + " " + time ) ; }
function countarray ( n , k , x ) { let dp = [ ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
function ellipsearea ( r ) { if ( r < 0 ) return - 1 ; var a = ( ( 3.14 * r * r ) / 4 ) ; return a ; }
function smallest ( k , d ) { let cnt = 1 ; let m = d % k ; let v = new Array ( k ) . fill ( 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } return - 1 ; }
function LargestString ( na ) { let N = na . length ; let c = new Array ( N ) ; let m = 1 ; for ( let j = 0 ; j < N ; j ++ ) { let character = new Array ( 26 , 0 ) ; for ( let k = 0 ; k < na [ j ] . length ; k ++ ) { let x = na [ j ] [ k ] . charCodeAt ( 0 ) - 65 ; if ( ( na [ j ] [ k ] != ' ' ) && ( character [ x ] == 0 ) ) { c [ j ] ++ ; character [ x ] = 1 ; } } if ( c [ j ] > c [ m ] ) m = j ; } document . write ( na [ m ] ) ; }
function findMinSum ( arr , K , L , size ) { if ( K * L > size ) return - 1 ; let minsum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; }
function factors ( n ) { let i , j ; document . write ( " " ) ; for ( i = 2 ; i <= n ; i ++ ) { document . write ( i + " " ) ; for ( j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { document . write ( j + " " ) ; if ( parseInt ( i / j ) != j ) document . write ( parseInt ( i / j ) + " " ) ; } } document . write ( " " ) ; } }
function countSymmetric ( n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
function findXOR ( Set , n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function volumeRec ( a , b , e , h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
function findMajority ( arr , n ) { let len = 32 ; let number = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let countt = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countt ++ ; } if ( countt > parseInt ( n / 2 , 10 ) ) number += ( 1 << i ) ; } let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > parseInt ( n / 2 , 10 ) ) document . write ( number ) ; else document . write ( " " ) ; }
function bitPos ( n1 , n2 ) { if ( n1 == n2 ) return 0 ; let bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; let bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; let bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; let maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } let xorValue = n1 ^ n2 ; let bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; let disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
function isLucky ( n ) { var arr = Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { var digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = parseInt ( n / 10 ) ; } return true ; }
function printPairs ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; } } }
function findEquation ( A , B , C ) { document . write ( " " + C + " " + " " + B + " " + A + " " ) }
function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
function cntEdges ( n ) { var edges = Math . pow ( 2 , n ) - 2 ; return edges ; }
function maximumTurns ( arr , N ) { let Count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = Math . floor ( arr [ i ] / 2 ) ; } } return Count ; }
function isPossible ( n , k , arr ) { let sum = arr [ 0 ] ; let maxVal = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . max ( maxVal , arr [ i ] ) ; } if ( maxVal > ( sum + k ) / n ) return false ; return true ; }
function isdodecagonal ( N ) { let n = ( 4 + Math . sqrt ( 20 * N + 16 ) ) / 10 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 12 ; if ( isdodecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function findNumber ( n , d ) { let ans = " " ; if ( d != 10 ) { ans += ( d ) . toString ( ) ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } else { if ( n == 1 ) ans += " " ; else { ans += ' ' ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } } return ans ; }
function findCount ( str ) { var result = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) if ( i === str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) || i === str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ) result ++ ; return result ; }
function Div_by_8 ( n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
function getRemainder ( num , divisor ) { let t = ( num - divisor * parseInt ( num / divisor ) ) ; return t ; }
function computePair ( K ) { if ( K == 1 ) { document . write ( " " ) ; return ; } else { document . write ( K * K / ( K - 1 ) + " " ) ; document . write ( K / ( K - 1 ) ) ; } }
function findPosition ( n , f , b ) { return n - Math . max ( f + 1 , n - b ) + 1 ; }
function maxXorSum ( n , k ) { if ( k == 1 ) return n ; let res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
function mixtureConcentration ( n , p ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
function findWaysToPair ( p ) { var dp = Array ( p + 1 ) ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( var i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }
function numberOfArithmeticSequences ( L , N ) { if ( N <= 2 ) return 0 ; var count = 0 ; var res = 0 ; for ( var i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
function min_remove ( arr , n , k ) { arr . sort ( ) ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = Math . min ( ans , n - j + i - 1 ) ; } } } return ans ; }
function maxGcd ( a , b ) { document . write ( Math . abs ( a - b ) ) ; }
function isCornerPresent ( str , corner ) { var n = str . length ; var cl = corner . length ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . localeCompare ( corner ) === 0 && str . substring ( n - cl , n ) . localeCompare ( corner ) === 0 ) ; }
function countSticks ( str , n ) { var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str [ i ] - ' ' ] ) ; } return cnt ; }
function countFriendsPairings ( n ) { let dp = [ ] ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
function isLucky ( n ) { let counter = 2 ; let next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= Math . floor ( next_position / counter ) ; counter ++ ; return isLucky ( next_position ) ; }
function possibleBinaries ( pos , ones , sum , k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos ] [ ones ] [ sum ] != - 1 ) return dp [ pos ] [ ones ] [ sum ] ; let ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos ] [ ones ] [ sum ] = ret ; return dp [ pos ] [ ones ] [ sum ] ; }
function maxDP ( n ) { let res = [ ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { res [ i ] = Math . max ( i , ( res [ Math . floor ( i / 2 ) ] + res [ Math . floor ( i / 3 ) ] + res [ Math . floor ( i / 4 ) ] + res [ Math . floor ( i / 5 ) ] ) ) ; } return res [ n ] ; }
function minOperation ( k ) { let dp = Array . from ( { length : k + 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
function graphExists ( a , n ) { while ( 1 ) { a . sort ( ( a , b ) => b - a ) if ( a [ 0 ] == 0 ) return true ; var v = a [ 0 ] ; a . shift ( ) ; if ( v > a . length ) return false ; for ( var i = 0 ; i < v ; i ++ ) { a [ i ] -- ; if ( a [ i ] < 0 ) return false ; } } }
function Area ( d , h1 , h2 ) { let area ; area = 0.5 * d * ( h1 + h2 ) ; return area ; }
function evenSubMatrix ( N ) { let even = 1 ; let odd = 2 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( ( i + j ) % 2 == 0 ) { document . write ( even + " " ) ; even += 2 ; } else { document . write ( odd + " " ) ; odd += 2 ; } } document . write ( " " ) ; } }
function minsteps ( arr , n ) { arr . sort ( ( a , b ) => a - b ) var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { ans += Math . abs ( arr [ i ] - Math . pow ( 2 , i ) ) ; } return ans ; }
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
function perimeter ( diameter , height ) { return 2 * ( diameter + height ) ; }
function findNumbers ( n ) { var odd = Math . pow ( 10 , n ) - 1 ; var even = odd - 1 ; document . write ( " " + even + " " ) ; document . write ( " " + odd ) ; }
function findUniquePair ( arr , n ) { let XOR = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; let set_bit_no = XOR & ~ ( XOR - 1 ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( " " + x + " " + y + " " + " " ) ; }
function minimum ( n ) { let product = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
function countSquares ( row , column ) { var topLeft = Math . min ( row , column ) - 1 ; var bottomRight = 8 - Math . max ( row , column ) ; var topRight = Math . min ( row , 9 - column ) - 1 ; var bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
function minItems ( k , r ) { for ( let i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
function longestRodInCuboid ( length , breadth , height ) { let result ; let temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; }
function canConvert ( str1 , str2 ) { var i = 0 , j = 0 ; while ( i < str1 . length && j < str2 . length ) { if ( str1 [ i ] !== str2 [ j ] ) { if ( str1 [ i ] === " " && str2 [ j ] === " " && i + 1 < str1 . length && str1 [ i + 1 ] === " " ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i === str1 . length && j === str2 . length ) return true ; return false ; }
function countNum ( arr , n ) { let count = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
function minOperation ( arr ) { let ans = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { for ( let j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( let k = 0 ; k <= i ; k ++ ) { for ( let h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
function getLargestSum ( N ) { var max_sum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { for ( j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . max ( max_sum , i + j ) ; } } return max_sum ; }
function countPairsWithDiffK ( arr , n , k ) { let count = 0 ; arr . sort ( ) ; let l = 0 ; let r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = parseInt ( n / i , 10 ) ; let num1 = fir * k + sec ; let res = parseInt ( ( num1 / k ) , 10 ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = parseInt ( ( num2 / k ) , 10 ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }
function printPFsInPairs ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + " " + parseInt ( n / i ) + " " ) ; }
function checksum ( n , k ) { var first_term = ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - parseInt ( ( first_term ) ) == 0 ) { for ( i = parseInt ( first_term ) ; i <= first_term + k - 1 ; i ++ ) { document . write ( i + " " ) ; } } else document . write ( " " ) ; }
function maxLenSub ( arr , n ) { let mls = new Array ( n ) . fill ( 1 ) , max = 0 ; for ( let i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
function countNumberHavingKthBitSet ( N , K ) { let numbers_rightmost_setbit_K = 0 ; for ( let i = 1 ; i <= K ; i ++ ) { let numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } document . write ( numbers_rightmost_setbit_K ) ; }
function DiStirngMatch ( Str ) { var N = Str . length ; var arr = Array ( N ) . fill ( 0 ) ; var START = 0 , END = N ; for ( var i = 0 ; i < N ; i ++ ) { if ( Str [ i ] == ' ' ) arr [ i ] = START ++ ; if ( Str [ i ] == ' ' ) arr [ i ] = END -- ; } arr [ N ] = START ; return arr ; }
function uniqueElement ( arr ) { var x = arr [ 0 ] ; var flag = 1 ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] != x ) { flag = 0 ; break ; } } if ( flag == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function unitDigitXRaisedY ( x , y ) { let res = 1 ; for ( let i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
function xoring ( a , b , n ) { let ans = " " ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == b [ i ] ) ans += " " ; else ans += " " ; } return ans ; }
function decideWinner ( a , n ) { var count0 = 0 ; var count1 = 0 ; var count2 = 0 ; var count3 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
function findRectNum ( n ) { return n * ( n + 1 ) ; }
function nextPerfectCube ( N ) { let nextN = Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; }
function findPermutation ( N ) { for ( var i = 1 ; i <= N ; i ++ ) document . write ( i + " " ) ; document . write ( " " ) ; }
function isStraighLineNum ( N ) { if ( N <= 99 ) return false ; let s = N . toString ( ) ; let d = s [ 1 ] - s [ 0 ] ; for ( let i = 2 ; i < s . length ; i ++ ) if ( s [ i ] - s [ i - 1 ] != d ) return false ; return true ; } let n = 135 ; if ( isStraighLineNum ( n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function sumOfInternalAngles ( n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; }
function Area ( a ) { if ( a < 0 ) return - 1 ; let h = 1.268 * a ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
function search ( arr , n , x ) { if ( arr [ n - 1 ] == x ) return " " ; let backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( let i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " " ; return " " ; } } }
function Solve ( N , M ) { let temp = ( N - 1 ) * ( M - 1 ) ; let ans = ( Math . pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) document . write ( ans ) ; else document . write ( 2 * ans ) ; }
function maxProfit ( prices , n ) { let profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { let day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; }
function countdigits ( n , k ) { if ( n == 0 ) return 0 ; var digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }
function countTrailingZero ( x ) { let count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
function find_prob ( N , P ) { let dp = [ ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( let i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( dp [ N ] ) ; }
function countReduce ( str ) { let n = str . length ; let res = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) res += Math . abs ( str [ i ] . charCodeAt ( ) - str [ n - i - 1 ] . charCodeAt ( ) ) ; return res ; }
function areaOftriangle ( side ) { let a = Math . sqrt ( Math . pow ( side / 2 , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let b = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let c = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let s = ( a + b + c ) / 2 ; let area = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area . toFixed ( 1 ) ; }
function minOpsToEmptyString ( s ) { var ans = Number . MIN_VALUE ; var cn0 = 0 ; var cn1 = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . max ( ans , Math . max ( cn0 , cn1 ) ) ; } document . write ( ans ) ; }
function isCenteredOctadecagonal ( N ) { let n = parseInt ( ( 9 + Math . sqrt ( 36 * N + 45 ) ) / 18 ) ; return ( n - parseInt ( n ) ) == 0 ; } let n = 19 ; if ( isCenteredOctadecagonal ( n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function checkEvenPower ( N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; }
function amendSentence ( sstr ) { let str = sstr . split ( ' ' ) ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) { str [ i ] = String . fromCharCode ( str [ i ] . charCodeAt ( ) + 32 ) ; if ( i != 0 ) document . write ( " " ) ; document . write ( str [ i ] ) ; } else document . write ( str [ i ] ) ; } }
function minSum ( a , n ) { a . sort ( ) ; let num1 = 0 ; let num2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
function findArea ( a , b ) { var Area ; Area = 3.142 * a * b ; document . write ( " " + Area . toFixed ( 2 ) ) ; }
function solve ( A , n , Q , q ) { var one = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; var glows = 0 , count = 0 ; if ( one >= Math . ceil ( n / 2 ) ) glows = 1 ; for ( var i = 0 ; i < q ; i ++ ) { var prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= Math . ceil ( n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; }
function countSol ( coeff , n , rhs ) { let dp = new Array ( rhs + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
function longLenSub ( arr , n ) { let um = new Map ( ) ; let longLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let len = 0 ; if ( um . has ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . has ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . set ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; }
function minimizeCost ( A , B , C ) { let ans = A + B + C ; for ( let i = 1 ; i <= 2 * C ; i ++ ) { let j = 0 ; while ( i * j <= 2 * C ) { ans = Math . min ( ans , Math . abs ( A - i ) + Math . abs ( B - j ) + Math . abs ( i * j - C ) ) ; j ++ ; } } return ans ; }
function cntWays ( n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
function maxCount ( arr , m , V ) { let table = [ ] ; table [ 0 ] = 0 ; for ( let i = 1 ; i <= V ; i ++ ) table [ i ] = - 1 ; for ( let i = 1 ; i <= V ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( arr [ j ] <= i ) { let sub_res = table [ i - arr [ j ] ] ; if ( sub_res != - 1 && sub_res + 1 > table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
function countBits ( n ) { var count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
function procal ( n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
function lexicographicSubConcat ( s ) { var n = s . length ; var sub_count = n * parseInt ( ( n + 1 ) / 2 ) ; var arr = Array ( sub_count ) ; var index = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var len = 1 ; len <= n - i ; len ++ ) arr [ index ++ ] = s . substring ( i , i + len ) ; arr . sort ( ) ; var res = " " ; for ( var i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
function formQuadruplets ( arr , n ) { var ans = 0 , pairs = 0 ; pairs = parseInt ( n / 4 ) ; arr . sort ( ) . reverse ( ) ; for ( var i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; }
function countXor ( N ) { let cnt = Math . floor ( N / 2 ) + 1 ; return cnt ; }
function checkArray ( arr , n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }
function search ( mat , n , x ) { let i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { document . write ( " " + i + " " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } document . write ( " " ) ; return ; }
function maxPointCount ( arr , k , size ) { let curr_points = 0 ; let max_points = 0 ; for ( let i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; let j = size - 1 ; for ( let i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = Math . max ( curr_points , max_points ) ; j -- ; } return max_points ; }
function Maxsum ( c1 , c2 , c3 , c4 ) { let sum = 0 ; let two34 = Math . min ( c2 , Math . min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . min ( c2 , c1 ) * 12 ; return sum ; }
function findXOR ( mat , N ) { let XOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { for ( let k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i ] [ j ] [ k ] ; XOR ^= mat [ i ] [ j ] [ N - k - 1 ] ; } } } } document . write ( XOR ) ; }
function countConsecutive ( N ) { let count = 0 ; for ( let L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { let a = ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - parseInt ( a , 10 ) == 0.0 ) count ++ ; } return count ; }
function findNth ( N ) { let b = 14 ; for ( let i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
function findOptimalSolution ( a , N ) { a . sort ( function ( a , b ) { return a - b } ) ; let points = 0 ; for ( let i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
function triacontagonalNum ( n ) { return ( 28 * n * n - 26 * n ) / 2 ; }
function ConstructList ( Q ) { var xr = 0 ; var ans = [ ] ; for ( var i = N - 1 ; i >= 0 ; i -- ) { if ( Q [ i ] [ 0 ] == 0 ) ans . push ( Q [ i ] [ 1 ] ^ xr ) ; else xr ^= Q [ i ] [ 1 ] ; } ans . push ( xr ) ; ans . sort ( ( a , b ) => a - b ) ; return ans ; } var Q = [ [ 0 , 6 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 4 ] , [ 1 , 5 ] ] ; var ans = ConstructList ( Q ) ; ans . forEach ( element => { document . write ( " " + element ) ; }
function sumOfTheSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let k = 2 ; for ( let j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
function countPairs ( n ) { let count = 0 ; for ( let x = 1 ; x < n ; x ++ ) { for ( let y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
function findMinXORSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_xor = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; let min_xor = curr_xor ; for ( let i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } document . write ( min_xor + " " ) ; }
function xorCalc ( k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return parseInt ( k / 2 ) ; return 1 ; }
function isValidNesbitt ( a , b , c ) { let A = a / ( b + c ) ; let B = b / ( a + c ) ; let C = c / ( a + b ) ; let inequality = A + B + C ; return ( inequality >= 1.5 ) ; } let a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) == true ) { document . write ( " " + " " ) ; document . write ( " " + a + " " + b + " " + c ) ; }
function check ( s ) { for ( let i = 0 ; i < s . length - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; }
function minimumBox ( arr , n ) { var q = [ ] ; arr . sort ( ( a , b ) => a - b ) q . push ( arr [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { var now = q [ 0 ] ; if ( arr [ i ] >= 2 * now ) q . pop ( 0 ) ; q . push ( arr [ i ] ) ; } return q . length ; }
function minSteps ( N ) { let count = 1 , res = 0 ; for ( let i = 1 ; i <= N ; i += count ) { res = Math . max ( res , count ) ; count ++ ; } return res ; }
function convert ( s ) { var n = s . length ; var s1 = " " ; s1 = s1 + s . charAt ( 0 ) . toLowerCase ( ) ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ' && i < n ) { s1 = s1 + " " + s . charAt ( i + 1 ) . toLowerCase ( ) ; i ++ ; } else s1 = s1 + s . charAt ( i ) . toUpperCase ( ) ; } return s1 ; }
function lucas ( n ) { let a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
function maxModProdSubarr ( arr , n , M ) { var ans = 0 ; var length = n ; for ( i = 0 ; i < n ; i ++ ) { var product = 1 ; for ( j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } document . write ( " " + ans + " " ) ; document . write ( " " + " " + length ) ; }
function subString ( str , n ) { for ( let len = 1 ; len <= n ; len ++ ) { for ( let i = 0 ; i <= n - len ; i ++ ) { let j = i + len - 1 ; for ( let k = i ; k <= j ; k ++ ) { document . write ( str [ k ] ) ; } document . write ( " " ) ; } } }
function enneacontagonNum ( n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
function findMinSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
function largestGCDSubsequence ( arr , n ) { var ans = 0 ; var maxele = Math . max ( ... arr ) ; for ( var i = 2 ; i <= maxele ; ++ i ) { var count = 0 ; for ( j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }
function hexacontagonNum ( n ) { return ( 58 * n * n - 56 * n ) / 2 ; }
function countTriplets ( N , K ) { if ( K % 2 == 0 ) { var x = parseInt ( N / K ) ; var y = parseInt ( ( N + ( K / 2 ) ) / K ) ; return x * x * x + y * y * y ; } else { var x = parseInt ( N / K ) ; return x * x * x ; } }
function findString ( N , K ) { for ( let i = 0 ; i < N ; i ++ ) { document . write ( String . fromCharCode ( ' ' . charCodeAt ( ) + i % K ) ) ; } }
function maximumK ( S ) { let N = S . length ; let ans = N ; let flag = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) { flag = 1 ; ans = Math . min ( ans , Math . max ( i + 1 , N - i - 1 ) ) ; } } if ( flag == 0 ) return 0 ; return ans ; }
function countPairsWithDiffK ( arr , N , K ) { var vis = new Array ( N ) ; vis . fill ( 0 ) ; var count = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( vis [ i ] == 1 ) continue ; for ( var j = i + 1 ; j < N ; j ++ ) { if ( vis [ j ] == 1 ) continue ; if ( Math . abs ( arr [ i ] - arr [ j ] ) >= K ) { count ++ ; vis [ i ] = 1 ; vis [ j ] = 1 ; break ; } } } document . write ( count + " " ) ; }
function getModulo ( n , d ) { return ( n & ( d - 1 ) ) ; }
function minSumPath ( ) { let memo = [ ] ; let n = A . length - 1 ; for ( let i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( let i = A . length - 2 ; i >= 0 ; i -- ) for ( let j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
function angle ( n ) { return 2 * n ; }
function condition ( a , b ) { let d = Math . abs ( a - b ) , count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; }
function count_minimum_operations ( n ) { let count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
function istriacontagonal ( N ) { let n = ( ( 26 + Math . sqrt ( 224 * N + 676 ) ) / 56 ) ; return ( n - parseInt ( n ) ) == 0 ; } let N = 30 ; if ( istriacontagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function seriesSum ( calculated , current , N ) { let i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
function longestCommonSum ( n ) { let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let sum1 = 0 , sum2 = 0 ; for ( let j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { let len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
function countFreq ( a , n ) { let hm = new Array ( n ) ; for ( let i = 0 ; i < hm . length ; i ++ ) { hm [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; let cumul = 0 ; for ( let i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { document . write ( a [ i ] + " " + cumul + " " ) ; } hm [ a [ i ] ] = 0 ; } }
function findTripleSum ( A , B , C ) { let sum = 0 ; for ( let i = 1 ; i <= A ; i ++ ) { for ( let j = 1 ; j <= B ; j ++ ) { for ( let k = 1 ; k <= C ; k ++ ) { let prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
function findNthNonSquare ( n ) { var x = n ; var ans = x + Math . floor ( 0.5 + Math . sqrt ( x ) ) ; return parseInt ( ans ) ; }
function Moves_Calculator ( x , y , row , col ) { let total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += Math . min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += Math . min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += Math . min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += Math . min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; let king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; }
function findExtra ( arr1 , arr2 , n ) { let index = n ; let left = 0 , right = n - 1 ; while ( left <= right ) { let mid = Math . floor ( ( left + right ) / 2 ) ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
function isEditDistanceOne ( s1 , s2 ) { let m = s1 . length , n = s2 . length ; if ( Math . abs ( m - n ) > 1 ) return false ; let count = 0 ; let i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; else { i ++ ; j ++ ; } count ++ ; } else { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; }
function isValid ( s ) { let n = Math . sqrt ( s . length ) ; let check = s [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = i , y = i ; while ( x >= 0 && y < n ) { if ( s [ ( n * x ) + y ] != check || s [ ( n * y ) + x ] != check ) { document . write ( " " ) ; return ; } x -- ; y ++ ; } } document . write ( " " ) ; }
function findLast ( mat ) { let m = mat . length ; let n = mat [ 0 ] . length ; let rows = new Set ( ) ; let cols = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . add ( i ) ; cols . add ( j ) ; } } } let avRows = m - rows . size ; let avCols = n - cols . size ; let choices = Math . min ( avRows , avCols ) ; if ( choices & 1 ) document . write ( " " ) else document . write ( " " ) }
function minDistance ( start , intend , n , d ) { let left = Number . MIN_SAFE_INTEGER ; let right = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { left = Math . max ( left , start [ i ] ) ; right = Math . min ( right , end [ i ] ) ; } if ( left > right ) return - 1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return left - d ; if ( d > right ) return d - right ; }
function countOfSubstringWithOnlyOnes ( s ) { var res = 0 , count = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { count = s [ i ] == ' ' ? count + 1 : 0 ; res = ( res + count ) ; } return res ; }
function solve ( n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; return solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
function findRadiusOfIncircle ( a , b , c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; var p = ( a + b + c ) / 2 ; var area = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; var radius = area / p ; return radius ; }
function maxOR ( arr , n , k , x ) { let preSum = new Array ( n + 1 ) ; let suffSum = new Array ( n + 1 ) ; let res = 0 , pow = 1 ; for ( let i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
function check ( X , K ) { var prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = parseInt ( Math . sqrt ( X ) ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = parseInt ( temp / i ) ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; }
function minDiffSubArray ( arr , n ) { let prefix_sum = new Array ( n ) ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; let suffix_sum = new Array ( n ) ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let diff = Math . abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
function findNumbers ( n , d ) { for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( " " + " " ) ; document . write ( " " + " " ) ; document . write ( n + d ) ; }
function calculateSum ( n ) { return ( Math . pow ( 2 , n + 1 ) + n - 2 ) ; }
function hexadiagonal ( a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }
function findPCSlope ( m ) { return - 1.0 / m ; }
function isProductEven ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
function printPossible ( a , b , c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) document . write ( " " ) ; else document . write ( " " ) ; }
function countTriplets ( n , sum ) { arr . sort ( function ( a , b ) { return b - a } ) ; let ans = 0 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { let j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; }
function largestNumber ( N ) { if ( N > 45 ) return - 1 ; let num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
function findWater ( n ) { let left = new Array ( n ) ; let right = new Array ( n ) ; let water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) left [ i ] = Math . max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) right [ i ] = Math . max ( right [ i + 1 ] , arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) water += Math . min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; }
function geometricMean ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + Math . log ( arr [ i ] ) ; sum = sum / n ; return Math . exp ( sum ) ; }
function minSteps ( S ) { let new_str = " " ; let N = S . length ; let i = 0 ; while ( i < N ) { new_str += S [ i ] ; let j = i ; while ( i < N && S [ i ] == S [ j ] ) ++ i ; } document . write ( Math . ceil ( ( new_str . length + 1 ) / 2.0 ) ) ; }
function countSubstrings ( s , c ) { var n = s . length ; var cnt = 0 ; var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
function checkSamePosition ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { var temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . has ( temp ) ) { document . write ( " " ) ; return ; } if ( mp . has ( temp ) ) { mp . set ( temp , mp . get ( temp ) + 1 ) } else mp . set ( temp , 1 ) } document . write ( " " ) ; }
function Calculate_GST ( org_cost , N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
function findAnswer ( X , N ) { return ( N - 1 ) * 9 + X ; }
function countRotations ( arr , n ) { let min = arr [ 0 ] , min_index = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
function powerOf2 ( n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
function myXOR ( x , y ) { return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) ; }
function possibleToReach ( x , y , z ) { if ( z < Math . abs ( x ) + Math . abs ( y ) || ( z - Math . abs ( x ) - Math . abs ( y ) ) % 2 == 1 ) { document . write ( " " + " " ) ; } else document . write ( " " + " " ) ; }
function rangeSum ( l , r ) { var a = 1 , b = 9 , res = 0 ; for ( var i = 1 ; i <= 10 ; i ++ ) { var L = Math . max ( l , a ) ; var R = Math . min ( r , b ) ; if ( L <= R ) { var sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
function findSmallestDifference ( A , B , m , n ) { A . sort ( ( a , b ) => a - b ) ; B . sort ( ( a , b ) => a - b ) ; let a = 0 , b = 0 ; let result = Number . MAX_SAFE_INTEGER ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
function sum_all_divisors ( num ) { var sum = 0 ; for ( var i = 1 ; i <= Math . sqrt ( num ) ; i ++ ) { sum += t1 + t2 ; } return sum ; }
function ways ( n ) { return parseInt ( n / 2 ) ; }
function canVote ( a , n , x ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( x + 1 ) ; for ( let j = 0 ; j < x + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; return ( sum - dp [ n ] [ x ] <= x ) ; } let n = 3 , x = 4 ; let a = [ 2 , 4 , 2 ] ; if ( canVote ( a , n , x ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function countMaxIntersect ( n ) { return ( n ) * ( n - 1 ) / 2 ; }
function findIndex ( a , n ) { let res = 0 ; let min_diff = Number . MAX_VALUE ; let prod = new Array ( n ) ; prod [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let curr_diff = Math . abs ( parseInt ( prod [ n - 1 ] / prod [ i ] , 10 ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
function maxSum ( a , n ) { let ans = 0 ; let arr = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; ++ i ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; ++ j ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
function findMaxK ( N ) { var p = Math . log ( N ) / Math . log ( 2 ) ; return parseInt ( Math . pow ( 2 , p ) ) ; }
function translate ( str ) { for ( let i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == ' ' && str [ i ] == ' ' ) { str [ i - 1 ] = ' ' ; let j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; }
function countEle ( s , a , N ) { var mp = new Map ( ) ; for ( var i = 0 ; i < N ; ++ i ) { var num = a [ i ] ; if ( mp . has ( num ) ) document . write ( " " ) ; else { var cnt = 0 ; while ( s [ s . length - 1 ] != num ) { mp . set ( s [ s . length - 1 ] , true ) ; s . pop ( ) ; cnt ++ ; } s . pop ( ) ; cnt ++ ; document . write ( cnt + " " ) ; } } }
function getMinOps ( arr ) { var res = 0 ; for ( i = 0 ; i < arr . length - 1 ; i ++ ) { res += Math . max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; }
function isPerfectCubeString ( str ) { var sum = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { sum += str . charCodeAt ( i ) ; } var cr = Math . round ( Math . cbrt ( sum ) ) ; return cr * cr * cr == sum ; }
function countPairs ( a , n , k ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . sqrt ( a ) / 6 ; return area ; }
function power ( x , y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; }
function productOfGP ( a , r , n ) { return Math . pow ( a , n ) * Math . pow ( r , n * ( n - 1 ) / 2 ) ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = $y / 2 y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function PrintIndexes ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let currSubSum = 0 ; for ( let j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; let sq = Math . floor ( Math . sqrt ( currSubSum ) ) ; if ( sq * sq == currSubSum ) { document . write ( " " + i + " " + j + " " + " " ) ; } } } }
function printArray ( a , n ) { a . sort ( function ( a , b ) { return a - b ; } ) ; var i = 0 ; var j = n - 1 ; while ( i <= j ) { if ( i == j ) { document . write ( a [ i ] + " " ) ; } else { document . write ( a [ j ] + " " ) ; document . write ( a [ i ] + " " ) ; } i = i + 1 ; j = j - 1 ; } document . write ( " " ) ; }
function det ( d ) { let Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) ; Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) ; Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) ; return Sum ; }
function minSum ( N ) { let ans = Math . ceil ( 2 * Math . sqrt ( N + 1 ) ) ; document . write ( ans ) ; }
function countSamePrefixSuffix ( s , n ) { var prefix = " " ; for ( let i = 0 ; i < n - 1 ; i ++ ) { prefix += s . charAt ( i ) ; var suffix = s . substring ( n - 1 - i , n ) ; if ( prefix == suffix ) { document . write ( prefix . length + " " ) ; } } }
function findSingle ( ar , ar_size ) { let res = ar [ 0 ] ; for ( let i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
function rectanglearea ( r ) { if ( r < 0 ) return - 1 ; var a = r * r ; return a ; }
function operations ( arr , n , k ) { arr . sort ( ) ; let i = 0 , sum = 0 ; while ( k -- > 0 ) { while ( i < n && arr [ i ] - sum == 0 ) i ++ ; if ( i < n && arr [ i ] - sum > 0 ) { document . write ( arr [ i ] - sum + " " ) ; sum = arr [ i ] ; } else document . write ( " " ) ; } }
function find_next ( n , k ) { let M = n + 1 ; while ( true ) { if ( ( M & ( 1 << k ) ) > 0 ) break ; M ++ ; } return M ; }
function findRange ( arr , N , K ) { let L = Number . MIN_VALUE ; let R = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let l = Math . ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; let r = Math . ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = Math . max ( L , l ) ; R = Math . min ( R , r ) ; } document . write ( L + " " + R ) ; }
function countDigit ( n ) { var prime = Array ( 10 ) . fill ( false ) ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; var temp = n , count = 0 ; while ( temp != 0 ) { var d = temp % 10 ; temp = parseInt ( temp / 10 ) ; if ( d > 0 && n % d == 0 && prime [ d ] ) count ++ ; } return count ; }
function minSum ( arr , n ) { arr . sort ( ) ; let x = arr [ Math . floor ( n / 2 ) ] ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += Math . abs ( arr [ i ] - x ) ; return sum ; }
function sphereSide ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var R = ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) / 2 ; return R ; }
function checkValidPolygon ( arr , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function printSubstrings ( str ) { var n = str . length ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { for ( var k = i ; k <= j ; k ++ ) { document . write ( str . charAt ( k ) ) ; } document . write ( " " ) ; } } }
function isPower ( x , y ) { var res1 = parseInt ( Math . log ( y ) ) / parseInt ( Math . log ( x ) ) ; var res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
function max_sum ( a , n ) { var dp = Array ( n + 1 ) . fill ( ) . map ( ( ) => Array ( 2 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; }
function path_to_root ( node ) { while ( node >= 1 ) { document . write ( node + " " ) ; node = parseInt ( node / 2 , 10 ) ; } }
function Survives ( n ) { let i ; for ( let i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= parseInt ( n / i ) ; } }
function printThreeParts ( N ) { if ( N % 3 == 0 ) document . write ( " " + ( N - 2 ) ) ; else document . write ( " " + ( N - 3 ) ) ; }
function intersection ( n ) { return n * ( n - 1 ) ; }
function calculateSum ( arr , n ) { if ( n == 0 ) return 0 ; let s = arr [ 0 ] ; let value = parseInt ( s ) ; let sum = value ; for ( let i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = parseInt ( s ) ; let operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' ' ) sum += value ; else sum -= value ; } return sum ; }
function count_pairs ( arr , brr , N , M , K ) { let i = 0 ; let j = 0 ; let cntPairs = 0 ; ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; ( brr ) . sort ( function ( a , b ) { return a - b ; } ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
function isSortedArray ( arr , n ) { var l = 0 var r = ( n - 1 ) while ( ( l + 1 ) < r ) { if ( arr [ l ] >= Math . max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= Math . max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l += 1 r -= 1 } else return false } return true }
function strScore ( str , s , n ) { let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) m . set ( str [ i ] , i + 1 ) ; if ( ! m . has ( s ) ) return 0 ; let score = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) score += s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ; score = score * m . get ( s ) ; return score ; }
function findDivisor ( x , y ) { if ( x == y ) return y ; return 2 ; }
function swap ( xp , yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
function nDigitPerfectCubes ( n ) { document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n - 1 ) ) ) ) , 3 ) + " " ) ; document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ) ; }
function isEven ( n ) { let isEven = true ; for ( let i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
function differentStrings ( s ) { var n = s . length ; var dp = Array ( n + 1 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] && ( s [ i ] == ' ' s [ i ] == ' ' ) ) dp [ i + 1 ] = dp [ i ] + dp [ i - 1 ] ; else dp [ i + 1 ] = dp [ i ] ; } document . write ( dp [ n ] + " " ) ; }
function unique ( s ) { for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { return false ; } } return true ; } if ( unique ( " " ) == true ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function minIndex ( arr , n , pos ) { var num = arr [ pos ] ; var i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
function pairStar ( input , i ) { output = output + input [ i ] ; if ( i == input . length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' ' ; pairStar ( input , i + 1 ) ; }
function findMinSoln ( n , k ) { var minSoln = 1000000000 ; for ( var i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = Math . min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; }
function rangeSum ( arr , N , L , R ) { let prefix = new Array ( N + 1 ) ; prefix [ 0 ] = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } let leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; let rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; document . write ( rightsum - leftsum ) ; }
function checkSequence ( a , b ) { if ( b . length == 0 ) return true ; if ( a . length == 0 ) return false ; if ( a [ 0 ] == b [ 0 ] ) return checkSequence ( a . substring ( 1 ) , b . substring ( 1 ) ) ; else return checkSequence ( a . substring ( 1 ) , b ) ; }
function printLargest ( a , n ) { let max = - 1 ; let ind = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let num = a [ i ] ; while ( num > 0 ) { let r = num % 10 ; num = Math . floor ( num / 10 ) ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( let i = ind ; i < n ; i ++ ) document . write ( a [ i ] ) ; for ( let i = 0 ; i < ind ; i ++ ) document . write ( a [ i ] ) ; }
function countPairs ( arr , n ) { let ans = 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; let left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
function checkSentence ( str ) { var len = str . length ; if ( str [ 0 ] . charCodeAt ( 0 ) < " " . charCodeAt ( 0 ) || str [ 0 ] . charCodeAt ( 0 ) > " " . charCodeAt ( 0 ) ) return false ; if ( str [ len - 1 ] !== " " ) return false ; var prev_state = 0 , curr_state = 0 ; var index = 1 ; while ( index <= str . length ) { if ( str [ index ] . charCodeAt ( 0 ) >= " " . charCodeAt ( 0 ) && str [ index ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) curr_state = 0 ; else if ( str [ index ] === " " ) curr_state = 1 ; else if ( str [ index ] . charCodeAt ( 0 ) >= " " . charCodeAt ( 0 ) && str [ index ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) curr_state = 2 ; else if ( str [ index ] === " " ) curr_state = 3 ; if ( prev_state === curr_state && curr_state !== 2 ) return false ; if ( prev_state === 2 && curr_state === 0 ) return false ; if ( curr_state === 3 && prev_state !== 1 ) return index + 1 == str . length ; index ++ ; prev_state = curr_state ; } return false ; } var str = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , ] ; var str_size = str . length ; var i = 0 ; for ( i = 0 ; i < str_size ; i ++ ) { var temp = str [ i ] . split ( " " ) ; if ( checkSentence ( temp ) ) document . write ( ' ' + str [ i ] + ' ' + " " + " " ) ; else document . write ( ' ' + str [ i ] + ' ' + " " + " " ) ; }
function minimumSwaps ( arr ) { let count = 0 ; let i = 0 ; while ( i < arr . length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { let temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; }
function sameEulerTotient ( N ) { return ( N & 1 ) ; }
function countPairs ( n ) { if ( n == 2 ) return 4 ; let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = n - max ; return count ; }
function polynomialRollingHash ( str ) { let p = 31 ; let m = ( 1e9 + 9 ) ; let power_of_p = 1 ; let hash_val = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { hash_val = ( hash_val + ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
function findPartition ( arr , n ) { var sum = 0 ; var i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; var part = Array ( parseInt ( sum / 2 ) + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ; for ( i = 1 ; i <= parseInt ( sum / 2 ) ; i ++ ) part [ i ] [ 0 ] = false ; for ( i = 1 ; i <= parseInt ( sum / 2 ) ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } } return part [ parseInt ( sum / 2 ) ] [ n ] ; }
function octahedral_num ( n ) { return n * ( 2 * n * n + 1 ) / 3 ; }
function rearrange ( arr , n ) { if ( arr == null n % 2 == 1 ) return ; let currIdx = Math . floor ( ( n - 1 ) / 2 ) ; while ( currIdx > 0 ) { let count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { let temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } }
function decToHexa ( n ) { var hexaDeciNum = Array . from ( { length : 100 } , ( _ , i ) => 0 ) ; var i = 0 ; while ( n != 0 ) { var temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = String . fromCharCode ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = String . fromCharCode ( temp + 55 ) ; i ++ ; } n = parseInt ( n / 16 ) ; } for ( j = i - 1 ; j >= 0 ; j -- ) document . write ( hexaDeciNum [ j ] ) ; }
function findTriangle ( a , n ) { let b = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { b [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; a . sort ( function ( i , j ) { return i - j ; } ) ; b . sort ( function ( i , j ) { return i - j ; } ) ; let x = 0 , y = 0 , z = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let p = i + 1 ; let q = i + 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . max ( p - j , 0 ) ; z += q - p ; } } } document . write ( " " + x + " " ) ; document . write ( " " + y + " " ) ; document . write ( " " + z + " " ) ; }
function twoEggDrop ( k ) { return Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
function prefixOccurrences ( str ) { var c = str . charAt ( 0 ) ; var countc = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) == c ) countc ++ ; } return countc ; }
function make_permutation ( arr , n ) { arr . sort ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += Math . abs ( i + 1 - arr [ i ] ) ; return ans ; }
function getBit ( num , i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }
function setallbitgivenrange ( n , l , r ) { let range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
function maxSubmatrixSum ( matrix ) { var r = matrix . length ; var c = matrix [ 0 ] . length ; var maxSubmatrix = 0 ; for ( i = 0 ; i < r ; i ++ ) { for ( j = 0 ; j < c ; j ++ ) { for ( k = i ; k < r ; k ++ ) { for ( l = j ; l < c ; l ++ ) { var sumSubmatrix = 0 ; for ( m = i ; m <= k ; m ++ ) { for ( n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m ] [ n ] ; } } maxSubmatrix = Math . max ( maxSubmatrix , sumSubmatrix ) ; } } } } document . write ( maxSubmatrix ) ; }
function maxHandshake ( n ) { return ( n * ( n - 1 ) ) / 2 ; }
function sumArray ( arr , n ) { let leftSum = new Array ( n ) ; let rightSum = new Array ( n ) ; let Sum = new Array ( n ) ; let i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) document . write ( Sum [ i ] + " " ) ; }
function findDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 , max_count = 0 , min_count = n ; for ( let i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
function FindPoint ( x1 , y1 , x2 , y2 , x , y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
function maximumXOR ( arr , n , K ) { K ++ ; let maxXor = Number . MIN_SAFE_INTEGER ; for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { if ( ( i ) . toString ( 2 ) . split ( ' ' ) . filter ( x => x == ' ' ) . length == K ) { let cur_xor = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) cur_xor = cur_xor ^ arr [ j ] ; } maxXor = Math . max ( maxXor , cur_xor ) ; } } return maxXor ; }
function solve ( A , B , C ) { let i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; let min_diff , current_diff , max_term ; min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
function findMinSum ( a , b , n ) { a . sort ( ) ; b . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
function max_valid_triplet ( A , n ) { let ans = - 1 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { let value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } document . write ( ans ) ; }
function find ( N , a , b ) { let probability = 0.0 ; for ( let i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = ( 1.0 / 6 ) ; for ( let i = 2 ; i <= N ; i ++ ) { for ( let j = i ; j <= 6 * i ; j ++ ) { for ( let k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( let sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; }
function smallest ( s ) { let l = s . length ; let ans = " " ; for ( let i = 0 ; i < l - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) { for ( let j = 0 ; j < l ; j ++ ) { if ( i != j ) { ans += s [ j ] ; } } return ans ; } } ans = s . substring ( 0 , l - 1 ) ; return ans ; }
function find ( n , k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
function firstNonRepeating ( str ) { let NO_OF_CHARS = 256 ; let arr = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( arr [ str [ i ] . charCodeAt ( 0 ) ] == - 1 ) arr [ str [ i ] . charCodeAt ( 0 ) ] = i ; else arr [ str [ i ] . charCodeAt ( 0 ) ] = - 2 ; } let res = Number . MAX_VALUE ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = Math . min ( res , arr [ i ] ) ; return res ; }
function countPairs ( a , n , k ) { a . sort ( ( a , b ) => a - b ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
function countSticks ( str ) { var cnt = 0 ; for ( var i = 0 ; str [ i ] ; i ++ ) { var ch = str [ i ] ; if ( ch >= ' ' && ch <= ' ' ) { cnt += sticks [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ; } else { cnt += number [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ; } } return cnt ; }
function findProduct ( arr , n ) { arr . sort ( ) ; var prod = 1 * arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; }
function removeRecur ( n ) { let prev_digit = n % 10 ; let pow = 10 ; let res = prev_digit ; while ( n > 0 ) { let curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = parseInt ( n / 10 , 10 ) ; } return res ; }
function fib ( n ) { let a = 0 , b = 1 , c ; if ( n >= 0 ) document . write ( a + " " ) ; if ( n >= 1 ) document . write ( b + " " ) ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; document . write ( c + " " ) ; a = b ; b = c ; } }
function nextPowerOfFour ( n ) { let x = Math . floor ( Math . sqrt ( Math . sqrt ( n ) ) ) ; if ( Math . pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return Math . pow ( x , 4 ) ; } }
function countBT ( h ) { let dp = new Array ( h + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
function missingNumber ( arr1 , arr2 , n ) { let mnum = 0 ; for ( let i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
function findMin ( arr , low , high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
function summation ( N ) { var co = parseInt ( ( N + 1 ) / 2 ) ; var ce = parseInt ( ( N ) / 2 ) ; var se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; var so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
function countMinReversals ( expr ) { var len = expr . length ; if ( len % 2 ) return - 1 ; var ans = 0 ; var i ; var open = 0 ; var close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' ' ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; }
function XorSum ( A , B , N ) { var ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; }
function minOperations ( A , n ) { if ( ( n & 1 ) > 0 ) return - 1 ; let zeros = 0 , consZeros = 0 , ones = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }
function nthTerm ( n ) { return ( n * n ) + ( n * n * n ) ; }
function MaxProfit ( arr , n , transactionFee ) { let buy = - arr [ 0 ] ; let sell = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let temp = buy ; buy = Math . max ( buy , sell - arr [ i ] ) ; sell = Math . max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . max ( sell , buy ) ; }
function minCost ( s , n ) { var minValue = 100000000 ; for ( var i = 0 ; i <= 25 ; i ++ ) { var cnt = 0 ; for ( var j = 0 ; j < n ; j ++ ) { cnt += Math . min ( Math . abs ( i - ( s [ j ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ) ) , 26 - Math . abs ( i - ( s [ j ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ) ) ) ; } minValue = Math . min ( minValue , cnt ) ; } return minValue ; }
function counLastDigitK ( low , high , k ) { let mlow = 10 * ( Math . ceil ( low / 10.0 ) ) ; let mhigh = 10 * ( Math . floor ( high / 10.0 ) ) ; let count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; }
function DivisibleBy41 ( first , second , c , n ) { let digit = new Array ( n ) . fill ( 0 ) ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( let i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; let ans = digit [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
function generateStr ( a , b , s , count , len ) { if ( count == len ) { document . write ( s + " " ) ; return ; } generateStr ( a . substring ( 1 ) , b . substring ( 1 ) , s + a [ 0 ] , count + 1 , len ) ; generateStr ( a . substring ( 1 ) , b . substring ( 1 ) , s + b [ 0 ] , count + 1 , len ) ; }
function ways ( n ) { var first = 2 ; var second = 3 ; var res = 0 ; for ( i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
function maxDivisions ( arr , N , X ) { arr . sort ( ) ; let maxSub = 0 ; let size = 0 ; for ( let i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } document . write ( maxSub + " " ) ; }
function HogbenNumber ( a ) { let p = ( Math . pow ( a , 2 ) - a + 1 ) ; return p ; }
function countPairs ( A , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } document . write ( count ) ; }
function nthprimedigitsnumber ( number ) { let rem ; let num = " " ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += ' ' ; break ; case 2 : num += ' ' ; break ; case 3 : num += ' ' ; break ; case 0 : num += ' ' ; break ; } if ( number % 4 == 0 ) number -- ; number = parseInt ( number / 4 , 10 ) ; } let st = num . split ( ' ' ) ; st . reverse ( ) ; return ( st . join ( " " ) ) ; }
function push ( new_data ) { var new_node = new Node ( new_data ) ; new_node . next = head ; head = new_node ; }
function occurredOnce ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; if ( arr [ 0 ] != arr [ 1 ] ) document . write ( arr [ 0 ] + " " ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) document . write ( arr [ i ] + " " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) document . write ( arr [ n - 1 ] + " " ) ; }
function findMinRec ( A , n ) { if ( n == 1 ) return A [ 0 ] ; return Math . min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
function checkIfCurzonNumber ( N ) { var powerTerm , productTerm ; powerTerm = Math . pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) { document . write ( " " + " " ) ; } else { document . write ( " " ) ; } }
function isMajority ( arr , n , x ) { let i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? parseInt ( n / 2 , 10 ) : parseInt ( n / 2 , 10 ) + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + parseInt ( n / 2 , 10 ) ] == x ) return true ; } return false ; }
function vertices ( N , A , B ) { var position = 0 ; var minisum = Number . MAX_VALUE ; var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { var x = Math . abs ( i - A ) ; var y = Math . abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
function findCnt ( arr , i , curr , n , m ) { if ( i == n ) { return ( curr == m ) ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i ] [ curr ] ; }
function minOperations ( n , m ) { var a = 0 , k = 1 ; var p = Math . max ( n , m ) ; while ( n != m ) { var s = ( p - n + p - m ) ; var q = ( ( - 1 + Math . sqrt ( 8 * s + 1 ) ) / 2 ) ; if ( q - Math . floor ( q ) == 0 ) { a = parseInt ( q ) ; n = m ; } p = p + 1 ; } return a ; }
function lastFiveDigits ( n ) { n = ( Math . floor ( n / 10000 ) ) * 10000 + ( Math . floor ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( Math . floor ( n / 10 ) % 10 ) * 10 + Math . floor ( n / 1000 ) % 10 ; let ans = 1 ; for ( let i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } document . write ( ans ) ; }
function Length_Diagonal ( a , b , d ) { let diagonal = Math . sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; }
function rmsValue ( arr , n ) { var square = 0 ; var mean = 0 ; var root = 0 ; for ( i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( n ) ) ; root = Math . sqrt ( mean ) ; return root ; }
function maxArea ( A , len ) { let area = 0 ; for ( let i = 0 ; i < len ; i ++ ) { for ( let j = i + 1 ; j < len ; j ++ ) { area = Math . max ( area , Math . min ( A [ j ] , A [ i ] ) * ( j - i ) ) ; } } return area ; }
function isValidSeq ( a , n ) { var nodes = n + 2 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 a [ i ] > nodes ) return false ; } return true ; }
function findAngles ( a , b , c , d ) { var numerator = a * a + d * d - b * b - c * c var denominator = 2 * ( a * b + c * d ) var x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; document . write ( " " ) ; numerator = a * a + b * b - c * c - d * d x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; document . write ( " " ) ; numerator = c * c + b * b - a * a - d * d x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; document . write ( " " ) ; numerator = d * d + c * c - a * a - b * b x = numerator / denominator document . write ( " " , Math . round ( ( ( Math . acos ( x ) * 180 ) / 3.141592 ) * 100 ) / 100.0 , " " ) ; }
function lenoflongestnonpalindrome ( s ) { let max1 = 1 , len = 0 ; for ( let i = 0 ; i < s . length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) len = 0 ; else if ( s [ i + 1 ] == s [ i - 1 ] && i > 0 ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
function incrementCount ( arr , N ) { let mini = arr [ 0 ] - arr [ 1 ] ; for ( let i = 2 ; i < N ; i ++ ) { mini = Math . min ( mini , arr [ i - 1 ] - arr [ i ] ) ; } document . write ( mini ) ; }
function genSequence ( n , val ) { for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { let x = i ^ ( i >> 1 ) ^ val ; document . write ( x + " " ) ; } }
function maxValueAtIndexK ( N , K , M ) { let S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; let X = ( M + S1 + S2 ) / N ; document . write ( X ) ; }
function cntSubSeq ( arr , n ) { let pos_count = 0 ; let neg_count = 0 ; let result ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }
function getMin ( arr , n ) { var minVal = Math . min . apply ( Math , arr ) ; return minVal ; }
function countkDist ( str , k ) { var res = 0 ; var n = str . length ; var cnt = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < n ; i ++ ) { var dist_count = 0 ; for ( j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
function performQuery ( arr , Q ) { for ( let i = 0 ; i < Q . length ; i ++ ) { let or = 0 ; let x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( let j = 0 ; j < arr . length ; j ++ ) { or = or | arr [ j ] ; } document . write ( or + " " ) ; } }
function areaSquare ( side , fold ) { var area = side * side ; return ( area * 1.0 ) / ( Math . pow ( 2 , fold ) ) ; }
function cyl ( r , R , h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; var r1 = r ; var h1 = h ; var V = ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; }
function SquareRoot ( num ) { let count = 0 ; for ( let n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; }
function getTime ( u , v , x ) { let speed = u + v ; let time = x / speed ; return time ; }
function waysOfDecoding ( s ) { let dp = new Array ( s . length + 1 ) ; for ( let i = 0 ; i < s . length + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' ' ? 9 : s [ 0 ] == ' ' ? 0 : 1 ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != ' ' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' && s [ i ] <= ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= ' ' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ s . length ] ; }
function round ( n ) { let a = parseInt ( n / 10 , 10 ) * 10 ; let b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
function smallestNumber ( N ) { document . write ( N * parseInt ( Math . ceil ( Math . pow ( 2 , ( N - 1 ) ) / N ) ) ) ; }
function sum_of_series ( n ) { var result = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - parseInt ( Math . pow ( i , 2 ) ) ; else result = result + parseInt ( Math . pow ( i , 2 ) ) ; } return result ; }
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
function findXor ( arr , n ) { let xoR = 0 ; for ( let i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
function nthXorFib ( n , a , b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }
function findValue ( X , Y , P ) { if ( P % 2 == 0 ) return parseInt ( ( Math . max ( X , Y ) / Math . min ( X , Y ) ) , 10 ) ; else return parseInt ( ( Math . max ( 2 * X , Y ) / Math . min ( 2 * X , Y ) ) , 10 ) ; }
function Area_of_Triangle ( a , b , c ) { var s = ( a + b + c ) / 2 ; var x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; var area = ( 4 / 3 ) * Math . sqrt ( x ) ; return area ; }
function find_Area ( a ) { var R = a * ( 2.0 - Math . sqrt ( 2 ) ) ; var area = 3.14 * R * R / 2.0 ; return area ; }
function mulsum ( arr , n , N ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } document . write ( sum ) ; }
function kthNonDivisible ( N , K ) { return K + parseInt ( Math . floor ( ( K - 1 ) / ( N - 1 ) ) , 10 ) ; }
function concentric_Haxagon ( n ) { return parseInt ( 3 * Math . pow ( n , 2 ) / 2 ) ; }
function check ( arr , n ) { var count = 0 ; var index = - 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) { count ++ ; index = i ; } } if ( count > 1 ) return false ; if ( count == 0 ) return true ; if ( index == n - 1 index == 1 ) return true ; if ( arr [ index - 1 ] < arr [ index + 1 ] ) return true ; if ( arr [ index - 2 ] < arr [ index ] ) return true ; return false ; }
function SternSequenceFunc ( BrocotSequence , n ) { for ( var i = 1 ; BrocotSequence . length < n ; i ++ ) { var considered_element = BrocotSequence [ i ] ; var precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push ( considered_element + precedent ) ; BrocotSequence . push ( considered_element ) ; } for ( var i = 0 ; i < 15 ; ++ i ) document . write ( BrocotSequence [ i ] + " " ) ; }
function countWords ( str ) { var state = OUT ; var wc = 0 ; var i = 0 ; while ( i < str . length ) { if ( str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }
function oppositeFaceOfDice ( N ) { let ans = 7 - N ; document . write ( ans ) ; }
function getOddOccurrence ( arr , arr_size ) { for ( let i = 0 ; i < arr_size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
function count_Strings ( n ) { var x = 1 ; for ( i = 1 ; i < n ; i ++ ) { x = ( 1 << x ) ; } return x - 1 ; }
function countNumbers ( l , r ) { return ( parseInt ( r / 6 ) - parseInt ( ( l - 1 ) / 6 ) ) ; }
function multiplyTen ( n ) { return ( n << 1 ) + ( n << 3 ) ; }
function newvol ( x ) { document . write ( " " + " " + x + " " ) ; }
function icosikaiheptagonalNum ( n ) { return ( 25 * n * n - 23 * n ) / 2 ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 3 * n - 5 ; }
function findOptimalPairs ( arr , N ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( var i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; }
function area ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var A = a * b ; return A ; }
function prletNthElement ( n ) { let arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }
function isWordPresent ( sentence , word ) { let s = sentence . split ( " " ) ; for ( let temp = 0 ; temp < s . length ; temp ++ ) { if ( s [ temp ] == ( word ) ) { return true ; } } return false ; }
function solve ( n , d , input ) { let a = new Array ( N ) ; let cnt = new Array ( V + 1 ) ; for ( let i = 0 ; i < n ; ++ i ) a [ i ] = input [ i ] ; let answer = 0 ; for ( let i = 0 ; i < d ; ++ i ) cnt [ a [ i ] ] ++ ; for ( let i = d ; i <= n - 1 ; ++ i ) { let acc = 0 ; let low_median = - 1 , high_median = - 1 ; for ( let v = 0 ; v <= V ; ++ v ) { acc += cnt [ v ] ; if ( low_median == - 1 && acc >= parseInt ( Math . floor ( ( d + 1 ) / 2.0 ) ) ) low_median = v ; if ( high_median == - 1 && acc >= parseInt ( Math . ceil ( ( d + 1 ) / 2.0 ) ) ) high_median = v ; } let double_median = low_median + high_median ; if ( a [ i ] >= double_median ) answer ++ ; cnt [ a [ i - d ] ] -- ; cnt [ a [ i ] ] ++ ; } document . write ( answer ) ; }
function minimumCost ( arr , cost , N ) { var dp = Array ( N ) . fill ( ) . map ( ( ) => Array ( 3 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = cost [ 0 ] ; dp [ 0 ] [ 2 ] = cost [ 0 ] * 2 ; for ( i = 1 ; i < N ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { var minimum = parseInt ( 1e6 ) ; if ( j + arr [ i ] != arr [ i - 1 ] ) minimum = Math . min ( minimum , dp [ i - 1 ] [ 0 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 1 ) minimum = Math . min ( minimum , dp [ i - 1 ] [ 1 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 2 ) minimum = Math . min ( minimum , dp [ i - 1 ] [ 2 ] ) ; dp [ i ] [ j ] = j * cost [ i ] + minimum ; } } var ans = parseInt ( 1e6 ) ; for ( i = 0 ; i < 3 ; i ++ ) ans = Math . min ( ans , dp [ N - 1 ] [ i ] ) ; document . write ( ans + " " ) ; }
function distance ( r , R ) { let d = Math . sqrt ( Math . pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
function CtSubarr ( arr , N , K ) { var st = new Set ( ) ; var prefixSum = 0 ; st . add ( prefixSum ) ; var res = 0 ; for ( var i = 0 ; i < N ; i ++ ) { prefixSum += arr [ i ] ; if ( st . has ( prefixSum - K ) ) { res += 1 ; prefixSum = 0 ; st = new Set ( ) ; st . add ( 0 ) ; } st . add ( prefixSum ) ; } return res ; }
function shuffle ( N , key ) { let NO_OF_BITS = N ; let reverse_num = 0 , temp ; for ( let i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } document . write ( reverse_num ) ; }
function nextFibonacci ( n ) { let a = n * ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; return Math . round ( a ) ; }
function nthOdd ( n ) { return ( 2 * n - 1 ) ; }
function findpair ( l , r ) { let ans1 = l ; let ans2 = 2 * l ; document . write ( ans1 + " " + ans2 ) ; }
function isCenteredtridecagonal ( N ) { let n = ( 13 + Math . sqrt ( 104 * N + 65 ) ) / 26 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 14 ; if ( isCenteredtridecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function printNumber ( N , K , M ) { var sum = K * ( ( M * ( M + 1 ) ) / 2 ) ; return sum - N ; }
function minSteps ( N ) { var res = parseInt ( ( Math . sqrt ( 1 + 8 * N ) - 1 ) / 2 ) ; return res ; }
function sumOfSeries ( x , k ) { var y = ( ( ( x ) / 81 ) * ( 9 * k - 1 + Math . pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }
function findEquation ( A , B , C , K ) { document . write ( A + " " + K * B + " " + K * K * C ) ; }
function steps ( source , step , dest ) { if ( Math . abs ( source ) > ( dest ) ) return Number . MAX_SAFE_INTEGER ; if ( source == dest ) return step ; let pos = steps ( source + step + 1 , step + 1 , dest ) ; let neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . min ( pos , neg ) ; }
function xorOfArray ( arr , n ) { let xor_arr = 0 ; for ( let i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }
function solve ( N , M , cp , sp ) { let profit = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; profit . sort ( function ( a , b ) { return b - a ; } ) ; let sum = 0 ; for ( let i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
function minOperations ( N ) { var x = Math . log ( N ) / Math . log ( 2 ) ; var ans = parseInt ( ( Math . ceil ( x ) ) ) ; return ans ; }
function isTrimorphic ( N ) { let cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N = parseInt ( N / 10 , 10 ) ; cube = parseInt ( cube / 10 , 10 ) ; } return true ; }
function asciiToSentence ( str , len ) { var num = 0 ; for ( var i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - ' ' ) ; if ( num >= 32 && num <= 122 ) { var ch = String . fromCharCode ( num ) ; document . write ( ch ) ; num = 0 ; } } }
function countWays ( N ) { if ( N == 1 ) return 4 ; let countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( let i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } let result = countS + countB ; return ( result * result ) ; }
function squares ( l , b , a ) { return parseInt ( Math . ceil ( l / a ) * Math . ceil ( b / a ) ) ; }
function findMinDiff ( arr , n , m ) { if ( m == 0 n == 0 ) return 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; if ( n < m ) return - 1 ; let min_diff = Number . MAX_VALUE ; for ( let i = 0 ; i + m - 1 < n ; i ++ ) { let diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
function squareArea ( a ) { if ( a < 0 ) return - 1 ; var area = ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; }
function countSetBits ( n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
function findDistinctSums ( N ) { return ( 2 * N - 1 ) ; }
function FindTrip ( arr , N ) { for ( let i = 1 ; i < N - 1 ; i ++ ) { let p = arr [ i - 1 ] ; let q = arr [ i ] ; let r = arr [ i + 1 ] ; if ( p < q && q > r ) { document . write ( ( i - 1 ) + " " + ( i ) + " " + ( i + 1 ) ) ; return ; } } document . write ( - 1 ) ; }
function sum ( n ) { let root = parseInt ( Math . sqrt ( n ) ) ; let ans = 0 ; for ( let i = 1 ; i <= root ; i ++ ) ans += parseInt ( n / i ) ; ans = ( 2 * ans ) - ( root * root ) ; return ans ; }
function titleToNumber ( s ) { let result = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { result *= 26 ; result += s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ; } return result ; }
function isPentadecagon ( N ) { var n = ( 11 + Math . sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - parseInt ( n ) ) == 0 ; } var N = 15 ; if ( isPentadecagon ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function minJumps ( arr , n ) { if ( n == 1 ) return 0 ; let res = Number . MAX_VALUE ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { let sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != Number . MAX_VALUE ) res = Math . min ( res , sub_res + 1 ) ; } } return res ; }
function make_String_S_to_T ( S , T ) { var possible = false ; var M = T . length ; var N = S . length ; for ( i = 0 ; i <= M ; i ++ ) { var prefix_length = i ; var suffix_length = M - i ; var prefix = S . substring ( 0 , prefix_length ) ; var suffix = S . substring ( N - suffix_length , N ) ; if ( ( prefix + suffix ) == ( T ) ) { possible = true ; break ; } } if ( possible ) return " " ; else return " " ; }
function complement ( num ) { var i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = parseInt ( num / 10 ) ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = parseInt ( Math . pow ( 10 , len ) - num ) ; return comp ; }
function isenneadecagonal ( N ) { let n = parseFloat ( 15 + Math . sqrt ( 136 * N + 225 ) ) / 34 ; return ( n - parseInt ( n ) ) == 0 } let N = 19 ; if ( isenneadecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function replaceOriginal ( s , n ) { var r = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' && s . charAt ( i ) != ' ' ) { document . write ( r [ i ] ) ; } } document . write ( " " ) ; }
function minCost ( arr ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } document . write ( Math . min ( even , odd ) ) ; }
function numPairs ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; }
function longestCommonPrefix ( a ) { let size = a . length ; if ( size == 0 ) return " " ; if ( size == 1 ) return a [ 0 ] ; a . sort ( ) ; let end = Math . min ( a [ 0 ] . length , a [ size - 1 ] . length ) ; let i = 0 ; while ( i < end && a [ 0 ] [ i ] == a [ size - 1 ] [ i ] ) i ++ ; let pre = a [ 0 ] . substring ( 0 , i ) ; return pre ; }
function prodSquare ( n ) { var s = new Map ( ) ; for ( var i = 2 ; i * i <= n ; ++ i ) { s . set ( i * i , 1 ) ; if ( s . has ( n / ( i * i ) ) ) return true ; } return false ; }
function findSubarrays ( arr , N , K ) { return N - K + 1 ; }
function bankNotes ( A , B , S , N ) { let numerator = S - ( B * N ) ; let denominator = A - B ; if ( numerator % denominator == 0 ) return ( Math . floor ( numerator / denominator ) ) ; return - 1 ; }
function search ( arr , n , x ) { let i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } document . write ( " " ) ; return - 1 ; }
function findN ( k ) { var ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
function getAverage ( x , y ) { var avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
function printTetra ( n ) { if ( n < 0 ) return ; var first = 0 , second = 1 ; var third = 1 , fourth = 2 ; var curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( var i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } document . write ( curr ) ; } }
function maxLitres ( budget , plastic , glass , refund ) { if ( glass - refund < plastic ) { let ans = Math . max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += Math . floor ( budget / plastic ) ; document . write ( ans ) ; } else { document . write ( Math . floor ( budget / plastic ) ) ; } }
function heptdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.802 * a ; return d ; }
function isFibbinaryNum ( n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
function minCount ( A , B , N ) { var i = 0 for ( let j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) i += 1 } return N - i }
function maxbalancedprefix ( str , n ) { var sum = 0 ; var maxi = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
function DecreasingArray ( a , n ) { var sum = 0 , dif = 0 ; var pq = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( pq . length != 0 && pq [ pq . length - 1 ] < a [ i ] ) { dif = a [ i ] - pq [ pq . length - 1 ] ; sum += dif ; pq . pop ( ) ; } pq . push ( a [ i ] ) ; pq . sort ( ( a , b ) => b - a ) ; } return sum ; }
function previousFibonacci ( n ) { var a = n / ( ( 1 + Math . sqrt ( 5 ) ) / 2 ) ; return Math . round ( a ) ; }
function LeadingZeros ( x , y ) { if ( ( x ^ y ) <= ( x & y ) ) document . write ( " " ) ; else if ( ( x & ( ~ y ) ) > y ) document . write ( y ) ; else document . write ( x ) ; }
function cal ( n ) { var res = Math . pow ( Math . ceil ( ( Math . pow ( Math . pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return parseInt ( res ) ; }
function isnonagonal ( N ) { let n = ( 5 + Math . sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 9 ; if ( isnonagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
function maximum_inversion ( n , k ) { var answer = 0 ; k = Math . min ( k , parseInt ( n / 2 ) ) ; var left = 1 ; var right = n ; while ( k > 0 ) { k -- ; answer += 2 * ( right - left ) - 1 ; left ++ ; right -- ; } document . write ( answer + " " ) ; }
function merge_and_sort ( output , arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i ] [ j ] ; } } output . sort ( function ( a , b ) { return a - b } ) ; }
function getSetBitsFromOneToN ( N ) { var two = 2 var ans = 0 var n = N while ( n != 0 ) { ans += Math . floor ( N / two ) * ( two >> 1 ) if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 two <<= 1 ; n >>= 1 ; } return ans }
function isInteger ( N ) { let X = Math . floor ( N ) ; let temp2 = N - X ; if ( temp2 > 0 ) { return false ; } return true ; } let N = 1.5 ; if ( isInteger ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function checkPalindromeB ( N , B ) { var rev = 0 ; var N1 = N ; while ( N1 ) { rev = rev * B + N1 % B ; N1 = parseInt ( N1 / B ) ; } return N == rev ; } var N = 5 , B = 2 ; if ( checkPalindromeB ( N , B ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function findSum ( L , R ) { var arr = [ ] ; var i = 0 ; var x = 2 ; while ( i <= R ) { arr . push ( i + x ) ; if ( i + 1 <= R ) arr . push ( i + 1 + x ) ; x *= - 1 ; i += 2 ; } var sum = 0 ; for ( var i = L ; i <= R ; ++ i ) sum += arr [ i ] ; return sum ; }
function twoWaySort ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
function checkSuffix ( A , B ) { let s1 = A . toString ( ) ; let s2 = B . toString ( ) ; let result ; result = s1 . endsWith ( s2 ) ; if ( result ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function getResult ( n ) { let st = n . toString ( ) ; for ( let i = 0 ; i < st . length ; i ++ ) { let d = st [ i ] . charCodeAt ( 0 ) - 48 ; if ( n % d == 0 ) { return " " ; } } return " " ; }
function countNumbers ( N ) { return parseInt ( Math . sqrt ( N ) , 10 ) - 1 ; }
function area_cicumscribed ( c ) { return ( c * c * ( PI / 4 ) ) ; }
function printLines ( n , k ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( k * ( 6 * i + 1 ) + " " + k * ( 6 * i + 2 ) + " " + k * ( 6 * i + 3 ) + " " + k * ( 6 * i + 5 ) + " " ) ; } }
function findCnt ( arr , n , k ) { var ret = 0 ; var i = 0 ; while ( i < n ) { var j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; var x = Math . max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }
function Kroneckerproduct ( A , B ) { let C = new Array ( rowa * rowb ) for ( let i = 0 ; i < ( rowa * rowb ) ; i ++ ) { C [ i ] = new Array ( cola * colb ) ; for ( let j = 0 ; j < ( cola * colb ) ; j ++ ) { C [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < rowa ; i ++ ) { for ( let k = 0 ; k < rowb ; k ++ ) { for ( let j = 0 ; j < cola ; j ++ ) { for ( let l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; document . write ( C [ i + l + 1 ] [ j + k + 1 ] + " " ) ; } } document . write ( " " ) ; } } }
function check ( arr , N ) { let even = 0 ; let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) document . write ( " " ) ; else document . write ( " " ) ; }
function minSum ( A , B , C , i , n , curr , dp ) { if ( n <= 0 ) return 0 ; if ( dp [ n ] [ curr ] != - 1 ) return dp [ n ] [ curr ] ; if ( curr == 0 ) { return dp [ n ] [ curr ] = Math . min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; } let A = [ 1 , 50 , 1 ] ; let B = [ 50 , 50 , 50 ] ; let C = [ 50 , 50 , 50 ] ; let dp = new Array ( SIZE ) ; for ( let i = 0 ; i < SIZE ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }
function equvInverse ( arr , N , P ) { let cntElem = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; }
function processWords ( input ) { var s = input . split ( ' ' ) ; s . forEach ( element => { charBuffer += element [ 0 ] ; } ) ; return charBuffer ; }
function gonNum65537 ( n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; }
function maximumAND ( L , R ) { return R ; }
function maxWeight ( arr , n , w1_r , w2_r , i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; var fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; }
function get_subset_count ( arr , K , N ) { ( arr ) . sort ( function ( a , b ) { return a - b ; } ) ; let left , right ; left = 0 ; right = N - 1 ; let ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; }
function encryptString ( str , n ) { let i = 0 , cnt = 0 ; let encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; }
function NoCarrySum ( N , M ) { return N ^ M ; }
function isTriangular ( num ) { if ( num < 0 ) return false ; var c = ( - 2 * num ) ; var b = 1 , a = 1 ; var d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; var root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; var root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
function avg_of_odd_num ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
function getSum ( n ) { let isOdd = ( n % 2 == 1 ) ? true : false ; let sumOdd = 0 , sumEven = 0 ; while ( n != 0 ) { if ( isOdd ) sumOdd += n % 10 ; else sumEven += n % 10 ; isOdd = ! isOdd ; n = Math . floor ( n / 10 ) ; } document . write ( " " + sumOdd + " " ) ; document . write ( " " + sumEven ) ; }
function distance ( a1 , b1 , c1 , a2 , b2 , c2 ) { var d = a1 * a2 + b1 * b2 + c1 * c2 ; var e1 = Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; var e2 = Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = parseFloat ( d / ( e1 * e2 ) ) ; var pi = 3.14159 ; var A = ( 180 / pi ) * Math . acos ( d ) ; document . write ( " " + A . toFixed ( 1 ) + " " ) ; }
function solve ( n ) { var ans = ( n * n / 4 ) ; return ans ; }
function NimGame ( N , A , B ) { let sum = A + B ; if ( N % sum <= A - 1 ) return " " ; else return " " ; }
function countSolutions ( a ) { let count = 0 ; for ( let i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
function center ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + " " + ( y1 + y2 ) / 2 ) ; }
function angleextcycquad ( z ) { document . write ( " " + " " + z + " " ) ; }
function proizvolov ( a , b , n ) { return n * n ; }
function isPossible ( w , h , x , y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }
function quadrant ( s ) { var l = s . length ; var i = 0 ; if ( s . indexOf ( " " ) != - 1 ) { i = s . indexOf ( " " ) ; } else { i = s . indexOf ( " " ) ; } var real = s . substr ( 0 , i ) ; var imaginary = s . substr ( i + 1 , l - 1 ) ; var x = parseInt ( real ) ; var y = parseInt ( imaginary ) ; if ( x > 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y < 0 ) document . write ( " " ) ; else if ( x > 0 && y < 0 ) document . write ( " " ) ; else if ( x == 0 && y > 0 ) document . write ( " " + " " ) ; else if ( x == 0 && y < 0 ) document . write ( " " + " " ) ; else if ( y == 0 && x < 0 ) document . write ( " " + " " ) ; else if ( y == 0 && x > 0 ) document . write ( " " + " " ) ; else document . write ( " " ) ; }
function print ( n ) { document . write ( n + parseInt ( n / 2 ) + " " ) ; for ( i = 2 ; i <= n ; i += 2 ) document . write ( i + " " ) ; for ( i = 1 ; i <= n ; i += 2 ) document . write ( i + " " ) ; for ( i = 2 ; i <= n ; i += 2 ) document . write ( i + " " ) ; }
function innerCirclearea ( radius ) { if ( radius < 0 ) { return - 1 ; } let r = radius / 2 ; let Area = ( 3.14 * Math . pow ( r , 2 ) ) ; return Area ; }
function dfs ( val , cost , tr , u , s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( var i = 0 ; i < tr [ u ] . length ; i ++ ) { dfs ( val , cost , tr , tr [ u ] [ i ] , s ) ; } }
function countNumbers ( N ) { return ( Math . pow ( 10 , N ) - 1 ) - ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; }
function maxSumWO3Consec ( arr , n ) { let sum = [ ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( let i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
function centeredIcosahedralNum ( n ) { return parseInt ( ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ) ; }
function Alphabet_N_Pattern ( N ) { var index , side_index , size ; var Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { document . write ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * index ; side_index ++ ) document . write ( " " ) ; if ( index != 0 && index != N - 1 ) document . write ( Diagonal ++ ) ; else document . write ( " " ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) document . write ( " " ) ; document . write ( Right ++ ) ; document . write ( " " ) ; } }
function findNthTerm ( n ) { document . write ( n * ( 4 * n + 3 ) ) ; }
function cntElements ( arr , n ) { let copy_arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; let count = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }
function printPascal ( n ) { arr = a = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( line = 0 ; line < n ; line ++ ) { for ( i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; document . write ( arr [ line ] [ i ] ) ; } document . write ( " " ) ; } }
function arraySortedOrNot ( arr , n ) { if ( n == 0 n == 1 ) return true ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
function maxPrimefactorNum ( N ) { if ( N < 2 ) return 0 ; arr = Array . from ( { length : N + 1 } , ( _ , i ) => false ) ; var prod = 1 , res = 0 ; for ( var p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( var i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
function printElements ( arr , n ) { for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) document . write ( arr [ i ] + " " ) ; } }
function NicomachuTheorum_sum ( n ) { let sum = 0 ; for ( let k = 1 ; k <= n ; k ++ ) sum += k * k * k ; let triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) document . write ( " " ) ; else document . write ( " " ) ; }
function nthTerm ( n ) { return Math . pow ( n , 2 ) + 4 * n ; }
function checkEvenOdd ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
function PowerOFPINnfactorial ( n , p ) { let ans = 0 ; let temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } let N = 3 ; let flag , k , m = 0 ; if ( ( N == 1 ) || ( N == 2 ) ) document . write ( 62 ) ; else m = 1000000000 + 7 ; if ( N % 2 == 0 ) { k = N / 2 ; flag = 1 ; } else { k = ( N - 1 ) / 2 ; flag = 0 ; } if ( flag != 0 ) { let a = power ( 62 , k , m ) ; document . write ( a ) ; } else { let a = power ( 62 , ( k + 1 ) , m ) ; document . write ( a ) ; }
function pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }
function getResult ( st ) { let sum = 0 ; let length = st . length ; for ( let i = 0 ; i < length ; i ++ ) { sum = sum + Math . pow ( st [ i ] - ' ' , length ) ; } let number = parseInt ( st , 10 ) ; if ( number == sum ) return " " ; else return " " ; }
function countWaysToTileBoard ( N ) { let dp = [ ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( let i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } document . write ( dp [ N ] ) ; }
function flipsPossible ( a , n ) { let count_odd = 0 ; let count_even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }
function countTripletsLessThanL ( n , L , arr ) { arr . sort ( ) ; var ways = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { var mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
function countIncreasing ( n ) { let cnt = 0 ; let len = 1 ; for ( let i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
function getSingle ( arr , n ) { let result = 0 ; let x , sum ; for ( let i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
function topsyTurvy ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' ) { return false ; } } return true ; }
function minOps ( arr , n , k ) { var max = arr [ 0 ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
function pythagoreanTriplet ( n ) { for ( let i = 1 ; i <= n / 3 ; i ++ ) { for ( let j = i + 1 ; j <= n / 2 ; j ++ ) { let k = n - i - j ; if ( i * i + j * j == k * k ) { document . write ( i + " " + j + " " + k ) ; return ; } } } document . write ( " " ) ; }
function nextGreater ( N ) { var power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
function findTerm ( n ) { if ( n == 1 ) return n ; else { let term = 7 ; for ( let i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
function CountWays ( r , b , l , R , B , W , dp ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r ] [ b ] [ l ] != - 1 ) return dp [ r ] [ b ] [ l ] ; var ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r ] [ b ] [ l ] = ans ; }
function factorial ( n ) { let M = 1000000007 ; let f = 1 ; for ( let i = 1 ; i <= n ; i ++ ) return f ; }
function compareValues ( a , b , c , d ) { let log1 = Math . log ( a ) / Math . log ( 10 ) ; let num1 = log1 * b ; let log2 = Math . log ( c ) / Math . log ( 10 ) ; let num2 = log2 * d ; if ( num1 > num2 ) document . write ( a + " " + b ) ; else document . write ( c + " " + d ) ; }
function MinimumNoOfWays ( arr , n ) { var mini_no_of_ways ; if ( n % 2 == 0 ) { mini_no_of_ways = n / 2 ; } else { mini_no_of_ways = n / 2 + 1 ; } return parseInt ( mini_no_of_ways ) ; }
function printMaxNumber ( n ) { if ( n & 1 ) { document . write ( " " ) ; for ( var i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) document . write ( " " ) ; } else { for ( var i = 0 ; i < n / 2 ; i ++ ) document . write ( " " ) ; } }
function countNumbers ( N ) { var count = 0 ; for ( i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( parseInt ( N / i ) != i ) { count ++ ; } } } return count ; }
function insertAfter ( prev_node , new_data ) { if ( prev_node == null ) { document . write ( " " ) ; return ; } var new_node = new Node ( new_data ) ; new_node . next = prev_node . next ; prev_node . next = new_node ; }
function findAverageOfCube ( n ) { let sum = 0 ; let i ; for ( i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; }
function countCubes ( a , b ) { return ( Math . floor ( b ** ( 1. / 3. ) ) - Math . ceil ( a ** ( 1. / 3. ) ) + 1 ) }
function rotate90Clockwise ( arr ) { for ( j = 0 ; j < N ; j ++ ) { for ( i = N - 1 ; i >= 0 ; i -- ) document . write ( arr [ i ] [ j ] + " " ) ; document . write ( " " ) ; } }
function coutSubSeq ( A , N , M ) { let sum = 0 ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { for ( let k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
function square ( a ) { if ( a < 0 ) return - 1 ; var x = 0.464 * a ; return x ; }
function findSum ( N , K ) { let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
function calcDeterminant ( arr ) { let determinant = 0 ; for ( let i = 0 ; i < N ; i ++ ) { determinant += Math . pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; }
function printKthBit ( n , k ) { document . write ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
function findLCS ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) != 0 ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } return mp . size ; }
function minOccupiedPosition ( A , n ) { var minPos = 0 ; for ( var i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; }
function countSubsequences ( s ) { let aCount = 0 ; let bCount = 0 ; let cCount = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
function countWaysToJump ( arr , n ) { let count_jump = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { count_jump [ i ] = 0 ; } for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( let j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count_jump [ i ] + " " ) ; }
function sphere ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; return r ; }
function minDaysToEmpty ( C , l ) { if ( l >= C ) return C ; let eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( Math . ceil ( eq_root ) + l ) ; }
function prletKPFNums ( A , B , K ) { let prime = [ ] ; for ( let i = 0 ; i < B + 1 ; i ++ ) prime [ i ] = true ; let p_factors = [ ] ; for ( let i = 0 ; i < B + 1 ; i ++ ) p_factors [ i ] = 0 ; for ( let p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( let i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( let i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) document . write ( i + " " ) ; }
function term ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
function cubeRoot ( n ) { let ans = Math . pow ( 3 , ( 1.0 / 3 ) * ( Math . log ( n ) / Math . log ( 3 ) ) ) ; return ans ; }
function check ( m , n ) { var RHS = m * Math . log ( n ) ; var LHS = n * Math . log ( m ) ; if ( LHS > RHS ) { document . write ( " " ) ; } else if ( LHS < RHS ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function checkPattern ( arr , m , k , n ) { let count = 1 , t = 0 ; for ( let i = 0 ; i < n - m ; i ++ ) { if ( arr [ i ] == arr [ i + m ] ) { t ++ ; if ( t == m ) { t = 0 ; count ++ ; if ( count == k ) { return " " ; } } } else { t = 0 ; count = 1 ; } } return " " ; }
function maxModulosum ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; }
function sumBetweenTwoKth ( arr , k1 , k2 ) { arr . sort ( function ( a , b ) { return a - b } ) ; var result = 0 ; for ( var i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
function lis ( arr , n ) { let lis = Array ( n ) . fill ( 0 ) ; let i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
function findMin ( N ) { let digit = N % 10 ; switch ( digit ) { case 0 : if ( N >= 90 ) return 10 ; break ; case 1 : if ( N >= 81 ) return 9 ; break ; case 2 : if ( N >= 72 ) return 8 ; break ; case 3 : if ( N >= 63 ) return 7 ; break ; case 4 : if ( N >= 54 ) return 6 ; break ; case 5 : if ( N >= 45 ) return 5 ; break ; case 6 : if ( N >= 36 ) return 4 ; break ; case 7 : if ( N >= 27 ) return 3 ; break ; case 8 : if ( N >= 18 ) return 2 ; break ; case 9 : if ( N >= 9 ) return 1 ; break ; } return - 1 ; }
function isPowerOfTwo ( n ) { return ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) == Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; } let N = 8 ; if ( isPowerOfTwo ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function rotate ( arr , N , X ) { let nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return nextPower - N ; let prevPower = nextPower / 2 ; return 2 * ( N - prevPower ) + 1 ; }
function printClosest ( ar1 , ar2 , m , n , x ) { let diff = Number . MAX_VALUE ; let res_l , res_r ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + ar1 [ res_l ] + " " + ar2 [ res_r ] + " " ) ; }
function longestSubseq ( s ) { let n = s . length ; let pre_count_0 = new Array ( n + 2 ) ; let pre_count_1 = new Array ( n + 1 ) ; let post_count_0 = new Array ( n + 2 ) ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( let j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s [ j - 1 ] == ' ' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s [ n - j ] == ' ' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= n ; j ++ ) ans = Math . max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; }
function isPerfectSquareString ( str ) { var sum = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; i ++ ) sum += str . charCodeAt ( i ) ; var squareRoot = Math . sqrt ( sum ) ; return squareRoot - Math . floor ( squareRoot ) == 0 ; }
function kthNum ( n , k ) { var a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; }
