bool checkPowerof8 ( int n ) { double i = Math . Log ( n ) / Math . Log ( 8 ) ; return ( i - Math . Floor ( i ) < 0.000001 ) ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
void sumFib ( int N ) { long num = ( long ) Math . Round ( Math . Pow ( ( Math . Sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / Math . Sqrt ( 5 ) ) ; Console . WriteLine ( num - 1 ) ; }
void findEquation ( int a , int b ) { int sum = ( a + b ) ; int product = ( a * b ) ; Console . WriteLine ( " x ^ 2 ▁ - ▁ ( " + sum + " x ) ▁ + ▁ ( " + product + " ) ▁ = ▁ 0" ) ; }
int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
int maxPeople ( int p ) { int tmp = 0 , count = 0 ; for ( int i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
int maxDistance ( int [ ] arr , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . ContainsKey ( arr [ i ] ) ) map . Add ( arr [ i ] , i ) ; else max_dist = Math . Max ( max_dist , i - map [ arr [ i ] ] ) ; } return max_dist ; }
int getIndexInSortedArray ( int [ ] arr , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
int Last_set_bit ( int n ) { int p = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) { return p ; } p ++ ; n = n >> 1 ; } return - 1 ; }
int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
int sumofsquare ( int n ) { int [ , ] C = new int [ n + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n , i ] * C [ n , i ] ) ; return sum ; }
int maxEvenIntegers ( int [ ] arr , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . Max ( ans , cnt ) ; } return ans ; }
void poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { Console . WriteLine ( ( int ) Math . Ceiling ( Math . Log ( buckets ) / Math . Log ( ( minutesToTest / minutesToDie ) + 1 ) ) ) ; }
int find ( List < int > arr , int N ) { int Sum = 0 ; foreach ( int item in arr ) Sum += item ; if ( Sum % N == 1 ) return - 1 ; int k = Sum / N ; int ans = 0 ; int i = 0 ; while ( i < N ) { ans = ans + Math . Abs ( k - arr [ i ] ) ; i += 1 ; } return ans / 2 ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { Console . WriteLine ( " The ▁ shortest ▁ distance ▁ " + " between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " + ( Math . Sqrt ( ( Math . Pow ( ( x2 - x1 ) , 2 ) ) + ( Math . Pow ( ( y2 - y1 ) , 2 ) ) ) - r ) ) ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
void checkSolution ( int a , int b , int c ) { if ( a == c ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
bool areVowelsInOrder ( string s ) { int n = s . Length ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { if ( s [ i ] < c ) { return false ; } else { c = s [ i ] ; } } } return true ; }
void checkEVENodd ( int [ ] arr , int n , int l , int r ) { if ( arr [ r ] == 1 ) Console . WriteLine ( " odd " ) ; else Console . WriteLine ( " even " ) ; }
int countways ( int n ) { int [ ] A = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
int largestNum ( int a , int b ) { return a * ( ( a / b ) > 0 ? 1 : 0 ) + b * ( ( b / a ) > 0 ? 1 : 0 ) ; }
int MaxRearrngeSum ( int [ ] A , int [ ] B , int N ) { Array . Sort ( A ) ; Array . Sort ( B ) ; Array . Reverse ( B ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxSum += Math . Abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
long product ( int [ , ] mat , int n ) { long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i , i ] ; d2 += mat [ i , n - i - 1 ] ; } return 1L * d1 * d2 ; }
void checkVantieghemsTheorem ( int limit ) { long prod = 1 ; for ( long n = 2 ; n < limit ; n ++ ) { if ( ( ( prod - n < 0 ? 0 : prod - n ) % ( ( 1 << ( int ) n ) - 1 ) ) == 0 ) Console . Write ( n + " ▁ is ▁ prime STRNEWLINE " ) ; prod *= ( ( 1 << ( int ) n ) - 1 ) ; } }
int findMean ( int [ ] arr , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = ( int ) Math . Floor ( ( double ) sum / count ) ; return mean ; }
int countSubset ( int [ ] arr , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int [ , ] t = new int [ n + 1 , sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 , j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i , j ] = t [ i - 1 , j ] ; else { t [ i , j ] = t [ i - 1 , j ] + t [ i - 1 , j - arr [ i - 1 ] ] ; } } } return t [ n , sum ] ; }
int fun ( int n ) { return n & ( n - 1 ) ; }
int hIndex ( int [ ] citations , int n ) { int hindex = 0 ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } Console . WriteLine ( hindex ) ; return hindex ; }
void allCharactersSame ( string s ) { HashSet < char > s1 = new HashSet < char > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) s1 . Add ( s [ i ] ) ; if ( s1 . Count == 1 ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int no_of_ways ( int [ ] a , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
void countTotalFrequencies ( string S1 , string S2 ) { HashSet < char > bset = new HashSet < char > ( ) ; foreach ( char x in S1 ) bset . Add ( x ) ; int count = 0 ; foreach ( char x in S2 ) { if ( bset . Contains ( x ) ) count += 1 ; } Console . Write ( count ) ; }
bool checkIsFibonacci ( int [ ] arr , int n ) { if ( n == 1 n == 2 ) return true ; Array . Sort ( arr ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; } return true ; }
long numbers ( int n ) { return ( long ) ( Math . Pow ( 2 , n + 1 ) ) - 2 ; }
int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = ( a > b ) ? ( ( a > c ) ? a : c ) : ( ( b > c ) ? b : c ) ; int smallest = ( a < b ) ? ( ( a < c ) ? a : c ) : ( ( b < c ) ? b : c ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } return - 1 ; }
int findSmallestNumK ( int n ) { int cummAnd = n ; int i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
bool getParity ( int n ) { bool parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
bool isEven ( int n ) { if ( ( n ^ 1 ) == n + 1 ) return true ; else return false ; }
int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int term ( int n ) { return n * ( n + 1 ) / 2 ; }
void check ( int n , int m ) { if ( n == 2 m == 2 n % m == 0 ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } }
int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
int EqualNumbers ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n != 0 ) return n - 1 ; return n ; }
void minimumTime ( int [ ] arr , int n ) { int sum = 0 ; int T = arr . Min ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } Console . WriteLine ( Math . Max ( 2 * T , sum ) ) ; }
bool findWinner ( int x , int y , int n ) { bool [ ] dp = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = false ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
bool isConvertible ( string str1 , string str2 , int k ) { if ( ( str1 . Length + str2 . Length ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . Min ( str1 . Length , str2 . Length ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . Length - str2 . Length + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
void printMissingElements ( int [ ] arr , int N ) { int diff = arr [ 0 ] - 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { Console . Write ( i + diff + " ▁ " ) ; diff ++ ; } } } }
int countNums ( int n , int x , int y ) { bool [ ] arr = new bool [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . Min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
void odd_even ( int [ ] arr , int n ) { List < int > odd_indexes = new List < int > ( ) ; List < int > even_indexes = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . Add ( arr [ i ] ) ; else even_indexes . Add ( arr [ i ] ) ; } odd_indexes . Sort ( ) ; even_indexes . Sort ( ) ; for ( int i = 0 ; i < odd_indexes . Count ; i ++ ) Console . Write ( odd_indexes [ i ] + " ▁ " ) ; for ( int i = 0 ; i < even_indexes . Count ; i ++ ) Console . Write ( even_indexes [ i ] + " ▁ " ) ; }
float Area ( float a ) { if ( a < 0 ) return - 1 ; float x = 0.464f * a ; float A = 0.70477f * ( float ) Math . Pow ( x , 2 ) ; return A ; }
void possibleNumbers ( HashSet < int > numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . Add ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; }
int clearLastBit ( int N , int K ) { int mask = ( - 1 << K + 1 ) ; return N = N & mask ; }
void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( n != 0 ) { int r = n % 10 ; largest = Math . Max ( r , largest ) ; smallest = Math . Min ( r , smallest ) ; n = n / 10 ; } Console . WriteLine ( largest + " ▁ " + smallest ) ; }
int smallest ( string s ) { int [ ] a = new int [ s . Length ] ; for ( int i = 0 ; i < s . Length ; i ++ ) a [ i ] = ( int ) ( s [ i ] - '0' ) ; ArrayList b = new ArrayList ( ) ; for ( int i = 0 ; i < a . Length ; i ++ ) { if ( a [ i ] % 2 != 0 ) b . Add ( a [ i ] ) ; } b . Sort ( ) ; if ( b . Count > 1 ) return ( ( int ) b [ 0 ] * 10 + ( int ) b [ 1 ] ) ; return - 1 ; }
int rankLessThanK ( int [ ] arr , int k , int n ) { int rank = 1 ; int position = 1 ; Array . Sort ( arr ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
bool search ( int [ ] arr , int n , int x ) { int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
void printDuplicates ( int [ ] arr , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { Console . Write ( arr [ i ] % n + " ▁ " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! ( fl > 0 ) ) Console . Write ( " - 1" ) ; }
void linearCongruentialMethod ( int Xo , int m , int a , int c , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } }
int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } Console . Write ( " Sum ▁ = ▁ " + sum ) ; Console . Write ( " Product = " }
int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
int binarySearch ( String [ ] arr , String x ) { int l = 0 , r = arr . Length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; int res = x . CompareTo ( arr [ m ] ) ; if ( res == 0 ) return m ; if ( res > 0 ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
int findKHCF ( int x , int y , int k ) { int small = Math . Min ( x , y ) ; int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; }
int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . Pow ( 2 , E - 1 ) ; }
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . Max ( Math . Max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
void contain ( int L , int U , int M ) { int count = 0 ; for ( int j = L ; j < U ; j ++ ) { HashSet < string > num = new HashSet < string > ( ) ; string str = j . ToString ( ) ; num . Add ( str ) ; if ( j % M == 0 && ! num . Contains ( M . ToString ( ) ) ) { count += 1 ; } } Console . Write ( count - 2 ) ; }
int totalTriangles ( int h , int v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; int total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
int getM ( int n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
int countStrings ( int n , int m , String [ ] s ) { HashSet < int > ind = new HashSet < int > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . Max ( mx , ( int ) ( s [ i ] [ j ] - '0' ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] - '0' == mx ) ind . Add ( i ) ; } return ind . Count ; }
bool isPowerOfK ( int n , int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
void completeSequence ( String s ) { int n = s . Length ; int open = 0 , close = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) open ++ ; else close ++ ; if ( close > open ) { Console . Write ( " IMPOSSIBLE " ) ; return ; } } Console . Write ( s ) ; for ( int i = 0 ; i < open - close ; i ++ ) Console . Write ( " ) " ) ; }
int countRhombi ( int h , int w ) { int ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; }
void prevGreater ( int [ ] arr , int n ) { Console . Write ( " - 1 , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { Console . Write ( arr [ j ] + " , ▁ " ) ; break ; } } if ( j == - 1 ) Console . Write ( " - 1 , ▁ " ) ; } }
void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) Console . Write ( i + " ▁ " ) ; }
double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . Sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
int countOccurrences ( int [ ] arr , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
float harmonicMean ( float [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }
void findNthTerm ( int n ) { Console . Write ( Math . Pow ( 2 , n ) - 2 * n ) ; }
int minOperation ( int N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } int k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ; t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
int perfectPowerOf2 ( int n ) { int per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
bool isSumEqual ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . Sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
void cal_cos ( float n ) { float accuracy = ( float ) 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( float ) ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . Cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= cosval - cosx ) ; Console . WriteLine ( cosx ) ; }
void findPoint ( int n , int h ) { for ( int i = 1 ; i < n ; i ++ ) Console . Write ( " { 0 : F2 } ▁ " , Math . Sqrt ( i / ( n * 1.0 ) ) * h ) ; }
int find ( int index , int openbrk , int n , int [ , ] adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index , openbrk ] != - 1 ) return dp [ index , openbrk ] ; dp [ index , openbrk ] = Math . Min ( adj [ index , 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index , 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index , openbrk ] ; }
int countSubarrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { long product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
void canMakeEqual ( String S ) { int N = S . Length ; int weightOfString = 0 ; for ( int i = 0 ; i < N ; i ++ ) { weightOfString += S [ i ] - ' a ' + 1 ; } if ( weightOfString % N == 0 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int minSumDifference ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; int rem = sum % n ; return rem * ( n - rem ) ; }
int singleNumber ( int [ ] nums , int n ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; long sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m . ContainsKey ( nums [ i ] ) ) { sum1 += nums [ i ] ; m . Add ( nums [ i ] , 1 ) ; } sum2 += nums [ i ] ; } return ( int ) ( 2 * ( sum1 ) - sum2 ) ; }
int areaSquare ( int L , int B ) { int large = Math . Max ( L , B ) ; int small = Math . Min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } }
int LIS ( int [ ] a , int n ) { int [ ] dp = new int [ N ] ; int [ ] d = new int [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . Max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . Max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . Max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
int findMinDiff ( int [ ] arr , int n ) { int diff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . Abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
bool isSymmetric ( int [ , ] mat , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i , j ] != mat [ j , i ] ) return false ; return true ; }
uint countOfMultiples ( uint n ) { return ( n / 3 + n / 5 - n / 15 ) ; }
int minSteps ( string str , int n , int k ) { if ( str [ n - 1 ] == '0' ) return - 1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( int i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) continue ; int steps = INT_MAX ; if ( i + k < n && str [ i + k ] == '1' ) steps = Math . Min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == '1' ) steps = Math . Min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == '1' ) steps = Math . Min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == INT_MAX ) ? steps : 1 + steps ; } if ( dp [ 0 ] == INT_MAX ) return - 1 ; return dp [ 0 ] ; }
int totalSubSets ( int n , int l , int r ) { int zero = ( int ) Math . Floor ( ( double ) r / 3 ) - ( int ) Math . Ceiling ( ( double ) l / 3 ) + 1 ; int one = ( int ) Math . Floor ( ( double ) ( r - 1 ) / 3 ) - ( int ) Math . Ceiling ( ( double ) ( l - 1 ) / 3 ) + 1 ; int two = ( int ) Math . Floor ( ( double ) ( r - 2 ) / 3 ) - ( int ) Math . Ceiling ( ( double ) ( l - 2 ) / 3 ) + 1 ; int [ , ] dp = new int [ n , 3 ] ; dp [ 0 , 0 ] = zero ; dp [ 0 , 1 ] = one ; dp [ 0 , 2 ] = two ; for ( int i = 1 ; i < n ; ++ i ) { dp [ i , 0 ] = ( ( dp [ i - 1 , 0 ] * zero ) + ( dp [ i - 1 , 1 ] * two ) + ( dp [ i - 1 , 2 ] * one ) ) % MOD ; dp [ i , 1 ] = ( ( dp [ i - 1 , 0 ] * one ) + ( dp [ i - 1 , 1 ] * zero ) + ( dp [ i - 1 , 2 ] * two ) ) % MOD ; dp [ i , 2 ] = ( ( dp [ i - 1 , 0 ] * two ) + ( dp [ i - 1 , 1 ] * one ) + ( dp [ i - 1 , 2 ] * zero ) ) % MOD ; } return dp [ n - 1 , 0 ] ; }
int matrixSum ( int [ , ] arr ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i , j ] ) ; } } return sum ; }
bool isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
String compute ( string str , int n ) { string reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " ; int l = str . Length ; String answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer = answer + str [ i ] ; for ( int i = n ; i < l ; i ++ ) answer = answer + reverseAlphabet [ str [ i ] - ' a ' ] ; return answer ; }
int CountTriplets ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int first = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
int cntSubsets ( int [ ] arr , int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } int result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
int findOddPair ( int [ ] A , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
int minimumAdjacentDifference ( int [ ] a , int n , int k ) { int minDiff = int . MaxValue ; for ( int i = 0 ; i <= k ; i ++ ) { int maxDiff = int . MinValue ; for ( int j = 0 ; j < n - k - 1 ; j ++ ) { for ( int p = i ; p <= i + j ; p ++ ) { maxDiff = Math . Max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; } } minDiff = Math . Min ( minDiff , maxDiff ) ; } return minDiff ; }
int divisible ( String num ) { int n = num . Length ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num [ i ] ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { System . Console . WriteLine ( i + " ▁ " + j + " ▁ " + k ) ; return ; } } } } } } }
int MinOperation ( int [ ] a , int [ ] b , int n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . Abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . Abs ( a [ i ] - b [ i ] ) ; } return result ; }
int ceilDifference ( int [ ] arr , int n , int x ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += ( int ) Math . Ceiling ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int totalCeilSum = ( int ) Math . Ceiling ( ( double ) ( totalSum ) / ( double ) ( x ) ) ; return Math . Abs ( perElementSum - totalCeilSum ) ; }
void checkArrangement ( int [ ] A1 , int [ ] A2 , int n , int k ) { Array . Sort ( A1 ) ; Array . Sort ( A2 ) ; Array . Reverse ( A2 ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) Console . WriteLine ( " No " ) ; else Console . WriteLine ( " Yes " ) ; }
int findEletobeInserted ( int [ ] A , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; }
int deleteElement ( int [ ] A , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
void compareVal ( double x , double y ) { double a = y * Math . Log ( x ) ; double b = x * Math . Log ( y ) ; if ( a > b ) Console . Write ( x + " ^ " + y + " ▁ > ▁ " + y + " ^ " + x ) ; else if ( a < b ) Console . Write ( x + " ^ " + y + " ▁ < ▁ " + y + " ^ " + x ) ; else if ( a == b ) Console . Write ( x + " ^ " + y + " ▁ = ▁ " + y + " ^ " + x ) ; }
int countStrings ( int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
void countSubString ( String s ) { int res = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { int x = 0 ; for ( int j = i ; j < s . Length ; j ++ ) { int temp = 1 << s [ j ] - ' a ' ; x ^= temp ; if ( ( x & ( x - 1 ) ) == 0 ) res ++ ; } } Console . Write ( res ) ; }
int noOfTriangles ( int n ) { return ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
void findAandB ( int N ) { int K = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) ; int B = ( 1 << K ) ; int A = B ^ N ; Console . Write ( A + " ▁ " + B ) ; }
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
int minServerLoads ( int n , int [ ] servers ) { int totalLoad = 0 ; for ( int i = 0 ; i < servers . Length ; i ++ ) totalLoad += servers [ i ] ; int requiredLoad = totalLoad / 2 ; int [ , ] dp = new int [ n + 1 , requiredLoad + 1 ] ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i , j ] = dp [ i - 1 , j ] ; else dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , servers [ i - 1 ] + dp [ i - 1 , j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n , requiredLoad ] ; }
void minimumOperations ( int [ ] arr , int N ) { int mx = 0 , pos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } Console . Write ( ( mx - 1 ) * N + pos + 1 ) ; }
int day_of_the_week ( int y , int m , int d ) { int [ ] t = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
int countPairsBruteForce ( int [ ] X , int [ ] Y , int m , int n ) { int ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( Math . Pow ( X [ i ] , Y [ j ] ) > Math . Pow ( Y [ j ] , X [ i ] ) ) ans ++ ; return ans ; }
bool sumSquare ( int n ) { for ( long i = 1 ; i * i <= n ; i ++ ) for ( long j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { Console . Write ( i + " ^ 2 ▁ + ▁ " + j + " ^ 2" ) ; return true ; } return false ; }
int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
int term ( int n ) { int x = ( ( ( 1 ) + ( int ) Math . Sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
int CountMaximum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
int findCnt ( String s , int i , int r ) { if ( i == s . Length ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i , r ] == 1 ) return dp [ i , r ] ; v [ i , r ] = 1 ; dp [ i , r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i , r ] ; }
int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
void insertNames ( String [ ] arr , int n ) { HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! set . Contains ( arr [ i ] ) ) { Console . Write ( " No STRNEWLINE " ) ; set . Add ( arr [ i ] ) ; } else { Console . Write ( " Yes STRNEWLINE " ) ; } } }
void solve ( int [ ] a , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; bool evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; }
int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; if ( i == j ) return dp [ i , j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i , j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i , j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
int countStrings ( String s ) { int cnt = 0 ; for ( int i = 1 ; i < s . Length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
bool isReversible ( string str ) { int i = 0 , j = str . Length - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) { return false ; } i ++ ; j -- ; } return true ; }
void longestAlternating ( int [ ] arr , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( count [ i ] + " ▁ " ) ; }
void constructArray ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( i + " ▁ " ) ; } }
int distancesum ( int [ ] x , int [ ] y , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . Abs ( x [ i ] - x [ j ] ) + Math . Abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
char findExtraCharcter ( char [ ] strA , char [ ] strB ) { int [ ] m1 = new int [ 256 ] ; for ( int i = 0 ; i < strB . Length ; i ++ ) m1 [ strB [ i ] ] ++ ; for ( int i = 0 ; i < strA . Length ; i ++ ) m1 [ strA [ i ] ] -- ; for ( int i = 0 ; i < m1 . Length ; i ++ ) { if ( m1 [ i ] == 1 ) return ( char ) i ; } return char . MinValue ; }
void generatepermutation ( int N ) { int [ ] answer = new int [ N ] ; answer [ 0 ] = N ; for ( int i = 1 ; i < N ; i ++ ) { answer [ i ] = i ; } foreach ( int i in answer ) Console . Write ( i + " ▁ " ) ; }
void EditDistDP ( String str1 , String str2 ) { int len1 = str1 . Length ; int len2 = str2 . Length ; int [ , ] DP = new int [ 2 , len1 + 1 ] ; for ( int i = 0 ; i <= len1 ; i ++ ) DP [ 0 , i ] = i ; for ( int i = 1 ; i <= len2 ; i ++ ) { for ( int j = 0 ; j <= len1 ; j ++ ) { if ( j == 0 ) DP [ i % 2 , j ] = i ; else if ( str1 [ j - 1 ] == str2 [ i - 1 ] ) { DP [ i % 2 , j ] = DP [ ( i - 1 ) % 2 , j - 1 ] ; } else { DP [ i % 2 , j ] = 1 + Math . Min ( DP [ ( i - 1 ) % 2 , j ] , Math . Min ( DP [ i % 2 , j - 1 ] , DP [ ( i - 1 ) % 2 , j - 1 ] ) ) ; } } } Console . Write ( DP [ len2 % 2 , len1 ] + " STRNEWLINE " ) ; }
void printPairs ( int [ ] arr , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) Console . Write ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " STRNEWLINE " ) ; }
int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
int largest ( int [ ] arr , int n ) { return arr . Max ( ) ; }
Boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
long centeredDodecagonal ( long n ) { return 6 * n * ( n - 1 ) + 1 ; }
void printString ( char [ ] str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; bool used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) Console . Write ( "1" ) ; } if ( str [ i ] != '1' ) Console . Write ( str [ i ] ) ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) Console . Write ( "1" ) ; }
int countTriangles ( int [ ] a , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; }
int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; }
bool isKPartitionPossible ( int [ ] arr , int N , int K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; int target = sum / K ; int [ ] dp = new int [ ( 1 << 15 ) ] ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == - 1 ) continue ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( ( mask & ( 1 << i ) ) == 0 ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; }
void maxSum ( int [ ] a , int n ) { int maxAnd = a . Max ( ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } Console . Write ( ( maxAnd + maxOR ) ) ; }
int deleteElement ( int [ ] arr , int n , int x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; int prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { int curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
bool isNumber ( string s ) { for ( int i = 0 ; i < s . Length ; i ++ ) if ( char . IsDigit ( s [ i ] ) == false ) return false ; return true ; }
string check ( int current_row , int current_col , int destination_row , int destination_col ) { if ( current_row == destination_row ) return " POSSIBLE " ; else if ( current_col == destination_col ) return " POSSIBLE " ; else return " NOT ▁ POSSIBLE " ; }
void minimumOperations ( int [ ] arr , int N ) { int oddCnt = 0 , evenCnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } Console . Write ( Math . Min ( oddCnt , evenCnt ) ) ; }
void highestPowerOfTwo ( int num ) { String s = num . ToString ( ) ; for ( int i = 0 ; i < ( int ) s . Length ; i ++ ) { if ( s [ i ] == '0' ) { Console . Write ( "0" ) ; continue ; } int lg = ( int ) ( Math . Log ( s [ i ] - '0' ) / Math . Log ( 2 ) ) ; int p = ( int ) Math . Pow ( 2 , lg ) ; Console . Write ( ( char ) ( p + 48 ) ) ; } }
int countPairs ( int [ ] arr , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } int ans = ( N - odd + odd / 2 - 1 ) + odd / 2 ; return ans ; }
double minAnglRot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; }
bool pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
string isAnBn ( string str ) { int n = str . Length ; if ( ( n & 1 ) != 0 ) return " No " ; int i ; for ( i = 0 ; i < n / 2 ; i ++ ) if ( str [ i ] != ' a ' str [ n - i - 1 ] != ' b ' ) return " No " ; return " Yes " ; }
int reduceZero ( int N ) { int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) dp [ i ] = ( int ) 1e9 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { foreach ( char c in String . Join ( " " , i ) . ToCharArray ( ) ) { dp [ i ] = Math . Min ( dp [ i ] , dp [ i - ( c - '0' ) ] + 1 ) ; } } return dp [ N ] ; }
void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; Console . Write ( res ) ; }
double angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; double den = Math . Sqrt ( Math . Pow ( ( x2 - x1 ) , 2 ) + Math . Pow ( ( y2 - y1 ) , 2 ) + Math . Pow ( ( z2 - z1 ) , 2 ) ) * Math . Sqrt ( Math . Pow ( ( x3 - x1 ) , 2 ) + Math . Pow ( ( y3 - y1 ) , 2 ) + Math . Pow ( ( z3 - z1 ) , 2 ) ) ; double angle = Math . Acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
bool areChractersUnique ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
int absSumDidd ( int [ ] a ) { Array . Sort ( a ) ; int midValue = a [ a . Length / 2 ] ; int sum = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { sum = sum + Math . Abs ( a [ i ] - midValue ) ; } return sum ; }
int possibleTriplets ( int [ ] arr , int N ) { int freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( int ) ( ( freq * 1L * ( freq - 1 ) * ( freq - 2 ) ) / 6 ) ; }
void checkSolveable ( int n , int m ) { if ( n == 1 m == 1 ) Console . WriteLine ( " YES " ) ; else if ( m == 2 && n == 2 ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
int lastRemaining ( int n , Dictionary < int , int > dp ) { if ( dp . ContainsKey ( n ) ) return dp [ n ] ; if ( n == 1 ) return 1 ; else dp . Add ( n , 2 * ( 1 + n / 2 - lastRemaining ( n / 2 , dp ) ) ) ; return dp [ n ] ; }
int findSteps ( int n , int m , int [ ] a ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
void checksum ( int n ) { if ( n % 3 == 0 ) Console . WriteLine ( n / 3 - 1 + " ▁ " + n / 3 + " ▁ " + ( n / 3 + 1 ) ) ; else Console . WriteLine ( " - 1" ) ; }
void minOpsToEmptyString ( string S , int N ) { int one = 0 , zero = 0 ; int x0 = 0 , x1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '0' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = Math . Max ( x0 , zero ) ; one = Math . Max ( x1 , one ) ; } Console . WriteLine ( Math . Max ( one , zero ) ) ; }
int smallestOdd ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
string largestSubStr ( string s ) { while ( s . Length != 0 && s [ s . Length - 1 ] == '1' ) s = s . Substring ( 0 , s . Length - 1 ) ; if ( s . Length == 0 ) return " - 1" ; else return s ; }
float areacircumscribed ( float a ) { return ( a * a * ( float ) ( PI / 2 ) ) ; }
int minimumLength ( int x , int y , int z ) { return 1 + Math . Abs ( x - y ) + Math . Abs ( y - z ) ; }
int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
int minMaxProduct ( int [ ] arr1 , int [ ] arr2 , int n1 , int n2 ) { Array . Sort ( arr1 ) ; Array . Sort ( arr2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }
int countPairs ( int [ ] P , int [ ] Q , int N , int M ) { int [ ] A = new int [ 2 ] ; int [ ] B = new int [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
int distinctCount ( int [ ] arr , int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . Add ( Math . Abs ( arr [ i ] ) ) ; return s . Count ; }
int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return ( int ) ( Math . Pow ( 2 , N / 2 + 1 ) + Math . Pow ( 2 , N / 2 ) - 2 ) ; } else { return ( int ) ( Math . Pow ( 2 , ( N + 1 ) / 2 ) + Math . Pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
int checkArray ( int [ ] arr , int N , int k ) { if ( N < 3 ) return - 1 ; int i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; int R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; int Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
int solve ( int [ ] A , int N ) { int i = 0 ; int k = 0 ; for ( int j = 1 ; j < N ; j ++ ) { int tempK = Math . Min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
int longestSubsequenceCommonSegment ( int k , string s1 , string s2 ) { int n = s1 . Length ; int m = s2 . Length ; int [ , ] lcs = new int [ n + 1 , m + 1 ] ; int [ , ] cnt = new int [ n + 1 , m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i , j ] = Math . Max ( lcs [ i - 1 , j ] , lcs [ i , j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i , j ] = cnt [ i - 1 , j - 1 ] + 1 ; if ( cnt [ i , j ] >= k ) { for ( int a = k ; a <= cnt [ i , j ] ; a ++ ) lcs [ i , j ] = Math . Max ( lcs [ i , j ] , lcs [ i - a , j - a ] + a ) ; } } } return lcs [ n , m ] ; }
int cntPairs ( int [ ] a , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
int Icosikaipentagon ( int n ) { return ( 23 * n * n - 21 * n ) / 2 ; }
int smallestNth ( int A , int B , int N ) { int res = Int32 . MaxValue ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { int D = ( B - A ) / ( j - i ) ; int FirstTerm = A - ( i - 1 ) * D ; int NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = Math . Min ( res , NthTerm ) ; } } } return res ; }
bool sumSquare ( int n ) { Dictionary < int , int > s = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i * i <= n ; ++ i ) { s . Add ( i * i , 1 ) ; if ( s . ContainsKey ( n - i * i ) ) { Console . WriteLine ( ( int ) Math . Sqrt ( n - i * i ) + " ^ 2 ▁ + ▁ " + i + " ^ 2" ) ; return true ; } } return false ; }
double largestSumOfAverages ( int [ ] A , int K ) { int n = A . Length ; double [ ] pre_sum = new double [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double [ ] dp = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . Max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return ( n & 1 ) > 0 ? 1 : 6 ; }
int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . Floor ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; int right = left * 2 ; return Math . Min ( ( n - left ) , ( right - n ) ) ; }
long noOfTriples ( long [ ] arr , int n ) { Array . Sort ( arr ) ; long count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
bool isTidy ( int num ) { int prev = 10 ; while ( num != 0 ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
void findSum ( int N , int K ) { int ans = 0 ; int i = 1 ; while ( i <= N ) { ans += N / i ; i = i * K ; } Console . Write ( ans ) ; }
void findNumbers ( int n ) { int i = 0 ; while ( i <= n ) { Console . Write ( 2 * i * i + 4 * i + 1 + i % 2 + " ▁ " ) ; i ++ ; } }
int getPairs ( int [ ] a ) { int n = a . Length ; int count = ( n * ( n - 1 ) ) / 2 ; return count ; }
int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
int fib ( int n ) { int [ ] term = new int [ 1000 ] ; if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } }
void findRightAngle ( double A , double H ) { double D = Math . Pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { double root1 = ( H * H + Math . Sqrt ( D ) ) / 2 ; double root2 = ( H * H - Math . Sqrt ( D ) ) / 2 ; double a = Math . Sqrt ( root1 ) ; double b = Math . Sqrt ( root2 ) ; if ( b >= a ) Console . WriteLine ( a + " ▁ " + b + " ▁ " + H ) ; else Console . WriteLine ( b + " ▁ " + a + " ▁ " + H ) ; } else Console . WriteLine ( " - 1" ) ; }
void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & N ) > 0 ) { result ++ ; } } Console . WriteLine ( result ) ; }
double kthRoot ( double n , int k ) { return Math . Pow ( k , ( ( 1.0 / k ) * ( Math . Log ( n ) / Math . Log ( k ) ) ) ) ; }
double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . Sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
void find_composite_nos ( int n ) { Console . WriteLine ( 9 * n + " ▁ " + 8 * n ) ; }
double Length_Diagonal ( int a , int b , double theta ) { double diagonal = Math . Sqrt ( ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) - 2 * a * b * Math . Cos ( theta * ( Math . PI / 180 ) ) ) ; return diagonal ; }
void findTriangles ( int n ) { int num = n ; Console . Write ( num + " ▁ " ) ; Console . WriteLine ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }
long SubArraySum ( int [ ] arr , int n ) { long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
void positions ( string str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ( str [ i ] & NUM ) + " ▁ " ) ; } }
int count_pairs ( int x ) { int ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = x / 2 ; } return ans ; }
int countOccurrences ( int N , int X ) { int count = 0 ; for ( int i = 1 ; i < Math . Sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { int a = i ; int b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; }
void checkWinner ( int N , int K ) { if ( N % ( K + 1 ) > 0 ) { Console . Write ( " A " ) ; } else { Console . Write ( " B " ) ; } }
int getTotalNumberOfSequences ( int m , int n ) { int [ , ] T = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i , j ] = 0 ; else if ( i < j ) T [ i , j ] = 0 ; else if ( j == 1 ) T [ i , j ] = i ; else T [ i , j ] = T [ i - 1 , j ] + T [ i / 2 , j - 1 ] ; } } return T [ m , n ] ; }
int maxDistance ( int [ ] array ) { int max1 = int . MinValue ; int min1 = int . MaxValue ; int max2 = int . MinValue ; int min2 = int . MaxValue ; for ( int i = 0 ; i < array . Length ; i ++ ) { max1 = Math . Max ( max1 , array [ i ] + i ) ; min1 = Math . Min ( min1 , array [ i ] + i ) ; max2 = Math . Max ( max2 , array [ i ] - i ) ; min2 = Math . Min ( min2 , array [ i ] - i ) ; } return Math . Max ( max1 - min1 , max2 - min2 ) ; }
int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
int times ( int [ ] steps , int n ) { int current_level = 0 ; int previous_level = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; }
int maxValue ( int [ ] a , int n , int pos , int moves , int left , int [ , ] dp ) { if ( moves == 0 || ( pos > n - 1 pos < 0 ) ) return 0 ; if ( dp [ pos , left ] != - 1 ) return dp [ pos , left ] ; int value = 0 ; if ( left > 0 && pos >= 1 ) value = Math . Max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) ; if ( pos <= n - 1 ) value = Math . Max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) ; return dp [ pos , left ] = value ; }
bool checkLuhn ( String cardNo ) { int nDigits = cardNo . Length ; int nSum = 0 ; bool isSecond = false ; for ( int i = nDigits - 1 ; i >= 0 ; i -- ) { int d = cardNo [ i ] - '0' ; if ( isSecond == true ) d = d * 2 ; nSum += d / 10 ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; }
int maxiConsecutiveSubarray ( int [ ] arr , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . Max ( maxi , cnt ) ; i = j ; } return maxi ; }
bool isAnyNotPalindrome ( String s ) { HashSet < char > unique = new HashSet < char > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) unique . Add ( s [ i ] ) ; if ( unique . Count > 1 ) return true ; else return false ; }
int lastDigitFactorial ( int n ) { if ( n == 0 ) return 1 ; else if ( n <= 2 ) return n ; else if ( n == 3 ) return 6 ; else if ( n == 4 ) return 4 ; else return 0 ; }
int findCount ( string s , int n , int a , int b ) { int res = 0 ; for ( int i = 0 ; i < b ; i ++ ) { if ( i == a ) { if ( s [ n - i - 1 ] != '1' ) res += 1 ; } else { if ( s [ n - i - 1 ] != '0' ) res += 1 ; } } return res ; }
int CountWays ( int N , int M ) { int count = 1 ; count = ( int ) Math . Pow ( 3 , M + N ) ; count *= ( int ) Math . Pow ( 2 , M * N ) ; return count ; }
void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { Console . WriteLine ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }
void minimumCost ( int [ ] cost , int n , int x ) { int [ ] dp = new int [ n + 2 ] ; dp [ 0 ] = cost [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + Math . Min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + Math . Min ( dp [ i - 1 ] , Math . Min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } Console . WriteLine ( dp [ n - 1 ] ) ; }
int nthElement ( int a , int b , int n ) { ArrayList seq = new ArrayList ( ) ; for ( int i = 1 ; i <= n ; i ++ ) seq . Add ( a * i ) ; seq . Sort ( ) ; for ( int i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . Contains ( b * i ) ) { seq . Add ( b * i ) ; seq . Sort ( ) ; k -- ; } } return ( int ) seq [ n - 1 ] ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
double findIndex ( int n ) { double x = Math . Sqrt ( 2 * Math . Pow ( 10 , ( n - 1 ) ) ) ; return Math . Round ( x ) ; }
void LCMPairs ( int [ ] arr , int N ) { int total_pairs = ( N * ( N - 1 ) ) / 2 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; Console . Write ( " Even ▁ = ▁ " + ( total_pairs - odd ) + " , ▁ Odd ▁ = ▁ " + odd ) ; }
void PrintMinNumberForPattern ( String seq ) { String result = " " ; Stack stk = new Stack ( ) ; for ( int i = 0 ; i <= seq . Length ; i ++ ) { stk . Push ( i + 1 ) ; if ( i == seq . Length seq [ i ] == ' I ' ) { while ( stk . Count != 0 ) { result += String . Join ( " " , stk . Peek ( ) ) ; result += " ▁ " ; stk . Pop ( ) ; } } } Console . WriteLine ( result ) ; }
void findpair ( int l , int r ) { int c = 0 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { Console . Write ( i + " , ▁ " + j ) ; c = 1 ; break ; } } if ( c == 1 ) break ; } }
bool isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return true ; return false ; }
bool isSubsetSum ( int [ ] arr , int n , int sum ) { bool [ , ] subset = new bool [ 2 , sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 , j ] = true ; else if ( i == 0 ) subset [ i % 2 , j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 , j ] = subset [ ( i + 1 ) % 2 , j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 , j ] ; else subset [ i % 2 , j ] = subset [ ( i + 1 ) % 2 , j ] ; } } return subset [ n % 2 , sum ] ; }
int maxLen ( int [ ] arr , int n ) { int min_val = arr . Min ( ) ; int freq = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
float ellipse ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float x = ( float ) ( 3.14 * l * b ) / 4 ; return x ; }
void isSequenceValid ( int [ ] B , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { Console . WriteLine ( " No " ) ; return ; } } Console . WriteLine ( " Yes " ) ; }
void makeArray ( int [ ] a , int n ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( i * n + " ▁ " ) ; }
long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
void redistribute ( int [ ] arr , int n , int x ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum / ( i + 1 ) < x ) { Console . Write ( i + " STRNEWLINE " ) ; break ; } } if ( i == n ) Console . Write ( n + " STRNEWLINE " ) ; }
void FindPairs ( int n , int k ) { Console . Write ( 1 + " ▁ " + n + " STRNEWLINE " ) ; k -- ; for ( long i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { Console . Write ( 1 + " ▁ " + i + " STRNEWLINE " ) ; k -- ; if ( k == 0 ) break ; if ( i != n / i ) { Console . Write ( 1 + " ▁ " + n / i + " STRNEWLINE " ) ; k -- ; } if ( k == 0 ) break ; } } }
void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } Console . Write ( N - Count ) ; }
void nearestPowerOfTwo ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int lg = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ; int a = ( int ) ( Math . Pow ( 2 , lg ) ) ; int b = ( int ) ( Math . Pow ( 2 , lg + 1 ) ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) Console . Write ( a + " ▁ " ) ; else Console . Write ( b + " ▁ " ) ; } }
void getPairs ( int [ ] arr , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } Console . Write ( count ) ; }
int min_elimination ( int n , int [ ] arr ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
void printSumSimple ( int [ , ] mat , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p , q ] ; Console . Write ( sum + " ▁ " ) ; } Console . WriteLine ( ) ; } }
int findMin ( int [ ] arr , int N , int k ) { int pairs = 0 ; for ( int i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return - 1 ; else return 2 * k + N - 1 ; }
Boolean canBecomeEmpty ( String str , String sub_str ) { while ( str . Length > 0 ) { int idx = str . IndexOf ( sub_str ) ; if ( idx == - 1 ) { break ; } str = str . Replace ( sub_str , " " ) ; } return ( str . Length == 0 ) ; }
long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; }
int countChars ( string str , int n ) { int i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == '0' ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; }
int minimumChar ( String S1 , String S2 ) { int n = S1 . Length ; int m = S2 . Length ; int ans = Int32 . MaxValue ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . Min ( minRemovedChar , ans ) ; } return ans ; }
int minNumber ( int [ ] a , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
void findkth ( int n , int k ) { List < int > v1 = new List < int > ( ) ; List < int > v2 = new List < int > ( ) ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . Add ( i ) ; if ( i != Math . Sqrt ( n ) ) v2 . Add ( n / i ) ; } } v2 . Reverse ( ) ; if ( k > ( v1 . Count + v2 . Count ) ) Console . Write ( " Doesn ' t ▁ Exist " ) ; else { if ( k <= v1 . Count ) Console . Write ( v1 [ k - 1 ] ) ; else Console . Write ( v2 [ k - v1 . Count - 1 ] ) ; } }
void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] < ' A ' s [ i ] > ' Z ' && s [ i ] < ' a ' s [ i ] > ' z ' ) { s = s . Remove ( i , 1 ) ; i -- ; } } Console . Write ( s ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
void sortSquares ( int [ ] arr ) { int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] * arr [ i ] ; Array . Sort ( arr ) ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; }
int bitwiseOrTillN ( int n ) { int result = 2 ; for ( int i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; }
long center_pentadecagonal_num ( long n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int stringToInt ( String str ) { if ( str . Length == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . Substring ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * Math . Pow ( 10 , str . Length - 1 ) + y ; return ( int ) ( x ) ; }
int evenbitsetnumber ( int n ) { int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
void swap ( int a , int b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; Console . Write ( " After ▁ swapping : ▁ a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b ) ; }
int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
int longestSubarray ( int [ ] arr , int n ) { int maxMean = 0 ; for ( int i = 1 ; i < n ; i ++ ) maxMean = Math . Max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int subarrayLength = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = Math . Max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
int Occurrence ( String s , int position ) { int count = 0 ; for ( int i = 0 ; i < position - 1 ; i ++ ) if ( s [ i ] == s [ position - 1 ] ) count ++ ; return count ; }
long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
int maxCost ( int [ ] a , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = Math . Max ( mx , a [ i ] ) ; int [ ] count = new int [ mx + 1 ] ; for ( int i = 0 ; i < count . Length ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . Min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = Math . Max ( num - l - 1 , 0 ) ; res [ num ] = Math . Max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
void printMaxOfMin ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = int . MinValue ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } Console . Write ( maxOfMin + " ▁ " ) ; } }
int addOne ( int x ) { return ( - ( ~ x ) ) ; }
void nDigitPerfectSquares ( int n ) { int smallest = ( int ) Math . Pow ( Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n - 1 ) ) ) , 2 ) ; Console . Write ( smallest + " ▁ " ) ; int largest = ( int ) Math . Pow ( Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n ) ) ) - 1 , 2 ) ; Console . Write ( largest ) ; }
void nearestPerfectSquare ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = ( int ) Math . Sqrt ( arr [ i ] ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) Console . Write ( a + " ▁ " ) ; else Console . Write ( b + " ▁ " ) ; } }
int countPS ( string str ) { int N = str . Length ; int [ , ] cps = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i , i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( k < N ) { if ( str [ i ] == str [ k ] ) cps [ i , k ] = cps [ i , k - 1 ] + cps [ i + 1 , k ] + 1 ; else cps [ i , k ] = cps [ i , k - 1 ] + cps [ i + 1 , k ] - cps [ i + 1 , k - 1 ] ; } } } return cps [ 0 , N - 1 ] ; }
int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }
void isCycleExists ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { Console . WriteLine ( " Yes " ) ; return ; } } Console . WriteLine ( " No " ) ; }
int countDigitsToBeRemoved ( int N , int K ) { string s = Convert . ToString ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . Length - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K == 0 ) return res ; else if ( f_zero == 1 ) return s . Length - 1 ; return - 1 ; }
int longestSubArray ( int [ ] arr , int n ) { bool isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
bool check ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { return true ; } } return false ; }
void areSame ( int a , int b ) { if ( ( a - b ) == 0 ) Console . Write ( " Same " ) ; else Console . Write ( " Not ▁ Same " ) ; }
int count ( int n ) { return ( int ) ( 15 * Math . Pow ( 16 , n - 1 ) ) ; }
int solve ( int n , int k , int mod , int [ ] dp ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; int cnt = 0 ; for ( int i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; }
int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool [ ] marked = new bool [ nNew + 1 ] ; for ( int i = 0 ; i < nNew + 1 ; i ++ ) marked [ i ] = false ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) Console . Write ( 2 + " ▁ " ) ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) Console . Write ( 2 * i + 1 + " ▁ " ) ; return - 1 ; }
int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; }
int seriesSum ( int n ) { int sum = 0 ; int currProd = 1 ; int currSum = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; }
Boolean IsPrime ( int i ) { if ( i % 2 == 0 && i != 2 ) return false ; else { for ( int j = 3 ; j <= Math . Sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) return false ; } return true ; } }
void equal_xor_sum ( int [ ] arr , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
int maxSum ( int [ ] arr , int n ) { int sum = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
void countOfSubarray ( int [ ] arr , int N ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int answer = 0 ; int sum = 0 ; mp [ 1 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( mp . ContainsKey ( sum - i ) ) answer += mp [ sum - i ] ; if ( mp . ContainsKey ( sum - 1 ) ) mp [ sum - 1 ] ++ ; else mp [ sum - 1 ] = 1 ; } Console . Write ( answer - 2 ) ; }
void generateString ( int K ) { string s = " " ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + ( char ) ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += ( char ) ( i ) ; s += ( char ) ( j ) ; } } s += ( char ) ( 97 ) ; Console . Write ( s ) ; }
int totalCircles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; }
int countQuadruples ( int [ ] A , int N ) { int ans = 0 ; Dictionary < int , int > freq = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . ContainsKey ( A [ i ] ) ) ans += freq [ A [ i ] ] ; else freq . Add ( A [ i ] , 0 ) ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { if ( freq . ContainsKey ( A [ i ] * A [ j ] * A [ k ] ) ) freq [ A [ i ] * A [ j ] * A [ k ] ] ++ ; else freq . Add ( A [ i ] * A [ j ] * A [ k ] , 1 ) ; } } } return ans ; }
String LexicographicalMaxString ( String str ) { String mx = " " ; for ( int i = 0 ; i < str . Length ; ++ i ) { if ( mx . CompareTo ( str . Substring ( i ) ) <= 0 ) { mx = str . Substring ( i ) ; } } return mx ; }
void leastBricks ( List < List < int > > wall ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int res = 0 ; foreach ( List < int > subList in wall ) { int width = 0 ; for ( int i = 0 ; i < subList . Count - 1 ; i ++ ) { width += subList [ i ] ; if ( map . ContainsKey ( width ) ) map [ width ] ++ ; else map . Add ( width , 1 ) ; res = Math . Max ( res , map [ width ] ) ; } } Console . Write ( wall . Count - res ) ; }
void findFactors ( int a , int b ) { int c ; c = a + b - 1 ; Console . Write ( c ) ; }
int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; }
void lexNumbers ( int n ) { List < String > s = new List < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . Add ( String . Join ( " " , i ) ) ; } s . Sort ( ) ; List < int > ans = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . Add ( Int32 . Parse ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ans [ i ] + " ▁ " ) ; }
int calcScore ( String str ) { int score = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; ) { int chunkSize = 1 ; char currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == '1' ) score += ( int ) Math . Pow ( chunkSize , 2 ) ; else score -= ( int ) Math . Pow ( chunkSize , 2 ) ; } return score ; }
int countNestedPolygons ( int sides ) { int count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
int minCount ( int [ ] arr , int n , int k ) { int ans = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; int l = 0 ; int r = 0 ; int tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = Math . Max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
void printORSumforEachElement ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int req_sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { req_sum += ( arr [ i ] arr [ j ] ) ; } Console . Write ( req_sum + " ▁ " ) ; } }
int countPairs ( int A , int B ) { int countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; }
int subsetXOR ( int [ ] arr , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . Log ( max_ele , 2 ) + 1 ) ) - 1 ; if ( k > m ) { return 0 ; } int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i , j ] = 0 ; dp [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 1 , j ^ arr [ i - 1 ] ] ; return dp [ n , k ] ; }
void tripletAndSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } Console . WriteLine ( ans ) ; }
int maxProfit ( int [ ] arr ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( ( arr [ i ] - ( 1 * i ) ) > 0 ) ans += ( arr [ i ] - ( 1 * i ) ) ; if ( ( arr [ i ] - ( 1 * i ) ) == 0 ) break ; } return ans ; }
int findCycles ( int N ) { int res = 0 ; int finalResult = 0 ; int val = 2 * N - 1 ; int s = val ; res = ( N - 1 ) * ( N - 2 ) ; finalResult = res + s ; return finalResult ; }
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( h * r * ( float ) Math . Sqrt ( 2 ) ) / ( h + ( float ) Math . Sqrt ( 2 ) * r ) ; return a ; }
int minFlips ( int [ , ] mat , String s ) { int N = mat . GetLength ( 0 ) ; int M = mat . GetLength ( 1 ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i , j ] != s [ i + j ] - '0' ) { count ++ ; } } } return count ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
void diameter ( double r ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " + " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " + 2 * r ) ; }
int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; }
void printMedian ( int [ ] arr , int n , int K ) { Array . Sort ( arr ) ; Console . Write ( arr [ ( n + K ) / 2 ] ) ; }
int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
void generate_derangement ( int N ) { int [ ] S = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int [ ] D = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( D [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; }
void PossibleValues ( int b , int x , int n ) { int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { Console . Write ( leastdivisible - b + " ▁ " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) Console . WriteLine ( - 1 ) ; }
int longestEvenOddSubarray ( int [ ] a , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = Math . Max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return Math . Max ( cnt , longest ) ; }
int LCIS ( int [ ] arr1 , int n , int [ ] arr2 , int m ) { int [ ] table = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
int lds ( int [ ] arr , int n ) { int [ ] lds = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
long F ( long A , long B ) { if ( A == 1 ) return ( 4 % B ) ; else { long temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
double get_concentration ( double mass , double volume ) { if ( volume == 0 ) return - 1 ; else return ( mass / volume ) * 1000 ; }
int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
bool check_order ( int [ ] arr ) { int cnt = 0 ; for ( int i = 0 ; i < arr . Length - 1 ; i ++ ) { if ( Math . Abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( Math . Abs ( arr [ 0 ] - arr [ arr . Length - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; }
float trianglearea ( float r ) { if ( r < 0 ) return - 1 ; return r * r ; }
string isDivisibleByDivisor ( int S , int D ) { S %= D ; List < int > hashMap = new List < int > ( ) ; ; hashMap . Add ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . Contains ( S ) ) { if ( S == 0 ) { return " Yes " ; } return " No " ; } else hashMap . Add ( S ) ; } return " Yes " ; }
double area_of_tetrahedron ( int side ) { return ( Math . Sqrt ( 3 ) * ( side * side ) ) ; }
int findInGrid ( int i , int j ) { if ( i == j ) return ( i * i - ( i - 1 ) ) ; else if ( i > j ) { if ( i % 2 == 0 ) return i * i - ( j - 1 ) ; else return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ; } else { if ( j % 2 == 0 ) return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ; else return j * j - ( i - 1 ) ; } }
int findBucketNo ( int p ) { return ( int ) Math . Ceiling ( ( Math . Sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
int countCrossLine ( int [ ] arr , int n ) { int count_crossline = 0 ; int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
int maxOnesIndex ( int [ ] arr , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
int distinctSubString ( String P , int N ) { HashSet < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { bool [ ] freq = new bool [ 26 ] ; String s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; if ( freq [ pos ] == true ) break ; freq [ pos ] = true ; s += P [ j ] ; S . Add ( s ) ; } } return S . Count ; }
void flippingBits ( int N , int K ) { int X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; Console . Write ( N ) ; }
bool check ( String str ) { int n = str . Length ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - '0' ) * 100 + ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; int fourth_last = str [ n - 4 ] - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
int minCountOfNumbers ( int N ) { int k = N % 10 ; int z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else return - 1 ; }
void factorsOf3 ( int [ ] arr , int N ) { int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 3 == 0 ) a ++ ; else if ( arr [ i ] % 3 == 1 ) b ++ ; else if ( arr [ i ] % 3 == 2 ) c ++ ; } if ( a >= 1 && a <= b + c + 1 ) Console . Write ( " Yes " + " STRNEWLINE " ) ; else if ( a == 0 && b == 0 && c > 0 ) Console . Write ( " Yes " + " STRNEWLINE " ) ; else if ( a == 0 && c == 0 && b > 0 ) Console . Write ( " Yes " + " STRNEWLINE " ) ; else Console . Write ( " No " + " STRNEWLINE " ) ; }
void getParity ( int n , int [ ] A ) { foreach ( int x in A ) { if ( ( x & 1 ) == 1 ) { Console . WriteLine ( " Even " ) ; return ; } } Console . WriteLine ( " Odd " ) ; }
int findsubArray ( int [ ] arr , int N , int K ) { int res = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { int curr_prod = 1 ; for ( int j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = Math . Min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
int sumOfSeries ( int n ) { int ans = ( int ) Math . Pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
int digSum ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; }
int countChar ( string str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( str [ i ] == x ) count ++ ; int repetitions = n / str . Length ; count = count * repetitions ; for ( int i = 0 ; i < n % str . Length ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; }
int countPairs ( int [ ] arr , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; int res = 0 ; foreach ( KeyValuePair < int , int > x in map ) { int cnt = x . Value ; res += ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } return res ; }
int numOfWays ( int [ , ] a , int n , int i , HashSet < int > blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i , j ] == 1 && ! blue . Contains ( j ) ) { blue . Add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . Remove ( j ) ; } } return count ; }
int maximum_middle_value ( int n , int k , int [ ] arr ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . Max ( ans , arr [ i - 1 ] ) ; } return ans ; }
void pendulumArrangement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int [ ] op = new int [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; Console . Write ( " Pendulum ▁ arrangement : " ) ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( op [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; }
int solve ( double M , double N , double s ) { int ans = ( ( int ) ( Math . Ceiling ( M / s ) ) * ( int ) ( Math . Ceiling ( N / s ) ) ) ; return ans ; }
char maxRepeating ( string str ) { int n = str . Length ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
int No_of_Triangle ( int N , int K ) { if ( N < K ) return - 1 ; else { int Tri_up = 0 ; Tri_up = ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ; int Tri_down = 0 ; Tri_down = ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ; return Tri_up + Tri_down ; } }
void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { Console . Write ( " A ▁ = ▁ " + A / 3 + " , ▁ B ▁ = ▁ " + B + " , ▁ C ▁ = ▁ " + C ) ; return ; } } } Console . WriteLine ( - 1 ) ; }
int maxSum ( int [ ] arr , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . Max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
int maxFreq ( string s , int a , int b ) { int [ ] fre = new int [ 10 ] ; int n = s . Length ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - '0' ] ++ ; if ( fre [ a ] == 0 && fre [ b ] == 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
int minOperation ( string s , int i , int j , int count ) { if ( ( i >= s . Length && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] ) return count ; if ( i >= s . Length ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return Math . Min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; }
bool isMajorityElement ( int [ ] arr , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; }
void findSquareSum ( int [ , ] Coordinates , int N ) { long xq = 0 , yq = 0 ; long xs = 0 , ys = 0 ; long res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int a , b ; a = Coordinates [ i , 0 ] ; b = Coordinates [ i , 1 ] ; res += xq ; res -= 2 * xs * a ; res += i * ( long ) ( a * a ) ; xq += a * a ; xs += a ; res += yq ; res -= 2 * ys * b ; res += i * ( long ) b * b ; yq += b * b ; ys += b ; } Console . Write ( res ) ; }
int isvalid ( int s ) { double k = ( - 1.0 + Math . Sqrt ( 1 + 8 * s ) ) / 2 ; if ( Math . Ceiling ( k ) == Math . Floor ( k ) ) return ( int ) k ; else return - 1 ; }
bool isicosihenagonal ( int N ) { float n = ( float ) ( ( 17 + Math . Sqrt ( 152 * N + 289 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; }
int countPairs ( int [ ] arr , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; }
int countPairs ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; }
int getPairs ( int [ ] a ) { int count = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { for ( int j = 0 ; j < a . Length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; }
int icosidigonal_num ( int n ) { return ( 20 * n * n - 18 * n ) / 2 ; }
long findMinCost ( int [ ] a , int k , int n ) { int max_ele = a . Max ( ) ; long [ ] dp = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) dp [ i ] = int . MaxValue ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int [ ] freq = new int [ max_ele + 1 ] ; for ( int j = i ; j < n ; ++ j ) { freq [ a [ j ] ] ++ ; int cost = 0 ; for ( int x = 0 ; x <= max_ele ; ++ x ) { cost += ( freq [ x ] == 1 ) ? 0 : freq [ x ] ; } dp [ j + 1 ] = Math . Min ( dp [ i ] + cost + k , dp [ j + 1 ] ) ; } } return dp [ n ] ; }
int countOnes ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
void findMaxValue ( int N , int K ) { int packages ; int maxi = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = Math . Max ( maxi , i ) ; } packages = N / maxi ; Console . WriteLine ( packages ) ; }
bool isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }
int countWays ( string s ) { int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; count [ s [ 0 ] - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
void parallel ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } }
int Balanced_Substring ( String str , int n ) { int ans = 0 ; int [ ] arr = new int [ n / 2 + 1 ] ; int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) d ++ ; else { if ( d == 1 ) { for ( int j = 2 ; j <= n / 2 + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; }
void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . Pow ( 10 , temp ) ; palindrome += n - 1 ; Console . Write ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { Console . Write ( palindrome % 10 ) ; palindrome /= 10 ; } Console . WriteLine ( " " ) ; }
long firstkdigits ( int n , int k ) { long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / Math . Pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; }
void waysToPaint ( int n ) { long same = 6 ; long diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } Console . WriteLine ( same + diff ) ; }
double calculate_angle ( double n ) { double total_angle = 360 ; return total_angle / n ; }
int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; }
void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) Console . Write ( i + " ▁ " ) ; }
int countWords ( string str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
int count ( int n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; int [ ] table = new int [ n + 1 ] ; int i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
void print ( String str1 ) { char [ ] str = str1 . ToCharArray ( ) ; Console . Write ( str [ 0 ] ) ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( ( str [ i ] == str [ i - 1 ] + 1 ) || ( str [ i ] == str [ i - 1 ] - 1 ) ) { Console . Write ( str [ i ] ) ; } else { Console . Write ( " STRNEWLINE " + str [ i ] ) ; } } }
void findBalance ( int x , float bal ) { if ( x % 10 == 0 && ( ( float ) x + 1.50 ) <= bal ) { Console . Write ( " { 0 : F2 } STRNEWLINE " , bal - x - 1.50 ) ; } else { Console . Write ( " { 0 : F2 } STRNEWLINE " , bal ) ; } }
void findMinAvgSubarray ( int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } Console . Write ( " Subarray ▁ between ▁ [ " + res_index + " , ▁ " + ( res_index + k - 1 ) + " ] ▁ has ▁ minimum ▁ average " ) ; }
int minCut ( string a ) { int [ ] cut = new int [ a . Length ] ; bool [ , ] palindrome = new bool [ a . Length , a . Length ] ; for ( int i = 0 ; i < a . Length ; i ++ ) { int minCut = i ; for ( int j = 0 ; j <= i ; j ++ ) { if ( a [ i ] == a [ j ] && ( i - j < 2 palindrome [ j + 1 , i - 1 ] ) ) { palindrome [ j , i ] = true ; minCut = Math . Min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . Length - 1 ] ; }
int countSequences ( int [ ] arr , int n ) { int count = 1 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
void precompute ( string s , string K ) { int n = s . Length ; for ( int i = 0 ; i < n - 2 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] ; if ( s . Substring ( i , K . Length ) . Equals ( K ) ) { cnt [ i + 1 ] += 1 ; } } cnt [ n - 2 + 1 ] = cnt [ n - 2 ] ; }
void solve ( int n ) { int n_2 = n / 2 ; String den ; den = "1" ; while ( n_2 -- > 0 ) den += '0' ; Console . WriteLine ( 1 + " / " + den ) ; }
void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
float find ( int N , int sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N , sum ] > 0 ) return dp [ N , sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( float ) ( 1.0 / 6 ) ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N , sum ] = dp [ N , sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N , sum ] ; }
double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = ( Math . PI / 180 ) * ( lat2 - lat1 ) ; double dLon = ( Math . PI / 180 ) * ( lon2 - lon1 ) ; lat1 = ( Math . PI / 180 ) * ( lat1 ) ; lat2 = ( Math . PI / 180 ) * ( lat2 ) ; double a = Math . Pow ( Math . Sin ( dLat / 2 ) , 2 ) + Math . Pow ( Math . Sin ( dLon / 2 ) , 2 ) * Math . Cos ( lat1 ) * Math . Cos ( lat2 ) ; double rad = 6371 ; double c = 2 * Math . Asin ( Math . Sqrt ( a ) ) ; return rad * c ; }
int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
long countWays ( int n ) { long [ , ] dp = new long [ 2 , n + 1 ] ; dp [ 0 , 1 ] = 1 ; dp [ 1 , 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 , i ] = dp [ 0 , i - 1 ] + dp [ 1 , i - 1 ] ; dp [ 1 , i ] = dp [ 0 , i - 1 ] * 2 + dp [ 1 , i - 1 ] ; } return dp [ 0 , n ] + dp [ 1 , n ] ; }
void rad ( double d , double h ) { Console . WriteLine ( " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; }
int findMissing ( int [ ] arr , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return - 1 ; return ( int ) ( num / den ) ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; HashSet < int > us = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) us . Add ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . Contains ( x - arr2 [ j ] ) ) count ++ ; return count ; }
int findCount ( int [ ] arr , int n ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { count ++ ; } else { ans = ans + count ; } } return ans ; }
String flip ( char [ ] s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { while ( s [ i ] == '0' ) { s [ i ] = '1' ; i ++ ; } break ; } } return new String ( s ) ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
bool isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
int binarySearch ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
void printModulus ( int X , int Y ) { int n = Math . Max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) Console . Write ( i + " ▁ " ) ; } }
int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
int maxGCD ( int n ) { return ( n / 2 ) ; }
int stirlingFactorial ( double n ) { if ( n == 1 ) return 1 ; double z ; z = System . Math . Sqrt ( 2 * 3.14 * n ) * System . Math . Pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; }
int firstDigit ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; }
void missing4 ( int [ ] arr ) { int [ ] helper = new int [ 4 ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) { int temp = Math . Abs ( arr [ i ] ) ; if ( temp <= arr . Length ) arr [ temp - 1 ] *= ( - 1 ) ; else if ( temp > arr . Length ) { if ( temp % arr . Length != 0 ) helper [ temp % arr . Length - 1 ] = - 1 ; else helper [ ( temp % arr . Length ) + arr . Length - 1 ] = - 1 ; } } for ( int i = 0 ; i < arr . Length ; i ++ ) if ( arr [ i ] > 0 ) Console . Write ( i + 1 + " ▁ " ) ; for ( int i = 0 ; i < helper . Length ; i ++ ) if ( helper [ i ] >= 0 ) Console . Write ( arr . Length + i + 1 + " ▁ " ) ; return ; }
int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . Min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
int maxORminusXOR ( int N ) { int MSB = ( int ) Math . Ceiling ( Math . Log ( N ) ) ; int M = 0 ; for ( int i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; }
void countXorPartition ( int N ) { double a = Math . Pow ( 2 , ( int ) ( N - Math . Log ( N + 1 ) / Math . Log ( 2 ) ) ) ; Console . Write ( a ) ; }
void record_sum ( int [ ] record , int l , int r , int n , int adder ) { for ( int i = l ; i <= r ; i ++ ) { record [ i ] += adder ; } }
int calculateTriangles ( int [ ] sides ) { double count = Math . Pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= Math . Pow ( sides [ 0 ] , 2 ) ; count -= Math . Pow ( sides [ 2 ] , 2 ) ; count -= Math . Pow ( sides [ 4 ] , 2 ) ; return ( int ) ( count ) ; }
double polyapothem ( double n , double a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . Tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
int oddSum ( int n ) { return ( n * n ) ; }
int difference ( int [ , ] arr , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i , j ] ; if ( i == n - j - 1 ) d2 += arr [ i , j ] ; } } return Math . Abs ( d1 - d2 ) ; }
float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; float x = r ; float V = ( float ) ( 4 * 3.14f * Math . Pow ( r , 3 ) ) / 3 ; return V ; }
int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + ( n ^ x ) ) ++ c ; return c ; }
long LastTwoDigit ( long num ) { long one = num % 10 ; num /= 10 ; long tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
void printCase ( int n ) { if ( n <= 2 ) { Console . Write ( - 1 ) ; return ; } for ( int i = n ; i >= 1 ; i -- ) Console . Write ( i + " ▁ " ) ; }
int length_substring ( string S , char K ) { int curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( int i = 0 ; i < S . Length ; i ++ ) { if ( S [ i ] == K ) { curr_cnt += 1 ; } else { prev_cnt = Math . Max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = Math . Max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; }
void findMaxNumbers ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int opr = ( int ) Math . Ceiling ( ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } Console . Write ( cnt ) ; }
int minStepToDeleteString ( string str ) { int N = str . Length ; int [ , ] dp = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i , j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i , j ] = 1 ; else { dp [ i , j ] = 1 + dp [ i + 1 , j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i , j ] = Math . Min ( 1 + dp [ i + 2 , j ] , dp [ i , j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i , j ] = Math . Min ( dp [ i + 1 , K - 1 ] + dp [ K + 1 , j ] , dp [ i , j ] ) ; } } } return dp [ 0 , N - 1 ] ; }
int findDistinctSums ( int n ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . Add ( i + j ) ; } } return s . Count ; }
void checkSumOfNatural ( int n ) { int i = 1 ; bool flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = ( int ) Math . Sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; }
int substrDeletion ( string str , int len ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count0 ++ ; else count1 ++ ; } return Math . Min ( count0 , count1 ) ; }
int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) ( 7 * Math . Pow ( 8 , i - 1 ) ) ; } return sum ; }
long findSum ( int n ) { long sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }
int maxConsecutiveRope ( int [ ] ropes , int N ) { int curSize = 0 ; Array . Sort ( ropes ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ropes [ i ] <= curSize + 1 ) { curSize = curSize + ropes [ i ] ; } else break ; } return curSize ; }
int FirstDigit ( int [ ] arr , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . Log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . Floor ( S ) ; int ans = ( int ) Math . Pow ( 10 , fract_S ) ; return ans ; }
int count ( String N , int X , String subStr , int index , int n ) { if ( index == n ) return 0 ; String a = subStr + N [ index ] ; int b = 0 ; if ( long . Parse ( a ) % X == 0 ) b = 1 ; int m1 = count ( N , X , a , index + 1 , n ) ; int m2 = b + count ( N , X , " " , index + 1 , n ) ; return Math . Max ( m1 , m2 ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int MinRemove ( int [ ] a , int n , int k ) { int [ ] cnt = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }
bool isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( Math . Ceiling ( a ) == 1 && Math . Floor ( a ) == 1 ) return true ; return false ; }
int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
void compute ( int [ ] query ) { int [ ] v = new int [ 100001 ] ; int [ ] dp = new int [ 100001 ] ; v [ 1 ] = 1 ; v [ 2 ] = 0 ; dp [ 1 ] = 0 ; dp [ 2 ] = 0 ; for ( int i = 3 ; i < 100001 ; i ++ ) { if ( i % 2 != 0 ) { if ( ( i / 2 ) % 2 == 0 ) { v [ i ] = 1 ; dp [ i ] = dp [ i - 1 ] ; } else { v [ i ] = v [ i / 2 ] + 1 ; dp [ i ] = dp [ i - 1 ] + v [ i ] - 1 ; } } else { v [ i ] = 0 ; dp [ i ] = dp [ i - 1 ] ; } } foreach ( int x in query ) Console . Write ( dp [ x ] + " STRNEWLINE " ) ; }
int remainder ( string str ) { int len = str . Length ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; }
int minsteps ( int n , int m ) { if ( m > n ) { return - 1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
void minModulo ( int L , int R , int N ) { if ( R - L < N ) { int ans = Int32 . MaxValue ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( i != j ) ans = Math . Min ( ans , ( i * j ) % N ) ; Console . WriteLine ( ans ) ; } else { Console . WriteLine ( 0 ) ; } }
int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }
bool isPanalphabeticWindow ( string s , int n ) { char ch = ' a ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch ++ ; if ( ch == ' z ' + 1 ) return true ; } return false ; }
void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { Console . Write ( fact + " ▁ " ) ; fact = fact * x ; x ++ ; } }
int minimum_sum ( int n , int k ) { if ( k % n == 0 ) return 0 ; return 1 ; }
int calculateSum ( int n ) { return ( ( int ) Math . Pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / ( int ) Math . Pow ( 9 , 3 ) - n * ( n + 1 ) / 18 ; }
void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { Console . WriteLine ( " NO " ) ; return ; } double a = ( N + Math . Sqrt ( val ) ) / 2.0 ; double b = ( N - Math . Sqrt ( val ) ) / 2.0 ; Console . WriteLine ( " a ▁ = ▁ " + a ) ; Console . WriteLine ( " b ▁ = ▁ " + b ) ; }
void findSymPairs ( int [ , ] arr ) { Dictionary < int , int > hM = new Dictionary < int , int > ( ) ; int val = 0 ; for ( int i = 0 ; i < arr . GetLength ( 0 ) ; i ++ ) { int first = arr [ i , 0 ] ; int sec = arr [ i , 1 ] ; if ( hM . ContainsKey ( sec ) ) val = hM [ sec ] ; if ( val != 0 && val == first ) Console . WriteLine ( " ( " + sec + " , ▁ " + first + " ) " ) ; else hM . Add ( first , sec ) ; } }
void isEqualSubstring ( string str , int x ) { int n = str . Length ; int i = 0 ; while ( i < n && i < x ) { if ( str [ i ] != str [ n - i - 1 ] ) { Console . Write ( " false " ) ; return ; } i ++ ; } Console . Write ( " true " ) ; }
void evenproduct ( int [ ] arr , int length ) { int count = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { int product = 1 ; for ( int j = i ; j < arr . Length ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } Console . WriteLine ( count ) ; }
int find_index ( int [ ] arr , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
int getValue ( int [ ] arr , int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int min = arr [ i ] ; int max = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { min = Math . Min ( arr [ j ] , min ) ; max = Math . Max ( arr [ j ] , max ) ; dp [ i ] = Math . Max ( dp [ i ] , max - min + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; }
int GIF ( double n ) { return ( int ) Math . Floor ( n ) ; }
bool check ( int [ ] a , int n ) { bool flag = false ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = true ; } if ( flag ) return false ; else return true ; }
int maxLength ( int [ ] a , int n ) { int maxLen = 0 ; int prev_cnt = 0 , curr_cnt = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = Math . Max ( maxLen , Math . Min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; }
int MinDistK ( int [ ] arr , int N , int K ) { int res = Int32 . MaxValue ; int dist = 0 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = Math . Max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = Math . Abs ( arr [ i ] ) + Math . Abs ( arr [ i + K - 1 ] ) + Math . Min ( Math . Abs ( arr [ i ] ) , Math . Abs ( arr [ i + K - 1 ] ) ) ; } res = Math . Min ( res , dist ) ; } return res ; }
int search ( int [ ] arr , int x ) { int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
int count ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; }
int smallestSumSubarr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = Math . Max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . Max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; }
void conVowUpp ( char [ ] str ) { int N = str . Length ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { char c = char . ToUpperInvariant ( str [ i ] ) ; str [ i ] = c ; } } foreach ( char c in str ) Console . Write ( c ) ; }
long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
int minOperations ( int [ ] a , int [ ] b , int n ) { int minA = a . Max ( ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = true ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; }
string even_or_odd ( string N ) { int len = N . Length ; if ( N [ len - 1 ] == '0' N [ len - 1 ] == '2' N [ len - 1 ] == '4' N [ len - 1 ] == '6' N [ len - 1 ] == '8' N [ len - 1 ] == ' A ' N [ len - 1 ] == ' C ' N [ len - 1 ] == ' E ' ) return ( " Even " ) ; else return ( " Odd " ) ; }
void find_sum_of_two_squares ( int a , int b ) { int ab = a * b ; for ( int i = 0 ; i * i <= ab ; i ++ ) { for ( int j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) Console . Write ( i + " ^ 2 ▁ + ▁ " + j + " ^ 2 ▁ = ▁ " + ab + " STRNEWLINE " ) ; } } }
bool isOctadecagon ( int N ) { double n = ( 14 + Math . Sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - ( int ) n ) == 0 ; }
int minimumCostOfBreaking ( int [ ] X , int [ ] Y , int m , int n ) { int res = 0 ; Array . Sort < int > ( X , new Comparison < int > ( ( i1 , i2 ) => i2 . CompareTo ( i1 ) ) ) ; Array . Sort < int > ( Y , new Comparison < int > ( ( i1 , i2 ) => i2 . CompareTo ( i1 ) ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return Math . Sqrt ( r ) ; }
int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
void smallestNumber ( int N ) { Console . Write ( N * Math . Floor ( ( Math . Pow ( 10 , N ) - 1 ) / N ) ) ; }
int maxDiff ( int [ ] arr , int n ) { int maxDiff = - 1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
void printDiagonalSums ( int [ , ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i , i ] ; secondary += mat [ i , n - i - 1 ] ; } Console . WriteLine ( " Principal ▁ Diagonal : " + principal ) ; Console . WriteLine ( " Secondary ▁ Diagonal : " + secondary ) ; }
int MaxXOR ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; }
bool checkFittingArrays ( int [ ] A , int [ ] B , int N ) { Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
void Main ( String [ ] args ) { String str = " geeksforgeeks " ; Console . WriteLine ( removeDuplicatesFromString ( str ) ) ; } }
double AreaofRectangle ( int L , int W ) { double area = ( W + L ) * ( W + L ) / 2 ; return area ; }
int TotalXorPair ( int [ ] arr , int N ) { int totalXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; }
int numberOfWays ( int x ) { int [ ] dp = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . Log ( n ) / Math . Log ( 10 ) ) ; int [ ] a = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . Ceiling ( Math . Pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . Ceiling ( Math . Pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
int countP ( int n , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 , k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i , j ] = 1 ; else dp [ i , j ] = j * dp [ i - 1 , j ] + dp [ i - 1 , j - 1 ] ; return dp [ n , k ] ; }
void checkPalindrome ( int num ) { String str = num . ToString ( ) ; int l = 0 , r = str . Length - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { Console . Write ( " No " ) ; return ; } l ++ ; r -- ; } Console . Write ( " Yes " ) ; return ; }
void countNumbers ( int n , int d ) { int total = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } Console . WriteLine ( total ) ; }
int count ( int N , int B ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) ( ( B - 1 ) * Math . Pow ( B , i - 1 ) ) ; } return sum ; }
void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; Console . Write ( real + " ▁ + ▁ " + imag + " i " ) ; }
void leftRotate ( int [ ] arr , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) Console . Write ( arr [ i % n ] + " ▁ " ) ; }
void removeSpecialCharacter ( String str ) { char [ ] s = str . ToCharArray ( ) ; int j = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } Console . WriteLine ( String . Join ( " " , s ) . Substring ( 0 , j ) ) ; }
void convertToASCII ( int N ) { String num = N . ToString ( ) ; foreach ( char ch in num . ToCharArray ( ) ) { Console . Write ( ch + " ▁ ( " + ( int ) ch + " ) STRNEWLINE " ) ; } }
int minOperation ( int [ ] arr ) { int minOp = int . MinValue ; int minNeg = 0 , maxPos = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return Math . Abs ( minNeg ) + maxPos ; }
int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; Dictionary < char , int > m = new Dictionary < char , int > ( ) ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] && str [ i ] <= r ) ) { cnt ++ ; if ( ! m . ContainsKey ( str [ i ] ) ) { m [ str [ i ] ] = 0 ; Console . Write ( str [ i ] + " ▁ " ) ; } m [ str [ i ] ] ++ ; } } return cnt ; }
int truncMod ( int a , int n ) { int q = a / n ; return a - n * q ; }
int maxPrimes ( int n ) { return n / 2 ; }
int CountMaximum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
int squareSum ( int n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
void alter ( long x , long y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } Console . WriteLine ( " X ▁ = ▁ " + x + " , ▁ " + " Y ▁ = ▁ " + y ) ; }
bool is_possible ( String s ) { int l = s . Length ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . Abs ( one - zero ) == 1 ) ; }
int MinOfCubedDP ( int k ) { int [ ] DP = new int [ k + 1 ] ; int j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = int . MaxValue ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
float gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . Abs ( b ) < 0.001 ) return ( float ) a ; else return ( float ) ( gcd ( b , a - Math . Floor ( a / b ) * b ) ) ; }
void printMaxSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . Sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( dp [ i ] + " ▁ " ) ; }
int singleelement ( int [ ] arr , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; }
int nthTerm ( int n ) { return 4 * ( int ) Math . Pow ( n , 2 ) - 7 * n + 3 ; }
int CountSubSet ( int [ ] arr , int n , int X ) { int N = ( int ) Math . Pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
int reachTarget ( int target ) { target = Math . Abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
void findMaxGuests ( int [ ] arrl , int [ ] exit , int n ) { Array . Sort ( arrl ) ; Array . Sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } Console . Write ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + max_guests + " ▁ at ▁ time ▁ " + time ) ; }
int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * r * r ) / 4 ) ; return a ; }
int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; int [ ] v = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) v [ i ] = 0 ; v [ m ] = 1 ; while ( true ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } }
void LargestString ( string [ ] na ) { int N = na . Length ; int [ ] c = new int [ N ] ; int m = 0 ; for ( int j = 0 ; j < N ; j ++ ) { bool [ ] character = new bool [ 26 ] ; for ( int k = 0 ; k < na [ j ] . Length ; k ++ ) { int x = na [ j ] [ k ] - ' A ' ; if ( ( na [ j ] [ k ] != ' ▁ ' ) && ( character [ x ] == false ) ) { c [ j ] ++ ; character [ x ] = true ; } } if ( c [ j ] > c [ m ] ) m = j ; } Console . Write ( na [ m ] ) ; }
int findMinSum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int minsum = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; }
void factors ( int n ) { int i , j ; Console . Write ( "1 ▁ - - > 1 STRNEWLINE " ) ; for ( i = 2 ; i <= n ; i ++ ) { Console . Write ( i + " ▁ - - > " ) ; for ( j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { Console . Write ( j + " , ▁ " ) ; if ( i / j != j ) Console . Write ( i / j + " , ▁ " ) ; } } Console . Write ( " STRNEWLINE " ) ; } }
int countSymmetric ( int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
int findXOR ( int [ ] Set , int n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i , curr ] = l ; if ( r != - 1 ) dp [ i , curr ] = Math . Max ( dp [ i , curr ] , r + 1 ) ; return dp [ i , curr ] ; }
double volumeRec ( double a , double b , double e , double h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
void findMajority ( int [ ] arr , int n ) { int len = 32 ; int number = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int countt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countt ++ ; } if ( countt > ( n / 2 ) ) number += ( 1 << i ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > ( n / 2 ) ) Console . Write ( number ) ; else Console . Write ( " Majority ▁ Element ▁ Not ▁ Present " ) ; }
int bitPos ( int n1 , int n2 ) { if ( n1 == n2 ) return 0 ; int bitCount1 = ( int ) Math . Floor ( Math . Log ( n1 ) / Math . Log ( 2 ) ) + 1 ; int bitCount2 = ( int ) Math . Floor ( Math . Log ( n2 ) / Math . Log ( 2 ) ) + 1 ; int bitDiff = Math . Abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . Max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . Pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . Pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = ( int ) Math . Floor ( Math . Log ( xorValue ) / Math . Log ( 2 ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
bool isLucky ( int n ) { bool [ ] arr = new bool [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
void printPairs ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " , ▁ " ) ; } } }
void findEquation ( int A , int B , int C ) { Console . Write ( " ( " + C + " ) " + " x ^ 2 ▁ + ( " + B + " ) x ▁ + ▁ ( " + A + " ) ▁ = ▁ 0" ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
int cntEdges ( int n ) { int edges = ( int ) Math . Pow ( 2 , n ) - 2 ; return edges ; }
int maximumTurns ( int [ ] arr , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; }
bool isPossible ( int n , int k , int [ ] arr ) { int sum = arr [ 0 ] ; int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . Max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; }
bool isdodecagonal ( int N ) { float n = ( float ) ( ( 4 + Math . Sqrt ( 20 * N + 16 ) ) / 10 ) ; return ( n - ( int ) n ) == 0 ; }
string findNumber ( int n , int d ) { string ans = " " ; if ( d != 10 ) { ans += d . ToString ( ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += " Impossible " ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; }
int findCount ( string str ) { int result = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( i == ( str [ i ] - ' a ' ) || i == ( str [ i ] - ' A ' ) ) result ++ ; return result ; }
bool Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
void computePair ( double K ) { if ( K == 1 ) { Console . Write ( " No " ) ; return ; } else { Console . Write ( K * K / ( K - 1 ) + " ▁ " ) ; Console . Write ( K / ( K - 1 ) + " STRNEWLINE " ) ; } }
int findPosition ( int n , int f , int b ) { return n - Math . Max ( f + 1 , n - b ) + 1 ; }
int maxXorSum ( int n , int k ) { if ( k == 1 ) return n ; int res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
double mixtureConcentration ( int n , int [ ] p ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return Math . Round ( res , 4 ) ; }
int findWaysToPair ( int p ) { int [ ] dp = new int [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }
int numberOfArithmeticSequences ( int [ ] L , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
int min_remove ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = Math . Min ( ans , n - j + i - 1 ) ; } } } return ans ; }
void maxGcd ( int a , int b ) { Console . Write ( Math . Abs ( a - b ) ) ; }
bool isCornerPresent ( string str , string corner ) { int n = str . Length ; int cl = corner . Length ; if ( n < cl ) return false ; return ( str . Substring ( 0 , cl ) . Equals ( corner ) && str . Substring ( n - cl , cl ) . Equals ( corner ) ) ; }
int countSticks ( String str , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str [ i ] - '0' ] ) ; } return cnt ; }
int countFriendsPairings ( int n ) { int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
bool isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }
int possibleBinaries ( int pos , int ones , int sum , int k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos , ones , sum ] != - 1 ) return dp [ pos , ones , sum ] ; int ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos , ones , sum ] = ret ; return dp [ pos , ones , sum ] ; }
int maxDP ( int n ) { int [ ] res = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . Max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
int minOperation ( int k ) { int [ ] dp = new int [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . Min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
bool graphExists ( ArrayList a , int n ) { while ( true ) { a . Sort ( ) ; a . Reverse ( ) ; if ( ( int ) a [ 0 ] == 0 ) return true ; int v = ( int ) a [ 0 ] ; a . Remove ( a [ 0 ] ) ; if ( v > a . Count ) return false ; for ( int i = 0 ; i < v ; i ++ ) { a [ i ] = ( int ) a [ i ] - 1 ; if ( ( int ) a [ i ] < 0 ) return false ; } } }
float Area ( int d , int h1 , int h2 ) { float area ; area = ( float ) 0.5 * d * ( h1 + h2 ) ; return area ; }
void evenSubMatrix ( int N ) { int even = 1 ; int odd = 2 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( i + j ) % 2 == 0 ) { Console . Write ( even + " ▁ " ) ; even += 2 ; } else { Console . Write ( odd + " ▁ " ) ; odd += 2 ; } } Console . WriteLine ( ) ; } }
int minsteps ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += Math . Abs ( arr [ i ] - ( int ) ( Math . Pow ( 2 , i ) ) ) ; } return ans ; }
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
void findNumbers ( int n ) { int odd = ( int ) Math . Pow ( 10 , n ) - 1 ; int even = odd - 1 ; Console . WriteLine ( " Even ▁ = ▁ " + even ) ; Console . Write ( " Odd ▁ = ▁ " + odd ) ; }
void findUniquePair ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } Console . WriteLine ( " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , ▁ " + y + " ) " ) ; }
int minimum ( int n ) { int product = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
int countSquares ( int row , int column ) { int topLeft = Math . Min ( row , column ) - 1 ; int bottomRight = 8 - Math . Max ( row , column ) ; int topRight = Math . Min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - Math . Max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = Math . Sqrt ( temp ) ; return result ; }
bool canConvert ( string str1 , string str2 ) { int i = 0 , j = 0 ; while ( i < str1 . Length && j < str2 . Length ) { if ( str1 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == '0' && str2 [ j ] == '1' && i + 1 < str1 . Length && str1 [ i + 1 ] == '0' ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i == str1 . Length && j == str2 . Length ) return true ; return false ; }
int countNum ( int [ ] arr , int n ) { int count = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
int minOperation ( bool [ ] [ ] arr ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . Max ( max_sum , i + j ) ; } } return max_sum ; }
int countPairsWithDiffK ( int [ ] arr , int n , int k ) { int count = 0 ; Array . Sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
int minimumX ( int n , int k ) { int mini = int . MaxValue ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . Min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . Min ( num2 , mini ) ; } } return mini ; }
void printPFsInPairs ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) Console . Write ( i + " * " + n / i + " STRNEWLINE " ) ; }
void checksum ( int n , int k ) { float first_term = ( float ) ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - ( int ) ( first_term ) == 0 ) { for ( int i = ( int ) first_term ; i <= first_term + k - 1 ; i ++ ) { Console . Write ( i + " ▁ " ) ; } } else Console . Write ( " - 1" ) ; }
int maxLenSub ( int [ ] arr , int n ) { int [ ] mls = new int [ n ] ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . Abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
void countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } Console . WriteLine ( numbers_rightmost_setbit_K ) ; }
void Main ( String [ ] args ) { String Str = " IDID " ; int N = Str . Length ; int [ ] ptr = DiStirngMatch ( Str ) ; for ( int i = 0 ; i <= N ; i ++ ) Console . Write ( ptr [ i ] + " ▁ " ) ; } }
void uniqueElement ( int [ ] arr ) { int x = arr [ 0 ] ; int flag = 1 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] != x ) { flag = 0 ; break ; } } if ( flag == 1 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
string xoring ( string a , string b , int n ) { string ans = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == b [ i ] ) ans += "0" ; else ans += "1" ; } return ans ; }
int decideWinner ( int [ ] a , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
int findRectNum ( int n ) { return n * ( n + 1 ) ; }
int nextPerfectCube ( int N ) { int nextN = ( int ) Math . Floor ( Math . Pow ( N , ( double ) 1 / 3 ) ) + 1 ; return nextN * nextN * nextN ; }
void findPermutation ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( i + " ▁ " ) ; }
bool isStraighLineNum ( int N ) { if ( N <= 99 ) return false ; string s = N . ToString ( ) ; int d = s [ 1 ] - s [ 0 ] ; for ( int i = 2 ; i < s . Length ; i ++ ) if ( s [ i ] - s [ i - 1 ] != d ) return false ; return true ; }
int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( ( n - 2 ) * 180 ) ; }
float Area ( float a ) { if ( a < 0 ) return - 1 ; float h = ( float ) 1.268 * a ; float A = ( float ) ( 0.70477 * Math . Pow ( h , 2 ) ) ; return A ; }
String search ( int [ ] arr , int n , int x ) { if ( arr [ n - 1 ] == x ) return " Found " ; int backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( int i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " Found " ; return " Not ▁ Found " ; } } }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = ( int ) ( Math . Pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) Console . Write ( ans ) ; else Console . Write ( 2 * ans ) ; }
int maxProfit ( int [ ] prices , int n ) { int profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { int day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; }
double countdigits ( int n , int k ) { if ( n == 0 ) return 0 ; int digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }
int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
float find_prob ( int N , float P ) { double [ ] dp = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; }
int countReduce ( string str ) { int n = str . Length ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += Math . Abs ( str [ i ] - str [ n - i - 1 ] ) ; return res ; }
double areaOftriangle ( int side ) { double a = Math . Sqrt ( Math . Pow ( side / 2 , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double b = Math . Sqrt ( Math . Pow ( side , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double c = Math . Sqrt ( Math . Pow ( side , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double s = ( a + b + c ) / 2 ; double area = Math . Sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area ; }
void minOpsToEmptyString ( string s ) { int ans = 0 ; int cn0 = 0 ; int cn1 = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . Max ( ans , Math . Max ( cn0 , cn1 ) ) ; } Console . Write ( ans ) ; }
bool isCenteredOctadecagonal ( int N ) { double n = ( 9 + Math . Sqrt ( 36 * N + 45 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
bool checkEvenPower ( long N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; }
void amendSentence ( string sstr ) { char [ ] str = sstr . ToCharArray ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { str [ i ] = ( char ) ( str [ i ] + 32 ) ; if ( i != 0 ) Console . Write ( " ▁ " ) ; Console . Write ( str [ i ] ) ; } else Console . Write ( str [ i ] ) ; } }
int minSum ( int [ ] a , int n ) { Array . Sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
void findArea ( float a , float b ) { float Area ; Area = ( float ) 3.142 * a * b ; Console . WriteLine ( " Area : ▁ " + Area ) ; }
int solve ( int [ ] A , int n , int [ ] Q , int q ) { int one = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; int glows = 0 , count = 0 ; if ( one >= ( int ) Math . Ceiling ( ( double ) n / 2 ) ) glows = 1 ; for ( int i = 0 ; i < q ; i ++ ) { int prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= ( int ) Math . Ceiling ( ( double ) n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; }
int countSol ( int [ ] coeff , int n , int rhs ) { int [ ] dp = new int [ rhs + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
int longLenSub ( int [ ] arr , int n ) { Dictionary < int , int > um = new Dictionary < int , int > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . ContainsKey ( arr [ i ] - 1 ) && len < um [ arr [ i ] - 1 ] ) len = um [ arr [ i ] - 1 ] ; if ( um . ContainsKey ( arr [ i ] + 1 ) && len < um [ arr [ i ] + 1 ] ) len = um [ arr [ i ] + 1 ] ; um [ arr [ i ] ] = len + 1 ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } return longLen ; }
int minimizeCost ( int A , int B , int C ) { int ans = A + B + C ; for ( int i = 1 ; i <= 2 * C ; i ++ ) { int j = 0 ; while ( i * j <= 2 * C ) { ans = Math . Min ( ans , Math . Abs ( A - i ) + Math . Abs ( B - j ) + Math . Abs ( i * j - C ) ) ; j ++ ; } } return ans ; }
int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
int maxCount ( int [ ] arr , int m , int V ) { int [ ] table = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = - 1 ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ j ] <= i ) { int sub_res = table [ i - arr [ j ] ] ; if ( sub_res != - 1 && sub_res + 1 > table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; }
double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
String lexicographicSubConcat ( String s ) { int n = s . Length ; int sub_count = n * ( n + 1 ) / 2 ; String [ ] arr = new String [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) { arr [ index ++ ] = s . Substring ( i , len ) ; } Array . Sort ( arr ) ; String res = " " ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
int formQuadruplets ( int [ ] arr , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; Array . Sort ( arr ) ; Array . Reverse ( arr ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; }
int countXor ( int N ) { int cnt = ( int ) N / 2 + 1 ; return cnt ; }
int checkArray ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }
void search ( int [ , ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i , j ] == x ) { Console . Write ( " n ▁ Found ▁ at ▁ " + i + " , ▁ " + j ) ; return ; } if ( mat [ i , j ] > x ) j -- ; else i ++ ; } Console . Write ( " n ▁ Element ▁ not ▁ found " ) ; return ; }
int maxPointCount ( int [ ] arr , int K , int size ) { int curr_points = 0 ; int max_points = 0 ; for ( int i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; int j = size - 1 ; for ( int i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = Math . Max ( curr_points , max_points ) ; j -- ; } return max_points ; }
int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = Math . Min ( c2 , Math . Min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . Min ( c2 , c1 ) * 12 ; return sum ; }
void findXOR ( int [ , , ] mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i , j , k ] ; XOR ^= mat [ i , j , N - k - 1 ] ; } } } } Console . WriteLine ( XOR ) ; }
int countConsecutive ( int N ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; }
int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
int findOptimalSolution ( int [ ] a , int N ) { Array . Sort ( a ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; }
> ConstructList ( int [ , ] Q ) { int xor = 0 ; List < int > ans = new List < int > ( ) ; for ( int i = Q . GetLength ( 0 ) - 1 ; i >= 0 ; i -- ) { if ( Q [ i , 0 ] == 0 ) ans . Add ( Q [ i , 1 ] ^ xor ) ; else xor ^= Q [ i , 1 ] ; } ans . Add ( xor ) ; ans . Sort ( ) ; return ans ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
void findMinXORSubarray ( int [ ] arr , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } Console . Write ( min_xor + " STRNEWLINE " ) ; }
int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return 1 ; }
bool isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; }
bool check ( String s ) { for ( int i = 0 ; i < s . Length - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; }
int minimumBox ( int [ ] arr , int n ) { Queue < int > q = new Queue < int > ( ) ; Array . Sort ( arr ) ; q . Enqueue ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . Peek ( ) ; if ( arr [ i ] >= 2 * now ) q . Dequeue ( ) ; q . Enqueue ( arr [ i ] ) ; } return q . Count ; }
int minSteps ( int N ) { int count = 1 , res = 0 ; for ( int i = 1 ; i <= N ; i += count ) { res = Math . Max ( res , count ) ; count ++ ; } return res ; }
String convert ( String s ) { int n = s . Length ; String s1 = " " ; s1 = s1 + Char . ToLower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s1 = s1 + " ▁ " + Char . ToLower ( s [ i + 1 ] ) ; i ++ ; } else s1 = s1 + Char . ToUpper ( s [ i ] ) ; } return s1 ; }
int lucas ( int n ) { int a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
void maxModProdSubarr ( int [ ] arr , int n , int M ) { int ans = 0 ; int length = n ; for ( int i = 0 ; i < n ; i ++ ) { int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } Console . WriteLine ( " Maximum ▁ subarray ▁ product ▁ is ▁ " + ans ) ; Console . WriteLine ( " Minimum ▁ length ▁ of ▁ the ▁ maximum ▁ " + " product ▁ subarray ▁ is ▁ " + length ) ; }
void subString ( string str , int n ) { for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; for ( int k = i ; k <= j ; k ++ ) Console . Write ( str [ k ] ) ; Console . WriteLine ( ) ; } } }
int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
int findMinSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
int largestGCDSubsequence ( int [ ] arr , int n ) { int ans = 0 ; int maxele = arr . Max ( ) ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . Max ( ans , count ) ; } return ans ; }
int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; }
int countTriplets ( int N , int K ) { if ( K % 2 == 0 ) { int x = N / K ; int y = ( N + ( K / 2 ) ) / K ; return x * x * x + y * y * y ; } else { int x = N / K ; return x * x * x ; } }
void findString ( int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( ( char ) ( ' A ' + i % K ) ) ; } }
int maximumK ( String S ) { int N = S . Length ; int ans = N ; int flag = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) { flag = 1 ; ans = Math . Min ( ans , Math . Max ( i + 1 , N - i - 1 ) ) ; } } if ( flag == 0 ) return 0 ; return ans ; }
void countPairsWithDiffK ( int [ ] arr , int N , int K ) { int [ ] vis = new int [ N ] ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( vis [ i ] == 1 ) continue ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( vis [ j ] == 1 ) continue ; if ( Math . Abs ( arr [ i ] - arr [ j ] ) >= K ) { count ++ ; vis [ i ] = 1 ; vis [ j ] = 1 ; break ; } } } Console . Write ( count ) ; }
uint getModulo ( uint n , uint d ) { return ( n & ( d - 1 ) ) ; }
int minSumPath ( ref List < List < int > > A ) { int [ ] memo = new int [ A . Count ] ; int n = A . Count - 1 ; for ( int i = 0 ; i < A [ n ] . Count ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . Count - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i + 1 ] . Count - 1 ; j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . Min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
int angle ( int n ) { return 2 * n ; }
int condition ( int a , int b ) { int d = Math . Abs ( a - b ) , count = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; }
int count_minimum_operations ( long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
bool istriacontagonal ( int N ) { float n = ( float ) ( ( 26 + Math . Sqrt ( 224 * N + 676 ) ) / 56 ) ; return ( n - ( int ) n ) == 0 ; }
int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
int longestCommonSum ( int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
void countFreq ( int [ ] a , int n ) { int [ ] hm = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { Console . WriteLine ( a [ i ] + " - > " + cumul ) ; } hm [ a [ i ] ] = 0 ; } }
int findTripleSum ( int A , int B , int C ) { int sum = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { int prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
int findNthNonSquare ( int n ) { double x = ( double ) n ; double ans = x + Math . Floor ( 0.5 + Math . Sqrt ( x ) ) ; return ( int ) ans ; }
int Moves_Calculator ( int x , int y , int row , int col ) { int total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += Math . Min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += Math . Min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += Math . Min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += Math . Min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; int king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; }
int findExtra ( int [ ] arr1 , int [ ] arr2 , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
bool isEditDistanceOne ( String s1 , String s2 ) { int m = s1 . Length , n = s2 . Length ; if ( Math . Abs ( m - n ) > 1 ) return false ; int count = 0 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; else { i ++ ; j ++ ; } count ++ ; } else { i ++ ; j ++ ; } } if ( i < m < n ) count ++ ; return count == 1 ; }
void isValid ( string s ) { int n = ( int ) Math . Sqrt ( s . Length ) ; char check = s [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = i , y = i ; while ( x >= 0 && y < n ) { if ( s [ ( n * x ) + y ] != check || s [ ( n * y ) + x ] != check ) { Console . Write ( " No " ) ; return ; } x -- ; y ++ ; } } Console . Write ( " Yes " ) ; }
void findLast ( int [ , ] mat ) { int m = 3 ; int n = 3 ; HashSet < int > rows = new HashSet < int > ( ) ; HashSet < int > cols = new HashSet < int > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( mat [ i , j ] > 0 ) ) { rows . Add ( i ) ; cols . Add ( j ) ; } } } int avRows = m - rows . Count ; int avCols = n - cols . Count ; int choices = Math . Min ( avRows , avCols ) ; if ( ( choices & 1 ) != 0 ) Console . WriteLine ( " P1" ) ; else Console . WriteLine ( " P2" ) ; }
int minDistance ( int [ ] start , int [ ] end , int n , int d ) { int left = Int32 . MinValue ; int right = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { left = Math . Max ( left , start [ i ] ) ; right = Math . Min ( right , end [ i ] ) ; } if ( left > right ) return - 1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return ( left - d ) ; if ( d > right ) return ( d - right ) ; return - 1 ; }
int countOfSubstringWithOnlyOnes ( string s ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { count = s [ i ] == '1' ? count + 1 : 0 ; res = ( res + count ) ; } return res ; }
int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; return solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
float findRadiusOfIncircle ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; float p = ( a + b + c ) / 2 ; float area = ( float ) Math . Sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float radius = area / p ; return ( float ) ( radius ) ; }
long maxOR ( long [ ] arr , int n , int k , int x ) { long [ ] preSum = new long [ n + 1 ] ; long [ ] suffSum = new long [ n + 1 ] ; long res = 0 , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
bool check ( int X , int K ) { int prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = Convert . ToInt32 ( Math . Sqrt ( X ) ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = temp / i ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; }
int minDiffSubArray ( int [ ] arr , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int [ ] suffix_sum = new int [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int minDiff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = Math . Abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
void findNumbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) Console . Write ( "1" + " ▁ " ) ; Console . Write ( "2" + " ▁ " ) ; Console . Write ( n + d ) ; }
int calculateSum ( int n ) { return ( ( int ) Math . Pow ( 2 , n + 1 ) + n - 2 ) ; }
float hexadiagonal ( float a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }
double findPCSlope ( double m ) { return - 1.0 / m ; }
bool isProductEven ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) Console . Write ( " NO " ) ; else Console . Write ( " YES " ) ; }
int countTriplets ( int n , int sum ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; }
long largestNumber ( int N ) { if ( N > 45 ) return - 1 ; int num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
int findWater ( int n ) { int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; int water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) left [ i ] = Math . Max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) right [ i ] = Math . Max ( right [ i + 1 ] , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) water += Math . Min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; }
float geometricMean ( int [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) Math . Log ( arr [ i ] ) ; sum = sum / n ; return ( float ) Math . Exp ( sum ) ; }
void minSteps ( string S ) { string new_str = " " ; int N = S . Length ; int i = 0 ; while ( i < N ) { new_str += S [ i ] ; int j = i ; while ( i < N && S [ i ] == S [ j ] ) ++ i ; } Console . Write ( ( int ) Math . Ceiling ( ( new_str . Length + 1 ) / 2.0 ) ) ; }
int countSubstrings ( string s , char c ) { int n = s . Length ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
void checkSamePosition ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . ContainsKey ( temp ) ) { Console . Write ( " Yes " ) ; return ; } mp [ temp ] = 1 ; } Console . Write ( " No " ) ; }
float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }
int countRotations ( int [ ] arr , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
int myXOR ( int x , int y ) { return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) ; }
void possibleToReach ( int x , int y , int z ) { if ( z < Math . Abs ( x ) + Math . Abs ( y ) || ( z - Math . Abs ( x ) - Math . Abs ( y ) ) % 2 == 1 ) { Console . Write ( " Not ▁ Possible " + " STRNEWLINE " ) ; } else Console . Write ( " Possible " + " STRNEWLINE " ) ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . Max ( l , a ) ; int R = Math . Min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int findSmallestDifference ( int [ ] A , int [ ] B , int m , int n ) { Array . Sort ( A ) ; Array . Sort ( B ) ; int a = 0 , b = 0 ; int result = int . MaxValue ; while ( a < m && b < n ) { if ( Math . Abs ( A [ a ] - B [ b ] ) < result ) result = Math . Abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
int sum_all_divisors ( int num ) { int sum = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( num ) ; i ++ ) { sum += t1 + t2 ; } return sum ; }
int ways ( int n ) { return n / 2 ; }
bool canVote ( int [ ] a , int n , int x ) { int [ , ] dp = new int [ n + 1 , x + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < x + 1 ; j ++ ) { dp [ i , j ] = 0 ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , a [ i ] + dp [ i - 1 , j - a [ i ] ] ) ; else dp [ i , j ] = dp [ i - 1 , j ] ; return ( sum - dp [ n , x ] >= x ) ; }
long countMaxIntersect ( long n ) { return ( n ) * ( n - 1 ) / 2 ; }
int findIndex ( int [ ] a , int n ) { int res = 0 ; long min_diff = Int64 . MaxValue ; long [ ] prod = new long [ n ] ; prod [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long curr_diff = Math . Abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
int maxSum ( int [ ] a , int n ) { int ans = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int [ , ] dp = new int [ n + 1 , 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i , 0 ] = Math . Max ( arr [ i ] , dp [ i - 1 , 0 ] + arr [ i ] ) ; dp [ i , 1 ] = Math . Max ( 0 , dp [ i - 1 , 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , dp [ i - 1 , 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i , 2 ] = dp [ i - 1 , 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i , 2 ] = Math . Max ( dp [ i , 2 ] , dp [ i - 1 , 2 ] + arr [ i ] ) ; ans = Math . Max ( ans , dp [ i , 0 ] ) ; ans = Math . Max ( ans , dp [ i , 1 ] ) ; ans = Math . Max ( ans , dp [ i , 2 ] ) ; } return ans ; }
int findMaxK ( int N ) { int p = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) ; return ( int ) Math . Pow ( 2 , p ) ; }
void translate ( char [ ] str ) { for ( int i = 1 ; i < str . Length ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; int j ; for ( j = i ; j < str . Length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ▁ ' ; } } return ; }
void countEle ( Stack < int > s , int [ ] a , int N ) { Dictionary < int , bool > mp = new Dictionary < int , bool > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int num = a [ i ] ; if ( mp . ContainsKey ( num ) ) Console . Write ( "0 ▁ " ) ; else { int cnt = 0 ; while ( s . Peek ( ) != num ) { mp . Add ( s . Peek ( ) , true ) ; s . Pop ( ) ; cnt ++ ; } s . Pop ( ) ; cnt ++ ; Console . Write ( cnt + " ▁ " ) ; } } }
int getMinOps ( int [ ] arr ) { int res = 0 ; for ( int i = 0 ; i < arr . Length - 1 ; i ++ ) { res += Math . Max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; }
bool isPerfectCubeString ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) sum += ( int ) str [ i ] ; double cr = Math . Round ( Math . Pow ( sum , ( double ) 1 / 3 ) ) ; return ( cr * cr * cr == sum ) ; }
int countPairs ( int [ ] a , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . Sqrt ( a ) / 6 ; return area ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; }
float productOfGP ( float a , float r , int n ) { return ( float ) Math . Pow ( a , n ) * ( float ) Math . Pow ( r , n * ( n - 1 ) / 2 ) ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; }
void PrintIndexes ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int currSubSum = 0 ; for ( int j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; int sq = ( int ) Math . Sqrt ( currSubSum ) ; if ( sq * sq == currSubSum ) { Console . Write ( " ( " + i + " , " + j + " ) " + " ▁ " ) ; } } } }
void printArray ( int [ ] a , int n ) { Array . Sort ( a ) ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( i == j ) { Console . Write ( a [ i ] + " ▁ " ) ; } else { Console . Write ( a [ j ] + " ▁ " ) ; Console . Write ( a [ i ] + " ▁ " ) ; } i = i + 1 ; j = j - 1 ; } Console . WriteLine ( ) ; }
int det ( int [ , ] d ) { int Sum = d [ 0 , 0 ] * ( ( d [ 1 , 1 ] * d [ 2 , 2 ] ) - ( d [ 2 , 1 ] * d [ 1 , 2 ] ) ) ; Sum -= d [ 0 , 1 ] * ( ( d [ 1 , 0 ] * d [ 2 , 2 ] ) - ( d [ 1 , 2 ] * d [ 2 , 0 ] ) ) ; Sum += d [ 0 , 2 ] * ( ( d [ 0 , 1 ] * d [ 1 , 2 ] ) - ( d [ 0 , 2 ] * d [ 1 , 1 ] ) ) ; return Sum ; }
void minSum ( int N ) { int ans = ( int ) Math . Ceiling ( 2 * Math . Sqrt ( N + 1 ) ) ; Console . WriteLine ( ans ) ; }
void countSamePrefixSuffix ( string s , int n ) { string prefix = " " ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix += s [ i ] ; string suffix = s . Substring ( n - 1 - i , i + 1 ) ; if ( prefix == suffix ) { Console . Write ( prefix . Length + " ▁ " ) ; } } }
int findSingle ( int [ ] ar , int ar_size ) { int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
float rectanglearea ( float r ) { if ( r < 0 ) return - 1 ; float a = r * r ; return a ; }
void operations ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 , sum = 0 ; while ( k -- > 0 ) { while ( i < n && arr [ i ] - sum == 0 ) i ++ ; if ( i < n && arr [ i ] - sum > 0 ) { Console . Write ( arr [ i ] - sum + " ▁ " ) ; sum = arr [ i ] ; } else Console . WriteLine ( "0" ) ; } }
int find_next ( int n , int k ) { int M = n + 1 ; while ( true ) { if ( ( M & ( 1L << k ) ) > 0 ) break ; M ++ ; } return M ; }
void findRange ( int [ ] arr , int N , int K ) { int L = Int32 . MinValue ; int R = Int32 . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { int l = ( int ) Math . Ceiling ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; int r = ( int ) Math . Ceiling ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = Math . Max ( L , l ) ; R = Math . Min ( R , r ) ; } Console . WriteLine ( L + " ▁ " + R ) ; }
int countDigit ( int n ) { bool [ ] prime = new bool [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) prime [ i ] = false ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] == true ) count ++ ; } return count ; }
int minSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int x = arr [ ( int ) ( n / 2 ) ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . Abs ( arr [ i ] - x ) ; return sum ; }
float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float R = ( float ) ( ( h * r * Math . Sqrt ( 2 ) ) / ( h + Math . Sqrt ( 2 ) * r ) ) / 2 ; return R ; }
void checkValidPolygon ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
void printSubstrings ( String str ) { int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) { Console . Write ( str [ k ] ) ; } Console . WriteLine ( ) ; } } }
bool isPower ( int x , int y ) { int res1 = ( int ) Math . Log ( y ) / ( int ) Math . Log ( x ) ; double res2 = Math . Log ( y ) / Math . Log ( x ) ; return ( res1 == res2 ) ; }
int max_sum ( int [ ] a , int n ) { int [ , ] dp = new int [ n + 1 , 2 ] ; dp [ 0 , 0 ] = 0 ; dp [ 0 , 1 ] = - 999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 , 0 ] = Math . Max ( dp [ i , 0 ] + a [ i ] , dp [ i , 1 ] - a [ i ] ) ; dp [ i + 1 , 1 ] = Math . Max ( dp [ i , 0 ] - a [ i ] , dp [ i , 1 ] + a [ i ] ) ; } return dp [ n , 0 ] ; }
void path_to_root ( int node ) { while ( node >= 1 ) { Console . Write ( node + " ▁ " ) ; node /= 2 ; } }
bool Survives ( int n ) { for ( int i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= n / i ; } }
void printThreeParts ( int N ) { if ( N % 3 == 0 ) Console . WriteLine ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " + ( N - 2 ) ) ; else Console . WriteLine ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " + ( N - 3 ) ) ; }
int intersection ( int n ) { return n * ( n - 1 ) ; }
int calculateSum ( string [ ] arr , int n ) { if ( n == 0 ) return 0 ; string s = arr [ 0 ] ; int value = int . Parse ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = int . Parse ( s ) ; char operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
int count_pairs ( int [ ] arr , int [ ] brr , int N , int M , int K ) { int i = 0 ; int j = 0 ; int cntPairs = 0 ; Array . Sort ( arr ) ; Array . Sort ( brr ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
bool isSortedArray ( int [ ] arr , int n ) { int l = 0 , r = ( n - 1 ) ; while ( ( l + 1 ) < r ) { if ( arr [ l ] >= Math . Max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= Math . Max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l ++ ; r -- ; } else { return false ; } } return true ; }
int strScore ( string [ ] str , string s , int n ) { Dictionary < string , int > m = new Dictionary < string , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m [ str [ i ] ] = i + 1 ; if ( ! m . ContainsKey ( s ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) score += s [ i ] - ' a ' + 1 ; score = score * m [ s ] ; return score ; }
int findDivisor ( int x , int y ) { if ( x == y ) return y ; return 2 ; }
void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
void nDigitPerfectCubes ( int n ) { int smallest = ( int ) Math . Pow ( Math . Ceiling ( MathF . Cbrt ( ( float ) Math . Pow ( 10 , ( n - 1 ) ) ) ) , 3 ) ; Console . Write ( smallest + " ▁ " ) ; int largest = ( int ) Math . Pow ( Math . Ceiling ( MathF . Cbrt ( ( float ) Math . Pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ; Console . Write ( largest ) ; }
bool isEven ( int n ) { bool isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
void differentStrings ( string s ) { int n = s . Length ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] && ( s [ i ] == '1' s [ i ] == '2' ) ) dp [ i + 1 ] = dp [ i ] + dp [ i - 1 ] ; else dp [ i + 1 ] = dp [ i ] ; } Console . Write ( dp [ n ] ) ; }
bool unique ( String s ) { Array . Sort ( s . ToCharArray ( ) ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { return false ; } } return true ; }
int minIndex ( int [ ] arr , int n , int pos ) { int num = arr [ pos ] ; int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
void pairStar ( String input , int i ) { output = output + input [ i ] ; if ( i == input . Length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' * ' ; pairStar ( input , i + 1 ) ; }
int findMinSoln ( int n , int k ) { int minSoln = int . MaxValue ; for ( int i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = Math . Min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; }
void rangeSum ( int [ ] arr , int N , int L , int R ) { int [ ] prefix = new int [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; Console . Write ( rightsum - leftsum ) ; }
bool checkSequence ( String a , String b ) { if ( b . Length == 0 ) return true ; if ( a . Length == 0 ) return false ; if ( a [ 0 ] == b [ 0 ] ) return checkSequence ( a . Substring ( 1 ) , b . Substring ( 1 ) ) ; else return checkSequence ( a . Substring ( 1 ) , b ) ; }
void printLargest ( int [ ] a , int n ) { int max = - 1 ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num > 0 ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( int i = ind ; i < n ; i ++ ) Console . Write ( a [ i ] ) ; for ( int i = 0 ; i < ind ; i ++ ) Console . Write ( a [ i ] ) ; }
int countPairs ( int [ ] arr , int n ) { int ans = 0 ; Array . Sort ( arr ) ; int left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
bool checkSentence ( char [ ] str ) { int len = str . Length ; if ( str [ 0 ] < ' A ' str [ 0 ] > ' Z ' ) return false ; if ( str [ len - 1 ] != ' . ' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( index <= str . Length ) { if ( str [ index ] >= ' A ' && str [ index ] <= ' Z ' ) curr_state = 0 ; else if ( str [ index ] == ' ▁ ' ) curr_state = 1 ; else if ( str [ index ] >= ' a ' && str [ index ] <= ' z ' ) curr_state = 2 ; else if ( str [ index ] == ' . ' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . Length ) ; index ++ ; prev_state = curr_state ; } return false ; }
int minimumSwaps ( int [ ] arr ) { int count = 0 ; int i = 0 ; while ( i < arr . Length ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; }
int sameEulerTotient ( int N ) { return ( N & 1 ) ; }
int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; }
long polynomialRollingHash ( String str ) { int p = 31 ; int m = ( int ) ( 1e9 + 9 ) ; long power_of_p = 1 ; long hash_val = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { hash_val = ( hash_val + ( str [ i ] - ' a ' + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return hash_val ; }
bool findPartition ( int [ ] arr , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool [ , ] part = new bool [ sum / 2 + 1 , n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 , i ] = true ; for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i , 0 ] = false ; for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i , j ] = part [ i , j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i , j ] = part [ i , j - 1 ] || part [ i - arr [ j - 1 ] , j - 1 ] ; } } return part [ sum / 2 , n ] ; }
int octahedral_num ( int n ) { return n * ( 2 * n * n + 1 ) / 3 ; }
void rearrange ( int [ ] arr ) { if ( arr == null arr . Length % 2 == 1 ) return ; int currIdx = ( arr . Length - 1 ) / 2 ; while ( currIdx > 0 ) { int count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } }
void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) Console . Write ( hexaDeciNum [ j ] ) ; }
void findTriangle ( int [ ] a , int n ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; Array . Sort ( a ) ; Array . Sort ( b ) ; int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . Max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . Max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . Max ( p - j , 0 ) ; z += q - p ; } } } Console . Write ( " Acute ▁ Triangle : ▁ " + x + " STRNEWLINE " ) ; Console . Write ( " Right ▁ Triangle : ▁ " + y + " STRNEWLINE " ) ; Console . Write ( " Obtuse ▁ Triangle : ▁ " + z + " STRNEWLINE " ) ; }
int twoEggDrop ( int k ) { return ( int ) System . Math . Ceiling ( ( - 1.0 + System . Math . Sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; }
int make_permutation ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += Math . Abs ( i + 1 - arr [ i ] ) ; return ans ; }
bool getBit ( int num , int i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }
int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
void maxSubmatrixSum ( int [ , ] matrix ) { int r = matrix . GetLength ( 0 ) ; int c = matrix . GetLength ( 1 ) ; int maxSubmatrix = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int k = i ; k < r ; k ++ ) { for ( int l = j ; l < c ; l ++ ) { int sumSubmatrix = 0 ; for ( int m = i ; m <= k ; m ++ ) { for ( int n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m , n ] ; } } maxSubmatrix = Math . Max ( maxSubmatrix , sumSubmatrix ) ; } } } } Console . WriteLine ( maxSubmatrix ) ; }
int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
void sumArray ( int [ ] arr , int n ) { int [ ] leftSum = new int [ n ] ; int [ ] rightSum = new int [ n ] ; int [ ] Sum = new int [ n ] ; int i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( Sum [ i ] + " ▁ " ) ; }
int findDiff ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . Max ( max_count , count ) ; min_count = Math . Min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
int maximumXOR ( int [ ] arr , int n , int K ) { K ++ ; int maxXor = Int32 . MinValue ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { if ( Convert . ToString ( i , 2 ) . Count ( c => c == '1' ) == K ) { int cur_xor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) cur_xor = cur_xor ^ arr [ j ] ; } maxXor = Math . Max ( maxXor , cur_xor ) ; } } return maxXor ; }
int solve ( int [ ] A , int [ ] B , int [ ] C ) { int i , j , k ; i = A . Length - 1 ; j = B . Length - 1 ; k = C . Length - 1 ; int min_diff , current_diff , max_term ; min_diff = Math . Abs ( Math . Max ( A [ i ] , Math . Max ( B [ j ] , C [ k ] ) ) - Math . Min ( A [ i ] , Math . Min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . Abs ( Math . Max ( A [ i ] , Math . Max ( B [ j ] , C [ k ] ) ) - Math . Min ( A [ i ] , Math . Min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . Max ( A [ i ] , Math . Max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
long findMinSum ( long [ ] a , long [ ] b , long n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . Abs ( a [ i ] - b [ i ] ) ; return sum ; }
void max_valid_triplet ( int [ ] A , int n ) { int ans = - 1 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { int value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } Console . WriteLine ( ans ) ; }
float find ( int N , int a , int b ) { float probability = 0.0f ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 , i ] = ( float ) ( 1.0 / 6 ) ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i , j ] = dp [ i , j ] + dp [ i - 1 , j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N , sum ] ; return probability ; }
String smallest ( String s ) { int l = s . Length ; String ans = " " ; for ( int i = 0 ; i < l - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) { for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { ans += s [ j ] ; } } return ans ; } } ans = s . Substring ( 0 , l - 1 ) ; return ans ; }
int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
int firstNonRepeating ( String str ) { int NO_OF_CHARS = 256 ; int [ ] arr = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( arr [ str [ i ] ] == - 1 ) arr [ str [ i ] ] = i ; else arr [ str [ i ] ] = - 2 ; } int res = int . MaxValue ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = Math . Min ( res , arr [ i ] ) ; return res ; }
int countPairs ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
int countSticks ( string str ) { int cnt = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( ch >= ' A ' && ch <= ' Z ' ) { cnt += sticks [ ch - ' A ' ] ; } else { cnt += number [ ch - '0' ] ; } } return cnt ; }
int findProduct ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int prod = 1 * arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; }
long removeRecur ( long n ) { long prev_digit = n % 10 ; long pow = 10 ; long res = prev_digit ; while ( n > 0 ) { long curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; }
void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) Console . Write ( a + " ▁ " ) ; if ( n >= 1 ) Console . Write ( b + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; Console . Write ( c + " ▁ " ) ; a = b ; b = c ; } }
int nextPowerOfFour ( int n ) { int x = ( int ) Math . Floor ( Math . Sqrt ( Math . Sqrt ( n ) ) ) ; if ( Math . Pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return ( int ) Math . Pow ( x , 4 ) ; } }
long countBT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
int missingNumber ( int [ ] arr1 , int [ ] arr2 , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
int findMin ( int [ ] arr , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
int summation ( int N ) { int co = ( N + 1 ) / 2 ; int ce = ( N ) / 2 ; int se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; int so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
int countMinReversals ( String expr ) { int len = expr . Length ; if ( len % 2 != 0 ) return - 1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) open ++ ; else { if ( open == 0 ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close != 0 ) ans += 2 ; return ans ; }
int XorSum ( int [ ] A , int [ ] B , int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; }
int minOperations ( int [ ] A , int n ) { if ( ( n & 1 ) > 0 ) return - 1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
int MaxProfit ( int [ ] arr , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = Math . Max ( buy , sell - arr [ i ] ) ; sell = Math . Max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . Max ( sell , buy ) ; }
int minCost ( string s , int n ) { int minValue = 100000000 ; for ( int i = 0 ; i <= 25 ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { cnt += Math . Min ( Math . Abs ( i - ( s [ j ] - ' a ' ) ) , 26 - Math . Abs ( i - ( s [ j ] - ' a ' ) ) ) ; } minValue = Math . Min ( minValue , cnt ) ; } return minValue ; }
int counLastDigitK ( int low , int high , int k ) { int mlow = 10 * Convert . ToInt32 ( Math . Ceiling ( low / 10.0 ) ) ; int mhigh = 10 * Convert . ToInt32 ( Math . Floor ( high / 10.0 ) ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; }
bool DivisibleBy41 ( int first , int second , int c , int n ) { int [ ] digit = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
void generateStr ( String a , String b , String s , int count , int len ) { if ( count == len ) { Console . WriteLine ( s ) ; return ; } generateStr ( a . Substring ( 1 ) , b . Substring ( 1 ) , s + a [ 0 ] , count + 1 , len ) ; generateStr ( a . Substring ( 1 ) , b . Substring ( 1 ) , s + b [ 0 ] , count + 1 , len ) ; }
int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
void maxDivisions ( int [ ] arr , int N , int X ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } Console . WriteLine ( maxSub ) ; }
int HogbenNumber ( int a ) { int p = ( int ) ( Math . Pow ( a , 2 ) - a + 1 ) ; return p ; }
void countPairs ( int [ ] A , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } Console . Write ( count ) ; }
string nthprimedigitsnumber ( int number ) { int rem ; string num = " " ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += '2' ; break ; case 2 : num += '3' ; break ; case 3 : num += '5' ; break ; case 0 : num += '7' ; break ; } if ( number % 4 == 0 ) number -- ; number = number / 4 ; } char [ ] st = num . ToCharArray ( ) ; Array . Reverse ( st ) ; return new string ( st ) ; }
void push ( int new_data ) { Node new_node = new Node ( new_data ) ; new_node . next = head ; head = new_node ; }
void occurredOnce ( int [ ] arr , int n ) { Array . Sort ( arr ) ; if ( arr [ 0 ] != arr [ 1 ] ) Console . Write ( arr [ 0 ] + " ▁ " ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) Console . Write ( arr [ i ] + " ▁ " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) Console . Write ( arr [ n - 1 ] + " ▁ " ) ; }
int findMinRec ( int [ ] A , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . Min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
void checkIfCurzonNumber ( long N ) { double powerTerm , productTerm ; powerTerm = Math . Pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
bool isMajority ( int [ ] arr , int n , int x ) { int i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; }
int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = int . MaxValue ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { int x = Math . Abs ( i - A ) ; int y = Math . Abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v [ i , curr ] ) return dp [ i , curr ] ; v [ i , curr ] = true ; dp [ i , curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i , curr ] ; }
int minOperations ( int n , int m ) { int a = 0 , k = 1 ; int p = Math . Max ( n , m ) ; while ( n != m ) { float s = ( float ) ( p - n + p - m ) ; float q = ( float ) ( ( - 1 + Math . Sqrt ( 8 * s + 1 ) ) / 2 ) ; if ( q - Math . Floor ( q ) == 0 ) { a = ( int ) q ; n = m ; } p = p + 1 ; } return a ; }
void lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } Console . WriteLine ( ans ) ; }
float Length_Diagonal ( int a , int b , int d ) { float diagonal = ( float ) Math . Sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; }
float rmsValue ( int [ ] arr , int n ) { int square = 0 ; float mean = 0 ; float root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { square += ( int ) Math . Pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = ( float ) Math . Sqrt ( mean ) ; return root ; }
int maxArea ( int [ ] a ) { int Area = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { for ( int j = i + 1 ; j < a . Length ; j ++ ) { Area = Math . Max ( Area , Math . Min ( a [ i ] , a [ j ] ) * ( j - i ) ) ; } } return Area ; }
Boolean isValidSeq ( int [ ] a , int n ) { int nodes = n + 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 a [ i ] > nodes ) return false ; } return true ; }
void findAngles ( double a , double b , double c , double d ) { double numerator = a * a + d * d - b * b - c * c ; double denominator = 2 * ( a * b + c * d ) ; double x = numerator / denominator ; Console . WriteLine ( " A : ▁ " + Math . Round ( ( ( Math . Acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; numerator = a * a + b * b - c * c - d * d ; x = numerator / denominator ; Console . WriteLine ( " B : ▁ " + Math . Round ( ( ( Math . Acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; numerator = c * c + b * b - a * a - d * d ; x = numerator / denominator ; Console . WriteLine ( " C : ▁ " + Math . Round ( ( ( Math . Acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; numerator = d * d + c * c - a * a - b * b ; x = numerator / denominator ; Console . WriteLine ( " D : ▁ " + Math . Round ( ( ( Math . Acos ( x ) * 180 ) / 3.141592 ) * 100.0 ) / 100.0 + " ▁ degrees " ) ; }
int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . ToCharArray ( ) ; for ( int i = 0 ; i < new_str . Length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
void incrementCount ( int [ ] arr , int N ) { int mini = arr [ 0 ] - arr [ 1 ] ; for ( int i = 2 ; i < N ; i ++ ) { mini = Math . Min ( mini , arr [ i - 1 ] - arr [ i ] ) ; } Console . WriteLine ( mini ) ; }
void genSequence ( int n , int val ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int x = i ^ ( i >> 1 ) ^ val ; Console . Write ( x + " ▁ " ) ; } }
void maxValueAtIndexK ( int N , int K , int M ) { int S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; int X = ( M + S1 + S2 ) / N ; Console . WriteLine ( X ) ; }
int cntSubSeq ( int [ ] arr , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . Pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= ( int ) Math . Pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }
int getMin ( int [ ] arr , int n ) { int minVal = arr . Min ( ) ; return minVal ; }
int countkDist ( string str , int k ) { int res = 0 ; int n = str . Length ; int [ ] cnt = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; Array . Clear ( cnt , 0 , cnt . Length ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - ' a ' ] == 0 ) dist_count ++ ; cnt [ str [ j ] - ' a ' ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }
bool isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
void performQuery ( int [ ] arr , int [ , ] Q ) { for ( int i = 0 ; i < Q . Length ; i ++ ) { int or = 0 ; int x = Q [ i , 0 ] ; arr [ x - 1 ] = Q [ i , 1 ] ; for ( int j = 0 ; j < arr . Length ; j ++ ) { or = or | arr [ j ] ; } Console . Write ( or + " ▁ " ) ; } }
double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / Math . Pow ( 2 , fold ) ; }
float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; float r1 = r ; float h1 = h ; float V = ( float ) ( 3.14 * Math . Pow ( r1 , 2 ) * h1 ) ; return V ; }
int SquareRoot ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; }
double getTime ( int u , int v , int x ) { double speed = u + v ; double time = x / speed ; return time ; }
int waysOfDecoding ( String s ) { long [ ] dp = new long [ s . Length + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != '0' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return ( int ) dp [ s . Length ] ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
void smallestNumber ( int N ) { Console . Write ( N * Math . Ceiling ( Math . Pow ( 2 , ( N - 1 ) ) / N ) ) ; }
int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - ( int ) Math . Pow ( i , 2 ) ; else result = result + ( int ) Math . Pow ( i , 2 ) ; } return result ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int findXor ( int [ ] arr , int n ) { int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }
int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( Math . Max ( X , Y ) / Math . Min ( X , Y ) ) ; else return ( Math . Max ( 2 * X , Y ) / Math . Min ( 2 * X , Y ) ) ; }
double Area_of_Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * Math . Sqrt ( x ) ; return area ; }
float find_Area ( float a ) { float R = a * ( float ) ( 2.0 - Math . Sqrt ( 2 ) ) ; float area = ( float ) ( ( 3.14 * R * R ) / 2.0 ) ; return area ; }
void mulsum ( int [ ] arr , int n , int N ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } Console . Write ( sum ) ; }
int kthNonDivisible ( int N , int K ) { return ( int ) ( K + Math . Floor ( ( double ) ( K - 1 ) / ( N - 1 ) ) ) ; }
int concentric_Hexagon ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) / 2 ; }
bool check ( int [ ] arr , int n ) { int count = 0 ; int index = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) { count ++ ; index = i ; } } if ( count > 1 ) return false ; if ( count == 0 ) return true ; if ( index == n - 1 index == 1 ) return true ; if ( arr [ index - 1 ] < arr [ index + 1 ] ) return true ; if ( arr [ index - 2 ] < arr [ index ] ) return true ; return false ; }
void SternSequenceFunc ( List < int > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . Count < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . Add ( considered_element + precedent ) ; BrocotSequence . Add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) Console . Write ( BrocotSequence [ i ] + " ▁ " ) ; }
int countWords ( String str ) { int state = OUT ; int wc = 0 ; int i = 0 ; while ( i < str . Length ) { if ( str [ i ] == ' ▁ ' str [ i ] == ' STRNEWLINE ' str [ i ] == ' TABSYMBOL ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }
void oppositeFaceOfDice ( int N ) { int ans = 7 - N ; Console . Write ( ans ) ; }
int getOddOccurrence ( int [ ] arr , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
long count_Strings ( long n ) { int x = 1 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( 1 << x ) ; } return x - 1 ; }
int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }
int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; }
void newvol ( double x ) { Console . WriteLine ( " percentage ▁ increase ▁ " + " in ▁ the ▁ volume ▁ of ▁ the ▁ cylinder ▁ is ▁ " + x + " % " ) ; }
int icosikaiheptagonal ( int n ) { return ( 25 * n * n - 23 * n ) / 2 ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + 3 * n - 5 ; }
void findOptimalPairs ( int [ ] arr , int N ) { Array . Sort ( arr ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) Console . Write ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " ▁ " ) ; }
float area ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float A = a * b ; return A ; }
int printNthElement ( int n ) { int [ ] arr = new int [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }
bool isWordPresent ( String sentence , String word ) { String [ ] s = sentence . Split ( ' ▁ ' ) ; foreach ( String temp in s ) { if ( temp . CompareTo ( word ) == 0 ) { return true ; } } return false ; }
void solve ( int n , int d , int [ ] input ) { int [ ] a = new int [ N ] ; int [ ] cnt = new int [ V + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) a [ i ] = input [ i ] ; int answer = 0 ; for ( int i = 0 ; i < d ; ++ i ) cnt [ a [ i ] ] ++ ; for ( int i = d ; i <= n - 1 ; ++ i ) { int acc = 0 ; int low_median = - 1 , high_median = - 1 ; for ( int v = 0 ; v <= V ; ++ v ) { acc += cnt [ v ] ; if ( low_median == - 1 && acc >= ( int ) ( Math . Floor ( ( d + 1 ) / 2.0 ) ) ) low_median = v ; if ( high_median == - 1 && acc >= ( int ) ( Math . Ceiling ( ( d + 1 ) / 2.0 ) ) ) high_median = v ; } int double_median = low_median + high_median ; if ( a [ i ] >= double_median ) answer ++ ; cnt [ a [ i - d ] ] -- ; cnt [ a [ i ] ] ++ ; } Console . Write ( answer + " STRNEWLINE " ) ; }
void minimumCost ( int [ ] arr , int [ ] cost , int N ) { int [ , ] dp = new int [ N , 3 ] ; dp [ 0 , 0 ] = 0 ; dp [ 0 , 1 ] = cost [ 0 ] ; dp [ 0 , 2 ] = cost [ 0 ] * 2 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int minimum = ( int ) 1e6 ; if ( j + arr [ i ] != arr [ i - 1 ] ) minimum = Math . Min ( minimum , dp [ i - 1 , 0 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 1 ) minimum = Math . Min ( minimum , dp [ i - 1 , 1 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 2 ) minimum = Math . Min ( minimum , dp [ i - 1 , 2 ] ) ; dp [ i , j ] = j * cost [ i ] + minimum ; } } int ans = ( int ) 1e6 ; for ( int i = 0 ; i < 3 ; i ++ ) ans = Math . Min ( ans , dp [ N - 1 , i ] ) ; Console . Write ( ans + " STRNEWLINE " ) ; }
double distance ( int r , int R ) { double d = Math . Sqrt ( Math . Pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
int CtSubarr ( int [ ] arr , int N , int K ) { HashSet < int > st = new HashSet < int > ( ) ; int prefixSum = 0 ; st . Add ( prefixSum ) ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefixSum += arr [ i ] ; if ( st . Contains ( prefixSum - K ) ) { res += 1 ; prefixSum = 0 ; st . Clear ( ) ; st . Add ( 0 ) ; } st . Add ( prefixSum ) ; } return res ; }
void shuffle ( int N , int key ) { int NO_OF_BITS = N ; int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } Console . Write ( reverse_num ) ; }
long nextFibonacci ( int n ) { double a = n * ( 1 + Math . Sqrt ( 5 ) ) / 2.0 ; return ( long ) Math . Round ( a ) ; }
int nthOdd ( int n ) { return ( 2 * n - 1 ) ; }
void findpair ( int l , int r ) { int ans1 = l ; int ans2 = 2 * l ; Console . WriteLine ( ans1 + " , ▁ " + ans2 ) ; }
bool isCenteredtridecagonal ( int N ) { float n = ( float ) ( ( 13 + Math . Sqrt ( 104 * N + 65 ) ) / 26 ) ; return ( n - ( int ) n ) == 0 ; }
int printNumber ( int N , int K , int M ) { int sum = K * ( M * ( M + 1 ) / 2 ) ; return sum - N ; }
int minSteps ( int N ) { int res = ( ( int ) Math . Sqrt ( 1 + 8 * N ) - 1 ) / 2 ; return res ; }
float sumOfSeries ( int x , int k ) { float y = ( float ) ( ( ( float ) ( x ) / 81 ) * ( 9 * k - 1 + Math . Pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }
void findEquation ( int A , int B , int C , int K ) { Console . Write ( A + " ▁ " + K * B + " ▁ " + K * K * C ) ; }
int steps ( int source , int step , int dest ) { if ( Math . Abs ( source ) > ( dest ) ) return int . MaxValue ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . Min ( pos , neg ) ; }
int xorOfArray ( int [ ] arr , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }
int solve ( int N , int M , int [ ] cp , int [ ] sp ) { int [ ] profit = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; Array . Sort ( profit ) ; Array . Reverse ( profit ) ; int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
int minOperations ( int N ) { double x = Math . Log ( N , 2 ) ; int ans = ( int ) ( Math . Ceiling ( x ) ) ; return ans ; }
bool isTrimorphic ( int N ) { int cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N /= 10 ; cube /= 10 ; } return true ; }
void asciiToSentence ( String str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; Console . Write ( ch ) ; num = 0 ; } } }
int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }
int squares ( int l , int b , int a ) { return ( int ) ( Math . Ceiling ( l / ( double ) a ) * Math . Ceiling ( b / ( double ) a ) ) ; }
int findMinDiff ( int [ ] arr , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; Array . Sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = int . MaxValue ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
float squareArea ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) ( Math . Pow ( 1.268 , 2 ) * Math . Pow ( a , 2 ) ) ; return area ; }
int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; }
void FindTrip ( int [ ] arr , int N ) { for ( int i = 1 ; i < N - 1 ; i ++ ) { int p = arr [ i - 1 ] ; int q = arr [ i ] ; int r = arr [ i + 1 ] ; if ( p < q && q > r ) { Console . WriteLine ( ( i - 1 ) + " ▁ " + ( i ) + " ▁ " + ( i + 1 ) ) ; return ; } } Console . WriteLine ( - 1 ) ; }
long sum ( long n ) { long root = ( long ) Math . Sqrt ( n ) ; long ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }
int titleToNumber ( string s ) { int result = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { result *= 26 ; result += s [ i ] - ' A ' + 1 ; } return result ; }
bool isPentadecagon ( int N ) { double n = ( 11 + Math . Sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; }
int minJumps ( int [ ] arr , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return int . MaxValue ; int min = int . MaxValue ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != int . MaxValue && jumps + 1 < min ) min = jumps + 1 ; } return min ; }
String make_String_S_to_T ( String S , String T ) { bool possible = false ; int M = T . Length ; int N = S . Length ; for ( int i = 0 ; i <= M ; i ++ ) { int prefix_length = i ; int suffix_length = M - i ; String prefix = S . Substring ( 0 , prefix_length ) ; String suffix = S . Substring ( N - suffix_length , suffix_length ) ; if ( ( prefix + suffix ) . Equals ( T ) ) { possible = true ; break ; } } if ( possible ) return " YES " ; else return " NO " ; }
int complement ( int num ) { int len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = num / 10 ; if ( Math . Abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . Pow ( 10 , len ) - num ; return comp ; }
bool isenneadecagonal ( int N ) { float n = ( float ) ( 15 + Math . Sqrt ( 136 * N + 225 ) ) / 34 ; return ( n - ( int ) n ) == 0 ; }
void replaceOriginal ( String s , int n ) { char [ ] r = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != ' a ' && s [ i ] != ' e ' && s [ i ] != ' i ' && s [ i ] != ' o ' && s [ i ] != ' u ' ) { Console . Write ( r [ i ] ) ; } } Console . WriteLine ( " " ) ; }
void minCost ( int [ ] arr ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } Console . Write ( Math . Min ( even , odd ) ) ; }
int numPairs ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; }
string longestCommonPrefix ( String [ ] a ) { int size = a . Length ; if ( size == 0 ) return " " ; if ( size == 1 ) return a [ 0 ] ; Array . Sort ( a ) ; int end = Math . Min ( a [ 0 ] . Length , a [ size - 1 ] . Length ) ; int i = 0 ; while ( i < end && a [ 0 ] [ i ] == a [ size - 1 ] [ i ] ) i ++ ; string pre = a [ 0 ] . Substring ( 0 , i ) ; return pre ; }
bool prodSquare ( int n ) { Dictionary < float , float > s = new Dictionary < float , float > ( ) ; for ( int i = 2 ; i * i <= n ; ++ i ) { s . Add ( ( float ) ( i * i ) , ( float ) 1 ) ; if ( s . ContainsKey ( ( float ) n / ( i * i ) ) ) return true ; } return false ; }
int findSubarrays ( int [ ] arr , int N , int K ) { return N - K + 1 ; }
int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return - 1 ; }
int search ( int [ ] arr , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . Abs ( arr [ i ] - x ) ; } Console . WriteLine ( " number ▁ is ▁ not " + " ▁ present ! " ) ; return - 1 ; }
int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr = 0 ; if ( n == 0 ) Console . Write ( first ) ; else if ( n == 1 n == 2 ) Console . Write ( second ) ; else if ( n == 3 ) Console . Write ( fourth ) ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } Console . Write ( curr ) ; } }
void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = Math . Max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; Console . WriteLine ( ans ) ; } else { Console . WriteLine ( ( budget / plastic ) ) ; } }
double heptdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.802 * a ; return d ; }
bool isFibbinaryNum ( int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
int minCount ( int [ ] A , int [ ] B , int N ) { int i = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) { i ++ ; } } return N - i ; }
int maxbalancedprefix ( string str , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
int DecreasingArray ( int [ ] a , int n ) { int sum = 0 , dif = 0 ; List < int > pq = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( pq . Count > 0 && pq [ 0 ] < a [ i ] ) { dif = a [ i ] - pq [ 0 ] ; sum += dif ; pq . RemoveAt ( 0 ) ; } pq . Add ( a [ i ] ) ; pq . Sort ( ) ; } return sum ; }
int previousFibonacci ( int n ) { double a = n / ( ( 1 + Math . Sqrt ( 5 ) ) / 2.0 ) ; return ( int ) Math . Round ( a ) ; }
void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) Console . WriteLine ( " STRNEWLINE Equal " ) ; else if ( ( x & ( ~ y ) ) > y ) Console . WriteLine ( y ) ; else Console . WriteLine ( x ) ; }
int cal ( int n ) { double res = Math . Pow ( Math . Ceiling ( ( Math . Pow ( Math . Pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return ( int ) res ; }
bool isnonagonal ( int N ) { double n = ( 5 + Math . Sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
void maximum_inversion ( int n , int k ) { int answer = 0 ; k = Math . Min ( k , n / 2 ) ; int left = 1 ; int right = n ; while ( k != 0 ) { k -- ; answer += 2 * ( right - left ) - 1 ; left ++ ; right -- ; } Console . WriteLine ( answer ) ; }
void merge_and_sort ( int [ ] output , int [ , ] arr , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i , j ] ; } } Array . Sort ( output ) ; }
int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n != 0 ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
bool isint ( double N ) { int X = ( int ) N ; double temp2 = N - X ; if ( temp2 > 0 ) { return false ; } return true ; }
bool checkPalindromeB ( int N , int B ) { int rev = 0 ; int N1 = N ; while ( N1 > 0 ) { rev = rev * B + N1 % B ; N1 = N1 / B ; } return N == rev ; }
int findSum ( int L , int R ) { ArrayList arr = new ArrayList ( ) ; int i = 0 ; int x = 2 ; while ( i <= R ) { arr . Add ( i + x ) ; if ( i + 1 <= R ) arr . Add ( i + 1 + x ) ; x *= - 1 ; i += 2 ; } int sum = 0 ; for ( i = L ; i <= R ; ++ i ) sum += ( int ) arr [ i ] ; return sum ; }
void twoWaySort ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }
void checkSuffix ( int A , int B ) { String s1 = String . Join ( " " , A ) ; String s2 = String . Join ( " " , B ) ; bool result ; result = s1 . EndsWith ( s2 ) ; if ( result ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } }
String getResult ( int n ) { string st = n . ToString ( ) ; for ( int i = 0 ; i < st . Length ; i ++ ) { int d = st [ i ] - 48 ; if ( n % d == 0 ) { return " Yes " ; } } return " No " ; }
int countNumbers ( int N ) { return ( int ) ( Math . Sqrt ( N ) ) - 1 ; }
double area_cicumscribed ( double c ) { return ( c * c * ( PI / 4 ) ) ; }
void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { Console . WriteLine ( k * ( 6 * i + 1 ) + " ▁ " + k * ( 6 * i + 2 ) + " ▁ " + k * ( 6 * i + 3 ) + " ▁ " + k * ( 6 * i + 5 ) ) ; } }
int findCnt ( int [ ] arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; int x = Math . Max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }
void Kroneckerproduct ( int [ , ] A , int [ , ] B ) { int [ , ] C = new int [ rowa * rowb , cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 , j + k + 1 ] = A [ i , j ] * B [ k , l ] ; Console . Write ( C [ i + l + 1 , j + k + 1 ] + " ▁ " ) ; } } Console . WriteLine ( ) ; } } }
void check ( int [ ] arr , int N ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; }
int minSum ( int [ ] A , int [ ] B , int [ ] C , int i , int n , int curr , int [ , ] dp ) { if ( n <= 0 ) return 0 ; if ( dp [ n , curr ] != - 1 ) return dp [ n , curr ] ; if ( curr == 0 ) { return dp [ n , curr ] = Math . Min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n , curr ] = Math . Min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n , curr ] = Math . Min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; }
int equvInverse ( int [ ] arr , int N , int P ) { int cntElem = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; }
new StringBuilder ( ) ; public static String processWords ( String input ) { String [ ] s = input . Split ( ' ▁ ' ) ; foreach ( String values in s ) { charBuffer . Append ( values [ 0 ] ) ; } return charBuffer . ToString ( ) ; }
int gonNum65537 ( int n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; }
int maximumAND ( int L , int R ) { return R ; }
int maxWeight ( int [ ] arr , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i , w1_r , w2_r ] != - 1 ) return dp [ i , w1_r , w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i , w1_r , w2_r ] = Math . Max ( fill_none , Math . Max ( fill_w1 , fill_w2 ) ) ; return dp [ i , w1_r , w2_r ] ; }
int get_subset_count ( int [ ] arr , int K , int N ) { Array . Sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; }
String encryptString ( String str , int n ) { int i = 0 , cnt = 0 ; String encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; }
int NoCarrySum ( int N , int M ) { return N ^ M ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + ( float ) Math . Sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - ( float ) Math . Sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . Floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . Floor ( root2 ) == root2 ) return true ; return false ; }
bool isSubsetSum ( int [ ] set , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
void getSum ( int n ) { bool isOdd = ( n % 2 == 1 ) ? true : false ; int sumOdd = 0 , sumEven = 0 ; while ( n != 0 ) { if ( isOdd ) sumOdd += n % 10 ; else sumEven += n % 10 ; isOdd = ! isOdd ; n /= 10 ; } Console . WriteLine ( " Sum ▁ odd ▁ = ▁ " + sumOdd ) ; Console . Write ( " Sum ▁ even ▁ = ▁ " + sumEven ) ; }
void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = ( float ) Math . Sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = ( float ) Math . Sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = ( float ) 3.14159 ; float A = ( 180 / pi ) * ( float ) ( Math . Acos ( d ) ) ; Console . Write ( " Angle ▁ is ▁ " + A + " ▁ degree " ) ; }
int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; }
String NimGame ( int N , int A , int B ) { int sum = A + B ; if ( N % sum <= A - 1 ) return " Bob " ; else return " Alice " ; }
int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
void center ( int x1 , int x2 , int y1 , int y2 ) { Console . WriteLine ( ( float ) ( x1 + x2 ) / 2 + " , ▁ " + ( float ) ( y1 + y2 ) / 2 ) ; }
void angleextcycquad ( int z ) { Console . WriteLine ( " The ▁ exterior ▁ angle ▁ of ▁ the " + " ▁ cyclic ▁ quadrilateral ▁ is ▁ " + z + " ▁ degrees " ) ; }
int proizvolov ( int [ ] a , int [ ] b , int n ) { return n * n ; }
bool isPossible ( int w , int h , int x , int y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }
void quadrant ( String s ) { int l = s . Length ; int i ; if ( s . Contains ( " + " ) ) { i = s . IndexOf ( ' + ' ) ; } else { i = s . IndexOf ( ' - ' ) ; } String real = s . Substring ( 0 , i ) ; String imaginary = s . Substring ( i + 1 , l - 2 - i ) ; int x = Int32 . Parse ( real ) ; int y = Int32 . Parse ( imaginary ) ; if ( x > 0 && y > 0 ) Console . Write ( " Quadrant ▁ 1" ) ; else if ( x < 0 && y > 0 ) Console . Write ( " Quadrant ▁ 2" ) ; else if ( x < 0 && y < 0 ) Console . Write ( " Quadrant ▁ 3" ) ; else if ( x > 0 && y < 0 ) Console . Write ( " Quadrant ▁ 4" ) ; else if ( x == 0 && y > 0 ) Console . Write ( " Lies ▁ on ▁ positive " + " ▁ Imaginary ▁ axis " ) ; else if ( x == 0 && y < 0 ) Console . Write ( " Lies ▁ on ▁ negative " + " ▁ Imaginary ▁ axis " ) ; else if ( y == 0 && x < 0 ) Console . Write ( " Lies ▁ on ▁ negative " + " ▁ X - axis " ) ; else if ( y == 0 && x > 0 ) Console . Write ( " Lies ▁ on ▁ positive " + " ▁ X - axis " ) ; else Console . Write ( " Lies ▁ on ▁ the ▁ Origin " ) ; }
void print ( int n ) { Console . WriteLine ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) Console . Write ( i + " ▁ " ) ; for ( int i = 1 ; i <= n ; i += 2 ) Console . Write ( i + " ▁ " ) ; for ( int i = 2 ; i <= n ; i += 2 ) Console . Write ( i + " ▁ " ) ; }
double innerCirclearea ( double radius ) { if ( radius < 0 ) { return - 1 ; } double r = radius / 2 ; double Area = ( 3.14 * Math . Pow ( r , 2 ) ) ; return Area ; }
void dfs ( int [ ] val , int [ ] cost , List < int > [ ] tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . Count ; i ++ ) { dfs ( val , cost , tr , tr [ u ] [ i ] , s ) ; } }
double countNumbers ( int N ) { return ( Math . Pow ( 10 , N ) - 1 ) - ( Math . Pow ( 10 , N ) - Math . Pow ( 8 , N ) ) / 2 ; }
int maxSumWO3Consec ( int [ ] arr , int n ) { int [ ] sum = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . Max ( sum [ 1 ] , Math . Max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . Max ( Math . Max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; }
void Alphabet_N_Pattern ( int N ) { int index , side_index ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { Console . Write ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) Console . Write ( " ▁ " ) ; if ( index != 0 && index != N - 1 ) Console . Write ( Diagonal ++ ) ; else Console . Write ( " ▁ " ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) Console . Write ( " ▁ " ) ; Console . Write ( Right ++ ) ; Console . Write ( " STRNEWLINE " ) ; } }
void findNthTerm ( int n ) { Console . WriteLine ( n * ( 4 * n + 3 ) ) ; }
int cntElements ( int [ ] arr , int n ) { int [ ] copy_arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }
void printPascal ( int n ) { int [ , ] arr = new int [ n , n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line , i ] = 1 ; else arr [ line , i ] = arr [ line - 1 , i - 1 ] + arr [ line - 1 , i ] ; Console . Write ( arr [ line , i ] ) ; } Console . WriteLine ( " " ) ; } }
bool arraySortedOrNot ( int [ ] arr , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; bool [ ] arr = new bool [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
void printElements ( int [ ] arr , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { Console . Write ( arr [ i ] + " ▁ " ) ; } } }
void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; }
int nthTerm ( int n ) { return ( int ) Math . Pow ( n , 2 ) + 4 * n ; }
void checkEvenOdd ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { Console . Write ( " Even " ) ; return ; } } Console . Write ( " Odd " ) ; }
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
bool pointsAreOnSameSideOfLine ( int a , int b , int c , int x1 , int y1 , int x2 , int y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }
string getResult ( string st ) { int sum = 0 ; int length = st . Length ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + ( int ) Math . Pow ( st [ i ] - '0' , length ) ; } int number = int . Parse ( st ) ; if ( number == sum ) return " yes " ; else return " no " ; }
void countWaysToTileBoard ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } Console . Write ( dp [ N ] ) ; }
bool flipsPossible ( int [ ] a , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }
int countTripletsLessThanL ( int n , int L , int [ ] arr ) { Array . Sort ( arr ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
int countIncreasing ( int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
int getSingle ( int [ ] arr , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
bool topsyTurvy ( char [ ] str ) { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '2' str [ i ] == '4' str [ i ] == '5' str [ i ] == '6' str [ i ] == '7' str [ i ] == '9' ) { return false ; } } return true ; }
int minOps ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int max = arr [ arr . Length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { Console . Write ( i + " , ▁ " + j + " , ▁ " + k ) ; return ; } } } Console . Write ( " No ▁ Triplet " ) ; }
int nextGreater ( int N ) { int power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
int CountWays ( int r , int b , int l , int R , int B , int W , int [ , , ] dp ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r , b , l ] != - 1 ) return dp [ r , b , l ] ; int ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r , b , l ] = ans ; }
long factorial ( int n ) { long M = 1000000007 ; long f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) return f ; }
void compareValues ( int a , int b , int c , int d ) { double log1 = Math . Log10 ( a ) ; double num1 = log1 * b ; double log2 = Math . Log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) Console . WriteLine ( a + " ^ " + b ) ; else Console . WriteLine ( c + " ^ " + d ) ; }
int MinimumNoOfWays ( int [ ] arr , int n ) { int mini_no_of_ways ; if ( n % 2 == 0 ) { mini_no_of_ways = n / 2 ; } else { mini_no_of_ways = n / 2 + 1 ; } return mini_no_of_ways ; }
void printMaxNumber ( int n ) { if ( n % 2 != 0 ) { Console . Write ( "7" ) ; for ( int i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) Console . Write ( "1" ) ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) Console . Write ( "1" ) ; } }
int countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( N / i != i ) { count ++ ; } } } return count ; }
void insertAfter ( Node prev_node , int new_data ) { if ( prev_node == null ) { Console . WriteLine ( " The ▁ given ▁ previous ▁ node " + " ▁ cannot ▁ be ▁ null " ) ; return ; } Node new_node = new Node ( new_data ) ; new_node . next = prev_node . next ; prev_node . next = new_node ; }
double findAverageOfCube ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; }
int countCubes ( int a , int b ) { return ( int ) ( Math . Floor ( Math . Cbrt ( b ) ) - Math . Ceiling ( Math . Cbrt ( a ) ) + 1 ) ; }
void rotate90Clockwise ( int [ , ] arr ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) Console . Write ( arr [ i , j ] + " ▁ " ) ; Console . WriteLine ( ) ; } }
int coutSubSeq ( int [ ] A , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
double square ( double a ) { if ( a < 0 ) return - 1 ; double x = 0.464 * a ; return x ; }
int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
double calcDeterminant ( int [ ] arr ) { double determinant = 0 ; for ( int i = 0 ; i < N ; i ++ ) { determinant += Math . Pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; }
void printKthBit ( long n , long k ) { Console . WriteLine ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
int findLCS ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } return mp . Count ; }
int minOccupiedPosition ( int [ ] A , int n ) { int minPos = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; }
int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' a ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' b ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' c ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
void countWaysToJump ( int [ ] arr , int n ) { int [ ] count_jump = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) count_jump [ i ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( count_jump [ i ] + " ▁ " ) ; }
float sphere ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; return r ; }
int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . Sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . Ceiling ( eq_root ) + l ) ; }
void printKPFNums ( int A , int B , int K ) { bool [ ] prime = new bool [ B + 1 ] ; for ( int i = 0 ; i < B + 1 ; i ++ ) prime [ i ] = true ; int [ ] p_factors = new int [ B + 1 ] ; for ( int i = 0 ; i < B + 1 ; i ++ ) p_factors [ i ] = 0 ; for ( int p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( int i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( int i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) Console . Write ( i + " ▁ " ) ; }
int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
double cubeRoot ( double n ) { double ans = Math . Pow ( 3 , ( ( 1.0 / 3 ) * ( Math . Log ( n ) / Math . Log ( 3 ) ) ) ) ; return ans ; }
void check ( ulong m , ulong n ) { double RHS = m * ( double ) Math . Log ( n ) ; double LHS = n * ( double ) Math . Log ( m ) ; if ( LHS > RHS ) Console . Write ( " m ^ n ▁ > ▁ n ^ m " ) ; else if ( LHS < RHS ) Console . Write ( " m ^ n ▁ < ▁ n ^ m " ) ; else Console . Write ( " m ^ n ▁ = ▁ n ^ m " ) ; }
String checkPattern ( int [ ] arr , int m , int k , int n ) { int count = 1 , t = 0 ; for ( int i = 0 ; i < n - m ; i ++ ) { if ( arr [ i ] == arr [ i + m ] ) { t ++ ; if ( t == m ) { t = 0 ; count ++ ; if ( count == k ) { return " Yes " ; } } } else { t = 0 ; count = 1 ; } } return " No " ; }
int maxModulosum ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; }
int sumBetweenTwoKth ( int [ ] arr , int n , int k1 , int k2 ) { Array . Sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
int lis ( int [ ] arr , int n ) { int [ ] lis = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
int findMin ( int N ) { int digit = N % 10 ; switch ( digit ) { case 0 : if ( N >= 90 ) return 10 ; break ; case 1 : if ( N >= 81 ) return 9 ; break ; case 2 : if ( N >= 72 ) return 8 ; break ; case 3 : if ( N >= 63 ) return 7 ; break ; case 4 : if ( N >= 54 ) return 6 ; break ; case 5 : if ( N >= 45 ) return 5 ; break ; case 6 : if ( N >= 36 ) return 4 ; break ; case 7 : if ( N >= 27 ) return 3 ; break ; case 8 : if ( N >= 18 ) return 2 ; break ; case 9 : if ( N >= 9 ) return 1 ; break ; } return - 1 ; }
bool isPowerOfTwo ( int n ) { return ( Math . Ceiling ( Math . Log ( n ) / Math . Log ( 2 ) ) == Math . Floor ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; }
int rotate ( int [ ] arr , int N , int X ) { int nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return nextPower - N ; int prevPower = nextPower / 2 ; return 2 * ( N - prevPower ) + 1 ; }
void printClosest ( int [ ] ar1 , int [ ] ar2 , int m , int n , int x ) { int diff = int . MaxValue ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . Abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . Abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } Console . Write ( " The ▁ closest ▁ pair ▁ is ▁ [ " + ar1 [ res_l ] + " , ▁ " + ar2 [ res_r ] + " ] " ) ; }
int longestSubseq ( String s ) { int n = s . Length ; int [ ] pre_count_0 = new int [ n + 2 ] ; int [ ] pre_count_1 = new int [ n + 1 ] ; int [ ] post_count_0 = new int [ n + 2 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s [ j - 1 ] == '0' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s [ n - j ] == '0' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = Math . Max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; }
bool isPerfectSquareString ( string str ) { int sum = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] ; double squareRoot = Math . Sqrt ( sum ) ; double F = Math . Floor ( squareRoot ) ; return ( ( squareRoot - F ) == 0 ) ; }
int kthNum ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; }
