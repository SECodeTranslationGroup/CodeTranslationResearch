def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = math . pow ( 2 , l - 1 ) ; NEW_LINE sumLastLevel = 0 ; NEW_LINE sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) ; NEW_LINE sum = sumLastLevel * l ; NEW_LINE return int ( sum ) ; NEW_LINE DEDENT
def shortestChainLen ( start , target , D ) : NEW_LINE INDENT if start == target : NEW_LINE return 0 NEW_LINE if target not in D : NEW_LINE INDENT return 0 NEW_LINE DEDENT level , wordlength = 0 , len ( start ) NEW_LINE Q = deque ( ) NEW_LINE Q . append ( start ) NEW_LINE while ( len ( Q ) > 0 ) : NEW_LINE INDENT level += 1 NEW_LINE sizeofQ = len ( Q ) NEW_LINE for i in range ( sizeofQ ) : NEW_LINE INDENT word = [ j for j in Q . popleft ( ) ] NEW_LINE for pos in range ( wordlength ) : NEW_LINE INDENT orig_char = word [ pos ] NEW_LINE for c in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT word [ pos ] = chr ( c ) NEW_LINE if ( " " . join ( word ) == target ) : NEW_LINE INDENT return level + 1 NEW_LINE DEDENT if ( " " . join ( word ) not in D ) : NEW_LINE INDENT continue NEW_LINE DEDENT del D [ " " . join ( word ) ] NEW_LINE Q . append ( " " . join ( word ) ) NEW_LINE DEDENT word [ pos ] = orig_char NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT
def minCost ( cost ) : NEW_LINE INDENT dist = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT
def numOfways ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if ( k % 2 ) : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n NEW_LINE DEDENT
def power ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT
def checkStar ( mat ) : NEW_LINE INDENT global size NEW_LINE vertexD1 = 0 NEW_LINE vertexDn_1 = 0 NEW_LINE if ( size == 1 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 ) NEW_LINE DEDENT if ( size == 2 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) NEW_LINE DEDENT for i in range ( 0 , size ) : NEW_LINE INDENT degreeI = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT degreeI = degreeI + 1 NEW_LINE DEDENT DEDENT if ( degreeI == 1 ) : NEW_LINE INDENT vertexD1 = vertexD1 + 1 NEW_LINE DEDENT elif ( degreeI == size - 1 ) : NEW_LINE INDENT vertexDn_1 = vertexDn_1 + 1 NEW_LINE DEDENT DEDENT return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 ) NEW_LINE DEDENT mat = [ [ 0 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] NEW_LINE if ( checkStar ( mat ) ) : NEW_LINE INDENT print ( " Star ▁ Graph " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Star ▁ Graph " ) NEW_LINE DEDENT
def push ( self , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = self . head NEW_LINE self . head = new_node NEW_LINE DEDENT
def insertAfter ( self , prev_node , new_data ) : NEW_LINE INDENT if prev_node is None : NEW_LINE INDENT print " The ▁ given ▁ previous ▁ node ▁ must ▁ inLinkedList . " NEW_LINE return NEW_LINE DEDENT new_node = Node ( new_data ) NEW_LINE new_node . next = prev_node . next NEW_LINE prev_node . next = new_node NEW_LINE DEDENT
def count ( self , temp , key ) : NEW_LINE INDENT if temp is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT if temp . data == key : NEW_LINE INDENT return 1 + count ( temp . next , key ) NEW_LINE DEDENT return count ( temp . next , key ) NEW_LINE DEDENT
def printSorted ( arr , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return NEW_LINE DEDENT printSorted ( arr , start * 2 + 1 , end ) NEW_LINE print ( arr [ start ] , end = " ▁ " ) NEW_LINE printSorted ( arr , start * 2 + 2 , end ) NEW_LINE DEDENT
def pairs ( arr , n , k ) : NEW_LINE INDENT smallest = 999999999999 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] + arr [ j ] - k ) < smallest : NEW_LINE INDENT smallest = abs ( arr [ i ] + arr [ j ] - k ) NEW_LINE count = 1 NEW_LINE DEDENT elif abs ( arr [ i ] + arr [ j ] - k ) == smallest : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " Minimal ▁ Value ▁ = ▁ " , smallest ) NEW_LINE print ( " Total ▁ Pairs ▁ = ▁ " , count ) NEW_LINE DEDENT
def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n // 2 ] [ i ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , row_sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n // 2 ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " , col_sum ) NEW_LINE DEDENT
def interchangeFirstLast ( mat , n , m ) : NEW_LINE INDENT rows = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = mat [ 0 ] [ i ] NEW_LINE mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] NEW_LINE mat [ rows - 1 ] [ i ] = t NEW_LINE DEDENT DEDENT mat = [ [ 8 , 9 , 7 , 6 ] , [ 4 , 7 , 6 , 5 ] , [ 3 , 2 , 1 , 8 ] , [ 9 , 9 , 7 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE interchangeFirstLast ( mat , n , m ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT
def checkMarkov ( m ) : NEW_LINE INDENT for i in range ( 0 , len ( m ) ) : NEW_LINE INDENT sm = 0 NEW_LINE for j in range ( 0 , len ( m [ i ] ) ) : NEW_LINE INDENT sm = sm + m [ i ] [ j ] NEW_LINE DEDENT if ( sm != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT m = [ [ 0 , 0 , 1 ] , [ 0.5 , 0 , 0.5 ] , [ 1 , 0 , 0 ] ] NEW_LINE if ( checkMarkov ( m ) ) : NEW_LINE INDENT print ( " ▁ yes ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ no ▁ " ) NEW_LINE DEDENT
def isDiagonalMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 4 , 0 , 0 , 0 ] , [ 0 , 7 , 0 , 0 ] , [ 0 , 0 , 5 , 0 ] , [ 0 , 0 , 0 , 1 ] ] NEW_LINE if ( isDiagonalMatrix ( mat ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isScalarMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 2 , 0 , 0 , 0 ] , [ 0 , 2 , 0 , 0 ] , [ 0 , 0 , 2 , 0 ] , [ 0 , 0 , 0 , 2 ] ] NEW_LINE if ( isScalarMatrix ( mat ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def Kroneckerproduct ( A , B ) : NEW_LINE INDENT C = [ [ 0 for j in range ( cola * colb ) ] for i in range ( rowa * rowb ) ] NEW_LINE for i in range ( 0 , rowa ) : NEW_LINE INDENT for k in range ( 0 , rowb ) : NEW_LINE INDENT for j in range ( 0 , cola ) : NEW_LINE INDENT for l in range ( 0 , colb ) : NEW_LINE INDENT C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] NEW_LINE print ( C [ i + l + 1 ] [ j + k + 1 ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT DEDENT DEDENT
def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE k = 7 NEW_LINE freq = find ( n , k ) NEW_LINE if ( freq < 0 ) : NEW_LINE INDENT print ( " ▁ element ▁ not ▁ exist " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ Frequency ▁ of ▁ " , k , " ▁ is ▁ " , freq ) NEW_LINE DEDENT
def minimumflip ( mat , n ) : NEW_LINE INDENT transpose = [ [ 0 ] * n ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT transpose [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if transpose [ i ] [ j ] != mat [ i ] [ j ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( flip / 2 ) NEW_LINE DEDENT
def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if mat [ i ] [ j ] != mat [ j ] [ i ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
def islowertriangular ( M ) : NEW_LINE INDENT for i in range ( 0 , len ( M ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( M ) ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT M = [ [ 1 , 0 , 0 , 0 ] , [ 1 , 4 , 0 , 0 ] , [ 4 , 6 , 2 , 0 ] , [ 0 , 4 , 7 , 6 ] ] NEW_LINE if islowertriangular ( M ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isuppertriangular ( M ) : NEW_LINE INDENT for i in range ( 1 , len ( M ) ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT M = [ [ 1 , 3 , 5 , 3 ] , [ 0 , 4 , 6 , 2 ] , [ 0 , 0 , 2 , 5 ] , [ 0 , 0 , 0 , 6 ] ] NEW_LINE if isuppertriangular ( M ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def freq ( ar , m , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " , odd ) NEW_LINE print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = " , even ) NEW_LINE DEDENT
def Identity ( size ) : NEW_LINE INDENT for row in range ( 0 , size ) : NEW_LINE INDENT for col in range ( 0 , size ) : NEW_LINE INDENT if ( row == col ) : NEW_LINE INDENT print ( "1 ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0 ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def isIdentity ( mat , N ) : NEW_LINE INDENT for row in range ( N ) : NEW_LINE INDENT for col in range ( N ) : NEW_LINE INDENT if ( row == col and mat [ row ] [ col ] != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT N = 4 ; NEW_LINE mat = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 1 ] ] ; NEW_LINE if ( isIdentity ( mat , N ) ) : NEW_LINE INDENT print ( " Yes ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) ; NEW_LINE DEDENT
def search ( mat , n , x ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == x ) : NEW_LINE INDENT print ( " Element ▁ found ▁ at ▁ ( " , i , " , " , j , " ) " ) NEW_LINE return 1 NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ Element ▁ not ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
def search ( mat , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < n and j >= 0 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == x ) : NEW_LINE INDENT print ( " n ▁ Found ▁ at ▁ " , i , " , ▁ " , j ) NEW_LINE return 1 NEW_LINE DEDENT if ( mat [ i ] [ j ] > x ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( " Element ▁ not ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
def calculateEnergy ( mat , n ) : NEW_LINE INDENT tot_energy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT q = mat [ i ] [ j ] // n NEW_LINE i_des = q NEW_LINE j_des = mat [ i ] [ j ] - ( n * q ) NEW_LINE tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) NEW_LINE DEDENT DEDENT return tot_energy NEW_LINE DEDENT
def countUnique ( mat , n , m ) : NEW_LINE INDENT rowsum = [ 0 ] * n ; NEW_LINE colsum = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 ) : NEW_LINE INDENT rowsum [ i ] += 1 ; NEW_LINE colsum [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT uniquecount = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) : NEW_LINE INDENT uniquecount += 1 ; NEW_LINE DEDENT DEDENT DEDENT return uniquecount ; NEW_LINE DEDENT
def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def areSumSame ( a , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT sum1 += a [ i ] [ j ] NEW_LINE sum2 += a [ j ] [ i ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def findMax ( arr ) : NEW_LINE INDENT row = 0 NEW_LINE j = N - 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( arr [ i ] [ j ] == 1 and j >= 0 ) : NEW_LINE INDENT row = i NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( " Row ▁ number ▁ = ▁ " , row + 1 , " , ▁ MaxCount ▁ = ▁ " , N - 1 - j ) NEW_LINE DEDENT
def isSymmetric ( mat , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] NEW_LINE if ( isSymmetric ( mat , 3 ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def printDiagonalSums ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT principal += mat [ i ] [ i ] NEW_LINE secondary += mat [ i ] [ n - i - 1 ] NEW_LINE DEDENT print ( " Principal ▁ Diagonal : " , principal ) NEW_LINE print ( " Secondary ▁ Diagonal : " , secondary ) NEW_LINE DEDENT
def printBoundary ( a , m , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( i == m - 1 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( j == n - 1 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def printSpiral ( mat , r , c ) : NEW_LINE INDENT a = 0 NEW_LINE b = 2 NEW_LINE low_row = 0 if ( 0 > a ) else a NEW_LINE low_column = 0 if ( 0 > b ) else b - 1 NEW_LINE high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1 NEW_LINE high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1 NEW_LINE while ( ( low_row > 0 - r and low_column > 0 - c ) ) : NEW_LINE INDENT i = low_column + 1 NEW_LINE while ( i <= high_column and i < c and low_row >= 0 ) : NEW_LINE INDENT print ( mat [ low_row ] [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT low_row -= 1 NEW_LINE i = low_row + 2 NEW_LINE while ( i <= high_row and i < r and high_column < c ) : NEW_LINE INDENT print ( mat [ i ] [ high_column ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT high_column += 1 NEW_LINE i = high_column - 2 NEW_LINE while ( i >= low_column and i >= 0 and high_row < r ) : NEW_LINE INDENT print ( mat [ high_row ] [ i ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT high_row += 1 NEW_LINE i = high_row - 2 NEW_LINE while ( i > low_row and i >= 0 and low_column >= 0 ) : NEW_LINE INDENT print ( mat [ i ] [ low_column ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT low_column -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT d1 += arr [ i ] [ j ] NEW_LINE DEDENT if ( i == n - j - 1 ) : NEW_LINE INDENT d2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return abs ( d1 - d2 ) ; NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT d1 = d1 + arr [ i ] [ i ] NEW_LINE d2 = d2 + arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT return abs ( d1 - d2 ) NEW_LINE DEDENT
def MAXMIN ( arr , n ) : NEW_LINE INDENT MIN = 10 ** 9 NEW_LINE MAX = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n // 2 + 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT if ( MIN > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT MIN = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT if ( MAX < arr [ i ] [ j ] ) : NEW_LINE INDENT MAX = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( MIN > arr [ i ] [ j ] ) : NEW_LINE INDENT MIN = arr [ i ] [ j ] NEW_LINE DEDENT if ( MAX < arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT MAX = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " MAXimum ▁ = " , MAX , " , ▁ MINimum ▁ = " , MIN ) NEW_LINE DEDENT
def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT ans = 0 ; temp = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if temp < n : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while temp < n : NEW_LINE INDENT if temp + i <= n : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT
def spiralDiaSum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT
def maxXOR ( mat , N ) : NEW_LINE INDENT max_xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT r_xor = r_xor ^ mat [ i ] [ j ] NEW_LINE c_xor = c_xor ^ mat [ j ] [ i ] NEW_LINE DEDENT if ( max_xor < max ( r_xor , c_xor ) ) : NEW_LINE INDENT max_xor = max ( r_xor , c_xor ) NEW_LINE DEDENT DEDENT return max_xor NEW_LINE DEDENT
def findK ( A , n , m , k ) : NEW_LINE INDENT if ( n < 1 or m < 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k <= m ) : NEW_LINE INDENT return A [ 0 ] [ k - 1 ] NEW_LINE DEDENT if ( k <= ( m + n - 1 ) ) : NEW_LINE INDENT return A [ ( k - m ) ] [ m - 1 ] NEW_LINE DEDENT if ( k <= ( m + n - 1 + m - 1 ) ) : NEW_LINE INDENT return A [ n - 1 ] [ m - 1 - ( k - ( m + n - 1 ) ) ] NEW_LINE DEDENT if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) : NEW_LINE INDENT return A [ n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ 0 ] NEW_LINE DEDENT A . pop ( 0 ) NEW_LINE [ j . pop ( 0 ) for j in A ] NEW_LINE return findK ( A , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) NEW_LINE DEDENT
def countZeroes ( mat ) : NEW_LINE INDENT row = N - 1 ; NEW_LINE col = 0 ; NEW_LINE count = 0 ; NEW_LINE while ( col < N ) : NEW_LINE INDENT while ( mat [ row ] [ col ] ) : NEW_LINE INDENT if ( row < 0 ) : NEW_LINE INDENT return count ; NEW_LINE DEDENT row = row - 1 ; NEW_LINE DEDENT count = count + ( row + 1 ) ; NEW_LINE col = col + 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while j >= 0 and i < n : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += ( j + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def printSpiral ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) NEW_LINE if ( i <= j ) : NEW_LINE INDENT print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = " TABSYMBOL " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = " TABSYMBOL " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def findMaxValue ( mat ) : NEW_LINE INDENT maxValue = 0 NEW_LINE for a in range ( N - 1 ) : NEW_LINE INDENT for b in range ( N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) : NEW_LINE INDENT maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return maxValue ; NEW_LINE DEDENT
def countIslands ( mat ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' X ' ) : NEW_LINE INDENT if ( ( i == 0 or mat [ i - 1 ] [ j ] == ' O ' ) and ( j == 0 or mat [ i ] [ j - 1 ] == ' O ' ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def printSumSimple ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT for j in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] ] NEW_LINE B = [ [ 0 for x in range ( M ) ] for y in range ( N ) ] NEW_LINE transpose ( A , B ) NEW_LINE print ( " Result ▁ matrix ▁ is " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( B [ i ] [ j ] , " ▁ " , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def transpose ( A ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE transpose ( A ) NEW_LINE print ( " Modified ▁ matrix ▁ is " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( A [ i ] [ j ] , " ▁ " , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def add ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE C = A [ : ] [ : ] NEW_LINE add ( A , B , C ) NEW_LINE print ( " Result ▁ matrix ▁ is " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( C [ i ] [ j ] , " ▁ " , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def subtract ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE C = A [ : ] [ : ] NEW_LINE subtract ( A , B , C ) NEW_LINE print ( " Result ▁ matrix ▁ is " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( C [ i ] [ j ] , " ▁ " , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def printNGE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + " ▁ - - ▁ " + str ( next ) ) NEW_LINE DEDENT DEDENT
def TowerOfHanoi ( n , from_rod , to_rod , aux_rod ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( " Move ▁ disk ▁ 1 ▁ from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE return NEW_LINE DEDENT TowerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE TowerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) NEW_LINE DEDENT
def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = INT_MIN ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def PrintMinNumberForPattern ( Strr ) : NEW_LINE INDENT res = ' ' NEW_LINE stack = [ ] NEW_LINE for i in range ( len ( Strr ) + 1 ) : NEW_LINE INDENT stack . append ( i + 1 ) NEW_LINE if ( i == len ( Strr ) or Strr [ i ] == ' I ' ) : NEW_LINE INDENT while len ( stack ) > 0 : NEW_LINE INDENT res += str ( stack . pop ( ) ) NEW_LINE res += ' ▁ ' NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def generate_derangement ( N ) : NEW_LINE INDENT S = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S [ i ] = i NEW_LINE DEDENT D = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 , 2 ) : NEW_LINE INDENT if i == N : NEW_LINE INDENT D [ N ] = S [ N - 1 ] NEW_LINE D [ N - 1 ] = S [ N ] NEW_LINE DEDENT else : NEW_LINE INDENT D [ i ] = i + 1 NEW_LINE D [ i + 1 ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( D [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def sumBetweenTwoKth ( arr , n , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( k1 , k2 - 1 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def minSum ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE num1 , num2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT num1 = num1 * 10 + a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT num2 = num2 * 10 + a [ i ] NEW_LINE DEDENT DEDENT return num2 + num1 NEW_LINE DEDENT
def maxDistance ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE maxDict = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT return maxDict NEW_LINE DEDENT
def checkDuplicatesWithinK ( arr , n , k ) : NEW_LINE INDENT myset = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in myset : NEW_LINE INDENT return True NEW_LINE DEDENT myset . append ( arr [ i ] ) NEW_LINE if ( i >= k ) : NEW_LINE INDENT myset . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findSymPairs ( arr , row ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if ( sec in hM . keys ( ) and hM [ sec ] == first ) : NEW_LINE INDENT print ( " ( " , sec , " , " , first , " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT
def areDisjoint ( set1 , set2 , m , n ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( set1 [ i ] == set2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def areDisjoint ( set1 , set2 , m , n ) : NEW_LINE INDENT set1 . sort ( ) NEW_LINE set2 . sort ( ) NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( set1 [ i ] < set2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( set2 [ j ] < set1 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] == b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in s . keys ( ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def areEqual ( arr1 , arr2 , n , m ) : NEW_LINE INDENT if ( n != m ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr1 = [ 3 , 5 , 2 , 5 , 2 ] NEW_LINE arr2 = [ 2 , 3 , 5 , 5 , 2 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE if ( areEqual ( arr1 , arr2 , n , m ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if i * j == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 9 , 40 ] NEW_LINE x = 400 NEW_LINE n = len ( arr ) NEW_LINE if ( isProduct ( arr , n , x ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT x = 900 NEW_LINE if ( isProduct ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if a [ i ] not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if arr1 [ i ] + arr2 [ j ] == x : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE us = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT us . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if x - arr2 [ j ] in us : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count , l , r = 0 , 0 , n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE count += 1 NEW_LINE DEDENT elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findSubarraySum ( arr , n , Sum ) : NEW_LINE INDENT prevSum = defaultdict ( lambda : 0 ) NEW_LINE res = 0 NEW_LINE currsum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT currsum += arr [ i ] NEW_LINE if currsum == Sum : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( currsum - Sum ) in prevSum : NEW_LINE INDENT res += prevSum [ currsum - Sum ] NEW_LINE DEDENT prevSum [ currsum ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] ; NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ k ] == product ) : NEW_LINE INDENT result = result + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT
def findPairs ( arr1 , arr2 , n , m , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( arr1 [ i ] + arr2 [ j ] == x ) : NEW_LINE INDENT print ( arr1 [ i ] , arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countFreq ( a , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] > 0 ) : NEW_LINE INDENT print ( a [ i ] , " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
def printPairs ( arr , n , k ) : NEW_LINE INDENT isPairFound = True NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and arr [ i ] % arr [ j ] == k ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , sep = " " , end = " ▁ " ) NEW_LINE isPairFound = True NEW_LINE DEDENT DEDENT DEDENT return isPairFound NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE if ( printPairs ( arr , n , k ) == False ) : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ exists " ) NEW_LINE DEDENT
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , " " , v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT for i in range ( 0 , n1 ) : NEW_LINE INDENT for j in range ( 0 , n2 ) : NEW_LINE INDENT for k in range ( 0 , n3 ) : NEW_LINE INDENT if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def maxLen ( arr ) : NEW_LINE INDENT hash_map = { } NEW_LINE curr_sum = 0 NEW_LINE max_len = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if arr [ i ] is 0 and max_len is 0 : NEW_LINE INDENT max_len = 1 NEW_LINE DEDENT if curr_sum is 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if curr_sum in hash_map : NEW_LINE INDENT max_len = max ( max_len , i - hash_map [ curr_sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash_map [ curr_sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
def longLenSub ( arr , n ) : NEW_LINE INDENT um = defaultdict ( lambda : 0 ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len1 = 0 NEW_LINE if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len1 + 1 NEW_LINE if longLen < um [ arr [ i ] ] : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minInsertion ( tr1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE count = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] % 2 == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( res == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return res - 1 NEW_LINE DEDENT DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 ; max_count = 0 ; min_count = n NEW_LINE for i in range ( 0 , ( n - 1 ) ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT max_count = max ( max_count , count ) NEW_LINE min_count = min ( min_count , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max_count - min_count NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : NEW_LINE INDENT result += abs ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if ( arr [ n - 2 ] != arr [ n - 1 ] ) : NEW_LINE INDENT result += abs ( arr [ n - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def calculate ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE DEDENT
def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum = - 1 if ( arr [ i ] == 0 ) else 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 NEW_LINE if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE startindex = i NEW_LINE DEDENT DEDENT DEDENT if ( maxsize == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ subarray " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( startindex , " to " , startindex + maxsize - 1 ) ; NEW_LINE DEDENT return maxsize NEW_LINE DEDENT
def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 10 ) } NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT sum += - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( sum not in um ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( ( sum - 1 ) in um ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( " { } ▁ { } ▁ { } " . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end =   " " ) ; NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) ; NEW_LINE DEDENT
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT j = i - 1 NEW_LINE k = i + 1 NEW_LINE while ( j >= 0 and k < n ) : NEW_LINE INDENT if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) : NEW_LINE INDENT print ( arr [ j ] , " " , arr [ i ] , " " , arr [ k ] ) NEW_LINE k += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 ; NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and ( arr [ j ] not in s ) ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) // 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE S . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT S = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( S ) NEW_LINE ans = findLargestd ( S , n ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( " No ▁ Solution " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + " , " c ▁ = ▁ d ▁ is " , ans ) NEW_LINE DEDENT
def recaman ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE arr [ 0 ] = 0 NEW_LINE print ( arr [ 0 ] , end = " , ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = arr [ i - 1 ] - i NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) : NEW_LINE INDENT curr = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = curr NEW_LINE print ( arr [ i ] , end = " , ▁ " ) NEW_LINE DEDENT DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n - 1 and j < 2 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT
def leftRotate ( arr , d , n ) : NEW_LINE INDENT if ( d == 0 or d == n ) : NEW_LINE INDENT return ; NEW_LINE DEDENT i = d NEW_LINE j = n - d NEW_LINE while ( i != j ) : NEW_LINE INDENT if ( i < j ) : NEW_LINE INDENT swap ( arr , d - i , d + j - i , i ) NEW_LINE j -= i NEW_LINE DEDENT else : NEW_LINE INDENT swap ( arr , d - i , d , j ) NEW_LINE i -= j NEW_LINE DEDENT DEDENT swap ( arr , d - i , d , i ) NEW_LINE DEDENT
def search ( arr , l , h , key ) : NEW_LINE INDENT if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] <= arr [ mid ] : NEW_LINE INDENT if key >= arr [ l ] and key <= arr [ mid ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if key >= arr [ mid ] and key <= arr [ h ] : NEW_LINE INDENT return search ( a , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] NEW_LINE key = 6 NEW_LINE i = search ( arr , 0 , len ( arr ) - 1 , key ) NEW_LINE if i != - 1 : NEW_LINE INDENT print ( " Index : ▁ % ▁ d " % i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Key ▁ not ▁ found " ) NEW_LINE DEDENT
def pairInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n ; NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT arr = [ 11 , 15 , 6 , 8 , 9 , 10 ] NEW_LINE sum = 16 NEW_LINE n = len ( arr ) NEW_LINE if ( pairInSortedRotated ( arr , n , sum ) ) : NEW_LINE INDENT print ( " Array ▁ has ▁ two ▁ elements ▁ with ▁ sum ▁ 16" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Array ▁ doesn ' t ▁ have ▁ two ▁ elements ▁ with ▁ sum ▁ 16 ▁ " ) NEW_LINE DEDENT
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT cnt += 1 NEW_LINE if l == ( r - 1 + n ) % n : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT index = int ( ( i + j ) % n ) NEW_LINE curr_sum += j * arr [ index ] NEW_LINE DEDENT res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT cum_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cum_sum += arr [ i ] NEW_LINE DEDENT curr_val = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_val += i * arr [ i ] NEW_LINE DEDENT res = curr_val NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) NEW_LINE curr_val = next_val NEW_LINE res = max ( res , next_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index ; NEW_LINE DEDENT
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) / 2 ; NEW_LINE mid = int ( mid ) NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) ; NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( str ( arr [ i % n ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findMin ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if high == low : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return arr [ mid + 1 ] NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return findMin ( arr , low , mid - 1 ) NEW_LINE DEDENT return findMin ( arr , mid + 1 , high ) NEW_LINE DEDENT
def findMin ( arr , low , high ) : NEW_LINE INDENT while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 ; NEW_LINE if ( arr [ mid ] == arr [ high ] ) : NEW_LINE INDENT high -= 1 ; NEW_LINE DEDENT elif ( arr [ mid ] > arr [ high ] ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return arr [ high ] ; NEW_LINE DEDENT
def maxHamming ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * ( 2 * n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT brr [ n + i ] = arr [ i ] NEW_LINE DEDENT maxHam = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currHam = 0 NEW_LINE k = 0 NEW_LINE for j in range ( i , i + n ) : NEW_LINE INDENT if brr [ j ] != arr [ k ] : NEW_LINE INDENT currHam += 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT if currHam == n : NEW_LINE INDENT return n NEW_LINE DEDENT maxHam = max ( maxHam , currHam ) NEW_LINE DEDENT return maxHam NEW_LINE DEDENT
def leftRotate ( arr , n , k ) : NEW_LINE INDENT mod = k % n NEW_LINE s = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT print str ( arr [ ( mod + i ) % n ] ) , NEW_LINE DEDENT print NEW_LINE return NEW_LINE DEDENT
def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE splitArr ( arr , n , position ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT
def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def reorder ( arr , index , n ) : NEW_LINE INDENT temp = [ 0 ] * n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp [ index [ i ] ] = arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE index [ i ] = i NEW_LINE DEDENT DEDENT arr = [ 50 , 40 , 70 , 60 , 90 ] NEW_LINE index = [ 3 , 0 , 4 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE reorder ( arr , index , n ) NEW_LINE print ( " Reordered ▁ array ▁ is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " Modified Index array is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( index [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def reorder ( arr , index , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while ( index [ i ] != i ) : NEW_LINE INDENT oldTargetI = index [ index [ i ] ] NEW_LINE oldTargetE = arr [ index [ i ] ] NEW_LINE arr [ index [ i ] ] = arr [ i ] NEW_LINE index [ index [ i ] ] = index [ i ] NEW_LINE index [ i ] = oldTargetI NEW_LINE arr [ i ] = oldTargetE NEW_LINE DEDENT DEDENT DEDENT arr = [ 50 , 40 , 70 , 60 , 90 ] NEW_LINE index = [ 3 , 0 , 4 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE reorder ( arr , index , n ) NEW_LINE print ( " Reordered ▁ array ▁ is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " Modified Index array is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( index [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( arr [ i ] < 0 and i < n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( arr [ j ] > 0 and j >= 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT temp = n * [ None ] NEW_LINE small , large = 0 , n - 1 NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if flag is True : NEW_LINE INDENT temp [ i ] = arr [ large ] NEW_LINE large -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ i ] = arr [ small ] NEW_LINE small += 1 NEW_LINE DEDENT flag = bool ( 1 - flag ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT max_idx = n - 1 NEW_LINE min_idx = 0 NEW_LINE max_elem = arr [ n - 1 ] + 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem NEW_LINE max_idx -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem NEW_LINE min_idx += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] / max_elem NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Original ▁ Array " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT rearrange ( arr , n ) NEW_LINE print ( " Modified Array " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( int ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT max_ele = arr [ n - 1 ] NEW_LINE min_ele = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] = max_ele NEW_LINE max_ele -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE min_ele += 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Origianl ▁ Array " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT rearrange ( arr , n ) NEW_LINE print ( " Modified Array " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 for k in range ( n ) ] NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( j == n or j == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT arr [ k ] = temp [ k ] NEW_LINE DEDENT DEDENT arr = [ 1 , - 1 , - 3 , - 2 , 7 , 5 , 11 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE segregateElements ( arr , n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive = positive + 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative = negative + 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT temp = a [ positive ] NEW_LINE a [ positive ] = a [ negative ] NEW_LINE a [ negative ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , - 3 , 5 , 6 , - 3 , 6 , 7 , - 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT for i in arr : NEW_LINE INDENT print ( str ( i ) + " ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT
def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT
def find3largest ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE check = 0 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( count < 4 ) : NEW_LINE INDENT if ( check != arr [ n - i ] ) : NEW_LINE INDENT print ( arr [ n - i ] , end = " ▁ " ) NEW_LINE check = arr [ n - i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT
def find_max_sum ( arr ) : NEW_LINE INDENT incl = 0 NEW_LINE excl = 0 NEW_LINE for i in arr : NEW_LINE INDENT new_excl = excl if excl > incl else incl NEW_LINE incl = excl + i NEW_LINE excl = new_excl NEW_LINE DEDENT return ( excl if excl > incl else incl ) NEW_LINE DEDENT
def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= x and arr [ i ] <= y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def answerQuery ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE l = l - 1 NEW_LINE for i in range ( l , r , 1 ) : NEW_LINE INDENT element = a [ i ] NEW_LINE divisors = 0 NEW_LINE for j in range ( l , r , 1 ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT divisors += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( divisors == ( r - l ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def record_sum ( record , l , r , n , adder ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT record [ i ] += adder NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 5 NEW_LINE arr = [ 0 ] * n NEW_LINE query = [ [ 1 , 1 , 2 ] , [ 1 , 4 , 5 ] , [ 2 , 1 , 2 ] , [ 2 , 1 , 3 ] , [ 2 , 3 , 4 ] ] NEW_LINE record = [ 0 ] * m NEW_LINE for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( query [ i ] [ 0 ] == 2 ) : NEW_LINE INDENT record_sum ( record , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , m , record [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT record_sum ( record , i , i , m , 1 ) NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( query [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT record_sum ( arr , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , n , record [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxint - 1 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT
def findMinAvgSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : return 0 NEW_LINE res_index = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT min_sum = curr_sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] NEW_LINE if ( curr_sum < min_sum ) : NEW_LINE INDENT min_sum = curr_sum NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( " Subarray ▁ between ▁ [ " , res_index , " , ▁ " , ( res_index + k - 1 ) , " ] ▁ has ▁ minimum ▁ average " ) NEW_LINE DEDENT
def minJumps ( arr , l , h ) : NEW_LINE INDENT if ( h == l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ l ] == 0 ) : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT min = float ( ' inf ' ) NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( i < l + arr [ l ] + 1 ) : NEW_LINE INDENT jumps = minJumps ( arr , i , h ) NEW_LINE if ( jumps != float ( ' inf ' ) and jumps + 1 < min ) : NEW_LINE INDENT min = jumps + 1 NEW_LINE DEDENT DEDENT DEDENT return min NEW_LINE DEDENT
def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE min_len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_sum <= x and end < n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE end += 1 NEW_LINE DEDENT while ( curr_sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_len ) : NEW_LINE INDENT min_len = end - start NEW_LINE DEDENT curr_sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return min_len NEW_LINE DEDENT
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
def findSmallest ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] <= res : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findMinDiff ( arr , n ) : NEW_LINE INDENT diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] - arr [ j ] ) < diff : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT
def findMinDiff ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] < diff : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT
def longestCommonSum ( arr1 , arr2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum1 += arr1 [ j ] NEW_LINE sum2 += arr2 [ j ] NEW_LINE if ( sum1 == sum2 ) : NEW_LINE INDENT len = j - i + 1 NEW_LINE if ( len > maxLen ) : NEW_LINE INDENT maxLen = len NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def segregate0and1 ( arr , n ) : NEW_LINE INDENT type0 = 0 ; type1 = n - 1 NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT arr [ type0 ] , arr [ type1 ] = arr [ type1 ] , arr [ type0 ] NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE segregate0and1 ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def getInvCount ( arr , n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT
def findNumberOfTriangles ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] > arr [ k ] and arr [ i ] + arr [ k ] > arr [ j ] and arr [ k ] + arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE A . sort ( ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT l = 0 ; NEW_LINE r = i - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l ; NEW_LINE r -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) ; NEW_LINE DEDENT
def countPairsBruteForce ( X , Y , m , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( pow ( X [ i ] , Y [ j ] ) > pow ( Y [ j ] , X [ i ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r < n : NEW_LINE INDENT if arr [ r ] - arr [ l ] == k : NEW_LINE INDENT count += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif arr [ r ] - arr [ l ] > k : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def constructArr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = pair [ i - 1 ] - arr [ 0 ] NEW_LINE DEDENT DEDENT
def merge ( ar1 , ar2 , m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = ar1 [ m - 1 ] NEW_LINE j = m - 2 NEW_LINE while ( j >= 0 and ar1 [ j ] > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar1 [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j != m - 2 or last > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar2 [ i ] NEW_LINE ar2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT ar1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE ar2 = [ 2 , 3 , 8 , 13 ] NEW_LINE m = len ( ar1 ) NEW_LINE n = len ( ar2 ) NEW_LINE merge ( ar1 , ar2 , m , n ) NEW_LINE print ( " After Merging First Array : " , ▁ end = " " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( ar1 [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT print ( " Second Array : " , ▁ end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ar2 [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT
def minmaxProduct ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE return arr1 [ n1 - 1 ] * arr2 [ 0 ] NEW_LINE DEDENT
def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 12 , 34 , 10 , 6 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE key = 40 NEW_LINE index = findElement ( arr , n , key ) NEW_LINE if index != - 1 : NEW_LINE INDENT print ( " element ▁ found ▁ at ▁ position : ▁ " + str ( index + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " element ▁ not ▁ found " ) NEW_LINE DEDENT
def findCommon ( ar1 , ar2 , ar3 , n1 , n2 , n3 ) : NEW_LINE INDENT i , j , k = 0 , 0 , 0 NEW_LINE while ( i < n1 and j < n2 and k < n3 ) : NEW_LINE INDENT if ( ar1 [ i ] == ar2 [ j ] and ar2 [ j ] == ar3 [ k ] ) : NEW_LINE INDENT print ar1 [ i ] , NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT elif ar1 [ i ] < ar2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ar2 [ j ] < ar3 [ k ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT
def findSingle ( ar , n ) : NEW_LINE INDENT res = ar [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def singleNumber ( nums ) : NEW_LINE INDENT return 2 * sum ( set ( nums ) ) - sum ( nums ) NEW_LINE DEDENT
def findMaxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum = arr [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT prefix_sum += arr [ j ] NEW_LINE DEDENT suffix_sum = arr [ i ] NEW_LINE j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT suffix_sum += arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( prefix_sum == suffix_sum ) : NEW_LINE INDENT res = max ( res , prefix_sum ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findMaxSum ( arr , n ) : NEW_LINE INDENT preSum = [ 0 for i in range ( n ) ] NEW_LINE suffSum = [ 0 for i in range ( n ) ] NEW_LINE ans = - 10000000 NEW_LINE preSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT preSum [ i ] = preSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT suffSum [ n - 1 ] = arr [ n - 1 ] NEW_LINE if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) : NEW_LINE INDENT ans = max ( ans , preSum [ n - 1 ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] NEW_LINE if ( suffSum [ i ] == preSum [ i ] ) : NEW_LINE INDENT ans = max ( ans , preSum [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def equilibrium ( arr ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT leftsum += arr [ j ] NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT rightsum += arr [ j ] NEW_LINE DEDENT if leftsum == rightsum : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def equilibrium ( arr ) : NEW_LINE INDENT total_sum = sum ( arr ) NEW_LINE leftsum = 0 NEW_LINE for i , num in enumerate ( arr ) : NEW_LINE INDENT total_sum -= num NEW_LINE if leftsum == total_sum : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def printLeaders ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] <= arr [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == size - 1 : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT DEDENT DEDENT
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE index = ceilSearch ( arr , 0 , n - 1 , x ) ; NEW_LINE if index == - 1 : NEW_LINE INDENT print ( " Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " % x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ceiling ▁ of ▁ % d ▁ is ▁ % d " % ( x , arr [ index ] ) ) NEW_LINE DEDENT
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE x = 20 NEW_LINE index = ceilSearch ( arr , 0 , n - 1 , x ) ; NEW_LINE if index == - 1 : NEW_LINE INDENT print ( " Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " % x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ceiling ▁ of ▁ % d ▁ is ▁ % d " % ( x , arr [ index ] ) ) NEW_LINE DEDENT
def isMajority ( arr , n , x ) : NEW_LINE INDENT last_index = ( n // 2 + 1 ) if n % 2 == 0 else ( n // 2 ) NEW_LINE for i in range ( last_index ) : NEW_LINE INDENT if arr [ i ] == x and arr [ i + n // 2 ] == x : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE x = 4 NEW_LINE if ( isMajority ( arr , n , x ) ) : NEW_LINE INDENT print ( " % ▁ d ▁ appears ▁ more ▁ than ▁ % ▁ d ▁ times ▁ in ▁ arr [ ] " % ( x , n // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % ▁ d ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ % ▁ d ▁ times ▁ in ▁ arr [ ] " % ( x , n // 2 ) ) NEW_LINE DEDENT
def isMajorityElement ( arr , n , key ) : NEW_LINE INDENT if ( arr [ n // 2 ] == key ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findPeak ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE return 0 NEW_LINE if ( arr [ 0 ] >= arr [ 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ i - 1 ] and arr [ i ] >= arr [ i + 1 ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " Repeating ▁ elements ▁ are ▁ " , end = ' ' ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT count = [ 0 ] * size NEW_LINE print ( " ▁ Repeating ▁ elements ▁ are ▁ " , end = " " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( count [ arr [ i ] ] == 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = count [ arr [ i ] ] + 1 NEW_LINE DEDENT DEDENT DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " ▁ The ▁ repeating ▁ elements ▁ are " , end = " ▁ " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def linearSearch ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] is i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def binarySearch ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE DEDENT if mid is arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def subArraySum ( arr , n , sum_ ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT curr_sum = arr [ i ] NEW_LINE j = i + 1 NEW_LINE while j <= n : NEW_LINE INDENT if curr_sum == sum_ : NEW_LINE INDENT print ( " Sum ▁ found ▁ between " ) NEW_LINE print ( " indexes ▁ % ▁ d ▁ and ▁ % ▁ d " % ( i , j - 1 ) ) NEW_LINE return 1 NEW_LINE DEDENT if curr_sum > sum_ or j == n : NEW_LINE INDENT break NEW_LINE DEDENT curr_sum = curr_sum + arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT sm = - 1000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : NEW_LINE INDENT sm = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return sm NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) NEW_LINE DEDENT
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] == sum : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printSubsequences ( arr , n ) : NEW_LINE INDENT opsize = math . pow ( 2 , n ) NEW_LINE for counter in range ( 1 , ( int ) ( opsize ) ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( counter & ( 1 << j ) ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def minOps ( arr , n , k ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max1 - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max1 - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return int ( res ) NEW_LINE DEDENT
def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE if current_diff < min_diff : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , B [ j ] , C [ k ] ) NEW_LINE if A [ i ] == max_term : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif B [ j ] == max_term : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE n = len ( arr ) NEW_LINE result = search ( arr , n , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index " , result ) NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , 0 , len ( arr ) - 1 , x ) NEW_LINE if result != - 1 : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d " % result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT
def interpolationSearch ( arr , lo , hi , x ) : NEW_LINE INDENT if ( lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] ) : NEW_LINE INDENT pos = lo + ( ( hi - lo ) // ( arr [ hi ] - arr [ lo ] ) * ( x - arr [ lo ] ) ) NEW_LINE if arr [ pos ] == x : NEW_LINE INDENT return pos NEW_LINE DEDENT if arr [ pos ] < x : NEW_LINE INDENT return interpolationSearch ( arr , pos + 1 , hi , x ) NEW_LINE DEDENT if arr [ pos ] > x : NEW_LINE INDENT return interpolationSearch ( arr , lo , pos - 1 , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE x = 18 NEW_LINE index = interpolationSearch ( arr , 0 , n - 1 , x ) NEW_LINE if index != - 1 : NEW_LINE INDENT print ( " Element ▁ found ▁ at ▁ index " , index ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ not ▁ found " ) NEW_LINE DEDENT
def countSort ( arr ) : NEW_LINE INDENT output = [ 0 for i in range ( len ( arr ) ) ] NEW_LINE count = [ 0 for i in range ( 256 ) ] NEW_LINE for i in arr : NEW_LINE INDENT count [ ord ( i ) ] += 1 NEW_LINE DEDENT for i in range ( 256 ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT output [ count [ ord ( arr [ i ] ) ] - 1 ] = arr [ i ] NEW_LINE count [ ord ( arr [ i ] ) ] -= 1 NEW_LINE DEDENT ans = [ " " for _ in arr ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT ans [ i ] = output [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printClosest ( ar1 , ar2 , m , n , x ) : NEW_LINE INDENT diff = sys . maxsize NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) NEW_LINE DEDENT if ar1 [ l ] + ar2 [ r ] > x : NEW_LINE INDENT r = r - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = l + 1 NEW_LINE DEDENT DEDENT print ( " The ▁ closest ▁ pair ▁ is ▁ [ " , ar1 [ res_l ] , " , " , ar2 [ res_r ] , " ] " ) NEW_LINE DEDENT
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT
def countOnes ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if arr [ mid ] == 1 : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , mid - 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def printMaxActivities ( s , f ) : NEW_LINE INDENT n = len ( f ) NEW_LINE print " The ▁ following ▁ activities ▁ are ▁ selected " NEW_LINE i = 0 NEW_LINE print i , NEW_LINE for j in xrange ( n ) : NEW_LINE INDENT if s [ j ] >= f [ i ] : NEW_LINE INDENT print j , NEW_LINE i = j NEW_LINE DEDENT DEDENT DEDENT
def lis ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maximum = max ( maximum , lis [ i ] ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def count ( S , m , n ) : NEW_LINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE m [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT DEDENT DEDENT DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if k == 0 or k == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 for i in xrange ( k + 1 ) ] NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT
def lbs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT lds = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in reversed ( range ( n - 1 ) ) : NEW_LINE INDENT for j in reversed ( range ( i - 1 , n ) ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( " Found ▁ a ▁ subset ▁ with ▁ given ▁ sum " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ subset ▁ with ▁ given ▁ sum " ) NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = int ( count * ( N + i - 1 ) ) NEW_LINE count = int ( count / i ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return n ; NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x ; NEW_LINE if temp > n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT dp = [ 0 , 1 , 2 , 3 ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp . append ( i ) NEW_LINE for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) : NEW_LINE INDENT temp = x * x ; NEW_LINE if temp > i : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def minCoins ( coins , m , V ) : NEW_LINE INDENT if ( V == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( coins [ i ] <= V ) : NEW_LINE INDENT sub_res = minCoins ( coins , m , V - coins [ i ] ) NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < res ) : NEW_LINE INDENT res = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def minCoins ( coins , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT table [ i ] = sys . maxsize NEW_LINE DEDENT for i in range ( 1 , V + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( coins [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - coins [ j ] ] NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if table [ V ] == sys . maxsize : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return table [ V ] NEW_LINE DEDENT
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT if ( not m ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + superSeq ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) NEW_LINE DEDENT
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( not i ) : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif ( not j ) : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def sumOfDigitsFrom1ToN ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT d = ( int ) ( math . log10 ( n ) ) NEW_LINE a = [ 0 ] * ( d + 1 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 45 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = ( int ) ( math . ceil ( math . pow ( 10 , d ) ) ) NEW_LINE msd = n // p NEW_LINE return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT countB = 1 NEW_LINE countS = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT prev_countB = countB NEW_LINE prev_countS = countS NEW_LINE countS = prev_countB + prev_countS NEW_LINE countB = prev_countS NEW_LINE DEDENT result = countS + countB NEW_LINE return ( result * result ) NEW_LINE DEDENT
def findoptimal ( N ) : NEW_LINE INDENT if N <= 6 : NEW_LINE INDENT return N NEW_LINE DEDENT maxi = 0 NEW_LINE for b in range ( N - 3 , 0 , - 1 ) : NEW_LINE INDENT curr = ( N - b - 1 ) * findoptimal ( b ) NEW_LINE if curr > maxi : NEW_LINE INDENT maxi = curr NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = 0 NEW_LINE for b in range ( n - 3 , 0 , - 1 ) : NEW_LINE INDENT curr = ( n - b - 1 ) * screen [ b - 1 ] NEW_LINE if ( curr > screen [ n - 1 ] ) : NEW_LINE INDENT screen [ n - 1 ] = curr NEW_LINE DEDENT DEDENT DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; NEW_LINE DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT print ( " Pattern ▁ found ▁ at ▁ index ▁ " , i ) NEW_LINE DEDENT DEDENT DEDENT
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while i <= N - M : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT print " Pattern ▁ found ▁ at ▁ index ▁ " + str ( i ) NEW_LINE i = i + M NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT
def power ( x , y ) : NEW_LINE INDENT temp = 0 NEW_LINE if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp ; NEW_LINE DEDENT else : NEW_LINE INDENT return x * temp * temp ; NEW_LINE DEDENT DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( y > 0 ) : return x * temp * temp NEW_LINE else : return ( temp * temp ) / x NEW_LINE DEDENT DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return x * power ( x , y - 1 ) NEW_LINE DEDENT
def isLucky ( n ) : NEW_LINE INDENT next_position = n NEW_LINE if isLucky . counter > n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % isLucky . counter == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT next_position = next_position - next_position / isLucky . counter NEW_LINE isLucky . counter = isLucky . counter + 1 NEW_LINE return isLucky ( next_position ) NEW_LINE DEDENT isLucky . counter = 2 NEW_LINE x = 5 NEW_LINE if isLucky ( x ) : NEW_LINE INDENT print x , " is ▁ a ▁ Lucky ▁ number " NEW_LINE DEDENT else : NEW_LINE INDENT print x , " is ▁ not ▁ a ▁ Lucky ▁ number " NEW_LINE DEDENT
def pow ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = a NEW_LINE increment = a NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( 1 , a ) : NEW_LINE INDENT answer += increment NEW_LINE DEDENT increment = answer NEW_LINE DEDENT return answer NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return n NEW_LINE DEDENT elif n >= 3 and n < 10 : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT po = 1 NEW_LINE while n / po > 9 : NEW_LINE INDENT po = po * 10 NEW_LINE DEDENT msd = n / po NEW_LINE if msd != 3 : NEW_LINE INDENT return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( msd * po - 1 ) NEW_LINE DEDENT DEDENT
def binomialCoefficient ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res / ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def printPascal ( n : int ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for line in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , line + 1 ) : NEW_LINE INDENT if ( i == 0 or i == line ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE print ( arr [ line ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) NEW_LINE print ( arr [ line ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " " , ▁ end ▁ = ▁ " " ) NEW_LINE DEDENT DEDENT
def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 ; NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = " ▁ " ) ; NEW_LINE C = int ( C * ( line - i ) / i ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT
def exponential ( n , x ) : NEW_LINE INDENT sum = 1.0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT sum = 1 + x * sum / i NEW_LINE DEDENT print ( " e ^ x ▁ = " , sum ) NEW_LINE DEDENT
def findgroups ( arr , n ) : NEW_LINE INDENT c = [ 0 , 0 , 0 ] NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] += 1 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) NEW_LINE res += c [ 1 ] * c [ 2 ] NEW_LINE res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 NEW_LINE res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 NEW_LINE res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += c [ 0 ] * c [ 1 ] * c [ 2 ] NEW_LINE return res NEW_LINE DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n >= 5 ) : NEW_LINE INDENT n //= 5 NEW_LINE count += n NEW_LINE DEDENT return count NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT catalan = [ 0 ] * ( n + 1 ) NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = " ▁ " ) NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT cat_ = 1 NEW_LINE print ( cat_ , " ▁ " , end = ' ' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cat_ *= ( 4 * i - 2 ) ; NEW_LINE cat_ //= ( i + 1 ) ; NEW_LINE print ( cat_ , " ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT
def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ) ; NEW_LINE DEDENT
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSolutions ( n ) : NEW_LINE INDENT x = 0 NEW_LINE res = 0 NEW_LINE yCount = 0 NEW_LINE while ( yCount * yCount < n ) : NEW_LINE INDENT yCount = yCount + 1 NEW_LINE DEDENT while ( yCount != 0 ) : NEW_LINE INDENT res = res + yCount NEW_LINE x = x + 1 NEW_LINE while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) : NEW_LINE INDENT yCount = yCount - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT
def getSingle ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT sm = 0 NEW_LINE x = ( 1 << i ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & x ) : NEW_LINE INDENT sm = sm + 1 NEW_LINE DEDENT DEDENT if ( ( sm % 3 ) != 0 ) : NEW_LINE INDENT result = result | x NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) ; NEW_LINE DEDENT x = 100 NEW_LINE y = 1 NEW_LINE if ( oppositeSigns ( x , y ) == True ) : NEW_LINE INDENT print " Signs ▁ are ▁ opposite " NEW_LINE DEDENT else : NEW_LINE INDENT print " Signs ▁ are ▁ not ▁ opposite " NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = 0 NEW_LINE change = 1 << i NEW_LINE for j in range ( 0 , n + 1 ) : NEW_LINE INDENT ans += k NEW_LINE if change == 1 : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getSetBitsFromOneToN ( N ) : NEW_LINE INDENT two = 2 NEW_LINE ans = 0 NEW_LINE n = N NEW_LINE while ( n != 0 ) : NEW_LINE INDENT ans += int ( N / two ) * ( two >> 1 ) NEW_LINE if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) : NEW_LINE INDENT ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 NEW_LINE DEDENT two <<= 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return ans NEW_LINE DEDENT
def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) NEW_LINE set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) NEW_LINE xor = ( set1 ^ set2 ) NEW_LINE xor = ( xor << p1 ) | ( xor << p2 ) NEW_LINE result = x ^ xor NEW_LINE return result NEW_LINE DEDENT
def swapBits ( num , p1 , p2 , n ) : NEW_LINE INDENT shift1 = 0 NEW_LINE shift2 = 0 NEW_LINE value1 = 0 NEW_LINE value2 = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT shift1 = 1 << p1 NEW_LINE shift2 = 1 << p2 NEW_LINE value1 = ( ( num & shift1 ) ) NEW_LINE value2 = ( ( num & shift2 ) ) NEW_LINE if ( ( value1 == 0 and value2 != 0 ) or ( value2 == 0 and value1 != 0 ) ) : NEW_LINE INDENT if ( value1 != 0 ) : NEW_LINE INDENT num = num & ( ~ shift1 ) NEW_LINE num = num | shift2 NEW_LINE DEDENT else : NEW_LINE INDENT num = num & ( ~ shift2 ) NEW_LINE num = num | shift1 NEW_LINE DEDENT DEDENT p1 += 1 NEW_LINE p2 += 1 NEW_LINE n -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x and y and z ) : NEW_LINE INDENT x = x - 1 NEW_LINE y = y - 1 NEW_LINE z = z - 1 NEW_LINE c = c + 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT if ( not ( y / x ) ) : NEW_LINE INDENT return y if ( not ( y / z ) ) else z NEW_LINE DEDENT return x if ( not ( x / z ) ) else z NEW_LINE DEDENT
def snoob ( x ) : NEW_LINE INDENT next = 0 NEW_LINE if ( x ) : NEW_LINE INDENT rightOne = x & - ( x ) NEW_LINE nextHigherOneBit = x + int ( rightOne ) NEW_LINE rightOnesPattern = x ^ int ( nextHigherOneBit ) NEW_LINE rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) NEW_LINE rightOnesPattern = int ( rightOnesPattern ) >> 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT m = 1 ; NEW_LINE while ( x & m ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT return ( - ( ~ x ) ) ; NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and ( not ( n & ( n - 1 ) ) ) ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT test_no = 64 NEW_LINE if ( isPowerOfFour ( 64 ) ) : NEW_LINE INDENT print ( test_no , ' is ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( test_no , ' is ▁ not ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) ) ; NEW_LINE DEDENT test_no = 64 ; NEW_LINE if ( isPowerOfFour ( test_no ) ) : NEW_LINE INDENT print ( test_no , " is ▁ a ▁ power ▁ of ▁ 4" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( test_no , " is ▁ not ▁ a ▁ power ▁ of ▁ 4" ) ; NEW_LINE DEDENT
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT
def getOddOccurrence ( arr , arr_size ) : NEW_LINE INDENT for i in range ( 0 , arr_size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 ; NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] ; NEW_LINE DEDENT nibble = num & 0xf ; NEW_LINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; NEW_LINE DEDENT
def countSetBits ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 4 * 8 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE count += 1 NEW_LINE return count NEW_LINE N = 15 NEW_LINE print ( countSetBits ( N ) ) NEW_LINE DEDENT DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p ; NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
def getParity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n : NEW_LINE INDENT parity = ~ parity NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return parity NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def powerof2 ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT elif n % 2 != 0 or n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return powerof2 ( n / 2 ) NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def PositionRightmostSetbit ( n ) : NEW_LINE INDENT position = 1 NEW_LINE m = 1 NEW_LINE while ( not ( n & m ) ) : NEW_LINE INDENT m = m << 1 NEW_LINE position += 1 NEW_LINE DEDENT return position NEW_LINE DEDENT
def PositionRightmostSetbit ( n ) : NEW_LINE INDENT p = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE return p NEW_LINE p += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT n = 18 NEW_LINE pos = PositionRightmostSetbit ( n ) NEW_LINE if ( pos != - 1 ) : NEW_LINE INDENT print ( pos ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
def bin ( n ) : NEW_LINE INDENT i = 1 << 31 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( ( n & i ) != 0 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT i = i // 2 NEW_LINE DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = " " ) NEW_LINE DEDENT
def swapBits ( x ) : NEW_LINE INDENT even_bits = x & 0xAAAAAAAA NEW_LINE odd_bits = x & 0x55555555 NEW_LINE even_bits >>= 1 NEW_LINE odd_bits <<= 1 NEW_LINE return ( even_bits odd_bits ) NEW_LINE DEDENT
def swap ( xp , yp ) : NEW_LINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT
def swap ( a , b ) : NEW_LINE INDENT a = ( a & b ) + ( a b ) NEW_LINE b = a + ( ~ b ) + 1 NEW_LINE a = a + ( ~ b ) + 1 NEW_LINE print ( " After ▁ Swapping : ▁ a ▁ = ▁ " , a , " , ▁ b ▁ = ▁ " , b ) NEW_LINE DEDENT
def checkSentence ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE if string [ 0 ] < ' A ' or string [ 0 ] > ' Z ' : NEW_LINE INDENT return False NEW_LINE DEDENT if string [ length - 1 ] != ' . ' : NEW_LINE INDENT return False NEW_LINE DEDENT prev_state = 0 NEW_LINE curr_state = 0 NEW_LINE index = 1 NEW_LINE while ( string [ index ] ) : NEW_LINE INDENT if string [ index ] >= ' A ' and string [ index ] <= ' Z ' : NEW_LINE INDENT curr_state = 0 NEW_LINE DEDENT elif string [ index ] == ' ▁ ' : NEW_LINE INDENT curr_state = 1 NEW_LINE DEDENT elif string [ index ] >= ' a ' and string [ index ] <= ' z ' : NEW_LINE INDENT curr_state = 2 NEW_LINE DEDENT elif string [ index ] == ' . ' : NEW_LINE INDENT curr_state = 3 NEW_LINE DEDENT if prev_state == curr_state and curr_state != 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if prev_state == 2 and curr_state == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if curr_state == 3 and prev_state != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT index += 1 NEW_LINE prev_state = curr_state NEW_LINE DEDENT return False NEW_LINE DEDENT string = [ " I ▁ love ▁ cinema . " , " The ▁ vertex ▁ is ▁ S . " , " I ▁ am ▁ single . " , " My ▁ name ▁ is ▁ KG . " , " I ▁ lovE ▁ cinema . " , " GeeksQuiz . ▁ is ▁ a ▁ quiz ▁ site . " , " I ▁ love ▁ Geeksquiz ▁ and ▁ Geeksforgeeks . " , " ▁ You ▁ are ▁ my ▁ friend . " , " I ▁ love ▁ cinema " ] NEW_LINE string_size = len ( string ) NEW_LINE for i in xrange ( string_size ) : NEW_LINE INDENT if checkSentence ( string [ i ] ) : NEW_LINE INDENT print " \ " " + string [ i ] + " \ " ▁ is ▁ correct " NEW_LINE DEDENT else : NEW_LINE INDENT print " \ " " + string [ i ] + " \ " ▁ is ▁ incorrect " NEW_LINE DEDENT DEDENT
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT
def isSubSequence ( string1 , string2 , m , n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if string1 [ m - 1 ] == string2 [ n - 1 ] : NEW_LINE INDENT return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( string1 , string2 , m , n - 1 ) NEW_LINE DEDENT string1 = " gksrek " NEW_LINE string2 = " geeksforgeeks " NEW_LINE if isSubSequence ( string1 , string2 , len ( string1 ) , len ( string2 ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def segregate0and1 ( arr , size ) : NEW_LINE INDENT left , right = 0 , size - 1 NEW_LINE while left < right : NEW_LINE INDENT while arr [ left ] == 0 and left < right : NEW_LINE INDENT left += 1 NEW_LINE DEDENT while arr [ right ] == 1 and left < right : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT if left < right : NEW_LINE INDENT arr [ left ] = 0 NEW_LINE arr [ right ] = 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
def segregate0and1 ( arr , size ) : NEW_LINE INDENT type0 = 0 NEW_LINE type1 = size - 1 NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT ( arr [ type0 ] , arr [ type1 ] ) = ( arr [ type1 ] , arr [ type0 ] ) NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE segregate0and1 ( arr , arr_size ) NEW_LINE print ( " Array ▁ after ▁ segregation ▁ is " , end = " ▁ " ) NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def maxSubarrayProduct ( arr , n ) : NEW_LINE INDENT result = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mul = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT result = max ( result , mul ) NEW_LINE mul *= arr [ j ] NEW_LINE DEDENT result = max ( result , mul ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT sum -= ( 2 * arr [ i ] ) NEW_LINE sum += ( 2 * arr [ n - i - 1 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def replace_elements ( arr , n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ pos ] = arr [ i ] NEW_LINE pos = pos + 1 NEW_LINE while ( pos > 1 and arr [ pos - 2 ] == arr [ pos - 1 ] ) : NEW_LINE INDENT pos -= 1 NEW_LINE arr [ pos - 1 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , pos ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def rearrange ( n ) : NEW_LINE INDENT global arr NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT currIdx = int ( ( n - 1 ) / 2 ) NEW_LINE while ( currIdx > 0 ) : NEW_LINE INDENT count = currIdx NEW_LINE swapIdx = currIdx NEW_LINE while ( count > 0 ) : NEW_LINE INDENT temp = arr [ swapIdx + 1 ] NEW_LINE arr [ swapIdx + 1 ] = arr [ swapIdx ] NEW_LINE arr [ swapIdx ] = temp NEW_LINE swapIdx = swapIdx + 1 NEW_LINE count = count - 1 NEW_LINE DEDENT currIdx = currIdx - 1 NEW_LINE DEDENT DEDENT n = len ( arr ) NEW_LINE rearrange ( n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " { } ▁ " . format ( arr [ i ] ) , end = " " ) NEW_LINE DEDENT
def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size ) : NEW_LINE INDENT if ( arr [ j ] - arr [ i ] > max_diff ) : NEW_LINE INDENT max_diff = arr [ j ] - arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return max_diff NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT maxDiff = - 1 NEW_LINE maxRight = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxRight ) : NEW_LINE INDENT maxRight = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT diff = maxRight - arr [ i ] NEW_LINE if ( diff > maxDiff ) : NEW_LINE INDENT maxDiff = diff NEW_LINE DEDENT DEDENT DEDENT return maxDiff NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if ( curr_sum > 0 ) : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if ( curr_sum > max_sum ) : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def maxIndexDiff ( arr , n ) : NEW_LINE INDENT maxDiff = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] and maxDiff < ( j - i ) : NEW_LINE INDENT maxDiff = j - i NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT return maxDiff NEW_LINE DEDENT
def findMaximum ( arr , low , high ) : NEW_LINE INDENT max = arr [ low ] NEW_LINE i = low NEW_LINE for i in range ( high + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def findMaximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high == low + 1 and arr [ low ] >= arr [ high ] : NEW_LINE INDENT return arr [ low ] ; NEW_LINE DEDENT if high == low + 1 and arr [ low ] < arr [ high ] : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT
def maxRepeating ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ arr [ i ] % k ] += k NEW_LINE DEDENT max = arr [ 0 ] NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE result = i NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def smallestGreater ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT diff = 1000 ; NEW_LINE closest = - 1 ; NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] and arr [ j ] - arr [ i ] < diff ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE closest = j ; NEW_LINE DEDENT DEDENT if ( closest == - 1 ) : NEW_LINE INDENT print ( " _ ▁ " , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " { } ▁ " . format ( arr [ closest ] ) , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT
def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ j - 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] > arr [ i ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) / 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if len > 1 : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) / 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def minNumber ( a , n , x ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE k = 0 NEW_LINE while ( a [ int ( ( n - 1 ) / 2 ) ] != x ) : NEW_LINE INDENT a [ n - 1 ] = x NEW_LINE n += 1 NEW_LINE a . sort ( reverse = False ) NEW_LINE k += 1 NEW_LINE DEDENT return k NEW_LINE DEDENT
def minNumber ( a , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = 0 NEW_LINE e = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == x : NEW_LINE INDENT e += 1 NEW_LINE DEDENT elif a [ i ] > x : NEW_LINE INDENT h += 1 NEW_LINE DEDENT elif a [ i ] < x : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE if l > h : NEW_LINE INDENT ans = l - h NEW_LINE DEDENT elif l < h : NEW_LINE INDENT ans = h - l - 1 ; NEW_LINE DEDENT return ans + 1 - e NEW_LINE DEDENT
def checkEVENodd ( arr , n , l , r ) : NEW_LINE INDENT if ( arr [ r ] == 1 ) : NEW_LINE INDENT print ( " odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT DEDENT
def findMean ( arr , l , r ) : NEW_LINE INDENT sum , count = 0 , 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT mean = math . floor ( sum / count ) NEW_LINE return mean NEW_LINE DEDENT
def calculateProduct ( A , L , R , P ) : NEW_LINE INDENT L = L - 1 NEW_LINE R = R - 1 NEW_LINE ans = 1 NEW_LINE for i in range ( R + 1 ) : NEW_LINE INDENT ans = ans * A [ i ] NEW_LINE ans = ans % P NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countDe ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE v = arr . copy ( ) NEW_LINE arr . sort ( ) NEW_LINE count1 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != v [ i ] ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE count2 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != v [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return ( min ( count1 , count2 ) ) NEW_LINE DEDENT
def maxOfSegmentMins ( a , n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return min ( a ) NEW_LINE DEDENT if k == 2 : NEW_LINE INDENT return max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE DEDENT return max ( a ) NEW_LINE DEDENT
def printMinimumProduct ( arr , n ) : NEW_LINE INDENT first_min = min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE second_min = max ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] < first_min ) : NEW_LINE INDENT second_min = first_min NEW_LINE first_min = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < second_min ) : NEW_LINE INDENT second_min = arr [ i ] NEW_LINE DEDENT DEDENT return first_min * second_min NEW_LINE DEDENT
def noOfTriples ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == arr [ 2 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if arr [ 0 ] == arr [ 2 ] : NEW_LINE INDENT return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 NEW_LINE DEDENT elif arr [ 1 ] == arr [ 2 ] : NEW_LINE INDENT return ( count - 1 ) * ( count ) / 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def MinOperation ( a , b , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] > b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT elif ( a [ i ] < b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def sortExceptUandL ( a , l , u , n ) : NEW_LINE INDENT b = [ 0 ] * ( n - ( u - l + 1 ) ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT b [ l + ( i - ( u + 1 ) ) ] = a [ i ] NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT a [ i ] = b [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT a [ i ] = b [ l + ( i - ( u + 1 ) ) ] NEW_LINE DEDENT DEDENT a = [ 5 , 4 , 3 , 12 , 14 , 9 ] NEW_LINE n = len ( a ) NEW_LINE l = 2 NEW_LINE u = 4 NEW_LINE sortExceptUandL ( a , l , u , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " { } ▁ " . format ( a [ i ] ) , end = " " ) NEW_LINE DEDENT
def sortExcept ( arr , k , n ) : NEW_LINE INDENT arr [ k ] , arr [ - 1 ] = arr [ - 1 ] , arr [ k ] NEW_LINE arr = sorted ( arr , key = lambda i : ( i is arr [ - 1 ] , i ) ) NEW_LINE last = arr [ - 1 ] NEW_LINE i = n - 1 NEW_LINE while i > k : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ k ] = last NEW_LINE return arr NEW_LINE DEDENT
def minswaps ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE num_unplaced_zeros = 0 NEW_LINE for index in range ( len ( arr ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ index ] == 0 : NEW_LINE INDENT num_unplaced_zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += num_unplaced_zeros NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 ; max_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return int ( res ) NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countPairs ( a , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( a [ j ] - a [ i ] ) < k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def countPairs ( a , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and a [ j ] - a [ i ] < k ) : NEW_LINE INDENT res += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findMaxPairs ( a , b , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE flag = [ False ] * n NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( abs ( a [ i ] - b [ j ] ) <= k and flag [ j ] == False ) : NEW_LINE INDENT result += 1 NEW_LINE flag [ j ] = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def findMaxPairs ( a , b , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE result = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if j < n : NEW_LINE INDENT if abs ( a [ i ] - b [ j ] ) <= k : NEW_LINE INDENT result += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif a [ i ] > b [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def sumOfMinAbsDifferences ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE sum += abs ( arr [ 0 ] - arr [ 1 ] ) ; NEW_LINE sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def findSmallestDifference ( A , B , m , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE result = sys . maxsize NEW_LINE while ( a < m and b < n ) : NEW_LINE INDENT if ( abs ( A [ a ] - B [ b ] ) < result ) : NEW_LINE INDENT result = abs ( A [ a ] - B [ b ] ) NEW_LINE DEDENT if ( A [ a ] < B [ b ] ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findLarger ( arr , n ) : NEW_LINE INDENT x = sorted ( arr ) NEW_LINE for i in range ( n / 2 , n ) : NEW_LINE INDENT print ( x [ i ] ) , NEW_LINE DEDENT DEDENT
def singleelement ( arr , n ) : NEW_LINE INDENT low = 0 NEW_LINE high = n - 2 NEW_LINE mid = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == arr [ mid ^ 1 ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return arr [ low ] NEW_LINE DEDENT
def countTriplets ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countTriplets ( arr , n , sum ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT j = i + 1 NEW_LINE k = n - 1 NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) : NEW_LINE INDENT k = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( k - j ) NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countTriplets ( a , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT xr = a [ i ] ^ a [ j ] NEW_LINE if ( xr in s and xr != a [ i ] and xr != a [ j ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return int ( count / 3 ) NEW_LINE DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT i , total = 0 , 1 NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT total += i NEW_LINE total -= a [ i - 2 ] NEW_LINE DEDENT return total NEW_LINE DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT n_elements_sum = n * ( n + 1 ) // 2 NEW_LINE return n_elements_sum - sum ( a ) NEW_LINE DEDENT
def countOccurrences ( arr , n , x ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x == arr [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT
def countOnes ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if arr [ mid ] == 1 : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , mid - 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def findMissing ( arr1 , arr2 , M , N ) : NEW_LINE INDENT if ( M != N - 1 and N != M - 1 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT res = res ^ arr1 [ i ] ; NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT res = res ^ arr2 [ i ] NEW_LINE DEDENT print ( " Missing ▁ element ▁ is " , res ) NEW_LINE DEDENT
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are " , x , " & " , y ) NEW_LINE DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT size = len ( arr ) NEW_LINE i , j = 0 , 1 NEW_LINE while i < size and j < size : NEW_LINE INDENT if i != j and arr [ j ] - arr [ i ] == n : NEW_LINE INDENT print " Pair ▁ found ▁ ( " , arr [ i ] , " , " , arr [ j ] , " ) " NEW_LINE return True NEW_LINE DEDENT elif arr [ j ] - arr [ i ] < n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print " No ▁ pair ▁ found " NEW_LINE return False NEW_LINE DEDENT
def findFourElements ( A , n , X ) : NEW_LINE INDENT for i in range ( 0 , n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] + A [ l ] == X : NEW_LINE INDENT print ( " % d , ▁ % d , ▁ % d , ▁ % d " % ( A [ i ] , A [ j ] , A [ k ] , A [ l ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > second and arr [ i ] < first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > third and arr [ i ] < second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ Third ▁ Largest " , " element ▁ is " , third ) NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT if ( arr [ n - 1 ] == x ) : NEW_LINE INDENT return " Found " NEW_LINE DEDENT backup = arr [ n - 1 ] NEW_LINE arr [ n - 1 ] = x NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT arr [ n - 1 ] = backup NEW_LINE if ( i < n - 1 ) : NEW_LINE INDENT return " Found " NEW_LINE DEDENT return " Not ▁ Found " NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ int ( n / 2 ) ] NEW_LINE DEDENT
def minAdjDifference ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : return NEW_LINE res = abs ( arr [ 1 ] - arr [ 0 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) NEW_LINE DEDENT res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) NEW_LINE print ( " Min ▁ Difference ▁ = ▁ " , res ) NEW_LINE DEDENT
def deleteElement ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < n ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def deleteElement ( arr , n , x ) : NEW_LINE INDENT if arr [ n - 1 ] == x : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT prev = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] != x : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT DEDENT if i < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr [ i ] = prev NEW_LINE return n - 1 NEW_LINE DEDENT arr = [ 11 , 15 , 6 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 6 NEW_LINE n = deleteElement ( arr , n , x ) NEW_LINE print ( " Modified ▁ array ▁ is " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT small = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT DEDENT great = 0 ; NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT great += 1 NEW_LINE DEDENT DEDENT invcount += great * small NEW_LINE DEDENT return invcount NEW_LINE DEDENT
def findWater ( arr , n ) : NEW_LINE INDENT left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE water = 0 NEW_LINE left [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT left [ i ] = max ( left [ i - 1 ] , arr [ i ] ) NEW_LINE DEDENT right [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT right [ i ] = max ( right [ i + 1 ] , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT water += min ( left [ i ] , right [ i ] ) - arr [ i ] NEW_LINE DEDENT return water NEW_LINE DEDENT
def findWater ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE left_max = 0 NEW_LINE right_max = 0 NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT if ( arr [ lo ] < arr [ hi ] ) : NEW_LINE INDENT if ( arr [ lo ] > left_max ) : NEW_LINE INDENT left_max = arr [ lo ] NEW_LINE DEDENT else : NEW_LINE INDENT result += left_max - arr [ lo ] NEW_LINE DEDENT lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( arr [ hi ] > right_max ) : NEW_LINE INDENT right_max = arr [ hi ] NEW_LINE DEDENT else : NEW_LINE INDENT result += right_max - arr [ hi ] NEW_LINE DEDENT hi -= 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxWater ( arr , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE l_max = 0 NEW_LINE r_max = 0 NEW_LINE result = 0 NEW_LINE while ( left <= right ) : NEW_LINE INDENT if r_max <= l_max : NEW_LINE INDENT result += max ( 0 , r_max - arr [ right ] ) NEW_LINE r_max = max ( r_max , arr [ right ] ) NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += max ( 0 , l_max - arr [ left ] ) NEW_LINE l_max = max ( l_max , arr [ left ] ) NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def missingK ( a , k , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE count = k NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT difference = 0 NEW_LINE if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) : NEW_LINE INDENT difference += ( a [ i + 1 ] - a [ i ] ) - 1 NEW_LINE if ( difference >= count ) : NEW_LINE INDENT ans = a [ i ] + count NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT count -= difference NEW_LINE DEDENT DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def countPairs ( A , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE A . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = 0 NEW_LINE while ( ( A [ i ] * math . pow ( k , x ) ) <= A [ j ] ) : NEW_LINE INDENT if ( ( A [ i ] * math . pow ( k , x ) ) == A [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findValue ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == k ) : NEW_LINE INDENT k = k * 2 NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT
def dupLastIndex ( arr , n ) : NEW_LINE INDENT if ( arr == None or n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT print ( " Last ▁ index : " , i ,   " Last " , ▁ " duplicate item : " , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " no ▁ duplicate ▁ found " ) NEW_LINE DEDENT
def findSmallest ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( a [ j ] % a [ i ] ) >= 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == n - 1 ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findIndex ( arr ) : NEW_LINE INDENT maxIndex = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > arr [ maxIndex ] ) : NEW_LINE INDENT maxIndex = i NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( maxIndex != i and arr [ maxIndex ] < ( 2 * arr [ i ] ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return maxIndex NEW_LINE DEDENT
def find_consecutive_steps ( arr , len ) : NEW_LINE INDENT count = 0 ; maximum = 0 NEW_LINE for index in range ( 1 , len ) : NEW_LINE INDENT if ( arr [ index ] > arr [ index - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maximum = max ( maximum , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max ( maximum , count ) NEW_LINE DEDENT
def CalculateMax ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE max_sum = arr [ n - 1 ] + arr [ n - 2 ] NEW_LINE return abs ( max_sum - min_sum ) NEW_LINE DEDENT
def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = [ ] ; NEW_LINE i = 0 ; NEW_LINE j = n - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT s . append ( ( a [ i ] + a [ j ] ) ) ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT mini = min ( s ) ; NEW_LINE maxi = max ( s ) ; NEW_LINE return abs ( maxi - mini ) ; NEW_LINE DEDENT
def printMinDiffPairs ( arr , n ) : NEW_LINE INDENT if n <= 1 : return NEW_LINE arr . sort ( ) NEW_LINE minDiff = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] ) == minDiff : NEW_LINE INDENT print ( " ( " + str ( arr [ i - 1 ] ) + " , ▁ " + str ( arr [ i ] ) + " ) , ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def maxDistance ( array ) : NEW_LINE INDENT max1 = - 2147483648 NEW_LINE min1 = + 2147483647 NEW_LINE max2 = - 2147483648 NEW_LINE min2 = + 2147483647 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT max1 = max ( max1 , array [ i ] + i ) NEW_LINE min1 = min ( min1 , array [ i ] + i ) NEW_LINE max2 = max ( max2 , array [ i ] - i ) NEW_LINE min2 = min ( min2 , array [ i ] - i ) NEW_LINE DEDENT return max ( max1 - min1 , max2 - min2 ) NEW_LINE DEDENT
def extrema ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT count += ( a [ i ] > a [ i - 1 ] and a [ i ] > a [ i + 1 ] ) ; NEW_LINE count += ( a [ i ] < a [ i - 1 ] and a [ i ] < a [ i + 1 ] ) ; NEW_LINE DEDENT return count NEW_LINE DEDENT
def _sum ( a , n ) : NEW_LINE INDENT maxSum = - 9999999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxSum = max ( maxSum , a [ i ] + a [ j ] ) NEW_LINE DEDENT DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] + a [ j ] == maxSum : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT
def nobleInteger ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == arr [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 3 , 20 , 40 , 2 ] NEW_LINE size = len ( arr ) NEW_LINE res = nobleInteger ( arr , size ) NEW_LINE if ( res != - 1 ) : NEW_LINE INDENT print ( " The ▁ noble ▁ integer ▁ is ▁ " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Noble ▁ Integer ▁ Found " ) NEW_LINE DEDENT
def nobleInteger ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if arr [ i ] == n - i - 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT if arr [ n - 1 ] == 0 : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 3 , 20 , 40 , 2 ] NEW_LINE res = nobleInteger ( arr ) NEW_LINE if res != - 1 : NEW_LINE INDENT print ( " The ▁ noble ▁ integer ▁ is " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Noble ▁ Integer ▁ Found " ) NEW_LINE DEDENT
def findMinSum ( a , b , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def deleteAlt ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT node = head . next NEW_LINE if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT head . next = node . next NEW_LINE deleteAlt ( head . next ) NEW_LINE DEDENT
def rotate ( arr , N , X ) : NEW_LINE INDENT nextPower = 1 NEW_LINE while ( nextPower <= N ) : NEW_LINE INDENT nextPower *= 2 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT ans = nextPower - N NEW_LINE return ans NEW_LINE DEDENT prevPower = nextPower // 2 NEW_LINE return 2 * ( N - prevPower ) + 1 NEW_LINE DEDENT
def findLargestRotation ( num ) : NEW_LINE INDENT ans = num NEW_LINE length = len ( str ( num ) ) NEW_LINE x = 10 ** ( length - 1 ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT lastDigit = num % 10 NEW_LINE num = num // 10 NEW_LINE num += ( lastDigit * x ) NEW_LINE if ( num > ans ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def getFirstElement ( a , N , K , M ) : NEW_LINE INDENT K %= N NEW_LINE if ( K >= M ) : NEW_LINE INDENT index = ( N - K ) + ( M - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT index = ( M - K - 1 ) NEW_LINE DEDENT result = a [ index ] NEW_LINE return result NEW_LINE DEDENT
def getFirstElement ( a , N , K , M ) : NEW_LINE INDENT K %= N NEW_LINE index = ( K + M - 1 ) % N NEW_LINE result = a [ index ] NEW_LINE return result NEW_LINE DEDENT
def countRotation ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def isConversionPossible ( s1 , s2 , x ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE s1 = list ( s1 ) NEW_LINE s2 = list ( s2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT diff = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE if diff == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if diff < 0 : NEW_LINE INDENT diff = diff + 26 NEW_LINE DEDENT if diff > x : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def RightRotate ( a , n , k ) : NEW_LINE INDENT k = k % n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT print ( a [ n + i - k ] , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i - k ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( " " ) ; NEW_LINE DEDENT
def countRotation ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while n > 0 : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( digit % 2 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def performQueries ( string , n , queries , q ) : NEW_LINE INDENT ptr = 0 ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT if ( queries [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; NEW_LINE DEDENT else : NEW_LINE INDENT k = queries [ i ] [ 1 ] ; NEW_LINE index = ( ptr + k - 1 ) % n ; NEW_LINE print ( string [ index ] ) ; NEW_LINE DEDENT DEDENT DEDENT
def countOddRotations ( n ) : NEW_LINE INDENT odd_count = 0 ; even_count = 0 NEW_LINE while n != 0 : NEW_LINE INDENT digit = n % 10 NEW_LINE if digit % 2 == 0 : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Odd ▁ = " , odd_count ) NEW_LINE print ( " Even ▁ = " , even_count ) NEW_LINE DEDENT
def generateNumbers ( m ) : NEW_LINE INDENT numbers = [ ] NEW_LINE for y in range ( 1 , 10 ) : NEW_LINE INDENT k_max = ( ( 10 ** ( m - 2 ) * ( 10 * y + 1 ) ) // ( 10 ** ( m - 1 ) + y ) ) NEW_LINE for k in range ( 1 , k_max + 1 ) : NEW_LINE INDENT x = ( ( y * ( 10 ** ( m - 1 ) - k ) ) // ( 10 * k - 1 ) ) NEW_LINE if ( ( y * ( 10 ** ( m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) : NEW_LINE INDENT numbers . append ( 10 * x + y ) NEW_LINE DEDENT DEDENT DEDENT for n in sorted ( numbers ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT
def rotate90Clockwise ( arr ) : NEW_LINE INDENT global N NEW_LINE for j in range ( N ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def occurredOnce ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE if arr [ 0 ] != arr [ 1 ] : NEW_LINE INDENT print ( arr [ 0 ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if arr [ n - 2 ] != arr [ n - 1 ] : NEW_LINE INDENT print ( arr [ n - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def occurredOnce ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE len = n NEW_LINE if arr [ 0 ] == arr [ len - 1 ] : NEW_LINE INDENT i = 2 NEW_LINE len -= 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i - 1 ] , end = " ▁ " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( arr [ n - 1 ] != arr [ 0 ] and arr [ n - 1 ] != arr [ n - 2 ] ) : NEW_LINE INDENT print ( arr [ n - 1 ] ) NEW_LINE DEDENT DEDENT
def minimunMoves ( arr , n ) : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT tmp = arr [ j ] + arr [ j ] NEW_LINE index = tmp . find ( arr [ i ] ) NEW_LINE if ( index == len ( arr [ i ] ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT curr_count += index NEW_LINE DEDENT ans = min ( curr_count , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def minLexRotation ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE arr = [ 0 ] * n NEW_LINE concat = str_ + str_ NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = concat [ i : n + i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ 0 ] NEW_LINE DEDENT
def findPair ( a , n , z ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i != j and a [ i ] + a [ j ] == z ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT a = [ 1 , - 2 , 1 , 0 , 5 ] NEW_LINE z = 0 NEW_LINE n = len ( a ) NEW_LINE if ( findPair ( a , n , z ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT
def printt ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT print ( a [ i ] , " " , a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def linearSearch ( a , n , key ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == key ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = 2 , 3 , 4 , 10 , 40 NEW_LINE x = 10 NEW_LINE n = len ( arr ) NEW_LINE if ( linearSearch ( arr , n , x ) ) : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT
def NimGame ( N , A , B ) : NEW_LINE INDENT sum = A + B NEW_LINE if ( N % sum <= A - 1 ) : NEW_LINE INDENT return " Bob " NEW_LINE DEDENT else : NEW_LINE INDENT return " Alice " NEW_LINE DEDENT DEDENT
def maximumSum ( arr , N ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT Sum += ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT DEDENT return Sum ; NEW_LINE DEDENT
def findWinner ( n , m ) : NEW_LINE INDENT X = 0 ; NEW_LINE Y = 0 ; NEW_LINE if ( n >= m ) : NEW_LINE INDENT X = n - 1 ; NEW_LINE Y = m ; NEW_LINE DEDENT else : NEW_LINE INDENT X = m - 1 ; NEW_LINE Y = n ; NEW_LINE DEDENT if ( X > Y ) : NEW_LINE INDENT print ( " X " ) ; NEW_LINE DEDENT elif ( Y > X ) : NEW_LINE INDENT print ( " Y " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT
def checkPascaltriangle ( N ) : NEW_LINE INDENT x = ( math . sqrt ( 8 * N + 1 ) - 1 ) / 2 NEW_LINE if ( math . ceil ( x ) - x == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( ( j - i ) % 2 == 0 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT sum -= arr [ j ] NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def checkIfDivisible ( string , num ) : NEW_LINE INDENT powerOf2 = int ( log2 ( num ) ) ; NEW_LINE if ( len ( string ) < powerOf2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( powerOf2 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT number = 0 ; NEW_LINE length = len ( string ) ; NEW_LINE for i in range ( length - powerOf2 , length ) : NEW_LINE INDENT number += ( ( ord ( string [ i ] ) - ord ( '0' ) ) * ( 10 ** ( powerOf2 - 1 ) ) ) ; NEW_LINE powerOf2 -= 1 ; NEW_LINE DEDENT if ( number % num ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT
def countNo ( A , N , L , R ) : NEW_LINE INDENT ans = L - 1 + N + math . floor ( ( N - 1 ) / ( A - 1 ) ) NEW_LINE if ans % A == 0 : NEW_LINE INDENT ans = ans + 1 ; NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def check_order ( arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( abs ( arr [ 0 ] - arr [ len ( arr ) - 1 ] ) > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( cnt > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 1 ] NEW_LINE if ( check_order ( arr ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def getM ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n - 2 ; NEW_LINE DEDENT DEDENT
def compute ( query ) : NEW_LINE INDENT v = [ None ] * 100001 NEW_LINE dp = [ None ] * 100001 NEW_LINE v [ 1 ] = 1 NEW_LINE v [ 2 ] = 0 NEW_LINE dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = 0 NEW_LINE for i in range ( 3 , 100001 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT if ( ( i // 2 ) % 2 == 0 ) : NEW_LINE INDENT v [ i ] = 1 NEW_LINE dp [ i ] = dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT v [ i ] = v [ i // 2 ] + 1 NEW_LINE dp [ i ] = dp [ i - 1 ] + v [ i ] - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT v [ i ] = 0 NEW_LINE dp [ i ] = dp [ i - 1 ] NEW_LINE DEDENT DEDENT for x in query : NEW_LINE INDENT print ( dp [ x ] ) NEW_LINE DEDENT DEDENT
def findSubarrays ( arr , N , K ) : NEW_LINE INDENT return N - K + 1 ; NEW_LINE DEDENT
def findCycles ( N ) : NEW_LINE INDENT res = 0 NEW_LINE finalResult = 0 NEW_LINE val = 2 * N - 1 ; NEW_LINE s = val NEW_LINE res = ( N - 1 ) * ( N - 2 ) NEW_LINE finalResult = res + s ; NEW_LINE return finalResult ; NEW_LINE DEDENT
def countPairs ( A , B ) : NEW_LINE INDENT countY = 0 NEW_LINE countX = ( B - A ) + 1 NEW_LINE next_val = 9 NEW_LINE while ( next_val <= B ) : NEW_LINE INDENT if ( next_val >= A ) : NEW_LINE INDENT countY += 1 NEW_LINE DEDENT next_val = next_val * 10 + 9 NEW_LINE DEDENT return ( countX * countY ) NEW_LINE DEDENT
def solve ( N , M ) : NEW_LINE INDENT ans = int ( ( N ) * int ( M / 2 ) ) NEW_LINE if ( M % 2 == 1 ) : NEW_LINE INDENT ans += int ( ( N + 1 ) / 2 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def precompute ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT cnt [ i + 1 ] = cnt [ i ] NEW_LINE if s [ i : len ( K ) + i ] == K : NEW_LINE INDENT cnt [ i + 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def constructArray ( N , K , X ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT ans [ 0 ] = X NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT print ( ans [ i % K ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def formQuadruplets ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE pairs = 0 NEW_LINE pairs = n // 4 NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( 0 , n - pairs , 3 ) : NEW_LINE INDENT ans += arr [ i + 2 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def possiblePositions ( n ) : NEW_LINE INDENT term1 = pow ( n , 4 ) ; NEW_LINE term2 = pow ( n , 3 ) ; NEW_LINE term3 = pow ( n , 2 ) ; NEW_LINE term4 = n / 3 ; NEW_LINE ans = ( ( math . ceil ( term1 ) ) / 2 - ( math . ceil ( 5 * term2 ) ) / 3 + ( math . ceil ( 3 * term3 ) ) / 2 - term4 ) ; NEW_LINE return ans ; NEW_LINE DEDENT
def countIntgralPoints ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) NEW_LINE DEDENT
def ShortestPalindrome ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = min ( ans , s [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printArray ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE j = n - 1 ; NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ j ] , end = " ▁ " ) ; NEW_LINE print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT
def SmallestDiv ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = INT_MAX ; NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT maxDiff = INT_MIN ; NEW_LINE for j in range ( n - k - 1 ) : NEW_LINE INDENT for p in range ( i , i + j + 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; NEW_LINE DEDENT DEDENT minDiff = min ( minDiff , maxDiff ) ; NEW_LINE DEDENT return minDiff ; NEW_LINE DEDENT
def maximumArea ( l , b , x , y ) : NEW_LINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE DEDENT
def countPair ( a , b ) : NEW_LINE INDENT s = str ( b ) NEW_LINE i = 0 NEW_LINE while i < ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != '9' ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT result = 0 NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT result = a * len ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT result = a * ( len ( s ) - 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def getArea ( a ) : NEW_LINE INDENT area = ( math . pi * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT
def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 ; count_even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 ; NEW_LINE DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT
def minSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) ; NEW_LINE n //= 10 ; NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT return 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def getWinner ( string , length ) : NEW_LINE INDENT total = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 ; NEW_LINE DEDENT DEDENT if ( ( total % 2 ) == 1 ) : NEW_LINE INDENT return " First " ; NEW_LINE DEDENT return " Second " ; NEW_LINE DEDENT
def findTriangle ( S ) : NEW_LINE INDENT X1 = 0 ; Y1 = 0 ; NEW_LINE X2 = MAX ; Y2 = 1 ; NEW_LINE X3 = ( MAX - S % MAX ) % MAX ; NEW_LINE Y3 = ( S + X3 ) / MAX ; NEW_LINE print ( " ( " , X1 , " , " , Y1 , " ) " ) ; NEW_LINE print ( " ( " , X2 , " , " , Y2 , " ) " ) ; NEW_LINE print ( " ( " , X3 , " , " , Y3 , " ) " ) ; NEW_LINE DEDENT
def maxOperations ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT diff = Y - X ; NEW_LINE if ( diff == 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( diff % 2 == 0 ) : NEW_LINE INDENT return ( diff // 2 ) ; NEW_LINE DEDENT return ( 1 + ( ( diff - 3 ) // 2 ) ) ; NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT F [ 1 ] = 2 ; NEW_LINE F [ 2 ] = 3 ; NEW_LINE F [ 3 ] = 4 ; NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; NEW_LINE DEDENT DEDENT
def get ( L , R ) : NEW_LINE INDENT x = 1.0 / L ; NEW_LINE y = 1.0 / ( R + 1.0 ) ; NEW_LINE return ( x - y ) ; NEW_LINE DEDENT
def findMin ( N : int ) : NEW_LINE INDENT digit = N % 10 NEW_LINE if digit == 0 and N >= 90 : NEW_LINE INDENT return 10 NEW_LINE DEDENT elif digit == 1 and N >= 81 : NEW_LINE INDENT return 9 NEW_LINE DEDENT elif digit == 2 and N >= 72 : NEW_LINE INDENT return 8 NEW_LINE DEDENT elif digit == 3 and N >= 63 : NEW_LINE INDENT return 7 NEW_LINE DEDENT elif digit == 4 and N >= 54 : NEW_LINE INDENT return 6 NEW_LINE DEDENT elif digit == 5 and N >= 45 : NEW_LINE INDENT return 5 NEW_LINE DEDENT elif digit == 6 and N >= 36 : NEW_LINE INDENT return 4 NEW_LINE DEDENT elif digit == 7 and N >= 27 : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif digit == 8 and N >= 18 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif digit == 9 and N >= 9 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def checkEvenOdd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( " Even " , end = " " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( " Odd " , end = " " ) ; NEW_LINE DEDENT
def maxPartition ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE P = 0 NEW_LINE current = " " NEW_LINE previous = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT current += s [ i ] NEW_LINE if ( current != previous ) : NEW_LINE INDENT previous = current NEW_LINE current = " " NEW_LINE P += 1 NEW_LINE DEDENT DEDENT return P NEW_LINE DEDENT
def find_maximum_value ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE minimum = 10 ** 9 NEW_LINE pos = 0 NEW_LINE neg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minimum = min ( minimum , abs ( a [ i ] ) ) NEW_LINE sum += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT neg += 1 NEW_LINE DEDENT DEDENT if ( pos > 0 and neg > 0 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT return ( sum - 2 * minimum ) NEW_LINE DEDENT
def find_number ( N , K ) : NEW_LINE INDENT r = " " NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += "00" NEW_LINE DEDENT return r NEW_LINE DEDENT
def maxCountAB ( s , n ) : NEW_LINE INDENT A = 0 NEW_LINE B = 0 NEW_LINE BA = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = s [ i ] NEW_LINE L = len ( S ) NEW_LINE for j in range ( L - 1 ) : NEW_LINE INDENT if ( S [ j ] == ' A ' and S [ j + 1 ] == ' B ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ( S [ 0 ] == ' B ' and S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT BA += 1 NEW_LINE DEDENT DEDENT elif ( S [ 0 ] == ' B ' ) : NEW_LINE INDENT B += 1 NEW_LINE DEDENT elif ( S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT A += 1 NEW_LINE DEDENT if ( BA == 0 ) : NEW_LINE INDENT ans += min ( B , A ) NEW_LINE DEDENT elif ( A + B == 0 ) : NEW_LINE INDENT ans += BA - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += BA + min ( B , A ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countPairs ( s ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE st . add ( ' a ' ) ; NEW_LINE st . add ( ' e ' ) ; NEW_LINE st . add ( ' i ' ) ; NEW_LINE st . add ( ' o ' ) ; NEW_LINE st . add ( ' u ' ) ; NEW_LINE count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] not in st and s [ i + 1 ] in st ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def maxSize ( v , n ) : NEW_LINE INDENT v . append ( 0 ) NEW_LINE v . append ( 100001 ) NEW_LINE n += 2 NEW_LINE v = sorted ( v ) NEW_LINE mx = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT L = v [ i - 1 ] + 1 NEW_LINE R = v [ i + 1 ] - 1 NEW_LINE cnt = R - L + 1 NEW_LINE mx = max ( mx , cnt ) NEW_LINE DEDENT return mx NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def getMinVal ( p , q ) : NEW_LINE INDENT if q % p == 0 : NEW_LINE INDENT return p NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findPoints ( l1 , r1 , l2 , r2 ) : NEW_LINE INDENT x = min ( l1 , l2 ) if ( l1 != l2 ) else - 1 NEW_LINE y = max ( r1 , r2 ) if ( r1 != r2 ) else - 1 NEW_LINE print ( x , y ) NEW_LINE DEDENT
def minOperations ( N ) : NEW_LINE INDENT x = log2 ( N ) NEW_LINE ans = ceil ( x ) NEW_LINE return ans NEW_LINE DEDENT
def find_greatest_divisor ( l , r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT return l ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT
def findNumbers ( arr , n ) : NEW_LINE INDENT sumN = ( n * ( n + 1 ) ) / 2 ; NEW_LINE sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEW_LINE sum = 0 ; NEW_LINE sumSq = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] ; NEW_LINE sumSq = sumSq + ( math . pow ( arr [ i ] , 2 ) ) ; NEW_LINE DEDENT B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; NEW_LINE A = sum - sumN + B ; NEW_LINE print ( " A ▁ = ▁ " , int ( A ) ) ; NEW_LINE print ( " B ▁ = ▁ " , int ( B ) ) ; NEW_LINE DEDENT
def getProbability ( p , q ) : NEW_LINE INDENT p /= 100 NEW_LINE q /= 100 NEW_LINE probability = ( p * p + q * q ) / ( p + q ) NEW_LINE return probability NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] & 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT
def minimumOperations ( arr , N ) : NEW_LINE INDENT mx = 0 NEW_LINE pos = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] >= mx ) : NEW_LINE INDENT mx = arr [ i ] NEW_LINE pos = i NEW_LINE DEDENT DEDENT print ( ( mx - 1 ) * N + pos + 1 ) NEW_LINE DEDENT
def printFreq ( arr , N ) : NEW_LINE INDENT freq = 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Frequency ▁ of " , arr [ i - 1 ] , " is : " , freq ) NEW_LINE freq = 1 NEW_LINE DEDENT DEDENT print ( " Frequency ▁ of " , arr [ N - 1 ] , " is : " , freq ) NEW_LINE DEDENT
def findLargestIndex ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == i ) : NEW_LINE INDENT print ( i ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def getPairsCount ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( a [ i ] * a [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def getPairsCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = arr [ i ] - ( i % arr [ i ] ) NEW_LINE for j in range ( s , n ) : NEW_LINE INDENT if ( i < j and ( arr [ i ] * arr [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def Minimum ( N , K ) : NEW_LINE INDENT sum = N * ( N + 1 ) // 2 NEW_LINE if ( K > sum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( K <= N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( N >= 1 and sum < K ) : NEW_LINE INDENT count += 1 NEW_LINE sum += N NEW_LINE N -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def numberofBoxes ( W , B , O ) : NEW_LINE INDENT low = 0 NEW_LINE high = min ( W , B ) NEW_LINE ans = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( ( W >= mid ) and ( B >= mid ) ) and ( ( W - mid ) + ( B - mid ) + O ) >= mid ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def minSwaps ( N , M , A , B ) : NEW_LINE INDENT count01 = 0 NEW_LINE count10 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , M ) : NEW_LINE INDENT if ( A [ i ] [ j ] != B [ i ] [ j ] ) : NEW_LINE INDENT if ( A [ i ] [ j ] == 1 ) : NEW_LINE INDENT count10 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count01 += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( count01 == count10 ) : NEW_LINE INDENT return count01 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def Count ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT sum += i NEW_LINE if ( sum <= K ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def Count ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = ( mid * mid + mid ) // 2 NEW_LINE if ( sum <= K ) : NEW_LINE INDENT res = max ( res , mid ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def repeatingElement ( arr , N ) : NEW_LINE INDENT M = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE M = max ( M , arr [ i ] ) NEW_LINE DEDENT sum1 = M * ( M + 1 ) // 2 NEW_LINE ans = ( sum - sum1 ) // ( N - M ) NEW_LINE return ans NEW_LINE DEDENT
def largestNum ( arr , n ) : NEW_LINE INDENT st = set ( [ ] ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( arr [ i ] ) NEW_LINE if ( - 1 * arr [ i ] ) in st : NEW_LINE INDENT res = max ( res , abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def probability ( arr1 , arr2 ) : NEW_LINE INDENT N = len ( arr1 ) NEW_LINE M = len ( arr2 ) NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT y = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( arr2 [ j ] > arr1 [ i ] ) : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT res += y NEW_LINE DEDENT res = res / ( N * M ) NEW_LINE return res NEW_LINE DEDENT
def minCost ( arr , A , B ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE m = len ( arr [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < m : NEW_LINE INDENT if ( arr [ i ] [ j ] == ' * ' ) : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT if ( j == m - 1 ) : NEW_LINE INDENT ans += A NEW_LINE DEDENT else : NEW_LINE INDENT if ( arr [ i ] [ j + 1 ] == ' . ' ) : NEW_LINE INDENT ans += min ( 2 * A , B ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += A NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def findkthElement ( arr , n , K ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while l + 1 < h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if arr [ l ] >= arr [ mid ] : NEW_LINE INDENT l = mid NEW_LINE DEDENT else : NEW_LINE INDENT h = mid NEW_LINE DEDENT DEDENT if arr [ l ] < arr [ h ] : NEW_LINE INDENT r = l NEW_LINE DEDENT else : NEW_LINE INDENT r = h NEW_LINE DEDENT if K <= r + 1 : NEW_LINE INDENT return arr [ r + 1 - K ] NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ n - ( K - ( r + 1 ) ) ] NEW_LINE DEDENT DEDENT
def find ( arr , N , key ) : NEW_LINE INDENT l = 0 NEW_LINE h = N - 1 NEW_LINE while l <= h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] >= arr [ mid ] : NEW_LINE INDENT if arr [ l ] >= key >= arr [ mid ] : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ mid ] >= key >= arr [ h ] : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findPairs ( A , B ) : NEW_LINE INDENT for i in range ( 1 , B + 1 ) : NEW_LINE INDENT y = A ^ i NEW_LINE if ( y > 0 and ( i y ) == B ) : NEW_LINE INDENT print ( i , " ▁ " , y ) NEW_LINE DEDENT DEDENT DEDENT
def NthComposite ( N ) : NEW_LINE INDENT IsPrime = [ True ] * 1000005 NEW_LINE for p in range ( 2 , 1000005 ) : NEW_LINE INDENT if p * p > 1000005 : NEW_LINE INDENT break NEW_LINE DEDENT if ( IsPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , 1000005 , p ) : NEW_LINE INDENT IsPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT Composites = [ ] NEW_LINE for p in range ( 4 , 1000005 ) : NEW_LINE INDENT if ( not IsPrime [ p ] ) : NEW_LINE INDENT Composites . append ( p ) NEW_LINE DEDENT DEDENT return Composites [ N - 1 ] NEW_LINE DEDENT
def maximumValue ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] + arr [ j ] + i - j ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def maximumValue ( arr , n ) : NEW_LINE INDENT maxvalue = arr [ 0 ] NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = max ( result , maxvalue + arr [ i ] - i ) NEW_LINE maxvalue = max ( maxvalue , arr [ i ] + i ) NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
def productOfTwoPerfectCubes ( N ) : NEW_LINE INDENT cube_root = round ( ( N ) ** ( 1 / 3 ) ) NEW_LINE print ( cube_root ) NEW_LINE if ( cube_root * cube_root * cube_root == N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT DEDENT
def printNumberOfPairs ( N ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT x = i NEW_LINE while ( x <= N ) : NEW_LINE INDENT x *= i NEW_LINE if ( x <= N ) : NEW_LINE INDENT st . add ( x ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( st ) ) NEW_LINE DEDENT
def findCost ( A , N ) : NEW_LINE INDENT totalCost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE totalCost += i NEW_LINE DEDENT DEDENT return totalCost NEW_LINE DEDENT
def minCount ( A , B , N ) : NEW_LINE INDENT i = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return N - i NEW_LINE DEDENT
def checkExists ( arr , N , M , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + M ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if ( count == M * ( K - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def CountPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def numberOfGates ( s ) : NEW_LINE INDENT N = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' . ' or s [ i ] == ' + ' or s [ i ] == '1' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans , end = " " ) NEW_LINE DEDENT
def findPairs ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] = abs ( arr [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE ans = 0 NEW_LINE for right in range ( N ) : NEW_LINE INDENT while ( 2 * arr [ left ] < arr [ right ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT ans += ( right - left ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def CalculateValues ( N ) : NEW_LINE INDENT for C in range ( 0 , N // 7 + 1 ) : NEW_LINE INDENT for B in range ( 0 , N // 5 + 1 ) : NEW_LINE INDENT A = N - 7 * C - 5 * B NEW_LINE if ( A >= 0 and A % 3 == 0 ) : NEW_LINE INDENT print ( " A ▁ = " , A / 3 , " , ▁ B ▁ = " , B , " , ▁ \ ▁ C ▁ = " , C , sep = " ▁ " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT
def mininsert ( arr , K , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT a = min ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE b = max ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE while ( K * a < b ) : NEW_LINE INDENT a *= K NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def sumOfDigits ( s ) : NEW_LINE INDENT curr = 0 NEW_LINE ret = 0 NEW_LINE for ch in s : NEW_LINE INDENT if ( ord ( ch ) >= 48 and ord ( ch ) <= 57 ) : NEW_LINE INDENT curr = curr * 10 + ord ( ch ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT ret += curr NEW_LINE curr = 0 NEW_LINE DEDENT DEDENT ret += curr NEW_LINE return ret NEW_LINE DEDENT
def print_triplet ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] < arr [ i ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( i - 1 , i , i + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def evenproduct ( arr , length ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( length + 1 ) : NEW_LINE INDENT product = 1 ; NEW_LINE for j in range ( i , length + 1 ) : NEW_LINE product *= arr [ j ] ; NEW_LINE if ( product % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT print ( count ) ; NEW_LINE DEDENT
def evenproduct ( arr , length ) : NEW_LINE INDENT total_subarray = length * ( length + 1 ) // 2 NEW_LINE total_odd = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE total_odd += count_odd NEW_LINE DEDENT DEDENT print ( total_subarray - total_odd ) NEW_LINE DEDENT
def countSubstrings ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE subs = 1 NEW_LINE pre = ' ' NEW_LINE for i in s : NEW_LINE INDENT if pre == i : NEW_LINE INDENT subs += 1 NEW_LINE DEDENT else : NEW_LINE INDENT subs = 1 NEW_LINE DEDENT ans += subs NEW_LINE pre = i NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def minimumOperations ( arr , N ) : NEW_LINE INDENT oddCnt = 0 NEW_LINE evenCnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT evenCnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT oddCnt += 1 NEW_LINE DEDENT DEDENT print ( min ( oddCnt , evenCnt ) ) NEW_LINE DEDENT
def minIncr ( arr ) : NEW_LINE INDENT forEven = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if i % 2 : NEW_LINE INDENT if not arr [ i ] % 2 : NEW_LINE INDENT forEven += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ i ] % 2 : NEW_LINE INDENT forEven += 1 NEW_LINE DEDENT DEDENT DEDENT return min ( forEven , len ( arr ) - forEven ) NEW_LINE DEDENT
def KthCharacter ( S , N , K ) : NEW_LINE INDENT strarray = [ char for char in S ] ; NEW_LINE strarray . sort ( ) ; NEW_LINE ch = strarray [ K - 1 ] ; NEW_LINE count = 0 ; NEW_LINE for c in strarray : NEW_LINE INDENT if ( c == ch ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT print ( count ) ; NEW_LINE DEDENT
def findMinLength ( arr , N ) : NEW_LINE INDENT front = 0 NEW_LINE back = N - 1 NEW_LINE while ( front < back ) : NEW_LINE INDENT x = arr [ front ] NEW_LINE if arr [ front ] != arr [ back ] : NEW_LINE INDENT break NEW_LINE DEDENT while ( arr [ front ] == x and front <= back ) : NEW_LINE INDENT front += 1 NEW_LINE DEDENT while ( arr [ back ] == x and front <= back ) : NEW_LINE INDENT back -= 1 NEW_LINE DEDENT DEDENT print ( back - front + 1 ) NEW_LINE DEDENT
def check ( a , n ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i + 1 ] > a [ i ] and a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE if ( check ( arr , N ) != 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def minOperations ( S ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( S [ i ] != S [ i - 1 ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT print ( count ) ; NEW_LINE DEDENT
def mulsum ( arr , n , N ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] % N == 0 : NEW_LINE INDENT sums = sums + arr [ i ] NEW_LINE DEDENT DEDENT print ( sums ) NEW_LINE DEDENT
def getCount ( rows , columns , A ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( i + 1 , rows , 1 ) : NEW_LINE INDENT if ( A [ i ] [ 0 ] * A [ j ] [ 1 ] == A [ i ] [ 1 ] * A [ j ] [ 0 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def minLength ( S , T , N , M ) : NEW_LINE INDENT temp = " " ; NEW_LINE subtract = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp += S [ i ] ; NEW_LINE if ( len ( temp ) >= M ) : NEW_LINE INDENT if ( T == ( temp [ len ( temp ) - M : len ( temp ) ] ) ) : NEW_LINE INDENT subtract += M ; NEW_LINE cnt = 0 ; NEW_LINE while ( cnt != M ) : NEW_LINE INDENT temp = temp [ 0 : len ( temp ) - 1 ] ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ( N - subtract ) ) ; NEW_LINE DEDENT
def Count_numbers ( L , R ) : NEW_LINE INDENT count = ( R - L ) // 2 NEW_LINE if ( R % 2 != 0 or L % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def minimumTime ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE T = max ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( max ( 2 * T , sum ) ) NEW_LINE DEDENT
def CountSubarray ( arr , n , k ) : NEW_LINE INDENT temp = k NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == temp ) : NEW_LINE INDENT if ( temp == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE temp = k NEW_LINE DEDENT else : NEW_LINE INDENT temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = k NEW_LINE if ( arr [ i ] == k ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def minSum ( N ) : NEW_LINE INDENT ans = math . ceil ( 2 * math . sqrt ( N + 1 ) ) NEW_LINE print ( math . trunc ( ans ) ) NEW_LINE DEDENT
def findMinDeletions ( v , n ) : NEW_LINE INDENT minDel = 10 ** 18 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L = v [ i ] [ 0 ] NEW_LINE R = v [ i ] [ 1 ] NEW_LINE Count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( v [ j ] [ 1 ] >= L and v [ j ] [ 0 ] <= R ) : NEW_LINE INDENT Count += 1 NEW_LINE DEDENT DEDENT minDel = min ( minDel , n - Count ) NEW_LINE DEDENT return minDel NEW_LINE DEDENT
def maxEvenIntegers ( arr , N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( 0 , K ) : NEW_LINE INDENT if arr [ i + j ] % 2 == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans = max ( cnt , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countNumbers ( n , d ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = i NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 8 == d ) : NEW_LINE INDENT total += 1 NEW_LINE break NEW_LINE DEDENT x = x // 8 NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE DEDENT
def getcount ( n , k ) : NEW_LINE INDENT res = ( n >> ( k + 1 ) ) << k NEW_LINE if ( ( n >> k ) & 1 ) : NEW_LINE INDENT res += n & ( ( 1 << k ) - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findCntTriplet ( N ) : NEW_LINE INDENT cntTriplet = 0 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( N % i != 0 ) : NEW_LINE INDENT cntTriplet += N // i ; NEW_LINE DEDENT else : NEW_LINE INDENT cntTriplet += ( N // i ) - 1 ; NEW_LINE DEDENT DEDENT return cntTriplet ; NEW_LINE DEDENT
def splitString ( S , N ) : NEW_LINE INDENT c = S [ N - 1 ] NEW_LINE f = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( S [ i ] == c ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def make_string_S_to_T ( S , T ) : NEW_LINE INDENT possible = False NEW_LINE M = len ( T ) NEW_LINE N = len ( S ) NEW_LINE for i in range ( 0 , M + 1 ) : NEW_LINE INDENT prefix_length = i NEW_LINE suffix_length = M - i NEW_LINE prefix = S [ : prefix_length ] NEW_LINE suffix = S [ N - suffix_length : N ] NEW_LINE if ( prefix + suffix == T ) : NEW_LINE INDENT possible = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( possible ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT
def findSum ( a ) : NEW_LINE INDENT ans = 0 NEW_LINE for low in range ( 0 , len ( a ) ) : NEW_LINE INDENT for high in range ( low , len ( a ) ) : NEW_LINE count = 0 NEW_LINE maxNumber = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( a [ i ] == maxNumber ) : NEW_LINE count += 1 NEW_LINE elif ( a [ i ] > maxNumber ) : NEW_LINE maxNumber = a [ i ] NEW_LINE count = 1 NEW_LINE DEDENT if count % 2 : NEW_LINE INDENT ans += maxNumber NEW_LINE DEDENT else : NEW_LINE INDENT ans += maxNumber * 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def minimum_deci_binary_number ( s ) : NEW_LINE INDENT m = - 10 ** 19 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temp = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( temp > m ) : NEW_LINE INDENT m = temp NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT
def minimumReverse ( s , n ) : NEW_LINE INDENT k = 0 ; NEW_LINE l = 0 ; NEW_LINE sum1 = 0 ; NEW_LINE sum0 = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT sum1 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT sum0 += 1 ; NEW_LINE DEDENT if ( s [ i ] == s [ i - 1 ] and s [ i ] == '0' ) : NEW_LINE INDENT k += 1 ; NEW_LINE DEDENT elif ( s [ i ] == s [ i - 1 ] and s [ i ] == '1' ) : NEW_LINE INDENT l += 1 ; NEW_LINE DEDENT DEDENT if ( s [ 0 ] == '1' ) : NEW_LINE INDENT sum1 += 1 ; NEW_LINE sum0 += 1 ; NEW_LINE DEDENT if ( abs ( sum1 - sum0 ) > 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return max ( k , l ) ; NEW_LINE DEDENT
def maxPairs ( nums , k ) : NEW_LINE INDENT nums = sorted ( nums ) NEW_LINE result = 0 NEW_LINE start , end = 0 , len ( nums ) - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( nums [ start ] + nums [ end ] > k ) : NEW_LINE INDENT end -= 1 NEW_LINE DEDENT elif ( nums [ start ] + nums [ end ] < k ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT else : NEW_LINE INDENT start += 1 NEW_LINE end -= 1 NEW_LINE result += 1 NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def maxPairs ( nums , k ) : NEW_LINE INDENT m = { } NEW_LINE result = 0 NEW_LINE for i in nums : NEW_LINE INDENT if ( ( i in m ) and m [ i ] > 0 ) : NEW_LINE INDENT m [ i ] = m [ i ] - 1 NEW_LINE result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if k - i in m : NEW_LINE INDENT m [ k - i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ k - i ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def SmallestString ( s , c ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if s [ i ] > c : NEW_LINE INDENT s = s [ : i ] + c + s [ i : ] NEW_LINE return s NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT s = s + c NEW_LINE return s NEW_LINE DEDENT
def countSubarrays ( A , N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] != A [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE j = i - 1 ; k = i + 2 ; NEW_LINE while ( j >= 0 and k < N and A [ j ] == A [ i ] and A [ k ] == A [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE j -= 1 ; NEW_LINE k += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT
def longestSubsequence ( N , Q , arr , Queries ) : NEW_LINE INDENT for i in range ( Q ) : NEW_LINE INDENT x = Queries [ i ] [ 0 ] NEW_LINE y = Queries [ i ] [ 1 ] NEW_LINE arr [ x - 1 ] = y NEW_LINE count = 1 NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ j ] != arr [ j - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def countString ( S ) : NEW_LINE INDENT count = 0 NEW_LINE for i in S : NEW_LINE INDENT if ( i == '0' and count > 0 ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( ( 1 << count ) - 1 ) NEW_LINE DEDENT
def find_longest_subarray ( A , N , K ) : NEW_LINE INDENT MaxLen = 0 NEW_LINE Len = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( K % A [ i ] == 0 ) : NEW_LINE INDENT Len += 1 NEW_LINE MaxLen = max ( MaxLen , Len ) NEW_LINE DEDENT else : NEW_LINE INDENT Len = 0 NEW_LINE DEDENT DEDENT return MaxLen NEW_LINE DEDENT
def MinDistK ( arr , N , K ) : NEW_LINE INDENT res = sys . maxsize NEW_LINE dist = 0 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT if ( arr [ i ] >= 0 and arr [ i + K - 1 ] >= 0 ) : NEW_LINE INDENT dist = max ( arr [ i ] , arr [ i + K - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dist = ( abs ( arr [ i ] ) + abs ( arr [ i + K - 1 ] ) + min ( abs ( arr [ i ] ) , abs ( arr [ i + K - 1 ] ) ) ) NEW_LINE DEDENT res = min ( res , dist ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSubsequece ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( a [ j ] == a [ l ] and a [ i ] == a [ k ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def checkPointRange ( arr , X , Y , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT dist = sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) NEW_LINE if ( dist <= arr [ i ] [ 2 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def removeOuterParentheses ( S ) : NEW_LINE INDENT res = " " NEW_LINE count = 0 NEW_LINE for c in S : NEW_LINE INDENT if ( c == ' ( ' and count > 0 ) : NEW_LINE INDENT res += c NEW_LINE DEDENT if ( c == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( c == ' ) ' and count > 1 ) : NEW_LINE INDENT res += c NEW_LINE DEDENT if ( c == ' ) ' ) : NEW_LINE count -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSum ( a , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT hm = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ arr [ i ] ] += 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT hm [ arr [ j ] ] += 1 NEW_LINE flag = False NEW_LINE for k in hm . values ( ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not flag ) : NEW_LINE return " No " NEW_LINE DEDENT hm . clear ( ) NEW_LINE DEDENT return " Yes " NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT hm = { } NEW_LINE count = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT hm [ arr [ j ] ] = hm . get ( arr [ j ] , 0 ) + 1 NEW_LINE if ( hm [ arr [ j ] ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( hm [ arr [ j ] ] == 2 ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( count == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def countPairsWithDiffK ( arr , N , K ) : NEW_LINE INDENT vis = [ 0 ] * N NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( vis [ i ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( vis [ j ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( abs ( arr [ i ] - arr [ j ] ) >= K ) : NEW_LINE INDENT count += 1 NEW_LINE vis [ i ] = 1 NEW_LINE vis [ j ] = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def maxiConsecutiveSubarray ( arr , N ) : NEW_LINE INDENT maxi = 0 ; NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE for j in range ( i , N - 1 ) : NEW_LINE INDENT if ( arr [ j + 1 ] == arr [ j ] + 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT maxi = max ( maxi , cnt ) ; NEW_LINE i = j ; NEW_LINE DEDENT return maxi ; NEW_LINE DEDENT
def FindTrip ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N - 1 ) : NEW_LINE INDENT p = arr [ i - 1 ] NEW_LINE q = arr [ i ] NEW_LINE r = arr [ i + 1 ] NEW_LINE if ( p < q and q > r ) : NEW_LINE INDENT print ( i - 1 , i , i + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def find_index ( arr , n , K ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == K : NEW_LINE INDENT return i NEW_LINE DEDENT elif arr [ i ] > K : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def find_index ( arr , n , B ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if arr [ mid ] == K : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < K : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return end + 1 NEW_LINE DEDENT
def printAlter ( arr , N ) : NEW_LINE INDENT for currIndex in range ( 0 , N ) : NEW_LINE INDENT if ( currIndex % 2 == 0 ) : NEW_LINE INDENT print ( arr [ currIndex ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def printAlter ( arr , N ) : NEW_LINE INDENT for currIndex in range ( 0 , N , 2 ) : NEW_LINE INDENT print ( arr [ currIndex ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def numberOfGP ( L , N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT res += count NEW_LINE DEDENT return res NEW_LINE DEDENT
def conVowUpp ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE str1 = " " NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) : NEW_LINE INDENT c = ( str [ i ] ) . upper ( ) NEW_LINE str1 += c NEW_LINE DEDENT else : NEW_LINE INDENT str1 += str [ i ] NEW_LINE DEDENT DEDENT print ( str1 ) NEW_LINE DEDENT
def cntSubarr ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE prefixXor = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT prefixXor = arr [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT prefixXor ^= arr [ j ] NEW_LINE if ( prefixXor == 0 and ( j - i + 1 ) % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def cntSubXor ( arr , N ) : NEW_LINE INDENT prefixXor = 0 ; NEW_LINE Even = [ 0 ] * M ; NEW_LINE Odd = [ 0 ] * M ; NEW_LINE cntSub = 0 ; NEW_LINE Odd [ 0 ] = 1 ; NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT prefixXor ^= arr [ i ] ; NEW_LINE if ( i % 2 == 1 ) : NEW_LINE INDENT cntSub += Odd [ prefixXor ] ; NEW_LINE Odd [ prefixXor ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntSub += Even [ prefixXor ] ; NEW_LINE Even [ prefixXor ] += 1 ; NEW_LINE DEDENT DEDENT return cntSub ; NEW_LINE DEDENT
def minLength ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ 0 ] != arr [ i ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return N NEW_LINE DEDENT
def PrintIndexes ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT currSubSum = 0 NEW_LINE for j in range ( i , N , 1 ) : NEW_LINE INDENT currSubSum += arr [ j ] NEW_LINE sq = int ( math . sqrt ( currSubSum ) ) NEW_LINE if ( sq * sq == currSubSum ) : NEW_LINE INDENT print ( " ( " , i , " , " , j , " ) " , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def productSum ( arr ) : NEW_LINE INDENT cntOne = 0 NEW_LINE N = len ( arr ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT cntOne += 1 NEW_LINE DEDENT DEDENT return cntOne * ( cntOne - 1 ) // 2 NEW_LINE DEDENT
def minCost ( A , B ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE i = 0 ; NEW_LINE maxlen = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT length = 0 ; NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE length += 1 ; NEW_LINE if ( i == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT maxlen = max ( maxlen , length ) ; NEW_LINE DEDENT return n - maxlen ; NEW_LINE DEDENT
def countSubarrays ( a , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE pref = [ ] NEW_LINE pref . append ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pref . append ( ( a [ i ] + pref [ i ] ) % k ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 1 ) : NEW_LINE INDENT if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans , end = ' ▁ ' ) NEW_LINE DEDENT
def EvenLIS ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if abs ( arr [ i ] ) > abs ( arr [ j ] ) and abs ( arr [ i ] % 2 ) == 0 and abs ( arr [ j ] % 2 ) == 0 and lis [ i ] < lis [ j ] + 1 : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maxlen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxlen = max ( maxlen , lis [ i ] ) NEW_LINE DEDENT print ( maxlen ) NEW_LINE DEDENT
def findMinLength ( arr ) : NEW_LINE INDENT index = len ( arr ) - 1 ; NEW_LINE while ( index > 0 and arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index -= 1 ; NEW_LINE DEDENT return index ; NEW_LINE DEDENT
def convertBfromA ( a , b ) : NEW_LINE INDENT moves = 0 NEW_LINE x = abs ( a - b ) NEW_LINE for i in range ( 10 , 0 , - 1 ) : NEW_LINE INDENT moves += x // i NEW_LINE x = x % i NEW_LINE DEDENT print ( moves , end = " ▁ " ) NEW_LINE DEDENT
def smallestNth ( A , B , N ) : NEW_LINE INDENT res = sys . maxsize NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( N , i , - 1 ) : NEW_LINE INDENT if ( ( B - A ) % ( j - i ) == 0 ) : NEW_LINE INDENT D = ( B - A ) // ( j - i ) NEW_LINE FirstTerm = A - ( i - 1 ) * D NEW_LINE NthTerm = FirstTerm + ( N - 1 ) * D NEW_LINE if ( FirstTerm > 0 ) : NEW_LINE INDENT res = min ( res , NthTerm ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def maximumSum ( a , b , n , index , lastpicked ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT option1 = 0 NEW_LINE option2 = 0 NEW_LINE if ( lastpicked == - 1 or a [ lastpicked ] != a [ index ] ) : NEW_LINE INDENT option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) NEW_LINE DEDENT option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) NEW_LINE return max ( option1 , option2 ) NEW_LINE DEDENT
def hIndex ( citations , n ) : NEW_LINE INDENT hindex = 0 NEW_LINE low = 0 NEW_LINE high = n - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( citations [ mid ] >= ( mid + 1 ) ) : NEW_LINE INDENT low = mid + 1 NEW_LINE hindex = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT print ( hindex ) NEW_LINE return hindex NEW_LINE DEDENT
def minOperation ( arr ) : NEW_LINE INDENT minOp = sys . maxsize NEW_LINE minNeg = 0 NEW_LINE maxPos = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT if ( arr [ i ] < minNeg ) : NEW_LINE INDENT minNeg = arr [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ i ] > maxPos : NEW_LINE INDENT maxPos = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return abs ( minNeg ) + maxPos NEW_LINE DEDENT
def checkHex ( s ) : NEW_LINE INDENT for ch in s : NEW_LINE INDENT if ( ( ch < '0' or ch > '9' ) and ( ch < ' A ' or ch > ' F ' ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Yes " ) NEW_LINE DEDENT
def checkArrInStack ( s , arr ) : NEW_LINE INDENT freq = { } NEW_LINE for ele in arr : NEW_LINE INDENT freq [ ele ] = freq . get ( ele , 0 ) + 1 NEW_LINE DEDENT while s : NEW_LINE INDENT poppedEle = s . pop ( ) NEW_LINE if poppedEle in freq : NEW_LINE freq [ poppedEle ] -= 1 NEW_LINE if not freq [ poppedEle ] : NEW_LINE INDENT del freq [ poppedEle ] NEW_LINE DEDENT DEDENT if not freq : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def lenghtOfLongestAP ( A , n ) : NEW_LINE INDENT dp = { } NEW_LINE res = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = A [ j ] - A [ i ] NEW_LINE if d in dp : NEW_LINE INDENT if i in dp [ d ] : NEW_LINE INDENT dp [ d ] [ j ] = dp [ d ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ d ] [ j ] = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ d ] = { } NEW_LINE dp [ d ] [ j ] = 2 NEW_LINE DEDENT if d in dp : NEW_LINE INDENT if j in dp [ d ] : NEW_LINE INDENT res = max ( res , dp [ d ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def isCubeSum ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( pow ( n , 1 / 3 ) ) + 1 ) : NEW_LINE INDENT if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT
def isSumCube ( N ) : NEW_LINE INDENT a = int ( pow ( N , 1 / 3 ) ) NEW_LINE b = a - 1 NEW_LINE ans = ( ( a * a * a + b * b * b ) == N ) NEW_LINE return ans NEW_LINE DEDENT i = 35 NEW_LINE if ( isSumCube ( i ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def checkSumOfNatural ( n ) : NEW_LINE INDENT i = 1 NEW_LINE flag = False NEW_LINE while i * ( i + 1 ) < n * 2 : NEW_LINE INDENT X = i * ( i + 1 ) NEW_LINE t = n * 2 - X NEW_LINE k = int ( math . sqrt ( t ) ) NEW_LINE if k * ( k + 1 ) == t : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if flag : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT
def countNumEnds ( A , L , R ) : NEW_LINE INDENT count = 0 NEW_LINE digits = int ( log10 ( A ) + 1 ) NEW_LINE temp = int ( pow ( 10 , digits ) ) NEW_LINE cycle = temp NEW_LINE while ( temp <= R ) : NEW_LINE INDENT if ( temp >= L ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT temp += cycle NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def minOperations ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE result = 0 NEW_LINE for i in range ( length // 2 ) : NEW_LINE INDENT D1 = ( ord ( max ( s [ i ] , s [ length - 1 - i ] ) ) - ord ( min ( s [ i ] , s [ length - 1 - i ] ) ) ) NEW_LINE D2 = 26 - D1 NEW_LINE result += min ( D1 , D2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def transformSubsequence ( n , m , A , B ) : NEW_LINE INDENT if B is None or len ( B ) == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT dp = [ [ 0 for col in range ( m + 1 ) ] for row in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT elif A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return n - dp [ n ] [ m ] NEW_LINE DEDENT
def MaximumPath ( grid ) : NEW_LINE INDENT N = len ( grid ) NEW_LINE M = len ( grid [ 0 ] ) NEW_LINE sum = [ [ 0 for i in range ( M + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = ( max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return sum [ N ] [ M ] NEW_LINE DEDENT
def right_angled ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for z in range ( 1 , n + 1 ) : NEW_LINE INDENT for y in range ( 1 , z + 1 ) : NEW_LINE INDENT for x in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( ( x * x ) + ( y * y ) == ( z * z ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def mirrorMatrix ( mat1 , mat2 , N ) : NEW_LINE INDENT row = 0 NEW_LINE col = 0 NEW_LINE isMirrorImage = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) : NEW_LINE INDENT isMirrorImage = False NEW_LINE DEDENT col += 1 NEW_LINE DEDENT col = 0 NEW_LINE row += 1 NEW_LINE DEDENT if ( isMirrorImage ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findMinCost ( a , k , n ) : NEW_LINE INDENT max_ele = max ( a ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = sys . maxsize NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq = [ 0 ] * ( max_ele + 1 ) NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT freq [ a [ j ] ] += 1 NEW_LINE cost = 0 NEW_LINE for x in range ( 0 , max_ele + 1 ) : NEW_LINE INDENT cost += ( 0 if ( freq [ x ] == 1 ) else freq [ x ] ) NEW_LINE DEDENT dp [ j + 1 ] = min ( dp [ i ] + cost + k , dp [ j + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def Maxcost ( s , cost ) : NEW_LINE INDENT count = 0 NEW_LINE maxcost = 0 NEW_LINE i = 0 NEW_LINE while i < len ( s ) - 1 : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT if cost [ i ] > cost [ i + 1 ] : NEW_LINE INDENT maxcost += cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT maxcost += cost [ i + 1 ] NEW_LINE cost [ i + 1 ] = cost [ i ] NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return maxcost NEW_LINE DEDENT
def maxSumSubarray ( arr ) : NEW_LINE INDENT i = 0 NEW_LINE j = 1 NEW_LINE set = { } NEW_LINE set [ arr [ 0 ] ] = 1 NEW_LINE sum = arr [ 0 ] NEW_LINE maxsum = sum NEW_LINE while ( i < len ( arr ) - 1 and j < len ( arr ) ) : NEW_LINE INDENT if arr [ j ] not in set : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE maxsum = max ( sum , maxsum ) NEW_LINE set [ arr [ j ] ] = 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE del set [ arr [ i ] ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return maxsum NEW_LINE DEDENT
def findSum ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT sum += ( j - i ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def maxSubarray ( a , k ) : NEW_LINE INDENT n = len ( a ) NEW_LINE answer = 0 NEW_LINE start = 0 NEW_LINE s = 0 NEW_LINE dq = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE while ( len ( dq ) > 0 and a [ dq [ - 1 ] ] <= x ) : NEW_LINE INDENT dq . popleft ( ) NEW_LINE DEDENT dq . append ( i ) NEW_LINE s += x NEW_LINE cost = a [ dq [ 0 ] ] * ( answer + 1 ) - s NEW_LINE if ( cost <= k ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( dq [ 0 ] == start ) : NEW_LINE INDENT dq . popleft ( ) NEW_LINE DEDENT s -= a [ start ] NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def maxGCD ( n ) : NEW_LINE INDENT return ( n // 2 ) ; NEW_LINE DEDENT
def canSplitArray ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= k ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def longestGP ( A , N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT length = 1 NEW_LINE common_ratio = 1 NEW_LINE maxlength = 1 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] % A [ i ] == 0 ) : NEW_LINE INDENT if ( A [ i + 1 ] // A [ i ] == common_ratio ) : NEW_LINE INDENT length = length + 1 NEW_LINE maxlength = max ( maxlength , length ) NEW_LINE DEDENT else : NEW_LINE INDENT common_ratio = A [ i + 1 ] // A [ i ] NEW_LINE length = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxlength = max ( maxlength , length ) NEW_LINE length = 1 NEW_LINE DEDENT DEDENT maxlength = max ( maxlength , length ) NEW_LINE return maxlength NEW_LINE DEDENT
def uncrossedLines ( a , b , n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def minFlips ( mat , s ) : NEW_LINE INDENT N = len ( mat ) NEW_LINE M = len ( mat [ 0 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != ord ( s [ i + j ] ) - ord ( '0' ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def lcmpair ( l , r ) : NEW_LINE INDENT x = l NEW_LINE y = 2 * l NEW_LINE if ( y > r ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " X ▁ = ▁ { } ▁ Y ▁ = ▁ { } " . format ( x , y ) ) NEW_LINE DEDENT DEDENT
def smallSumSubset ( data , target , maxVal ) : NEW_LINE INDENT if target <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif sum ( data ) < target : NEW_LINE INDENT return maxVal NEW_LINE DEDENT elif sum ( data ) == target : NEW_LINE INDENT return len ( data ) NEW_LINE DEDENT elif data [ 0 ] >= target : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif data [ 0 ] < target : NEW_LINE INDENT return min ( smallSumSubset ( data [ 1 : ] ,   \ target , maxVal ) , 1 + smallSumSubset ( data [ 1 : ] ,   \ target - data [ 0 ] , maxVal ) ) NEW_LINE DEDENT DEDENT data = [ 3 , 1 , 7 , 1 , 2 ] NEW_LINE target = 11 NEW_LINE val = smallSumSubset ( data , target , len ( data ) + 1 ) NEW_LINE if val > len ( data ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( val ) NEW_LINE DEDENT
def minServerLoads ( n , servers ) : NEW_LINE INDENT totalLoad = sum ( servers ) NEW_LINE requiredLoad = totalLoad // 2 NEW_LINE dp = [ [ 0 for col in range ( requiredLoad + 1 ) ] for row in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , requiredLoad + 1 ) : NEW_LINE INDENT if servers [ i - 1 ] > j : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return totalLoad - 2 * dp [ n ] [ requiredLoad ] NEW_LINE DEDENT
def maxDiffSubsets ( arr ) : NEW_LINE INDENT totalSum = 0 NEW_LINE pos = False NEW_LINE neg = False NEW_LINE min = sys . maxsize NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT totalSum += abs ( arr [ i ] ) NEW_LINE if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos = True NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg = True NEW_LINE DEDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT if ( pos and neg ) : NEW_LINE INDENT return totalSum NEW_LINE DEDENT else : NEW_LINE INDENT return totalSum - 2 * min NEW_LINE DEDENT DEDENT
def minDiffSubArray ( arr , n ) : NEW_LINE INDENT prefix_sum = [ 0 ] * n NEW_LINE prefix_sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] = ( prefix_sum [ i - 1 ] + arr [ i ] ) NEW_LINE DEDENT suffix_sum = [ 0 ] * n NEW_LINE suffix_sum [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffix_sum [ i ] = ( suffix_sum [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT minDiff = sys . maxsize NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) NEW_LINE if ( diff < minDiff ) : NEW_LINE INDENT minDiff = diff NEW_LINE DEDENT DEDENT return minDiff NEW_LINE DEDENT
def minDiffSubArray ( arr , n ) : NEW_LINE INDENT total_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total_sum += arr [ i ] NEW_LINE DEDENT prefix_sum = 0 NEW_LINE minDiff = sys . maxsize NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT prefix_sum += arr [ i ] NEW_LINE diff = abs ( ( total_sum - prefix_sum ) - prefix_sum ) NEW_LINE if ( diff < minDiff ) : NEW_LINE INDENT minDiff = diff NEW_LINE DEDENT DEDENT return minDiff NEW_LINE DEDENT
def CtSubarr ( arr , N , K ) : NEW_LINE INDENT st = set ( ) NEW_LINE prefixSum = 0 NEW_LINE st . add ( prefixSum ) NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefixSum += arr [ i ] NEW_LINE if ( ( prefixSum - K ) in st ) : NEW_LINE INDENT res += 1 NEW_LINE prefixSum = 0 NEW_LINE st . clear ( ) NEW_LINE st . add ( 0 ) NEW_LINE DEDENT st . add ( prefixSum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def getMaxLength ( arr , N ) : NEW_LINE INDENT res = 2 NEW_LINE dist = 2 NEW_LINE curradj = ( arr [ 1 ] - arr [ 0 ] ) NEW_LINE prevadj = ( arr [ 1 ] - arr [ 0 ] ) NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT curradj = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( curradj == prevadj ) : NEW_LINE INDENT dist += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prevadj = curradj NEW_LINE res = max ( res , dist ) NEW_LINE dist = 2 NEW_LINE DEDENT DEDENT res = max ( res , dist ) NEW_LINE return res NEW_LINE DEDENT
def uniqueElement ( arr ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE flag = 1 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] != x ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findPermutation ( arr , N ) : NEW_LINE INDENT pos = len ( arr ) + 1 NEW_LINE if ( pos > N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i not in arr ) : NEW_LINE INDENT if ( i % pos == 0 or pos % i == 0 ) : NEW_LINE INDENT arr . add ( i ) NEW_LINE res += findPermutation ( arr , N ) NEW_LINE arr . remove ( i ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def minimum_required_operations ( arr , n , k ) : NEW_LINE INDENT answer = 0 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] + arr [ i + 1 ] > k : NEW_LINE INDENT if arr [ i ] > k : NEW_LINE INDENT answer += ( arr [ i ] - k ) NEW_LINE arr [ i ] = k NEW_LINE DEDENT answer += ( arr [ i ] + arr [ i + 1 ] ) - k NEW_LINE arr [ i + 1 ] = ( k - arr [ i ] ) NEW_LINE answer %= mod NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def minSteps ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( k == 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == flag ) : NEW_LINE INDENT cnt += 1 NEW_LINE flag = ( flag + 1 ) % 2 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def solve ( arr , n , X , Y ) : NEW_LINE INDENT diff = Y - X NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT diff = diff % ( arr [ i ] - 1 ) NEW_LINE DEDENT DEDENT if ( diff == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def Numberofways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def getMinOps ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT ans += max ( arr [ i ] - arr [ i + 1 ] , 0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxsubstringLength ( S , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ' a ' or S [ i ] == ' e ' or S [ i ] == ' i ' or S [ i ] == ' o ' or S [ i ] == ' u ' ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT DEDENT maxLen = 0 NEW_LINE curr_sum = 0 NEW_LINE hash = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if ( curr_sum == 0 ) : NEW_LINE INDENT maxLen = max ( maxLen , i + 1 ) NEW_LINE DEDENT if ( curr_sum in hash . keys ( ) ) : NEW_LINE INDENT maxLen = max ( maxLen , i - hash [ curr_sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash [ curr_sum ] = i NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
def largest_subarray ( a , n ) : NEW_LINE INDENT index = defaultdict ( lambda : 0 ) NEW_LINE ans = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = max ( index [ a [ i ] ] , j ) NEW_LINE ans = max ( ans , i - j + 1 ) NEW_LINE index [ a [ i ] ] = i + 1 NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def knapSack ( nums , S ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT sum += nums [ i ] ; NEW_LINE DEDENT if ( sum < S or - sum > - S or ( S + sum ) % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT dp = [ 0 ] * ( ( ( S + sum ) // 2 ) + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE for j in range ( len ( nums ) ) : NEW_LINE INDENT for i in range ( len ( dp ) - 1 , nums [ j ] - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] += dp [ i - nums [ j ] ] ; NEW_LINE DEDENT DEDENT return dp [ len ( dp ) - 1 ] ; NEW_LINE DEDENT
def getMaxSum ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 2 ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = a [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 0 ] NEW_LINE max_sum = max ( dp [ 0 ] [ 0 ] , dp [ 0 ] [ 1 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( a [ i ] , dp [ i - 1 ] [ 0 ] + a [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] + a [ i ] , a [ i ] * a [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] + a [ i ] * a [ i ] ) NEW_LINE max_sum = max ( max_sum , dp [ i ] [ 1 ] ) NEW_LINE max_sum = max ( max_sum , dp [ i ] [ 0 ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
def countSubstrings ( s , n ) : NEW_LINE INDENT count , sum = 0 , 0 NEW_LINE mp = defaultdict ( lambda : 0 ) NEW_LINE mp [ 0 ] += 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE count += mp [ sum - ( i + 1 ) ] NEW_LINE mp [ sum - ( i + 1 ) ] += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def min_operations ( A ) : NEW_LINE INDENT if len ( A ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = A [ 0 ] NEW_LINE for i in range ( 1 , len ( A ) ) : NEW_LINE INDENT if A [ i ] > A [ i - 1 ] : NEW_LINE INDENT ans += A [ i ] - A [ i - 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE y = n + 1 NEW_LINE while ( y <= n * n + n ) : NEW_LINE INDENT if ( ( n * n ) % ( y - n ) == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT y += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT g = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 0 and g == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( arr [ i ] - arr [ i ] < 0 ) : NEW_LINE INDENT g = 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 4 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if ( check ( arr , n ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findMinSum ( A , K ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE minimum_sum = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT minimum = sys . maxsize ; NEW_LINE for j in range ( i + K , n , 1 ) : NEW_LINE INDENT minimum = min ( minimum , A [ j ] ) ; NEW_LINE DEDENT if ( minimum == sys . maxsize ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT minimum_sum = min ( minimum_sum , A [ i ] + minimum ) ; NEW_LINE DEDENT print ( minimum_sum ) ; NEW_LINE DEDENT
def calc_distance ( A , B , n ) : NEW_LINE INDENT distance_traveled_A = 0 NEW_LINE distance_traveled_B = 0 NEW_LINE answer = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT distance_traveled_A += A [ i ] NEW_LINE distance_traveled_B += B [ i ] NEW_LINE if ( ( distance_traveled_A == distance_traveled_B ) and ( A [ i ] == B [ i ] ) ) : NEW_LINE INDENT answer += A [ i ] NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def solve ( n , d , input1 ) : NEW_LINE INDENT a = [ 0 ] * N NEW_LINE cnt = [ 0 ] * ( V + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = input1 [ i ] NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( d ) : NEW_LINE INDENT cnt [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( d , n ) : NEW_LINE INDENT acc = 0 NEW_LINE low_median = - 1 NEW_LINE high_median = - 1 NEW_LINE for v in range ( V + 1 ) : NEW_LINE INDENT acc += cnt [ v ] NEW_LINE if ( low_median == - 1 and acc >= int ( math . floor ( ( d + 1 ) / 2.0 ) ) ) : NEW_LINE INDENT low_median = v NEW_LINE DEDENT if ( high_median == - 1 and acc >= int ( math . ceil ( ( d + 1 ) / 2.0 ) ) ) : NEW_LINE INDENT high_median = v NEW_LINE DEDENT DEDENT double_median = low_median + high_median NEW_LINE if ( a [ i ] >= double_median ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT cnt [ a [ i - d ] ] -= 1 NEW_LINE cnt [ a [ i ] ] += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT
def equalXORandOR ( n ) : NEW_LINE INDENT m = 0 NEW_LINE MSB = int ( log2 ( n ) ) NEW_LINE for i in range ( MSB + 1 ) : NEW_LINE INDENT if ( not ( n & ( 1 << i ) ) ) : NEW_LINE INDENT m += ( 1 << i ) NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT
def findMinSoln ( n , k ) : NEW_LINE INDENT minSoln = sys . maxsize ; NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT minSoln = min ( minSoln , ( n // i ) * k + i ) ; NEW_LINE DEDENT DEDENT return minSoln ; NEW_LINE DEDENT
def dfs ( val , cost , tr , u , s ) : NEW_LINE INDENT global cnt NEW_LINE s = s + cost [ u ] NEW_LINE if ( s < 0 ) : NEW_LINE INDENT s = 0 NEW_LINE DEDENT if ( s > val [ u ] ) : NEW_LINE INDENT return NEW_LINE DEDENT cnt += 1 NEW_LINE for i in range ( 0 , len ( tr [ u ] ) ) : NEW_LINE INDENT dfs ( val , cost , tr , tr [ u ] [ i ] , s ) NEW_LINE DEDENT DEDENT
def ContinuousElements ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] != a [ i - 1 ] ) : NEW_LINE if ( curr == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT curr = 0 NEW_LINE curr += 1 NEW_LINE if ( curr == 1 ) : NEW_LINE return False NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT
def findNewString ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE freq = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] NEW_LINE freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def min_remove ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] - arr [ i ] <= k ) : NEW_LINE INDENT ans = min ( ans , n - j + i - 1 ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT countzeroes = 0 ; NEW_LINE countones = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT countzeroes += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countones += 1 ; NEW_LINE DEDENT DEDENT if ( abs ( countzeroes - countones ) == 1 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def bs ( a , n , ele ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE ch = ' @ ' NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 ; NEW_LINE if ( ar [ mid ] == ele ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT elif ( ar [ mid ] < ele ) : NEW_LINE INDENT ch = ar [ mid ] NEW_LINE start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 ; NEW_LINE DEDENT DEDENT return ch NEW_LINE DEDENT
def countPairs ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == arr [ arr [ i ] - 1 ] - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count // 2 ) NEW_LINE DEDENT
def solve ( A , N ) : NEW_LINE INDENT i = 0 NEW_LINE k = 0 NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT tempK = ( min ( A [ i ] , A [ j ] ) // ( j - i ) ) NEW_LINE if ( tempK > k ) : NEW_LINE INDENT k = tempK NEW_LINE DEDENT if ( A [ j ] >= A [ i ] // ( j - i ) ) : NEW_LINE INDENT i = j NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT
def split ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] == 1 ) : NEW_LINE INDENT count = 2 NEW_LINE break NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def FindPairs ( n , k ) : NEW_LINE INDENT print ( 1 , n ) NEW_LINE k -= 1 NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( 1 , i ) NEW_LINE k -= 1 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i != n // i ) : NEW_LINE INDENT print ( 1 , n // i ) NEW_LINE k -= 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def minOperations ( S , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT zero , one = 0 , 0 NEW_LINE for j in range ( i , len ( S ) , K ) : NEW_LINE INDENT if ( S [ j ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT ans += min ( zero , one ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSubString ( S , C ) : NEW_LINE INDENT count = 0 NEW_LINE conCount = 0 NEW_LINE for ch in S : NEW_LINE INDENT if ( ch == C ) : NEW_LINE INDENT conCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( ( conCount * ( conCount + 1 ) ) // 2 ) NEW_LINE conCount = 0 NEW_LINE DEDENT DEDENT count += ( ( conCount * ( conCount + 1 ) ) // 2 ) NEW_LINE print ( count ) NEW_LINE DEDENT
def findsubArray ( arr , N , K ) : NEW_LINE INDENT res = N + 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT curr_prad = 1 NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT curr_prad = curr_prad * arr [ j ] NEW_LINE if ( curr_prad % N == K and res > ( j - i + 1 ) ) : NEW_LINE INDENT res = min ( res , j - i + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if res == N + 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT
def countTriplets ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE map = defaultdict ( lambda : 0 ) NEW_LINE for j in range ( N - 2 , 0 , - 1 ) : NEW_LINE INDENT map [ A [ j + 1 ] ] += 1 NEW_LINE for i in range ( j ) : NEW_LINE INDENT target = A [ i ] * A [ j ] NEW_LINE if ( target in map . keys ( ) ) : NEW_LINE INDENT ans += map [ target ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def checkrules ( s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if s [ 0 ] != '1' : NEW_LINE INDENT return False NEW_LINE DEDENT if len ( s ) > 2 : NEW_LINE INDENT if s [ 1 ] == '0' and s [ 2 ] == '0' : NEW_LINE INDENT return checkrules ( s [ 3 : ] ) NEW_LINE DEDENT DEDENT return checkrules ( s [ 1 : ] ) NEW_LINE DEDENT
def Maxlen ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def count_elements ( arr ) : NEW_LINE INDENT count = 1 NEW_LINE max = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT count += 1 NEW_LINE max = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def printNum ( L , R ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT temp = i NEW_LINE c = 10 NEW_LINE flag = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 10 >= c ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT c = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def countSub ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE ans = 0 NEW_LINE cnt = 26 * [ 0 ] NEW_LINE i , j = 0 , 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( j < n and ( cnt [ ord ( Str [ j ] ) - ord ( ' a ' ) ] == 0 ) ) : NEW_LINE INDENT cnt [ ord ( Str [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE ans += ( j - i + 1 ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ ord ( Str [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findMaxValue ( N , K ) : NEW_LINE INDENT packages = 0 ; NEW_LINE maxi = 1 ; NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT maxi = max ( maxi , i ) ; NEW_LINE DEDENT DEDENT packages = N // maxi ; NEW_LINE print ( packages ) ; NEW_LINE DEDENT
def solve ( a , n ) : NEW_LINE INDENT mx = - sys . maxsize - 1 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( mx > a [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT mx = max ( mx , a [ j - 1 ] ) NEW_LINE DEDENT return True NEW_LINE DEDENT a = [ 1 , 0 , 2 ] NEW_LINE n = len ( a ) NEW_LINE possible = solve ( a , n ) NEW_LINE if ( possible != 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def maxSide ( a , n ) : NEW_LINE INDENT sideLength = 0 NEW_LINE a . sort NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > sideLength ) : NEW_LINE INDENT sideLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( sideLength ) NEW_LINE DEDENT
def countPairs ( X , Y , m , n ) : NEW_LINE INDENT suffix = [ 0 ] * 1005 NEW_LINE total_pairs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT suffix [ Y [ i ] ] += 1 NEW_LINE DEDENT for i in range ( int ( 1e3 ) , 2 , - 1 ) : NEW_LINE INDENT suffix [ i ] += suffix [ i + 1 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( X [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( X [ i ] == 1 ) : NEW_LINE INDENT total_pairs += suffix [ 0 ] NEW_LINE continue NEW_LINE DEDENT elif ( X [ i ] == 2 ) : NEW_LINE INDENT total_pairs += suffix [ 5 ] NEW_LINE DEDENT elif ( X [ i ] == 3 ) : NEW_LINE INDENT total_pairs += ( suffix [ 2 ] + suffix [ 4 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT total_pairs += suffix [ X [ i ] + 1 ] NEW_LINE DEDENT total_pairs += suffix [ 0 ] + suffix [ 1 ] NEW_LINE DEDENT return total_pairs NEW_LINE DEDENT
def splitArray ( arr , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 10 ** 9 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT result = min ( result , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def findSolutions ( N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( ( i + N // i ) % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( 4 * count ) ; NEW_LINE DEDENT
def findValue ( R , C ) : NEW_LINE INDENT k = ( R * ( R - 1 ) ) // 2 + 1 NEW_LINE diff = R + 1 NEW_LINE for i in range ( 1 , C ) : NEW_LINE INDENT k = ( k + diff ) NEW_LINE diff += 1 NEW_LINE DEDENT return k NEW_LINE DEDENT
def get_subset_count ( arr , K , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE left = 0 ; NEW_LINE right = N - 1 ; NEW_LINE ans = 0 ; NEW_LINE while ( left <= right ) : NEW_LINE INDENT if ( arr [ left ] + arr [ right ] < K ) : NEW_LINE INDENT ans += 1 << ( right - left ) ; NEW_LINE left += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def naive_find_x ( N ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT c += i * i * i NEW_LINE if c >= N : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def binary_searched_find_x ( k ) : NEW_LINE INDENT l = 0 NEW_LINE r = k NEW_LINE ans = 0 NEW_LINE while l <= r : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( ( mid * ( mid + 1 ) ) // 2 ) ** 2 >= k : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def lenOfLongZigZagArr ( a , n ) : NEW_LINE INDENT _max = 1 NEW_LINE _len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if i % 2 == 0 and a [ i ] < a [ i + 1 ] : NEW_LINE INDENT _len += 1 NEW_LINE DEDENT elif i % 2 == 1 and a [ i ] > a [ i + 1 ] : NEW_LINE INDENT _len += 1 NEW_LINE DEDENT else : NEW_LINE DEDENT if _max < _len : NEW_LINE INDENT _max = _len NEW_LINE DEDENT _len = 1 NEW_LINE if _max < _len : NEW_LINE INDENT _max = _len NEW_LINE DEDENT return _max NEW_LINE DEDENT
def findColumn ( mat : list ) : NEW_LINE INDENT row = 0 NEW_LINE col = M - 1 NEW_LINE while row < N and col >= 0 : NEW_LINE INDENT if mat [ row ] [ col ] == 1 : NEW_LINE INDENT col -= 1 NEW_LINE flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT row += 1 NEW_LINE DEDENT DEDENT col += 1 NEW_LINE if flag : NEW_LINE INDENT return col + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def minMaxDiff ( arr , n , k ) : NEW_LINE INDENT max_adj_dif = float ( ' - inf ' ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT max_adj_dif = max ( max_adj_dif , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; NEW_LINE DEDENT if ( max_adj_dif == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT best = 1 ; NEW_LINE worst = max_adj_dif ; NEW_LINE while ( best < worst ) : NEW_LINE INDENT mid = ( best + worst ) // 2 ; NEW_LINE required = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT required += ( abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) // mid NEW_LINE DEDENT if ( required > k ) : NEW_LINE INDENT best = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT worst = mid NEW_LINE DEDENT DEDENT return worst NEW_LINE DEDENT
def findNumbers ( N , M ) : NEW_LINE INDENT m = M NEW_LINE remLen = { } NEW_LINE for len1 in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT remainder = M % N NEW_LINE if ( remLen . get ( remainder ) == None ) : NEW_LINE INDENT remLen [ remainder ] = len1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT M = M * 10 + m NEW_LINE M = M % N NEW_LINE DEDENT LenA = len1 NEW_LINE LenB = remLen [ remainder ] NEW_LINE for i in range ( LenB ) : NEW_LINE INDENT print ( m , end = " " ) NEW_LINE DEDENT print ( " ▁ " , end = " " ) NEW_LINE for i in range ( LenA ) : NEW_LINE INDENT print ( m , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def countTriplets ( a , n , x ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE temp . append ( a [ i ] ) NEW_LINE temp . append ( a [ j ] ) NEW_LINE temp . append ( a [ k ] ) NEW_LINE temp . sort ( ) NEW_LINE if ( temp [ 0 ] < temp [ 1 ] and temp [ 1 ] < temp [ 2 ] and temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def FindRank ( arr , length ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT rank = rank + 1 NEW_LINE DEDENT DEDENT print ( rank , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def xorOfSum ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT answer ^= ( a [ i ] + a [ j ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def permutation ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxEle = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( s ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def getPositionCount ( a , n ) : NEW_LINE INDENT count = 1 ; NEW_LINE min = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] <= min ) : NEW_LINE INDENT min = a [ i ] ; NEW_LINE count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def CountSubSet ( arr , n , X ) : NEW_LINE INDENT N = 2 ** n ; NEW_LINE count = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( arr [ j ] == X ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) ; NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def canBeBalanced ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE count_1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT count_1 = min ( count_1 , count ) NEW_LINE DEDENT if ( count_1 >= - 1 and count == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT s = " ( ) ) ( ) ( " NEW_LINE n = len ( s ) NEW_LINE if ( canBeBalanced ( s , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def sentinelSearch ( arr , n , key ) : NEW_LINE INDENT last = arr [ n - 1 ] NEW_LINE arr [ n - 1 ] = key NEW_LINE i = 0 NEW_LINE while ( arr [ i ] != key ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT arr [ n - 1 ] = last NEW_LINE if ( ( i < n - 1 ) or ( arr [ n - 1 ] == key ) ) : NEW_LINE INDENT print ( key , " is ▁ present ▁ at ▁ index " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ Not ▁ found " ) NEW_LINE DEDENT DEDENT
def insertNames ( arr , n ) : NEW_LINE INDENT string = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in string : NEW_LINE INDENT print ( " No " ) ; NEW_LINE string . add ( arr [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT DEDENT DEDENT
def containsElement ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = xorArr ^ arr [ i ] NEW_LINE if ( arr [ i ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 8 , 2 , 4 , 15 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if ( containsElement ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def length_substring ( S , K ) : NEW_LINE INDENT curr_cnt = 0 NEW_LINE prev_cnt = 0 NEW_LINE max_len = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT if ( S [ i ] == K ) : NEW_LINE INDENT curr_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prev_cnt = max ( prev_cnt , curr_cnt ) NEW_LINE curr_cnt = 0 NEW_LINE DEDENT DEDENT prev_cnt = max ( prev_cnt , curr_cnt ) NEW_LINE max_len = prev_cnt NEW_LINE return max_len NEW_LINE DEDENT
def LeftRightNode ( preorder , n ) : NEW_LINE INDENT min = 10 ** 9 NEW_LINE max = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min > preorder [ i ] ) : NEW_LINE INDENT min = preorder [ i ] NEW_LINE DEDENT if ( max < preorder [ i ] ) : NEW_LINE INDENT max = preorder [ i ] NEW_LINE DEDENT DEDENT print ( " Leftmost ▁ node ▁ is ▁ " , min ) NEW_LINE print ( " Rightmost ▁ node ▁ is ▁ " , max ) NEW_LINE DEDENT
def distinct ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE if len ( arr ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 0 , len ( arr ) - 1 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT elif ( i > 0 & i < len ( arr ) - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] or arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( arr [ len ( arr ) - 1 ] != arr [ len ( arr ) - 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT matched = True ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] != arr [ j ] ) : NEW_LINE INDENT matched = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( matched ) : NEW_LINE INDENT return i + 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
def maximum_middle_value ( n , k , arr ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT ans = max ( ans , arr [ i - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def firstRepeating ( string ) : NEW_LINE INDENT visited = [ False ] * NO_OF_CHARS ; NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT visited [ i ] = False ; NEW_LINE DEDENT res = - 1 ; NEW_LINE for i in range ( len ( string ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( visited [ string . index ( string [ i ] ) ] == False ) : NEW_LINE INDENT visited [ string . index ( string [ i ] ) ] = True ; NEW_LINE DEDENT else : NEW_LINE INDENT res = i ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
def maxSumArray ( arr , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE mp = { i : 0 for i in range ( 4 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += arr [ i ] NEW_LINE mp [ arr [ i ] ] += 1 NEW_LINE DEDENT minimum = maxsize NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( key == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT minimum = min ( minimum , value * key ) NEW_LINE DEDENT return ( sum1 - minimum ) NEW_LINE DEDENT
def MinimumX ( a , b , c , k ) : NEW_LINE INDENT x = 10 ** 9 NEW_LINE if ( k <= c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = k - c NEW_LINE l = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) : NEW_LINE INDENT x = min ( x , m ) NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( ( a * m * m ) + ( b * m ) < ( k - c ) ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def findMissing ( arr , n ) : NEW_LINE INDENT l , h = 0 , n - 1 NEW_LINE mid = 0 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = l + ( h - l ) // 2 NEW_LINE if ( arr [ mid ] - mid == arr [ 0 ] ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT return arr [ mid ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxSum ( arr , n , K ) : NEW_LINE INDENT maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sumk = 0 NEW_LINE for j in range ( i , n , K ) : NEW_LINE INDENT sumk = sumk + arr [ j ] NEW_LINE DEDENT maximum = max ( maximum , sumk ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - leftGreater ) NEW_LINE DEDENT
def countPairs ( s1 , n1 , s2 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * 26 ; NEW_LINE freq2 = [ 0 ] * 26 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT count += min ( freq1 [ i ] , freq2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def findpair ( l , r ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , " , ▁ " , j ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def findpair ( l , r ) : NEW_LINE INDENT ans1 = l NEW_LINE ans2 = 2 * l NEW_LINE print ( ans1 , " , ▁ " , ans2 ) NEW_LINE DEDENT
def minIndex ( arr , n , pos ) : NEW_LINE INDENT num = arr [ pos ] NEW_LINE i = pos - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] != num ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return i + 1 NEW_LINE DEDENT
def strScore ( string , s , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ string [ i ] ] = i + 1 NEW_LINE DEDENT if s not in m . keys ( ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT score = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT score += ord ( s [ i ] ) - ord ( ' a ' ) + 1 NEW_LINE DEDENT score = score * m [ s ] NEW_LINE return score NEW_LINE DEDENT
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def max_min ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) NEW_LINE DEDENT
def findMinDifference ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff1 = arr [ n - 1 ] - arr [ 1 ] NEW_LINE diff2 = arr [ n - 2 ] - arr [ 0 ] NEW_LINE return min ( diff1 , diff2 ) NEW_LINE DEDENT
def minimal ( a , n ) : NEW_LINE INDENT lo , hi = 0 , n - 1 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if a [ mid ] < a [ mid + 1 ] : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT return lo NEW_LINE return lo NEW_LINE DEDENT DEDENT
def LowerInsertionPoint ( arr , n , X ) : NEW_LINE INDENT if ( X < arr [ 0 ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( X > arr [ n - 1 ] ) : NEW_LINE INDENT return n NEW_LINE DEDENT lowerPnt = 0 NEW_LINE i = 1 NEW_LINE while ( i < n and arr [ i ] < X ) : NEW_LINE INDENT lowerPnt = i NEW_LINE i = i * 2 NEW_LINE DEDENT while ( lowerPnt < n and arr [ lowerPnt ] < X ) : NEW_LINE INDENT lowerPnt += 1 NEW_LINE DEDENT return lowerPnt NEW_LINE DEDENT
def minIndex ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( 2 * arr [ i ] == sum ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def smallest_pair ( a , n ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE secondMin = sys . maxsize NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( a [ j ] < min ) : NEW_LINE INDENT secondMin = min NEW_LINE min = a [ j ] NEW_LINE DEDENT elif ( ( a [ j ] < secondMin ) and a [ j ] != min ) : NEW_LINE INDENT secondMin = a [ j ] NEW_LINE DEDENT DEDENT return ( secondMin + min ) NEW_LINE DEDENT
def checkSorted ( n , arr ) : NEW_LINE INDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( arr [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE ct = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != b [ i ] : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT if ct == 0 or ct == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def printIntersection ( A , B ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( A [ i ] [ j ] == B [ i ] [ j ] ) : NEW_LINE INDENT print ( A [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def checkIndices ( Arr , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( Arr [ i ] != Arr [ j ] ) : NEW_LINE INDENT if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT count = 1 NEW_LINE max_lenght = 1 NEW_LINE prev_mod = arr [ 0 ] % k NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_mod = arr [ i ] % k NEW_LINE if curr_mod == prev_mod : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_lenght = max ( max_lenght , count ) NEW_LINE count = 1 NEW_LINE prev_mod = curr_mod NEW_LINE DEDENT DEDENT return max ( max_lenght , count ) NEW_LINE DEDENT
def longestsubarray ( arr , n , k ) : NEW_LINE INDENT current_count = 0 NEW_LINE max_count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT current_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_count = 0 NEW_LINE DEDENT max_count = max ( current_count , max_count ) NEW_LINE DEDENT return max_count NEW_LINE DEDENT
def countSegments ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT flag = False NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = " xzyyz " NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def numberOfElements ( height , n ) : NEW_LINE INDENT max_so_far = 0 NEW_LINE coun = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if height [ i ] > max_so_far : NEW_LINE INDENT max_so_far = height [ i ] NEW_LINE coun = coun + 1 NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT
def count_triples ( n , k ) : NEW_LINE INDENT count , i , j , l = 0 , 0 , 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for l in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i + j ) % k == 0 and ( i + l ) % k == 0 and ( j + l ) % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if i != j and abs ( arr [ i ] - arr [ j ] ) <= k : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == n : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countEle ( s , a , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT num = a [ i ] NEW_LINE if num in mp : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE while s [ - 1 ] != num : NEW_LINE INDENT mp [ s . pop ( ) ] = True NEW_LINE cnt += 1 NEW_LINE DEDENT s . pop ( ) NEW_LINE cnt += 1 NEW_LINE print ( cnt , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def colMaxDiff ( mat ) : NEW_LINE INDENT max_diff = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_val = mat [ 0 ] [ i ] NEW_LINE min_val = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT max_val = max ( max_val , mat [ j ] [ i ] ) NEW_LINE min_val = min ( min_val , mat [ j ] [ i ] ) NEW_LINE DEDENT max_diff = max ( max_diff , max_val - min_val ) NEW_LINE DEDENT return max_diff NEW_LINE DEDENT
def countChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT count = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def search ( ar , size ) : NEW_LINE INDENT a = 0 NEW_LINE b = size - 1 NEW_LINE mid = 0 NEW_LINE while b > a + 1 : NEW_LINE INDENT mid = ( a + b ) // 2 NEW_LINE if ( ar [ a ] - a ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT b = mid NEW_LINE DEDENT elif ( ar [ b ] - b ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT a = mid NEW_LINE DEDENT DEDENT return ar [ a ] + 1 NEW_LINE DEDENT
def next ( arr , target ) : NEW_LINE INDENT start = 0 ; NEW_LINE end = len ( arr ) - 1 ; NEW_LINE ans = - 1 ; NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 ; NEW_LINE if ( arr [ mid ] <= target ) : NEW_LINE INDENT start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid ; NEW_LINE end = mid - 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def printNSE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + " ▁ - - ▁ " + str ( next ) ) NEW_LINE DEDENT DEDENT
def deleteElement ( A , L , R , N ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i <= L or i >= R : NEW_LINE INDENT A [ j ] = A [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( x == arr [ i ] ) : NEW_LINE INDENT res = i NEW_LINE DEDENT DEDENT if ( res == - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = arr [ res ] NEW_LINE i = res NEW_LINE while ( i > 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ 0 ] = temp NEW_LINE return True NEW_LINE DEDENT
def majorityNumber ( nums ) : NEW_LINE INDENT num_count = { } NEW_LINE for num in nums : NEW_LINE INDENT if num in num_count : NEW_LINE INDENT num_count [ num ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_count [ num ] = 1 NEW_LINE DEDENT DEDENT for num in num_count : NEW_LINE INDENT if num_count [ num ] > len ( nums ) / 2 : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = a . count ( k ) NEW_LINE return round ( count / n , 2 ) NEW_LINE DEDENT
def slopeOfNum ( num , n ) : NEW_LINE INDENT slope = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( num [ i ] > num [ i - 1 ] and num [ i ] > num [ i + 1 ] ) : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT elif ( num [ i ] < num [ i - 1 ] and num [ i ] < num [ i + 1 ] ) : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT DEDENT return slope NEW_LINE DEDENT
def pairExists ( arr1 : List [ int ] , m : int , arr2 : List [ int ] , n : int ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( arr2 [ 2 ] - arr1 [ 2 ] ) not in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT s . add ( arr1 [ i ] ) NEW_LINE DEDENT return False NEW_LINE DEDENT
def prevGreater ( arr , n ) : NEW_LINE INDENT print ( " - 1" , end = " , ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT print ( arr [ j ] , end = " , ▁ " ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 0 and flag == 0 : NEW_LINE INDENT print ( " - 1" , end = " , ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def prevGreater ( arr , n ) : NEW_LINE INDENT s = list ( ) ; NEW_LINE s . append ( arr [ 0 ] ) NEW_LINE print ( " - 1 , ▁ " , end = " " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and s [ - 1 ] < arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if len ( s ) == 0 : NEW_LINE INDENT print ( " - 1 , ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ - 1 ] , " , ▁ " , end = " " ) NEW_LINE DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT fl = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] >= n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] < 2 * n ) : NEW_LINE INDENT print ( arr [ i ] % n , end = " ▁ " ) NEW_LINE fl = 1 ; NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n ; NEW_LINE DEDENT if ( fl == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def findTriplets ( arr , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) : NEW_LINE INDENT print ( arr [ i ] , " ▁ " , arr [ j ] , " ▁ " , arr [ k ] , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def findTriplets ( arr , n , Sum ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = Sum - ( arr [ i ] + arr [ j ] ) NEW_LINE if x in s . keys ( ) : NEW_LINE INDENT print ( x , arr [ i ] , arr [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s [ arr [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def printPairs ( arr , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == sum ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def solve ( a , n ) : NEW_LINE INDENT max1 = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( abs ( a [ i ] - a [ j ] ) > max1 ) : NEW_LINE INDENT max1 = abs ( a [ i ] - a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return max1 NEW_LINE DEDENT
def solve ( a , n ) : NEW_LINE INDENT min1 = a [ 0 ] NEW_LINE max1 = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max1 ) : NEW_LINE INDENT max1 = a [ i ] NEW_LINE DEDENT if ( a [ i ] < min1 ) : NEW_LINE INDENT min1 = a [ i ] NEW_LINE DEDENT DEDENT return abs ( min1 - max1 ) NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT max_product = - sys . maxsize ; NEW_LINE for i in range ( n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return max_product ; NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE max = maxProduct ( arr , n ) ; NEW_LINE if ( max == - 1 ) : NEW_LINE INDENT print ( " No ▁ Quadruple ▁ Exists " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Maximum ▁ product ▁ is " , max ) ; NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE x = ( arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ) NEW_LINE y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] NEW_LINE z = ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ) NEW_LINE return max ( x , max ( y , z ) ) NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countTripletsLessThanL ( n , L , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ways = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT mostDistantDistance = arr [ k ] - arr [ i ] NEW_LINE if ( mostDistantDistance <= L ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ways NEW_LINE DEDENT
def isSuffix ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if ( n1 > n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ ' ▁ ' ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def checkIfAllTogether ( s , c ) : NEW_LINE INDENT oneSeen = False NEW_LINE i = 0 NEW_LINE n = len ( s ) NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT if ( oneSeen == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i < n and s [ i ] == c ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = "110029" ; NEW_LINE if ( checkIfAllTogether ( s , '1' ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 ; back = n - 1 NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] NEW_LINE x = 130 NEW_LINE n = len ( arr ) NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def sortString ( st , n ) : NEW_LINE INDENT arr = [ 0 ] * 26 NEW_LINE new_str = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( st [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT while ( arr [ i ] > 0 ) : NEW_LINE INDENT new_str += chr ( i + ord ( ' a ' ) ) NEW_LINE arr [ i ] -= 1 NEW_LINE DEDENT DEDENT return new_str NEW_LINE DEDENT
def getGreatestSum ( a ) : NEW_LINE INDENT prev_max = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( prev_max < a [ N - 1 ] [ j ] ) : NEW_LINE INDENT prev_max = a [ N - 1 ] [ j ] NEW_LINE DEDENT DEDENT sum = prev_max NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT curr_max = - 2147483648 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( prev_max > a [ i ] [ j ] and a [ i ] [ j ] > curr_max ) : NEW_LINE INDENT curr_max = a [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( curr_max == - 2147483648 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev_max = curr_max NEW_LINE sum = sum + prev_max NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT j = i NEW_LINE while j < n and arr [ j ] <= arr [ j - 1 ] : NEW_LINE INDENT arr [ j ] = arr [ j ] + 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] ; prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] <= prev : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE x = ' e ' NEW_LINE index = findLastIndex ( str , x ) NEW_LINE if index == - 1 : NEW_LINE INDENT print ( " Character ▁ not ▁ found " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Last ▁ index ▁ is ' , index ) NEW_LINE DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE x = ' e ' NEW_LINE index = findLastIndex ( str , x ) NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT print ( " Character ▁ not ▁ found " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Last ▁ index ▁ is ▁ " , index ) NEW_LINE DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT if ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT if ( b > c ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( a > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a > c ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( b > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if x * y > 0 : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( x * z > 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def findValue ( X , Y , P ) : NEW_LINE INDENT if P % 2 == 0 : NEW_LINE INDENT return int ( max ( X , Y ) / min ( X , Y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return int ( max ( 2 * X , Y ) / min ( 2 * X , Y ) ) NEW_LINE DEDENT DEDENT
def countCountries ( ans , N ) : NEW_LINE INDENT total_countries = 0 NEW_LINE i = 0 NEW_LINE invalid = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT curr_size = ans [ i ] NEW_LINE num = ans [ i ] NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( ans [ i ] != curr_size ) : NEW_LINE INDENT print ( " Invalid ▁ Answer " ) NEW_LINE return ; NEW_LINE DEDENT else : NEW_LINE INDENT num = num - 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT total_countries = total_countries + 1 ; NEW_LINE DEDENT print ( " There ▁ are ▁ " , total_countries , " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . " ) NEW_LINE DEDENT
def countMaxSetBits ( left , right ) : NEW_LINE INDENT while ( left | ( left + 1 ) ) <= right : NEW_LINE INDENT left |= left + 1 NEW_LINE DEDENT return left NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = 15 NEW_LINE n = findS ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( s / 2 ) + 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = int ( ( l + r ) / 2 ) NEW_LINE sum = int ( mid * ( mid + 1 ) / 2 ) NEW_LINE if ( sum == s ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( sum > s ) : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT s = 15 NEW_LINE n = findS ( s ) NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
def isvalid ( s ) : NEW_LINE INDENT k = ( - 1 + math . sqrt ( 1 + 8 * s ) ) / 2 NEW_LINE if ( math . ceil ( k ) == math . floor ( k ) ) : NEW_LINE INDENT return int ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def calcSafe ( pos ) : NEW_LINE INDENT j = pos % 10 NEW_LINE i = pos / 10 NEW_LINE dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) NEW_LINE dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) NEW_LINE dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) NEW_LINE dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) NEW_LINE sum = ( dis_11 + dis_18 + dis_81 + dis_88 + 1 ) NEW_LINE return ( 64 - sum ) NEW_LINE DEDENT
def countCrossLine ( arr , n ) : NEW_LINE INDENT count_crossline = 0 ; NEW_LINE i , key , j = 0 , 0 , 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT key = arr [ i ] ; NEW_LINE j = i - 1 ; NEW_LINE while ( j >= 0 and arr [ j ] > key ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] ; NEW_LINE j = j - 1 ; NEW_LINE count_crossline += 1 ; NEW_LINE DEDENT arr [ j + 1 ] = key ; NEW_LINE DEDENT return count_crossline ; NEW_LINE DEDENT
def missing4 ( arr ) : NEW_LINE INDENT helper = [ 0 ] * 4 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT temp = abs ( arr [ i ] ) NEW_LINE if ( temp <= len ( arr ) ) : NEW_LINE INDENT arr [ temp - 1 ] = arr [ temp - 1 ] * ( - 1 ) NEW_LINE DEDENT elif ( temp > len ( arr ) ) : NEW_LINE INDENT if ( temp % len ( arr ) ) : NEW_LINE INDENT helper [ temp % len ( arr ) - 1 ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT helper [ ( temp % len ( arr ) ) + len ( arr ) - 1 ] = - 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT print ( ( i + 1 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( helper ) ) : NEW_LINE INDENT if ( helper [ i ] >= 0 ) : NEW_LINE INDENT print ( ( len ( arr ) + i + 1 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] == num2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT
def minTotalDistance ( grid : list ) : NEW_LINE INDENT if ROW == 0 or COL == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT vertical = [ ] NEW_LINE horizontal = [ ] NEW_LINE for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT vertical . append ( i ) NEW_LINE horizontal . append ( j ) NEW_LINE DEDENT DEDENT DEDENT vertical . sort ( ) NEW_LINE horizontal . sort ( ) NEW_LINE size = len ( vertical ) // 2 NEW_LINE x = vertical [ size ] NEW_LINE y = horizontal [ size ] NEW_LINE distance = 0 NEW_LINE for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT distance += abs ( x - i ) + abs ( y - j ) NEW_LINE DEDENT DEDENT DEDENT return distance NEW_LINE DEDENT
def findMinRec ( A , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT return min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) NEW_LINE DEDENT
def findMaxRec ( A , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT return max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) NEW_LINE DEDENT
def countBuildings ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > curr_max or arr [ i ] == curr_max ) : NEW_LINE INDENT count += 1 NEW_LINE curr_max = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( int ) ( ( left + right ) / 2 ) NEW_LINE if ( arr2 [ mid ] == arr1 [ mid ] ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def minCostToMakeElementEqual ( a ) : NEW_LINE INDENT l = len ( a ) NEW_LINE if ( l % 2 == 1 ) : NEW_LINE INDENT y = a [ l // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT y = ( a [ l // 2 ] + a [ ( l - 2 ) // 2 ] ) // 2 NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT s += abs ( a [ i ] - y ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def maxConsecutiveRopes ( ropes , N ) : NEW_LINE INDENT curSize = 0 NEW_LINE ropes = sorted ( ropes ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( ropes [ i ] <= curSize + 1 ) : NEW_LINE INDENT curSize = curSize + ropes [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return curSize NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE index = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] >= arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( count > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( count == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( index == n - 1 or index == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ index - 1 ] < arr [ index + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ index - 2 ] < arr [ index ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isSortedArray ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = ( n - 1 ) NEW_LINE while ( ( l + 1 ) < r ) : NEW_LINE INDENT if ( arr [ l ] >= max ( arr [ l + 1 ] , arr [ r - 1 ] ) and arr [ r ] >= max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def mincost ( arr , N , X ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE cost = 0 NEW_LINE min_cost = sys . maxsize NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT cost = abs ( arr [ i ] ) * x + ( sum - abs ( arr [ i ] ) * i ) NEW_LINE sum += abs ( arr [ i ] ) NEW_LINE min_cost = min ( min_cost , cost ) NEW_LINE DEDENT DEDENT return min_cost NEW_LINE DEDENT
def maximumSum ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( ) NEW_LINE sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; NEW_LINE print ( sum ) NEW_LINE DEDENT
def getBuckets ( arr , N ) : NEW_LINE INDENT availableWater = N * ( N - 1 ) // 2 NEW_LINE arr . sort ( ) NEW_LINE i , Sum = 0 , 0 NEW_LINE while ( Sum <= availableWater ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT print ( i - 1 , end = " " ) NEW_LINE DEDENT
def minimum_sum ( A , N ) : NEW_LINE INDENT A . sort ( reverse = False ) NEW_LINE sum = sys . maxsize NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT sum = min ( sum , abs ( A [ i ] - A [ i + 1 ] ) + abs ( A [ i + 1 ] - A [ i + 2 ] ) ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def maximumSumPermutation ( arr ) : NEW_LINE INDENT N = len ( arr ) ; NEW_LINE arr . sort ( ) ; NEW_LINE temp = arr [ 0 ] ; NEW_LINE arr [ 0 ] = arr [ N - 1 ] ; NEW_LINE arr [ N - 1 ] = temp ; NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def findMaxNumbers ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT opr = math . ceil ( math . log2 ( arr [ i ] ) ) NEW_LINE k -= opr NEW_LINE if ( k < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT
def sameChar ( S , N ) : NEW_LINE INDENT S = ' ' . join ( sorted ( S ) ) NEW_LINE mid = ord ( S [ N // 2 ] ) NEW_LINE total_operations = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT total_operations += abs ( ord ( S [ i ] ) - mid ) NEW_LINE DEDENT print ( total_operations ) NEW_LINE DEDENT
def minimumIncreasingSubsequences ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freqX = 0 NEW_LINE while ( i < N and arr [ i ] == x ) : NEW_LINE INDENT freqX += 1 NEW_LINE i += 1 NEW_LINE DEDENT count = max ( count , freqX ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def findLastElement ( arr , N ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != 0 \ and arr [ i ] - arr [ i - 1 ] != 2 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( arr [ N - 1 ] ) ; NEW_LINE DEDENT
def maxDivisions ( arr , N , X ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE maxSub = 0 ; NEW_LINE size = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT size += 1 ; NEW_LINE if ( arr [ i ] * size >= X ) : NEW_LINE INDENT maxSub += 1 ; NEW_LINE size = 0 ; NEW_LINE DEDENT DEDENT print ( maxSub ) ; NEW_LINE DEDENT
def meanOfRemainingElements ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE kthPercent = ( N * K ) / 100 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i >= kthPercent and i < ( N - kthPercent ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT mean = sum / ( N - 2 * kthPercent ) NEW_LINE print ( ' % .5f ' % mean ) NEW_LINE DEDENT
def getcount ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for b in range ( 0 , N ) : NEW_LINE INDENT for a in range ( 0 , N ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT continue NEW_LINE DEDENT for c in range ( 0 , N ) : NEW_LINE INDENT if ( c == a or c == b ) : NEW_LINE INDENT continue NEW_LINE DEDENT d = arr [ b ] * arr [ b ] // 4 NEW_LINE if ( arr [ a ] * arr ) <= d : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def maxPossibleSum ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE j = N - 3 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE j -= 3 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def findMaxDifference ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE Leftsum = 0 NEW_LINE Totalsum = 0 NEW_LINE Min , Max = 10 ** 8 , - 10 ** 8 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Totalsum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT leftNumbers = i NEW_LINE rightNumbers = n - i - 1 NEW_LINE Totalsum = Totalsum - arr [ i ] NEW_LINE sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) NEW_LINE Min = min ( Min , sum ) NEW_LINE Max = max ( Max , sum ) NEW_LINE Leftsum += arr [ i ] NEW_LINE DEDENT print ( Max - Min ) NEW_LINE DEDENT
def check ( a , b , Na , Nb , k , m ) : NEW_LINE INDENT if ( Na < k or Nb < m ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT a . sort ( ) NEW_LINE a . sort ( ) NEW_LINE if ( a [ k - 1 ] < b [ Nb - m ] ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
def splitArray ( arr , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 10 ** 9 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT result = min ( result , arr [ i ] ^ arr [ i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def CountMaximum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def rearrange ( A , B , N , X ) : NEW_LINE INDENT flag = True NEW_LINE A = sorted ( A ) NEW_LINE B = sorted ( B ) [ : : - 1 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] + B [ i ] > X ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findSum ( A , N , K ) : NEW_LINE INDENT A . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( N // K , N , K - 1 ) : NEW_LINE INDENT sum += A [ i ] ; NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT
def maxcntPairsSumKRemoved ( arr , k ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE if not arr or len ( arr ) == 1 : NEW_LINE INDENT return cntPairs NEW_LINE DEDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE right = len ( arr ) - 1 NEW_LINE while left < right : NEW_LINE INDENT s = arr [ left ] + arr [ right ] NEW_LINE if s == k : NEW_LINE INDENT cntPairs += 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT elif s > k : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT left += 1 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT
def minDiff ( A , K ) : NEW_LINE INDENT A . sort ( ) ; NEW_LINE n = len ( A ) ; NEW_LINE if ( n <= K ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT mindiff = A [ n - 1 ] - A [ 0 ] ; NEW_LINE if ( K == 0 ) : NEW_LINE INDENT return mindiff ; NEW_LINE DEDENT i = 0 ; NEW_LINE for j in range ( n - 1 - K , n ) : NEW_LINE INDENT mindiff = min ( mindiff , A [ j ] - A [ i ] ) ; NEW_LINE i += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT return mindiff ; NEW_LINE DEDENT
def findMinimum ( arr , N , K ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , 2 * ( N // K ) , 2 ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findSubarrays ( arr , N ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( " NO " ) ; NEW_LINE DEDENT
def getPairs ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] > K * arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def Selection_Sort ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT min_index = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ min_index ] ) : NEW_LINE INDENT min_index = j NEW_LINE DEDENT DEDENT arr [ i ] , arr [ min_index ] = arr [ min_index ] , arr [ i ] NEW_LINE DEDENT DEDENT n = 5 NEW_LINE arr = [ 2 , 0 , 1 , 4 , 3 ] NEW_LINE Selection_Sort ( arr , n ) NEW_LINE print ( " The ▁ Sorted ▁ Array ▁ by ▁ using ▁ "   \ " Selection ▁ Sort ▁ is ▁ : ▁ " , end = ' ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def Bubble_Sort ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT return arr NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 2 , 0 , 1 , 4 , 3 ] NEW_LINE arr = Bubble_Sort ( arr , n ) NEW_LINE print ( " The ▁ Sorted ▁ Array ▁ by ▁ using ▁ Bubble ▁ Sort ▁ is ▁ : ▁ " , end = ' ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def Bubble_Sort ( arr , n ) : NEW_LINE INDENT flag = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( n - i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE flag = True NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE arr = [ 2 , 0 , 1 , 4 , 3 ] NEW_LINE Bubble_Sort ( arr , n ) NEW_LINE print ( " The ▁ Sorted ▁ Array ▁ by ▁ using ▁ Bubble ▁ Sort ▁ is ▁ : ▁ " , end = ' ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def splitArray ( arr , n , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = n - 1 NEW_LINE result = 0 NEW_LINE while ( K > 0 ) : NEW_LINE INDENT result += arr [ i - 1 ] NEW_LINE i -= 2 NEW_LINE K -= 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
def maxCostToRemove ( arr , N , K ) : NEW_LINE INDENT maxCost = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE for i in range ( 0 , N , K ) : NEW_LINE INDENT maxCost += arr [ i + 1 ] NEW_LINE DEDENT return maxCost NEW_LINE DEDENT
def countPairs ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT xo = ( A [ i ] ^ A [ j ] ) NEW_LINE mx = max ( A [ i ] , A [ j ] ) NEW_LINE if ( xo > mx ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def checkArrangement ( A1 , A2 , n , k ) : NEW_LINE INDENT A1 = sorted ( A1 ) NEW_LINE A2 = sorted ( A2 ) NEW_LINE A2 = A2 [ : : - 1 ] NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( A1 [ i ] + A2 [ i ] > k ) or ( A1 [ i ] + A2 [ i ] < k // 2 ) ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
def MaxRearrngeSum ( A , B , N ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( reverse = True ) NEW_LINE maxSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT maxSum += abs ( A [ i ] - B [ i ] ) NEW_LINE DEDENT return maxSum NEW_LINE DEDENT
def largestArea ( arr1 , n , arr2 , m ) : NEW_LINE INDENT end = 0 NEW_LINE start = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE arr1 . sort ( reverse = False ) NEW_LINE arr2 . sort ( reverse = False ) NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( start == 0 ) : NEW_LINE INDENT start = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT end = arr1 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if ( end == 0 or start == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( end - start ) NEW_LINE DEDENT DEDENT
def count_pairs ( arr , brr , N , M , K ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE cntPairs = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE brr = sorted ( brr ) NEW_LINE while ( i < N and j < M ) : NEW_LINE INDENT if ( brr [ j ] - arr [ i ] > K ) : NEW_LINE INDENT cntPairs += ( M - j ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT
def firstSubsequence ( s ) : NEW_LINE INDENT allsubseq = [ ] NEW_LINE k = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT k = [ i for i in s ] NEW_LINE del k [ i ] NEW_LINE allsubseq . append ( " " . join ( k ) ) NEW_LINE DEDENT allsubseq = sorted ( allsubseq ) NEW_LINE print ( allsubseq [ 0 ] ) NEW_LINE DEDENT
def rankLessThanK ( arr , k , n ) : NEW_LINE INDENT rank = 1 ; NEW_LINE position = 1 ; NEW_LINE arr = sorted ( arr ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i == n - 1 or arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT rank = position ; NEW_LINE if ( rank > k ) : NEW_LINE INDENT return position - 1 ; NEW_LINE DEDENT DEDENT position += 1 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT
def maxArea ( point_x , point_y , n , length , width ) : NEW_LINE INDENT point_x . sort ( ) NEW_LINE point_y . sort ( ) NEW_LINE dx = point_x [ 0 ] NEW_LINE dy = point_y [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dx = max ( dx , point_x [ i ] - point_x [ i - 1 ] ) NEW_LINE dy = max ( dy , point_y [ i ] - point_y [ i - 1 ] ) NEW_LINE DEDENT dx = max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) NEW_LINE dy = max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) NEW_LINE print ( ( dx - 1 ) * ( dy - 1 ) ) NEW_LINE DEDENT
def solve ( values , salary ) : NEW_LINE INDENT ret = 1 NEW_LINE amt = 0 NEW_LINE values = sorted ( values ) NEW_LINE salary = sorted ( salary ) NEW_LINE while ( len ( salary ) > 0 ) : NEW_LINE INDENT while ( ( len ( values ) and values [ - 1 ] >= salary [ - 1 ] ) ) : NEW_LINE INDENT amt += 1 NEW_LINE del values [ - 1 ] NEW_LINE DEDENT if ( amt == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ret *= amt NEW_LINE amt -= 1 NEW_LINE ret %= MOD NEW_LINE del salary [ - 1 ] NEW_LINE DEDENT return ret NEW_LINE DEDENT
def minsteps ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += abs ( arr [ i ] - pow ( 2 , i ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findCost ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT p = a [ j ] - j NEW_LINE a [ j ] = 0 NEW_LINE if ( p < 0 ) : NEW_LINE INDENT p = 0 NEW_LINE continue NEW_LINE DEDENT count += p NEW_LINE DEDENT return count NEW_LINE DEDENT
def XorSum ( A , B , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT ans = ans ^ ( A [ i ] + B [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findCount ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 1 NEW_LINE cur_max = arr [ 0 ] NEW_LINE cur_min = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT cur_max = arr [ i ] NEW_LINE if ( cur_max - cur_min > K ) : NEW_LINE INDENT result += 1 NEW_LINE cur_max = arr [ i ] NEW_LINE cur_min = arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] NEW_LINE maxPossible = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxPossible > 0 ) : NEW_LINE INDENT if ( arr [ i ] >= maxPossible ) : NEW_LINE INDENT ans += ( maxPossible - 1 ) NEW_LINE maxPossible = maxPossible - 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxPossible = arr [ i ] NEW_LINE ans += maxPossible NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr . sort ( ) NEW_LINE left = 0 NEW_LINE right = 1 ; NEW_LINE while ( right < n ) : NEW_LINE INDENT if ( arr [ left ] == arr [ right ] ) : NEW_LINE INDENT ans += right - left ; NEW_LINE DEDENT else : NEW_LINE INDENT left = right ; NEW_LINE DEDENT right += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE count = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in count : NEW_LINE INDENT ans += count [ arr [ i ] ] NEW_LINE DEDENT if arr [ i ] in count : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maximizeFinalElement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE if ( arr [ 0 ] != 1 ) : NEW_LINE INDENT arr [ 0 ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] + 1 ; NEW_LINE DEDENT DEDENT return arr [ n - 1 ] ; NEW_LINE DEDENT
def findLeastDist ( A , N ) : NEW_LINE INDENT A . sort ( ) ; NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT return A [ ( N - 1 ) // 2 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT return A [ N // 2 ] ; NEW_LINE DEDENT DEDENT
def solution ( A , B , C ) : NEW_LINE INDENT arr = [ 0 ] * 3 NEW_LINE arr [ 0 ] = A NEW_LINE arr [ 1 ] = B NEW_LINE arr [ 2 ] = C NEW_LINE arr = sorted ( arr ) NEW_LINE if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) : NEW_LINE INDENT return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT
def removeElements ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] * pow ( 2 , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def canMadeEqual ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] ) : NEW_LINE return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def maxMinDifference ( arr , n , k ) : NEW_LINE INDENT if ( k >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE i = k NEW_LINE j = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT ans = min ( arr [ j ] - arr [ i ] , ans ) NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def numberofpairs ( arr , N ) : NEW_LINE INDENT answer = 0 NEW_LINE arr . sort ( ) NEW_LINE minDiff = 10000000 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] == minDiff : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def sortarray ( arr , N ) : NEW_LINE INDENT if ( N == 3 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( N // 2 ) NEW_LINE k = 1 NEW_LINE for l in range ( N // 4 ) : NEW_LINE INDENT print ( k , k + 1 , N ) NEW_LINE print ( k + 1 , N , N - 1 ) NEW_LINE k = k + 2 NEW_LINE N = N - 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def countMinSteps ( arr , target , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minimumSteps = 0 NEW_LINE i , j = 0 , n - 1 NEW_LINE while i <= j : NEW_LINE INDENT if arr [ i ] + arr [ j ] <= target : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT minimumSteps += 1 NEW_LINE DEDENT return minimumSteps NEW_LINE DEDENT
def findMinSum ( arr , K , L , size ) : NEW_LINE INDENT if ( K * L > size ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minsum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT minsum += arr [ i ] NEW_LINE DEDENT return minsum NEW_LINE DEDENT
def minBox ( arr , n ) : NEW_LINE INDENT box = n NEW_LINE arr . sort ( ) NEW_LINE curr_box , next_box = 0 , 1 NEW_LINE while ( curr_box < n and next_box < n ) : NEW_LINE INDENT if ( arr [ curr_box ] < arr [ next_box ] ) : NEW_LINE INDENT box = box - 1 NEW_LINE curr_box = curr_box + 1 NEW_LINE next_box = next_box + 1 NEW_LINE DEDENT elif ( arr [ curr_box ] == arr [ next_box ] ) : NEW_LINE INDENT next_box = next_box + 1 NEW_LINE DEDENT DEDENT print ( box ) NEW_LINE DEDENT
def redistribute ( arr , n , x ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum / ( i + 1 ) < x ) : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT
def lexNumbers ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s . append ( str ( i ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( int ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def findMinDif ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ N - 1 ] - arr [ N - 2 ] ) NEW_LINE DEDENT
def sortArray ( A , N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE INDENT for i in range ( N // 2 ) : NEW_LINE INDENT x = i NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT y = N - i - 2 NEW_LINE z = N - i - 1 NEW_LINE DEDENT A [ z ] = A [ y ] NEW_LINE A [ y ] = A [ x ] NEW_LINE A [ x ] = x + 1 NEW_LINE DEDENT print ( " Sorted ▁ Array : ▁ " , end = " " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def maximumSum ( a , b , k , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i < k : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT a [ i ] , b [ j ] = b [ j ] , a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def calculate_minimum_split ( a , k ) : NEW_LINE INDENT p = [ ] NEW_LINE n = len ( a ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT p . append ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT p . sort ( reverse = True ) NEW_LINE min_sum = sum ( p [ : k - 1 ] ) NEW_LINE res = a [ n - 1 ] - a [ 0 ] - min_sum NEW_LINE return res NEW_LINE DEDENT
def maxProfit ( arr ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] - ( 1 * i ) ) > 0 : NEW_LINE INDENT ans += ( arr [ i ] - ( 1 * i ) ) NEW_LINE DEDENT if ( arr [ i ] - ( 1 * i ) ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def sortDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE out = [ ] NEW_LINE while n : NEW_LINE INDENT out . append ( arr . pop ( n // 2 ) ) NEW_LINE n = n - 1 NEW_LINE DEDENT print ( * out ) NEW_LINE return out NEW_LINE DEDENT
def countPairs ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] > B [ ans ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def kthpair ( n , k , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE k -= 1 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT t = 1 NEW_LINE while ( arr [ i ] == arr [ i + t ] ) : NEW_LINE INDENT t += 1 NEW_LINE DEDENT if ( t * n > k ) : NEW_LINE INDENT break NEW_LINE DEDENT k = k - t * n NEW_LINE i += t NEW_LINE DEDENT print ( arr [ i ] , " ▁ " , arr [ k // t ] ) NEW_LINE DEDENT
def get_permutation ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += abs ( arr [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def make_permutation ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += abs ( i + 1 - arr [ i ] ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def minimumProduct ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE product = 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT product *= ( arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT return product NEW_LINE DEDENT
def minimiseMedian ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE ans = abs ( arr [ n // 2 ] - arr [ ( n // 2 ) - 1 ] ) ; NEW_LINE return ans ; NEW_LINE DEDENT
def findK ( arr , size , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE temp_sum = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT temp_sum += arr [ i ] NEW_LINE if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minimumSwaps ( arr ) : NEW_LINE INDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = arr [ arr [ i ] - 1 ] ; NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] ; NEW_LINE arr [ i ] = temp ; NEW_LINE count += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ 0 ] * 3 ; NEW_LINE arr [ 0 ] = a ; NEW_LINE arr [ 1 ] = b ; NEW_LINE arr [ 2 ] = c ; NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; NEW_LINE k = k - diff ; NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT
def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] - arr [ l ] ; NEW_LINE DEDENT if ( vis [ l ] [ r ] ) : NEW_LINE INDENT return dp [ l ] [ r ] ; NEW_LINE DEDENT vis [ l ] [ r ] = 1 ; NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT
def findSum ( arr , n , k ) : NEW_LINE INDENT ans = arr [ n - k - 1 ] - arr [ 0 ] ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def checkRectangles ( arr , n ) : NEW_LINE INDENT ans = True NEW_LINE arr . sort ( ) NEW_LINE area = arr [ 0 ] * arr [ 4 * n - 1 ] NEW_LINE for i in range ( 0 , 2 * n , 2 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] or arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] or arr [ i ] * arr [ 4 * n - i - 1 ] != area ) : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 ] NEW_LINE n = 2 NEW_LINE if ( checkRectangles ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findMin ( arr , n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - i ) NEW_LINE i = j - 1 NEW_LINE DEDENT return n - ans NEW_LINE DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT c_sum = 0 ; NEW_LINE arr . sort ( reverse = True ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c_sum += arr [ i ] ; NEW_LINE if ( c_sum < 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return n ; NEW_LINE DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def isPossible ( A , B , n , m , x , y ) : NEW_LINE INDENT if ( x > n or y > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE if ( A [ x - 1 ] < B [ m - y ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT A = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE B = [ 2 , 2 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE x = 3 NEW_LINE y = 1 NEW_LINE if ( isPossible ( A , B , n , m , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def cntElements ( arr , n ) : NEW_LINE INDENT copy_arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT copy_arr [ i ] = arr [ i ] NEW_LINE DEDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != copy_arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def Segment ( x , l , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( x [ i ] - l [ i ] > x [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( x [ i ] + l [ i ] < x [ i + 1 ] ) : NEW_LINE INDENT x [ i ] = x [ i ] + l [ i ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Next_greater ( a , n , x ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE low , high , ans = 0 , n - 1 , x + 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( a [ mid ] <= ans ) : NEW_LINE INDENT if ( a [ mid ] == ans ) : NEW_LINE INDENT ans += 1 NEW_LINE high = n - 1 NEW_LINE DEDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT maxratio = - sys . maxsize - 1 ; NEW_LINE maxindex = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( val [ i ] / wt [ i ] ) > maxratio ) : NEW_LINE INDENT maxratio = ( val [ i ] / wt [ i ] ) ; NEW_LINE maxindex = i ; NEW_LINE DEDENT DEDENT return ( W * maxratio ) ; NEW_LINE DEDENT
def solution ( arr , x ) : NEW_LINE INDENT closestSum = sys . maxsize NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( arr ) ) : NEW_LINE INDENT if ( abs ( x - closestSum ) > abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) : NEW_LINE INDENT closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return closestSum NEW_LINE DEDENT
def removeElements ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * n ; l = 1 ; NEW_LINE brr [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( brr [ l - 1 ] <= arr [ i ] ) : NEW_LINE INDENT brr [ l ] = arr [ i ] ; NEW_LINE l += 1 ; NEW_LINE DEDENT DEDENT for i in range ( l ) : NEW_LINE INDENT print ( brr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def maxWater ( height , n ) : NEW_LINE INDENT maximum = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT current = min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ; NEW_LINE maximum = max ( maximum , current ) ; NEW_LINE DEDENT DEDENT return maximum ; NEW_LINE DEDENT
def maxSelectionCount ( a , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE a . sort ( ) ; NEW_LINE select = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= select ) : NEW_LINE DEDENT DEDENT res += 1 ; NEW_LINE select += 1 ; NEW_LINE INDENT return res ; NEW_LINE DEDENT
def sort ( s ) : NEW_LINE INDENT c , s = list ( s ) , list ( s ) NEW_LINE c . sort ( ) NEW_LINE al_c = 0 NEW_LINE nu_c = 0 NEW_LINE while ord ( c [ al_c ] ) < 97 : NEW_LINE INDENT al_c += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] < ' a ' : NEW_LINE INDENT s [ i ] = c [ nu_c ] NEW_LINE nu_c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = c [ al_c ] NEW_LINE al_c += 1 NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def reArrange ( words , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ words [ i ] ] = i + 1 NEW_LINE DEDENT words . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( mp [ words [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def PrintBothArrays ( a , n ) : NEW_LINE INDENT v1 , v2 = [ ] , [ ] ; NEW_LINE mpp = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpp [ a [ i ] ] += 1 ; NEW_LINE if ( mpp [ a [ i ] ] == 1 ) : NEW_LINE INDENT v1 . append ( a [ i ] ) ; NEW_LINE DEDENT elif ( mpp [ a [ i ] ] == 2 ) : NEW_LINE INDENT v2 . append ( a [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT v1 . sort ( ) ; NEW_LINE print ( " Strictly ▁ increasing ▁ array ▁ is : " ) ; NEW_LINE for it in v1 : NEW_LINE INDENT print ( it , end = " ▁ " ) ; NEW_LINE DEDENT v2 . sort ( reverse = True ) ; NEW_LINE print ( " Strictly decreasing array is : " ) ; NEW_LINE for it in v2 : NEW_LINE INDENT print ( it , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def selectionSort ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp ) : NEW_LINE INDENT minn = temp NEW_LINE r = temp . next NEW_LINE while ( r ) : NEW_LINE INDENT if ( minn . data > r . data ) : NEW_LINE INDENT minn = r NEW_LINE DEDENT r = r . next NEW_LINE DEDENT x = temp . data NEW_LINE temp . data = minn . data NEW_LINE minn . data = x NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT
def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s = ' ' . join ( sorted ( s ) ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def check ( str ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = - sys . maxsize - 1 NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ascii = str [ i ] NEW_LINE if ( ord ( ascii ) < 96 or ord ( ascii ) > 122 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ord ( ascii ) NEW_LINE if ( min > ord ( ascii ) ) : NEW_LINE INDENT min = ord ( ascii ) NEW_LINE DEDENT if ( max < ord ( ascii ) ) : NEW_LINE INDENT max = ord ( ascii ) NEW_LINE DEDENT DEDENT min -= 1 NEW_LINE eSum = ( ( ( max * ( max + 1 ) ) // 2 ) - ( ( min * ( min + 1 ) ) // 2 ) ) NEW_LINE return sum == eSum NEW_LINE DEDENT
def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE arr . sort ( reverse = False ) NEW_LINE if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ int ( size / 2 ) - 1 ] + arr [ int ( size / 2 ) ] ) / 2 NEW_LINE return median NEW_LINE DEDENT median = arr [ int ( size / 2 ) ] NEW_LINE return median NEW_LINE DEDENT
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < b [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findAnswer ( n , arr ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE sum = 0 NEW_LINE for i in range ( int ( n / 2 ) ) : NEW_LINE INDENT sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def merge_and_sort ( output , arr , n , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT output [ i * n + j ] = arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT output . sort ( ) NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE x = arr [ n // 2 ] ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += abs ( arr [ i ] - x ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def odd_even ( n ) : NEW_LINE INDENT odd_indexes = [ ] NEW_LINE even_indexes = [ ] NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if i % 2 == 0 : odd_indexes . append ( n [ i ] ) NEW_LINE else : even_indexes . append ( n [ i ] ) NEW_LINE DEDENT for i in sorted ( odd_indexes ) : print ( i , end = " ▁ " ) NEW_LINE for i in sorted ( even_indexes ) : print ( i , end = " ▁ " ) NEW_LINE DEDENT
def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = False NEW_LINE if ( arr [ 0 ] % 2 == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT while ( index < n ) : NEW_LINE INDENT if ( flag == True and i < len ( v1 ) ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] NEW_LINE index += 1 NEW_LINE i += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT elif j < len ( v2 ) : NEW_LINE INDENT arr [ index ] = v2 [ j ] NEW_LINE index += 1 NEW_LINE j += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countDistinct ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == j + 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT res += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def countDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE numToAdd = - 1 NEW_LINE numAdded = False NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( diff != d ) : NEW_LINE INDENT if ( numAdded ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT numToAdd = arr [ i ] - d NEW_LINE numAdded = True NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if ( numToAdd == - 1 ) : NEW_LINE INDENT return ( arr [ n - 1 ] + d ) NEW_LINE DEDENT return numToAdd NEW_LINE DEDENT
def countSequences ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] + 1 != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def average ( arr , n , k ) : NEW_LINE INDENT total = 0 NEW_LINE if ( 2 * k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE start , end = k , n - k - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT return ( total / ( n - 2 * k ) ) NEW_LINE DEDENT
def minMovesToSort ( arr , n ) : NEW_LINE INDENT moves = 0 NEW_LINE mn = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > mn ) : NEW_LINE INDENT moves += arr [ i ] - mn NEW_LINE DEDENT DEDENT return moves NEW_LINE DEDENT
def PointInKSquares ( n , a , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return a [ n - k ] NEW_LINE DEDENT
def minimumMoves ( a , n ) : NEW_LINE INDENT operations = 0 NEW_LINE a . sort ( reverse = False ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT operations = operations + abs ( a [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return operations NEW_LINE DEDENT
def printCase ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minCost ( A , n ) : NEW_LINE INDENT cost = 0 NEW_LINE A . sort ( ) ; NEW_LINE K = A [ int ( n / 2 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cost = cost + abs ( A [ i ] - K ) NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT tempCost = 0 NEW_LINE K = A [ int ( n / 2 ) - 1 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tempCost = tempCost + abs ( A [ i ] - K ) NEW_LINE DEDENT cost = min ( cost , tempCost ) NEW_LINE DEDENT return cost NEW_LINE DEDENT
def items ( n , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE z = a [ n - 1 ] NEW_LINE x = 1 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s += a [ i ] NEW_LINE if ( s <= z ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def SubseqWidths ( A ) : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE N = len ( A ) NEW_LINE A . sort ( ) NEW_LINE pow2 = [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pow2 . append ( pow2 [ - 1 ] * 2 % MOD ) NEW_LINE DEDENT ans = 0 NEW_LINE for i , x in enumerate ( A ) : NEW_LINE INDENT ans = ( ans + ( pow2 [ i ] - pow2 [ N - 1 - i ] ) * x ) % MOD NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findOptimalSolution ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT
def numBoxex ( A , n , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE ans = 0 NEW_LINE while i <= j : NEW_LINE INDENT ans += 1 NEW_LINE if A [ i ] + A [ j ] <= K : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE flag = 0 NEW_LINE k = 2 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT i = l NEW_LINE while i < l + k and i <= r : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT flag = 1 NEW_LINE l = i NEW_LINE i = r NEW_LINE while i > r - k and i >= l : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT flag = 0 NEW_LINE r = i NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT
def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] < s [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findProduct ( arr , n ) : NEW_LINE INDENT sorted ( arr ) NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] != arr [ i ] ) : NEW_LINE INDENT prod = prod * arr [ i ] NEW_LINE DEDENT DEDENT return prod ; NEW_LINE DEDENT
def rotateRec ( n , L , B ) : NEW_LINE INDENT m = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = max ( L [ i ] , B [ i ] ) ; NEW_LINE DEDENT elif ( min ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = min ( L [ i ] , B [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT n = 3 ; NEW_LINE L = [ 5 , 5 , 6 ] ; NEW_LINE B = [ 6 , 7 , 8 ] ; NEW_LINE if ( rotateRec ( n , L , B ) == 1 ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT
def absSumDidd ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE midValue = a [ ( int ) ( n // 2 ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + abs ( a [ i ] - midValue ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minDistance ( n , k , point ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT point [ i ] . sort ( ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( point [ i ] [ ( ( n + 1 ) // 2 ) - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def solve ( N , M , cp , sp ) : NEW_LINE INDENT profit = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT profit . append ( sp [ i ] - cp [ i ] ) NEW_LINE DEDENT profit . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if profit [ i ] > 0 : NEW_LINE INDENT sum += profit [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def printOrder ( arr , n , k ) : NEW_LINE INDENT a = arr [ 0 : k ] ; NEW_LINE a . sort ( ) ; NEW_LINE b = arr [ k : n ] ; NEW_LINE b . sort ( ) ; NEW_LINE b . reverse ( ) ; NEW_LINE return a + b ; NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = printOrder ( arr , n , k ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for end in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while ( start < mid ) : NEW_LINE INDENT prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) NEW_LINE if ( prod > m ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif ( prod < m ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findMaxNum ( arr , n ) : NEW_LINE INDENT arr . sort ( rever num = arr [ 0 ] se = True ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT num = num * 10 + arr [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT
def printRLE ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( s ) - 1 ) : NEW_LINE INDENT count = 1 NEW_LINE while s [ i ] == s [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE if i + 1 == len ( s ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( str ( s [ i ] ) + str ( count ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT
def distribution ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return min ( count , n / 2 ) NEW_LINE DEDENT
def distribution ( arr , n ) : NEW_LINE INDENT resources = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT resources . add ( arr [ i ] ) ; NEW_LINE DEDENT return min ( len ( resources ) , n // 2 ) ; NEW_LINE DEDENT
def printPairs ( arr , n ) : NEW_LINE INDENT pairs = set ( ) NEW_LINE pair_exists = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT pairs . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT if ( - arr [ i ] ) in pairs : NEW_LINE INDENT print ( " { } , ▁ { } " . format ( arr [ i ] , - arr [ i ] ) ) NEW_LINE pair_exists = True NEW_LINE DEDENT DEDENT DEDENT if pair_exists == False : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ exists " ) NEW_LINE DEDENT DEDENT
def printTriplets ( arr , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n - 2 , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) : NEW_LINE INDENT print ( arr [ i ] , " , " , arr [ j ] , " , " , arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def printTriplets ( arr , n , sum ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT ( j , k ) = ( i + 1 , n - 1 ) NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT for x in range ( j + 1 , k + 1 ) : NEW_LINE INDENT print ( str ( arr [ i ] ) + " , ▁ " + str ( arr [ j ] ) + " , ▁ " + str ( arr [ x ] ) ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countTriplets ( arr , n , a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ j ] + arr [ k ] >= a ) and ( arr [ i ] + arr [ j ] + arr [ k ] <= b ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def checkFittingArrays ( A , B , N ) : NEW_LINE INDENT A = sorted ( A ) NEW_LINE B = sorted ( B ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] > B [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT A = [ 7 , 5 , 3 , 2 ] NEW_LINE B = [ 5 , 4 , 8 , 7 ] NEW_LINE N = len ( A ) NEW_LINE if ( checkFittingArrays ( A , B , N ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def areSame ( a , b ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE b . sort ( ) ; NEW_LINE return ( a == b ) a = [ 7 , 7 , 5 ] ; NEW_LINE DEDENT b = [ 7 , 5 , 5 ] ; NEW_LINE if ( areSame ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; ; NEW_LINE DEDENT
def maximum_toys ( cost , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE cost . sort ( reverse = False ) NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT if ( sum + cost [ i ] <= K ) : NEW_LINE INDENT sum = sum + cost [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findOptimalPairs ( arr , N ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE i = 0 NEW_LINE j = N - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , " , arr [ j ] , " ) " , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT
def areBookingsPossible ( A , B , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if i + K < len ( A ) and A [ i + K ] < B [ i ] : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def lexicographicSubConcat ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE sub_count = ( n * ( n + 1 ) ) // 2 ; NEW_LINE arr = [ 0 ] * sub_count ; NEW_LINE index = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n - i + 1 ) : NEW_LINE INDENT arr [ index ] = s [ i : i + j ] ; NEW_LINE index += 1 ; NEW_LINE DEDENT DEDENT arr . sort ( ) ; NEW_LINE res = " " ; NEW_LINE for i in range ( sub_count ) : NEW_LINE INDENT res += arr [ i ] ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def function ( st ) : NEW_LINE INDENT global MAX NEW_LINE l = len ( st ) NEW_LINE counter = [ 0 ] * MAX NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT counter [ ord ( st [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( l // 2 , l ) : NEW_LINE INDENT counter [ ord ( st [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( counter [ i ] != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT st = " abcasdsabcae " NEW_LINE if function ( st ) : NEW_LINE INDENT print ( " Yes , ▁ both ▁ halves ▁ differ ▁ by ▁ at ▁ " , " least ▁ one ▁ character " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No , ▁ both ▁ halves ▁ do ▁ not ▁ differ ▁ at ▁ all " ) NEW_LINE DEDENT
def function ( st ) : NEW_LINE INDENT st = list ( st ) NEW_LINE l = len ( st ) NEW_LINE st [ : l // 2 ] = sorted ( st [ : l // 2 ] ) NEW_LINE st [ l // 2 : ] = sorted ( st [ l // 2 : ] ) NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT if ( st [ i ] != st [ l // 2 + i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def operations ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE i = 0 ; sum = 0 ; NEW_LINE while ( k > 0 ) : NEW_LINE INDENT while ( i < n and arr [ i ] - sum == 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT if ( i < n and arr [ i ] - sum > 0 ) : NEW_LINE INDENT print ( arr [ i ] - sum , end = " ▁ " ) ; NEW_LINE sum = arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) ; NEW_LINE DEDENT k -= 1 ; NEW_LINE DEDENT DEDENT
def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum / 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def minimumBox ( arr , n ) : NEW_LINE INDENT q = collections . deque ( [ ] ) NEW_LINE arr . sort ( ) NEW_LINE q . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q [ 0 ] NEW_LINE if ( arr [ i ] >= 2 * now ) : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT q . append ( arr [ i ] ) NEW_LINE DEDENT return len ( q ) NEW_LINE DEDENT
def printMedian ( arr , n , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE print ( arr [ int ( ( n + K ) / 2 ) ] ) NEW_LINE DEDENT
def sortBinaryArray ( a , n ) : NEW_LINE INDENT j = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 1 : NEW_LINE INDENT j = j + 1 NEW_LINE a [ i ] , a [ j ] = a [ j ] , a [ i ] NEW_LINE DEDENT DEDENT DEDENT a = [ 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 ] NEW_LINE n = len ( a ) NEW_LINE sortBinaryArray ( a , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def almostSort ( A , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if A [ i ] > A [ i + 1 ] : NEW_LINE INDENT A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if A [ i ] > A [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def check ( v , l ) : NEW_LINE INDENT n = len ( v ) NEW_LINE for i in v : NEW_LINE INDENT i = ' ' . join ( sorted ( i ) ) NEW_LINE DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( v [ i ] [ j ] > v [ i + 1 ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT v = [ " ebcda " , " ihgfj " , " klmno " , " pqrst " , " yvwxu " ] NEW_LINE if check ( v , l ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def findDuplicate ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j , count = i + 1 , 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT i = j NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def longestCommonPrefix ( a ) : NEW_LINE INDENT size = len ( a ) NEW_LINE if ( size == 0 ) : NEW_LINE INDENT return " " NEW_LINE DEDENT if ( size == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT a . sort ( ) NEW_LINE end = min ( len ( a [ 0 ] ) , len ( a [ size - 1 ] ) ) NEW_LINE i = 0 NEW_LINE while ( i < end and a [ 0 ] [ i ] == a [ size - 1 ] [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT pre = a [ 0 ] [ 0 : i ] NEW_LINE return pre NEW_LINE DEDENT
def find ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE b = int ( ceil ( n / k ) ) NEW_LINE print ( " minimum ▁ " , sum ( arr [ : b ] ) ) NEW_LINE print ( " maximum ▁ " , sum ( arr [ - b : ] ) ) NEW_LINE DEDENT
def checkForSorting ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 0 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkForSorting ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def pendulumArrangement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE op = [ 0 ] * n NEW_LINE mid = int ( ( n - 1 ) / 2 ) NEW_LINE j = 1 NEW_LINE i = 1 NEW_LINE op [ mid ] = arr [ 0 ] NEW_LINE for i in range ( 1 , mid + 1 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE op [ mid - i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( int ( n % 2 ) == 0 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE DEDENT print ( " Pendulum ▁ arrangement : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( op [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maxLevel ( boxes , n ) : NEW_LINE INDENT boxes . sort ( ) NEW_LINE prev_width = boxes [ 0 ] NEW_LINE prev_count = 1 NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_width += boxes [ i ] NEW_LINE curr_count += 1 NEW_LINE if ( curr_width > prev_width and curr_count > prev_count ) : NEW_LINE INDENT prev_width = curr_width NEW_LINE prev_count = curr_count NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minDifferenceAmongMaxMin ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 2147483647 NEW_LINE for i in range ( ( N - K ) + 1 ) : NEW_LINE INDENT curSeqDiff = arr [ i + K - 1 ] - arr [ i ] NEW_LINE res = min ( res , curSeqDiff ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , max ( b , c ) ) NEW_LINE get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , " ▁ " , get_mid , " ▁ " , get_max ) NEW_LINE DEDENT
def twoWaySort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 3 , 2 , 7 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE twoWaySort ( arr , n ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def sortSquare ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE DEDENT arr = [ - 6 , - 3 , - 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Before ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE sortSquare ( arr , n ) NEW_LINE print ( " After ▁ sort " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def ksmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE if ( k < arr [ 0 ] ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT if ( k == arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] + 1 ; NEW_LINE DEDENT if ( k > arr [ n - 1 ] ) : NEW_LINE INDENT return k + n ; NEW_LINE DEDENT if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= ( arr [ 0 ] - 1 ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT c = arr [ i ] - arr [ i - 1 ] - 1 ; NEW_LINE if ( k <= c ) : NEW_LINE INDENT return arr [ i - 1 ] + k ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= c ; NEW_LINE DEDENT DEDENT return arr [ n - 1 ] + k ; NEW_LINE DEDENT
def mergeTwoHalf ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE DEDENT
def minDiff ( arr , n , k ) : NEW_LINE INDENT result = + 2147483647 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ 2 , 1 , 3 ] NEW_LINE b = [ 7 , 8 , 9 ] NEW_LINE k = 10 NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , b , n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findMinDiff ( arr , n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE if ( n < m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT min_diff = arr [ n - 1 ] - arr [ 0 ] NEW_LINE for i in range ( len ( arr ) - m + 1 ) : NEW_LINE INDENT min_diff = min ( min_diff , arr [ i + m - 1 ] - arr [ i ] ) NEW_LINE DEDENT return min_diff NEW_LINE DEDENT
def getIndexInSortedArray ( arr , n , idx ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ idx ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( arr [ i ] == arr [ idx ] and i < idx ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT
def minValue ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) NEW_LINE DEDENT
def findSubsequenceCount ( S , T ) : NEW_LINE INDENT m = len ( T ) NEW_LINE n = len ( S ) NEW_LINE if m > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( n + 1 ) : NEW_LINE INDENT mat [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if T [ i - 1 ] != S [ j - 1 ] : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return mat [ m ] [ n ] NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 ; b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if max == - 1 : NEW_LINE INDENT print ( " No ▁ Tripplet ▁ Exits " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Maximum ▁ product ▁ is " , max ) NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT
def distinctCount ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( abs ( arr [ i ] ) ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT
def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( ) ; NEW_LINE exit . sort ( ) ; NEW_LINE guests_in = 1 ; NEW_LINE max_guests = 1 ; NEW_LINE time = arrl [ 0 ] ; NEW_LINE i = 1 ; NEW_LINE j = 0 ; NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arrl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guests_in = guests_in + 1 ; NEW_LINE if ( guests_in > max_guests ) : NEW_LINE INDENT max_guests = guests_in ; NEW_LINE time = arrl [ i ] ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT guests_in = guests_in - 1 ; NEW_LINE j = j + 1 ; NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = " , max_guests , " at ▁ time " , time ) NEW_LINE DEDENT
def maxConsecutiveCnt ( arr ) : NEW_LINE INDENT X = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] <= ( X + 1 ) ) : NEW_LINE INDENT X = X + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return X + 1 NEW_LINE DEDENT
def minimumPossibleProduct ( K ) : NEW_LINE INDENT res = 1 NEW_LINE r = ( 1 << K ) - 1 NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT res *= ( r - 1 ) NEW_LINE DEDENT res *= r NEW_LINE return res NEW_LINE DEDENT
def countPoints ( D ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , int ( sqrt ( D * D ) ) , 1 ) : NEW_LINE INDENT y = int ( sqrt ( ( D * D - x * x ) ) ) NEW_LINE if ( x * x + y * y == D * D ) : NEW_LINE INDENT count += 4 NEW_LINE DEDENT DEDENT count += 4 NEW_LINE return count NEW_LINE DEDENT
def minimizeCost ( A , B , C ) : NEW_LINE INDENT ans = A + B + C NEW_LINE for i in range ( 1 , 2 * C + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( i * j <= 2 * C ) : NEW_LINE INDENT ans = min ( ans , abs ( A - i ) + abs ( B - j ) + abs ( i * j - C ) ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def averageSetBits ( N , K , arr ) : NEW_LINE INDENT p = N NEW_LINE q = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT _p = p NEW_LINE _q = q NEW_LINE p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N NEW_LINE q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N NEW_LINE DEDENT return p NEW_LINE DEDENT
def minimumcoins ( arr , N ) : NEW_LINE INDENT coins = 0 NEW_LINE j = 0 NEW_LINE if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT coins += 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = i NEW_LINE while ( j < N and arr [ j ] == 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT x = ( j - i ) NEW_LINE coins += x // 3 NEW_LINE i = j - 1 NEW_LINE DEDENT return coins NEW_LINE DEDENT
def findRange ( arr , N , K ) : NEW_LINE INDENT L = - sys . maxsize - 1 NEW_LINE R = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) NEW_LINE r = ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) - 1 ) NEW_LINE L = max ( L , l ) NEW_LINE R = min ( R , r ) NEW_LINE DEDENT print ( L , R ) NEW_LINE DEDENT
def maximizeProduct ( N ) : NEW_LINE INDENT MSB = ( int ) ( math . log2 ( N ) ) NEW_LINE X = 1 << MSB NEW_LINE Y = N - ( 1 << MSB ) NEW_LINE for i in range ( MSB ) : NEW_LINE INDENT if ( not ( N & ( 1 << i ) ) ) : NEW_LINE INDENT X += 1 << i NEW_LINE Y += 1 << i NEW_LINE DEDENT DEDENT print ( X , Y ) NEW_LINE DEDENT
def arrayDivisionByTwo ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] // 2 NEW_LINE cnt += 1 NEW_LINE DEDENT ans = min ( ans , cnt ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minPushes ( N , K , arr ) : NEW_LINE INDENT dp = [ - 1 ] * 100000 NEW_LINE dp [ N ] = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for xx in range ( 100000 ) : NEW_LINE INDENT x = xx NEW_LINE if ( dp [ x ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT next = ( x + arr [ i ] ) % 100000 NEW_LINE while ( dp [ next ] == - 1 or dp [ next ] > dp [ x ] + 1 ) : NEW_LINE INDENT dp [ next ] = dp [ x ] + 1 NEW_LINE x = next NEW_LINE next = ( next + arr [ i ] ) % 100000 NEW_LINE DEDENT DEDENT DEDENT return dp [ K ] NEW_LINE DEDENT
def minApples ( ) : NEW_LINE INDENT if M <= S * K : NEW_LINE INDENT return M NEW_LINE DEDENT elif M <= S * K + E + W : NEW_LINE INDENT return S * K + ( M - S * K ) * K NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def maxAverage ( A , N , X , Y ) : NEW_LINE INDENT A . sort ( ) NEW_LINE sum = 0 NEW_LINE res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE count += 1 NEW_LINE if ( count == X ) : NEW_LINE INDENT if ( N - i - 1 < X ) : NEW_LINE INDENT i += 1 NEW_LINE cnt = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT cnt += 1 NEW_LINE sum += A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT X = X + cnt NEW_LINE res += sum / X NEW_LINE break NEW_LINE DEDENT res += sum / X NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def largestMerge ( word1 , word2 ) : NEW_LINE INDENT merge = " " NEW_LINE while len ( word1 ) != 0 or len ( word2 ) != 0 : NEW_LINE INDENT if word1 >= word2 : NEW_LINE INDENT merge = merge + word1 [ 0 ] NEW_LINE word1 = word1 [ 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT merge = merge + word2 [ 0 ] NEW_LINE word2 = word2 [ 1 : ] NEW_LINE DEDENT DEDENT return merge NEW_LINE DEDENT
def find ( arr , N ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE if Sum % N : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = Sum // N NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT ans = ans + abs ( k - arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return ans // 2 NEW_LINE DEDENT DEDENT
def maxGcd ( a , b ) : NEW_LINE INDENT print ( abs ( a - b ) ) NEW_LINE DEDENT
def printBinaryString ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT print ( 0 , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT
def MinCost ( days , cost , N ) : NEW_LINE INDENT size = days [ N - 1 ] + 1 NEW_LINE dp = [ 0 for i in range ( size ) ] NEW_LINE dp [ size - 1 ] = min ( cost [ 0 ] , min ( cost [ 1 ] , cost [ 2 ] ) ) NEW_LINE ptr = N - 2 NEW_LINE for i in range ( size - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( ptr >= 0 and days [ ptr ] == i ) : NEW_LINE INDENT val1 = dp [ i + 1 ] + cost [ 0 ] NEW_LINE val2 = cost [ 1 ] + ( 0 if ( i + 7 >= size ) else dp [ i + 7 ] ) NEW_LINE val3 = cost [ 2 ] + ( 0 if ( i + 30 >= size ) else dp [ i + 30 ] ) NEW_LINE dp [ i ] = min ( val1 , min ( val2 , val3 ) ) NEW_LINE ptr -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i + 1 ] NEW_LINE DEDENT DEDENT return dp [ 1 ] NEW_LINE DEDENT
def minElements ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE requiredNum = 1 NEW_LINE i = 0 NEW_LINE while ( requiredNum <= K ) : NEW_LINE INDENT if ( i < N and requiredNum >= arr [ i ] ) : NEW_LINE INDENT requiredNum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE requiredNum += requiredNum NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def minimumSteps ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE a = abs ( a - b ) NEW_LINE cnt = ( a // 5 ) + ( a % 5 ) // 2 + ( a % 5 ) % 2 NEW_LINE return cnt NEW_LINE DEDENT
def maximumCount ( arr , N ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd and even ) : NEW_LINE INDENT return N - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT DEDENT
def countOpenDoors ( N ) : NEW_LINE INDENT doorsOpen = int ( math . sqrt ( N ) ) NEW_LINE return doorsOpen NEW_LINE DEDENT
def minPossibleValue ( N , K , X ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( X <= K ) : NEW_LINE INDENT X = X * 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT X = X + K ; NEW_LINE DEDENT DEDENT return X ; NEW_LINE DEDENT
def possibleNumbers ( numbers , N , M , A , B ) : NEW_LINE INDENT if ( M == 0 ) : NEW_LINE INDENT numbers . add ( N ) NEW_LINE return NEW_LINE DEDENT possibleNumbers ( numbers , N + A , M - 1 , A , B ) NEW_LINE possibleNumbers ( numbers , N + B , M - 1 , A , B ) NEW_LINE DEDENT
def convertXintoY ( X , Y ) : NEW_LINE INDENT while ( Y > X ) : NEW_LINE INDENT if ( Y % 2 == 0 ) : NEW_LINE INDENT Y //= 2 NEW_LINE DEDENT elif ( Y % 10 == 1 ) : NEW_LINE INDENT Y //= 10 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( X == Y ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def MaxXOR ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res |= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def leastBricks ( wall ) : NEW_LINE INDENT map = defaultdict ( int ) NEW_LINE res = 0 NEW_LINE for list in wall : NEW_LINE INDENT width = 0 NEW_LINE for i in range ( len ( list ) - 1 ) : NEW_LINE INDENT width += list [ i ] NEW_LINE map [ width ] += 1 NEW_LINE res = max ( res , map [ width ] ) NEW_LINE DEDENT DEDENT print ( len ( wall ) - res ) NEW_LINE DEDENT
def findPermutation ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( " " , ▁ end ▁ = ▁ " " ) NEW_LINE DEDENT
def countOfPairs ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE for k in range ( 1 , int ( sqrt ( x ) ) + 1 , 1 ) : NEW_LINE INDENT count += max ( 0 , min ( y , x / k - 1 ) - k ) NEW_LINE DEDENT print ( int ( count ) ) NEW_LINE DEDENT
def numberOfWays ( N , X , Y ) : NEW_LINE INDENT S1 = ( N - 1 ) * X + Y NEW_LINE S2 = ( N - 1 ) * Y + X NEW_LINE return ( S2 - S1 + 1 ) NEW_LINE DEDENT
def countPermutations ( N ) : NEW_LINE INDENT adj = [ [ ] for i in range ( 105 ) ] NEW_LINE indeg = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT sum = i + j NEW_LINE if ( ceil ( sqrt ( sum ) ) == floor ( sqrt ( sum ) ) ) : NEW_LINE INDENT adj [ i ] . append ( j ) NEW_LINE DEDENT DEDENT if ( len ( adj [ i ] ) == 1 ) : NEW_LINE INDENT indeg += 1 NEW_LINE DEDENT DEDENT if ( indeg == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT elif ( indeg <= 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def findMaximumProfit ( arr , M , N ) : NEW_LINE INDENT max_heap = [ ] NEW_LINE maxProfit = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT max_heap . append ( arr [ i ] ) NEW_LINE DEDENT max_heap . sort ( ) NEW_LINE max_heap . reverse ( ) NEW_LINE while ( M > 0 ) : NEW_LINE INDENT M -= 1 NEW_LINE X = max_heap [ 0 ] NEW_LINE max_heap . pop ( 0 ) NEW_LINE maxProfit += X NEW_LINE max_heap . append ( X - 1 ) NEW_LINE max_heap . sort ( ) NEW_LINE max_heap . reverse ( ) NEW_LINE DEDENT print ( maxProfit ) NEW_LINE DEDENT
def largestNumber ( N ) : NEW_LINE INDENT if ( N > 45 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num = 0 NEW_LINE digit = 9 NEW_LINE while ( N > 0 and digit > 0 ) : NEW_LINE INDENT if ( digit <= N ) : NEW_LINE INDENT num *= 10 NEW_LINE num += digit NEW_LINE N -= digit NEW_LINE DEDENT digit -= 1 NEW_LINE DEDENT return num * 10 NEW_LINE DEDENT
def MinimumOperations ( A , N , K ) : NEW_LINE INDENT Count = 0 NEW_LINE i = 0 NEW_LINE while ( i < N - 1 ) : NEW_LINE INDENT i = i + K - 1 NEW_LINE Count += 1 NEW_LINE DEDENT return Count NEW_LINE DEDENT
def sumOfMedians ( arr , N , K ) : NEW_LINE INDENT selectMedian = ( K + 1 ) // 2 NEW_LINE totalArrays = N // K NEW_LINE minSum = 0 NEW_LINE i = selectMedian - 1 NEW_LINE while ( i < N and totalArrays != 0 ) : NEW_LINE INDENT minSum = minSum + arr [ i ] NEW_LINE i = i + selectMedian NEW_LINE totalArrays -= 1 NEW_LINE DEDENT print ( minSum ) NEW_LINE DEDENT
def generateString ( K ) : NEW_LINE INDENT s = " " NEW_LINE for i in range ( 97 , 97 + K , 1 ) : NEW_LINE INDENT s = s + chr ( i ) ; NEW_LINE for j in range ( i + 1 , 97 + K , 1 ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE DEDENT DEDENT s += chr ( 97 ) NEW_LINE print ( s ) NEW_LINE DEDENT
def minimumValue ( N , K ) : NEW_LINE INDENT return math . ceil ( K / N ) NEW_LINE DEDENT
def minModulo ( L , R , N ) : NEW_LINE INDENT if ( R - L < N ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT for j in range ( L , R + 1 ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % N ) NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT
def countNumbers ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( N % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( N // i != i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findEquation ( A , B , C , K ) : NEW_LINE INDENT print ( A , K * B , K * K * C ) NEW_LINE DEDENT
def checkString ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( 2 * k + 1 > n ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT a = s [ 0 : k ] NEW_LINE b = s [ n - k : n ] NEW_LINE b = b [ : : - 1 ] NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findMin ( arr , N , k ) : NEW_LINE INDENT pairs = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pairs += arr [ i ] / 2 NEW_LINE DEDENT if ( k > pairs ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * k + N - 1 NEW_LINE DEDENT DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT oddcount , evencount = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT oddcount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT evencount += 1 NEW_LINE DEDENT DEDENT return min ( oddcount , evencount ) NEW_LINE DEDENT
def printLastElement ( arr , N ) : NEW_LINE INDENT leftTurn = True NEW_LINE remainElements = N NEW_LINE step = 1 NEW_LINE head = 1 NEW_LINE while ( remainElements > 1 ) : NEW_LINE INDENT if ( leftTurn ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT else : NEW_LINE INDENT if ( remainElements % 2 == 1 ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT DEDENT remainElements = remainElements // 2 NEW_LINE step = step * 2 NEW_LINE leftTurn = not leftTurn NEW_LINE DEDENT print ( arr [ head - 1 ] ) NEW_LINE DEDENT
def findEquation ( S , M ) : NEW_LINE INDENT print ( "1 ▁ " , ( ( - 1 ) * S ) , " ▁ " , M ) NEW_LINE DEDENT
def countTriplets ( N , K ) : NEW_LINE INDENT if ( K % 2 == 0 ) : NEW_LINE INDENT x = N // K NEW_LINE y = ( N + ( K // 2 ) ) // K NEW_LINE return x * x * x + y * y * y NEW_LINE DEDENT else : NEW_LINE INDENT x = N // K NEW_LINE return x * x * x NEW_LINE DEDENT DEDENT
def minLength ( s ) : NEW_LINE INDENT i = 0 ; j = len ( s ) - 1 NEW_LINE while ( i < j and s [ i ] == s [ j ] ) : NEW_LINE INDENT d = s [ i ] NEW_LINE while ( i <= j and s [ i ] == d ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while ( i <= j and s [ j ] == d ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return j - i + 1 NEW_LINE DEDENT
def findNumber ( N ) : NEW_LINE INDENT ans = [ 1 , 2 , 4 , 8 , 7 , 5 ] NEW_LINE return ans [ N % 6 ] NEW_LINE DEDENT
def canBeEmptied ( A , B ) : NEW_LINE INDENT if ( max ( A , B ) > 2 * min ( A , B ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if ( ( A + B ) % 3 == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countDecrements ( arr ) : NEW_LINE INDENT count_1 = 0 NEW_LINE count_2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) : NEW_LINE INDENT count_2 += 1 NEW_LINE DEDENT DEDENT DEDENT print ( min ( count_1 , count_2 ) ) NEW_LINE DEDENT
def findScoreSum ( n ) : NEW_LINE INDENT total = 0 NEW_LINE prev_monday , curr_day = 0 , 0 NEW_LINE for day in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( day % 7 == 1 ) : NEW_LINE INDENT prev_monday += 1 NEW_LINE curr_day = prev_monday NEW_LINE DEDENT total += curr_day NEW_LINE curr_day += 1 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT
def findScoreSum ( n ) : NEW_LINE INDENT F = n // 7 NEW_LINE D = n % 7 NEW_LINE fullWeekScore = ( 49 + 7 * F ) * F // 2 NEW_LINE lastNonFullWeekScore = ( 2 * F + D + 1 ) * D // 2 NEW_LINE print ( fullWeekScore + lastNonFullWeekScore ) NEW_LINE DEDENT
def distIntegers ( L , R ) : NEW_LINE INDENT return 2 * R - 2 * L + 1 NEW_LINE DEDENT
def maximumNum ( X , Y , N ) : NEW_LINE INDENT num = 0 NEW_LINE if ( N - N % X + Y <= N ) : NEW_LINE INDENT num = N - N % X + Y NEW_LINE DEDENT else : NEW_LINE INDENT num = N - N % X - ( X - Y ) NEW_LINE DEDENT return num NEW_LINE DEDENT
def evenXorSubarray ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT XOR = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ j ] NEW_LINE if ( ( XOR & 1 ) == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def countOccurrences ( n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT if ( x // i <= n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def MinimumCost ( A , B , N ) : NEW_LINE INDENT totalCost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT mod_A = B [ i ] % A [ i ] NEW_LINE totalCost_A = min ( mod_A , A [ i ] - mod_A ) NEW_LINE mod_B = A [ i ] % B [ i ] NEW_LINE totalCost_B = min ( mod_B , B [ i ] - mod_B ) NEW_LINE totalCost += min ( totalCost_A , totalCost_B ) NEW_LINE DEDENT return totalCost NEW_LINE DEDENT
def countOccurrences ( N , X ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( X ) ) + 1 ) : NEW_LINE INDENT if X % i == 0 : NEW_LINE INDENT a = i NEW_LINE b = X // i NEW_LINE if a <= N and b <= N : NEW_LINE INDENT if a == b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def winner ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT DEDENT
def LCMPairs ( arr , N ) : NEW_LINE INDENT total_pairs = ( N * ( N - 1 ) ) / 2 NEW_LINE odd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT odd = ( odd * ( odd - 1 ) ) // 2 NEW_LINE print ( " Even ▁ = " , int ( total_pairs - odd ) , " , " , " ▁ Odd ▁ = " , odd ) NEW_LINE DEDENT
def printNumber ( N , K , M ) : NEW_LINE INDENT sum = K * ( M * ( M + 1 ) / 2 ) NEW_LINE return sum - N NEW_LINE DEDENT
def countPairs ( L , R ) : NEW_LINE INDENT firstNum = 2 * L NEW_LINE lastNum = 2 * R NEW_LINE Cntpairs = lastNum - firstNum + 1 NEW_LINE print ( Cntpairs ) NEW_LINE DEDENT
def countPairs ( A , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( count ) ; NEW_LINE DEDENT
def maximumCandy ( candies , safety , N , M ) : NEW_LINE INDENT total = 0 NEW_LINE ans = 10 ** 8 NEW_LINE all_safe = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( candies [ i ] + M > safety [ i ] ) : NEW_LINE INDENT all_safe = False NEW_LINE ans = min ( ans , safety [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , candies [ i ] + M ) NEW_LINE DEDENT total += candies [ i ] NEW_LINE DEDENT if ( all_safe ) : NEW_LINE INDENT return total NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT
def checkArrays ( arr1 , arr2 , N ) : NEW_LINE INDENT count = 0 NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT if ( arr1 [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE if ( count < 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag and count == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def construct_Array ( N , K ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( K * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def MinimumMoves ( A , B , N ) : NEW_LINE INDENT totalOperations = 0 NEW_LINE carry = 0 NEW_LINE K = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT nearestMultiple = ceil ( ( A [ i ] + carry ) / B [ i ] ) * B [ i ] NEW_LINE K = nearestMultiple - ( A [ i ] + carry ) NEW_LINE totalOperations += K NEW_LINE carry += K NEW_LINE DEDENT return totalOperations NEW_LINE DEDENT
def maxSheets ( A , B ) : NEW_LINE INDENT area = A * B NEW_LINE count = 1 NEW_LINE while ( area % 2 == 0 ) : NEW_LINE INDENT area //= 2 NEW_LINE count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findMinMoves ( a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( a == b or abs ( a - b ) == 1 ) : NEW_LINE INDENT ans = a + b NEW_LINE DEDENT else : NEW_LINE INDENT k = min ( a , b ) NEW_LINE j = max ( a , b ) NEW_LINE ans = 2 * k + 2 * ( j - k ) - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def find ( N ) : NEW_LINE INDENT F = int ( ( N - 4 ) / 5 ) NEW_LINE if ( ( N - 5 * F ) % 2 ) == 0 : NEW_LINE INDENT O = 2 NEW_LINE DEDENT else : NEW_LINE INDENT O = 1 NEW_LINE DEDENT T = ( N - 5 * F - O ) // 2 NEW_LINE print ( " Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ " , F ) NEW_LINE print ( " Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ " , T ) NEW_LINE print ( " Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ " , O ) NEW_LINE DEDENT
def check ( current_row , current_col , destination_row , destination_col ) : NEW_LINE INDENT if ( current_row == destination_row ) : NEW_LINE INDENT return ( " POSSIBLE " ) NEW_LINE DEDENT elif ( current_col == destination_col ) : NEW_LINE INDENT return ( " POSSIBLE " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " NOT ▁ POSSIBLE " ) NEW_LINE DEDENT DEDENT
def generatepermutation ( N ) : NEW_LINE INDENT answer = [ ] NEW_LINE answer . append ( N ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT answer . append ( i ) NEW_LINE DEDENT print ( * answer ) NEW_LINE DEDENT
def cntEvenSumPairs ( X , Y ) : NEW_LINE INDENT cntXEvenNums = X / 2 NEW_LINE cntXOddNums = ( X + 1 ) / 2 NEW_LINE cntYEvenNums = Y / 2 NEW_LINE cntYOddNums = ( Y + 1 ) / 2 NEW_LINE cntPairs = ( ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ) NEW_LINE return cntPairs NEW_LINE DEDENT
def maxValueAtIndexK ( N , K , M ) : NEW_LINE INDENT S1 = 0 ; S2 = 0 ; NEW_LINE S1 = K * ( K + 1 ) // 2 ; NEW_LINE S2 = ( N - K - 1 ) * ( N - K ) // 2 ; NEW_LINE X = ( M + S1 + S2 ) // N ; NEW_LINE print ( X ) ; NEW_LINE DEDENT
def farthestCellDistance ( N , M , R , C ) : NEW_LINE INDENT d1 = N + M - R - C ; NEW_LINE d2 = R + C - 2 ; NEW_LINE d3 = N - R + C - 1 ; NEW_LINE d4 = M - C + R - 1 ; NEW_LINE maxDistance = max ( d1 , max ( d2 , max ( d3 , d4 ) ) ) ; NEW_LINE print ( maxDistance ) ; NEW_LINE DEDENT
def minimumStepReqArr ( arr , N ) : NEW_LINE INDENT cntStep = 0 NEW_LINE N += 1 NEW_LINE i = 31 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE INDENT cntStep += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return cntStep NEW_LINE DEDENT
def findInGrid ( i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return ( i * i - ( i - 1 ) ) NEW_LINE DEDENT elif ( i > j ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT return i * i - ( j - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j % 2 == 0 ) : NEW_LINE INDENT return ( ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return j * j - ( i - 1 ) NEW_LINE DEDENT DEDENT DEDENT
def minOpsToEmptyString ( S , N ) : NEW_LINE INDENT one = 0 NEW_LINE zero = 0 NEW_LINE x0 = 0 NEW_LINE x1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT x0 += 1 NEW_LINE x1 = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x1 += 1 NEW_LINE x0 = 0 NEW_LINE DEDENT zero = max ( x0 , zero ) NEW_LINE one = max ( x1 , one ) NEW_LINE DEDENT print ( max ( one , zero ) ) NEW_LINE DEDENT
def minOpsToTurnArrToZero ( arr , N ) : NEW_LINE INDENT st = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i in st . keys ( ) or arr [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT st [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT print ( len ( st ) ) NEW_LINE DEDENT
def minMoves ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( - 1 , 2 ) : NEW_LINE INDENT for j in range ( - 1 , 2 ) : NEW_LINE INDENT num1 = arr [ 0 ] + i NEW_LINE num2 = arr [ 1 ] + j NEW_LINE flag = 1 NEW_LINE moves = abs ( i ) + abs ( j ) NEW_LINE for idx in range ( 2 , N ) : NEW_LINE INDENT num = num1 + num2 NEW_LINE if ( abs ( arr [ idx ] - num ) > 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT moves += abs ( arr [ idx ] - num ) NEW_LINE DEDENT num1 = num2 NEW_LINE num2 = num NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT ans = min ( ans , moves ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def querySum ( arr , N , Q , M ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE sum = 0 NEW_LINE while ( x < N ) : NEW_LINE INDENT sum += arr [ x ] NEW_LINE x += y NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minXOR ( Arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( Arr [ i ] == 2 ) : NEW_LINE INDENT print ( Arr [ i ] ^ 3 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Arr [ i ] ^ 2 , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findMaxValByRearrArr ( arr , N ) : NEW_LINE INDENT res = 0 ; NEW_LINE res = ( N * ( N + 1 ) ) // 2 ; NEW_LINE return res ; NEW_LINE DEDENT
def min_steps_required ( n , m , r , c ) : NEW_LINE INDENT i = 0 ; j = 0 ; NEW_LINE corner_steps_req = INT_MAX ; NEW_LINE i = 1 ; NEW_LINE j = 1 ; NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; NEW_LINE i = n ; NEW_LINE j = 1 ; NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; NEW_LINE i = 1 ; NEW_LINE j = m ; NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; NEW_LINE i = n ; NEW_LINE j = m ; NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; NEW_LINE minimum_steps = min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; NEW_LINE return minimum_steps + corner_steps_req ; NEW_LINE DEDENT
def cntOnesArrWithGivenOp ( arr , N ) : NEW_LINE INDENT cntOnes = 0 ; NEW_LINE cntOnes = int ( N ** ( 1 / 2 ) ) ; NEW_LINE return cntOnes ; NEW_LINE DEDENT
def cntKnightsAttackPawn ( knights , pawn , M ) : NEW_LINE INDENT cntKnights = 0 ; NEW_LINE for i in range ( M ) : NEW_LINE INDENT X = abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; NEW_LINE Y = abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; NEW_LINE if ( ( X == 1 and Y == 2 ) or ( X == 2 and Y == 1 ) ) : NEW_LINE INDENT cntKnights += 1 ; NEW_LINE DEDENT DEDENT return cntKnights ; NEW_LINE DEDENT
def maxksum ( L , R , K ) : NEW_LINE INDENT N = ( R // 10 - L // 10 ) + 1 ; NEW_LINE if ( K > N ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE return ; NEW_LINE DEDENT R = R // 10 ; NEW_LINE X = R - K ; NEW_LINE sum = 10 * ( ( R * ( R + 1 ) ) // 2 - ( X * ( X + 1 ) ) // 2 ) ; NEW_LINE print ( sum ) ; NEW_LINE DEDENT
def path_to_root ( node ) : NEW_LINE INDENT while ( node >= 1 ) : NEW_LINE INDENT print ( node , end = " ▁ " ) NEW_LINE node //= 2 NEW_LINE DEDENT DEDENT
def minValue ( arr , n ) : NEW_LINE INDENT minimum = min ( arr ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] - minimum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countEvenPairs ( N , M ) : NEW_LINE INDENT count = 0 ; NEW_LINE nEven = int ( math . floor ( N / 2 ) ) ; NEW_LINE nOdd = int ( math . ceil ( N / 2 ) ) ; NEW_LINE mEven = int ( math . floor ( M / 2 ) ) ; NEW_LINE mOdd = int ( math . ceil ( M / 2 ) ) ; NEW_LINE count = nEven * mEven + nOdd * mOdd ; NEW_LINE return count ; NEW_LINE DEDENT
def string_palindrome ( N , K ) : NEW_LINE INDENT for i in range ( K ) : NEW_LINE INDENT print ( " a " , end = " " ) NEW_LINE DEDENT s = " bcd " NEW_LINE for i in range ( N - K ) : NEW_LINE INDENT print ( s [ i % 3 ] , end = " " ) NEW_LINE DEDENT DEDENT
def lastRemovedCharacter ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return ord ( str [ 0 ] ) NEW_LINE DEDENT if ( str [ n - 2 ] == '0' ) : NEW_LINE INDENT return ( ord ( '1' ) - ord ( str [ n - 1 ] ) + ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( str [ n - 1 ] ) NEW_LINE DEDENT DEDENT
def findNumbers ( aXORb , aANDb , aXORc , aANDc , bXORc , bANDc ) : NEW_LINE INDENT a , b , c = 0 , 0 , 0 ; NEW_LINE aSUMb = 0 ; NEW_LINE aSUMc = 0 ; NEW_LINE bSUMc = 0 ; NEW_LINE aSUMb = aXORb + aANDb * 2 ; NEW_LINE aSUMc = aXORc + aANDc * 2 ; NEW_LINE bSUMc = bXORc + bANDc * 2 ; NEW_LINE a = ( aSUMb - bSUMc + aSUMc ) // 2 ; NEW_LINE b = aSUMb - a ; NEW_LINE c = aSUMc - a ; NEW_LINE print ( " a ▁ = ▁ " , a , end = " " ) ; NEW_LINE print ( " , ▁ b ▁ = ▁ " , b , end = " " ) ; NEW_LINE print ( " , ▁ c ▁ = ▁ " , c , end = " " ) ; NEW_LINE DEDENT
def findNumber ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( ( N & 1 ) == 1 ) : NEW_LINE INDENT N = N >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return N << count NEW_LINE DEDENT
def findNumber ( N ) : NEW_LINE INDENT return N & ( N + 1 ) NEW_LINE DEDENT
def countNumberOfStrings ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE n = length - 1 NEW_LINE count = 2 ** n NEW_LINE return count NEW_LINE DEDENT
def findBitwiseORGivenXORAND ( X , Y ) : NEW_LINE INDENT return X + Y NEW_LINE DEDENT
def minimumcntOperationReq ( arr , N ) : NEW_LINE INDENT cntOp = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT cntOp += 1 NEW_LINE DEDENT DEDENT return ( cntOp + 1 ) // 2 NEW_LINE DEDENT
def isSequenceValid ( B , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( ( i + 1 ) % B [ i ] != 0 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Yes " ) NEW_LINE DEDENT
def ConstArrayAdjacentCoprime ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minimumCost ( a , b ) : NEW_LINE INDENT fre1 = [ 0 ] * ( 256 ) NEW_LINE fre2 = [ 0 ] * ( 256 ) NEW_LINE for c in a : NEW_LINE INDENT fre1 [ ord ( c ) ] += 1 NEW_LINE DEDENT for c in b : NEW_LINE INDENT fre2 [ ord ( c ) ] += 1 NEW_LINE DEDENT mincost = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT mincost += abs ( fre1 [ i ] - fre2 [ i ] ) NEW_LINE DEDENT print ( mincost ) NEW_LINE DEDENT
def minCost ( arr ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT print ( min ( even , odd ) ) NEW_LINE DEDENT
def bitonicSequence ( num , lower , upper ) : NEW_LINE INDENT if ( num > ( upper - lower ) * 2 + 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT ans = deque ( ) NEW_LINE for i in range ( min ( upper - lower + 1 , num - 1 ) ) : NEW_LINE INDENT ans . append ( upper - i ) NEW_LINE DEDENT for i in range ( num - len ( ans ) ) : NEW_LINE INDENT ans . appendleft ( upper - i - 1 ) NEW_LINE DEDENT print ( list ( ans ) ) NEW_LINE DEDENT
def checkCount ( A , Q , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT L = Q [ i ] [ 0 ] NEW_LINE R = Q [ i ] [ 1 ] NEW_LINE L -= 1 NEW_LINE R -= 1 NEW_LINE if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def findPairs ( N ) : NEW_LINE INDENT for i in range ( 0 , N + 1 ) : NEW_LINE INDENT print ( " ( " , i , " , " , N - i , " ) , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
def longestSubsequence ( arr , N ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def findXandYwithminABSX_Y ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( ( N // 2 ) , ( N // 2 + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( N // 2 - 1 ) , ( N // 2 + 1 ) ) NEW_LINE DEDENT DEDENT
def minSteps ( S ) : NEW_LINE INDENT new_str = " " NEW_LINE N = len ( S ) NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT new_str += S [ i ] NEW_LINE j = i NEW_LINE while ( i < N and S [ i ] == S [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( ceil ( ( len ( new_str ) + 1 ) / 2 ) ) NEW_LINE DEDENT
def MaximumSides ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT if ( ( n & n - 1 ) != 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def countOfSubarray ( arr , N ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE answer = 0 NEW_LINE sum = 0 NEW_LINE mp [ 1 ] += 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE answer += mp [ sum - i ] NEW_LINE mp [ sum - i ] += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT
def Moves_Calculator ( x , y , row , col ) : NEW_LINE INDENT total_moves = 0 NEW_LINE if ( row - x ) > 0 and ( col - y ) > 0 : NEW_LINE INDENT total_moves += min ( ( row - x ) , ( col - y ) ) NEW_LINE DEDENT if ( y - 1 ) > 0 and ( x - 1 ) > 0 : NEW_LINE INDENT total_moves += min ( ( y - 1 ) , ( x - 1 ) ) NEW_LINE DEDENT if ( x - 1 ) > 0 and ( col - y ) > 0 : NEW_LINE INDENT total_moves += min ( ( x - 1 ) , ( col - y ) ) NEW_LINE DEDENT if ( row - x ) > 0 and ( y - 1 ) > 0 : NEW_LINE INDENT total_moves += min ( ( row - x ) , ( y - 1 ) ) NEW_LINE DEDENT total_moves += ( row - 1 ) + ( col - 1 ) NEW_LINE king_moves = 0 NEW_LINE if x + 1 <= m : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if y + 1 <= n : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if y - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x + 1 <= m and y + 1 <= n : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x + 1 <= m and y - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x - 1 > 0 and y - 1 > 0 : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT if x - 1 > 0 and y + 1 <= n : NEW_LINE INDENT king_moves += 1 NEW_LINE DEDENT return total_moves - king_moves NEW_LINE DEDENT
def clstNum ( N ) : NEW_LINE INDENT return ( N - 1 ) NEW_LINE DEDENT
def equvInverse ( arr , N , P ) : NEW_LINE INDENT cntElem = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) : NEW_LINE INDENT cntElem = cntElem + 1 NEW_LINE DEDENT DEDENT return cntElem NEW_LINE DEDENT
def pairProductMean ( arr , N ) : NEW_LINE INDENT pairArray = [ ] ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT pairProduct = arr [ i ] * arr [ j ] ; NEW_LINE pairArray . append ( pairProduct ) ; NEW_LINE DEDENT DEDENT length = len ( pairArray ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT sum += pairArray [ i ] ; NEW_LINE DEDENT mean = 0 ; NEW_LINE if ( length != 0 ) : NEW_LINE INDENT mean = sum / length ; NEW_LINE DEDENT else : NEW_LINE INDENT mean = 0 ; NEW_LINE DEDENT return mean ; NEW_LINE DEDENT
def minProduct ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , ( n - 4 ) // 2 + 1 ) : NEW_LINE INDENT ans = ( ans * ( n - 2 ) ) % mod NEW_LINE DEDENT ans = ( ans * ( n - 2 ) * ( n - 1 ) ) % mod NEW_LINE print ( int ( ans ) ) NEW_LINE DEDENT
def TotalXorPair ( arr , N ) : NEW_LINE INDENT totalXOR = 0 ; NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT totalXOR ^= arr [ i ] ^ arr [ j ] ; NEW_LINE DEDENT DEDENT return totalXOR ; NEW_LINE DEDENT
def minAbsDiff ( N ) : NEW_LINE INDENT sumSet1 = 0 NEW_LINE sumSet2 = 0 NEW_LINE for i in reversed ( range ( N + 1 ) ) : NEW_LINE INDENT if sumSet1 <= sumSet2 : NEW_LINE sumSet1 = sumSet1 + i NEW_LINE else : NEW_LINE sumSet2 = sumSet2 + i NEW_LINE DEDENT return abs ( sumSet1 - sumSet2 ) NEW_LINE DEDENT
def minAbsDiff ( N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def possibleAcyclicGraph ( N ) : NEW_LINE INDENT print ( pow ( 2 , N - 1 ) ) NEW_LINE return NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT countPowerof2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == 1 ) : NEW_LINE INDENT countPowerof2 += 1 NEW_LINE DEDENT DEDENT desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) // 2 NEW_LINE print ( desiredPairs ) NEW_LINE DEDENT
def minProd ( X , Y , N ) : NEW_LINE INDENT if ( X <= Y ) : NEW_LINE INDENT if ( N < X ) : NEW_LINE INDENT return ( X - N ) * Y NEW_LINE DEDENT else : NEW_LINE INDENT return max ( Y - ( N - X + 1 ) , 1 ) NEW_LINE DEDENT DEDENT if ( Y >= N ) : NEW_LINE INDENT return ( Y - N ) * X NEW_LINE DEDENT return max ( X - ( N - Y + 1 ) , 1 ) NEW_LINE DEDENT
def condition ( a , b ) : NEW_LINE INDENT d = abs ( a - b ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT if i * i > d : NEW_LINE INDENT break NEW_LINE DEDENT if ( d % i == 0 ) : NEW_LINE INDENT if ( d // i == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def find_next ( n , k ) : NEW_LINE INDENT M = n + 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( ( M & ( 1 << k ) ) > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT M += 1 ; NEW_LINE DEDENT return M ; NEW_LINE DEDENT
def maximumSubarrays ( arr , N , target ) : NEW_LINE INDENT ans = 0 NEW_LINE availIdx = - 1 NEW_LINE cur_sum = 0 NEW_LINE mp = { } NEW_LINE mp [ 0 ] = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cur_sum += arr [ i ] NEW_LINE if ( ( cur_sum - target ) in mp and mp [ cur_sum - target ] >= availIdx ) : NEW_LINE INDENT ans += 1 NEW_LINE availIdx = i NEW_LINE DEDENT mp [ cur_sum ] = i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def factorsOf3 ( arr , N ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 3 == 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( arr [ i ] % 3 == 1 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT elif ( arr [ i ] % 3 == 2 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( a >= 1 and a <= b + c + 1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif ( a == 0 and b == 0 and c > 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif ( a == 0 and c == 0 and b > 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def maxBottles ( n , e ) : NEW_LINE INDENT s = 0 NEW_LINE b = 0 NEW_LINE a = n NEW_LINE while ( a != 0 ) : NEW_LINE INDENT s = s + a NEW_LINE a = ( a + b ) // e NEW_LINE b = n - ( a * e ) NEW_LINE n = a + b NEW_LINE DEDENT return s NEW_LINE DEDENT
def getPosition ( N , M ) : NEW_LINE INDENT if ( M > ( N // 2 ) ) : NEW_LINE INDENT return ( M - ( N // 2 ) ) NEW_LINE DEDENT return ( M + ( N // 2 ) ) NEW_LINE DEDENT
def clearLastBit ( N , K ) : NEW_LINE INDENT mask = ( - 1 << K + 1 ) NEW_LINE N = N & mask NEW_LINE return N NEW_LINE DEDENT
def findWinner ( a , n ) : NEW_LINE INDENT win = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT win = 1 NEW_LINE DEDENT else : NEW_LINE INDENT win = 0 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT if ( win == 0 and a [ i ] > 1 ) : NEW_LINE INDENT win = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( win == 1 and a [ i ] > 1 ) : NEW_LINE INDENT win = 0 NEW_LINE DEDENT DEDENT DEDENT if ( win == 0 ) : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT DEDENT
def isPossible ( r , b , g ) : NEW_LINE INDENT r = r % 3 NEW_LINE b = b % 3 NEW_LINE g = g % 3 NEW_LINE if ( r == b or b == g or g == r ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT R = 1 NEW_LINE B = 3 NEW_LINE G = 6 NEW_LINE if ( isPossible ( R , B , G ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isReachable ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT while ( x2 > x1 and y2 > y1 ) : NEW_LINE INDENT if ( x2 > y2 ) : NEW_LINE INDENT x2 %= y2 NEW_LINE DEDENT else : NEW_LINE INDENT y2 %= x2 NEW_LINE DEDENT DEDENT if ( x2 == x1 ) : NEW_LINE INDENT return ( y2 - y1 ) >= 0 and ( y2 - y1 ) % x1 == 0 NEW_LINE DEDENT elif ( y2 == y1 ) : NEW_LINE INDENT return ( x2 - x1 ) >= 0 and ( x2 - x1 ) % y1 == 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT source_x = 2 NEW_LINE source_y = 10 NEW_LINE dest_x = 26 NEW_LINE dest_y = 12 NEW_LINE if ( isReachable ( source_x , source_y , dest_x , dest_y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minLength ( A , N ) : NEW_LINE INDENT elem = A [ 0 ] NEW_LINE count = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( A [ i ] == elem ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( count == N ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def checkWinner ( N , K ) : NEW_LINE INDENT if ( N % ( K + 1 ) ) : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT DEDENT
def findMaxSoln ( n , x , y ) : NEW_LINE INDENT ans = - sys . maxsize NEW_LINE for k in range ( n + 1 ) : NEW_LINE INDENT if ( k % x == y ) : NEW_LINE INDENT ans = max ( ans , k ) NEW_LINE DEDENT DEDENT return ( ans if ( ans >= 0 and ans <= n ) else - 1 ) NEW_LINE DEDENT
def getMinOps ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def getCount ( N , M ) : NEW_LINE INDENT total_count = 0 NEW_LINE total_count += N // 10 NEW_LINE x = ( N // 10 ) * 10 NEW_LINE if ( ( N - x ) >= M ) : NEW_LINE INDENT total_count = total_count + 1 NEW_LINE DEDENT return total_count NEW_LINE DEDENT
def printMissingElements ( arr , N ) : NEW_LINE INDENT diff = arr [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] - i != diff ) : NEW_LINE INDENT while ( diff < arr [ i ] - i ) : NEW_LINE INDENT print ( i + diff , end = " ▁ " ) NEW_LINE diff += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countNestedPolygons ( sides ) : NEW_LINE INDENT count = 0 NEW_LINE while ( sides > 5 ) : NEW_LINE INDENT sides //= 2 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minCost ( str , a , b ) : NEW_LINE INDENT openUnbalanced = 0 ; NEW_LINE closedUnbalanced = 0 ; NEW_LINE openCount = 0 ; NEW_LINE closedCount = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT openUnbalanced += 1 ; NEW_LINE openCount += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( openUnbalanced == 0 ) : NEW_LINE INDENT closedUnbalanced += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT openUnbalanced -= 1 ; NEW_LINE DEDENT closedCount += 1 ; NEW_LINE DEDENT DEDENT result = a * ( abs ( openCount - closedCount ) ) ; NEW_LINE if ( closedCount > openCount ) : NEW_LINE INDENT closedUnbalanced -= ( closedCount - openCount ) ; NEW_LINE DEDENT if ( openCount > closedCount ) : NEW_LINE INDENT openUnbalanced -= ( openCount - closedCount ) ; NEW_LINE DEDENT result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; NEW_LINE print ( result ) ; NEW_LINE DEDENT
def mindigits ( n ) : NEW_LINE INDENT if ( n % 9 == 0 ) : NEW_LINE INDENT print ( n // 9 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n // 9 ) + 1 ) ; NEW_LINE DEDENT DEDENT
def countOfSubarray ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] -= 1 NEW_LINE DEDENT pref = [ 0 ] * N NEW_LINE pref [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + arr [ i ] NEW_LINE DEDENT mp = defaultdict ( lambda : 0 ) NEW_LINE answer = 0 NEW_LINE mp [ 0 ] += 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT answer += mp [ pref [ i ] ] NEW_LINE mp [ pref [ i ] ] += 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT
def printsubset ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE x = 0 NEW_LINE vec = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = n & 1 NEW_LINE if ( x ) : NEW_LINE INDENT vec . append ( pow ( k , count ) ) NEW_LINE DEDENT n = n >> 1 NEW_LINE count += 1 NEW_LINE DEDENT for item in vec : NEW_LINE INDENT print ( item , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def checkEquall ( arr , N ) : NEW_LINE INDENT sumEven , sumOdd = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sumOdd += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sumEven += arr [ i ] NEW_LINE DEDENT DEDENT if ( sumEven == sumOdd ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def countEvenSum ( low , high , k ) : NEW_LINE INDENT even_count = high / 2 - ( low - 1 ) / 2 NEW_LINE odd_count = ( high + 1 ) / 2 - low / 2 NEW_LINE even_sum = 1 NEW_LINE odd_sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT prev_even = even_sum NEW_LINE prev_odd = odd_sum NEW_LINE even_sum = ( ( prev_even * even_count ) + ( prev_odd * odd_count ) ) NEW_LINE odd_sum = ( ( prev_even * odd_count ) + ( prev_odd * even_count ) ) NEW_LINE DEDENT print ( int ( even_sum ) ) NEW_LINE DEDENT
def incrementCount ( arr , N ) : NEW_LINE INDENT mini = arr [ 0 ] - arr [ 1 ] NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT mini = min ( mini , arr [ i - 1 ] - arr [ i ] ) NEW_LINE DEDENT print ( mini ) NEW_LINE DEDENT
def Length_Diagonals ( a , theta ) : NEW_LINE INDENT p = a * math . sqrt ( 2 + ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE q = a * math . sqrt ( 2 - ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT
def maxORminusXOR ( N ) : NEW_LINE INDENT MSB = int ( math . log2 ( N ) ) ; NEW_LINE M = 0 NEW_LINE for i in range ( MSB + 1 ) : NEW_LINE INDENT M += ( 1 << i ) NEW_LINE DEDENT return M NEW_LINE DEDENT
def No_of_Triangle ( N , K ) : NEW_LINE INDENT if ( N < K ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT Tri_up = 0 ; NEW_LINE Tri_up = ( ( N - K + 1 ) * ( N - K + 2 ) ) // 2 ; NEW_LINE Tri_down = 0 ; NEW_LINE Tri_down = ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) // 2 ; NEW_LINE return Tri_up + Tri_down ; NEW_LINE DEDENT DEDENT
def findPair ( A , B , N ) : NEW_LINE INDENT X = N - B + A NEW_LINE if ( X % 2 != 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT X = X // 2 NEW_LINE Y = N - X NEW_LINE print ( X , Y ) NEW_LINE DEDENT DEDENT
def check ( a , n ) : NEW_LINE INDENT ma = a [ 1 ] - a [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( ( a [ i ] > a [ i - 1 ] and a [ i + 1 ] < a [ i ] ) or ( a [ i ] < a [ i - 1 ] and a [ i + 1 ] > a [ i ] ) ) : NEW_LINE INDENT ma = max ( ma , abs ( a [ i ] - a [ i + 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT print ( " Amplitude ▁ = ▁ " , ma ) NEW_LINE return True NEW_LINE DEDENT
def countSetBits ( L , R ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT n = i ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += ( n & 1 ) ; NEW_LINE n = n >> 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def countElement ( A , N , B , M , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT currentElement = B [ i ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT diff = abs ( currentElement - A [ j ] ) NEW_LINE if ( diff <= K ) : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT
def AreaofRectangle ( L , W ) : NEW_LINE INDENT area = ( W + L ) * ( W + L ) / 2 NEW_LINE return area NEW_LINE DEDENT
def downToZero ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n NEW_LINE DEDENT dp = [ - 1 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 2 NEW_LINE dp [ 3 ] = 3 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT sqr = ( int ) ( math . sqrt ( i ) ) NEW_LINE best = sys . maxsize NEW_LINE while ( sqr > 1 ) : NEW_LINE INDENT if ( i % sqr == 0 ) : NEW_LINE INDENT best = min ( best , 1 + dp [ sqr ] ) NEW_LINE DEDENT sqr -= 1 NEW_LINE DEDENT best = min ( best , 1 + dp [ i - 1 ] ) NEW_LINE dp [ i ] = best NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def downToZero ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 4 ; NEW_LINE DEDENT DEDENT
def getMinCost ( A , B , N ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT mini = min ( mini , min ( A [ i ] , B [ i ] ) ) NEW_LINE DEDENT return mini * ( 2 * N - 1 ) NEW_LINE DEDENT
def solve ( n , arr ) : NEW_LINE INDENT s = ' a ' * ( n ) NEW_LINE ans = [ ] NEW_LINE ans . append ( s ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if len ( s ) - 1 >= arr [ i ] : NEW_LINE ch = s [ arr [ i ] ] NEW_LINE if ( ch == ' b ' ) : NEW_LINE INDENT ch = ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT ch = ' b ' NEW_LINE DEDENT p = list ( s ) NEW_LINE p [ arr [ i ] ] = ch NEW_LINE s = ' ' . join ( p ) NEW_LINE ans . append ( s ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSwaps ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE ind , res = 1 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( ind < n and A [ ind ] == A [ i ] ) : NEW_LINE INDENT ind += 1 NEW_LINE DEDENT if ( ind < n and A [ ind ] > A [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE ind += 1 NEW_LINE DEDENT if ( ind >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countSwaps ( A , n ) : NEW_LINE INDENT mp = { } NEW_LINE max_frequency = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT max_frequency = max ( max_frequency , mp [ A [ i ] ] ) NEW_LINE DEDENT return n - max_frequency NEW_LINE DEDENT
def min_operation ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def find ( n ) : NEW_LINE INDENT print ( n // 2 ) NEW_LINE DEDENT
def maxSubsequences ( arr , n ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE maxCount = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT count = m [ arr [ i ] ] NEW_LINE if count > 1 : NEW_LINE INDENT m [ arr [ i ] ] = count - 1 NEW_LINE DEDENT else : NEW_LINE INDENT m . pop ( arr [ i ] ) NEW_LINE DEDENT if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxCount += 1 NEW_LINE DEDENT maxCount += 1 NEW_LINE INDENT if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT return maxCount NEW_LINE DEDENT
def count ( n , k ) : NEW_LINE INDENT count = ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; NEW_LINE print ( count ) ; NEW_LINE DEDENT
def sumOfFactors ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT first = i NEW_LINE last = ( N // i ) * i NEW_LINE factors = ( last - first ) // i + 1 NEW_LINE totalContribution = ( ( ( factors * ( factors + 1 ) ) // 2 ) * i ) NEW_LINE ans += totalContribution NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findAandB ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT a = N * N / ( N - 1 ) NEW_LINE b = a / N NEW_LINE print ( " a ▁ = ▁ " , a ) NEW_LINE print ( " b ▁ = ▁ " , b ) NEW_LINE DEDENT
def maxSelections ( A , n , k ) : NEW_LINE INDENT A . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + A [ i ] ; NEW_LINE if ( sum > k ) : NEW_LINE break ; NEW_LINE count += 1 ; NEW_LINE return count ; NEW_LINE DEDENT DEDENT
def computePair ( K ) : NEW_LINE INDENT if ( K == 1 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT print ( K * K / ( K - 1 ) , end = " ▁ " ) NEW_LINE print ( K / ( K - 1 ) ) NEW_LINE DEDENT DEDENT
def getMaxDifference ( N ) : NEW_LINE INDENT M = - 1 ; NEW_LINE maxDiff = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT diff = ( N ^ i ) - ( N & i ) ; NEW_LINE if ( diff >= maxDiff ) : NEW_LINE INDENT maxDiff = diff ; NEW_LINE M = i ; NEW_LINE DEDENT DEDENT return M ; NEW_LINE DEDENT
def findM ( N ) : NEW_LINE INDENT M = 0 ; NEW_LINE MSB = int ( math . log ( N ) ) ; NEW_LINE for i in range ( MSB ) : NEW_LINE INDENT if ( ( N & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT M += ( 1 << i ) ; NEW_LINE DEDENT DEDENT return M ; NEW_LINE DEDENT
def countStrings ( A , B , K ) : NEW_LINE INDENT X = ( A + B ) // ( K + 1 ) NEW_LINE return ( min ( A , min ( B , X ) ) * ( K + 1 ) ) NEW_LINE DEDENT
def findShifts ( A , N ) : NEW_LINE INDENT shift = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == A [ i ] - 1 ) : NEW_LINE INDENT shift [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT shift [ i ] = ( A [ i ] - 1 - i + N ) % N NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( shift [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def isDivisible ( N ) : NEW_LINE INDENT return ( N - 1 ) % 3 != 0 NEW_LINE DEDENT
def calculate ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( len ( arr ) ) : NEW_LINE INDENT sum += abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT ans . append ( sum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def no_of_moves ( Matrix , x , y ) : NEW_LINE INDENT moves = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( Matrix [ i ] [ j ] != 0 ) : NEW_LINE INDENT moves += abs ( x - i ) NEW_LINE moves += abs ( y - j ) NEW_LINE DEDENT DEDENT DEDENT print ( moves ) NEW_LINE DEDENT
def is_linear ( s ) : NEW_LINE INDENT tmp = 0 NEW_LINE first = s [ 0 ] NEW_LINE pos = 0 NEW_LINE while pos < len ( s ) : NEW_LINE INDENT if ( s [ pos ] != first ) : NEW_LINE INDENT return False NEW_LINE DEDENT tmp += 1 NEW_LINE pos += tmp NEW_LINE DEDENT return True NEW_LINE DEDENT
def calculateWays ( arr1 , arr2 , N ) : NEW_LINE INDENT A = arr2 [ 0 ] NEW_LINE B = arr2 [ 1 ] NEW_LINE C = arr2 [ 2 ] NEW_LINE D = arr2 [ 3 ] NEW_LINE ans , b , c , d = 0 , 0 , 0 , 0 NEW_LINE while b <= B and b * 5 <= ( N ) : NEW_LINE INDENT c = 0 NEW_LINE while ( c <= C and b * 5 + c * 10 <= ( N ) ) : NEW_LINE INDENT d = 0 NEW_LINE while ( d <= D and b * 5 + c * 10 + d * 20 <= ( N ) ) : NEW_LINE INDENT if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT c += 1 NEW_LINE DEDENT b += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def removeAll ( arr , n ) : NEW_LINE INDENT if arr [ 0 ] < arr [ n - 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def minNum ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 210 * ( 10 ** ( n - 1 ) // 210 + 1 ) ) NEW_LINE DEDENT DEDENT
def numberOfPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( i + j ) == n : NEW_LINE count += 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def numberOfPairs ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return n // 2 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n // 2 ; NEW_LINE DEDENT DEDENT
def find_max ( n , k ) : NEW_LINE INDENT X = [ 0 ] * 32 NEW_LINE cnt = 0 NEW_LINE i = 31 NEW_LINE while ( i >= 0 and cnt != k ) : NEW_LINE INDENT if ( ( n & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT X [ i ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT s = " " NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if X [ i ] == 0 : NEW_LINE INDENT s += '0' NEW_LINE DEDENT else : NEW_LINE INDENT s += '1' NEW_LINE DEDENT DEDENT return int ( s , 2 ) NEW_LINE DEDENT
def get_palindrome_time ( str ) : NEW_LINE INDENT hh = ( ( ord ( str [ 0 ] ) - 48 ) * 10 + ( ord ( str [ 1 ] ) - 48 ) ) NEW_LINE mm = ( ( ord ( str [ 3 ] ) - 48 ) * 10 + ( ord ( str [ 4 ] ) - 48 ) ) NEW_LINE requiredTime = 0 NEW_LINE while ( hh % 10 != mm // 10 or hh // 10 != mm % 10 ) : NEW_LINE INDENT mm += 1 NEW_LINE if ( mm == 60 ) : NEW_LINE INDENT mm = 0 NEW_LINE hh += 1 NEW_LINE DEDENT if ( hh == 24 ) : NEW_LINE INDENT hh = 0 NEW_LINE DEDENT requiredTime += 1 ; NEW_LINE DEDENT return requiredTime NEW_LINE DEDENT
def Solve ( N , M ) : NEW_LINE INDENT temp = ( N - 1 ) * ( M - 1 ) NEW_LINE ans = pow ( 2 , temp ) NEW_LINE if ( ( N + M ) % 2 != 0 ) : NEW_LINE INDENT print ( ans ) NEW_LINE else : NEW_LINE print ( 2 * ans ) NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , M = 3 , 3 NEW_LINE Solve ( N , M ) NEW_LINE DEDENT DEDENT DEDENT
def minPoints ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( ( n % 2 != 0 ) and ( m % 2 != 0 ) ) : NEW_LINE INDENT ans = ( ( n * m ) // 2 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( n * m ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxProfit ( prices , n ) : NEW_LINE INDENT profit = 0 NEW_LINE currentDay = n - 1 NEW_LINE while ( currentDay > 0 ) : NEW_LINE INDENT day = currentDay - 1 NEW_LINE while ( day >= 0 and ( prices [ currentDay ] > prices [ day ] ) ) : NEW_LINE INDENT profit += ( prices [ currentDay ] - prices [ day ] ) NEW_LINE day -= 1 NEW_LINE DEDENT currentDay = day ; NEW_LINE DEDENT return profit ; NEW_LINE DEDENT
def findDirection ( n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT if ( m % 2 == 0 ) : NEW_LINE INDENT print ( " Up " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Down " ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Left " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Right " ) ; NEW_LINE DEDENT DEDENT DEDENT
def createArray ( n , s ) : NEW_LINE INDENT if ( 2 * n <= s ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE s -= 2 NEW_LINE DEDENT print ( s ) NEW_LINE print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT
def maxModulosum ( a , n ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 += a [ i ] ; NEW_LINE DEDENT return sum1 - n ; NEW_LINE DEDENT
def findAns ( mat , x , y , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT ans += ( abs ( x - i ) + abs ( y - j ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( n , m , x , y , d ) : NEW_LINE INDENT top = min ( d , x - 1 ) NEW_LINE down = min ( d , n - x ) NEW_LINE left = min ( d , y - 1 ) NEW_LINE right = min ( d , m - y ) NEW_LINE quad1 = top * left NEW_LINE quad2 = left * down NEW_LINE quad3 = down * right NEW_LINE quad4 = right * top NEW_LINE totalsq = ( quad1 + quad2 + quad3 + quad4 ) NEW_LINE singleBlocks = ( top + down + left + right + 1 ) NEW_LINE return totalsq + singleBlocks NEW_LINE DEDENT
def get_last_two_digit ( N ) : NEW_LINE INDENT if ( N % 4 == 0 ) : NEW_LINE INDENT return "01" ; NEW_LINE DEDENT elif ( N % 4 == 1 ) : NEW_LINE INDENT return "07" ; NEW_LINE DEDENT elif ( N % 4 == 2 ) : NEW_LINE INDENT return "49" ; NEW_LINE DEDENT return "43" ; NEW_LINE DEDENT
def isSubseqPossible ( arr , N , K ) : NEW_LINE INDENT i = 0 NEW_LINE odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd == 0 or ( even == 0 and K % 2 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def minimumCost ( arr , cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE dp [ 0 ] [ 1 ] = cost [ 0 ] NEW_LINE dp [ 0 ] [ 2 ] = cost [ 0 ] * 2 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT minimum = 1e6 NEW_LINE if ( j + arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ 0 ] ) NEW_LINE DEDENT if ( j + arr [ i ] != arr [ i - 1 ] + 1 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ 1 ] ) NEW_LINE DEDENT if ( j + arr [ i ] != arr [ i - 1 ] + 2 ) : NEW_LINE INDENT minimum = min ( minimum , dp [ i - 1 ] [ 2 ] ) NEW_LINE DEDENT dp [ i ] [ j ] = j * cost [ i ] + minimum NEW_LINE DEDENT DEDENT ans = 1e6 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT ans = min ( ans , dp [ N - 1 ] [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def makeZero ( x , y , a , b ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT tot_cost = ( y - x ) * a NEW_LINE cost1 = 2 * x * a NEW_LINE cost2 = x * b NEW_LINE tot_cost += min ( cost1 , cost2 ) NEW_LINE print ( tot_cost ) NEW_LINE DEDENT
def count_triangles ( a , b , c , d ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( a , b + 1 ) : NEW_LINE INDENT num_greater_than_d = ( max ( d , c + x ) - max ( d , b + x - 1 ) ) NEW_LINE ans = ( ans + num_greater_than_d * ( d - c + 1 ) ) NEW_LINE r = min ( max ( c , c + x ) , d ) - c ; NEW_LINE l = min ( max ( c , b + x - 1 ) , d ) - c ; NEW_LINE x1 = int ( ( r * ( r + 1 ) ) / 2 ) NEW_LINE x2 = int ( ( l * ( l + 1 ) ) / 2 ) NEW_LINE ans = ans + ( x1 - x2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def check ( S , prices , type1 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( type1 [ j ] == 0 and type1 [ k ] == 1 ) or ( type1 [ j ] == 1 and type1 [ k ] == 0 ) ) : NEW_LINE INDENT if ( prices [ j ] + prices [ k ] <= S ) : NEW_LINE INDENT return " Yes " ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return " No " ; NEW_LINE DEDENT
def numPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ j ] % arr [ i ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def maxRemainingSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE result = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT result += sum ; NEW_LINE DEDENT return result NEW_LINE DEDENT
def longestSubsequence ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE answer = 0 ; NEW_LINE prev = ' - ' ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( prev != s [ i ] ) : NEW_LINE INDENT prev = s [ i ] ; NEW_LINE answer += 1 ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT
def MinDiff ( n ) : NEW_LINE INDENT val = 2 ** n NEW_LINE sep = n // 2 NEW_LINE grp1 = 0 NEW_LINE grp2 = 0 NEW_LINE grp1 = grp1 + val NEW_LINE for i in range ( 1 , sep ) : NEW_LINE INDENT grp1 = grp1 + 2 ** i NEW_LINE DEDENT for i in range ( sep , n ) : NEW_LINE INDENT grp2 = grp2 + 2 ** i NEW_LINE DEDENT print ( abs ( grp1 - grp2 ) ) NEW_LINE DEDENT
def minOccupiedPosition ( A , n ) : NEW_LINE INDENT minPos = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( A [ i ] > 0 ) : NEW_LINE INDENT minPos += 1 NEW_LINE i += 2 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return minPos NEW_LINE DEDENT
def minOperations ( a , b , n ) : NEW_LINE INDENT minA = min ( a ) ; NEW_LINE for x in range ( minA , - 1 , - 1 ) : NEW_LINE INDENT check = True ; NEW_LINE operations = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x % b [ i ] == a [ i ] % b [ i ] ) : NEW_LINE INDENT operations += ( a [ i ] - x ) / b [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT check = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( check ) : NEW_LINE INDENT return operations ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
def findMinimumK ( a , n , S ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return math . ceil ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) NEW_LINE DEDENT
def MinimumValue ( a , n ) : NEW_LINE INDENT answer = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT answer = min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def MinimumValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE minXor = sys . maxsize ; NEW_LINE val = 0 ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] ; NEW_LINE minXor = min ( minXor , val ) ; NEW_LINE DEDENT return minXor ; NEW_LINE DEDENT
def largestNum ( n ) : NEW_LINE INDENT num = 0 ; NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT x = ( 1 << i ) ; NEW_LINE if ( ( x - 1 ) <= n ) : NEW_LINE INDENT num = ( 1 << i ) - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return num ; NEW_LINE DEDENT
def findString ( N , K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( chr ( ord ( ' A ' ) + i % K ) , end = " " ) ; NEW_LINE DEDENT DEDENT
def getLargestSum ( N ) : NEW_LINE INDENT max_sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( i * j % ( i + j ) == 0 ) : NEW_LINE INDENT max_sum = max ( max_sum , i + j ) NEW_LINE DEDENT DEDENT DEDENT return max_sum NEW_LINE DEDENT
def getLargestSum ( N ) : NEW_LINE INDENT for i in range ( 1 , int ( N ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( N ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT k = N // j ; NEW_LINE a = k * i ; NEW_LINE b = k * j ; NEW_LINE if ( a <= N and b <= N and a * b % ( a + b ) == 0 ) : NEW_LINE INDENT max_sum = max ( max_sum , a + b ) ; NEW_LINE DEDENT DEDENT DEDENT return max_sum ; NEW_LINE DEDENT
def findSum ( L , R ) : NEW_LINE INDENT arr = [ ] NEW_LINE i = 0 NEW_LINE x = 2 NEW_LINE k = 0 NEW_LINE while ( i <= R ) : NEW_LINE INDENT arr . insert ( k , i + x ) NEW_LINE k += 1 NEW_LINE if ( i + 1 <= R ) : NEW_LINE INDENT arr . insert ( k , i + 1 + x ) NEW_LINE DEDENT k += 1 NEW_LINE x *= - 1 NEW_LINE i += 2 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT
def count ( s ) : NEW_LINE INDENT cnt , ans = 0 , 0 NEW_LINE N = len ( s ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == ' R ' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( s [ i ] == ' L ' ) : NEW_LINE INDENT ans += cnt NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE answer = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] ; NEW_LINE DEDENT return answer * ( 2 * k - 2 ) ; NEW_LINE DEDENT
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def distinctSubstring ( P , N ) : NEW_LINE INDENT S = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ False ] * 26 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE if ( freq [ pos ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT freq [ pos ] = True NEW_LINE s += P [ j ] NEW_LINE S [ s ] = 1 NEW_LINE DEDENT DEDENT return len ( S ) NEW_LINE DEDENT
def calcSum ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , k + i ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maxValue ( arr , n , moves ) : NEW_LINE INDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT distance = n - 1 - i NEW_LINE if ( moves < distance ) : NEW_LINE INDENT break NEW_LINE DEDENT can_take = moves // distance NEW_LINE take = min ( arr [ i ] , can_take ) NEW_LINE arr [ n - 1 ] += take NEW_LINE moves -= take * distance NEW_LINE DEDENT DEDENT return arr [ n - 1 ] NEW_LINE DEDENT
def findLCS ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return len ( mp ) NEW_LINE DEDENT
def countPairs ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE pair = 0 NEW_LINE index = 0 NEW_LINE while ( index < len ( arr ) - 1 ) : NEW_LINE INDENT if arr [ index + 1 ] - arr [ index ] <= k : NEW_LINE INDENT pair += 1 NEW_LINE index += 2 NEW_LINE DEDENT else : NEW_LINE INDENT index += 1 NEW_LINE DEDENT DEDENT return pair NEW_LINE DEDENT
def minOperations ( n , m ) : NEW_LINE INDENT a = 0 ; k = 1 ; NEW_LINE p = max ( n , m ) ; NEW_LINE while ( n != m ) : NEW_LINE INDENT s = float ( p - n + p - m ) ; NEW_LINE q = ( - 1 + sqrt ( 8 * s + 1 ) ) / 2 ; NEW_LINE if ( q - floor ( q ) == 0 ) : NEW_LINE INDENT a = q ; NEW_LINE n = m ; NEW_LINE DEDENT p = p + 1 ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT
def minCost ( cost , n ) : NEW_LINE INDENT totalCost = 0 NEW_LINE boardingBus = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( cost [ boardingBus ] > cost [ i ] ) : NEW_LINE INDENT totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) NEW_LINE boardingBus = i NEW_LINE DEDENT DEDENT totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) NEW_LINE return totalCost NEW_LINE DEDENT
def k_sum ( a , n , k ) : NEW_LINE INDENT r , sum = 0 , 0 ; NEW_LINE ans = 0 ; NEW_LINE for l in range ( n ) : NEW_LINE INDENT while ( sum < k ) : NEW_LINE INDENT if ( r == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += a [ r ] ; NEW_LINE r += 1 ; NEW_LINE DEDENT DEDENT if ( sum < k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ans += n - r + 1 ; NEW_LINE sum -= a [ l ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def minCapacity ( enter , exit , n ) : NEW_LINE INDENT minCap = 0 ; NEW_LINE currCap = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT currCap = currCap + enter [ i ] - exit [ i ] ; NEW_LINE minCap = max ( minCap , currCap ) ; NEW_LINE DEDENT return minCap ; NEW_LINE DEDENT
def Findpermutation ( n ) : NEW_LINE INDENT a = [ 0 ] * ( n + 1 ) ; NEW_LINE a [ 1 ] = n ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT a [ i ] = i - 1 ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT
def lexo_small ( n , k ) : NEW_LINE INDENT arr = " " ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr += ' a ' ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT k -= i ; NEW_LINE if ( k >= 0 ) : NEW_LINE INDENT if ( k >= 26 ) : NEW_LINE INDENT arr = arr [ : i ] + ' z ' + arr [ i + 1 : ] ; NEW_LINE k -= 26 ; NEW_LINE DEDENT else : NEW_LINE INDENT c = ( k + 97 - 1 ) ; NEW_LINE arr = arr [ : i ] + chr ( c ) + arr [ i + 1 : ] ; NEW_LINE k -= ord ( arr [ i ] ) - ord ( ' a ' ) + 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT k += i ; NEW_LINE DEDENT return arr ; NEW_LINE DEDENT
def getMin ( arr , n ) : NEW_LINE INDENT minVal = min ( arr ) ; NEW_LINE return minVal ; NEW_LINE DEDENT
def Substring ( s ) : NEW_LINE INDENT ans , temp = 1 , 1 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , temp ) NEW_LINE temp = 1 NEW_LINE DEDENT DEDENT ans = max ( ans , temp ) NEW_LINE return ans NEW_LINE DEDENT
def Balanced_Substring ( s , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE arr = [ 0 ] * ( int ( n / 2 ) + 1 ) ; NEW_LINE d = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT d += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( d == 1 ) : NEW_LINE INDENT j = 2 NEW_LINE while ( j <= n // 2 + 1 and arr [ j ] != 0 ) : NEW_LINE INDENT arr [ j ] = 0 NEW_LINE DEDENT DEDENT ans += 1 ; NEW_LINE ans += arr [ d ] ; NEW_LINE arr [ d ] += 1 ; NEW_LINE d -= 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def find_set ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE return ; NEW_LINE DEDENT sum1 = ( n * ( n - 1 ) ) / 2 ; NEW_LINE sum2 = n ; NEW_LINE print ( sum1 , " ▁ " , sum2 ) ; NEW_LINE DEDENT
def longestSubarray ( arr , n ) : NEW_LINE INDENT maxMean = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxMean = max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) // 2 ) ; NEW_LINE DEDENT ans = 0 ; NEW_LINE subarrayLength = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= maxMean ) : NEW_LINE INDENT subarrayLength += 1 ; NEW_LINE ans = max ( ans , subarrayLength ) ; NEW_LINE DEDENT else : NEW_LINE INDENT subarrayLength = 0 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def CheckForSequence ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( k >= arr [ i ] ) : NEW_LINE INDENT k -= arr [ i ] ; NEW_LINE DEDENT DEDENT if ( k != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT
def printMaxNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT print ( "7" , end = " " ) ; NEW_LINE for i in range ( int ( ( n - 3 ) / 2 ) ) : NEW_LINE INDENT print ( "1" , end = " " ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n / 2 ) : NEW_LINE INDENT print ( "1" , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT
def generateArray ( n , k ) : NEW_LINE INDENT array = [ 0 ] * k NEW_LINE remaining = n - int ( k * ( k + 1 ) / 2 ) NEW_LINE if remaining < 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT right_most = remaining % k NEW_LINE high = ceil ( remaining / k ) NEW_LINE low = floor ( remaining / k ) NEW_LINE for i in range ( k - right_most , k ) : NEW_LINE INDENT array [ i ] = high NEW_LINE DEDENT for i in range ( k - right_most ) : NEW_LINE INDENT array [ i ] = low NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT array [ i ] += i + 1 NEW_LINE DEDENT if k - 1 != remaining or k == 1 : NEW_LINE INDENT print ( * array ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT elif k == 2 or k == 3 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT array [ 1 ] -= 1 NEW_LINE array [ k - 1 ] += 1 NEW_LINE print ( * array ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT
def get_maximum ( s , a ) : NEW_LINE INDENT s = list ( s ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) < a [ ord ( s [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( ord ( s [ j ] ) - ord ( '0' ) <= a [ ord ( s [ j ] ) - ord ( '0' ) ] ) ) : NEW_LINE INDENT s [ j ] = chr ( ord ( '0' ) + a [ ord ( s [ j ] ) - ord ( '0' ) ] ) NEW_LINE j += 1 NEW_LINE DEDENT return " " . join ( s ) ; NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT isOdd = True NEW_LINE DEDENT else : NEW_LINE INDENT isOdd = False NEW_LINE DEDENT sumOdd = 0 NEW_LINE sumEven = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( isOdd ) : NEW_LINE INDENT sumOdd += n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sumEven += n % 10 NEW_LINE DEDENT isOdd = not isOdd NEW_LINE n //= 10 NEW_LINE DEDENT print ( " Sum ▁ odd ▁ = ▁ " , sumOdd ) NEW_LINE print ( " Sum ▁ even ▁ = ▁ " , sumEven ) NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sumOdd = 0 NEW_LINE sumEven = 0 NEW_LINE num = str ( n ) NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT sumOdd = sumOdd + int ( num [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT sumEven = sumEven + int ( num [ i ] ) NEW_LINE DEDENT DEDENT print ( " Sum ▁ odd ▁ = ▁ " , sumOdd ) NEW_LINE print ( " Sum ▁ even ▁ = ▁ " , sumEven ) NEW_LINE DEDENT
def bankNotes ( A , B , S , N ) : NEW_LINE INDENT numerator = S - ( B * N ) NEW_LINE denominator = A - B NEW_LINE if ( numerator % denominator == 0 ) : NEW_LINE INDENT return ( numerator // denominator ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countSteps ( n ) : NEW_LINE INDENT steps = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT largest = int ( sqrt ( n ) ) ; NEW_LINE n -= ( largest * largest ) ; NEW_LINE steps += 1 ; NEW_LINE DEDENT return steps ; NEW_LINE DEDENT
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT
def Minsteps ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( m > n ) : NEW_LINE INDENT if ( m & 1 ) : NEW_LINE INDENT m += 1 NEW_LINE ans += 1 NEW_LINE DEDENT m //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans + n - m NEW_LINE DEDENT
def maxCandies ( arr , n ) : NEW_LINE INDENT prevBought = arr [ n - 1 ] ; NEW_LINE candies = prevBought ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT x = min ( prevBought - 1 , arr [ i ] ) ; NEW_LINE if ( x >= 0 ) : NEW_LINE INDENT candies += x ; NEW_LINE prevBought = x ; NEW_LINE DEDENT DEDENT return candies ; NEW_LINE DEDENT
def Maxsum ( c1 , c2 , c3 , c4 ) : NEW_LINE INDENT sum = 0 NEW_LINE two34 = min ( c2 , min ( c3 , c4 ) ) NEW_LINE sum = two34 * 234 NEW_LINE c2 -= two34 NEW_LINE sum += min ( c2 , c1 ) * 12 NEW_LINE return sum NEW_LINE DEDENT
def maximumResult ( a , b , c ) : NEW_LINE INDENT countOfNegative = 0 NEW_LINE Sum = a + b + c NEW_LINE product = a * b * c NEW_LINE largest = max ( a , b , c ) NEW_LINE smallest = min ( a , b , c ) NEW_LINE if a < 0 : NEW_LINE INDENT countOfNegative += 1 NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT countOfNegative += 1 NEW_LINE DEDENT if c < 0 : NEW_LINE INDENT countOfNegative += 1 NEW_LINE DEDENT if countOfNegative == 0 : NEW_LINE INDENT return ( Sum - largest ) * largest NEW_LINE DEDENT elif countOfNegative == 1 : NEW_LINE INDENT return ( product // smallest ) + smallest NEW_LINE DEDENT elif countOfNegative == 2 : NEW_LINE INDENT return ( product // largest ) + largest NEW_LINE DEDENT elif countOfNegative == 3 : NEW_LINE INDENT return ( Sum - smallest ) * smallest NEW_LINE DEDENT DEDENT
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT ans += b // n NEW_LINE ans += 1 if ( i % n + b % n ) >= n else 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * int ( a / n ) * int ( b / n ) NEW_LINE ans += int ( a / n ) * ( b % n ) NEW_LINE ans += ( a % n ) * int ( b / n ) NEW_LINE ans += int ( ( ( a % n ) + ( b % n ) ) / n ) ; NEW_LINE return ans NEW_LINE DEDENT
def encryptString ( string , n ) : NEW_LINE INDENT i , cnt = 0 , 0 NEW_LINE encryptedStr = " " NEW_LINE while i < n : NEW_LINE INDENT cnt = i + 1 NEW_LINE while cnt > 0 : NEW_LINE INDENT encryptedStr += string [ i ] NEW_LINE cnt -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return encryptedStr NEW_LINE DEDENT
def min_elimination ( n , arr ) : NEW_LINE INDENT count = 0 NEW_LINE prev_val = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_val = arr [ i ] ; NEW_LINE if ( curr_val % 2 == prev_val % 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT prev_val = curr_val NEW_LINE DEDENT return count NEW_LINE DEDENT
def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = "9" NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT result = result + "0" NEW_LINE DEDENT return result NEW_LINE DEDENT
def findIntersection ( intervals , N ) : NEW_LINE INDENT l = intervals [ 0 ] [ 0 ] NEW_LINE r = intervals [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( intervals [ i ] [ 0 ] > r or intervals [ i ] [ 1 ] < l ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l = max ( l , intervals [ i ] [ 0 ] ) NEW_LINE r = min ( r , intervals [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT print ( " [ " , l , " , ▁ " , r , " ] " ) NEW_LINE DEDENT
def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 NEW_LINE n = len ( s ) NEW_LINE for c in range ( 27 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + c ) NEW_LINE curr = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT if ( s [ i ] != ch ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while ( i < n and s [ i ] == ch and cnt != k ) : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if ( cnt == k ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT
def find_rectangle ( area ) : NEW_LINE INDENT l , b = 0 , 0 NEW_LINE M = mt . ceil ( mt . sqrt ( area ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( M , 0 , - 1 ) : NEW_LINE INDENT if ( area % i == 0 ) : NEW_LINE INDENT l = ( area // i ) NEW_LINE b = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( " l ▁ = " , l , " , ▁ b ▁ = " , b ) NEW_LINE DEDENT
def find_rectangle ( area ) : NEW_LINE INDENT for i in range ( int ( math . ceil ( math . sqrt ( area ) ) ) , area + 1 ) : NEW_LINE INDENT if ( ( int ( area / i ) * i ) == area ) : NEW_LINE INDENT print ( i , int ( area / i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def sizeSubSet ( a , k , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % k != 0 or a [ i ] // k not in s ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def minimumSets ( s , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE num = 0 NEW_LINE l = len ( s ) NEW_LINE f = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if ( num <= y ) : NEW_LINE INDENT f = 1 NEW_LINE if ( f ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT num = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE f = 0 NEW_LINE if ( num <= y ) : NEW_LINE INDENT f = 1 NEW_LINE DEDENT else : NEW_LINE INDENT num = 0 NEW_LINE DEDENT DEDENT DEDENT if ( f ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def minItems ( k , r ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( ( i * k - r ) % 10 == 0 or ( i * k ) % 10 == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 10 ; NEW_LINE DEDENT
def check ( n , marks ) : NEW_LINE INDENT x = max ( marks ) NEW_LINE bonus = 100 - x NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( marks [ i ] + bonus >= 50 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def find_sum ( n , k ) : NEW_LINE INDENT total_sum = ( n * ( n + 1 ) ) // 2 NEW_LINE power = k NEW_LINE while power <= n : NEW_LINE INDENT total_sum -= power NEW_LINE power *= k NEW_LINE DEDENT return total_sum NEW_LINE DEDENT
def maxLitres ( budget , plastic , glass , refund ) : NEW_LINE INDENT if glass - refund < plastic : NEW_LINE INDENT ans = max ( ( budget - refund ) // ( glass - refund ) , 0 ) NEW_LINE budget -= ans * ( glass - refund ) NEW_LINE ans += budget // plastic NEW_LINE print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( budget // plastic ) NEW_LINE DEDENT DEDENT
def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def completeSequence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE open = 0 NEW_LINE close = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT open += 1 NEW_LINE DEDENT else : NEW_LINE INDENT close += 1 NEW_LINE DEDENT if ( close > open ) : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( s , end = " " ) NEW_LINE for i in range ( open - close ) : NEW_LINE INDENT print ( " ) " , end = " " ) NEW_LINE DEDENT DEDENT
def leastValue ( P , A , N , a ) : NEW_LINE INDENT ans = - 1 NEW_LINE tmp = float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = P - a [ i ] * 0.006 NEW_LINE if abs ( t - A ) < tmp : NEW_LINE INDENT tmp = abs ( t - A ) NEW_LINE ans = i NEW_LINE DEDENT DEDENT return a [ ans ] NEW_LINE DEDENT
def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) ; NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff / K ) - 1 ; NEW_LINE DEDENT DEDENT return inser ; NEW_LINE DEDENT
def minCost ( N , P , Q ) : NEW_LINE INDENT cost = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT cost += P NEW_LINE N -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = N // 2 ; NEW_LINE if ( temp * P > Q ) : NEW_LINE INDENT cost += Q NEW_LINE DEDENT else : NEW_LINE INDENT cost += P * temp NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT
def count_minimum_operations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT if ( n % 3 == 0 ) : NEW_LINE INDENT n //= 3 NEW_LINE DEDENT elif ( n % 3 == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findPermutation ( n ) : NEW_LINE INDENT len = ceil ( log10 ( n ) ) NEW_LINE for i in range ( 0 , len , 1 ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT n = ( ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) ) NEW_LINE continue NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def getMinCost ( arr , n ) : NEW_LINE INDENT min_ele = min ( arr ) NEW_LINE return min_ele * ( n - 1 ) NEW_LINE DEDENT
def cal_minimum_time ( X ) : NEW_LINE INDENT t = 0 NEW_LINE sum = 0 NEW_LINE while ( sum < X ) : NEW_LINE INDENT t = t + 1 NEW_LINE sum = sum + t ; NEW_LINE DEDENT return t ; NEW_LINE DEDENT
def minDiff ( n , x , A ) : NEW_LINE INDENT mn = A [ 0 ] NEW_LINE mx = A [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mn = min ( mn , A [ i ] ) NEW_LINE mx = max ( mx , A [ i ] ) NEW_LINE DEDENT return max ( 0 , mx - mn - 2 * x ) NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE l = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT s += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE l . append ( i ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE print ( * l ) NEW_LINE DEDENT
def CountPair ( L , R ) : NEW_LINE INDENT x = ( R - L + 1 ) NEW_LINE print ( x // 2 ) NEW_LINE DEDENT
def problemsLeft ( K , P , N ) : NEW_LINE INDENT if ( K <= P ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( K - P ) * N ) NEW_LINE DEDENT DEDENT
def printCoins ( arr , n ) : NEW_LINE INDENT oddSum = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT oddSum += arr [ i ] NEW_LINE DEDENT evenSum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT evenSum += arr [ i ] NEW_LINE DEDENT if oddSum > evenSum : NEW_LINE INDENT start = 0 NEW_LINE DEDENT else : NEW_LINE INDENT start = 1 NEW_LINE DEDENT for i in range ( start , n , 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countSubstrings ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE subs = 1 NEW_LINE pre = ' ' NEW_LINE for i in s : NEW_LINE INDENT if pre == i : NEW_LINE INDENT subs += 1 NEW_LINE DEDENT else : NEW_LINE INDENT subs = 1 NEW_LINE DEDENT ans += subs NEW_LINE pre = i NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def results ( n , k ) : NEW_LINE INDENT return round ( pow ( n , ( 1.0 / pow ( 2 , k ) ) ) ) NEW_LINE DEDENT
def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT sum_here = arr [ 0 ] NEW_LINE max_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) NEW_LINE max_sum = max ( max_sum , sum_here ) NEW_LINE DEDENT return ( - 1 ) * max_sum NEW_LINE DEDENT
def printLargest ( a , n ) : NEW_LINE INDENT max = - 1 NEW_LINE ind = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT r = num % 10 ; NEW_LINE num = num / 10 ; NEW_LINE if ( num == 0 ) : NEW_LINE INDENT if ( max < r ) : NEW_LINE INDENT max = r NEW_LINE ind = i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( ind , n ) : NEW_LINE INDENT print ( a [ i ] , end = ' ' ) , NEW_LINE DEDENT for i in range ( 0 , ind ) : NEW_LINE INDENT print ( a [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT
def findMinimumAdjacentSwaps ( arr , N ) : NEW_LINE INDENT visited = [ False ] * ( N + 1 ) NEW_LINE minimumSwaps = 0 NEW_LINE for i in range ( 2 * N ) : NEW_LINE INDENT if ( visited [ arr [ i ] ] == False ) : NEW_LINE INDENT visited [ arr [ i ] ] = True NEW_LINE count = 0 NEW_LINE for j in range ( i + 1 , 2 * N ) : NEW_LINE INDENT if ( visited [ arr [ j ] ] == False ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT minimumSwaps += count NEW_LINE DEDENT DEDENT DEDENT DEDENT return minimumSwaps NEW_LINE DEDENT
def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M NEW_LINE DEDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT
def DecreasingArray ( a , n ) : NEW_LINE INDENT ss , dif = ( 0 , 0 ) NEW_LINE pq = PriorityQueue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = 0 NEW_LINE if not pq . empty ( ) : NEW_LINE INDENT tmp = pq . get ( ) NEW_LINE pq . put ( tmp ) NEW_LINE DEDENT if not pq . empty ( ) and tmp < a [ i ] : NEW_LINE INDENT dif = a [ i ] - tmp NEW_LINE ss += dif NEW_LINE pq . get ( ) NEW_LINE DEDENT pq . put ( a [ i ] ) NEW_LINE DEDENT return ss NEW_LINE DEDENT
def ifPossible ( arr , n ) : NEW_LINE INDENT cp = [ 0 ] * n NEW_LINE cp = arr NEW_LINE cp . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE if ( ifPossible ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ( counts ) ; NEW_LINE DEDENT
def MinOperation ( a , n , k ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 1 and a [ i ] > k ) : NEW_LINE INDENT result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + k - a [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def survival ( S , N , M ) : NEW_LINE INDENT if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT days = ( M * S ) / N NEW_LINE if ( ( ( M * S ) % N ) != 0 ) : NEW_LINE INDENT days += 1 NEW_LINE DEDENT print ( " Yes ▁ " ) , NEW_LINE print ( days ) NEW_LINE DEDENT DEDENT
def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = " " ) NEW_LINE DEDENT for i in range ( 1 , int ( N / 9 ) + 1 ) : NEW_LINE INDENT print ( "9" , end = " " ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def noAdjacentDup ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = " a " NEW_LINE while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def cost ( a , n ) : NEW_LINE INDENT return ( ( n - 1 ) * min ( a ) ) NEW_LINE DEDENT
def maxDifference ( arr , N , k ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = 0 NEW_LINE max_difference = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE M = max ( k , N - k ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT max_difference = S1 - ( S - S1 ) NEW_LINE return max_difference NEW_LINE DEDENT
def winner ( a , n , k ) : NEW_LINE INDENT if k >= n - 1 : NEW_LINE INDENT return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > best : NEW_LINE INDENT best = a [ i ] NEW_LINE if i == True : NEW_LINE INDENT times = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE if times >= k : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT
def minproduct ( a , b , n , k ) : NEW_LINE INDENT diff = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro = a [ i ] * b [ i ] NEW_LINE res = res + pro NEW_LINE if ( pro < 0 and b [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro < 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] > 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT d = abs ( pro - temp ) NEW_LINE if ( d > diff ) : NEW_LINE INDENT diff = d NEW_LINE DEDENT DEDENT return res - diff NEW_LINE DEDENT
def minSum ( A ) : NEW_LINE INDENT min_val = min ( A ) ; NEW_LINE return min_val * ( len ( A ) - 1 ) NEW_LINE DEDENT
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 ; NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 ; NEW_LINE code_digit = unlock_code % 10 ; NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; NEW_LINE input = int ( input / 10 ) ; NEW_LINE unlock_code = int ( unlock_code / 10 ) ; NEW_LINE DEDENT return rotation ; NEW_LINE DEDENT
def minCost ( coin , n , k ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE coins_needed = math . ceil ( 1.0 * n // ( k + 1 ) ) ; NEW_LINE ans = 0 NEW_LINE for i in range ( coins_needed - 1 + 1 ) : NEW_LINE INDENT ans += coin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE hzntl = 1 ; vert = 1 NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT
def maximumSum ( arr , n , k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT min = + 2147483647 NEW_LINE index = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < min ) : NEW_LINE INDENT min = arr [ j ] NEW_LINE index = j NEW_LINE DEDENT DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ index ] = - arr [ index ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maxDiffSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxVal = arr [ i ] NEW_LINE minVal = arr [ i ] NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT minVal = min ( minVal , arr [ j ] ) NEW_LINE maxVal = max ( maxVal , arr [ j ] ) NEW_LINE if ( j - 1 >= 0 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , maxVal - minVal ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def LongestOddEvenSubarray ( A , N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 0 and A [ i - 1 ] % 2 == 0 ) or ( A [ i ] % 2 != 0 and A [ i - 1 ] % 2 != 0 ) ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def LongestOddEvenSubarray ( A , N ) : NEW_LINE INDENT dp = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 0 and A [ i - 1 ] % 2 == 0 ) or ( A [ i ] % 2 != 0 and A [ i - 1 ] % 2 != 0 ) ) : NEW_LINE INDENT dp = dp + 1 NEW_LINE ans = max ( ans , dp ) NEW_LINE DEDENT else : NEW_LINE INDENT dp = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countStrings ( N ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp . get ( N , - 1 ) != - 1 : NEW_LINE INDENT return dp [ N ] NEW_LINE DEDENT ret = 0 NEW_LINE for div in range ( 1 , int ( N ** .5 ) + 1 ) : NEW_LINE INDENT if N % div == 0 : NEW_LINE INDENT ret += ( 1 << div ) - countStrings ( div ) NEW_LINE div2 = N // div NEW_LINE if div2 != div and div != 1 : NEW_LINE INDENT ret += ( 1 << div2 ) - countStrings ( div2 ) NEW_LINE DEDENT DEDENT DEDENT dp [ N ] = ret NEW_LINE return ret NEW_LINE DEDENT
def countOfNumbers ( N ) : NEW_LINE INDENT ans = 1 NEW_LINE for index in range ( 1 , N + 1 ) : NEW_LINE INDENT choices = 0 NEW_LINE for digit in range ( 1 , 10 ) : NEW_LINE INDENT if ( index % digit == 0 ) : NEW_LINE INDENT choices += 1 NEW_LINE DEDENT DEDENT ans = ( ans * choices ) % mod NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def MaxProfit ( arr , n , transactionFee ) : NEW_LINE INDENT buy = - arr [ 0 ] NEW_LINE sell = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT temp = buy NEW_LINE buy = max ( buy , sell - arr [ i ] ) NEW_LINE sell = max ( sell , temp + arr [ i ] - transactionFee ) NEW_LINE DEDENT return max ( sell , buy ) NEW_LINE DEDENT
def MaximumSum ( a , b , n ) : NEW_LINE INDENT dp = [ [ - 1 for j in range ( 2 ) ] for i in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = a [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = b [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) NEW_LINE if ( i - 2 >= 0 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , b [ i ] ) NEW_LINE DEDENT DEDENT return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT
def waysOfDecoding ( s ) : NEW_LINE INDENT dp = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE if s [ 0 ] == ' * ' : NEW_LINE INDENT dp [ 1 ] = 9 NEW_LINE DEDENT elif s [ 0 ] == '0' : NEW_LINE INDENT dp [ 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] = 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' * ' ) : NEW_LINE INDENT dp [ i + 1 ] = 9 * dp [ i ] NEW_LINE if ( s [ i - 1 ] == '1' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == '2' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == ' * ' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if s [ i ] != '0' : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = 0 NEW_LINE DEDENT if ( s [ i - 1 ] == '1' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == '2' and s [ i ] <= '6' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M NEW_LINE DEDENT elif ( s [ i - 1 ] == ' * ' ) : NEW_LINE INDENT if ( s [ i ] <= '6' ) : NEW_LINE INDENT dp [ i + 1 ] = dp [ i + 1 ] + 2 * dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = dp [ i + 1 ] + 1 * dp [ i - 1 ] NEW_LINE DEDENT dp [ i + 1 ] = dp [ i + 1 ] % M NEW_LINE DEDENT DEDENT DEDENT return dp [ len ( s ) ] NEW_LINE DEDENT
def KvisibleFromLeft ( N , K ) : NEW_LINE INDENT if ( N == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT return ans NEW_LINE DEDENT return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) NEW_LINE DEDENT
def KvisibleFromLeft ( N , K ) : NEW_LINE INDENT if ( dp [ N ] [ K ] != - 1 ) : NEW_LINE INDENT return dp [ N ] [ K ] NEW_LINE DEDENT if ( N == K ) : NEW_LINE INDENT dp [ N ] [ K ] = 1 NEW_LINE return dp [ N ] [ K ] NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT dp [ N ] [ K ] = ans NEW_LINE return dp [ N ] [ K ] NEW_LINE DEDENT dp [ N ] [ K ] = KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) NEW_LINE return dp [ N ] [ K ] NEW_LINE DEDENT N , K = 5 , 2 NEW_LINE for i in range ( 1005 ) : NEW_LINE INDENT for j in range ( 1005 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT
def maximumSum ( A , N , K , D ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( ( 1 << N ) ) : NEW_LINE INDENT sum = 0 NEW_LINE c = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i >> j & 1 ) : NEW_LINE INDENT sum += A [ j ] NEW_LINE c += 1 NEW_LINE DEDENT DEDENT if ( sum % D == 0 and c <= K ) : NEW_LINE INDENT ans = max ( ans , sum ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxSumWO3Consec ( A , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return A [ 0 ] + A [ 1 ] NEW_LINE DEDENT third = A [ 0 ] NEW_LINE second = third + A [ 1 ] NEW_LINE first = max ( second , A [ 1 ] + A [ 2 ] ) NEW_LINE sum = max ( max ( third , second ) , first ) NEW_LINE for i in range ( 3 , N , 1 ) : NEW_LINE INDENT sum = max ( max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) NEW_LINE third = second NEW_LINE second = first NEW_LINE first = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT
def longestSubSequence ( A , N ) : NEW_LINE INDENT dp = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] and A [ j ] [ 1 ] > A [ i ] [ 1 ] ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N - 1 ] ) NEW_LINE DEDENT
def countSubset ( arr , n , diff ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum += diff NEW_LINE sum = sum // 2 NEW_LINE t = [ [ 0 for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for j in range ( sum + 1 ) : NEW_LINE INDENT t [ 0 ] [ j ] = 0 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT t [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] > j ) : NEW_LINE INDENT t [ i ] [ j ] = t [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT return t [ n ] [ sum ] NEW_LINE DEDENT
def countSortedArrays ( start , m , size , n ) : NEW_LINE INDENT if ( size == m ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( start > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT notTaken , taken = 0 , 0 NEW_LINE taken = countSortedArrays ( start , m , size + 1 , n ) NEW_LINE notTaken = countSortedArrays ( start + 1 , m , size , n ) NEW_LINE return taken + notTaken NEW_LINE DEDENT
def findMinCost ( arr , X , n , i = 0 ) : NEW_LINE INDENT if ( X <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 10 ** 8 NEW_LINE DEDENT inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) NEW_LINE if ( inc != 10 ** 8 ) : NEW_LINE INDENT inc += arr [ i ] [ 1 ] NEW_LINE DEDENT exc = findMinCost ( arr , X , n , i + 1 ) NEW_LINE return min ( inc , exc ) NEW_LINE DEDENT
def NumberOfways ( N , K ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for row in range ( 1 , K + 1 ) : NEW_LINE INDENT for col in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( col >= row ) : NEW_LINE INDENT dp [ col ] = dp [ col ] + dp [ col - row ] NEW_LINE DEDENT DEDENT DEDENT return ( dp [ N ] ) NEW_LINE DEDENT
def MaxSubsetlength ( arr , A , B ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( B + 1 ) ] for i in range ( A + 1 ) ] NEW_LINE for str in arr : NEW_LINE INDENT zeros = str . count ( '0' ) NEW_LINE ones = str . count ( '1' ) NEW_LINE for i in range ( A , zeros - 1 , - 1 ) : NEW_LINE INDENT for j in range ( B , ones - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp [ A ] [ B ] NEW_LINE DEDENT
def getValue ( arr , N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT minn = arr [ i ] NEW_LINE maxx = arr [ i ] NEW_LINE j = i NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT minn = min ( arr [ j ] , minn ) NEW_LINE maxx = max ( arr [ j ] , maxx ) NEW_LINE dp [ i ] = max ( dp [ i ] , maxx - minn + ( dp [ j - 1 ] if ( j >= 1 ) else 0 ) ) NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return dp [ N - 1 ] NEW_LINE DEDENT
def maxScore ( s , a ) : NEW_LINE INDENT if s in dp : NEW_LINE INDENT return dp [ s ] NEW_LINE DEDENT n = len ( s ) NEW_LINE if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT head = 0 NEW_LINE mx = - 1 NEW_LINE while head < n : NEW_LINE INDENT tail = head NEW_LINE while tail < n : NEW_LINE INDENT if s [ tail ] != s [ head ] : NEW_LINE INDENT head = tail NEW_LINE break NEW_LINE DEDENT sub = s [ head : tail + 1 ] NEW_LINE mx = max ( mx , a [ len ( sub ) - 1 ] + maxScore ( s [ : head ] + s [ tail + 1 : ] , a ) ) NEW_LINE tail += 1 NEW_LINE DEDENT if tail == n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ s ] = mx NEW_LINE return mx NEW_LINE DEDENT
def numberOfUniqueOutcomes ( N , S ) : NEW_LINE INDENT if ( S < N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 or N == S ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) NEW_LINE DEDENT
def numOfWays ( a , n , i = 0 , blue = [ ] ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 and j not in blue : NEW_LINE INDENT count += numOfWays ( mat , n , i + 1 , blue + [ j ] ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def waysToPaint ( n ) : NEW_LINE INDENT same = 6 NEW_LINE diff = 6 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT sameTmp = 3 * same + 2 * diff NEW_LINE diffTmp = 2 * same + 2 * diff NEW_LINE same = sameTmp NEW_LINE diff = diffTmp NEW_LINE DEDENT print ( same + diff ) NEW_LINE DEDENT
def find ( A , B , C , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE arr [ 0 ] = A NEW_LINE arr [ 1 ] = B NEW_LINE arr [ 2 ] = C NEW_LINE for i in range ( 3 , N ) : NEW_LINE INDENT arr [ i ] = ( arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 3 ] ) NEW_LINE DEDENT return arr [ N - 1 ] NEW_LINE DEDENT
def minCost ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] NEW_LINE for i in range ( 2 , n - 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) NEW_LINE print ( dp [ n - 1 ] ) NEW_LINE DEDENT
def maxSubmatrixSum ( matrix ) : NEW_LINE INDENT r = len ( matrix ) NEW_LINE c = len ( matrix [ 0 ] ) NEW_LINE maxSubmatrix = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT for k in range ( i , r ) : NEW_LINE INDENT for l in range ( j , c ) : NEW_LINE INDENT sumSubmatrix = 0 NEW_LINE for m in range ( i , k + 1 ) : NEW_LINE INDENT for n in range ( j , l + 1 ) : NEW_LINE INDENT sumSubmatrix += matrix [ m ] [ n ] NEW_LINE DEDENT DEDENT maxSubmatrix = max ( maxSubmatrix , sumSubmatrix ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( maxSubmatrix ) NEW_LINE DEDENT
def minCost ( costs , N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] NEW_LINE dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] NEW_LINE DEDENT print ( min ( dp [ N - 1 ] [ 0 ] , min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) NEW_LINE DEDENT
def FindMaxS ( X , Y , Z , n ) : NEW_LINE INDENT global A , B , C NEW_LINE if ( X < 0 or Y < 0 or Z < 0 ) : NEW_LINE INDENT return - 10 ** 9 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 ) NEW_LINE ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 ) NEW_LINE co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 ) NEW_LINE no = FindMaxS ( X , Y , Z , n - 1 ) NEW_LINE maximum = max ( ch , max ( ca , max ( co , no ) ) ) NEW_LINE return maximum NEW_LINE DEDENT
def FindMaxS ( X , Y , Z , n , A , B , C ) : NEW_LINE INDENT if ( X < 0 or Y < 0 or Z < 0 ) : NEW_LINE INDENT return - sys . maxsize - 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ X ] [ Y ] [ Z ] NEW_LINE DEDENT ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) NEW_LINE ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) NEW_LINE co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) NEW_LINE no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) NEW_LINE maximum = max ( ch , max ( ca , max ( co , no ) ) ) NEW_LINE dp [ n ] [ X ] [ Y ] [ Z ] = maximum NEW_LINE return dp [ n ] [ X ] [ Y ] [ Z ] NEW_LINE DEDENT
def find ( N , sum ) : NEW_LINE INDENT if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return 1.0 / 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT s = s + find ( N - 1 , sum - i ) / 6 NEW_LINE DEDENT return s NEW_LINE DEDENT
def find ( N , sum ) : NEW_LINE INDENT if ( N < 0 sum < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ N ] [ sum ] > 0 ) : NEW_LINE INDENT return dp [ N ] [ sum ] ; NEW_LINE DEDENT if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return ( float ) ( 1.0 / 6 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; NEW_LINE DEDENT return dp [ N ] [ sum ] ; NEW_LINE DEDENT
def find ( N , a , b ) : NEW_LINE INDENT probability = 0.0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1.0 / 6 NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT for j in range ( i , ( 6 * i ) + 1 ) : NEW_LINE INDENT for k in range ( 1 , 7 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 NEW_LINE DEDENT DEDENT DEDENT for Sum in range ( a , b + 1 ) : NEW_LINE INDENT probability = probability + dp [ N ] [ Sum ] NEW_LINE DEDENT return probability NEW_LINE DEDENT
def minAtEachIndex ( n , arr ) : NEW_LINE INDENT dp1 = [ 0 ] * n NEW_LINE dp2 = [ 0 ] * n NEW_LINE i = 0 NEW_LINE dp1 [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp1 [ i ] = min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) NEW_LINE DEDENT dp2 [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp2 [ i ] = min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) NEW_LINE DEDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT v . append ( min ( dp1 [ i ] , dp2 [ i ] ) ) NEW_LINE DEDENT for x in v : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def totalArrays ( N , M ) : NEW_LINE INDENT end_with_one = [ 0 ] * ( N + 1 ) ; NEW_LINE end_not_with_one = [ 0 ] * ( N + 1 ) ; NEW_LINE end_with_one [ 0 ] = 1 ; NEW_LINE end_not_with_one [ 0 ] = 0 ; NEW_LINE end_with_one [ 1 ] = 0 ; NEW_LINE end_not_with_one [ 1 ] = M - 1 ; NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT end_with_one [ i ] = end_not_with_one [ i - 1 ] ; NEW_LINE end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; NEW_LINE DEDENT return end_with_one [ N - 1 ] ; NEW_LINE DEDENT
def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE tuples = { } ; NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def countWaysToTileBoard ( N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) NEW_LINE DEDENT print ( dp [ N ] ) NEW_LINE DEDENT
def FindSub ( string , res , i ) : NEW_LINE INDENT if ( i == len ( string ) ) : NEW_LINE INDENT if ( len ( res ) > 0 ) : NEW_LINE INDENT print ( res , end = " ▁ " ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT ch = string [ i ] ; NEW_LINE FindSub ( string , res , i + 1 ) ; NEW_LINE FindSub ( string , res + ch , i + 1 ) ; NEW_LINE FindSub ( string , res + str ( ord ( ch ) ) , i + 1 ) ; NEW_LINE DEDENT
def MinOp ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return N ; NEW_LINE DEDENT bit = ( int ) ( math . log ( N ) / math . log ( 2 ) ) + 1 ; NEW_LINE return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; NEW_LINE DEDENT
def findNumberOfStrings ( n ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( 6 ) ] for i in range ( n + 1 ) ] NEW_LINE DP [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 6 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return DP [ n ] [ 5 ] NEW_LINE DEDENT
def findNumberOfStrings ( n ) : NEW_LINE INDENT return int ( ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ) NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT r1 = r2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r1 , r2 = max ( r1 , r2 + arr [ 0 ] [ i ] ) , max ( r2 , r1 + arr [ 1 ] [ i ] ) NEW_LINE DEDENT print ( max ( r1 , r2 ) ) NEW_LINE DEDENT
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT dp = [ [ 0 ] * ( K + 1 ) ] * 2 NEW_LINE mod = 1000000007 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 0 , K + 1 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 if ( j == 0 ) else 0 NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT var = ( 0 if ( max ( j - ( i - 1 ) , 0 ) == 0 ) else dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) NEW_LINE dp [ i % 2 ] [ j ] = ( ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( var ) + mod ) % mod ) % mod ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N % 2 ] [ K ] ) NEW_LINE DEDENT
def maxScore ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE N += 1 NEW_LINE dp = [ [ - 100000 for i in range ( 2 * N ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for s in range ( 1 , 2 * ( N - 1 ) + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j <= N - 1 and j <= s : NEW_LINE INDENT dp [ i ] [ s ] = max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ N ] [ 2 * ( N - 1 ) ] NEW_LINE DEDENT
def minimumCost ( cost , n , x ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 2 ) NEW_LINE dp [ 0 ] = cost [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i ] = cost [ i ] + dp [ i - 1 ] NEW_LINE DEDENT if ( i == 2 ) : NEW_LINE INDENT dp [ i ] = cost [ i ] + min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) NEW_LINE DEDENT if ( i >= 3 ) : NEW_LINE INDENT dp [ i ] = ( cost [ i ] + min ( dp [ i - 1 ] , min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ) NEW_LINE DEDENT DEDENT print ( dp [ n - 1 ] ) NEW_LINE DEDENT
def maxSum ( a , n , k ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT option = maxSum ( a , n - 1 , k ) NEW_LINE if ( k >= a [ n - 1 ] ) : NEW_LINE INDENT option = max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) NEW_LINE DEDENT return option NEW_LINE DEDENT
def maxCount ( arr , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 , 1 ) : NEW_LINE INDENT table [ i ] = - 1 NEW_LINE for i in range ( 1 , V + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , m , 1 ) : NEW_LINE INDENT if ( arr [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - arr [ j ] ] NEW_LINE if ( sub_res != - 1 and sub_res + 1 > table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return table [ V ] NEW_LINE DEDENT
def longestPalSubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxLength = 1 NEW_LINE start = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT for j in range ( i , len ( str ) , 1 ) : NEW_LINE INDENT flag = 1 NEW_LINE for k in range ( ( j - i + 1 ) // 2 ) : NEW_LINE INDENT if ( str [ i + k ] != str [ j - k ] ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag != 0 and ( j - i + 1 ) > maxLength ) : NEW_LINE INDENT start = i NEW_LINE maxLength = j - i + 1 NEW_LINE DEDENT DEDENT DEDENT return maxLength NEW_LINE DEDENT
def lastRemaining ( n , dp ) : NEW_LINE INDENT if n in dp : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] = 2 * ( 1 + n // 2 - lastRemaining ( n // 2 , dp ) ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def findWays ( N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = 0 ; NEW_LINE for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + dp [ i - j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] ) ; NEW_LINE DEDENT
def FindNoOfFullVessels ( n , t ) : NEW_LINE INDENT Matrix = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE Matrix [ 0 ] [ 0 ] = t * 1.0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT exceededwater = Matrix [ i ] [ j ] - 1.0 NEW_LINE if ( exceededwater < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans += 1 NEW_LINE if ( i + 1 < n ) : NEW_LINE INDENT Matrix [ i + 1 ] [ j ] += exceededwater / 2 NEW_LINE DEDENT if ( i + 1 < n and j + 1 < n ) : NEW_LINE INDENT Matrix [ i + 1 ] [ j + 1 ] += exceededwater / 2 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def minSteps ( m , n ) : NEW_LINE INDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return inf NEW_LINE DEDENT min_cost = inf NEW_LINE for i in range ( 2 , m , 2 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT min_cost = min ( min_cost , m / i + minSteps ( m + i , n ) ) NEW_LINE DEDENT DEDENT return min_cost NEW_LINE DEDENT
def minCountOfNumbers ( N ) : NEW_LINE INDENT k = N % 10 NEW_LINE z = N - ( 9 * ( 9 - k ) ) NEW_LINE if ( z >= 9 and z % 10 == 9 ) : NEW_LINE INDENT return 10 - k NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def solve ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE val = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = a [ i ] NEW_LINE j = i NEW_LINE while ( j + 1 < n and sum < val [ j + 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE sum += a [ j ] NEW_LINE DEDENT dp [ i ] = ( j - i ) + dp [ j + 1 ] NEW_LINE val [ i ] = sum NEW_LINE DEDENT return dp [ 0 ] NEW_LINE DEDENT
def minDays ( n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return n NEW_LINE DEDENT cnt = 1 + min ( n % 2 + minDays ( n // 2 ) , n % 3 + minDays ( n // 3 ) ) NEW_LINE return cnt NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT dp = dict ( ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE if n not in dp : NEW_LINE INDENT dp [ n ] = 1 + min ( n % 2 + count ( n // 2 ) , n % 3 + count ( n // 3 ) ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def maxValue ( a , n , pos , moves , left , dp ) : NEW_LINE INDENT if ( moves == 0 or ( pos > n - 1 or pos < 0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ left ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ left ] NEW_LINE DEDENT value = 0 NEW_LINE if ( left > 0 and pos >= 1 ) : NEW_LINE INDENT value = max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) NEW_LINE DEDENT if ( pos <= n - 1 ) : NEW_LINE INDENT value = max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) NEW_LINE DEDENT dp [ pos ] [ left ] = value NEW_LINE return dp [ pos ] [ left ] NEW_LINE DEDENT
def maximumSum ( a , count , index , n , dp ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ count ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ count ] NEW_LINE DEDENT take_element = ( a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ) NEW_LINE dont_take = maximumSum ( a , count , index + 1 , n , dp ) NEW_LINE dp [ index ] [ count ] = max ( take_element , dont_take ) NEW_LINE return dp [ index ] [ count ] NEW_LINE DEDENT
def countNums ( N ) : NEW_LINE INDENT l = pow ( 10 , N - 1 ) NEW_LINE r = pow ( 10 , N ) - 1 NEW_LINE count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT xorr = 0 NEW_LINE temp = i NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT xorr = xorr ^ ( temp % 10 ) NEW_LINE temp //= 10 NEW_LINE DEDENT if ( xorr <= 9 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def countNums ( N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 16 ) ] for j in range ( N ) ] ; NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT for k in range ( 0 , 16 ) : NEW_LINE INDENT xor = j ^ k ; NEW_LINE dp [ i ] [ xor ] += dp [ i - 1 ] [ k ] ; NEW_LINE DEDENT DEDENT DEDENT count = 0 ; NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT count += dp [ N - 1 ] [ i ] ; NEW_LINE DEDENT print ( count ) ; NEW_LINE DEDENT
def count ( a , M , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , M + 1 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i % a [ j ] == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def minSum ( n , num , price ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = sys . maxsize NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( num [ j ] > num [ i ] ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , price [ i ] + price [ j ] ) NEW_LINE ans = min ( ans , dp [ i ] + price [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ans is not sys . maxsize : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def solve ( n , k , mod , dp ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 2 , k + 1 , 2 ) : NEW_LINE INDENT cnt = ( ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ) NEW_LINE DEDENT dp [ n ] = cnt NEW_LINE return int ( cnt ) NEW_LINE DEDENT
def maxProfit ( price , n ) : NEW_LINE INDENT buy1 , buy2 = sys . maxsize , sys . maxsize NEW_LINE profit1 , profit2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT buy1 = min ( buy1 , price [ i ] ) NEW_LINE profit1 = max ( profit1 , price [ i ] - buy1 ) NEW_LINE buy2 = min ( buy2 , price [ i ] - profit1 ) NEW_LINE profit2 = max ( profit2 , price [ i ] - buy2 ) NEW_LINE DEDENT return profit2 NEW_LINE DEDENT
def findMaximumScore ( a , n ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT dp = [ 0 ] * ( max ( a ) + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = freq [ 1 ] NEW_LINE for i in range ( 2 , len ( dp ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + freq [ i ] * i ) NEW_LINE DEDENT return dp [ - 1 ] NEW_LINE DEDENT
def reduceZero ( N ) : NEW_LINE INDENT dp = [ 1e9 for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for c in str ( i ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i - ( ord ( c ) - 48 ) ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
def printpenta ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE third = 0 NEW_LINE fourth = 0 NEW_LINE fifth = 1 NEW_LINE curr = 0 NEW_LINE if ( n == 0 or n == 1 or \ n == 2 or n == 3 ) : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif ( n == 5 ) : NEW_LINE INDENT print ( fifth ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 5 , n ) : NEW_LINE INDENT curr = first + second + third + fourth + fifth NEW_LINE first = second NEW_LINE second = third NEW_LINE third = fourth NEW_LINE fourth = fifth NEW_LINE fifth = curr NEW_LINE DEDENT DEDENT print ( curr ) NEW_LINE DEDENT
def possibleBinaries ( pos , ones , sum , k ) : NEW_LINE INDENT if ( ones == k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( pos == 0 ) : NEW_LINE INDENT return 1 if ( sum == 0 ) else 0 NEW_LINE DEDENT if ( dp [ pos ] [ ones ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ ones ] [ sum ] NEW_LINE DEDENT ret = ( possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ) NEW_LINE dp [ pos ] [ ones ] [ sum ] = ret NEW_LINE return dp [ pos ] [ ones ] [ sum ] NEW_LINE DEDENT
def smallestNum ( n ) : NEW_LINE INDENT res = 1 NEW_LINE i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT length = int ( log10 ( i ) + 1 ) NEW_LINE if ( length == n ) : NEW_LINE INDENT return int ( log ( i ) // log ( 2 ) ) NEW_LINE DEDENT i *= 2 NEW_LINE DEDENT DEDENT
def isKPartitionPossible ( arr , N , K ) : NEW_LINE INDENT if ( K == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( N < K ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % K != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT target = sum / K NEW_LINE dp = [ 0 for i in range ( 1 << 15 ) ] NEW_LINE for i in range ( ( 1 << N ) ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for mask in range ( ( 1 << N ) ) : NEW_LINE INDENT if ( dp [ mask ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( mask & ( 1 << i ) == 0 ) and dp [ mask ] + arr [ i ] <= target ) : NEW_LINE INDENT dp [ mask ( 1 << i ) ] = ( ( dp [ mask ] + arr [ i ] ) % target ) NEW_LINE DEDENT DEDENT DEDENT if ( dp [ ( 1 << N ) - 1 ] == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def minOperation ( k ) : NEW_LINE INDENT dp = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i // 2 ] + 1 ) NEW_LINE DEDENT DEDENT return dp [ k ] NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( n == 4 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT return 4 ; NEW_LINE DEDENT table = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = 0 ; NEW_LINE DEDENT table [ 0 ] = 0 ; NEW_LINE table [ 2 ] = 1 ; NEW_LINE table [ 4 ] = 2 ; NEW_LINE table [ 6 ] = 4 ; NEW_LINE for i in range ( 8 , n + 1 , 2 ) : NEW_LINE INDENT table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; NEW_LINE DEDENT return table [ n ] ; NEW_LINE DEDENT
def findX ( targetValue ) : NEW_LINE INDENT start = 0 ; NEW_LINE end = targetValue ; NEW_LINE mid = 0 ; NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 ; NEW_LINE if ( mid * mid <= targetValue ) : NEW_LINE INDENT result = mid NEW_LINE start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 ; NEW_LINE DEDENT DEDENT print ( result ) ; NEW_LINE DEDENT
def differentStrings ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] and ( s [ i ] == '1' or s [ i ] == '2' ) ) : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] + dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] NEW_LINE DEDENT DEDENT print ( dp [ n ] ) NEW_LINE DEDENT
def solve ( n , k , m ) : NEW_LINE INDENT if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 0 and k != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n != 0 and k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n < 0 or k < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ n ] [ k ] : NEW_LINE INDENT return dp [ n ] [ k ] NEW_LINE DEDENT ans = 0 NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = ans + solve ( n - j , k - 1 , m ) NEW_LINE DEDENT dp [ n ] [ k ] = ans NEW_LINE return dp [ n ] [ k ] NEW_LINE DEDENT
def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT for q in range ( Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) NEW_LINE ans = - 1 NEW_LINE for k in range ( min_dist + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for row in range ( i - k , i + k + 1 ) : NEW_LINE INDENT for col in range ( j - k , j + k + 1 ) : NEW_LINE INDENT count += matrix [ row ] [ col ] NEW_LINE DEDENT DEDENT if count > K : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ 0 ] [ j ] = ( countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for q in range ( 0 , Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( i , j , R - i - 1 , C - j - 1 ) NEW_LINE ans = - 1 NEW_LINE for k in range ( 0 , min_dist + 1 ) : NEW_LINE INDENT x1 = i - k NEW_LINE x2 = i + k NEW_LINE y1 = j - k NEW_LINE y2 = j + k NEW_LINE count = countDP [ x2 ] [ y2 ] ; NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT if ( count > K ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ 0 ] [ j ] = ( countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for q in range ( 0 , Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( i , j , R - i - 1 , C - j - 1 ) NEW_LINE ans = - 1 NEW_LINE l = 0 NEW_LINE u = min_dist NEW_LINE while ( l <= u ) : NEW_LINE INDENT mid = int ( ( l + u ) / 2 ) NEW_LINE x1 = i - mid NEW_LINE x2 = i + mid NEW_LINE y1 = j - mid NEW_LINE y2 = j + mid NEW_LINE count = countDP [ x2 ] [ y2 ] NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT if ( count <= K ) : NEW_LINE INDENT ans = 2 * mid + 1 NEW_LINE l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT u = mid - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
def numberOfArithmeticSequences ( L , N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( ( L [ i ] - L [ i - 1 ] ) == ( L [ i - 1 ] - L [ i - 2 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT res += count NEW_LINE DEDENT return res NEW_LINE DEDENT
def count_special ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT
def divisorGame ( N , A , dp ) : NEW_LINE INDENT if ( N == 1 or N == 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dp [ N ] [ A ] != - 1 ) : NEW_LINE INDENT return dp [ N ] [ A ] NEW_LINE DEDENT if ( A == 1 ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT for i in range ( 1 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( A ) : NEW_LINE INDENT ans |= divisorGame ( N - i , 0 , dp ) NEW_LINE DEDENT else : NEW_LINE INDENT ans &= divisorGame ( N - i , 1 , dp ) NEW_LINE DEDENT DEDENT DEDENT dp [ N ] [ A ] = ans NEW_LINE return dp [ N ] [ A ] NEW_LINE DEDENT
def findCost ( cost_mat , N , M ) : NEW_LINE INDENT dp = [ [ 0 ] * M for _ in range ( M ) ] NEW_LINE dp [ 0 ] = cost_mat [ 0 ] NEW_LINE for row in range ( 1 , N ) : NEW_LINE INDENT for curr_col in range ( M ) : NEW_LINE INDENT val = 999999999 NEW_LINE for prev_col in range ( M ) : NEW_LINE INDENT if curr_col != prev_col : NEW_LINE INDENT val = min ( val , dp [ row - 1 ] [ prev_col ] ) NEW_LINE DEDENT DEDENT dp [ row ] [ curr_col ] = val + cost_mat [ row ] [ curr_col ] NEW_LINE DEDENT DEDENT return min ( dp [ - 1 ] ) NEW_LINE DEDENT
def k_nonzero_numbers ( s , n , k ) : NEW_LINE INDENT dp = [ [ [ 0 for i in range ( k + 2 ) ] for i in range ( 2 ) ] for i in range ( n + 2 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT for x in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ x ] = 0 NEW_LINE DEDENT DEDENT DEDENT dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( sm < 2 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE if sm : NEW_LINE INDENT y = 9 NEW_LINE DEDENT else : NEW_LINE INDENT y = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT while ( x <= y ) : NEW_LINE INDENT dp [ i + 1 ] [ ( sm or x < ( ord ( s [ i ] ) - ord ( '0' ) ) ) ] [ j + ( x > 0 ) ] += dp [ i ] [ sm ] [ j ] NEW_LINE x += 1 NEW_LINE DEDENT DEDENT sm += 1 NEW_LINE DEDENT DEDENT return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] NEW_LINE DEDENT
def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; NEW_LINE ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; NEW_LINE ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def find_max ( i , sum , v , k ) : NEW_LINE INDENT if ( i == len ( v ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ sum ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) : NEW_LINE INDENT ans = find_max ( i + 1 , sum , v , k ) NEW_LINE DEDENT if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) : NEW_LINE INDENT ans = max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) NEW_LINE DEDENT dp [ i ] [ sum ] = ans NEW_LINE return dp [ i ] [ sum ] NEW_LINE DEDENT
def cntSubSeq ( arr , n ) : NEW_LINE INDENT pos_count = 0 ; NEW_LINE neg_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_count += 1 NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg_count += 1 NEW_LINE DEDENT DEDENT result = int ( math . pow ( 2 , pos_count ) ) NEW_LINE if ( neg_count > 0 ) : NEW_LINE INDENT result *= int ( math . pow ( 2 , neg_count - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE DEDENT return result NEW_LINE DEDENT
def minSteps ( string , n , k ) : NEW_LINE INDENT if ( string [ n - 1 ] == '0' ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n < 4 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT dp = [ 0 ] * n ; NEW_LINE dp [ n - 1 ] = 0 ; NEW_LINE dp [ n - 2 ] = 1 ; NEW_LINE dp [ n - 3 ] = 1 ; NEW_LINE for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT steps = INT_MAX ; NEW_LINE if ( i + k < n and string [ i + k ] == '1' ) : NEW_LINE INDENT steps = min ( steps , dp [ i + k ] ) ; NEW_LINE DEDENT if ( string [ i + 1 ] == '1' ) : NEW_LINE INDENT steps = min ( steps , dp [ i + 1 ] ) ; NEW_LINE DEDENT if ( string [ i + 2 ] == '1' ) : NEW_LINE INDENT steps = min ( steps , dp [ i + 2 ] ) ; NEW_LINE DEDENT dp [ i ] = steps if ( steps == INT_MAX ) else ( 1 + steps ) ; NEW_LINE DEDENT if ( dp [ 0 ] == INT_MAX ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return dp [ 0 ] ; NEW_LINE DEDENT
def eggDrop ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE x = 0 ; NEW_LINE while ( dp [ x ] [ n ] < k ) : NEW_LINE INDENT x += 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; NEW_LINE DEDENT DEDENT return x ; NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f0 = 1 NEW_LINE f1 = 1 NEW_LINE f2 = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT ans = f0 + f1 + f2 NEW_LINE f0 = f1 NEW_LINE f1 = f2 NEW_LINE f2 = ans NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countStr ( N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT
def countSquareMatrices ( a , N , M ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , M ) : NEW_LINE INDENT if ( a [ i ] [ j ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT a [ i ] [ j ] = min ( [ a [ i - 1 ] [ j ] , a [ i ] [ j - 1 ] , a [ i - 1 ] [ j - 1 ] ] ) + 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT count += a [ i ] [ j ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxLengthSquare ( row , column , arr , k ) : NEW_LINE INDENT sum = np . zeros ( ( row + 1 , column + 1 ) ) ; NEW_LINE cur_max = 1 ; NEW_LINE max = 0 ; NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; NEW_LINE if ( i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) : NEW_LINE INDENT max = cur_max ; NEW_LINE cur_max += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ; NEW_LINE DEDENT
def findLargestString ( s , i , r ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return INT_MIN ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] ; NEW_LINE DEDENT v [ i ] [ r ] = 1 ; NEW_LINE dp [ i ] [ r ] = max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( ord ( s [ i ] ) - ord ( '0' ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; NEW_LINE return dp [ i ] [ r ] ; NEW_LINE DEDENT
def findCnt ( s , i , r ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] ; NEW_LINE DEDENT v [ i ] [ r ] = 1 ; NEW_LINE dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( ord ( s [ i ] ) - ord ( '0' ) ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; NEW_LINE return dp [ i ] [ r ] ; NEW_LINE DEDENT
def findMax ( a , n ) : NEW_LINE INDENT dp = np . zeros ( ( n , 2 ) ) ; NEW_LINE dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; NEW_LINE dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; NEW_LINE DEDENT print ( max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) , end = " " ) ; NEW_LINE DEDENT
def minCount ( arr , n , k ) : NEW_LINE INDENT ans = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT sum -= k ; NEW_LINE l = 0 ; NEW_LINE r = 0 ; NEW_LINE tot = 0 ; NEW_LINE while ( l < n ) : NEW_LINE INDENT if ( tot <= sum ) : NEW_LINE INDENT ans = max ( ans , r - l ) ; NEW_LINE if ( r == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT tot += arr [ r ] ; NEW_LINE r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tot -= arr [ l ] ; NEW_LINE l += 1 NEW_LINE DEDENT DEDENT return ( n - ans ) ; NEW_LINE DEDENT
def minMergeCost ( i , j , arr ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT v [ i ] [ j ] = True ; NEW_LINE x = dp [ i ] [ j ] ; NEW_LINE x = sys . maxsize ; NEW_LINE tot = 0 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT tot += arr [ k ] ; NEW_LINE DEDENT for k in range ( i + 1 , j + 1 ) : NEW_LINE INDENT x = min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; NEW_LINE DEDENT return x ; NEW_LINE DEDENT
def expectedSteps ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( x <= 5 ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT if ( v [ x ] ) : NEW_LINE INDENT return dp [ x ] NEW_LINE DEDENT v [ x ] = 1 NEW_LINE dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 NEW_LINE return dp [ x ] NEW_LINE DEDENT
def minDifference ( x , y , k , b , c ) : NEW_LINE INDENT if ( x >= n or y >= m ) : NEW_LINE INDENT return INT_MAX ; NEW_LINE DEDENT if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT diff = b [ x ] [ y ] - c [ x ] [ y ] ; NEW_LINE return min ( abs ( k - diff ) , abs ( k + diff ) ) ; NEW_LINE DEDENT ans = dp [ x ] [ y ] [ k ] ; NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT ans = INT_MAX ; NEW_LINE diff = b [ x ] [ y ] - c [ x ] [ y ] ; NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k + diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k + diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k - diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT
def countSubSeq ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def max_sum ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; NEW_LINE DEDENT return dp [ n ] [ 0 ] ; NEW_LINE DEDENT
def subsequence ( S , T , n , m ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , m + 1 ) ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; NEW_LINE if ( S [ i - 1 ] == T [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT dp [ i ] [ j ] += mod ; NEW_LINE dp [ i ] [ j ] %= mod ; NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] ; NEW_LINE DEDENT
def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ arr [ i ] ] = 0 ; NEW_LINE DEDENT dp [ 0 ] = 1 ; NEW_LINE dp [ 1 ] = 1 if ( dp [ 1 ] == - 1 ) else dp [ 1 ] ; NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; NEW_LINE dp [ i ] %= MOD ; NEW_LINE DEDENT return dp [ k ] ; NEW_LINE DEDENT
def findCount ( n ) : NEW_LINE INDENT return int ( math . log ( n , 2 ) ) + 1 NEW_LINE DEDENT
def findMax ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ j ] % arr [ i ] == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT res = max ( count , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) NEW_LINE return dp [ i ] [ curr ] NEW_LINE DEDENT
def findSetBits ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) ; NEW_LINE print ( dp [ 0 ] , end = " ▁ " ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i // 2 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i // 2 ] + 1 ; NEW_LINE DEDENT print ( dp [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( not curr ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT
def findCnt ( arr , i , required_sum , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( required_sum == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ required_sum + base ] ) : NEW_LINE INDENT return dp [ i ] [ required_sum + base ] ; NEW_LINE DEDENT v [ i ] [ required_sum + base ] = 1 ; NEW_LINE dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; NEW_LINE return dp [ i ] [ required_sum + base ] ; NEW_LINE DEDENT
def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return ( curr == m ) ; NEW_LINE DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; NEW_LINE return dp [ i ] [ curr ] ; NEW_LINE DEDENT
def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return ( curr == m ) ; NEW_LINE DEDENT if ( v1 [ i ] [ curr ] ) : NEW_LINE INDENT return dp1 [ i ] [ curr ] ; NEW_LINE DEDENT v1 [ i ] [ curr ] = 1 ; NEW_LINE dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; NEW_LINE return dp1 [ i ] [ curr ] ; NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def LISusingLCS ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE sortedseq = sorted ( seq ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ n ] [ n ] NEW_LINE DEDENT
def count_numbers ( k , n , flag ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count_numbers ( k , n - 1 , 1 ) NEW_LINE DEDENT DEDENT
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT
def cntSubsets ( arr , n ) : NEW_LINE INDENT max = pow ( 2 , n ) NEW_LINE result = 0 NEW_LINE for i in range ( max ) : NEW_LINE INDENT counter = i NEW_LINE if ( counter & ( counter >> 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT result += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def cntSubsets ( arr , n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n ; NEW_LINE a [ 0 ] = b [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; NEW_LINE b [ i ] = a [ i - 1 ] ; NEW_LINE DEDENT result = a [ n - 1 ] + b [ n - 1 ] ; NEW_LINE return result ; NEW_LINE DEDENT
def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE DEDENT
def ways ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] % mod NEW_LINE DEDENT
def minJumps ( arr , N ) : NEW_LINE INDENT fib = [ 0 for i in range ( 30 ) ] NEW_LINE fib [ 0 ] = 0 NEW_LINE fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , 30 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DP = [ 0 for i in range ( N + 2 ) ] NEW_LINE DP [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 2 ) : NEW_LINE INDENT DP [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , N + 2 ) : NEW_LINE INDENT for j in range ( 1 , 30 ) : NEW_LINE INDENT if ( ( arr [ i - 1 ] == 1 or i == N + 1 ) and i - fib [ j ] >= 0 ) : NEW_LINE INDENT DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) NEW_LINE DEDENT DEDENT DEDENT if ( DP [ N + 1 ] != MAX ) : NEW_LINE INDENT return DP [ N + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def Max_Sum ( arr1 , arr2 , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = arr1 [ i ] NEW_LINE dp [ i ] [ 1 ] = arr2 [ i ] NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) NEW_LINE DEDENT DEDENT return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT
def Probability ( p , n ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , n + 1 ) ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0.0 NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 1.0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT ans = 0.0 ; NEW_LINE for i in range ( ( n + 1 ) // 2 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def count_required_sequence ( n , arr ) : NEW_LINE INDENT total_required_subsequence = 0 ; NEW_LINE total_n_required_subsequence = 0 ; NEW_LINE dp = np . zeros ( ( N , 2 ) ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT turn_required = 0 ; NEW_LINE for j in range ( - 1 , 2 , 1 ) : NEW_LINE INDENT turn_required += dp [ arr [ i ] + j ] [ 0 ] ; NEW_LINE DEDENT required_end_i = ( total_required_subsequence + turn_required ) ; NEW_LINE n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; NEW_LINE total_required_subsequence += required_end_i ; NEW_LINE total_n_required_subsequence += n_required_end_i ; NEW_LINE dp [ arr [ i ] ] [ 1 ] += required_end_i ; NEW_LINE dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; NEW_LINE DEDENT return total_required_subsequence ; NEW_LINE DEDENT
def maxSum ( arr , i , n , k ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( visit [ i ] ) : NEW_LINE INDENT return dp [ i ] ; NEW_LINE DEDENT visit [ i ] = 1 ; NEW_LINE tot = 0 ; NEW_LINE dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; NEW_LINE j = i NEW_LINE while ( j < i + k and j < n ) : NEW_LINE INDENT tot += arr [ j ] ; NEW_LINE dp [ i ] = max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; NEW_LINE j += 1 NEW_LINE DEDENT return dp [ i ] ; NEW_LINE DEDENT
def minSum ( A , B , C , i , n , curr , dp ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ n ] [ curr ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ curr ] ; NEW_LINE DEDENT if ( curr == 0 ) : NEW_LINE INDENT dp [ n ] [ curr ] = min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; NEW_LINE return dp [ n ] [ curr ] NEW_LINE DEDENT if ( curr == 1 ) : NEW_LINE INDENT dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; NEW_LINE return dp [ n ] [ curr ] NEW_LINE DEDENT dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; NEW_LINE return dp [ n ] [ curr ] NEW_LINE DEDENT
def getChicks ( n ) : NEW_LINE INDENT chicks = pow ( 3 , n - 1 ) NEW_LINE return chicks NEW_LINE DEDENT
def sumMax ( i , arr , n ) : NEW_LINE INDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] ) : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT v [ i ] = True NEW_LINE dp [ i ] = max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) NEW_LINE return dp [ i ] NEW_LINE DEDENT
def maxSum ( arr , i , n ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] ) : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT v [ i ] = 1 NEW_LINE dp [ i ] = max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) NEW_LINE return dp [ i ] NEW_LINE DEDENT
def MinOfCubed ( k ) : NEW_LINE INDENT if ( k < 8 ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT res = k ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ( i * i * i ) > k ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def MinOfCubedDP ( k ) : NEW_LINE INDENT DP = [ 0 ] * ( k + 1 ) ; NEW_LINE j = 1 ; NEW_LINE t = 1 ; NEW_LINE DP [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT DP [ i ] = sys . maxsize ; NEW_LINE while ( j <= i ) : NEW_LINE INDENT if ( j == i ) : NEW_LINE INDENT DP [ i ] = 1 ; NEW_LINE DEDENT elif ( DP [ i ] > DP [ i - j ] ) : NEW_LINE INDENT DP [ i ] = DP [ i - j ] + 1 ; NEW_LINE DEDENT t += 1 ; NEW_LINE j = t * t * t ; NEW_LINE DEDENT t = j = 1 ; NEW_LINE DEDENT return DP [ k ] ; NEW_LINE DEDENT
def LIS ( a , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE d = [ 0 for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ a [ i ] ] = 1 NEW_LINE for j in range ( 2 , a [ i ] ) : NEW_LINE INDENT if j * j > a [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT if ( a [ i ] % j == 0 ) : NEW_LINE INDENT dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) NEW_LINE dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] // j ] ] + 1 ) NEW_LINE d [ j ] = a [ i ] NEW_LINE d [ a [ i ] // j ] = a [ i ] NEW_LINE DEDENT DEDENT ans = max ( ans , dp [ a [ i ] ] ) NEW_LINE d [ a [ i ] ] = a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = a [ i - 1 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] NEW_LINE if i >= 2 : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) NEW_LINE DEDENT if i >= 2 : NEW_LINE INDENT dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] NEW_LINE DEDENT if i >= 3 : NEW_LINE INDENT dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) NEW_LINE DEDENT ans = max ( ans , dp [ i ] [ 0 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 1 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 2 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] > 0 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = True NEW_LINE dp [ i ] [ j ] [ m ] = ( findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ) NEW_LINE return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT
def CountWays ( r , b , l , R , B , W , dp ) : NEW_LINE INDENT if ( l > W ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( r > R ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( b == B and r == R ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( b == B ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ r ] [ b ] [ l ] != - 1 ) : NEW_LINE INDENT return dp [ r ] [ b ] [ l ] NEW_LINE DEDENT ans = 0 ; NEW_LINE ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; NEW_LINE ans = ans % mod ; NEW_LINE dp [ r ] [ b ] [ l ] = ans NEW_LINE return ans ; NEW_LINE DEDENT
def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT
def findWays ( p ) : NEW_LINE INDENT dp = [ 0 ] * ( p + 1 ) NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 2 NEW_LINE for i in range ( 3 , p + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return dp [ p ] NEW_LINE DEDENT
def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT
def totalSubSets ( n , l , r ) : NEW_LINE INDENT MOD = 1000000007 ; NEW_LINE zero = ( math . floor ( r / 3 ) - math . ceil ( l / 3 ) + 1 ) ; NEW_LINE one = ( math . floor ( ( r - 1 ) / 3 ) - math . ceil ( ( l - 1 ) / 3 ) + 1 ) ; NEW_LINE two = ( math . floor ( ( r - 2 ) / 3 ) - math . ceil ( ( l - 2 ) / 3 ) + 1 ) ; NEW_LINE dp = [ [ 0 for x in range ( 3 ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = zero ; NEW_LINE dp [ 0 ] [ 1 ] = one ; NEW_LINE dp [ 0 ] [ 2 ] = two ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; NEW_LINE dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; NEW_LINE dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; NEW_LINE DEDENT return dp [ n - 1 ] [ 0 ] ; NEW_LINE DEDENT
def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( diff == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] ; NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) ; NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; NEW_LINE dp [ idx ] [ diff ] = ans % MOD ; NEW_LINE return dp [ idx ] [ diff ] NEW_LINE DEDENT
def maxPathSum ( tri ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , N - i ) : NEW_LINE INDENT if ( j - 1 >= 0 ) : NEW_LINE INDENT tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; NEW_LINE DEDENT ans = max ( ans , tri [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def get_max_splits ( num_string ) : NEW_LINE INDENT count = 0 NEW_LINE running_sum = 0 NEW_LINE for i in range ( len ( num_string ) ) : NEW_LINE INDENT current_num = int ( num_string [ i ] ) NEW_LINE running_sum += current_num NEW_LINE if current_num % 3 == 0 or ( running_sum != 0 and running_sum % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPaths ( Sum , get , m , n , dp ) : NEW_LINE INDENT if ( Sum < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( Sum == 0 ) : NEW_LINE INDENT return get NEW_LINE DEDENT if ( dp [ Sum ] [ get ] != - 1 ) : NEW_LINE INDENT return dp [ Sum ] [ get ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT res += countPaths ( Sum - i , 1 , m , n , dp ) NEW_LINE res += countPaths ( Sum - i , get , m , n , dp ) NEW_LINE DEDENT DEDENT dp [ Sum ] [ get ] = res NEW_LINE return dp [ Sum ] [ get ] NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE x = 3 NEW_LINE dp = [ [ - 1 for i in range ( 2 ) ] for i in range ( Max + 1 ) ] NEW_LINE for i in range ( Max + 1 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT
def solve ( x ) : NEW_LINE INDENT ans , temp = 0 , x NEW_LINE if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT last = x % 10 NEW_LINE while ( x ) : NEW_LINE INDENT first = x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if ( first <= last ) : NEW_LINE INDENT ans = 9 + temp // 10 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 8 + temp // 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findMinimumCost ( n , x , y ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] = x NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i & 1 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) // 2 ] + y + x ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ i // 2 ] + y ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE dp [ index ] [ cnt ] = ans NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT
def sumOddFibonacci ( n ) : NEW_LINE INDENT Sum = [ 0 ] * ( n + 1 ) ; NEW_LINE Sum [ 0 ] = 0 ; NEW_LINE Sum [ 1 ] = 1 ; NEW_LINE Sum [ 2 ] = 2 ; NEW_LINE Sum [ 3 ] = 5 ; NEW_LINE Sum [ 4 ] = 10 ; NEW_LINE Sum [ 5 ] = 23 ; NEW_LINE for i in range ( 6 , n + 1 ) : NEW_LINE INDENT Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; NEW_LINE DEDENT return Sum [ n ] ; NEW_LINE DEDENT
def MaxProfit ( treasure , color , n , k , col , A , B ) : NEW_LINE INDENT sum = 0 NEW_LINE if k == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if col == color [ k ] : NEW_LINE INDENT sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def MaxProfit ( treasure , color , n , k , col , A , B ) : NEW_LINE INDENT if ( k == n ) : NEW_LINE INDENT dp [ k ] [ col ] = 0 NEW_LINE return dp [ k ] [ col ] NEW_LINE DEDENT if ( dp [ k ] [ col ] != - 1 ) : NEW_LINE INDENT return dp [ k ] [ col ] NEW_LINE DEDENT summ = 0 NEW_LINE if ( col == color [ k ] ) : NEW_LINE INDENT summ += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT else : NEW_LINE INDENT summ += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT dp [ k ] [ col ] = summ NEW_LINE return dp [ k ] [ col ] NEW_LINE DEDENT
def calculateEvenSum ( n ) : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( 2 * n + 1 ) NEW_LINE fibo [ 0 ] , fibo [ 1 ] = 0 , 1 NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , 2 * n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT sum += fibo [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def find ( index , openbrk , n , adj ) : NEW_LINE INDENT if ( openbrk < 0 ) : NEW_LINE INDENT return MAX_VAL NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT if ( openbrk == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return MAX_VAL NEW_LINE DEDENT DEDENT if ( dp [ index ] [ openbrk ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ openbrk ] NEW_LINE DEDENT dp [ index ] [ openbrk ] = min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) NEW_LINE return dp [ index ] [ openbrk ] NEW_LINE DEDENT
def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( 1 , n ) : NEW_LINE INDENT count = 1 NEW_LINE c = 1 NEW_LINE for i in range ( 1 , row_num ) : NEW_LINE INDENT c = c * ( row_num - i ) / i NEW_LINE if ( c % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minFallingPathSum ( A ) : NEW_LINE INDENT for R in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for C in range ( n ) : NEW_LINE INDENT best = A [ R + 1 ] [ C ] NEW_LINE if C > 0 : NEW_LINE INDENT best = min ( best , A [ R + 1 ] [ C - 1 ] ) NEW_LINE DEDENT if C + 1 < n : NEW_LINE INDENT best = min ( best , A [ R + 1 ] [ C + 1 ] ) NEW_LINE DEDENT A [ R ] [ C ] = A [ R ] [ C ] + best NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = min ( ans , A [ 0 ] [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def fun ( marks , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( 0 , n ) ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if marks [ i ] > marks [ i + 1 ] : NEW_LINE INDENT temp = i NEW_LINE while True : NEW_LINE INDENT if marks [ temp ] > marks [ temp + 1 ] and temp >= 0 : NEW_LINE INDENT if dp [ temp ] > dp [ temp + 1 ] : NEW_LINE INDENT temp -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ temp ] = dp [ temp + 1 ] + 1 NEW_LINE temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT elif marks [ i ] < marks [ i + 1 ] : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] + 1 NEW_LINE DEDENT DEDENT return ( sum ( dp ) ) NEW_LINE DEDENT
def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT
def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT if m == 1 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) NEW_LINE DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i == 1 or j == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 1 , n - 1 ) : NEW_LINE INDENT for i in range ( n - L ) : NEW_LINE INDENT dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) NEW_LINE DEDENT DEDENT return dp [ 1 ] [ n - 1 ] NEW_LINE DEDENT
def lds ( arr , n ) : NEW_LINE INDENT lds = [ 0 for i in range ( n ) ] NEW_LINE lds [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( lds [ j ] != 0 and arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT lds [ i ] = max ( lds [ i ] , lds [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max ( lds ) NEW_LINE DEDENT
def find ( start , adj , n , dp ) : NEW_LINE INDENT if ( start == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ start ] != - 1 ) : NEW_LINE INDENT return dp [ start ] NEW_LINE DEDENT dp [ start ] = 0 NEW_LINE one = 0 NEW_LINE zero = 0 NEW_LINE for k in range ( start , n , 1 ) : NEW_LINE INDENT if ( adj [ k ] == '1' ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( one > zero ) : NEW_LINE INDENT dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) NEW_LINE DEDENT DEDENT return dp [ start ] NEW_LINE DEDENT
def alternateFib ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT f1 = 0 ; NEW_LINE f2 = 1 ; NEW_LINE print ( f1 , end = " ▁ " ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f3 = f2 + f1 ; NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT print ( f3 , end = " ▁ " ) ; NEW_LINE DEDENT f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE DEDENT DEDENT
def printTetra ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 5 ) ; NEW_LINE dp [ 0 ] = 0 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE dp [ 3 ] = 2 ; NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ) ; NEW_LINE DEDENT print ( dp [ n ] ) ; NEW_LINE DEDENT
def printTetra ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT first = 0 ; NEW_LINE second = 1 ; NEW_LINE third = 1 ; NEW_LINE fourth = 2 ; NEW_LINE curr = 0 ; NEW_LINE if ( n == 0 ) : NEW_LINE INDENT print ( first ) ; NEW_LINE DEDENT elif ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( second ) ; NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT print ( fourth ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 4 , n + 1 ) : NEW_LINE INDENT curr = first + second + third + fourth ; NEW_LINE first = second ; NEW_LINE second = third ; NEW_LINE third = fourth ; NEW_LINE fourth = curr ; NEW_LINE DEDENT DEDENT print ( curr ) ; NEW_LINE DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp = [ None ] * n NEW_LINE if n == 1 : NEW_LINE INDENT return cost [ 0 ] NEW_LINE DEDENT dp [ 0 ] = cost [ 0 ] NEW_LINE dp [ 1 ] = cost [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] NEW_LINE DEDENT return min ( dp [ n - 2 ] , dp [ n - 1 ] ) NEW_LINE DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT
def countPaths ( n ) : NEW_LINE INDENT zB = 1 NEW_LINE zADC = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT nzB = zADC * 3 NEW_LINE nzADC = ( zADC * 2 + zB ) NEW_LINE zB = nzB NEW_LINE zADC = nzADC NEW_LINE DEDENT return zB NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT if term [ n ] != 0 : NEW_LINE INDENT return term [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE return term [ n ] NEW_LINE DEDENT DEDENT
def lds ( arr , n ) : NEW_LINE INDENT lds = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lds [ i ] ) : NEW_LINE INDENT max = lds [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT return n << ( n - 1 ) ; NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE print ( c , end = ' ▁ ' ) NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT DEDENT
def largestSumOfAverages ( A , K ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE pre_sum = [ 0 ] * ( n + 1 ) ; NEW_LINE pre_sum [ 0 ] = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; NEW_LINE DEDENT dp = [ 0 ] * n ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; NEW_LINE DEDENT for k in range ( K - 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ 0 ] ) ; NEW_LINE DEDENT
def minSumPath ( A ) : NEW_LINE INDENT memo = [ None ] * len ( A ) NEW_LINE n = len ( A ) - 1 NEW_LINE for i in range ( len ( A [ n ] ) ) : NEW_LINE INDENT memo [ i ] = A [ n ] [ i ] NEW_LINE DEDENT for i in range ( len ( A ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( len ( A [ i ] ) ) : NEW_LINE INDENT memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT return memo [ 0 ] NEW_LINE DEDENT
def findSDSFunc ( n ) : NEW_LINE INDENT DP = [ 0 ] * ( n + 1 ) NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( int ( i % 2 ) == 0 ) : NEW_LINE INDENT DP [ i ] = DP [ int ( i / 2 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] ) NEW_LINE DEDENT DEDENT return DP [ n ] NEW_LINE DEDENT
def isPossible ( index , sum ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( ( sum % M ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) ; NEW_LINE placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) ; NEW_LINE if ( placeAdd or placeMinus ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def Golomb ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 1 ] = 1 NEW_LINE print ( dp [ 1 ] , end = " ▁ " ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] NEW_LINE print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def removals ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT ans = n - 1 NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE j = dp [ i - 1 ] NEW_LINE while ( j != i and arr [ i ] - arr [ j ] > k ) : NEW_LINE j += 1 NEW_LINE dp [ i ] = min ( dp [ i ] , j ) NEW_LINE ans = min ( ans , ( n - ( i - j + 1 ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maximumSegments ( n , a , b , c ) : NEW_LINE INDENT dp = [ - 1 ] * ( n + 10 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( dp [ i ] != - 1 ) : NEW_LINE INDENT dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) NEW_LINE dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) NEW_LINE dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def sequence ( n ) : NEW_LINE INDENT f = [ 0 , 1 , 1 ] NEW_LINE print ( f [ 1 ] , end = " ▁ " ) , NEW_LINE print ( f [ 2 ] , end = " ▁ " ) , NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) NEW_LINE print ( f [ i ] , end = " ▁ " ) , NEW_LINE DEDENT DEDENT
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) NEW_LINE if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : NEW_LINE INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; NEW_LINE DEDENT if ( cnt [ i ] [ j ] >= k ) : NEW_LINE INDENT for a in range ( k , cnt [ i ] [ j ] + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return lcs [ n ] [ m ] NEW_LINE DEDENT
def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT
def find_prob ( N , P ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = P NEW_LINE dp [ 3 ] = 1 - P NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT
def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483648 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def maximumSumSubarray ( arr , n ) : NEW_LINE INDENT min_prefix_sum = 0 NEW_LINE res = - math . inf NEW_LINE prefix_sum = [ ] NEW_LINE prefix_sum . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum . append ( prefix_sum [ i - 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res = max ( res , prefix_sum [ i ] - min_prefix_sum ) NEW_LINE min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPath ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , row ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ 0 ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , row ) : NEW_LINE INDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ row - 1 ] [ col - 1 ] == 1 ) NEW_LINE DEDENT arr = [ [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , 0 , - 1 , - 1 ] , [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , - 1 , 0 , - 1 ] , [ 0 , 0 , - 1 , 0 , 0 ] ] NEW_LINE if ( isPath ( arr ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT res = [ 0 ] * ( n + 2 ) NEW_LINE res [ 0 ] = 1 NEW_LINE res [ 1 ] = 1 NEW_LINE res [ 2 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 4 NEW_LINE if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return c NEW_LINE DEDENT for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = c + b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE DEDENT return d NEW_LINE DEDENT
def numberofways ( n , m ) : NEW_LINE INDENT dp = np . zeros ( ( n + 2 , n + 2 ) ) NEW_LINE dp [ 0 ] [ n + 1 ] = 1 NEW_LINE for k in range ( n , m - 1 , - 1 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ] NEW_LINE if ( i - k >= 0 ) : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def zigzag ( n , k ) : NEW_LINE INDENT if ( n == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; NEW_LINE DEDENT
def zigzag ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def preprocess ( list , steps ) : NEW_LINE INDENT ways [ 0 ] [ 8 ] [ 8 ] = 1 NEW_LINE for N in range ( 1 , 16 , 1 ) : NEW_LINE INDENT for i in range ( 1 , depth , 1 ) : NEW_LINE INDENT for j in range ( 1 , depth , 1 ) : NEW_LINE INDENT ways [ N ] [ i ] [ j ] = ( ways [ N - 1 ] [ i ] [ j + 1 ] + ways [ N - 1 ] [ i ] [ j - 1 ] + ways [ N - 1 ] [ i + 1 ] [ j ] + ways [ N - 1 ] [ i - 1 ] [ j ] + ways [ N - 1 ] [ i + 1 ] [ j - 1 ] + ways [ N - 1 ] [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT list [ N ] = ways [ N ] [ 8 ] [ 8 ] NEW_LINE DEDENT print ( " Number ▁ of ▁ walks ▁ possible ▁ is / are " , list [ steps ] ) NEW_LINE DEDENT
def eulerian ( n , m ) : NEW_LINE INDENT if ( m >= n or n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) NEW_LINE DEDENT
def eulerian ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def nswp ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT
def nswp ( n ) : NEW_LINE INDENT dp = [ 1 for x in range ( n + 1 ) ] ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; NEW_LINE DEDENT return dp [ n ] ; NEW_LINE DEDENT
def longOddEvenIncSeq ( arr , n ) : NEW_LINE INDENT lioes = list ( ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lioes . append ( 1 ) NEW_LINE DEDENT i = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : NEW_LINE INDENT lioes [ i ] = lioes [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if maxLen < lioes [ i ] : NEW_LINE INDENT maxLen = lioes [ i ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
def dealnnoy ( n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) NEW_LINE DEDENT
def dealnnoy ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def longestAlternating ( arr , n ) : NEW_LINE INDENT count = [ None ] * n NEW_LINE count [ n - 1 ] = 1 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( arr [ i ] * arr [ i + 1 ] < 0 ) : NEW_LINE INDENT count [ i ] = count [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 1 ; NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT print ( count [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT
def maxDP ( n ) : NEW_LINE INDENT res = list ( ) NEW_LINE res . append ( 0 ) NEW_LINE res . append ( 1 ) NEW_LINE i = 2 NEW_LINE while i < n + 1 : NEW_LINE INDENT res . append ( max ( i , ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) ) NEW_LINE i = i + 1 NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT
def countarray ( n , k , x ) : NEW_LINE INDENT dp = list ( ) NEW_LINE dp . append ( 0 ) NEW_LINE dp . append ( 1 ) NEW_LINE i = 2 NEW_LINE while i < n : NEW_LINE INDENT dp . append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] ) NEW_LINE DEDENT
def largestSubset ( a , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 or a [ i ] % a [ j ] == 0 : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT
def maxSum ( mat , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE maxSum = INT_MIN NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxi = INT_MIN NEW_LINE if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + maxi NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
def answer ( n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 ; NEW_LINE DEDENT for j in range ( 10 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ n ] [ j ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ int ( ch ) for ch in st ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT st = "3144" NEW_LINE if ( isSubSeqDivisible ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( l , n ) : NEW_LINE INDENT i += 1 NEW_LINE if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( dp [ x ] ) NEW_LINE DEDENT
def alternateSubarray ( arr , n ) : NEW_LINE INDENT len = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT len . append ( 0 ) NEW_LINE DEDENT len [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] ^ arr [ i + 1 ] == True ) : NEW_LINE INDENT len [ i ] = len [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( len [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
def productSubSeqCount ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ k ] [ n ] NEW_LINE DEDENT
def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != MAX ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ None ] * n NEW_LINE msds = [ None ] * n NEW_LINE max_sum = 0 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] NEW_LINE dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) NEW_LINE DEDENT return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] NEW_LINE DEDENT
def countways ( n ) : NEW_LINE INDENT A = [ 0 for i in range ( n + 2 ) ] NEW_LINE A [ 0 ] = 1 NEW_LINE A [ 1 ] = 3 NEW_LINE A [ 2 ] = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] NEW_LINE DEDENT return A [ n ] NEW_LINE DEDENT
def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mls . append ( 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def findWinner ( x , y , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = False NEW_LINE dp [ 1 ] = True NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i - 1 >= 0 and not dp [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT elif ( i - x >= 0 and not dp [ i - x ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT elif ( i - y >= 0 and not dp [ i - y ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = False NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT x = 3 ; y = 4 ; n = 5 NEW_LINE if ( findWinner ( x , y , n ) ) : NEW_LINE INDENT print ( ' A ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' B ' ) NEW_LINE DEDENT
def maxGameByWinner ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE i = 1 NEW_LINE while dp [ i ] <= N : NEW_LINE INDENT i = i + 1 NEW_LINE dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE DEDENT return ( i - 1 ) NEW_LINE DEDENT
def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = True NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = False NEW_LINE DEDENT elif ( arr [ i - 1 ] <= j ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n % 2 ] [ sum ] NEW_LINE DEDENT arr = [ 6 , 2 , 5 ] NEW_LINE sum = 7 NEW_LINE n = len ( arr ) NEW_LINE if ( isSubsetSum ( arr , n , sum ) == True ) : NEW_LINE INDENT print ( " There ▁ exists ▁ a ▁ subset ▁ with ▁ given ▁ sum " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ subset ▁ exists ▁ with ▁ given ▁ sum " ) NEW_LINE DEDENT
def isPossible ( elements , target ) : NEW_LINE INDENT dp = [ False ] * ( target + 1 ) NEW_LINE dp [ 0 ] = True NEW_LINE for ele in elements : NEW_LINE INDENT for j in range ( target , ele - 1 , - 1 ) : NEW_LINE INDENT if dp [ j - ele ] : NEW_LINE INDENT dp [ j ] = True NEW_LINE DEDENT DEDENT DEDENT return dp [ target ] NEW_LINE DEDENT arr = [ 6 , 2 , 5 ] NEW_LINE target = 7 NEW_LINE if isPossible ( arr , target ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT
def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT min_ending_here = sys . maxsize NEW_LINE min_so_far = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min_ending_here > 0 ) : NEW_LINE INDENT min_ending_here = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT min_ending_here += arr [ i ] NEW_LINE DEDENT min_so_far = min ( min_so_far , min_ending_here ) NEW_LINE DEDENT return min_so_far NEW_LINE DEDENT
def nonDecNums ( n ) : NEW_LINE INDENT a = np . zeros ( ( n + 1 , 10 ) ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return int ( a [ n ] [ 0 ] ) NEW_LINE DEDENT
def countWays ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 1000000007 NEW_LINE same , diff = 0 , k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = total * ( k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = ( same + diff ) % mod NEW_LINE DEDENT return total NEW_LINE DEDENT
def countBT ( h ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE dp = [ 0 for i in range ( h + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , h + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD NEW_LINE DEDENT return dp [ h ] NEW_LINE DEDENT
def minTimeForWritingChars ( N , insert , remov , cpy ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return insert NEW_LINE DEDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 1 ] = insert NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + cpy ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + cpy + remov ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
def sumOfSubstrings ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE INDENT mf = 1 NEW_LINE for i in range ( len ( num ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( int ( num [ i ] ) ) * ( i + 1 ) * mf NEW_LINE mf = mf * 10 + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m or i == 1 ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
def maxSum ( grid , n ) : NEW_LINE INDENT incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = max ( excl , incl ) NEW_LINE incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) NEW_LINE excl = excl_new NEW_LINE DEDENT return max ( excl , incl ) NEW_LINE DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif i < j : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif j == 1 : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT
def minInsertionStepToSortArray ( arr , N ) : NEW_LINE INDENT lis = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT max = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return ( N - max ) NEW_LINE DEDENT
def printDistinct ( str ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != ' ▁ ' ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT n = i NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( count [ ord ( str [ i ] ) ] == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while ( j < n - 1 and j <= arr [ i ] + i ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minStepToDeleteString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] NEW_LINE for l in range ( 1 , N + 1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = l - 1 NEW_LINE while j < N : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT for K in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ K ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT
def solve ( i , par , a , n , k , current_ans ) : NEW_LINE INDENT if ( par > k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT global ans NEW_LINE if ( par == k and i == n - 1 ) : NEW_LINE INDENT ans = min ( ans , current_ans ) NEW_LINE return 0 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT
def minCost ( a , n , k ) : NEW_LINE INDENT dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] ; NEW_LINE dp [ 0 ] [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] ; NEW_LINE DEDENT
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ) NEW_LINE DEDENT
def solve ( n , lookup = { } ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n not in lookup : NEW_LINE INDENT lookup [ n ] = ( solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ) NEW_LINE DEDENT return lookup [ n ] NEW_LINE DEDENT
def countSubsequences ( s ) : NEW_LINE INDENT aCount = 0 NEW_LINE bCount = 0 NEW_LINE cCount = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT aCount = ( 1 + 2 * aCount ) NEW_LINE DEDENT elif ( s [ i ] == ' b ' ) : NEW_LINE INDENT bCount = ( aCount + 2 * bCount ) NEW_LINE DEDENT elif ( s [ i ] == ' c ' ) : NEW_LINE INDENT cCount = ( bCount + 2 * cCount ) NEW_LINE DEDENT DEDENT return cCount NEW_LINE DEDENT
def maximumDifferenceSum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 , 0 ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT
def countStr ( n , bCount , cCount ) : NEW_LINE INDENT if ( bCount < 0 or cCount < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bCount == 0 and cCount == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = countStr ( n - 1 , bCount , cCount ) NEW_LINE res += countStr ( n - 1 , bCount - 1 , cCount ) NEW_LINE res += countStr ( n - 1 , bCount , cCount - 1 ) NEW_LINE return res NEW_LINE DEDENT
def maxRevenue ( m , x , revenue , n , t ) : NEW_LINE INDENT maxRev = [ 0 ] * ( m + 1 ) NEW_LINE nxtbb = 0 ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( nxtbb < n ) : NEW_LINE INDENT if ( x [ nxtbb ] != i ) : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( i <= t ) : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; NEW_LINE DEDENT nxtbb += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT DEDENT return maxRev [ m ] NEW_LINE DEDENT
def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def largestKSubmatrix ( a ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ] NEW_LINE result = 0 NEW_LINE for i in range ( Row ) : NEW_LINE INDENT for j in range ( Col ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT result = max ( result , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countDivisibleSubseq ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ l - 1 ] [ 0 ] NEW_LINE DEDENT
def MaximumPath ( Mat ) : NEW_LINE INDENT result = 0 NEW_LINE dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT result = max ( result , dp [ N - 1 ] [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j >= 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT
def canVote ( a , n , x ) : NEW_LINE INDENT dp = [ [ 0 ] * ( x + 1 ) for _ in range ( n + 1 ) ] NEW_LINE a = a [ : ] NEW_LINE a . append ( 0 ) NEW_LINE sm = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sm += a [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT if a [ i ] <= j : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return ( sm - dp [ n ] [ x ] ) <= x NEW_LINE DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i <= 2 ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT global dp NEW_LINE if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) NEW_LINE return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] = n NEW_LINE return dp [ n ] NEW_LINE DEDENT DEDENT
def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT
def findMaxPoints ( A ) : NEW_LINE INDENT P1S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT for j in range ( 2 , M ) : NEW_LINE INDENT op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] NEW_LINE op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] NEW_LINE ans = max ( ans , max ( op1 , op2 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def MaxDotProduct ( A , B , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , m + 1 , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT
def printDistSum ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( Sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def printMaxSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE maxi = 0 NEW_LINE for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) : NEW_LINE INDENT if ( dp [ j - 1 ] > maxi ) : NEW_LINE INDENT maxi = dp [ j - 1 ] NEW_LINE DEDENT if ( dp [ ( i + 1 ) // j - 1 ] > maxi and j != 1 ) : NEW_LINE INDENT maxi = dp [ ( i + 1 ) // j - 1 ] NEW_LINE DEDENT DEDENT DEDENT dp [ i ] += maxi NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( dp [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) ) NEW_LINE DEDENT if ( n == 4 ) : NEW_LINE INDENT return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) NEW_LINE DEDENT dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = arr [ 1 ] NEW_LINE dp [ 2 ] = arr [ 2 ] NEW_LINE dp [ 3 ] = arr [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) NEW_LINE DEDENT return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) NEW_LINE DEDENT
def minSum ( ar , n ) : NEW_LINE INDENT if ( n <= 4 ) : NEW_LINE INDENT return min ( ar ) NEW_LINE DEDENT sum = [ 0 for i in range ( n ) ] NEW_LINE sum [ 0 ] = ar [ 0 ] NEW_LINE sum [ 1 ] = ar [ 1 ] NEW_LINE sum [ 2 ] = ar [ 2 ] NEW_LINE sum [ 3 ] = ar [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) NEW_LINE DEDENT return min ( sum [ n - 4 : n ] ) NEW_LINE DEDENT
def longestSubseqWithDiffOne ( arr , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < dp [ i ] ) : NEW_LINE INDENT result = dp [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxSumWO3Consec ( arr , n ) : NEW_LINE INDENT sum = [ 0 for k in range ( n ) ] NEW_LINE if n >= 1 : NEW_LINE INDENT sum [ 0 ] = arr [ 0 ] NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT sum [ 1 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) NEW_LINE DEDENT return sum [ n - 1 ] NEW_LINE DEDENT
def maxSumWO3Consec ( n ) : NEW_LINE INDENT if ( sum [ n ] != - 1 ) : NEW_LINE INDENT return sum [ n ] NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT sum [ n ] = 0 NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT sum [ n ] = arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT sum [ n ] = arr [ 1 ] + arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) NEW_LINE return sum [ n ] NEW_LINE DEDENT
def pad ( n ) : NEW_LINE INDENT pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT pNext = pPrevPrev + pPrev NEW_LINE pPrevPrev = pPrev NEW_LINE pPrev = pCurr NEW_LINE pCurr = pNext NEW_LINE DEDENT return pNext ; NEW_LINE DEDENT
def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 ] * N NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE if ( arr [ i ] - arr [ i - 1 ] < K ) : NEW_LINE INDENT if ( i >= 2 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ N - 1 ] NEW_LINE DEDENT
def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : NEW_LINE INDENT maxSum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] < k ) : NEW_LINE INDENT maxSum += arr [ i ] NEW_LINE maxSum += arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return maxSum NEW_LINE DEDENT
def lucas ( n ) : NEW_LINE INDENT a = 2 NEW_LINE b = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT
def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n ) NEW_LINE DEDENT
def breakSum ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) ; NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def countPS ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT cps [ i ] [ i ] = 1 NEW_LINE DEDENT for L in range ( 2 , N + 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT k = L + i - 1 NEW_LINE if ( k < N ) : NEW_LINE INDENT if ( str [ i ] == str [ k ] ) : NEW_LINE INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return cps [ 0 ] [ N - 1 ] NEW_LINE DEDENT
def countPS ( i , j ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT
def maxCost ( mat , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , min ( i + 1 , N ) ) : NEW_LINE INDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( result < dp [ N - 1 ] [ i ] ) : NEW_LINE INDENT result = dp [ N - 1 ] [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : return 0 NEW_LINE if ( K == 0 ) : return 1 NEW_LINE if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum = sum + int ( num [ i ] ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res = res + countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ position ] [ previous_sum ] != - 1 ) : NEW_LINE INDENT return dp [ position ] [ previous_sum ] NEW_LINE DEDENT dp [ position ] [ previous_sum ] = 0 NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum += ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res += countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT dp [ position ] [ previous_sum ] = res NEW_LINE return res NEW_LINE DEDENT
def minCost ( cost , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost = sys . maxsize NEW_LINE for j in range ( i ) : NEW_LINE INDENT if j < len ( cost ) and cost [ j ] != - 1 : NEW_LINE INDENT min_cost = min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT dp [ i ] = min_cost NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; NEW_LINE DEDENT DEDENT return dp [ W ] ; NEW_LINE DEDENT
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT
def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) NEW_LINE DEDENT
def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def minTime ( arr , n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT incl_new = arr [ i ] + min ( excl , incl ) NEW_LINE excl_new = incl NEW_LINE incl = incl_new NEW_LINE excl = excl_new NEW_LINE DEDENT return min ( incl , excl ) NEW_LINE DEDENT
def lcs ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] NEW_LINE bi = bool NEW_LINE for i in range ( m ) : NEW_LINE INDENT bi = i & 1 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ bi ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ bi ] [ n ] NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= 3 : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT elif i == 4 : NEW_LINE INDENT dp [ i ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def subsetXOR ( arr , n , k ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max_ele : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( int ) ( math . log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE if ( k > m ) : NEW_LINE return 0 NEW_LINE dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def permutationCoeff ( n , k ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT return int ( fact [ n ] / fact [ n - k ] ) NEW_LINE DEDENT
def countDer ( n ) : NEW_LINE INDENT if ( n == 1 ) : return 0 NEW_LINE if ( n == 2 ) : return 1 NEW_LINE return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) NEW_LINE DEDENT
def countDer ( n ) : NEW_LINE INDENT der = [ 0 for i in range ( n + 1 ) ] NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT
def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT
def countP ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ k ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( j == 1 or i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def bellNumber ( n ) : NEW_LINE INDENT bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE bell [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return bell [ n ] [ 0 ] NEW_LINE DEDENT for n in range ( 6 ) : NEW_LINE INDENT print ( ' Bell ▁ Number ' , n , ' is ' , bellNumber ( n ) ) NEW_LINE DEDENT
def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countSol ( coeff , n , rhs ) : NEW_LINE INDENT dp = [ 0 for i in range ( rhs + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( coeff [ i ] , rhs + 1 ) : NEW_LINE INDENT dp [ j ] += dp [ j - coeff [ i ] ] NEW_LINE DEDENT DEDENT return dp [ rhs ] NEW_LINE DEDENT
def printCountRec ( dist ) : NEW_LINE INDENT if dist < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dist == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ) NEW_LINE DEDENT
def printCountDP ( dist ) : NEW_LINE INDENT count = [ 0 ] * ( dist + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if dist >= 1 : NEW_LINE INDENT count [ 1 ] = 1 NEW_LINE DEDENT if dist >= 2 : NEW_LINE INDENT count [ 2 ] = 2 NEW_LINE DEDENT for i in range ( 3 , dist + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) NEW_LINE DEDENT return count [ dist ] ; NEW_LINE DEDENT
def prCountDP ( dist ) : NEW_LINE INDENT ways = [ 0 ] * 3 NEW_LINE n = dist NEW_LINE ways [ 0 ] = 1 NEW_LINE ways [ 1 ] = 1 NEW_LINE ways [ 2 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] NEW_LINE DEDENT return ways [ n % 3 ] NEW_LINE DEDENT
def countSeq ( n ) : NEW_LINE INDENT nCr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT nCr = ( nCr * ( n + 1 - r ) ) / r ; NEW_LINE res += nCr * nCr ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT
def steps ( source , step , dest ) : NEW_LINE INDENT if ( abs ( source ) > ( dest ) ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( source == dest ) : NEW_LINE INDENT return step NEW_LINE DEDENT pos = steps ( source + step + 1 , step + 1 , dest ) NEW_LINE neg = steps ( source - step - 1 , step + 1 , dest ) NEW_LINE return min ( pos , neg ) NEW_LINE DEDENT
def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( mt . log10 ( n ) ) NEW_LINE a = [ 1 for i in range ( d + 1 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT a [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + mt . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = mt . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n // p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for x in range ( n ) ] for y in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path *= i ; NEW_LINE path //= ( i - n + 1 ) ; NEW_LINE DEDENT return path ; NEW_LINE DEDENT
def Solve ( self , A ) : NEW_LINE INDENT ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT llap = [ 2 ] * n NEW_LINE A . sort ( ) NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k < n ) : NEW_LINE INDENT if A [ i ] + A [ k ] == 2 * A [ j ] : NEW_LINE INDENT llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT elif A [ i ] + A [ k ] < 2 * A [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
def optimalStrategyOfGame ( arr , n ) : NEW_LINE INDENT table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for gap in range ( n ) : NEW_LINE INDENT for j in range ( gap , n ) : NEW_LINE INDENT i = j - gap NEW_LINE x = 0 NEW_LINE if ( ( i + 2 ) <= j ) : NEW_LINE INDENT x = table [ i + 2 ] [ j ] NEW_LINE DEDENT y = 0 NEW_LINE if ( ( i + 1 ) <= ( j - 1 ) ) : NEW_LINE INDENT y = table [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT z = 0 NEW_LINE if ( i <= ( j - 2 ) ) : NEW_LINE INDENT z = table [ i ] [ j - 2 ] NEW_LINE DEDENT table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) NEW_LINE DEDENT DEDENT return table [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def findWays ( m , n , x ) : NEW_LINE INDENT table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ] NEW_LINE for j in range ( 1 , min ( m + 1 , x + 1 ) ) : NEW_LINE INDENT table [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT for k in range ( 1 , min ( m + 1 , j ) ) : NEW_LINE INDENT table [ i ] [ j ] += table [ i - 1 ] [ j - k ] NEW_LINE DEDENT DEDENT DEDENT return table [ - 1 ] [ - 1 ] NEW_LINE DEDENT
def findWays ( f , d , s ) : NEW_LINE INDENT mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] NEW_LINE mem [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( 1 , s + 1 ) : NEW_LINE INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] NEW_LINE if j - f - 1 >= 0 : NEW_LINE INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mem [ d ] [ s ] NEW_LINE DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def LCSubStr ( s , t , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( 2 ) ] NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == t [ j - 1 ] ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 NEW_LINE if ( dp [ i % 2 ] [ j ] > res ) : NEW_LINE INDENT res = dp [ i % 2 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def findMinInsertions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return 0 if ( str [ l ] == str [ h ] ) else 1 NEW_LINE DEDENT if ( str [ l ] == str [ h ] ) : NEW_LINE INDENT return findMinInsertions ( str , l + 1 , h - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) NEW_LINE DEDENT DEDENT
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( " Found ▁ a ▁ subset ▁ with ▁ given ▁ sum " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ subset ▁ with ▁ given ▁ sum " ) NEW_LINE DEDENT
def findPartition ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i , j = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if sum % 2 != 0 : NEW_LINE INDENT return false NEW_LINE DEDENT part = [ [ True for i in range ( n + 1 ) ] for j in range ( sum // 2 + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT part [ 0 ] [ i ] = True NEW_LINE DEDENT for i in range ( 1 , sum // 2 + 1 ) : NEW_LINE INDENT part [ i ] [ 0 ] = False NEW_LINE DEDENT for i in range ( 1 , sum // 2 + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT part [ i ] [ j ] = part [ i ] [ j - 1 ] NEW_LINE if i >= arr [ j - 1 ] : NEW_LINE INDENT part [ i ] [ j ] = ( part [ i ] [ j ] or part [ i - arr [ j - 1 ] ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return part [ sum // 2 ] [ n ] NEW_LINE DEDENT arr = [ 3 , 1 , 1 , 2 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if findPartition ( arr , n ) == True : NEW_LINE INDENT print ( " Can ▁ be ▁ divided ▁ into ▁ two " , " subsets ▁ of ▁ equal ▁ sum " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Can ▁ not ▁ be ▁ divided ▁ into ▁ " , " two ▁ subsets ▁ of ▁ equal ▁ sum " ) NEW_LINE DEDENT
def minCut ( a ) : NEW_LINE INDENT cut = [ 0 for i in range ( len ( a ) ) ] NEW_LINE palindrome = [ [ False for i in range ( len ( a ) ) ] for j in range ( len ( a ) ) ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT minCut = i ; NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT if ( a [ i ] == a [ j ] and ( i - j < 2 or palindrome [ j + 1 ] [ i - 1 ] ) ) : NEW_LINE INDENT palindrome [ j ] [ i ] = True ; NEW_LINE minCut = min ( minCut , 0 if j == 0 else ( cut [ j - 1 ] + 1 ) ) ; NEW_LINE DEDENT DEDENT cut [ i ] = minCut ; NEW_LINE DEDENT return cut [ len ( a ) - 1 ] ; NEW_LINE DEDENT
def lbs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT lds = [ 1 for i in range ( n + 1 ) ] NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT maximum = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
def maxSumIS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE msis = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < msis [ i ] : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < _min : NEW_LINE INDENT _min = count NEW_LINE DEDENT DEDENT return _min NEW_LINE DEDENT
def count ( S , m , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE DEDENT
def checkArray ( arr , N , k ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT Sum = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT R = ( k * k + k + 1 ) NEW_LINE if ( Sum % R != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT Mid = k * ( Sum // R ) NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT temp += arr [ i - 1 ] NEW_LINE if ( arr [ i ] == Mid ) : NEW_LINE INDENT if ( temp == Mid // k ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT
def minumumOperation ( N , arr ) : NEW_LINE INDENT sum_arr = sum ( arr ) NEW_LINE if sum_arr >= N : NEW_LINE INDENT print ( sum_arr - N ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT
def GenerateArray ( N , X ) : NEW_LINE INDENT prev_xor = X NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT print ( i ^ prev_xor , end = " " ) NEW_LINE if ( i != N ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT prev_xor = i NEW_LINE DEDENT DEDENT
def oddLengthPalindrome ( K ) : NEW_LINE INDENT palin = K NEW_LINE K = K // 10 NEW_LINE while ( K > 0 ) : NEW_LINE INDENT rev = K % 10 NEW_LINE palin = palin * 10 + rev NEW_LINE K = K // 10 NEW_LINE DEDENT return palin NEW_LINE DEDENT
def maxSubsequenceLen ( S , K ) : NEW_LINE INDENT N = len ( S ) NEW_LINE start , end = 0 , 0 NEW_LINE S = sorted ( S ) NEW_LINE ans , sum = - 10 ** 9 , 0 NEW_LINE for end in range ( N ) : NEW_LINE INDENT sum = sum + ( ord ( S [ end ] ) - ord ( ' a ' ) ) NEW_LINE while ( sum + K < ( ord ( S [ end ] ) - ord ( ' a ' ) ) * ( end - start + 1 ) ) : NEW_LINE INDENT sum = sum - ( ord ( S [ start ] ) - ord ( ' a ' ) ) NEW_LINE start += 1 NEW_LINE DEDENT ans = max ( ans , end - start + 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def findEquation ( A , B , C ) : NEW_LINE INDENT print ( " ( " + str ( C ) + " ) " + " x ^ 2 ▁ + ( " + str ( B ) + " ) x ▁ + ▁ ( " + str ( A ) + " ) ▁ = ▁ 0" ) NEW_LINE DEDENT
def findMinMoves ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % N != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT avg = sum // N NEW_LINE total = 0 NEW_LINE needCount = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT needCount += ( arr [ i ] - avg ) NEW_LINE total = max ( max ( abs ( needCount ) , arr [ i ] - avg ) , total ) NEW_LINE DEDENT return total NEW_LINE DEDENT
def totalCombination ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE K = R - L NEW_LINE if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = K - L NEW_LINE count = ( ( ans + 1 ) * ( ans + 2 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT
def checkPattern ( arr , m , k , n ) : NEW_LINE INDENT count = 1 NEW_LINE t = 0 NEW_LINE for i in range ( n - m ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + m ] ) : NEW_LINE INDENT t += 1 NEW_LINE if ( t == m ) : NEW_LINE INDENT t = 0 NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT t = 0 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT return " No " NEW_LINE DEDENT
def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT
def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT A = A ^ ( A & B ) NEW_LINE B = B ^ ( A & B ) NEW_LINE print ( A , B ) NEW_LINE DEDENT
def isValid ( s ) : NEW_LINE INDENT n = int ( math . sqrt ( len ( s ) ) ) NEW_LINE check = s [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = i NEW_LINE y = i NEW_LINE while ( x >= 0 and y < n ) : NEW_LINE INDENT if ( s [ n * x + y ] != check or s [ n * x + x ] != check ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT x -= 1 NEW_LINE y += 1 NEW_LINE DEDENT DEDENT print ( " Yes " ) NEW_LINE DEDENT
def sumOfSubarrayProd ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE res = 0 NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT incr = arr [ i ] * ( 1 + res ) NEW_LINE ans += incr NEW_LINE res = incr NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def OddLengthSum ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE l = len ( arr ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( i , l , 2 ) : NEW_LINE INDENT for k in range ( i , j + 1 , 1 ) : NEW_LINE INDENT sum += arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def OddLengthSum ( arr ) : NEW_LINE INDENT Sum = 0 NEW_LINE l = len ( arr ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT Sum += ( ( ( ( i + 1 ) * ( l - i ) + 1 ) // 2 ) * arr [ i ] ) NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def sameEulerTotient ( N ) : NEW_LINE INDENT return ( N & 1 ) ; NEW_LINE DEDENT
def evenSubMatrix ( N ) : NEW_LINE INDENT even = 1 NEW_LINE odd = 2 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( ( i + j ) % 2 == 0 ) : NEW_LINE INDENT print ( even , end = " ▁ " ) NEW_LINE even += 2 NEW_LINE DEDENT else : NEW_LINE INDENT print ( odd , end = " ▁ " ) NEW_LINE odd += 2 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def removeLeadingZeros ( str ) : NEW_LINE INDENT regex = " ^ 0 + ( ? ! $ ) " NEW_LINE str = re . sub ( regex , " " , str ) NEW_LINE print ( str ) NEW_LINE DEDENT
def TotalHammingDistance ( n ) : NEW_LINE INDENT i = 1 NEW_LINE sum = 0 NEW_LINE while ( n // i > 0 ) : NEW_LINE INDENT sum = sum + n // i NEW_LINE i = i * 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maximum_inversion ( n , k ) : NEW_LINE INDENT answer = 0 ; NEW_LINE k = min ( k , n // 2 ) ; NEW_LINE left = 1 ; NEW_LINE right = n ; NEW_LINE while ( k > 0 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE answer += 2 * ( right - left ) - 1 ; NEW_LINE left += 1 ; NEW_LINE right -= 1 ; NEW_LINE DEDENT print ( answer ) ; NEW_LINE DEDENT
def possibleToReach ( x , y , z ) : NEW_LINE INDENT if ( z < abs ( x ) + abs ( y ) or ( z - abs ( x ) - abs ( y ) ) % 2 ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Possible " ) NEW_LINE DEDENT DEDENT
def nCycle ( N ) : NEW_LINE INDENT return ( N ) * ( N - 1 ) + 1 NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT s = 0 ; NEW_LINE l = 1 ; NEW_LINE while ( l < n + 1 ) : NEW_LINE INDENT r = ( int ) ( n / math . floor ( n / l ) ) ; NEW_LINE x = ( ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ) ; NEW_LINE y = ( ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ) ; NEW_LINE p = ( int ) ( ( n / l ) % m ) ; NEW_LINE s = ( ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ) ; NEW_LINE s %= m ; NEW_LINE l = r + 1 ; NEW_LINE DEDENT print ( int ( ( s + m ) % m ) ) ; NEW_LINE DEDENT
def smallestNum ( N ) : NEW_LINE INDENT x = pow ( 10.0 , ( N - 1 ) / 2.0 ) ; NEW_LINE return math . ceil ( x ) ; NEW_LINE DEDENT
def solve ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT print ( N // 2 , N ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( N - 1 ) // 2 , ( N - 1 ) ) NEW_LINE DEDENT DEDENT
def makeArray ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( ( i + 1 ) * n , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printOddFactorNumber ( n , m ) : NEW_LINE INDENT for i in range ( n , m + 1 ) : NEW_LINE INDENT if ( ( i > 0 ) and ( ( i & ( i - 1 ) ) != 0 ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def PrintSeries ( n ) : NEW_LINE INDENT k = 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( k * ( 2 * k - 1 ) , end = ' ▁ ' ) NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT
def min_time_to_cut ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( math . log2 ( N ) ) + 1 NEW_LINE DEDENT
def HogbenNumber ( a ) : NEW_LINE INDENT p = ( pow ( a , 2 ) - a + 1 ) NEW_LINE return p NEW_LINE DEDENT
def countKCountdown ( arr , N , K ) : NEW_LINE INDENT flag = - 1 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT flag = K ; NEW_LINE DEDENT if ( arr [ i ] == flag ) : NEW_LINE INDENT flag -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT flag = - 1 ; NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def findDistinctSums ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT s . add ( i + j ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT
def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT
def check_string_exist ( S ) : NEW_LINE INDENT size = len ( S ) NEW_LINE check = True NEW_LINE for i in range ( size ) : NEW_LINE INDENT if S [ i ] != S [ ( i + 2 ) % size ] : NEW_LINE INDENT check = False NEW_LINE break NEW_LINE DEDENT DEDENT if check : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def fib ( n ) : NEW_LINE INDENT f0 = 0 NEW_LINE f1 = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = n % 60 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 2 , rem + 3 ) : NEW_LINE INDENT f = ( f0 + f1 ) % 60 NEW_LINE f0 = f1 NEW_LINE f1 = f NEW_LINE DEDENT s = f1 - 1 NEW_LINE return ( s ) NEW_LINE DEDENT DEDENT
def printSinX ( N ) : NEW_LINE INDENT Xi = 0 ; NEW_LINE num = 1 ; NEW_LINE while ( N > 0 ) : NEW_LINE INDENT print ( " X " , num , " = " , Xi , end = " ▁ " ) ; NEW_LINE print ( " sin ( X " , num , " ) ▁ = " , end = " ▁ " ) ; NEW_LINE print ( " { : . 6f } " . format ( math . sin ( Xi ) ) ,   " " ) ; NEW_LINE num += 1 ; NEW_LINE Xi += 710 ; NEW_LINE N = N - 1 ; NEW_LINE DEDENT DEDENT
def nthTerm ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) NEW_LINE DEDENT
def distinctSubstring ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - 97 NEW_LINE sum += ord ( Q [ pos ] ) - 48 NEW_LINE s += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT
def distinctSubstring ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE s = ' ' NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - 97 NEW_LINE sum = sum + ord ( Q [ pos ] ) - 48 NEW_LINE s += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT
def isKAlternating ( s , k ) : NEW_LINE INDENT if ( len ( s ) < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT bitAtIndex = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT for i in range ( k , len ( s ) ) : NEW_LINE INDENT if ( s [ i - k ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; NEW_LINE if ( N % 2 == 1 ) : NEW_LINE INDENT nth = ( N * N ) + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( N * N ) - 1 ; NEW_LINE DEDENT return nth ; NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 12 ; NEW_LINE nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) + 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; NEW_LINE return nth ; NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 4 ; NEW_LINE pi = 1 ; po = 1 ; NEW_LINE n = N ; NEW_LINE while ( n > 1 ) : NEW_LINE INDENT pi *= n - 1 ; NEW_LINE n -= 1 ; NEW_LINE po *= 2 ; NEW_LINE DEDENT nth = ( first_term * pi ) // po ; NEW_LINE return nth ; NEW_LINE DEDENT
def findSum ( arr , n , k ) : NEW_LINE INDENT if ( k <= n - 2 ) : NEW_LINE INDENT return ( arr [ n - 1 ] - arr [ 0 ] ) ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT
def squareDigitSum ( num ) : NEW_LINE INDENT lengthN = len ( num ) NEW_LINE result = ( lengthN // 9 ) * 81 + ( lengthN % 9 ) ** 2 NEW_LINE return result NEW_LINE DEDENT
def getElement ( N , r , c ) : NEW_LINE INDENT if ( r > c ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( r == 1 ) : NEW_LINE INDENT return c ; NEW_LINE DEDENT a = ( r + 1 ) * pow ( 2 , r - 2 ) ; NEW_LINE d = pow ( 2 , r - 1 ) ; NEW_LINE c = c - r ; NEW_LINE element = a + d * c ; NEW_LINE return element ; NEW_LINE DEDENT
def checkSequence ( a , b ) : NEW_LINE INDENT if len ( b ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( a ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( a [ 0 ] == b [ 0 ] ) : NEW_LINE INDENT return checkSequence ( a [ 1 : ] , b [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return checkSequence ( a [ 1 : ] , b ) NEW_LINE DEDENT DEDENT
def updateString ( S , A , B ) : NEW_LINE INDENT l = len ( A ) NEW_LINE i = 0 NEW_LINE while i + l <= len ( S ) : NEW_LINE INDENT curr = S [ i : i + l ] NEW_LINE if curr == A : NEW_LINE INDENT new_string = S [ 0 : i ] + B + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_string = S [ 0 : i ] + A + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return S NEW_LINE DEDENT
def findCount ( str1 , str2 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE ans = sys . maxsize NEW_LINE hash1 = [ 0 ] * 26 NEW_LINE hash2 = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT hash1 [ ord ( str1 [ i ] ) - 97 ] = hash1 [ ord ( str1 [ i ] ) - 97 ] + 1 NEW_LINE DEDENT for i in range ( 0 , len2 ) : NEW_LINE INDENT hash2 [ ord ( str2 [ i ] ) - 97 ] = hash2 [ ord ( str2 [ i ] ) - 97 ] + 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if ( hash2 [ i ] != 0 ) : NEW_LINE INDENT ans = min ( ans , hash1 [ i ] // hash2 [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getCount ( a , b ) : NEW_LINE INDENT if ( len ( b ) % len ( a ) != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT count = int ( len ( b ) / len ( a ) ) NEW_LINE a = a * count NEW_LINE if ( a == b ) : NEW_LINE INDENT return count NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT
def getSum ( n , d ) : NEW_LINE INDENT if ( n < d ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n % 10 != d ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT k = n // 10 NEW_LINE return ( ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 ) NEW_LINE DEDENT
def countDecreasing ( A , n ) : NEW_LINE INDENT len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) ; NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def doMatch ( A , B ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] != ' * ' and B [ i ] != ' * ' : NEW_LINE INDENT if A [ i ] != B [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def minimumChar ( S1 , S2 ) : NEW_LINE INDENT n , m = len ( S1 ) , len ( S2 ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( m - n + 1 ) : NEW_LINE INDENT minRemovedChar = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( S1 [ j ] != S2 [ i + j ] ) : NEW_LINE INDENT minRemovedChar += 1 NEW_LINE DEDENT DEDENT ans = min ( minRemovedChar , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isSubstring ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( s2 [ i + j ] != s1 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j + 1 == M : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def patternCount ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 ; counter = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( str [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE if ( str [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def translate ( st ) : NEW_LINE INDENT for i in range ( 1 , len ( st ) ) : NEW_LINE INDENT if ( st [ i - 1 ] == ' A ' and st [ i ] == ' B ' ) : NEW_LINE INDENT st [ i - 1 ] = ' C ' NEW_LINE for j in range ( i , len ( st ) - 1 ) : NEW_LINE INDENT st [ j ] = st [ j + 1 ] NEW_LINE DEDENT st [ len ( st ) - 1 ] = ' ▁ ' NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while i <= N - M : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE print " Pattern ▁ found ▁ at ▁ index ▁ " + str ( i ) NEW_LINE i = i + M NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT
def generateNumber ( number ) : NEW_LINE INDENT temp = 0 ; adding_number = 0 ; NEW_LINE result = " " ; NEW_LINE l = len ( number ) ; NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT digit = ord ( number [ i ] ) - ord ( '0' ) ; NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT adding_number += 1 ; NEW_LINE digit += adding_number ; NEW_LINE if ( digit >= 10 ) : NEW_LINE INDENT digit %= 9 ; NEW_LINE if ( digit == 0 ) : NEW_LINE INDENT digit = 9 ; NEW_LINE DEDENT DEDENT DEDENT result = str ( digit ) + result ; NEW_LINE temp += 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
def findString ( arr , N ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += '1' if arr [ i ] [ i ] == '0' else '0' NEW_LINE DEDENT return ans NEW_LINE DEDENT
def commonSubstring ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE ans = " " NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( ans ) == 0 ) : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " True " ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT
def maxlength ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = 1 NEW_LINE j = i + 1 NEW_LINE while ( j <= n - 1 and s [ j ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maximumK ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE ans = N NEW_LINE flag = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( S [ i ] != S [ i + 1 ] ) : NEW_LINE INDENT flag = 1 NEW_LINE ans = min ( ans , max ( i + 1 , N - i - 1 ) ) NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def generateLetters ( S , P , M ) : NEW_LINE INDENT if ( P == len ( S ) ) : NEW_LINE INDENT print ( S ) ; NEW_LINE return NEW_LINE DEDENT generateLetters ( S , P + 1 , M ) ; NEW_LINE S = S . replace ( S [ P ] , M [ S [ P ] ] ) NEW_LINE generateLetters ( S , P + 1 , M ) ; NEW_LINE DEDENT
def FindKthChar ( Str , K , X ) : NEW_LINE INDENT ans = ' ▁ ' NEW_LINE Sum = 0 NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT digit = ord ( Str [ i ] ) - 48 NEW_LINE Range = int ( math . pow ( digit , X ) ) NEW_LINE Sum += Range NEW_LINE if ( K <= Sum ) : NEW_LINE INDENT ans = Str [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumHammingDistance ( S , K ) : NEW_LINE INDENT n = len ( S ) NEW_LINE pref = [ 0 ] * n NEW_LINE pref [ 0 ] = ord ( S [ 0 ] ) - ord ( '0' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + ( ord ( S [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT cnt = pref [ n - 1 ] NEW_LINE ans = cnt NEW_LINE for i in range ( n - K ) : NEW_LINE INDENT value = pref [ i + K - 1 ] - ( pref [ i - 1 ] if ( i - 1 ) >= 0 else 0 ) NEW_LINE ans = min ( ans , cnt - value + ( K - value ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isEqualSubstring ( string , x ) : NEW_LINE INDENT n = len ( string ) NEW_LINE i = 0 NEW_LINE while i < n and i < x : NEW_LINE INDENT if ( string [ i ] != string [ n - i - 1 ] ) : NEW_LINE INDENT print ( " false " ) NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( " true " ) NEW_LINE return NEW_LINE DEDENT
def minimumOperations ( S , N ) : NEW_LINE INDENT ans = 0 NEW_LINE cntOne = 0 NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT ans += cntOne NEW_LINE cntOne *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT cntOne += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def minOpsToEmptyString ( s ) : NEW_LINE INDENT ans = - 10 ** 9 NEW_LINE cn0 = 0 NEW_LINE cn1 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT if ( cn1 > 0 ) : NEW_LINE INDENT cn1 -= 1 NEW_LINE DEDENT cn0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( cn0 > 0 ) : NEW_LINE INDENT cn0 -= 1 NEW_LINE DEDENT cn1 += 1 NEW_LINE DEDENT ans = max ( [ ans , cn0 , cn1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def prefixDivisble ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % i != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 52248 NEW_LINE if ( prefixDivisble ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def zigzag ( s , rows ) : NEW_LINE INDENT interval = 2 * rows - 2 NEW_LINE for i in range ( rows ) : NEW_LINE INDENT step = interval - 2 * i NEW_LINE for j in range ( i , len ( s ) , interval ) : NEW_LINE INDENT print ( s [ j ] , end = " " ) NEW_LINE if ( step > 0 and step < interval and step + j < len ( s ) ) : NEW_LINE INDENT for k in range ( ( interval - rows - i ) ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT print ( s [ j + step ] , end = " " ) NEW_LINE for k in range ( i - 1 ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for k in range ( interval - rows ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def findMinimumCost ( s , N ) : NEW_LINE INDENT count_1 , count_0 = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT DEDENT k = abs ( count_0 - count_1 ) NEW_LINE if ( count_1 == N or count_0 == N ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k // 2 ) NEW_LINE DEDENT DEDENT
def countOccurrences ( S , X , Y ) : NEW_LINE INDENT count = 0 NEW_LINE N = len ( S ) NEW_LINE A = len ( X ) NEW_LINE B = len ( Y ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i : i + B ] == Y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( S [ i : i + A ] == X ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def canMakeEqual ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE weightOfString = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT weightOfString += ord ( S [ i ] ) - ord ( ' a ' ) + 1 NEW_LINE DEDENT if ( weightOfString % N == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def minLength ( S ) : NEW_LINE INDENT st = [ ] NEW_LINE for ch in S : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( ch ) NEW_LINE DEDENT else : NEW_LINE INDENT top = st [ - 1 ] NEW_LINE if ( abs ( ord ( ch ) - ord ( top ) ) == 1 ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( ch ) NEW_LINE DEDENT DEDENT DEDENT return len ( st ) NEW_LINE DEDENT
def findMinimumTime ( tasks , K ) : NEW_LINE INDENT map = { } NEW_LINE curr_time = 0 NEW_LINE for c in tasks : NEW_LINE INDENT if ( c in map ) : NEW_LINE INDENT if ( curr_time - map <= K ) : NEW_LINE INDENT curr_time += K - ( curr_time - map ) + 1 NEW_LINE DEDENT DEDENT map = curr_time NEW_LINE curr_time += 1 NEW_LINE DEDENT print ( curr_time ) NEW_LINE DEDENT
def getString ( N ) : NEW_LINE INDENT ans = " " NEW_LINE while ( N >= 26 ) : NEW_LINE INDENT ans += ' z ' NEW_LINE N -= 26 NEW_LINE DEDENT ans += chr ( N + ord ( ' a ' ) - 1 ) NEW_LINE return ans NEW_LINE DEDENT
def subString ( s , n ) : NEW_LINE INDENT hash = { 0 : 1 } NEW_LINE pre = 0 NEW_LINE count = 0 NEW_LINE for i in s : NEW_LINE INDENT pre ^= ( 1 << ord ( i ) - 97 ) NEW_LINE count += hash . get ( pre , 0 ) NEW_LINE hash [ pre ] = hash . get ( pre , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countSamePrefixSuffix ( s , n ) : NEW_LINE INDENT prefix = " " NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT prefix += s [ i ] NEW_LINE suffix = s [ n - 1 - i : 2 * n - 2 - i ] NEW_LINE if ( prefix == suffix ) : NEW_LINE INDENT print ( len ( prefix ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def atleastkDistinctChars ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = defaultdict ( int ) NEW_LINE begin = 0 NEW_LINE end = 0 NEW_LINE ans = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT c = s [ end ] NEW_LINE mp += 1 NEW_LINE end += 1 NEW_LINE while ( len ( mp ) >= k ) : NEW_LINE INDENT pre = s [ begin ] NEW_LINE mp [ pre ] -= 1 NEW_LINE if ( mp [ pre ] == 0 ) : NEW_LINE INDENT del mp [ pre ] NEW_LINE DEDENT ans += len ( s ) - end + 1 NEW_LINE begin += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def canSplit ( S ) : NEW_LINE INDENT frequency = [ 0 ] * 26 NEW_LINE cnt_singles = 0 NEW_LINE k = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT frequency [ ord ( S [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT odd = 0 NEW_LINE eve = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( frequency [ i ] ) : NEW_LINE INDENT odd += ( frequency [ i ] & 1 ) NEW_LINE eve += frequency [ i ] // 2 NEW_LINE DEDENT DEDENT if ( eve >= odd ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def addASCII ( S , N ) : NEW_LINE INDENT for i in range ( len ( S ) ) : NEW_LINE INDENT a = ord ( N [ i ] ) - ord ( '0' ) NEW_LINE b = ord ( S [ i ] ) + a NEW_LINE if ( b > 122 ) : NEW_LINE INDENT b -= 26 NEW_LINE DEDENT S = S . replace ( S [ i ] , chr ( b ) ) NEW_LINE DEDENT print ( S ) NEW_LINE DEDENT
def countOperations ( X , Y , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( X ) ) : NEW_LINE INDENT c = 0 NEW_LINE if ( X [ i ] == Y [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( X [ i ] < Y [ i ] ) : NEW_LINE INDENT if ( ( ord ( Y [ i ] ) - ord ( X [ i ] ) ) >= K ) : NEW_LINE INDENT c = ( ord ( Y [ i ] ) - ord ( X [ i ] ) ) // K NEW_LINE DEDENT c += ( ord ( Y [ i ] ) - ord ( X [ i ] ) ) % K NEW_LINE DEDENT else : NEW_LINE INDENT t = 90 - ord ( X [ i ] ) NEW_LINE t += ord ( Y [ i ] ) - 65 + 1 NEW_LINE if ( t >= K ) : NEW_LINE INDENT c = t // K NEW_LINE DEDENT c += ( t % K ) NEW_LINE DEDENT count += c NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def pendulumArrangement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE op = [ 0 ] * n NEW_LINE mid = int ( ( n - 1 ) / 2 ) NEW_LINE j = 1 NEW_LINE i = 1 NEW_LINE op [ mid ] = arr [ 0 ] NEW_LINE for i in range ( 1 , mid + 1 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE op [ mid - i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( int ( n % 2 ) == 0 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE DEDENT print ( " Pendulum ▁ arrangement : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( op [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countTotalFrequencies ( S1 , S2 ) : NEW_LINE INDENT bset = set ( S1 ) NEW_LINE count = 0 NEW_LINE for x in S2 : NEW_LINE INDENT if x in bset : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def scoreOfParentheses ( s ) : NEW_LINE INDENT stack = [ ] NEW_LINE stack . append ( 0 ) NEW_LINE for c in s : NEW_LINE INDENT if ( c == ' ( ' ) : NEW_LINE INDENT stack . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = stack [ len ( stack ) - 1 ] NEW_LINE stack = stack [ : - 1 ] NEW_LINE val = 0 NEW_LINE if ( tmp > 0 ) : NEW_LINE INDENT val = tmp * 2 NEW_LINE DEDENT else : NEW_LINE INDENT val = 1 NEW_LINE DEDENT stack [ len ( stack ) - 1 ] += val NEW_LINE DEDENT DEDENT print ( stack [ len ( stack ) - 1 ] ) NEW_LINE DEDENT
def make_palindrome ( S1 , S2 , S3 ) : NEW_LINE INDENT maskA , maskC = 0 , 0 NEW_LINE for i in S1 : NEW_LINE INDENT maskA |= ( 1 << ( ord ( i ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT for i in S3 : NEW_LINE INDENT maskC |= ( 1 << ( ord ( i ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT if ( ( maskA & maskC ) > 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT
def maximum_pallindromic ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT res += arr [ i ] // 3 NEW_LINE arr [ i ] = arr [ i ] % 3 NEW_LINE if ( arr [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT elif ( arr [ i ] == 2 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT res += min ( c1 , c2 ) NEW_LINE t = min ( c1 , c2 ) NEW_LINE c1 -= t NEW_LINE c2 -= t NEW_LINE res += 2 * ( c2 // 3 ) NEW_LINE c2 %= 3 NEW_LINE res += c2 // 2 NEW_LINE print ( res ) NEW_LINE DEDENT
def minLength ( Str , N , K , M ) : NEW_LINE INDENT stackOfChar = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT stackOfChar . append ( Str [ i ] ) NEW_LINE if ( len ( stackOfChar ) >= M ) : NEW_LINE INDENT l = " " NEW_LINE for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K [ j ] != stackOfChar [ - 1 ] ) : NEW_LINE INDENT f = 0 NEW_LINE while ( f != len ( l ) ) : NEW_LINE INDENT stackOfChar . append ( l [ f ] ) NEW_LINE f += 1 NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT l = stackOfChar [ - 1 ] + l NEW_LINE stackOfChar . pop ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( stackOfChar ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT N = 3 NEW_LINE if ( ( N == 1 ) or ( N == 2 ) ) : NEW_LINE INDENT print ( 62 ) NEW_LINE DEDENT else : NEW_LINE INDENT m = ( 10 ** 9 ) + 7 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT k = N // 2 NEW_LINE flag = True NEW_LINE DEDENT else : NEW_LINE INDENT k = ( N - 1 ) // 2 NEW_LINE flag = False NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT a = power ( 62 , k , m ) NEW_LINE print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT a = power ( 62 , ( k + 1 ) , m ) NEW_LINE print ( a ) NEW_LINE DEDENT DEDENT
def lenOfLongestReqSubstr ( s , N ) : NEW_LINE INDENT ind = { } NEW_LINE mask = 0 NEW_LINE ind [ 0 ] = - 1 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE mask ^= ( 1 << val ) NEW_LINE if ( mask in ind ) : NEW_LINE INDENT ans = max ( ans , i - ind [ mask ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ind [ mask ] = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findFreq ( strr , N ) : NEW_LINE INDENT freq = [ 0 ] * 256 NEW_LINE max = 0 NEW_LINE charMax = '0' NEW_LINE for i in range ( N ) : NEW_LINE INDENT ch = ord ( strr [ i ] ) NEW_LINE freq [ ch ] += 1 NEW_LINE if ( freq [ ch ] >= max ) : NEW_LINE INDENT max = freq [ ch ] NEW_LINE charMax = ch NEW_LINE DEDENT print ( chr ( charMax ) , " - > " , max ) NEW_LINE DEDENT DEDENT
def minCost ( s , n ) : NEW_LINE INDENT minValue = 100000000 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT cnt += min ( abs ( i - ( ord ( s [ j ] ) - ord ( ' a ' ) ) ) , 26 - abs ( i - ( ord ( s [ j ] ) - ord ( ' a ' ) ) ) ) NEW_LINE DEDENT minValue = min ( minValue , cnt ) NEW_LINE DEDENT return minValue NEW_LINE DEDENT
def countSubString ( s ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT x = 0 ; NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT temp = 1 << ord ( s [ j ] ) - ord ( ' a ' ) ; NEW_LINE x ^= temp ; NEW_LINE if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT res += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( res ) ; NEW_LINE DEDENT
def countSubstring ( s ) : NEW_LINE INDENT answer = 0 NEW_LINE m = defaultdict ( lambda : 0 ) NEW_LINE m [ 0 ] = 1 NEW_LINE x = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT x ^= 1 << ( ord ( s [ j ] ) - ord ( ' a ' ) ) NEW_LINE answer += m [ x ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT answer += m [ x ^ ( 1 << i ) ] NEW_LINE DEDENT m [ x ] += 1 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT
def min_cost ( S ) : NEW_LINE INDENT cost = 0 NEW_LINE F = 0 NEW_LINE B = 0 NEW_LINE n = len ( S ) - S . count ( ' ▁ ' ) NEW_LINE if n == 1 : NEW_LINE INDENT return cost NEW_LINE DEDENT for char in S : NEW_LINE INDENT if char != ' ▁ ' : NEW_LINE INDENT if B != 0 : NEW_LINE INDENT cost += min ( n - F , F ) * B NEW_LINE B = 0 NEW_LINE DEDENT F += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT
def countOfSubstringWithOnlyOnes ( s ) : NEW_LINE INDENT count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 ; NEW_LINE DEDENT res = res + count NEW_LINE DEDENT return res NEW_LINE DEDENT
def charactersCount ( str , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT cur = str [ 0 ] ; NEW_LINE ind = 0 ; NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( str [ j ] < cur ) : NEW_LINE INDENT cur = str [ j ] ; NEW_LINE ind = j ; NEW_LINE DEDENT DEDENT str = str [ 0 : ind ] + str [ ind + 1 : ] ; NEW_LINE n -= 1 ; NEW_LINE count += ind + 1 ; NEW_LINE DEDENT print ( count ) ; NEW_LINE DEDENT
def printMiddleCharacter ( str ) : NEW_LINE INDENT length = len ( str ) ; NEW_LINE middle = length // 2 ; NEW_LINE print ( str [ middle ] ) ; NEW_LINE DEDENT
def is_rtol ( s ) : NEW_LINE INDENT tmp = floor ( sqrt ( len ( s ) ) ) - 1 NEW_LINE first = s [ tmp ] NEW_LINE for pos in range ( tmp , len ( s ) - 1 , tmp ) : NEW_LINE INDENT if ( s [ pos ] != first ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def count_minimum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = i NEW_LINE while j < n and ( s [ j ] == s [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT diff = j - i NEW_LINE ans += diff // 2 NEW_LINE i = j NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def polynomialRollingHash ( str ) : NEW_LINE INDENT p = 31 NEW_LINE m = 1e9 + 9 NEW_LINE power_of_p = 1 NEW_LINE hash_val = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT hash_val = ( ( hash_val + ( ord ( str [ i ] ) - ord ( ' a ' ) + 1 ) * power_of_p ) % m ) NEW_LINE power_of_p = ( power_of_p * p ) % m NEW_LINE DEDENT return int ( hash_val ) NEW_LINE DEDENT
def count_Strings ( n ) : NEW_LINE INDENT x = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x = ( 1 << x ) ; NEW_LINE DEDENT return x - 1 ; NEW_LINE DEDENT
def decrypt ( Str , Start , End ) : NEW_LINE INDENT if ( Start > End ) : NEW_LINE INDENT return ; NEW_LINE DEDENT mid = ( Start + End ) >> 1 ; NEW_LINE print ( Str [ mid ] , end = " " ) ; NEW_LINE decrypt ( Str , mid + 1 , End ) ; NEW_LINE decrypt ( Str , Start , mid - 1 ) ; NEW_LINE DEDENT
def decode_String ( st , K ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( 0 , len ( st ) , K ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT for i in range ( len ( st ) - ( K - 1 ) , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def BalancedNumber ( s ) : NEW_LINE INDENT Leftsum = 0 NEW_LINE Rightsum = 0 NEW_LINE for i in range ( 0 , int ( len ( s ) / 2 ) ) : NEW_LINE INDENT Leftsum = Leftsum + int ( s [ i ] ) NEW_LINE Rightsum = ( Rightsum + int ( s [ len ( s ) - 1 - i ] ) ) NEW_LINE DEDENT if ( Leftsum == Rightsum ) : NEW_LINE INDENT print ( " Balanced " , end =   ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Balanced " , end =   ' ' ) NEW_LINE DEDENT DEDENT
def minFlips ( target ) : NEW_LINE INDENT curr = '1' NEW_LINE count = 0 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if ( target [ i ] == curr ) : NEW_LINE INDENT count += 1 NEW_LINE curr = chr ( 48 + ( ord ( curr ) + 1 ) % 2 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def minDel ( s1 , s2 ) : NEW_LINE INDENT i = len ( s1 ) NEW_LINE j = len ( s2 ) NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return i + j NEW_LINE DEDENT
def checkWord ( board , word , index , row , col ) : NEW_LINE INDENT if ( row < 0 or col < 0 or row >= len ( board ) or col >= len ( board [ 0 ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( board [ row ] [ col ] != word [ index ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( index == len ( word ) - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = board [ row ] [ col ] NEW_LINE board [ row ] [ col ] = ' * ' NEW_LINE if ( checkWord ( board , word , index + 1 , row + 1 , col ) or checkWord ( board , word , index + 1 , row - 1 , col ) or checkWord ( board , word , index + 1 , row , col + 1 ) or checkWord ( board , word , index + 1 , row , col - 1 ) ) : NEW_LINE INDENT board [ row ] [ col ] = temp NEW_LINE return True NEW_LINE DEDENT board [ row ] [ col ] = temp NEW_LINE return False NEW_LINE DEDENT
def count ( N , X , subStr , index , n ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = subStr + N [ index ] NEW_LINE b = 0 NEW_LINE if ( int ( a ) % X == 0 ) : NEW_LINE INDENT b = 1 NEW_LINE DEDENT m1 = count ( N , X , a , index + 1 , n ) NEW_LINE m2 = b + count ( N , X , " " , index + 1 , n ) NEW_LINE return max ( m1 , m2 ) NEW_LINE DEDENT
def checkSuffix ( A , B ) : NEW_LINE INDENT s1 = str ( A ) NEW_LINE s2 = str ( B ) NEW_LINE result = s1 . endswith ( s2 ) NEW_LINE if ( result ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def checkSuffix ( A , B ) : NEW_LINE INDENT digit_B = int ( math . log10 ( B ) ) + 1 ; NEW_LINE A -= B ; NEW_LINE return ( A % int ( math . pow ( 10 , digit_B ) ) ) ; NEW_LINE DEDENT A = 12345 ; B = 45 ; NEW_LINE result = checkSuffix ( A , B ) ; NEW_LINE if ( result == 0 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def count_min_length ( s ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE ans = sys . maxsize ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT hash [ i ] = - 1 ; NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == i - 1 or hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == i - 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT ans = min ( ans , i - hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] - 1 ) ; NEW_LINE hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i ; NEW_LINE DEDENT DEDENT if ( ans == INT_MAX ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def countStrings ( s ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( 1 , len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def RemoveHTMLTags ( strr ) : NEW_LINE INDENT print ( re . compile ( r ' < [ ^ > ] + > ' ) . sub ( ' ' , strr ) ) NEW_LINE DEDENT
def removeRepeating ( s1 , s2 ) : NEW_LINE INDENT s3 = s1 + " ▁ " + s2 + " ▁ " NEW_LINE words = " " NEW_LINE i = 0 NEW_LINE for x in s3 : NEW_LINE INDENT if ( x == ' ▁ ' ) : NEW_LINE INDENT if ( words not in s1 or words not in s2 ) : NEW_LINE INDENT print ( words , end = " " ) NEW_LINE DEDENT words = " ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT words = words + x NEW_LINE DEDENT DEDENT DEDENT
def findStr ( S ) : NEW_LINE INDENT S = list ( S ) NEW_LINE n = len ( S ) NEW_LINE for i in range ( 0 , n // 2 ) : NEW_LINE if S [ i ] != ' a ' : NEW_LINE INDENT S [ i ] = ' a ' NEW_LINE return ( ' ' . join ( S ) ) NEW_LINE DEDENT S [ n - 1 ] = ' b ' NEW_LINE if n < 2 : NEW_LINE INDENT return ' - 1' NEW_LINE DEDENT else : NEW_LINE INDENT return ( ' ' . join ( S ) ) NEW_LINE DEDENT DEDENT
def kth_string ( n , k ) : NEW_LINE INDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if k <= ( n - i - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j == i or j == n - k ) : NEW_LINE INDENT print ( ' Y ' , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' X ' , end = " " ) NEW_LINE DEDENT DEDENT break NEW_LINE DEDENT k -= ( n - i - 1 ) NEW_LINE DEDENT DEDENT
def decodeStr ( str , len ) : NEW_LINE INDENT c = [ " " for i in range ( len ) ] NEW_LINE pos = 1 NEW_LINE if ( len % 2 == 1 ) : NEW_LINE INDENT med = int ( len / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT med = int ( len / 2 - 1 ) NEW_LINE DEDENT c [ med ] = str [ 0 ] NEW_LINE if ( len % 2 == 0 ) : NEW_LINE INDENT c [ med + 1 ] = str [ 1 ] NEW_LINE DEDENT if ( len & 1 ) : NEW_LINE INDENT k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 2 NEW_LINE DEDENT for i in range ( k , len , 2 ) : NEW_LINE INDENT c [ med - pos ] = str [ i ] NEW_LINE if ( len % 2 == 1 ) : NEW_LINE INDENT c [ med + pos ] = str [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT c [ med + pos + 1 ] = str [ i + 1 ] NEW_LINE DEDENT pos += 1 NEW_LINE DEDENT print ( * c , sep = " " ) NEW_LINE DEDENT
def GeberateDefangIP ( str ) : NEW_LINE INDENT defangIP = " " ; NEW_LINE for c in str : NEW_LINE INDENT if ( c == ' . ' ) : NEW_LINE INDENT defangIP += " [ . ] " NEW_LINE DEDENT else : NEW_LINE INDENT defangIP += c ; NEW_LINE DEDENT DEDENT return defangIP ; NEW_LINE DEDENT
def flip ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT while ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] = '1' NEW_LINE i += 1 NEW_LINE DEDENT s = ' ' . join ( map ( str , s ) ) NEW_LINE return s NEW_LINE DEDENT DEDENT DEDENT
def distinct ( S , M ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT c = len ( set ( [ d for d in S [ i ] ] ) ) NEW_LINE if ( c <= M ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def moveAtEnd ( s , i , l ) : NEW_LINE INDENT if ( i >= l ) : NEW_LINE return NEW_LINE curr = s [ i ] NEW_LINE if ( curr != ' x ' ) : NEW_LINE INDENT print ( curr , end = " " ) NEW_LINE DEDENT moveAtEnd ( s , i + 1 , l ) NEW_LINE if ( curr == ' x ' ) : NEW_LINE INDENT print ( curr , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def String ( l , x , y ) : NEW_LINE INDENT p = 97 NEW_LINE for j in range ( l ) : NEW_LINE INDENT ans = chr ( p + j % y ) NEW_LINE print ( ans , end = " " ) NEW_LINE DEDENT DEDENT
def removeDuplicates ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j < n : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT res = res + str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def contain ( L , U , M ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( L , U + 1 ) : NEW_LINE INDENT num = set ( str ( j ) ) NEW_LINE if ( j % M == 0 and str ( M ) not in num ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def group_formed ( S ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT a = S [ i ] NEW_LINE b = S [ i + 1 ] NEW_LINE if ( a != b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def solve ( a , b ) : NEW_LINE INDENT l = len ( a ) NEW_LINE min = 0 NEW_LINE max = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( a [ i ] == ' + ' or b [ i ] == ' + ' or a [ i ] != b [ i ] ) : NEW_LINE INDENT max += 1 NEW_LINE DEDENT if ( a [ i ] != ' + ' and b [ i ] != ' + ' and a [ i ] != b [ i ] ) : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min + max ) NEW_LINE DEDENT
def xor ( a , b , n ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT else : NEW_LINE INDENT ans += "1" NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPerfectCubeString ( str1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT sum += ord ( str1 [ i ] ) NEW_LINE DEDENT cr = ceil ( ( sum ) ** ( 1 / 3 ) ) NEW_LINE return ( cr * cr * cr == sum ) NEW_LINE DEDENT str1 = " ll " NEW_LINE if ( isPerfectCubeString ( str1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def XorAscii ( str1 , len1 ) : NEW_LINE INDENT ans = ord ( str1 [ 0 ] ) NEW_LINE for i in range ( 1 , len1 ) : NEW_LINE INDENT ans = ( ans ^ ( ord ( str1 [ i ] ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSticks ( string ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT ch = string [ i ] ; NEW_LINE if ( ch >= ' A ' and ch <= ' Z ' ) : NEW_LINE INDENT cnt += sticks [ ord ( ch ) - ord ( ' A ' ) ] ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += number [ ord ( ch ) - ord ( '0' ) ] ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def productAtKthLevel ( tree , k , i , level ) : NEW_LINE INDENT if ( tree [ i [ 0 ] ] == ' ( ' ) : NEW_LINE INDENT i [ 0 ] += 1 NEW_LINE if ( tree [ i [ 0 ] ] == ' ) ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT product = 1 NEW_LINE if ( level == k ) : NEW_LINE INDENT product = int ( tree [ i [ 0 ] ] ) NEW_LINE DEDENT i [ 0 ] += 1 NEW_LINE leftproduct = productAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE i [ 0 ] += 1 NEW_LINE rightproduct = productAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE i [ 0 ] += 1 NEW_LINE return product * leftproduct * rightproduct NEW_LINE DEDENT DEDENT
def count ( str1 , str2 ) : NEW_LINE INDENT c = 0 ; j = 0 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] in str2 : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT print ( " No . ▁ of ▁ matching ▁ characters ▁ are : ▁ " , c ) ; NEW_LINE DEDENT
def smallest ( s ) : NEW_LINE INDENT a = list ( s ) NEW_LINE b = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( int ( a [ i ] ) % 2 != 0 ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT DEDENT b = sorted ( b ) NEW_LINE if ( len ( b ) > 1 ) : NEW_LINE INDENT return int ( b [ 0 ] ) * 10 + int ( b [ 1 ] ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findNthOccur ( string , ch , N ) : NEW_LINE INDENT occur = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ch ) : NEW_LINE INDENT occur += 1 ; NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
def converthenumber ( n ) : NEW_LINE INDENT s = str ( n ) ; NEW_LINE res = " " ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' or s [ i ] == '9' ) : NEW_LINE INDENT res += s [ i ] ; NEW_LINE DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( len ( res ) == 2 ) : NEW_LINE INDENT print ( res ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT
def isWordPresent ( sentence , word ) : NEW_LINE INDENT s = sentence . split ( " ▁ " ) NEW_LINE for i in s : NEW_LINE INDENT if ( i == word ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = " Geeks ▁ for ▁ Geeks " NEW_LINE word = " Geeks " NEW_LINE if ( isWordPresent ( s , word ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def canMake ( s ) : NEW_LINE INDENT o = 0 ; z = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) == 1 ) : NEW_LINE INDENT o += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT z += 1 ; NEW_LINE DEDENT DEDENT if ( o % 2 == 1 and z % 2 == 1 ) : NEW_LINE INDENT return " NO " ; NEW_LINE DEDENT else : NEW_LINE INDENT return " YES " ; NEW_LINE DEDENT DEDENT
def countChars ( string , n ) : NEW_LINE INDENT i = 0 ; cnt = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT i += 2 ; NEW_LINE DEDENT cnt += 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT
def findMinSwaps ( s , k ) : NEW_LINE INDENT ans = 0 ; NEW_LINE c_one = 0 ; c_zero = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT c_one += 1 ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c_zero += 1 ; NEW_LINE ans += c_one ; NEW_LINE DEDENT if ( c_zero == k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( c_zero < k ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE arr = [ ] NEW_LINE for y in newlist : NEW_LINE INDENT if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( arr ) ) NEW_LINE DEDENT DEDENT
def countSubStr ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += ( i + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findLength ( s , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE cnt_zero = 0 NEW_LINE cnt_one = 0 NEW_LINE while ( l < len ( s ) and r <= len ( s ) ) : NEW_LINE INDENT if ( cnt_zero >= k and cnt_one >= 1 ) : NEW_LINE INDENT ans = min ( ans , r - l ) NEW_LINE l += 1 NEW_LINE if ( s [ l - 1 ] == '0' ) : NEW_LINE INDENT cnt_zero -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( r == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( s [ r ] == '0' ) : NEW_LINE INDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 NEW_LINE DEDENT r += 1 NEW_LINE DEDENT DEDENT if ( ans == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largestSubStr ( s ) : NEW_LINE INDENT while ( len ( s ) and s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT s = s [ : len ( s ) - 1 ] ; NEW_LINE DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return " - 1" ; NEW_LINE DEDENT else : NEW_LINE INDENT return s ; NEW_LINE DEDENT DEDENT
def findPhoneNumber ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( sum < 10 ) : NEW_LINE INDENT print ( n , "0" , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT n = str ( n ) NEW_LINE sum = str ( sum ) NEW_LINE n += sum NEW_LINE print ( n ) NEW_LINE DEDENT DEDENT
def findMidAlphabet ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT mid = ( ord ( s1 [ i ] ) + ord ( s2 [ i ] ) ) // 2 NEW_LINE print ( chr ( mid ) , end = " " ) NEW_LINE DEDENT DEDENT
def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_zero = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( s [ i ] == '0' ) ; NEW_LINE DEDENT return int ( pow ( 2 , c_zero - 1 ) ) ; NEW_LINE DEDENT
def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans += ( s [ i ] == '0' ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def isPalindrome ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE low = 0 NEW_LINE high = len ( s ) - 1 NEW_LINE while ( low < high ) : NEW_LINE INDENT if ( s [ low ] != s [ high ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 123.321 NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def cntWays ( string , n ) : NEW_LINE INDENT x = n + 1 ; NEW_LINE ways = x * x * ( x * x - 1 ) // 12 ; NEW_LINE return ways ; NEW_LINE DEDENT
def Count ( s , pos ) : NEW_LINE INDENT c = s [ pos - 1 ] NEW_LINE counter = 0 NEW_LINE for i in range ( pos - 1 ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
def countSticks ( string , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += ( sticks [ ord ( string [ i ] ) - ord ( '0' ) ] ) ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT
def getCount ( str1 , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n - 2 ) : NEW_LINE INDENT if ( str1 [ i ] == str1 [ i + 1 ] and str1 [ i ] == str1 [ i + 2 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE i = i + 2 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def getChar ( strr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT summ += ( ord ( strr [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( summ % 26 == 0 ) : NEW_LINE INDENT return ord ( ' z ' ) NEW_LINE DEDENT else : NEW_LINE INDENT summ = summ % 26 NEW_LINE return chr ( ord ( ' a ' ) + summ - 1 ) NEW_LINE DEDENT DEDENT
def findNumbers ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 1 NEW_LINE result = 0 NEW_LINE left = 0 NEW_LINE right = 1 NEW_LINE while ( right < n ) : NEW_LINE INDENT if ( s [ left ] == s [ right ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += count * ( count + 1 ) // 2 NEW_LINE left = right NEW_LINE count = 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT result += count * ( count + 1 ) // 2 NEW_LINE print ( result ) NEW_LINE DEDENT
def canBeBalanced ( s , n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT k = " ( " k = k + s + " ) " NEW_LINE d = [ ] NEW_LINE count = 0 NEW_LINE for i in range ( len ( k ) ) : NEW_LINE INDENT if k [ i ] == " ( " : NEW_LINE INDENT d . append ( " ( " ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( d ) != 0 : NEW_LINE INDENT d . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if len ( d ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT S = " ) ( ( ) " NEW_LINE n = len ( S ) NEW_LINE if ( canBeBalanced ( S , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def maxLenSubStr ( s ) : NEW_LINE INDENT if ( len ( s ) < 3 ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT temp = 2 NEW_LINE ans = 2 NEW_LINE for i in range ( 2 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] or s [ i ] != s [ i - 2 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( temp , ans ) NEW_LINE temp = 2 NEW_LINE DEDENT DEDENT ans = max ( temp , ans ) NEW_LINE return ans NEW_LINE DEDENT
def find_winner ( string , n ) : NEW_LINE INDENT string1 = " " ; string2 = " " ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT string1 += string [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT string2 += string [ i ] ; NEW_LINE DEDENT DEDENT string1 = " " . join ( sorted ( string1 ) ) NEW_LINE string2 = " " . join ( sorted ( string2 ) ) NEW_LINE if ( string1 < string2 ) : NEW_LINE INDENT print ( " A " , end = " " ) ; NEW_LINE DEDENT elif ( string2 < string1 ) : NEW_LINE INDENT print ( " B " , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Tie " , end = " " ) ; NEW_LINE DEDENT DEDENT
def printChar ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def reverse ( string , length , l , r ) : NEW_LINE INDENT if ( l < 0 or r >= length or l > r ) : NEW_LINE INDENT return string ; NEW_LINE DEDENT string = list ( string ) NEW_LINE while ( l < r ) : NEW_LINE INDENT c = string [ l ] ; NEW_LINE string [ l ] = string [ r ] ; NEW_LINE string [ r ] = c ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT return " " . join ( string ) ; NEW_LINE DEDENT
def findPrefix ( str1 , str2 ) : NEW_LINE INDENT pos = False ; NEW_LINE while ( len ( str1 ) != 0 ) : NEW_LINE INDENT if operator . contains ( str2 , str1 ) != True : NEW_LINE INDENT str1 = str1 [ 0 : len ( str1 ) - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT pos = operator . contains ( str2 , str1 ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( pos == False ) : NEW_LINE INDENT return " - 1" ; NEW_LINE DEDENT return str1 ; NEW_LINE DEDENT
def encrypt ( input_arr ) : NEW_LINE INDENT evenPos = ' @ ' ; oddPos = ' ! ' ; NEW_LINE for i in range ( len ( input_arr ) ) : NEW_LINE INDENT ascii = ord ( input_arr [ i ] ) ; NEW_LINE repeat = ( ascii - 96 ) if ascii >= 97 else ( ascii - 64 ) ; NEW_LINE for j in range ( repeat ) : NEW_LINE DEDENT if ( i % 2 == 0 ) : NEW_LINE INDENT print ( oddPos , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( evenPos , end = " " ) ; NEW_LINE DEDENT DEDENT
def IsRedundantBraces ( A ) : NEW_LINE INDENT a , b = 0 , 0 ; NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == ' ( ' and A [ i + 2 ] == ' ) ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( A [ i ] == ' * ' or A [ i ] == ' + ' or A [ i ] == ' - ' or A [ i ] == ' / ' ) : NEW_LINE INDENT a += 1 ; NEW_LINE DEDENT if ( A [ i ] == ' ( ' ) : NEW_LINE INDENT b += 1 ; NEW_LINE DEDENT DEDENT if ( b > a ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) // 2 NEW_LINE DEDENT
def stringToInt ( str ) : NEW_LINE INDENT if ( len ( str ) == 1 ) : NEW_LINE INDENT return ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE DEDENT y = stringToInt ( str [ 1 : ] ) ; NEW_LINE x = ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE x = x * ( 10 ** ( len ( str ) - 1 ) ) + y ; NEW_LINE return int ( x ) ; NEW_LINE DEDENT
def Occurrence ( s , position ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( position - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ position - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def generateStr ( a , b , s , count , len ) : NEW_LINE INDENT if ( count == len ) : NEW_LINE INDENT print ( s ) ; NEW_LINE return ; NEW_LINE DEDENT generateStr ( a [ 1 : ] , b [ 1 : ] , s + a [ 0 ] , count + 1 , len ) ; NEW_LINE generateStr ( a [ 1 : ] , b [ 1 : ] , s + b [ 0 ] , count + 1 , len ) ; NEW_LINE DEDENT
def countTotalDistinct ( string ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE items = set ( ) ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT temp = " " ; NEW_LINE ans = set ( ) ; NEW_LINE for j in range ( i , len ( string ) ) : NEW_LINE INDENT temp = temp + string [ j ] ; NEW_LINE ans . add ( string [ j ] ) ; NEW_LINE if temp not in items : NEW_LINE INDENT items . add ( temp ) ; NEW_LINE cnt += len ( ans ) ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def removeDuplicates ( S ) : NEW_LINE INDENT ans = " " ; NEW_LINE for it in S : NEW_LINE INDENT if ( ans == " " or ans [ - 1 ] != it ) : NEW_LINE INDENT ans += it ; NEW_LINE DEDENT elif ( ans [ - 1 ] == it ) : NEW_LINE INDENT ans = ans [ : - 1 ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def getOrgString ( s ) : NEW_LINE INDENT print ( s [ 0 ] , end = " " ) NEW_LINE i = 1 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) >= ord ( ' A ' ) and ord ( s [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT print ( " ▁ " , s [ i ] . lower ( ) , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = " " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def canConvert ( str1 , str2 ) : NEW_LINE INDENT i , j = 0 , 0 ; NEW_LINE while ( i < len ( str1 ) and j < len ( str2 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT if ( str1 [ i ] == '0' and str2 [ j ] == '1' and i + 1 < len ( str1 ) and str1 [ i + 1 ] == '0' ) : NEW_LINE INDENT i += 2 ; NEW_LINE j += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( i == len ( str1 ) and j == len ( str2 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT str1 = "00100" ; NEW_LINE str2 = "111" ; NEW_LINE if ( canConvert ( str1 , str2 ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def isPossible ( Str ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT freq [ Str [ j ] ] = freq . get ( Str [ j ] , 0 ) + 1 NEW_LINE if ( freq [ Str [ j ] ] > max_freq ) : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Str = " geeksforgeeks " NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPossible ( l , m , x , y ) : NEW_LINE INDENT if ( l * m == x + y ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def isValid ( s ) : NEW_LINE INDENT p = " " NEW_LINE p = s . find ( " geek " ) NEW_LINE if ( s . find ( " keeg " , p + 4 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isTwoAlter ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def findCount ( s , n , a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( b ) : NEW_LINE INDENT if ( i == a ) : NEW_LINE INDENT res += ( s [ n - i - 1 ] != '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT res += ( s [ n - i - 1 ] != '0' ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def positions ( str ) : NEW_LINE INDENT for i in str : NEW_LINE INDENT print ( ( ord ( i ) & NUM ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def lenoflongestnonpalindrome ( s ) : NEW_LINE INDENT max1 , length = 1 , 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT length = 0 NEW_LINE DEDENT elif s [ i + 1 ] == s [ i - 1 ] and i > 0 : NEW_LINE INDENT length = 1 NEW_LINE length += 1 NEW_LINE DEDENT DEDENT if max1 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max1 NEW_LINE DEDENT DEDENT
def printChar ( str_ , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( " { } " . format ( str_ [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def calcScore ( str ) : NEW_LINE INDENT score = 0 NEW_LINE len1 = len ( str ) NEW_LINE i = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT chunkSize = 1 NEW_LINE currentChar = str [ i ] NEW_LINE i += 1 NEW_LINE while ( i < len1 and str [ i ] == currentChar ) : NEW_LINE INDENT chunkSize += 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( currentChar == '1' ) : NEW_LINE INDENT score += pow ( chunkSize , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT score -= pow ( chunkSize , 2 ) NEW_LINE DEDENT DEDENT return score NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countSubStr ( str , n , x ) : NEW_LINE INDENT res = 0 ; count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT res += ( ( count + 1 ) * ( n - i ) ) ; NEW_LINE count = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
def isValid ( str1 , n ) : NEW_LINE INDENT if ( ( ( ord ( str1 [ 0 ] ) >= ord ( ' a ' ) and ord ( str1 [ 0 ] ) <= ord ( ' z ' ) ) or ( ord ( str1 [ 0 ] ) >= ord ( ' A ' ) and ord ( str1 [ 0 ] ) <= ord ( ' Z ' ) ) or ord ( str1 [ 0 ] ) == ord ( ' _ ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , len ( str1 ) ) : NEW_LINE INDENT if ( ( ( ord ( str1 [ i ] ) >= ord ( ' a ' ) and ord ( str1 [ i ] ) <= ord ( ' z ' ) ) or ( ord ( str1 [ i ] ) >= ord ( ' A ' ) and ord ( str1 [ i ] ) <= ord ( ' Z ' ) ) or ( ord ( str1 [ i ] ) >= ord ( '0' ) and ord ( str1 [ i ] ) <= ord ( '9' ) ) or ord ( str1 [ i ] ) == ord ( ' _ ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str1 = " _ geeks123" NEW_LINE n = len ( str1 ) NEW_LINE if ( isValid ( str1 , n ) ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT
def countSubStr ( string , n ) : NEW_LINE INDENT length = len ( string ) ; NEW_LINE return ( length - n + 1 ) ; NEW_LINE DEDENT
def countSubstrings ( s , c ) : NEW_LINE INDENT n = len ( s ) NEW_LINE cnt = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != c ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Sum += ( cnt * ( cnt + 1 ) ) // 2 NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT Sum += ( cnt * ( cnt + 1 ) ) // 2 NEW_LINE return Sum NEW_LINE DEDENT
def FirstAndLast ( string ) : NEW_LINE INDENT ch = list ( string ) ; NEW_LINE i = 0 ; NEW_LINE while i < len ( ch ) : NEW_LINE INDENT k = i ; NEW_LINE while ( i < len ( ch ) and ch [ i ] != ' ▁ ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT if ( ord ( ch [ k ] ) >= 97 and ord ( ch [ k ] ) <= 122 ) : NEW_LINE INDENT ch [ k ] = chr ( ord ( ch [ k ] ) - 32 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ch [ k ] = ch [ k ] NEW_LINE DEDENT if ( ord ( ch [ i - 1 ] ) >= 90 and ord ( ch [ i - 1 ] ) <= 122 ) : NEW_LINE INDENT ch [ i - 1 ] = chr ( ord ( ch [ i - 1 ] ) - 32 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ch [ i - 1 ] = ch [ i - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return " " . join ( ch ) ; NEW_LINE DEDENT
def findM ( s , x ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) != x ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def FirstAndLast ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT if i == len ( string ) - 1 : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT if string [ i ] == " ▁ " : NEW_LINE INDENT print ( string [ i - 1 ] , string [ i + 1 ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printLastChar ( string ) : NEW_LINE INDENT string = string + " ▁ " NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] == ' ▁ ' : NEW_LINE INDENT print ( string [ i - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def asciiToSentence ( string , length ) : NEW_LINE INDENT num = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT num = num * 10 + ( ord ( string [ i ] ) - ord ( '0' ) ) ; NEW_LINE if ( num >= 32 and num <= 122 ) : NEW_LINE INDENT ch = chr ( num ) ; NEW_LINE print ( ch , end = " " ) ; NEW_LINE num = 0 ; NEW_LINE DEDENT DEDENT DEDENT
def countDistinctCode ( string ) : NEW_LINE INDENT codes = set ( ) NEW_LINE for i in range ( 0 , len ( string ) - 1 ) : NEW_LINE INDENT codes . add ( string [ i : i + 2 ] ) NEW_LINE DEDENT return len ( codes ) NEW_LINE DEDENT
def countKeyPressed ( string , length ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT count += arr [ ord ( string [ i ] ) - ord ( ' a ' ) ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def minLettersNeeded ( n ) : NEW_LINE INDENT if n % 26 == 0 : NEW_LINE INDENT return ( n // 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) NEW_LINE DEDENT DEDENT
def countMinReversals ( expr ) : NEW_LINE INDENT length = len ( expr ) NEW_LINE if length % 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = 0 NEW_LINE open = 0 NEW_LINE close = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if expr [ i ] == " " : NEW_LINE INDENT open += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if not open : NEW_LINE INDENT close += 1 NEW_LINE DEDENT else : NEW_LINE INDENT open -= 1 NEW_LINE DEDENT DEDENT DEDENT ans = ( close // 2 ) + ( open // 2 ) NEW_LINE close %= 2 NEW_LINE open %= 2 NEW_LINE if close > 0 : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minReplacement ( s , length ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if i % 2 == 0 and s [ i ] == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i % 2 == 1 and s [ i ] == '0' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return min ( ans , length - ans ) NEW_LINE DEDENT
def substrDeletion ( string , length ) : NEW_LINE INDENT count0 = 0 ; NEW_LINE count1 = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 ; NEW_LINE DEDENT DEDENT return min ( count0 , count1 ) ; NEW_LINE DEDENT
def maxBalancedStr ( s ) : NEW_LINE INDENT open1 = 0 NEW_LINE close1 = 0 NEW_LINE open2 = 0 NEW_LINE close2 = 0 NEW_LINE open3 = 0 NEW_LINE close3 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : open1 += 1 continue if s [ i ] == ' ) ' : NEW_LINE INDENT close1 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' { ' : NEW_LINE INDENT open2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' } ' : NEW_LINE INDENT close2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' [ ' : NEW_LINE INDENT open3 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' ] ' : NEW_LINE INDENT close3 += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT maxLen = ( 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) ) NEW_LINE return maxLen NEW_LINE DEDENT
def findCost ( s1 , s2 , a , b , c , d , n ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( s1 [ i ] == '1' and s2 [ i ] == '2' ) or ( s2 [ i ] == '1' and s1 [ i ] == '2' ) ) : NEW_LINE INDENT cost += min ( d , min ( a , b + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '2' and s2 [ i ] == '3' ) or ( s2 [ i ] == '2' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( b , a + c ) ) NEW_LINE DEDENT elif ( ( s1 [ i ] == '1' and s2 [ i ] == '3' ) or ( s2 [ i ] == '1' and s1 [ i ] == '3' ) ) : NEW_LINE INDENT cost += min ( d , min ( c , a + b ) ) NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT
def prefixOccurrences ( str1 ) : NEW_LINE INDENT c = str1 [ 0 ] NEW_LINE countc = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == c ) : NEW_LINE INDENT countc += 1 NEW_LINE DEDENT DEDENT return countc NEW_LINE DEDENT
def Preprocess ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE mp [ A [ i ] ] = 1 NEW_LINE if A [ i ] == A [ n - i - 1 ] : NEW_LINE INDENT mp [ A [ n - i - 1 ] ] += 1 NEW_LINE DEDENT if B [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ B [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ B [ i ] ] = 1 NEW_LINE DEDENT if B [ n - i - 1 ] in mp . keys ( ) : NEW_LINE INDENT mp [ B [ n - 1 - i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ B [ n - 1 - i ] ] = 1 NEW_LINE DEDENT sz = len ( mp ) NEW_LINE if ( sz == 4 ) : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT elif ( sz == 3 ) : NEW_LINE INDENT ans += 1 + ( A [ i ] == A [ n - i - 1 ] ) NEW_LINE DEDENT elif ( sz == 2 ) : NEW_LINE INDENT ans += mp [ A [ i ] ] != 2 NEW_LINE DEDENT DEDENT if ( n % 2 == 1 and A [ n // 2 ] != B [ n // 2 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countStrings ( n , m , s ) : NEW_LINE INDENT ind = dict ( ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT mx = 0 NEW_LINE str1 = s [ j ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , int ( str1 [ i ] ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if int ( str1 [ i ] ) == mx : NEW_LINE INDENT ind [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT return len ( ind ) NEW_LINE DEDENT
def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT
def maxValue ( a , b ) : NEW_LINE INDENT b = sorted ( b ) NEW_LINE bi = [ i for i in b ] NEW_LINE ai = [ i for i in a ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( bi [ j ] > ai [ i ] ) : NEW_LINE INDENT ai [ i ] = bi [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT x = " " . join ( ai ) NEW_LINE return x NEW_LINE DEDENT
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if string [ i ] == string [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def decryptString ( str , n ) : NEW_LINE INDENT i = 0 NEW_LINE jump = 1 NEW_LINE decryptedStr = " " NEW_LINE while ( i < n ) : NEW_LINE INDENT decryptedStr += str [ i ] ; NEW_LINE i += jump NEW_LINE jump += 1 NEW_LINE DEDENT return decryptedStr NEW_LINE DEDENT
def countSubStr ( str , l , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT n = 0 NEW_LINE for j in range ( i , l , 1 ) : NEW_LINE INDENT n = n * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE if ( n % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def printString ( Str1 , n ) : NEW_LINE INDENT ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '1' ) : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT used = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '2' and used == False ) : NEW_LINE INDENT used = 1 NEW_LINE for j in range ( ones ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT DEDENT if ( Str1 [ i ] != '1' ) : NEW_LINE INDENT print ( Str1 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if ( used == False ) : NEW_LINE INDENT for j in range ( ones ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def Colour_Combination ( s ) : NEW_LINE INDENT temp = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) , 1 ) : NEW_LINE INDENT if ( temp != s [ i ] ) : NEW_LINE INDENT if ( ( temp == ' B ' or temp == ' G ' ) and ( s [ i ] == ' G ' or s [ i ] == ' B ' ) ) : NEW_LINE INDENT temp = ' Y ' NEW_LINE DEDENT elif ( ( temp == ' B ' or temp == ' Y ' ) and ( s [ i ] == ' Y ' or s [ i ] == ' B ' ) ) : NEW_LINE INDENT temp = ' G ' NEW_LINE DEDENT else : NEW_LINE INDENT temp = ' B ' NEW_LINE DEDENT DEDENT DEDENT return temp NEW_LINE DEDENT
def reverse ( str1 , x ) : NEW_LINE INDENT n = ( len ( str1 ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x - 1 , n - 1 , - 1 ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x , len ( str1 ) ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def removeChars ( s ) : NEW_LINE INDENT modifiedStr = " " NEW_LINE modifiedStr += s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) and s [ i - 1 ] . islower ( ) or s [ i ] . islower ( ) and s [ i - 1 ] . isupper ( ) ) : NEW_LINE INDENT modifiedStr += s [ i ] NEW_LINE DEDENT DEDENT return modifiedStr NEW_LINE DEDENT
def pairStar ( Input , Output , i = 0 ) : NEW_LINE INDENT Output = Output + Input [ i ] NEW_LINE if ( i == len ( Input ) - 1 ) : NEW_LINE INDENT print ( Output ) NEW_LINE return ; NEW_LINE DEDENT if ( Input [ i ] == Input [ i + 1 ] ) : NEW_LINE INDENT Output = Output + ' * ' ; NEW_LINE DEDENT pairStar ( Input , Output , i + 1 ) ; NEW_LINE DEDENT
def binarySearch ( arr , x ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( arr ) NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( ( r - l ) // 2 ) NEW_LINE res = ( x == arr [ m ] ) NEW_LINE if ( res == 0 ) : NEW_LINE INDENT return m - 1 NEW_LINE DEDENT if ( res > 0 ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def printExpansion ( str ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , len ( str ) ) : NEW_LINE INDENT print ( str [ j ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printExpansion ( str ) : NEW_LINE INDENT suff = " " NEW_LINE for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT suff = suff + str [ i ] NEW_LINE print ( suff , end = " " ) NEW_LINE DEDENT DEDENT
def count ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE d , count = 0 , 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT d += ord ( s [ i ] ) NEW_LINE if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT prev = ord ( s [ i - k ] ) NEW_LINE d -= prev NEW_LINE d += ord ( s [ i ] ) NEW_LINE if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE return count NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 for i in range ( 10 ) ] NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT a = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE fre [ a ] += 1 NEW_LINE DEDENT if ( fre [ a ] == 0 and fre [ b ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( fre [ a ] >= fre [ b ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT
def findSubstringCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ord ( str [ i ] ) + 1 == ord ( str [ i + 1 ] ) ) : NEW_LINE INDENT result += 1 NEW_LINE while ( ord ( str [ i ] ) + 1 == ord ( str [ i + 1 ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def CountCharacters ( str , l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE m = { } NEW_LINE length = len ( str ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if ( not ( l <= ord ( str [ i ] ) and ord ( str [ i ] ) <= r ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ord ( str [ i ] ) not in m : NEW_LINE INDENT m [ ord ( str [ i ] ) ] = 0 NEW_LINE print ( str [ i ] , end = " ▁ " ) NEW_LINE DEDENT m [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def strScore ( str , s , n ) : NEW_LINE INDENT score = 0 NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == s ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT score += ( ord ( s [ j ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT index = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT score = score * index NEW_LINE return score NEW_LINE DEDENT
def countChar ( str , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE repetitions = n // len ( str ) NEW_LINE count = count * repetitions NEW_LINE l = n % len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def separateChar ( str__ ) : NEW_LINE INDENT n = len ( str__ ) NEW_LINE digitSum = 0 NEW_LINE alphabetSum = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( str__ [ i ] ) >= 48 and ord ( str__ [ i ] ) <= 56 ) : NEW_LINE INDENT digitSum += ord ( str__ [ i ] ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT alphabetSum += ord ( str__ [ i ] ) - ord ( ' a ' ) + 1 NEW_LINE alphabetSum %= 26 NEW_LINE DEDENT DEDENT sumStr = str ( digitSum ) NEW_LINE alphabetStr = chr ( alphabetSum + ord ( ' a ' ) - 1 ) NEW_LINE sumStr += alphabetStr NEW_LINE return sumStr NEW_LINE DEDENT
def maxProductSum ( string , m ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxProd , maxSum = ( - ( sys . maxsize ) - 1 , - ( sys . maxsize ) - 1 ) NEW_LINE for i in range ( n - m + 1 ) : NEW_LINE INDENT product , sum = 1 , 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( " Maximum ▁ Product ▁ = " , maxProd ) NEW_LINE print ( " Maximum ▁ sum ▁ = " , maxSum ) NEW_LINE DEDENT
def countConsecutive ( s ) : NEW_LINE INDENT count = - 1 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( i <= len ( s ) ) : NEW_LINE INDENT if ( s [ i ] is s [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def CountCharacters ( str1 , l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len1 = len ( str1 ) NEW_LINE for i in str1 : NEW_LINE INDENT if ( l <= ord ( i ) and ord ( i ) <= r ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) - 2 : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '0' ) : NEW_LINE INDENT count = count + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def CountCharacters ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ord ( str [ i ] ) < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def countWords ( str ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( 1 , len ( str ) - 1 ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def smallest ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT ans = s [ 0 : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT
def replacingConsonants ( s ) : NEW_LINE INDENT nVowel = " aaaeeeeiiiiioooooouuuuuuuu " NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT s = s . replace ( s [ i ] , nVowel [ ord ( s [ i ] ) - 97 ] ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT right = 0 NEW_LINE left = 0 NEW_LINE coun = 0 NEW_LINE max_length = - ( sys . maxsize - 1 ) NEW_LINE s = s + '1' NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if s [ i ] == ' o ' : NEW_LINE INDENT coun += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if coun > max_length : NEW_LINE INDENT right = 0 NEW_LINE left = 0 NEW_LINE if s [ i ] == ' x ' : NEW_LINE INDENT right = 1 NEW_LINE DEDENT if i - coun > 0 and s [ i - coun - 1 ] == ' x ' : NEW_LINE INDENT left = 1 NEW_LINE DEDENT coun = math . ceil ( float ( coun / ( right + left ) ) ) NEW_LINE max_length = max ( max_length , coun ) NEW_LINE DEDENT coun = 0 NEW_LINE DEDENT DEDENT return max_length NEW_LINE DEDENT
def is_possible ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE one = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT if ( l % 2 == 0 ) : NEW_LINE INDENT return ( one == zero ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( abs ( one - zero ) == 1 ) NEW_LINE DEDENT DEDENT
def countSubStr ( S , X ) : NEW_LINE INDENT cnt = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i ] != '0' ) : NEW_LINE INDENT j = 1 NEW_LINE while ( ( j + i ) <= N ) : NEW_LINE INDENT num = int ( S [ i : i + j ] ) NEW_LINE if ( num > X ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT if s [ i ] < c : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def solve ( s , k ) : NEW_LINE INDENT count , length , pos = 0 , 0 , 0 NEW_LINE m = dict . fromkeys ( s , 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE length += 1 NEW_LINE if length > k : NEW_LINE INDENT m [ s [ pos ] ] -= 1 NEW_LINE pos += 1 NEW_LINE length -= 1 NEW_LINE DEDENT if length == k and m [ s [ i ] ] == length : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def minParentheses ( p ) : NEW_LINE INDENT bal = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , len ( p ) ) : NEW_LINE INDENT if ( p [ i ] == ' ( ' ) : NEW_LINE INDENT bal += 1 NEW_LINE DEDENT else : NEW_LINE INDENT bal += - 1 NEW_LINE DEDENT if ( bal == - 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE bal += 1 NEW_LINE DEDENT DEDENT return bal + ans NEW_LINE DEDENT
def isAnyNotPalindrome ( s ) : NEW_LINE INDENT unique = set ( ) NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT unique . add ( s [ i ] ) NEW_LINE DEDENT if ( len ( unique ) > 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT
def Solve ( N , M ) : NEW_LINE INDENT temp = ( N - 1 ) * ( M - 1 ) NEW_LINE ans = pow ( 2 , temp ) NEW_LINE if ( ( N + M ) % 2 != 0 ) : NEW_LINE INDENT print ( ans ) NEW_LINE else : NEW_LINE print ( 2 * ans ) NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , M = 3 , 3 NEW_LINE Solve ( N , M ) NEW_LINE DEDENT DEDENT DEDENT
def productAscii ( str ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT prod = prod * ord ( str [ i ] ) NEW_LINE DEDENT return prod NEW_LINE DEDENT
def isCheck ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE lowerStr , upperStr = " " , " " NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( ord ( str [ i ] ) >= 65 and ord ( str [ i ] ) <= 91 ) : NEW_LINE INDENT upperStr = upperStr + str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT lowerStr = lowerStr + str [ i ] NEW_LINE DEDENT DEDENT transformStr = lowerStr . upper ( ) NEW_LINE return transformStr == upperStr NEW_LINE DEDENT
def minimumLength ( s ) : NEW_LINE INDENT maxOcc = 0 NEW_LINE n = len ( s ) NEW_LINE arr = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if arr [ i ] > maxOcc : NEW_LINE INDENT maxOcc = arr [ i ] NEW_LINE DEDENT DEDENT return n - maxOcc NEW_LINE DEDENT
def oddEquivalent ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def minOperation ( s , i , j , count ) : NEW_LINE INDENT if ( ( i >= len ( s ) and j < 0 ) or ( i == j ) ) : NEW_LINE INDENT return MAX NEW_LINE DEDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( i >= len ( s ) ) : NEW_LINE INDENT return minOperation ( s , i , j - 1 , count + 1 ) NEW_LINE DEDENT elif ( j < 0 ) : NEW_LINE INDENT return minOperation ( s , i + 1 , j , count + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) NEW_LINE DEDENT DEDENT
def countStrings ( s ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( i % 2 == 0 and s [ i ] == ' $ ' ) : NEW_LINE INDENT sum *= 21 NEW_LINE DEDENT elif ( s [ i ] == ' $ ' ) : NEW_LINE INDENT sum *= 5 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def removeDuplicatesFromString ( str2 ) : NEW_LINE INDENT counter = 0 ; NEW_LINE i = 0 ; NEW_LINE size = len ( str2 ) ; NEW_LINE str1 = list ( str2 ) ; NEW_LINE x = 0 ; NEW_LINE length = 0 ; NEW_LINE while ( i < size ) : NEW_LINE INDENT x = ord ( str1 [ i ] ) - 97 ; NEW_LINE if ( ( counter & ( 1 << x ) ) == 0 ) : NEW_LINE INDENT str1 [ length ] = chr ( 97 + x ) ; NEW_LINE counter = counter | ( 1 << x ) ; NEW_LINE length += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT str2 = ' ' . join ( str1 ) ; NEW_LINE return str2 [ 0 : length ] ; NEW_LINE DEDENT
def removeDuplicatesFromString ( string ) : NEW_LINE INDENT table = [ 0 for i in range ( 256 ) ] NEW_LINE endIndex = 0 NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( table [ ord ( string [ i ] ) ] == 0 ) : NEW_LINE INDENT table [ ord ( string [ i ] ) ] = - 1 NEW_LINE string [ endIndex ] = string [ i ] NEW_LINE endIndex += 1 NEW_LINE DEDENT DEDENT ans = " " NEW_LINE for i in range ( endIndex ) : NEW_LINE ans += string [ i ] NEW_LINE return ans NEW_LINE DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ i ] == True : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE DEDENT DEDENT
def countFreq ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 for i in range ( limit + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , count [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def countFreq ( Str ) : NEW_LINE INDENT count = [ 0 ] * ( limit + 1 ) NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT count [ ord ( Str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( chr ( i ) , count [ i ] ) NEW_LINE DEDENT DEDENT
def isInGivenBase ( Str , base ) : NEW_LINE INDENT if ( base > 16 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( base <= 10 ) : NEW_LINE INDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( Str [ i ] . isnumeric ( ) and ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( Str [ i ] . isnumeric ( ) and ( ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) or ( ord ( Str [ i ] ) >= ord ( ' A ' ) and ord ( Str [ i ] ) < ( ord ( ' A ' ) + base - 10 ) ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT Str = " AF87" NEW_LINE if ( isInGivenBase ( Str , 16 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = sorted ( str1 ) NEW_LINE str1 = " ▁ " . join ( a ) NEW_LINE b = sorted ( str2 ) NEW_LINE str2 = " ▁ " . join ( b ) NEW_LINE for i in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def powerOfJump ( s ) : NEW_LINE INDENT count = 1 NEW_LINE max_so_far = 0 NEW_LINE ch = s [ - 1 ] NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == ch : NEW_LINE INDENT if count > max_so_far : NEW_LINE INDENT max_so_far = count NEW_LINE DEDENT count = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def averageValue ( s ) : NEW_LINE INDENT sum_char = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum_char += ord ( s [ i ] ) NEW_LINE DEDENT return sum_char // len ( s ) NEW_LINE DEDENT
def solve ( s1 , s2 ) : NEW_LINE INDENT flag1 = 0 NEW_LINE flag2 = 0 NEW_LINE if ( len ( s1 ) != len ( s2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l = len ( s1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s1 [ i ] == '1' ) : NEW_LINE INDENT flag1 = 1 ; NEW_LINE DEDENT if ( s2 [ i ] == '1' ) : NEW_LINE INDENT flag2 = 1 NEW_LINE DEDENT if ( flag1 & flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ! flag1 &   ! flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s1 = "100101" NEW_LINE s2 = "100000" NEW_LINE if solve ( s1 , s2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def firstNonRepeating ( string ) : NEW_LINE INDENT arr = [ - 1 for i in range ( NO_OF_CHARS ) ] NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if arr [ ord ( string [ i ] ) ] == - 1 : NEW_LINE INDENT arr [ ord ( string [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT arr [ ord ( string [ i ] ) ] = - 2 NEW_LINE DEDENT DEDENT res = 10 ** 18 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if arr [ i ] >= 0 : NEW_LINE INDENT res = min ( res , arr [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT string = " geeksforgeeks " NEW_LINE index = firstNonRepeating ( string ) NEW_LINE if index == 10 ** 18 : NEW_LINE INDENT print ( " Either ▁ all ▁ characters ▁ are ▁ repeating ▁ or ▁ string ▁ is ▁ empty " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ non - repeating ▁ character ▁ is " , string [ index ] ) NEW_LINE DEDENT
def multiply ( num1 , num2 ) : NEW_LINE INDENT n1 = len ( num1 ) NEW_LINE n2 = len ( num2 ) NEW_LINE if ( n1 == 0 or n2 == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( n1 + n2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n_1 = ord ( num1 [ i ] ) - ord ( '0' ) NEW_LINE i_n2 = 0 NEW_LINE for j in range ( n2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n_2 = ord ( num2 [ j ] ) - ord ( '0' ) NEW_LINE sum = n_1 * n_2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = sum // 10 NEW_LINE result [ i_n1 + i_n2 ] = sum % 10 NEW_LINE i_n2 += 1 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE DEDENT i_n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while ( i >= 0 and result [ i ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT s = " " NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s += str ( result [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def countDigits ( st , n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT cnt = 1 NEW_LINE i = 0 NEW_LINE st2 = " " NEW_LINE i = 1 NEW_LINE while ( i < len ( st ) ) : NEW_LINE INDENT if ( st [ i ] == st [ i - 1 ] ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT else : NEW_LINE INDENT st2 += chr ( 48 + cnt ) NEW_LINE st2 += st [ i - 1 ] NEW_LINE cnt = 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT st2 += chr ( 48 + cnt ) NEW_LINE st2 += st [ i - 1 ] NEW_LINE countDigits ( st2 , n - 1 ) NEW_LINE n = n - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( st ) NEW_LINE DEDENT DEDENT
def countSubstrig ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) ; NEW_LINE n2 = len ( str2 ) ; NEW_LINE if ( n1 == 0 or n1 < n2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( str1 [ 0 : n2 ] == str2 ) : NEW_LINE INDENT return countSubstrig ( str1 [ n2 - 1 : ] , str2 ) + 1 ; NEW_LINE DEDENT return countSubstrig ( str1 [ n2 - 1 : ] , str2 ) ; NEW_LINE DEDENT
def check ( s , m ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE c1 = c1 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 ; NEW_LINE c2 = c2 + 1 ; NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT s = "001001" ; NEW_LINE m = 2 ; NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def nextGreatestAlphabet ( alphabets , K ) : NEW_LINE INDENT n = len ( alphabets ) NEW_LINE if ( K >= alphabets [ n - 1 ] ) : NEW_LINE return alphabets [ 0 ] NEW_LINE l = 0 NEW_LINE r = len ( alphabets ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = int ( ( l + r ) / 2 ) NEW_LINE if ( alphabets [ mid ] > K ) : NEW_LINE INDENT r = mid - 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT if ( alphabets [ ans ] < K ) : NEW_LINE INDENT return alphabets [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return alphabets [ ans ] NEW_LINE DEDENT DEDENT
def hasAllcodes ( s , k ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT us . add ( s [ i : k ] ) NEW_LINE DEDENT return len ( us ) == 1 << k NEW_LINE DEDENT s = "00110110" NEW_LINE k = 2 NEW_LINE if ( hasAllcodes ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def possibleToSort ( arr , n , str ) : NEW_LINE INDENT max_element = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT max_element = max ( max_element , arr [ i ] ) NEW_LINE if ( str [ i ] == '0' ) : NEW_LINE INDENT if ( max_element > i + 1 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE continue NEW_LINE DEDENT if ( s [ i ] == ' F ' ) : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def LexicographicalMaxString ( str ) : NEW_LINE INDENT mx = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT mx = max ( mx , str [ i : ] ) NEW_LINE DEDENT return mx NEW_LINE DEDENT
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT str1 = "10101100" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str1 , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT str2 = "111010100" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str2 , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE return int ( n * ( n + 1 ) / 2 ) ; NEW_LINE DEDENT
def countWays ( s ) : NEW_LINE INDENT count = [ 0 ] * 26 ; NEW_LINE for x in s : NEW_LINE INDENT count [ ord ( x ) - ord ( ' a ' ) ] = ( count [ ord ( x ) - ord ( ' a ' ) ] ) + 1 ; NEW_LINE DEDENT count [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE ans = 1 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT ans *= count [ i ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def isPerfectSquareString ( str ) : NEW_LINE INDENT sum = 0 ; NEW_LINE l = len ( str ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum = sum + ord ( str [ i ] ) ; NEW_LINE DEDENT squareRoot = math . sqrt ( sum ) ; NEW_LINE return ( ( squareRoot - math . floor ( squareRoot ) ) == 0 ) ; NEW_LINE DEDENT str = " d " ; NEW_LINE if ( isPerfectSquareString ( str ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def findSubstrings ( s , k ) : NEW_LINE INDENT ans = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = [ 0 ] * 26 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT cnt [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( cnt [ ord ( s [ j ] ) - ord ( ' a ' ) ] <= k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findExtraCharacter ( strA , strB ) : NEW_LINE INDENT m1 = { } NEW_LINE for i in strB : NEW_LINE INDENT if i in m1 : NEW_LINE INDENT m1 [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 [ i ] = 1 NEW_LINE DEDENT DEDENT for i in strA : NEW_LINE INDENT m1 [ i ] -= 1 NEW_LINE DEDENT for h1 in m1 : NEW_LINE INDENT if m1 [ h1 ] == 1 : NEW_LINE INDENT return h1 NEW_LINE DEDENT DEDENT DEDENT
def transformString ( s ) : NEW_LINE INDENT ch = ' a ' NEW_LINE if ( len ( s ) < 26 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( ord ( ch ) > ord ( ' z ' ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( s [ i ] <= ch ) : NEW_LINE INDENT s [ i ] = ch NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT DEDENT if ( ch <= ' z ' ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT print ( " " . join ( s ) ) NEW_LINE DEDENT
def copy_str ( x , y ) : NEW_LINE INDENT if len ( y ) == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT c = copy_str ( x , ( y ) [ 1 : - 1 ] ) NEW_LINE return c NEW_LINE DEDENT DEDENT
def numofstring ( n , m ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return m NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return m * ( m - 1 ) NEW_LINE DEDENT return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) NEW_LINE DEDENT
def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT
def LargestString ( na ) : NEW_LINE INDENT N = len ( na ) NEW_LINE c = [ 0 ] * N NEW_LINE m = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT character = [ False ] * 26 NEW_LINE for k in range ( len ( na [ j ] ) ) : NEW_LINE INDENT x = ord ( na [ j ] [ k ] ) - ord ( ' A ' ) NEW_LINE if ( ( na [ j ] [ k ] != ' ▁ ' ) and ( character [ x ] == False ) ) : NEW_LINE INDENT c [ j ] += 1 NEW_LINE character [ x ] = True NEW_LINE DEDENT if ( c [ j ] > c [ m ] ) : NEW_LINE INDENT m = j NEW_LINE DEDENT DEDENT DEDENT print ( na [ m ] ) NEW_LINE DEDENT
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if ( n < cl ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) ) NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE corner = " geeks " NEW_LINE if ( isCornerPresent ( str , corner ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minRemoval ( strr ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for char in strr : NEW_LINE INDENT hash [ ord ( char ) - ord ( ' a ' ) ] = hash [ ord ( char ) - ord ( ' a ' ) ] + 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if hash [ i ] % 2 : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return 0 if count == 0 else count - 1 NEW_LINE DEDENT
def printSequence ( arr , input ) : NEW_LINE INDENT n = len ( input ) NEW_LINE output = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( input [ i ] == ' ▁ ' ) : NEW_LINE INDENT output = output + "0" NEW_LINE DEDENT else : NEW_LINE INDENT position = ord ( input [ i ] ) - ord ( ' A ' ) NEW_LINE output = output + arr [ position ] NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT
def findSubsequence ( stri , k ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR ; NEW_LINE for i in range ( len ( stri ) ) : NEW_LINE INDENT a [ ord ( stri [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( stri ) ) : NEW_LINE INDENT if a [ ord ( stri [ i ] ) - ord ( ' a ' ) ] >= k : NEW_LINE INDENT print ( stri [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def isConvertible ( str1 , str2 , k ) : NEW_LINE INDENT if ( ( len ( str1 ) + len ( str2 ) ) < k ) : NEW_LINE INDENT return True NEW_LINE DEDENT commonLength = 0 NEW_LINE for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT commonLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str = " abccaa " NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findLUSlength ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( len ( a ) , len ( b ) ) NEW_LINE DEDENT
def convert ( str ) : NEW_LINE INDENT w = " " NEW_LINE z = " " ; NEW_LINE str = str . upper ( ) + " ▁ " ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] ; NEW_LINE if ( ch != ' ▁ ' ) : NEW_LINE INDENT w = w + ch ; NEW_LINE DEDENT else : NEW_LINE INDENT z = ( z + ( w [ 0 ] ) . lower ( ) + w [ 1 : len ( w ) ] + " ▁ " ) ; NEW_LINE w = " " ; NEW_LINE DEDENT DEDENT return z ; NEW_LINE DEDENT
def convert ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE s1 = " " NEW_LINE s1 = s1 + s [ 0 ] . lower ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' and i <= n ) : NEW_LINE INDENT s1 = s1 + " ▁ " + ( s [ i + 1 ] ) . lower ( ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT s1 = s1 + ( s [ i ] ) . upper ( ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return s1 NEW_LINE DEDENT
def first ( str ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . istitle ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT str = " geeksforGeeKS " NEW_LINE res = first ( str ) NEW_LINE if ( res == 0 ) : NEW_LINE INDENT print ( " No ▁ uppercase ▁ letter " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def swapTwoHalves ( a , b ) : NEW_LINE INDENT la = len ( a ) NEW_LINE lb = len ( b ) NEW_LINE c = a [ 0 : la // 2 ] + b [ lb // 2 : lb ] NEW_LINE d = b [ 0 : lb // 2 ] + a [ la // 2 : la ] NEW_LINE print ( c ,   " " , d ) NEW_LINE DEDENT
def string_length ( str ) : NEW_LINE INDENT if str == ' ' : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + string_length ( str [ 1 : ] ) NEW_LINE DEDENT DEDENT
def lexNext ( s , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != ' z ' : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE s [ i ] = chr ( k + 1 ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT DEDENT s [ i ] = ' a ' NEW_LINE DEDENT
def longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * SIZE NEW_LINE freq2 = [ 0 ] * SIZE NEW_LINE l = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT l += min ( freq1 [ i ] , freq2 [ i ] ) NEW_LINE DEDENT return l NEW_LINE DEDENT
def isPanalphabeticWindow ( s , n ) : NEW_LINE INDENT ch = ' a ' NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT if ( ch == ' z ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = " abujm ▁ zvcd ▁ acefc ▁ deghf ▁ gijkle ▁ m ▁ n ▁ o ▁ p ▁ pafqrstuvwxyzfap " NEW_LINE n = len ( s ) NEW_LINE if ( isPanalphabeticWindow ( s , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def round ( n ) : NEW_LINE INDENT a = ( n // 10 ) * 10 NEW_LINE b = a + 10 NEW_LINE return ( b if n - a > b - n else a ) NEW_LINE DEDENT
def ASCIISentence ( str ) : NEW_LINE INDENT for i in str : NEW_LINE INDENT print ( ord ( i ) , end = ' ' ) NEW_LINE DEDENT print ( ' ' , ▁ end ▁ = ▁ ' ' ) NEW_LINE DEDENT
def convert ( string ) : NEW_LINE INDENT n = len ( string ) ; NEW_LINE string = list ( string ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == ' ▁ ' ) : NEW_LINE INDENT string [ i ] = ' _ ' ; NEW_LINE DEDENT else : NEW_LINE INDENT string [ i ] = string [ i ] . lower ( ) ; NEW_LINE DEDENT DEDENT string = " " . join ( string ) NEW_LINE print ( string ) ; NEW_LINE DEDENT
def findOccurrences ( str , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT
def isEven ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE dotSeen = False NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' and dotSeen == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == ' . ' ) : NEW_LINE INDENT dotSeen = True NEW_LINE continue NEW_LINE DEDENT if ( ( int ) ( s [ i ] ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT s = "100.70" NEW_LINE if ( isEven ( s ) ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT
def largestAnagramSet ( arr , n ) : NEW_LINE INDENT maxSize = 0 NEW_LINE count = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = ' ' . join ( sorted ( arr [ i ] ) ) NEW_LINE if arr [ i ] in count : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = 1 NEW_LINE DEDENT maxSize = max ( maxSize , count [ arr [ i ] ] ) NEW_LINE DEDENT return maxSize NEW_LINE DEDENT
def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( " Vowels : " , vowels ) NEW_LINE print ( " Consonant : " , consonant ) NEW_LINE print ( " Digit : " , digit ) NEW_LINE print ( " Special ▁ Character : " , specialChar ) NEW_LINE DEDENT
def finalPosition ( move ) : NEW_LINE INDENT l = len ( move ) NEW_LINE countUp , countDown = 0 , 0 NEW_LINE countLeft , countRight = 0 , 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( move [ i ] == ' U ' ) : NEW_LINE INDENT countUp += 1 NEW_LINE DEDENT elif ( move [ i ] == ' D ' ) : NEW_LINE INDENT countDown += 1 NEW_LINE DEDENT elif ( move [ i ] == ' L ' ) : NEW_LINE INDENT countLeft += 1 NEW_LINE DEDENT elif ( move [ i ] == ' R ' ) : NEW_LINE INDENT countRight += 1 NEW_LINE DEDENT DEDENT print ( " Final ▁ Position : ▁ ( " , ( countRight - countLeft ) , " , ▁ " , ( countUp - countDown ) , " ) " ) NEW_LINE DEDENT
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == c1 ) : NEW_LINE INDENT s = s [ 0 : i ] + c2 + s [ i + 1 : ] NEW_LINE DEDENT elif ( s [ i ] == c2 ) : NEW_LINE INDENT s = s [ 0 : i ] + c1 + s [ i + 1 : ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def maxbalancedprefix ( str , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE maxi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == ' ( ' : NEW_LINE INDENT _sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT _sum -= 1 NEW_LINE DEDENT if _sum < 0 : NEW_LINE INDENT break NEW_LINE DEDENT if _sum == 0 : NEW_LINE INDENT maxi = i + 1 NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT
def fibWord ( n ) : NEW_LINE INDENT Sn_1 = "0" NEW_LINE Sn = "01" NEW_LINE tmp = " " NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT tmp = Sn NEW_LINE Sn += Sn_1 NEW_LINE Sn_1 = tmp NEW_LINE DEDENT return Sn NEW_LINE DEDENT
def countOccurrences ( str , word ) : NEW_LINE INDENT a = str . split ( " ▁ " ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT if ( word == a [ i ] ) : NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def compute ( st , n ) : NEW_LINE INDENT reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " NEW_LINE l = len ( st ) NEW_LINE answer = " " NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT answer = answer + st [ i ] ; NEW_LINE DEDENT for i in range ( n , l ) : NEW_LINE INDENT answer = ( answer + reverseAlphabet [ ord ( st [ i ] ) - ord ( ' a ' ) ] ) ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT
def generateString ( n ) : NEW_LINE INDENT s = " " ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i & 2 ) > 1 ) : NEW_LINE INDENT s += ' b ' ; NEW_LINE DEDENT else : NEW_LINE INDENT s += ' a ' ; NEW_LINE DEDENT DEDENT print ( s ) ; NEW_LINE DEDENT
def cost ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE res = 0 NEW_LINE j = l - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( st [ i ] != st [ j ] ) : NEW_LINE INDENT res += ( min ( ord ( st [ i ] ) , ord ( st [ j ] ) ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def isValidISBN ( isbn ) : NEW_LINE INDENT if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE return ( _sum % 11 == 0 ) NEW_LINE DEDENT isbn = "007462542X " NEW_LINE if isValidISBN ( isbn ) : NEW_LINE INDENT print ( ' Valid ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT
def remainder ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT num = rem * 10 + ( int ) ( st [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT
def longestSubseq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE pre_count_0 = [ 0 for i in range ( n + 2 ) ] NEW_LINE pre_count_1 = [ 0 for i in range ( n + 1 ) ] NEW_LINE post_count_0 = [ 0 for i in range ( n + 2 ) ] NEW_LINE pre_count_0 [ 0 ] = 0 NEW_LINE post_count_0 [ n + 1 ] = 0 NEW_LINE pre_count_1 [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pre_count_0 [ j ] = pre_count_0 [ j - 1 ] NEW_LINE pre_count_1 [ j ] = pre_count_1 [ j - 1 ] NEW_LINE post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] NEW_LINE if ( s [ j - 1 ] == '0' ) : NEW_LINE INDENT pre_count_0 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pre_count_1 [ j ] += 1 NEW_LINE DEDENT if ( s [ n - j ] == '0' ) : NEW_LINE INDENT post_count_0 [ n - j + 1 ] += 1 NEW_LINE DEDENT DEDENT if ( pre_count_0 [ n ] == n or pre_count_0 [ n ] == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 1 ) : NEW_LINE INDENT ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def removeSpecialCharacter ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ( ord ( s [ i ] ) < ord ( ' A ' ) or ord ( s [ i ] ) > ord ( ' Z ' ) and ord ( s [ i ] ) < ord ( ' a ' ) or ord ( s [ i ] ) > ord ( ' z ' ) ) : NEW_LINE INDENT del s [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( " " . join ( s ) ) NEW_LINE DEDENT
def removeSpecialCharacter ( s ) : NEW_LINE INDENT t = " " NEW_LINE for i in s : NEW_LINE INDENT if ( i >= ' A ' and i <= ' Z ' ) or ( i >= ' a ' and i <= ' z ' ) : NEW_LINE INDENT t += i NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE DEDENT
def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def maximumChars ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = - 1 NEW_LINE firstInd = [ - 1 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT first_ind = firstInd [ ord ( str1 [ i ] ) ] NEW_LINE if ( first_ind == - 1 ) : NEW_LINE INDENT firstInd [ ord ( str1 [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT
def findString ( n , k ) : NEW_LINE INDENT res = " " NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + count ) NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT count = 0 ; NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countReduce ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT res += abs ( int ( ord ( str [ i ] ) ) - int ( ord ( str [ n - i - 1 ] ) ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( 10 ) : NEW_LINE INDENT for m in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if ( i + j + k == l + m + n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c < ans ) : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def makeAndCheckString ( words , str ) : NEW_LINE INDENT n = len ( words ) NEW_LINE first = second = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if words [ i ] == str : NEW_LINE INDENT return True NEW_LINE DEDENT if str [ 0 ] == words [ i ] [ 1 ] : NEW_LINE INDENT first = True NEW_LINE DEDENT if str [ 1 ] == words [ i ] [ 0 ] : NEW_LINE INDENT second = True NEW_LINE DEDENT if first and second : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT str = ' ya ' NEW_LINE words = [ ' ah ' , ' oy ' , ' to ' , ' ha ' ] NEW_LINE if makeAndCheckString ( words , str ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def checkLuhn ( cardNo ) : NEW_LINE INDENT nDigits = len ( cardNo ) NEW_LINE nSum = 0 NEW_LINE isSecond = False NEW_LINE for i in range ( nDigits - 1 , - 1 , - 1 ) : NEW_LINE INDENT d = ord ( cardNo [ i ] ) - ord ( '0' ) NEW_LINE if ( isSecond == True ) : NEW_LINE INDENT d = d * 2 NEW_LINE DEDENT nSum += d // 10 NEW_LINE nSum += d % 10 NEW_LINE isSecond = not isSecond NEW_LINE DEDENT if ( nSum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findRepeatFirstN2 ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( p != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT
def countSubstrs ( str , i , j , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) NEW_LINE if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def stringPalindrome ( A , B ) : NEW_LINE INDENT countA = [ 0 ] * MAX_CHAR NEW_LINE countB = [ 0 ] * MAX_CHAR NEW_LINE l1 = len ( A ) NEW_LINE l2 = len ( B ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT countA [ ord ( A [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT countB [ ord ( B [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( ( countA [ i ] > 1 and countB [ i ] == 0 ) ) : NEW_LINE INDENT return ' A ' NEW_LINE DEDENT DEDENT return ' B ' NEW_LINE DEDENT
def prCharWithFreq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = np . zeros ( 26 , dtype = np . int ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] != 0 ) : NEW_LINE INDENT print ( str [ i ] , freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] , end = " ▁ " ) NEW_LINE freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] = 0 NEW_LINE DEDENT DEDENT DEDENT
def FirstRepeated ( string ) : NEW_LINE INDENT checker = 0 NEW_LINE pos = 0 NEW_LINE for i in string : NEW_LINE INDENT val = ord ( i ) - ord ( ' a ' ) ; NEW_LINE if ( ( checker & ( 1 << val ) ) > 0 ) : NEW_LINE INDENT return pos NEW_LINE DEDENT checker |= ( 1 << val ) NEW_LINE pos += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT string = " abcfdeacf " NEW_LINE i = FirstRepeated ( string ) NEW_LINE if i != - 1 : NEW_LINE INDENT print " Char ▁ = ▁ " , string [ i ] , " ▁ and ▁ Index ▁ = ▁ " , i ; NEW_LINE DEDENT else : NEW_LINE INDENT print " No ▁ repeated ▁ Char " NEW_LINE DEDENT
def printSubsequences ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE opsize = int ( pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( opsize ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( str [ j ] , end = " " ) NEW_LINE if ( counter & ( 1 << j ) ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( " " , ▁ end ▁ = ▁ " " ) NEW_LINE DEDENT DEDENT
def sentencePalindrome ( s ) : NEW_LINE INDENT l , h = 0 , len ( s ) - 1 NEW_LINE s = s . lower ( ) NEW_LINE while ( l <= h ) : NEW_LINE INDENT if ( not ( s [ l ] >= ' a ' and s [ l ] <= ' z ' ) ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( not ( s [ h ] >= ' a ' and s [ h ] <= ' z ' ) ) : NEW_LINE INDENT h -= 1 NEW_LINE DEDENT elif ( s [ l ] == s [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " Too ▁ hot ▁ to ▁ hoot . " NEW_LINE if ( sentencePalindrome ( s ) ) : NEW_LINE INDENT print " Sentence ▁ is ▁ palindrome . " NEW_LINE DEDENT else : NEW_LINE INDENT print " Sentence ▁ is ▁ not ▁ palindrome . " NEW_LINE DEDENT
def substringConversions ( s , k , b ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ( i + k ) < l + 1 ) : NEW_LINE INDENT sub = s [ i : i + k ] ; NEW_LINE sum , counter = 0 , 0 ; NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ; NEW_LINE counter += 1 ; NEW_LINE DEDENT print ( sum , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def permute ( inp ) : NEW_LINE INDENT n = len ( inp ) NEW_LINE mx = 1 << n NEW_LINE inp = inp . lower ( ) NEW_LINE for i in range ( mx ) : NEW_LINE INDENT combination = [ k for k in inp ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( ( i >> j ) & 1 ) == 1 ) : NEW_LINE INDENT combination [ j ] = inp [ j ] . upper ( ) NEW_LINE DEDENT DEDENT temp = " " NEW_LINE for i in combination : NEW_LINE INDENT temp += i NEW_LINE DEDENT print temp , NEW_LINE DEDENT DEDENT
def xorZero ( str ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT
def findFlips ( str , n ) : NEW_LINE INDENT last = ' ▁ ' NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( last != str [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT last = str [ i ] NEW_LINE DEDENT return res // 2 NEW_LINE DEDENT
def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] . isdigit ( ) != True : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def allCharactersSame ( s ) : NEW_LINE INDENT s1 = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s1 . append ( s [ i ] ) NEW_LINE DEDENT s1 = list ( set ( s1 ) ) NEW_LINE if ( len ( s1 ) == 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def evenlength ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def possibleStrings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , left + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 , 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def splitString ( str ) : NEW_LINE INDENT alpha = " " NEW_LINE num = " " NEW_LINE special = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num + str [ i ] NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT special += str [ i ] NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT
def subString ( Str , n ) : NEW_LINE INDENT for Len in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - Len + 1 ) : NEW_LINE INDENT j = i + Len - 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( Str [ k ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT
def subString ( s , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for len in range ( i + 1 , n + 1 ) : NEW_LINE INDENT print ( s [ i : len ] ) ; NEW_LINE DEDENT DEDENT DEDENT
def printAllSubstrings ( s , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT temp = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT DEDENT
def printSubstrings ( string , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , ( j + 1 ) ) : NEW_LINE INDENT print ( string [ k ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT
def processWords ( input ) : NEW_LINE INDENT s = input . split ( " ▁ " ) NEW_LINE for values in s : NEW_LINE INDENT charBuffer . append ( values [ 0 ] ) NEW_LINE DEDENT return charBuffer NEW_LINE DEDENT
def amendSentence ( string ) : NEW_LINE INDENT string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] >= ' A ' and string [ i ] <= ' Z ' : NEW_LINE INDENT string [ i ] = chr ( ord ( string [ i ] ) + 32 ) NEW_LINE if i != 0 : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def repeat ( s , n ) : NEW_LINE INDENT s1 = s NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += s1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def lengthOfLastWord ( a ) : NEW_LINE INDENT l = 0 NEW_LINE x = a . strip ( ) NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if x [ i ] == " ▁ " : NEW_LINE INDENT l = 0 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT
def toggleCase ( a ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a = a [ : i ] + chr ( ord ( a [ i ] ) ^ 32 ) + a [ i + 1 : ] ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT
def uniqueCharacters ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT str = " GeeksforGeeks " ; NEW_LINE if ( uniqueCharacters ( str ) ) : NEW_LINE INDENT print ( " The ▁ String ▁ " , str , " ▁ has ▁ all ▁ unique ▁ characters " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ String ▁ " , str , " ▁ has ▁ duplicate ▁ characters " ) ; NEW_LINE DEDENT
def uniqueCharacters ( str ) : NEW_LINE INDENT checker = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT bitAtIndex = ord ( str [ i ] ) - ord ( ' a ' ) NEW_LINE if ( ( bitAtIndex ) > 0 ) : NEW_LINE INDENT if ( ( checker & ( ( 1 << bitAtIndex ) ) ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def printRotatedString ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE temp = string + string NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( temp [ i + j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def solve ( i , X , Y , a , b , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X <= 0 ) : NEW_LINE INDENT return ( b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) NEW_LINE DEDENT if ( Y <= 0 ) : NEW_LINE INDENT return ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) , b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) NEW_LINE DEDENT DEDENT
def moveSpaceInFront ( s ) : NEW_LINE INDENT i = len ( s ) - 1 ; NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ j ] != ' ▁ ' ) : NEW_LINE INDENT s = s [ : i ] + s [ j ] + s [ i + 1 : ] NEW_LINE i -= 1 ; NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT s = s [ : i ] + ' ▁ ' + s [ i + 1 : ] NEW_LINE i -= 1 NEW_LINE DEDENT return s ; NEW_LINE DEDENT
def titleToNumber ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE for B in range ( len ( s ) ) : NEW_LINE INDENT result *= 26 ; NEW_LINE result += ord ( s [ B ] ) - ord ( ' A ' ) + 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if n & ( 1 << ( k - 1 ) ) : NEW_LINE INDENT print ( " SET " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NOT ▁ SET " ) NEW_LINE DEDENT DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if ( ( n >> ( k - 1 ) ) and 1 ) : NEW_LINE INDENT print ( " SET " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NOT ▁ SET " ) NEW_LINE DEDENT DEDENT
def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; NEW_LINE str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ) ; NEW_LINE str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; NEW_LINE start += 1 ; NEW_LINE end -= 1 ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT
def isanbn ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n & 1 : NEW_LINE INDENT return " No " NEW_LINE DEDENT for i in range ( int ( n / 2 ) ) : NEW_LINE INDENT if str [ i ] != ' a ' or str [ n - i - 1 ] != ' b ' : NEW_LINE return " No " NEW_LINE DEDENT return " Yes " NEW_LINE DEDENT
def evenNumSubstring ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE count = [ 0 ] * MAX_CHAR ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
def maxRepeating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE cur_count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT cur_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE oddDigSum = 0 NEW_LINE evenDigSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT DEDENT return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) NEW_LINE DEDENT st = "76945" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) NEW_LINE DEDENT
def _print ( string ) : NEW_LINE INDENT print ( string [ 0 ] , end = " " ) NEW_LINE for i in range ( 1 , len ( string ) ) : NEW_LINE INDENT if ( ord ( string [ i ] ) == ord ( string [ i - 1 ] ) + 1 or ord ( string [ i ] ) == ord ( string [ i - 1 ] ) - 1 ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ) NEW_LINE print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def areCharactersUnique ( s ) : NEW_LINE INDENT checker = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE if ( checker & ( 1 << val ) ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT checker |= ( 1 << val ) NEW_LINE DEDENT return True NEW_LINE DEDENT s = " aaabbccdaa " NEW_LINE if areCharactersUnique ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def unique ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE s . sort ( ) NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE break NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if ( unique ( " abcdd " ) == True ) : NEW_LINE INDENT print ( " String ▁ is ▁ Unique " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " String ▁ is ▁ not ▁ Unique " ) NEW_LINE DEDENT
def countWords ( str , l ) : NEW_LINE INDENT count = 1 ; NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , l - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def hammingDist ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE count = 0 NEW_LINE while ( i < len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE print ( " Yes " ) if s [ i ] == s [ j ] else print ( " No " ) NEW_LINE DEDENT
def isequal ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE num = 0 NEW_LINE x = 1 NEW_LINE i = n - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( '0' <= str [ i ] and str [ i ] <= '9' ) : NEW_LINE INDENT num = ( ord ( str [ i ] ) - ord ( '0' ) ) * x + num NEW_LINE x = x * 10 NEW_LINE if ( num >= n ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return num == i + 1 NEW_LINE DEDENT
def arekAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] > count2 [ i ] ) : NEW_LINE INDENT count = count + abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT DEDENT return ( count <= k ) NEW_LINE DEDENT
def countToMake0lternate ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE DEDENT return result NEW_LINE DEDENT
def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT
def ispalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE j = l - 1 NEW_LINE while i <= j : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( ' a ' ) ) or ( i == ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def canBecomeEmpty ( string , sub_str ) : NEW_LINE INDENT while len ( string ) > 0 : NEW_LINE INDENT idx = string . find ( sub_str ) NEW_LINE if idx == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT string = string . replace ( sub_str , " " , 1 ) NEW_LINE DEDENT return ( len ( string ) == 0 ) NEW_LINE DEDENT
def waysToPaint ( n ) : NEW_LINE INDENT same = 6 NEW_LINE diff = 6 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT sameTmp = 3 * same + 2 * diff NEW_LINE diffTmp = 2 * same + 2 * diff NEW_LINE same = sameTmp NEW_LINE diff = diffTmp NEW_LINE DEDENT print ( same + diff ) NEW_LINE DEDENT
def isReversible ( str ) : NEW_LINE INDENT i = 0 ; j = len ( str ) - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT str = " aba " ; NEW_LINE if ( isReversible ( str ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def findSum ( str1 ) : NEW_LINE INDENT temp = "0" NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = "0" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT
def intToRoman ( num ) : NEW_LINE INDENT m = [ " " , " M " , " MM " , " MMM " ] NEW_LINE c = [ " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM ▁ " ] NEW_LINE x = [ " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " ] NEW_LINE i = [ " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " ] NEW_LINE thousands = m [ num // 1000 ] NEW_LINE hundereds = c [ ( num % 1000 ) // 100 ] NEW_LINE tens = x [ ( num % 100 ) // 10 ] NEW_LINE ones = i [ num % 10 ] NEW_LINE ans = ( thousands + hundereds + tens + ones ) NEW_LINE return ans NEW_LINE DEDENT
def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def to_upper ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ' a ' <= string [ i ] <= ' z ' ) : NEW_LINE INDENT string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) ) + string [ i + 1 : ] ) NEW_LINE DEDENT DEDENT return string ; NEW_LINE DEDENT
def to_upper ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ' a ' <= s [ i ] <= ' z ' ) : NEW_LINE INDENT s = s [ 0 : i ] + chr ( ord ( s [ i ] ) & ( ~ ( 1 << 5 ) ) ) + s [ i + 1 : ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT
def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE tuples = { } ; NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def isEditDistanceOne ( s1 , s2 ) : NEW_LINE INDENT m = len ( s1 ) NEW_LINE n = len ( s2 ) NEW_LINE if abs ( m - n ) > 1 : NEW_LINE INDENT return false NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if s1 [ i ] != s2 [ j ] : NEW_LINE INDENT if count == 1 : NEW_LINE INDENT return false NEW_LINE DEDENT if m > n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif m < n : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT count += 1 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if i < m or j < n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count == 1 NEW_LINE DEDENT s1 = " gfg " NEW_LINE s2 = " gf " NEW_LINE if isEditDistanceOne ( s1 , s2 ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def removeRecurringDigits ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE ( i , j ) = ( 0 , 0 ) NEW_LINE str = ' ' NEW_LINE while i < l : NEW_LINE INDENT str += num [ i ] NEW_LINE j += 1 NEW_LINE while ( i + 1 < l and num [ i ] == num [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return str NEW_LINE DEDENT
def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def pattern ( st , length ) : NEW_LINE INDENT for i in range ( length ) : NEW_LINE INDENT j = length - 1 - i NEW_LINE for k in range ( length ) : NEW_LINE INDENT if ( k == i or k == j ) : NEW_LINE INDENT print ( st [ k ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def printPattern ( Str , Len ) : NEW_LINE INDENT for i in range ( Len ) : NEW_LINE INDENT for j in range ( Len ) : NEW_LINE INDENT if ( ( i == j ) or ( i + j == Len - 1 ) ) : NEW_LINE INDENT print ( Str [ j ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def removeRecur ( n ) : NEW_LINE INDENT prev_digit = n % 10 NEW_LINE pow = 10 NEW_LINE res = prev_digit NEW_LINE while ( n ) : NEW_LINE INDENT curr_digit = n % 10 NEW_LINE if ( curr_digit != prev_digit ) : NEW_LINE INDENT res += curr_digit * pow NEW_LINE prev_digit = curr_digit NEW_LINE pow *= 10 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def removeSpaces ( string ) : NEW_LINE INDENT string = string . replace ( ' ▁ ' , ' ' ) NEW_LINE return string NEW_LINE DEDENT
def countSubStr ( st , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( st [ j ] == '1' ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def countSubStr ( st , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT m = m + 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) // 2 NEW_LINE DEDENT
def canFormPalindrome ( s ) : NEW_LINE INDENT bitvector = 0 NEW_LINE for str in s : NEW_LINE INDENT bitvector ^= 1 << ord ( str ) NEW_LINE DEDENT return bitvector == 0 or bitvector & ( bitvector - 1 ) == 0 NEW_LINE DEDENT if canFormPalindrome ( " geeksforgeeks " ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = ord ( number [ i ] ) - ord ( '0' ) NEW_LINE if ( number [ i ] == '9' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = ( sum + ord ( number [ j ] ) - ord ( '0' ) ) % 9 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countWords ( string ) : NEW_LINE INDENT state = OUT NEW_LINE wc = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' ▁ ' or string [ i ] ==   ' ' ▁ or ▁ string [ i ] ▁ = = ▁ ' 	 ' ) : NEW_LINE INDENT state = OUT NEW_LINE DEDENT elif state == OUT : NEW_LINE INDENT state = IN NEW_LINE wc += 1 NEW_LINE DEDENT DEDENT return wc NEW_LINE DEDENT string =   " One two three NEW_LINE INDENT four five   " NEW_LINE DEDENT
def longestUniqueSubsttr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited = [ 0 ] * 256 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( visited [ ord ( str [ j ] ) ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , j - i + 1 ) NEW_LINE visited [ ord ( str [ j ] ) ] = True NEW_LINE DEDENT DEDENT visited [ ord ( str [ i ] ) ] = False NEW_LINE DEDENT return res NEW_LINE DEDENT
def printRLE ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT count = 1 NEW_LINE while ( i < n - 1 and st [ i ] == st [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE print ( st [ i - 1 ] + str ( count ) , end = " " ) NEW_LINE DEDENT DEDENT
def reverse ( string ) : NEW_LINE INDENT if len ( string ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT temp = string [ 0 ] NEW_LINE reverse ( string [ 1 : ] ) NEW_LINE print ( temp , end = ' ' ) NEW_LINE DEDENT
def removeDuplicate ( str , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in str : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT st = " " NEW_LINE for i in s : NEW_LINE INDENT st = st + i NEW_LINE DEDENT return st NEW_LINE DEDENT
def unique ( s ) : NEW_LINE INDENT st = " " NEW_LINE length = len ( s ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT c = s [ i ] NEW_LINE if c not in st : NEW_LINE INDENT st += c NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT
def maximumXOR ( arr , n , K ) : NEW_LINE INDENT K += 1 NEW_LINE maxXor = - 10 ** 9 NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT if ( bin ( i ) . count ( '1' ) == K ) : NEW_LINE INDENT cur_xor = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT cur_xor = cur_xor ^ arr [ j ] NEW_LINE DEDENT DEDENT maxXor = max ( maxXor , cur_xor ) NEW_LINE DEDENT DEDENT return maxXor NEW_LINE DEDENT
def TowerOfHanoi ( N ) : NEW_LINE INDENT for x in range ( 1 , int ( math . pow ( 2 , N ) ) ) : NEW_LINE INDENT print ( " Move ▁ from ▁ Rod ▁ " , ( ( x & x - 1 ) % 3 + 1 ) , " ▁ to ▁ Rod ▁ " , ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) ) NEW_LINE DEDENT DEDENT
def printPairs ( arr , arr_size , sum ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT temp = sum - arr [ i ] NEW_LINE if ( temp in s ) : NEW_LINE INDENT print " Pair ▁ with ▁ given ▁ sum ▁ " + str ( sum ) + NEW_LINE DEDENT DEDENT " ▁ is ▁ ( " + str ( arr [ i ] ) + " , ▁ " + str ( temp ) + " ) " NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def numPairs ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( 2 * a [ i ] >= a [ j - 1 ] and 2 * a [ i ] < a [ j ] ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT if index == 0 : NEW_LINE INDENT index = n NEW_LINE DEDENT ans += index - i - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def count ( arr , low , high , x ) : NEW_LINE INDENT if ( ( low > high ) or ( low == high and arr [ low ] != x ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( low == high and arr [ low ] == x ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return count ( arr , low , ( low + high ) // 2 , x ) + count ( arr , 1 + ( low + high ) // 2 , high , x ) ; NEW_LINE DEDENT
def F ( A , B ) : NEW_LINE INDENT if ( A == 1 ) : NEW_LINE INDENT return ( 4 % B ) ; NEW_LINE DEDENT else : NEW_LINE INDENT temp = F ( A - 1 , B ) ; NEW_LINE return ( temp * temp ) % B ; NEW_LINE DEDENT DEDENT
def rangeSum ( l , r ) : NEW_LINE INDENT a = 1 ; b = 9 ; res = 0 ; NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT L = max ( l , a ) ; NEW_LINE R = min ( r , b ) ; NEW_LINE if ( L <= R ) : NEW_LINE INDENT sum = ( L + R ) * ( R - L + 1 ) // 2 ; NEW_LINE res += ( i * i ) * ( sum % MOD ) ; NEW_LINE res %= MOD ; NEW_LINE DEDENT a *= 10 ; NEW_LINE b = b * 10 + 9 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def exponentMod ( A , B , C ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponentMod ( A , B / 2 , C ) NEW_LINE y = ( y * y ) % C NEW_LINE DEDENT else : NEW_LINE INDENT y = A % C NEW_LINE y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C NEW_LINE DEDENT return ( ( y + C ) % C ) NEW_LINE DEDENT
def minDaysToEmpty ( C , l ) : NEW_LINE INDENT if ( l >= C ) : return C NEW_LINE eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 NEW_LINE return math . ceil ( eq_root ) + l NEW_LINE DEDENT
def shuffleArray ( a , n ) : NEW_LINE INDENT i , q , k = 0 , 1 , n NEW_LINE while ( i < n ) : NEW_LINE INDENT j = k NEW_LINE while ( j > i + q ) : NEW_LINE INDENT a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT a = [ 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shuffleArray ( a , int ( n / 2 ) ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * ( m + n ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE d += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE d += 1 NEW_LINE j += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT
def binarySearch ( arr , left , right ) : NEW_LINE INDENT if ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 ; NEW_LINE if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( arr [ mid ] < arr [ mid + 1 ] ) : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , right ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , left , mid - 1 ) ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE index = binarySearch ( arr , 1 , n - 2 ) ; NEW_LINE if ( index != - 1 ) : NEW_LINE INDENT print ( arr [ index ] ) ; NEW_LINE DEDENT
def findRepeatingElement ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( arr [ mid ] != mid + 1 ) : NEW_LINE INDENT if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT return findRepeatingElement ( arr , low , mid - 1 ) NEW_LINE DEDENT return findRepeatingElement ( arr , mid + 1 , high ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE index = findRepeatingElement ( arr , 0 , n - 1 ) NEW_LINE if ( index is not - 1 ) : NEW_LINE INDENT print arr [ index ] NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) != 0 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT DEDENT DEDENT y = y >> 1 NEW_LINE x = x * x NEW_LINE INDENT return res NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 y = y / 2 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 ; result = 1 NEW_LINE while ( result <= x ) : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
def countDirectPath ( N ) : NEW_LINE INDENT return N + ( N * ( N - 3 ) ) // 2 NEW_LINE DEDENT
def findArea ( a , b , c ) : NEW_LINE INDENT area = ( 4 * 3.141592653 * pow ( ( pow ( a * b , 1.6 ) + pow ( a * c , 1.6 ) + pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ) NEW_LINE print ( " { : . 2f } " . format ( round ( area , 2 ) ) ) NEW_LINE DEDENT
def findRadius ( r1 , r2 , r3 ) : NEW_LINE INDENT r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) NEW_LINE return r4 NEW_LINE DEDENT
def findSides ( A , C , c ) : NEW_LINE INDENT B = 180 - ( A + C ) NEW_LINE A = A * ( 3.14159 / 180 ) NEW_LINE C = C * ( 3.14159 / 180 ) NEW_LINE B = B * ( 3.14159 / 180 ) NEW_LINE a = ( c / math . sin ( C ) ) * math . sin ( A ) NEW_LINE b = ( c / math . sin ( C ) ) * math . sin ( B ) NEW_LINE print ( " { 0 : . 2f } " . format ( a ) ) NEW_LINE print ( " { 0 : . 2f } " . format ( b ) ) NEW_LINE DEDENT
def minimumRectangleArea ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE A . sort ( ) NEW_LINE ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT ans = min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def closestsAngle ( N , A ) : NEW_LINE INDENT mi = sys . maxsize NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT angle = 180.0 * i / N NEW_LINE if ( math . fabs ( angle - A ) < math . fabs ( mi - A ) ) : NEW_LINE INDENT mi = angle NEW_LINE i += 1 NEW_LINE ans = i NEW_LINE DEDENT DEDENT print ( 2 , 1 , 2 + ans ) NEW_LINE DEDENT
def areaOftriangle ( side ) : NEW_LINE INDENT a = sqrt ( pow ( side / 2 , 2 ) + pow ( side / 2 , 2 ) ) NEW_LINE b = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) NEW_LINE c = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) NEW_LINE s = ( a + b + c ) / 2 NEW_LINE area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE return round ( area , 1 ) NEW_LINE DEDENT
def lengthOfLatusRectum ( A , B ) : NEW_LINE INDENT major = 2.0 * A NEW_LINE minor = 2.0 * B NEW_LINE latus_rectum = ( minor * minor ) / major NEW_LINE return latus_rectum NEW_LINE DEDENT
def check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT value_1 = a * x1 + b * y1 + c * z1 + d NEW_LINE value_2 = a * x2 + b * y2 + c * z2 + d NEW_LINE if ( ( value_1 > 0 and value_2 > 0 ) or ( value_1 < 0 and value_2 < 0 ) ) : NEW_LINE INDENT print ( " On ▁ same ▁ side " ) NEW_LINE DEDENT if ( ( value_1 > 0 and value_2 < 0 ) or ( value_1 < 0 and value_2 > 0 ) ) : NEW_LINE INDENT print ( " On ▁ different ▁ sides " ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 == 0 ) : NEW_LINE INDENT print ( " Both ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 != 0 ) : NEW_LINE INDENT print ( " Point ▁ 1 ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT if ( value_1 != 0 and value_2 == 0 ) : NEW_LINE INDENT print ( " Point ▁ 2 ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT DEDENT
def findLine ( distance , degree ) : NEW_LINE INDENT x = degree * 3.14159 / 180 NEW_LINE if ( degree > 90 ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT result_1 = math . sin ( x ) NEW_LINE result_2 = math . cos ( x ) NEW_LINE print ( ' % .2f ' % result_2 , " x ▁ + " , ' % .2f ' % result_1 , " y ▁ = ▁ " , distance , sep = " " ) NEW_LINE DEDENT
def AreaFactor ( n ) : NEW_LINE INDENT pi = 3.14159265 NEW_LINE areaf = 1 / ( math . cos ( pi / n ) * math . cos ( pi / n ) ) NEW_LINE print ( ' % .6f ' % areaf ) NEW_LINE DEDENT
def eccHyperbola ( A , B ) : NEW_LINE INDENT r = B * B / A * A NEW_LINE r += 1 NEW_LINE return math . sqrt ( r ) NEW_LINE DEDENT
def findAngle ( M1 , M2 ) : NEW_LINE INDENT PI = 3.14159265 NEW_LINE angle = abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) NEW_LINE ret = atan ( angle ) NEW_LINE val = ( ret * 180 ) / PI NEW_LINE print ( round ( val , 4 ) ) NEW_LINE DEDENT
def calculateArea ( A , B , C , D ) : NEW_LINE INDENT S = ( A + B + C + D ) // 2 NEW_LINE area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) NEW_LINE return area NEW_LINE DEDENT
def angle ( R1 , R2 , D ) : NEW_LINE INDENT ans = ( ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ) NEW_LINE return ans NEW_LINE DEDENT
def triangleArea ( a , b ) : NEW_LINE INDENT ratio = b / a NEW_LINE print ( ratio ) NEW_LINE DEDENT
def minimumTriangleArea ( a , b ) : NEW_LINE INDENT area = a * b NEW_LINE print ( area ) NEW_LINE DEDENT
def findAngles ( a , b , c , d ) : NEW_LINE INDENT numerator = a * a + d * d - b * b - c * c NEW_LINE denominator = 2 * ( a * b + c * d ) NEW_LINE x = numerator / denominator NEW_LINE print ( " A : ▁ " , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , " ▁ degrees " ) NEW_LINE numerator = a * a + b * b - c * c - d * d NEW_LINE x = numerator / denominator NEW_LINE print ( " B : ▁ " , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , " ▁ degrees " ) NEW_LINE numerator = c * c + b * b - a * a - d * d NEW_LINE x = numerator / denominator NEW_LINE print ( " C : ▁ " , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , " ▁ degrees " ) NEW_LINE numerator = d * d + c * c - a * a - b * b NEW_LINE x = numerator / denominator NEW_LINE print ( " D : ▁ " , ' % .2f ' % ( ( math . acos ( x ) * 180 ) / 3.141592 ) , " ▁ degrees " ) NEW_LINE DEDENT
def countInscribed ( R1 , R2 ) : NEW_LINE INDENT if ( R2 > R1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT angle = 0 NEW_LINE ratio = 0 NEW_LINE number_of_circles = 0 NEW_LINE ratio = R2 / ( R1 - R2 ) NEW_LINE if ( R1 < 2 * R2 ) : NEW_LINE INDENT number_of_circles = 1 NEW_LINE DEDENT else : NEW_LINE INDENT angle = ( abs ( math . asin ( ratio ) * 180 ) / 3.14159265 ) NEW_LINE number_of_circles = ( 360 / ( 2 * math . floor ( angle ) ) ) NEW_LINE DEDENT return number_of_circles NEW_LINE DEDENT
def findPairs ( x , y , K ) : NEW_LINE INDENT n = len ( x ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( K * abs ( x [ i ] - x [ j ] ) >= abs ( y [ i ] - y [ j ] ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def lengthOfLatusRectum ( A , B ) : NEW_LINE INDENT major = 2.0 * A NEW_LINE minor = 2.0 * B NEW_LINE latus_rectum = ( minor * minor ) / major NEW_LINE return latus_rectum NEW_LINE DEDENT
def totalCircles ( L , B ) : NEW_LINE INDENT if ( L > B ) : NEW_LINE INDENT temp = L NEW_LINE L = B NEW_LINE B = temp NEW_LINE DEDENT return B // L NEW_LINE DEDENT
def secondary_polygon ( Angle ) : NEW_LINE INDENT edges_primary = 360 // Angle NEW_LINE if edges_primary >= 6 : NEW_LINE INDENT edges_max_secondary = edges_primary // 2 NEW_LINE return edges_max_secondary + 3 NEW_LINE DEDENT else : NEW_LINE INDENT return " Not ▁ Possible " NEW_LINE DEDENT DEDENT
def findSquareSum ( Coordinates , N ) : NEW_LINE INDENT xq , yq = 0 , 0 NEW_LINE xs , ys = 0 , 0 NEW_LINE res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = Coordinates [ i ] [ 0 ] NEW_LINE b = Coordinates [ i ] [ 1 ] NEW_LINE res += xq NEW_LINE res -= 2 * xs * a NEW_LINE res += i * ( a * a ) NEW_LINE xq += a * a NEW_LINE xs += a NEW_LINE res += yq NEW_LINE res -= 2 * ys * b NEW_LINE res += i * b * b NEW_LINE yq += b * b NEW_LINE ys += b NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def findDiagonal ( s ) : NEW_LINE INDENT return math . sqrt ( 2 ) * s NEW_LINE DEDENT
def triangleArea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT area = ( 3 * sqrt ( 3 ) * a * b ) / ( 4 ) ; NEW_LINE print ( " { : . 5f } " . format ( area ) ) NEW_LINE DEDENT
def parallel ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def findRadius ( r1 , r2 ) : NEW_LINE INDENT a1 , a2 , a3 , r3 = 0 , 0 , 0 , 0 ; NEW_LINE a1 = 3.14 * r1 * r1 ; NEW_LINE a2 = 3.14 * r2 * r2 ; NEW_LINE a3 = a1 + a2 ; NEW_LINE r3 = ( ( a3 / 3.14 ) ** ( 1 / 2 ) ) ; NEW_LINE return r3 ; NEW_LINE DEDENT
def cntRect ( points , N , rectangle ) : NEW_LINE INDENT cntHor = set ( [ ] ) NEW_LINE cntVer = set ( [ ] ) NEW_LINE cntHor . add ( 0 ) NEW_LINE cntVer . add ( 0 ) NEW_LINE cntHor . add ( rectangle [ 3 ] [ 0 ] ) NEW_LINE cntVer . add ( rectangle [ 3 ] [ 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cntHor . add ( points [ i ] [ 0 ] ) NEW_LINE cntVer . add ( points [ i ] [ 1 ] ) NEW_LINE DEDENT return ( ( len ( cntHor ) - 1 ) * ( len ( cntVer ) - 1 ) ) NEW_LINE DEDENT
def noOfTriangles ( n ) : NEW_LINE INDENT return n * ( n + 2 ) * ( 2 * n + 1 ) // 8 NEW_LINE DEDENT
def No_of_squares ( N , K ) : NEW_LINE INDENT no_of_squares = 0 ; NEW_LINE no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; NEW_LINE return no_of_squares ; NEW_LINE DEDENT
def No_of_cubes ( N , K ) : NEW_LINE INDENT No = 0 NEW_LINE No = ( N - K + 1 ) NEW_LINE No = pow ( No , 3 ) NEW_LINE return No NEW_LINE DEDENT
def No_of_rectangles ( L , B , l , b ) : NEW_LINE INDENT if ( l > L ) or ( b > B ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( L - l + 1 ) * ( B - b + 1 ) ; NEW_LINE DEDENT DEDENT
def checkTriangle ( x , y , z ) : NEW_LINE INDENT if x == y == z : NEW_LINE INDENT print ( " Equilateral ▁ Triangle " ) NEW_LINE DEDENT elif x == y or y == z or z == x : NEW_LINE INDENT print ( " Isosceles ▁ Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Scalene ▁ Triangle " ) NEW_LINE DEDENT DEDENT
def Circumradius ( a , b , c , d ) : NEW_LINE INDENT s = ( a + b + c + d ) / 2 NEW_LINE radius = ( 1 / 4 ) * math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) NEW_LINE return radius NEW_LINE DEDENT
def Area_of_Rhombus ( a , theta ) : NEW_LINE INDENT area = ( a ** 2 ) * math . sin ( math . radians ( theta ) ) NEW_LINE return area NEW_LINE DEDENT
def calculateTriangles ( sides ) : NEW_LINE INDENT count = pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) NEW_LINE count -= pow ( sides [ 0 ] , 2 ) NEW_LINE count -= pow ( sides [ 2 ] , 2 ) NEW_LINE count -= pow ( sides [ 4 ] , 2 ) NEW_LINE return int ( count ) NEW_LINE DEDENT
def Length_Diagonal ( a , b , theta ) : NEW_LINE INDENT diagonal = math . sqrt ( ( ( a ** 2 ) + ( b ** 2 ) ) - 2 * a * b * math . cos ( math . radians ( theta ) ) ) NEW_LINE return diagonal NEW_LINE DEDENT
def maximumTiles ( n , m ) : NEW_LINE INDENT print ( int ( ( m * n ) / 2 ) ) ; NEW_LINE DEDENT
def Length_Diagonal ( a , b , d ) : NEW_LINE INDENT diagonal = math . sqrt ( 2 * ( ( a ** 2 ) + ( b ** 2 ) ) - ( d ** 2 ) ) NEW_LINE return diagonal NEW_LINE DEDENT
def Diagonals ( a , b , c , d ) : NEW_LINE INDENT p = math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) NEW_LINE q = math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT
def det ( d ) : NEW_LINE INDENT Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) NEW_LINE Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) NEW_LINE Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) NEW_LINE return Sum NEW_LINE DEDENT
def distance ( r , R ) : NEW_LINE INDENT d = math . sqrt ( ( R ** 2 ) - ( 2 * r * R ) ) NEW_LINE return d NEW_LINE DEDENT
def areaOfSquare ( S ) : NEW_LINE INDENT area = S * S NEW_LINE return area NEW_LINE DEDENT
def checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) : NEW_LINE INDENT A = ( int ( pow ( ( X2 - X1 ) , 2 ) ) + int ( pow ( ( Y2 - Y1 ) , 2 ) ) ) NEW_LINE B = ( int ( pow ( ( X3 - X2 ) , 2 ) ) + int ( pow ( ( Y3 - Y2 ) , 2 ) ) ) NEW_LINE C = ( int ( pow ( ( X3 - X1 ) , 2 ) ) + int ( pow ( ( Y3 - Y1 ) , 2 ) ) ) NEW_LINE if ( ( A > 0 and B > 0 and C > 0 ) and ( A == ( B + C ) or B == ( A + C ) or C == ( A + B ) ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def checkValidPolygon ( arr , N ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT if Sum == 180 * ( N - 2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def minAnglRot ( N ) : NEW_LINE INDENT res = 360 // N NEW_LINE return res NEW_LINE DEDENT
def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) // 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT
def Area_of_Triangle ( a , b , c ) : NEW_LINE INDENT s = ( a + b + c ) // 2 NEW_LINE x = s * ( s - a ) NEW_LINE x = x * ( s - b ) NEW_LINE x = x * ( s - c ) NEW_LINE area = ( 4 / 3 ) * math . sqrt ( x ) NEW_LINE return area NEW_LINE DEDENT
def Area_of_Triangle ( a , b , k ) : NEW_LINE INDENT area = ( 1 / 2 ) * a * b * math . sin ( k ) NEW_LINE return area NEW_LINE DEDENT
def findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , d , e , f ) : NEW_LINE INDENT a = x2 - x1 NEW_LINE b = y2 - y1 NEW_LINE c = z2 - z1 NEW_LINE A = ( b * f - c * e ) NEW_LINE B = ( a * f - c * d ) NEW_LINE C = ( a * e - b * d ) NEW_LINE D = - ( A * d - B * e + C * f ) NEW_LINE print ( A , " x ▁ + ▁ " , B , " y ▁ + ▁ " , C , " z ▁ + ▁ " , D , " = ▁ 0" ) NEW_LINE DEDENT
def count_rectangles ( N , M ) : NEW_LINE INDENT p_x = ( N * ( N - 1 ) ) // 2 NEW_LINE p_y = ( M * ( M - 1 ) ) // 2 NEW_LINE return p_x * p_y NEW_LINE DEDENT
def median ( a , b , c ) : NEW_LINE INDENT n = ( 1 / 2 ) * math . sqrt ( 2 * ( b ** 2 ) + 2 * ( c ** 2 ) - a ** 2 ) NEW_LINE return n NEW_LINE DEDENT
def findSide ( a , B , C ) : NEW_LINE INDENT A = 180 - C - B NEW_LINE radA = math . pi * ( A / 180 ) NEW_LINE radB = math . pi * ( B / 180 ) NEW_LINE radC = math . pi * ( C / 180 ) NEW_LINE b = a / math . sin ( radA ) * math . sin ( radB ) NEW_LINE c = a / math . sin ( radA ) * math . sin ( radC ) NEW_LINE return b , c NEW_LINE DEDENT
def areaSquare ( L , B ) : NEW_LINE INDENT large = max ( L , B ) NEW_LINE small = min ( L , B ) NEW_LINE if ( large >= 2 * small ) : NEW_LINE INDENT return large * large NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * small ) * ( 2 * small ) NEW_LINE DEDENT DEDENT
def calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT ABx = x1 - x2 ; NEW_LINE ABy = y1 - y2 ; NEW_LINE ABz = z1 - z2 ; NEW_LINE BCx = x3 - x2 ; NEW_LINE BCy = y3 - y2 ; NEW_LINE BCz = z3 - z2 ; NEW_LINE dotProduct = ( ABx * BCx + ABy * BCy + ABz * BCz ) ; NEW_LINE magnitudeAB = ( ABx * ABx + ABy * ABy + ABz * ABz ) ; NEW_LINE magnitudeBC = ( BCx * BCx + BCy * BCy + BCz * BCz ) ; NEW_LINE angle = dotProduct ; NEW_LINE angle /= math . sqrt ( magnitudeAB * magnitudeBC ) ; NEW_LINE angle = ( angle * 180 ) / 3.14 ; NEW_LINE print ( round ( abs ( angle ) , 4 ) ) NEW_LINE DEDENT
def triacontagonalNum ( n ) : NEW_LINE INDENT return ( 28 * n * n - 26 * n ) // 2 NEW_LINE DEDENT
def heptacontagonNum ( n ) : NEW_LINE INDENT return ( 68 * n * n - 66 * n ) // 2 ; NEW_LINE DEDENT
def hexacontagonNum ( n ) : NEW_LINE INDENT return ( 58 * n * n - 56 * n ) // 2 NEW_LINE DEDENT
def isicositetragonal ( N ) : NEW_LINE INDENT n = ( 10 + math . sqrt ( 44 * N + 100 ) ) / 22 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT i = 24 NEW_LINE if ( isicositetragonal ( i ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def enneacontagonNum ( n ) : NEW_LINE INDENT return ( 88 * n * n - 86 * n ) // 2 NEW_LINE DEDENT
def triacontakaidigonNum ( n ) : NEW_LINE INDENT return ( 30 * n * n - 28 * n ) // 2 NEW_LINE DEDENT
def isTridecagon ( N ) : NEW_LINE INDENT n = ( 9 + math . sqrt ( 88 * N + 81 ) ) / 22 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT i = 13 NEW_LINE if ( isTridecagon ( i ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isicosihenagonal ( N ) : NEW_LINE INDENT n = ( 17 + math . sqrt ( 152 * N + 289 ) ) / 38 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT i = 21 NEW_LINE if isicosihenagonal ( i ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isicositrigonal ( N ) : NEW_LINE INDENT n = ( 19 + math . sqrt ( 168 * N + 361 ) ) / 42 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT i = 23 NEW_LINE if ( isicositrigonal ( i ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def IcosihexagonalNum ( n ) : NEW_LINE INDENT return ( 24 * n * n - 22 * n ) // 2 NEW_LINE DEDENT
def icosikaioctagonalNum ( n ) : NEW_LINE INDENT return ( 26 * n * n - 24 * n ) // 2 NEW_LINE DEDENT
def octacontagonNum ( n ) : NEW_LINE INDENT return ( 78 * n * n - 76 * n ) // 2 NEW_LINE DEDENT
def hectagonNum ( n ) : NEW_LINE INDENT return ( 98 * n * n - 96 * n ) // 2 NEW_LINE DEDENT
def tetracontagonNum ( n ) : NEW_LINE INDENT return ( 38 * n * n - 36 * n ) // 2 NEW_LINE DEDENT
def Tridecagonal_num ( n ) : NEW_LINE INDENT return ( 11 * n * n - 9 * n ) / 2 NEW_LINE DEDENT
def Pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 13 * n * n - 11 * n ) / 2 NEW_LINE DEDENT
def Octadecagonal_num ( n ) : NEW_LINE INDENT return ( 16 * n * n - 14 * n ) / 2 NEW_LINE DEDENT
def IcositrigonalNum ( n ) : NEW_LINE INDENT return ( 21 * n * n - 19 * n ) / 2 ; NEW_LINE DEDENT
def Icositetragonal_num ( n ) : NEW_LINE INDENT return ( 22 * n * n - 20 * n ) / 2 NEW_LINE DEDENT
def Icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 17 * n ) / 2 NEW_LINE DEDENT
def checkTriangle ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT a = ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) NEW_LINE if a == 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT DEDENT
def checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) : NEW_LINE INDENT Xn = max ( X1 , min ( Xc , X2 ) ) NEW_LINE Yn = max ( Y1 , min ( Yc , Y2 ) ) NEW_LINE Dx = Xn - Xc NEW_LINE Dy = Yn - Yc NEW_LINE return ( Dx ** 2 + Dy ** 2 ) <= R ** 2 NEW_LINE DEDENT if ( __name__ == " _ _ main _ _ " ) : NEW_LINE INDENT R = 1 NEW_LINE Xc , Yc = 0 , 0 NEW_LINE X1 , Y1 = 1 , - 1 NEW_LINE X2 , Y2 = 3 , 1 NEW_LINE print ( checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) ) NEW_LINE DEDENT
def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) / 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def solve ( s ) : NEW_LINE INDENT area = ( 1.732 * s ** 2 ) / 8 NEW_LINE return area NEW_LINE DEDENT
def area ( R ) : NEW_LINE INDENT base = 1.732 * R NEW_LINE height = ( 3 / 2 ) * R NEW_LINE area = ( ( 1 / 2 ) * base * height ) NEW_LINE return area NEW_LINE DEDENT
def circlearea ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = ( 3.14 * R * R ) / 4 ; NEW_LINE return a ; NEW_LINE DEDENT
def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) ; NEW_LINE area = 3.14 * R * R / 2.0 ; NEW_LINE return area ; NEW_LINE DEDENT
def times ( steps , n ) : NEW_LINE INDENT current_level = 0 NEW_LINE previous_level = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT previous_level = current_level NEW_LINE current_level = current_level + steps [ i ] NEW_LINE if ( ( previous_level < 0 and current_level >= 0 ) or ( previous_level > 0 and current_level <= 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( P , Q , N , M ) : NEW_LINE INDENT A = [ 0 ] * 2 NEW_LINE B = [ 0 ] * 2 NEW_LINE for i in range ( N ) : NEW_LINE INDENT A [ P [ i ] % 2 ] += 1 NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT B [ Q [ i ] % 2 ] += 1 NEW_LINE DEDENT return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) NEW_LINE DEDENT
def find_angle ( x , y , z ) : NEW_LINE INDENT volume = x * x * y ; NEW_LINE ans = 0 ; NEW_LINE if ( z < volume // 2 ) : NEW_LINE INDENT d = ( x * y * y ) / ( 2.0 * z ) ; NEW_LINE ans = atan ( d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT z = volume - z ; NEW_LINE d = ( 2 * z ) / ( float ) ( x * x * x ) ; NEW_LINE ans = atan ( d ) ; NEW_LINE DEDENT ans = ( ans * 180 ) / 3.14159265 ; NEW_LINE return round ( ans , 4 ) ; NEW_LINE DEDENT
def findsolution ( d , h , m , n ) : NEW_LINE INDENT k = ( 4 * m ) / ( pie * d * d ) NEW_LINE if ( n > k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = ( h / ( k - n ) ) NEW_LINE return round ( ans , 5 ) NEW_LINE DEDENT
def sumOfInternalAngles ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( n - 2 ) * 180 ) NEW_LINE DEDENT
def cntWays ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n - 2 ) // 4 NEW_LINE DEDENT DEDENT
def noOfTriangles ( n ) : NEW_LINE INDENT y = 4 * n NEW_LINE return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) // 6 NEW_LINE DEDENT
def angle ( n ) : NEW_LINE INDENT return 2 * n NEW_LINE DEDENT
def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT
def orthogonality ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; NEW_LINE if ( dsquare == r1 * r1 + r2 * r2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT x1 , y1 = 4 , 3 NEW_LINE x2 , y2 = 0 , 1 NEW_LINE r1 , r2 = 2 , 4 NEW_LINE f = orthogonality ( x1 , y1 , x2 , y2 , r1 , r2 ) NEW_LINE if ( f ) : NEW_LINE INDENT print ( " Given ▁ circles ▁ are ▁ orthogonal . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Given ▁ circles ▁ are ▁ not ▁ orthogonal . " ) NEW_LINE DEDENT
def area ( d1 , a ) : NEW_LINE INDENT d2 = ( 4 * ( a ** 2 ) - d1 ** 2 ) ** 0.5 NEW_LINE area = 0.5 * d1 * d2 NEW_LINE return ( area ) NEW_LINE DEDENT
def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) // 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT
def pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT fx1 = a * x1 + b * y1 - c NEW_LINE fx2 = a * x2 + b * y2 - c NEW_LINE if ( ( fx1 * fx2 ) > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a , b , c = 1 , 1 , 1 NEW_LINE x1 , y1 = 1 , 1 NEW_LINE x2 , y2 = 2 , 1 NEW_LINE if ( pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def Area ( d , h1 , h2 ) : NEW_LINE INDENT area = 0.5 * d * ( h1 + h2 ) ; NEW_LINE return area ; NEW_LINE DEDENT
def diagonal_length ( a ) : NEW_LINE INDENT L = 0 NEW_LINE L = a * sqrt ( 3 ) NEW_LINE return L NEW_LINE DEDENT
def concentric_Hexagon ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) // 2 NEW_LINE DEDENT
def find_area ( r , d ) : NEW_LINE INDENT R = d / PI NEW_LINE R += pow ( r , 2 ) NEW_LINE R = sqrt ( R ) NEW_LINE area = PI * pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT
def Valid ( a , b , c , d ) : NEW_LINE INDENT if ( a + b + c + d == 360 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT a = 80 ; b = 70 ; c = 100 ; d = 110 ; NEW_LINE if ( Valid ( a , b , c , d ) ) : NEW_LINE INDENT print ( " Valid ▁ quadrilateral " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid ▁ quadrilateral " ) ; NEW_LINE DEDENT
def Valid ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c == 180 ) and a != 0 and b != 0 and c != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def Perimeter ( a , b ) : NEW_LINE INDENT perimeter = 0 NEW_LINE perimeter = ( 2 * 3.14 * sqrt ( ( a * a + b * b ) / ( 2 * 1.0 ) ) ) ; NEW_LINE print ( perimeter ) NEW_LINE DEDENT
def calculate_angle ( n ) : NEW_LINE INDENT total_angle = 360 ; NEW_LINE return ( total_angle // n ) NEW_LINE DEDENT
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 ; NEW_LINE return area ; NEW_LINE DEDENT
def areaOfKite ( a , b , angle ) : NEW_LINE INDENT angle = angle * PI ; NEW_LINE area = a * b * math . sin ( angle ) ; NEW_LINE return area ; NEW_LINE DEDENT
def angleOncirCumference ( z ) : NEW_LINE INDENT return ( z / 2 ) ; NEW_LINE DEDENT
def newvol ( x ) : NEW_LINE INDENT print ( " percentage ▁ increase " " in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ " , ( ( x ** ( 3 ) ) / 10000 + 3 * x + ( 3 * ( x ** ( 2 ) ) ) / 100 ) , " % " ) ; NEW_LINE DEDENT
def newvol ( x ) : NEW_LINE INDENT print ( " percentage ▁ increase ▁ in ▁ the " , pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 , " % " ) DEDENT
def newvol ( x ) : NEW_LINE INDENT print ( " percentage ▁ increase ▁ in ▁ the ▁ volume ▁ of ▁ the ▁ cylinder ▁ is ▁ " , x , " % " ) NEW_LINE DEDENT
def radius ( n , d ) : NEW_LINE INDENT print ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " , d / ( ( n - 1 ) * ( 2 ** ( 1 / 2 ) ) ) ) ; NEW_LINE DEDENT
def findTriangles ( n ) : NEW_LINE INDENT num = n NEW_LINE print ( num , end = " ▁ " ) NEW_LINE print ( num * ( num - 4 ) * ( num - 5 ) // 6 ) NEW_LINE DEDENT
def radius ( n , d ) : NEW_LINE INDENT print ( " The ▁ radius ▁ of ▁ each ▁ circle ▁ is ▁ " , d / ( 2 * n - 2 ) ) ; NEW_LINE DEDENT
def radius ( n , d ) : NEW_LINE INDENT print ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " , d / ( n - 1 ) ) ; NEW_LINE DEDENT
def findTriangles ( n ) : NEW_LINE INDENT num = n * ( n - 4 ) NEW_LINE print ( num ) NEW_LINE DEDENT
def innerCirclearea ( radius ) : NEW_LINE INDENT if ( radius < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = radius / 2 ; NEW_LINE Area = ( 3.14 * pow ( r , 2 ) ) ; NEW_LINE return Area ; NEW_LINE DEDENT
def angleequichord ( z ) : NEW_LINE INDENT print ( " The ▁ angle ▁ subtended ▁ at " , " the ▁ center ▁ is " , z , " degrees " ) ; NEW_LINE DEDENT
def lengequichord ( z ) : NEW_LINE INDENT print ( " The ▁ distance ▁ between ▁ the " , " chord ▁ and ▁ the ▁ center ▁ is " , z ) NEW_LINE DEDENT
def lengperpbisect ( r1 , r2 ) : NEW_LINE INDENT z = 2 * ( ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ** ( 1 / 2 ) ) ; NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ perpendicular ▁ bisector ▁ is ▁ " , z ) ; NEW_LINE DEDENT
def anglequichord ( z ) : NEW_LINE INDENT print ( " The ▁ angle ▁ is ▁ " , z , " ▁ degrees " ) NEW_LINE DEDENT
def lengchord ( z ) : NEW_LINE INDENT print ( " The ▁ length ▁ is ▁ " , end = " " ) ; NEW_LINE print ( z ) ; NEW_LINE DEDENT
def angleextcycquad ( z ) : NEW_LINE INDENT print ( " The ▁ exterior ▁ angle ▁ of ▁ the " , end = " " ) ; NEW_LINE print ( " cyclic ▁ quadrilateral ▁ is ▁ " , end = " " ) ; NEW_LINE print ( z , " ▁ degrees " ) ; NEW_LINE DEDENT
def anglechordtang ( z ) : NEW_LINE INDENT print ( " The ▁ angle ▁ between ▁ tangent " , " and ▁ the ▁ chord ▁ is " , z , " degrees " ) ; NEW_LINE DEDENT
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT x1 , y1 = - 10 , 8 ; NEW_LINE x2 , y2 = 14 , - 24 ; NEW_LINE r1 , r2 = 30 , 10 ; NEW_LINE t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; NEW_LINE if ( t == 1 ) : NEW_LINE INDENT print ( " There ▁ are ▁ 3 ▁ common ▁ tangents ▁ between ▁ the ▁ circles . " ) NEW_LINE DEDENT elif ( t < 0 ) : NEW_LINE INDENT print ( " There ▁ are ▁ 4 ▁ common ▁ tangents ▁ between ▁ the ▁ circles . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ 2 ▁ common ▁ tangents ▁ between ▁ the ▁ circles . " ) NEW_LINE DEDENT
def Regions ( Vertices , Edges ) : NEW_LINE INDENT R = Edges + 2 - Vertices ; NEW_LINE return R ; NEW_LINE DEDENT
def lengthOfTangent ( r1 , r2 , d ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ transverse " , " common ▁ tangent ▁ is " , ' { 0 : . 6g } ' . format ( sqrt ( pow ( d , 2 ) - pow ( ( r1 + r2 ) , 2 ) ) ) ) NEW_LINE DEDENT
def remainingArea ( N , M , K ) : NEW_LINE INDENT while ( K > 0 and N > 0 and M > 0 ) : NEW_LINE INDENT if ( N > M ) : NEW_LINE INDENT N = N - M ; NEW_LINE DEDENT else : NEW_LINE INDENT M = M - N ; NEW_LINE DEDENT K = K - 1 ; NEW_LINE DEDENT if ( N > 0 and M > 0 ) : NEW_LINE INDENT return N * M ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT
def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is ▁ " , ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT
def rad ( d , h ) : NEW_LINE INDENT print ( " The ▁ radius ▁ of ▁ the ▁ circle ▁ is " , ( ( d * d ) / ( 8 * h ) + h / 2 ) ) NEW_LINE DEDENT
def shortdis ( r , d ) : NEW_LINE INDENT print ( " The ▁ shortest ▁ distance ▁ " , end = " " ) ; NEW_LINE print ( " from ▁ the ▁ chord ▁ to ▁ centre ▁ " , end = " " ) ; NEW_LINE print ( ( ( r * r ) - ( ( d * d ) / 4 ) ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT
def lengtang ( r1 , r2 ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ direct " , " common ▁ tangent ▁ is " , 2 * ( r1 * r2 ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT
def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( " The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " , ( ( ( ( x2 - x1 ) ** 2 ) + ( ( y2 - y1 ) ** 2 ) ) ** ( 1 / 2 ) ) - r ) ; NEW_LINE DEDENT
def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is " , ( ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 / 2 ) ) ) ; NEW_LINE DEDENT
def length_of_chord ( r , x ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ chord " , " ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * r * mt . sin ( x * ( 3.14 / 180 ) ) ) NEW_LINE DEDENT
def diameter ( r ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " , " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * r ) NEW_LINE DEDENT
def normal ( m , n ) : NEW_LINE INDENT N = ( ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ) ; NEW_LINE return N ; NEW_LINE DEDENT
def getSlope ( m ) : NEW_LINE INDENT return m ; NEW_LINE DEDENT
def totalTriangles ( h , v ) : NEW_LINE INDENT if ( h == 0 and v == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( h == 0 ) : NEW_LINE INDENT return ( ( v + 1 ) * ( v + 2 ) / 2 ) NEW_LINE DEDENT if ( v == 0 ) : NEW_LINE INDENT return ( h + 1 ) NEW_LINE DEDENT total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) NEW_LINE return total NEW_LINE DEDENT
def ellipse ( l , b ) : NEW_LINE INDENT if l < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 3.14 * l * b ) / 4 NEW_LINE return x NEW_LINE DEDENT
def isPossible ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxS = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE maxS = max ( a [ i ] , maxS ) NEW_LINE DEDENT if ( ( sum - maxS ) > maxS ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findAreaShaded ( a ) : NEW_LINE INDENT sqArea = a * a ; NEW_LINE semiCircleArea = ( 3.14 * ( a * a ) / 8 ) NEW_LINE ShadedArea = 4 * semiCircleArea - sqArea ; NEW_LINE return ShadedArea ; NEW_LINE DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return x + y + 2 * ( ( y - x ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x + y + 2 * ( ( ( x - y ) + 1 ) // 2 ) NEW_LINE DEDENT DEDENT
def pointIsOnLine ( m , c , x , y ) : NEW_LINE INDENT if ( y == ( ( m * x ) + c ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT m = 3 ; c = 2 ; NEW_LINE x = 1 ; y = 5 ; NEW_LINE if ( pointIsOnLine ( m , c , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def sph ( r , R , h ) : NEW_LINE INDENT if ( r < 0 and R < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = r NEW_LINE V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 NEW_LINE return V NEW_LINE DEDENT
def Area ( a , b ) : NEW_LINE INDENT if ( a < 0 and b < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT h = math . sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) ; NEW_LINE A = 0.70477 * pow ( h , 2 ) ; NEW_LINE return A ; NEW_LINE DEDENT
def cone ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = ( a * math . sqrt ( 2 ) ) / 3 ; NEW_LINE h = ( 2 * a ) / 3 ; NEW_LINE V = 3.14 * math . pow ( r , 2 ) * h ; NEW_LINE return V ; NEW_LINE DEDENT
def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * math . pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT
def Area ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 2 * r ) / mt . sqrt ( 5 ) NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT
def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.464 * a NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT
def areaCircle ( b ) : NEW_LINE INDENT area = math . pi * b * b NEW_LINE return area NEW_LINE DEDENT
def areaSquare ( side , fold ) : NEW_LINE INDENT area = side * side NEW_LINE ans = area / pow ( 2 , fold ) NEW_LINE return ans NEW_LINE DEDENT
def square ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.464 * a NEW_LINE return x NEW_LINE DEDENT
def ReuleauxArea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = 0.70477 * 2 * pow ( r , 2 ) NEW_LINE return A NEW_LINE DEDENT
def cyl ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( 2 * a * mt . sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT
def Area ( l , b , h ) : NEW_LINE INDENT if ( l < 0 or b < 0 or h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( l * b ) / ( l + b ) NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT
def squareSide ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.423 * a NEW_LINE return x NEW_LINE DEDENT
def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y + z * z NEW_LINE a = round ( a , 8 ) NEW_LINE if ( ceil ( a ) == 1 & floor ( a ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def polyapothem ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE DEDENT
def polydiagonal ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( 2 * a * mt . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) NEW_LINE DEDENT
def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE DEDENT
def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE return A NEW_LINE DEDENT
def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return d NEW_LINE DEDENT
def heptdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.802 * a NEW_LINE return round ( d , 3 ) NEW_LINE DEDENT
def ReuleauxArea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = 0.70477 * pow ( a , 2 ) ; NEW_LINE return A NEW_LINE DEDENT
def hexagonside ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT x = 0.5176 * a ; NEW_LINE return x ; NEW_LINE DEDENT
def hexagonside ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = a // 3 NEW_LINE return x NEW_LINE DEDENT
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT d = 1.73 * a ; NEW_LINE return d ; NEW_LINE DEDENT
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT
def ReuleauxArea ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0.70477 * pow ( a , 2 ) NEW_LINE DEDENT
def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 / n NEW_LINE theta_in_radians = theta * 3.14 / 180 NEW_LINE return 2 * r * sin ( theta_in_radians / 2 ) NEW_LINE DEDENT
def squareArea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT area = ( 1.268 ** 2 ) * ( a ** 2 ) ; NEW_LINE return area ; NEW_LINE DEDENT
def trianglearea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT area = ( 3 * math . sqrt ( 3 ) * math . pow ( a , 2 ) ) / 4 ; NEW_LINE return area ; NEW_LINE DEDENT
def CubeVolume ( d ) : NEW_LINE INDENT Volume = ( sqrt ( 3 ) * pow ( d , 3 ) ) / 9 NEW_LINE return Volume NEW_LINE DEDENT
def hexagonArea ( d ) : NEW_LINE INDENT return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 NEW_LINE DEDENT
def cyl ( r , R , h ) : NEW_LINE INDENT if ( h < 0 and r < 0 and R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r1 = r NEW_LINE h1 = h NEW_LINE V = 3.14 * pow ( r1 , 2 ) * h1 NEW_LINE return round ( V , 2 ) NEW_LINE DEDENT
def findVolume ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / 2 NEW_LINE h = a NEW_LINE V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT
def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT
def area_cicumscribed ( c ) : NEW_LINE INDENT return ( c * c * ( PI / 4 ) ) NEW_LINE DEDENT
def cyl ( r , h ) : NEW_LINE INDENT if ( r < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = ( 2 * r ) / 3 NEW_LINE H = ( 2 * h ) / 3 NEW_LINE V = 3.14 * math . pow ( R , 2 ) * H NEW_LINE return V NEW_LINE DEDENT
def cube ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = math . pow ( h , 3 ) NEW_LINE return a NEW_LINE DEDENT
def sph ( r , h ) : NEW_LINE INDENT if ( r < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = r NEW_LINE return float ( R ) NEW_LINE DEDENT
def cyl ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT V = ( ( 2 * 3.14 * math . pow ( R , 3 ) ) / ( 3 * math . sqrt ( 3 ) ) ) ; NEW_LINE return float ( V ) NEW_LINE DEDENT
def rod ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT l = ( math . sqrt ( math . pow ( h , 2 ) + 4 * math . pow ( r , 2 ) ) ) NEW_LINE return float ( l ) NEW_LINE DEDENT
def cubeSide ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( ( h * r * math . sqrt ( 2 ) ) / ( h + math . sqrt ( 2 ) * r ) ) NEW_LINE return a NEW_LINE DEDENT
def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) / sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT
def sphere ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / 2 NEW_LINE return r NEW_LINE DEDENT
def numberOfCuts ( M , N ) : NEW_LINE INDENT result = 0 NEW_LINE result = ( M - 1 ) * ( N - 1 ) NEW_LINE return result NEW_LINE DEDENT
def maxVol ( P , A ) : NEW_LINE INDENT l = ( P - sqrt ( P * P - 24 * A ) ) / 12 NEW_LINE V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) NEW_LINE return V NEW_LINE DEDENT
def rhombusAreaPeri ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE perimeter = 2 * sqrt ( pow ( d1 , 2 ) + pow ( d2 , 2 ) ) NEW_LINE print ( " The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals " , d1 , " and " , d2 , " is " , area , " . " ) NEW_LINE print ( " The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals " , d1 , " and " , d2 , " is " , perimeter , " . " ) NEW_LINE DEDENT
def equation_ellipse ( x1 , y1 , a , b , c , e ) : NEW_LINE INDENT t = a * a + b * b NEW_LINE a1 = t - e * ( a * a ) NEW_LINE b1 = t - e * ( b * b ) NEW_LINE c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) NEW_LINE d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) NEW_LINE e1 = - 2 * e * a * b NEW_LINE f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) NEW_LINE print ( " Equation ▁ of ▁ ellipse ▁ is " , a1 , " x ^ 2 ▁ + " , b1 , " y ^ 2 ▁ + " , c1 , " x ▁ + " , d1 , " y ▁ + " , e1 , " xy ▁ + " , f1 , " = ▁ 0" ) NEW_LINE DEDENT
def maxArea ( perimeter ) : NEW_LINE INDENT length = int ( ceil ( perimeter / 4 ) ) NEW_LINE breadth = int ( floor ( perimeter / 4 ) ) NEW_LINE return length * breadth NEW_LINE DEDENT
def countMaxIntersect ( n ) : NEW_LINE INDENT return int ( n * ( n - 1 ) / 2 ) NEW_LINE DEDENT
def foot ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; NEW_LINE x2 = a * k + x1 ; NEW_LINE y2 = b * k + y1 ; NEW_LINE z2 = c * k + z1 ; NEW_LINE print ( " x2 ▁ = " , round ( x2 , 1 ) ) NEW_LINE print ( " y2 ▁ = " , round ( y2 , 1 ) ) NEW_LINE print ( " z2 ▁ = " , round ( z2 , 1 ) ) NEW_LINE DEDENT
def equation_parabola ( x1 , y1 , a , b , c ) : NEW_LINE INDENT t = a * a + b * b NEW_LINE a1 = t - ( a * a ) NEW_LINE b1 = t - ( b * b ) ; NEW_LINE c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) NEW_LINE d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) NEW_LINE e1 = - 2 * a * b NEW_LINE f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) NEW_LINE print ( " equation ▁ of ▁ parabola ▁ is " , a1 , " x ^ 2 ▁ + " , b1 , " y ^ 2 ▁ + " , c1 , " x ▁ + " , d1 , " y ▁ + ▁ " , e1 , " xy ▁ + " , f1 , " = ▁ 0 . " ) NEW_LINE DEDENT
def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 ; NEW_LINE b = - 2 * y1 ; NEW_LINE c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; NEW_LINE print ( " x ^ 2 ▁ + ▁ ( " , a , " x ) ▁ + ▁ " , end = " " ) ; NEW_LINE print ( " y ^ 2 ▁ + ▁ ( " , b , " y ) ▁ = ▁ " , end = " " ) ; NEW_LINE print ( c , " . " ) ; NEW_LINE DEDENT
def section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) : NEW_LINE INDENT x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) NEW_LINE y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) NEW_LINE z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) NEW_LINE print ( " ( " , x , " , " , y , " , " , z , " ) " ) NEW_LINE DEDENT
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) ) NEW_LINE DEDENT
def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT
def checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT resx = x1 + x2 + x3 NEW_LINE resy = y1 + y2 + y3 NEW_LINE resz = z1 + z2 + z3 NEW_LINE if ( resx == 0 and resy == 0 and resz == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT x1 = - 2 ; y1 = - 7 ; z1 = - 9 NEW_LINE x2 = 5 ; y2 = - 14 ; z2 = 14 NEW_LINE x3 = - 3 ; y3 = 21 ; z3 = - 5 NEW_LINE if ( checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ) : NEW_LINE INDENT print ( " The ▁ vectors ▁ are ▁ at ▁ equilibrium . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ vectors ▁ are ▁ not ▁ at ▁ equilibrium . " ) NEW_LINE DEDENT
def findTangent ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if y == ( 2 * x - x * x ) : NEW_LINE INDENT if dif < 0 : NEW_LINE INDENT print ( " y ▁ = " , dif , " x " , ( x * dif ) + ( y ) ) NEW_LINE DEDENT elif dif > 0 : NEW_LINE INDENT print ( " y ▁ = " , dif , " x + " , - x * dif + y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT DEDENT DEDENT
def hexadiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a NEW_LINE DEDENT
def octadiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return a * math . sqrt ( 4 + ( 2 * math . sqrt ( 2 ) ) ) NEW_LINE DEDENT
def CalPeri ( ) : NEW_LINE INDENT s = 5 NEW_LINE Perimeter = 10 * s NEW_LINE print ( " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ " , Perimeter ) NEW_LINE DEDENT
def octaside ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = a / ( sqrt ( 2 ) + 1 ) NEW_LINE return s NEW_LINE DEDENT
def findEdges ( s1 , s2 , s3 ) : NEW_LINE INDENT a = math . sqrt ( s1 * s2 / s3 ) NEW_LINE b = math . sqrt ( s3 * s1 / s2 ) NEW_LINE c = math . sqrt ( s3 * s2 / s1 ) NEW_LINE sum = a + b + c NEW_LINE return 4 * sum NEW_LINE DEDENT
def findRadiusOfcircumcircle ( n , a ) : NEW_LINE INDENT if n < 0 or a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) NEW_LINE return radius NEW_LINE DEDENT
def rhombusarea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( l * b ) / 2 NEW_LINE DEDENT
def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def area ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = a * b NEW_LINE return A NEW_LINE DEDENT
def circle_inscribed ( a ) : NEW_LINE INDENT return pi * ( a * a ) / 12 NEW_LINE DEDENT
def findRadiusOfcircumcircle ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT radius = ( math . sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ) ; NEW_LINE return radius ; NEW_LINE DEDENT
def surfaceArea ( b , s ) : NEW_LINE INDENT return 2 * b * s + pow ( b , 2 ) NEW_LINE DEDENT
def findRadiusOfIncircle ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT p = ( a + b + c ) / 2 NEW_LINE area = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) NEW_LINE radius = area / p NEW_LINE return radius NEW_LINE DEDENT
def trianglearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( l * b ) / 2 NEW_LINE return area NEW_LINE DEDENT
def area ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = sqrt ( a ) / 6 NEW_LINE return area NEW_LINE DEDENT
def halfsquare ( n , x , y ) : NEW_LINE INDENT half = n // 2 NEW_LINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def checkpoint ( h , k , x , y , a ) : NEW_LINE INDENT p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) NEW_LINE return p NEW_LINE DEDENT
def checkpoint ( h , k , x , y , a , b ) : NEW_LINE INDENT p = ( ( math . pow ( ( x - h ) , 2 ) // math . pow ( a , 2 ) ) + ( math . pow ( ( y - k ) , 2 ) // math . pow ( b , 2 ) ) ) NEW_LINE return p NEW_LINE DEDENT
def findVolume ( u , v , w , U , V , W , b ) : NEW_LINE INDENT uPow = pow ( u , 2 ) NEW_LINE vPow = pow ( v , 2 ) NEW_LINE wPow = pow ( w , 2 ) NEW_LINE UPow = pow ( U , 2 ) NEW_LINE VPow = pow ( V , 2 ) NEW_LINE WPow = pow ( W , 2 ) NEW_LINE a = ( 4 * ( uPow * vPow * wPow ) - uPow * pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ) NEW_LINE vol = sqrt ( a ) NEW_LINE vol /= b NEW_LINE print ( round ( vol , 4 ) ) NEW_LINE DEDENT
def trianglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / ( 4 * b ) NEW_LINE return area NEW_LINE DEDENT
def squarearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 4 * ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) NEW_LINE return area NEW_LINE DEDENT
def longestRodInCuboid ( length , breadth , height ) : NEW_LINE INDENT temp = length * length + breadth * breadth + height * height NEW_LINE result = sqrt ( temp ) NEW_LINE return result NEW_LINE DEDENT
def trianglearea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return r * r NEW_LINE DEDENT
def squarearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 4 * ( pow ( r , 2 ) / 5 ) NEW_LINE return a NEW_LINE DEDENT
def rectanglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT
def trapezoidarea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 3 * sqrt ( 3 ) * pow ( r , 2 ) ) / 4 NEW_LINE return a NEW_LINE DEDENT
def squareArea ( l , b , h ) : NEW_LINE INDENT if l < 0 or b < 0 or h < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( l * b ) / ( l + b ) NEW_LINE return a * a NEW_LINE DEDENT
def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) NEW_LINE return A NEW_LINE DEDENT
def circlearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l < b ) : NEW_LINE INDENT return 3.14 * pow ( l // 2 , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 3.14 * pow ( b // 2 , 2 ) NEW_LINE DEDENT DEDENT
def rectanglearea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = r * r NEW_LINE return a NEW_LINE DEDENT
def shortestLength ( n , x , y ) : NEW_LINE INDENT answer = 0 NEW_LINE i = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if ( x [ i ] + y [ i ] > answer ) : NEW_LINE INDENT answer = x [ i ] + y [ i ] NEW_LINE DEDENT i += 1 NEW_LINE n -= 1 NEW_LINE DEDENT print ( " Length ▁ - > ▁ " + str ( answer ) ) NEW_LINE print ( " Path ▁ - > ▁ " + " ( ▁ 1 , ▁ " + str ( answer ) + " ▁ ) " + " and ▁ ( ▁ " + str ( answer ) + " , ▁ 1 ▁ ) " ) NEW_LINE DEDENT
def maxLines ( n , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT s = [ ] ; NEW_LINE slope = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x1 [ i ] == x2 [ i ] ) : NEW_LINE INDENT slope = sys . maxsize ; NEW_LINE DEDENT else : NEW_LINE INDENT slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; NEW_LINE DEDENT s . append ( slope ) ; NEW_LINE DEDENT return len ( s ) ; NEW_LINE DEDENT
def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l / a ) * math . ceil ( b / a ) NEW_LINE DEDENT
def angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) : NEW_LINE INDENT num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) NEW_LINE den = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) * math . sqrt ( ( x3 - x1 ) ** 2 + ( y3 - y1 ) ** 2 + ( z3 - z1 ) ** 2 ) NEW_LINE angle = math . degrees ( math . acos ( num / den ) ) NEW_LINE return round ( angle , 3 ) NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT x = n // 2 NEW_LINE return ( ( x + 1 ) * ( n - x + 1 ) ) NEW_LINE DEDENT
def makePolygon ( a ) : NEW_LINE INDENT n = 360 / ( 180 - a ) NEW_LINE if n == int ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) : NEW_LINE INDENT a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE a = b1 * c2 - b2 * c1 NEW_LINE b = a2 * c1 - a1 * c2 NEW_LINE c = a1 * b2 - b1 * a2 NEW_LINE d = ( - a * x1 - b * y1 - c * z1 ) NEW_LINE if ( a * x + b * y + c * z + d == 0 ) : NEW_LINE INDENT print ( " Coplanar " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Coplanar " ) NEW_LINE DEDENT DEDENT
def solve ( M , N , s ) : NEW_LINE INDENT ans = ( ( math . ceil ( M / s ) ) * ( math . ceil ( N / s ) ) ) ; NEW_LINE return ans NEW_LINE DEDENT
def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if ( x5 > x6 or y5 > y6 ) : NEW_LINE INDENT print ( " No ▁ intersection " ) NEW_LINE return NEW_LINE DEDENT print ( " ( " , x5 , " , ▁ " , y5 , " ) ▁ " , end = " ▁ " ) NEW_LINE print ( " ( " , x6 , " , ▁ " , y6 , " ) ▁ " , end = " ▁ " ) NEW_LINE x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( " ( " , x7 , " , ▁ " , y7 , " ) ▁ " , end = " ▁ " ) NEW_LINE x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( " ( " , x8 , " , ▁ " , y8 , " ) ▁ " ) NEW_LINE DEDENT
def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if ( x > x1 and x < x2 and y > y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) : NEW_LINE INDENT if ( a1 / a2 == b1 / b2 and b1 / b2 == c1 / c2 ) : NEW_LINE INDENT x1 = y1 = 0 NEW_LINE z1 = - d1 / c1 NEW_LINE d = abs ( ( c2 * z1 + d2 ) ) / ( math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) NEW_LINE print ( " Perpendicular ▁ distance ▁ is " ) , d NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Planes ▁ are ▁ not ▁ parallel " ) NEW_LINE DEDENT DEDENT
def distance ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT d = ( a1 * a2 + b1 * b2 + c1 * c2 ) NEW_LINE e1 = math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) NEW_LINE e2 = math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) NEW_LINE d = d / ( e1 * e2 ) NEW_LINE A = math . degrees ( math . acos ( d ) ) NEW_LINE print ( " Angle ▁ is " ) , A , ( " degree " ) NEW_LINE DEDENT
def shortest_distance ( x1 , y1 , z1 , a , b , c , d ) : NEW_LINE INDENT d = abs ( ( a * x1 + b * y1 + c * z1 + d ) ) NEW_LINE e = ( math . sqrt ( a * a + b * b + c * c ) ) NEW_LINE print ( " Perpendicular ▁ distance ▁ is " , d / e ) NEW_LINE DEDENT
def haversine ( lat1 , lon1 , lat2 , lon2 ) : NEW_LINE INDENT dLat = ( lat2 - lat1 ) * math . pi / 180.0 NEW_LINE dLon = ( lon2 - lon1 ) * math . pi / 180.0 NEW_LINE lat1 = ( lat1 ) * math . pi / 180.0 NEW_LINE lat2 = ( lat2 ) * math . pi / 180.0 NEW_LINE a = ( pow ( math . sin ( dLat / 2 ) , 2 ) + pow ( math . sin ( dLon / 2 ) , 2 ) * math . cos ( lat1 ) * math . cos ( lat2 ) ) ; NEW_LINE rad = 6371 NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE return rad * c NEW_LINE DEDENT
def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE a = b1 * c2 - b2 * c1 NEW_LINE b = a2 * c1 - a1 * c2 NEW_LINE c = a1 * b2 - b1 * a2 NEW_LINE d = ( - a * x1 - b * y1 - c * z1 ) NEW_LINE print " equation ▁ of ▁ plane ▁ is ▁ " , NEW_LINE print a , " x ▁ + " , NEW_LINE print b , " y ▁ + " , NEW_LINE print c , " z ▁ + " , NEW_LINE print d , " = ▁ 0 . " NEW_LINE DEDENT
def mirror_point ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / float ( ( a * a + b * b + c * c ) ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE x3 = 2 * x2 - x1 NEW_LINE y3 = 2 * y2 - y1 NEW_LINE z3 = 2 * z2 - z1 NEW_LINE print " x3 ▁ = " , x3 , NEW_LINE print " y3 ▁ = " , y3 , NEW_LINE print " z3 ▁ = " , z3 , NEW_LINE DEDENT
def octant ( x , y , z ) : NEW_LINE INDENT if x >= 0 and y >= 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 1st ▁ octant " NEW_LINE DEDENT elif x < 0 and y >= 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 2nd ▁ octant " NEW_LINE DEDENT elif x < 0 and y < 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 3rd ▁ octant " NEW_LINE DEDENT elif x >= 0 and y < 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 4th ▁ octant " NEW_LINE DEDENT elif x >= 0 and y >= 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 5th ▁ octant " NEW_LINE DEDENT elif x < 0 and y >= 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 6th ▁ octant " NEW_LINE DEDENT elif x < 0 and y < 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 7th ▁ octant " NEW_LINE DEDENT elif x >= 0 and y < 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 8th ▁ octant " NEW_LINE DEDENT DEDENT
def findVolume ( l , b , h ) : NEW_LINE INDENT return ( ( l * b * h ) / 2 ) NEW_LINE DEDENT
def countNumberOfTriangles ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) * ( n - 2 ) // 6 ) NEW_LINE DEDENT
def countRectangles ( radius ) : NEW_LINE INDENT rectangles = 0 NEW_LINE diameter = 2 * radius NEW_LINE diameterSquare = diameter * diameter NEW_LINE for a in range ( 1 , 2 * radius ) : NEW_LINE INDENT for b in range ( 1 , 2 * radius ) : NEW_LINE INDENT diagonalLengthSquare = ( a * a + b * b ) NEW_LINE if ( diagonalLengthSquare <= diameterSquare ) : NEW_LINE INDENT rectangles += 1 NEW_LINE DEDENT DEDENT DEDENT return rectangles NEW_LINE DEDENT
def centeredDodecagonal ( n ) : NEW_LINE INDENT return 6 * n * ( n - 1 ) + 1 ; NEW_LINE DEDENT
def heptagonalNumber ( n ) : NEW_LINE INDENT return ( ( 5 * n * n ) - ( 3 * n ) ) // 2 NEW_LINE DEDENT
def centeredTridecagonalNum ( n ) : NEW_LINE INDENT return ( 13 * n * ( n - 1 ) + 2 ) // 2 NEW_LINE DEDENT
def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) / 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT
def pentagon_pyramidal ( n ) : NEW_LINE INDENT return n * n * ( n + 1 ) / 2 NEW_LINE DEDENT
def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT a1 = 2 NEW_LINE b1 = - 3 NEW_LINE c1 = 5 NEW_LINE a2 = 3 NEW_LINE b2 = 4 NEW_LINE c2 = - 7 NEW_LINE a3 = 9 NEW_LINE b3 = - 5 NEW_LINE c3 = 8 NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getQuadrant ( X , Y , R , PX , PY ) : NEW_LINE INDENT if ( PX == X and PY == Y ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT val = ( math . pow ( ( PX - X ) , 2 ) + math . pow ( ( PY - Y ) , 2 ) ) ; NEW_LINE if ( val > pow ( R , 2 ) ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( PX > X and PY >= Y ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( PX <= X and PY > Y ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( PX < X and PY <= Y ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT if ( PX >= X and PY < Y ) : NEW_LINE INDENT return 4 ; NEW_LINE DEDENT DEDENT
def center_pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 15 * n * n - 15 * n + 2 ) // 2 NEW_LINE DEDENT
def icosidigonal_num ( n ) : NEW_LINE INDENT return ( 20 * n * n - 18 * n ) // 2 NEW_LINE DEDENT
def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) // 2 NEW_LINE DEDENT
def center_octadecagon_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 9 * n + 1 ) NEW_LINE DEDENT
def hendecagonal_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 7 * n ) // 2 NEW_LINE DEDENT
def centereddecagonalnum ( n ) : NEW_LINE INDENT return ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT
def cen_octagonalnum ( n ) : NEW_LINE INDENT return ( 4 * n * n - 4 * n + 1 ) NEW_LINE DEDENT
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT
def nthEnneadecagonal ( n ) : NEW_LINE INDENT return ( 17 * n * n - 15 * n ) // 2 NEW_LINE DEDENT
def hexadecagonalNum ( n ) : NEW_LINE INDENT return ( ( 14 * n * n ) - 12 * n ) // 2 NEW_LINE DEDENT
def centered_pentagonal_Num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) // 2 NEW_LINE DEDENT
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " , 2 * x2 - x1 , " , " , 2 * y2 - y1 , " ) " ) ; NEW_LINE DEDENT
def intersection ( n ) : NEW_LINE INDENT return n * ( n - 1 ) ; NEW_LINE DEDENT
def findPCSlope ( m ) : NEW_LINE INDENT return - 1.0 / m NEW_LINE DEDENT
def parallel ( n , a ) : NEW_LINE INDENT x = True ; NEW_LINE y = True ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) : NEW_LINE INDENT x = False ; NEW_LINE DEDENT if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) : NEW_LINE INDENT y = False ; NEW_LINE DEDENT DEDENT if ( x ) : NEW_LINE INDENT print ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; NEW_LINE DEDENT elif ( y ) : NEW_LINE INDENT print ( " Parallel ▁ to ▁ X ▁ Axis " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Parallel ▁ to ▁ X ▁ and ▁ Y ▁ Axis " ) ; NEW_LINE DEDENT DEDENT
def otherEndPoint ( x1 , y1 , m1 , m2 ) : NEW_LINE INDENT x2 = ( 2 * m1 - x1 ) NEW_LINE y2 = ( 2 * m2 - y1 ) NEW_LINE print ( " x2 ▁ = ▁ { } , ▁ y2 ▁ = ▁ { } " . format ( x2 , y2 ) ) NEW_LINE DEDENT
def numberOfSticks ( x ) : NEW_LINE INDENT return ( 3 * x * ( x + 1 ) ) / 2 NEW_LINE DEDENT
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( X ) NEW_LINE Xmin = min ( X ) NEW_LINE Ymax = max ( Y ) NEW_LINE Ymin = min ( Y ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " , sep = " " ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymax , " } " , sep = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " , sep = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " , sep = " " ) NEW_LINE DEDENT
def checkOrigin ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) NEW_LINE DEDENT if ( checkOrigin ( 1 , 28 , 2 , 56 ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT r = 8 ; R = 4 ; r1 = 2 ; x1 = 6 ; y1 = 0 NEW_LINE if ( checkcircle ( r , R , r1 , x1 , y1 ) ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT
def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 ) ) NEW_LINE DEDENT
def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT
def find_Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT
def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = 7 NEW_LINE b = 10 NEW_LINE c = 5 NEW_LINE if checkValidity ( a , b , c ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( a == b and d == c ) or ( a == c and b == d ) or ( a == d and b == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def pythagorean_quadruple ( a , b , c , d ) : NEW_LINE INDENT sum = a * a + b * b + c * c ; NEW_LINE if ( d * d == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 2 NEW_LINE d = 3 NEW_LINE if ( pythagorean_quadruple ( a , b , c , d ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEW_LINE DEDENT
def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( int ( ( x1 + x2 ) / 2 ) , end = " " ) NEW_LINE print ( " , " , int ( ( y1 + y2 ) / 2 ) ) NEW_LINE DEDENT
def perimeter ( diameter , height ) : NEW_LINE INDENT return 2 * ( diameter + height ) NEW_LINE DEDENT
def area_of_segment ( radius , angle ) : NEW_LINE INDENT area_of_sector = pi * NEW_LINE INDENT ( radius * radius ) NEW_LINE * ( angle / 360 ) NEW_LINE DEDENT area_of_triangle = 1 / 2 * NEW_LINE INDENT ( radius * radius ) * NEW_LINE math . sin ( ( angle * pi ) / 180 ) NEW_LINE DEDENT return area_of_sector - area_of_triangle ; NEW_LINE DEDENT
def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , " ▁ , ▁ " , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT
def area_of_tetrahedron ( side ) : NEW_LINE INDENT return ( math . sqrt ( 3 ) * ( side * side ) ) ; NEW_LINE DEDENT
def vol_tetra ( side ) : NEW_LINE INDENT volume = ( side ** 3 / ( 6 * math . sqrt ( 2 ) ) ) NEW_LINE return round ( volume , 2 ) NEW_LINE DEDENT
def overflow ( H , r , h , N , R ) : NEW_LINE INDENT tank_cap = 3.14 * r * r * H NEW_LINE water_vol = 3.14 * r * r * h NEW_LINE balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R NEW_LINE vol = water_vol + balls_vol NEW_LINE if vol > tank_cap : NEW_LINE INDENT print ( " Overflow " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ in ▁ overflow ▁ state " ) NEW_LINE DEDENT DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( dp [ x ] ) NEW_LINE DEDENT
def maxvolume ( s ) : NEW_LINE INDENT maxvalue = 0 NEW_LINE i = 1 NEW_LINE for i in range ( s - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( s ) : NEW_LINE INDENT k = s - i - j NEW_LINE maxvalue = max ( maxvalue , i * j * k ) NEW_LINE DEDENT DEDENT return maxvalue NEW_LINE DEDENT
def maxvolume ( s ) : NEW_LINE INDENT length = int ( s / 3 ) NEW_LINE s -= length NEW_LINE breadth = s / 2 NEW_LINE height = s - breadth NEW_LINE return int ( length * breadth * height ) NEW_LINE DEDENT
def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT return 1.33 * math . pi * r1 * r2 * r3 NEW_LINE DEDENT
def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT if x1 == x2 : NEW_LINE INDENT return ( sys . maxsize ) NEW_LINE DEDENT return ( ( y2 - y1 ) / ( x2 - x1 ) ) NEW_LINE DEDENT
def areaOctagon ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side ) NEW_LINE DEDENT
def Area ( b1 , b2 , h ) : NEW_LINE INDENT return ( ( b1 + b2 ) / 2 ) * h NEW_LINE DEDENT
def hexagonArea ( s ) : NEW_LINE INDENT return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; NEW_LINE DEDENT
def Circumference ( a ) : NEW_LINE INDENT return ( 4 * a ) NEW_LINE DEDENT
def maxArea ( a , b , c , d ) : NEW_LINE INDENT semiperimeter = ( a + b + c + d ) / 2 NEW_LINE return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) NEW_LINE DEDENT
def arcLength ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ cannot ▁ be ▁ formed " ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT
def SectorArea ( radius , angle ) : NEW_LINE INDENT pi = 22 / 7 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT sector = ( pi * radius ** 2 ) * ( angle / 360 ) NEW_LINE print ( sector ) NEW_LINE return NEW_LINE DEDENT DEDENT
def minRadius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT
def circumference ( r ) : NEW_LINE INDENT return ( 2 * PI * r ) NEW_LINE DEDENT
def areaSquare ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
def maxSquare ( b , m ) : NEW_LINE INDENT return ( b / m - 1 ) * ( b / m ) / 2 NEW_LINE DEDENT
def minPerimeter ( n ) : NEW_LINE INDENT l = math . sqrt ( n ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n / l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT DEDENT
def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( " Touch " ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( " Intersect " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT
def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : NEW_LINE INDENT dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) NEW_LINE dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) NEW_LINE if ( dis1 != dis2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
def fitOrNotFit ( R , r , x , y , rad ) : NEW_LINE INDENT val = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) NEW_LINE if ( val + rad <= R and val - rad >= R - r ) : NEW_LINE INDENT print ( " Fits " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Doesn ' t ▁ Fit " ) NEW_LINE DEDENT DEDENT
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT x1 = - 10 NEW_LINE y1 = 8 NEW_LINE x2 = 14 NEW_LINE y2 = - 24 NEW_LINE r1 = 30 NEW_LINE r2 = 10 NEW_LINE t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) NEW_LINE if ( t == 1 ) : NEW_LINE INDENT print ( " Circle ▁ touch ▁ to ▁ each ▁ other . " ) NEW_LINE DEDENT elif ( t < 0 ) : NEW_LINE INDENT print ( " Circle ▁ not ▁ touch ▁ to ▁ each ▁ other . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Circle ▁ intersect ▁ to ▁ each ▁ other . " ) NEW_LINE DEDENT
def rectCount ( n , m ) : NEW_LINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4 NEW_LINE DEDENT
def countObtuseAngles ( a , b , k ) : NEW_LINE INDENT c1 = ( b - a ) - 1 NEW_LINE c2 = ( k - b ) + ( a - 1 ) NEW_LINE if ( c1 == c2 ) : NEW_LINE return 0 NEW_LINE return min ( c1 , c2 ) NEW_LINE DEDENT
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT height = length NEW_LINE while ( height * length <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE height += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_y - m * sum_x ) / n ; NEW_LINE print ( " m ▁ = ▁ " , m ) ; NEW_LINE print ( " c ▁ = ▁ " , c ) ; NEW_LINE DEDENT
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d / ( 2 * r ) ) NEW_LINE DEDENT
def findRightAngle ( A , H ) : NEW_LINE INDENT D = pow ( H , 4 ) - 16 * A * A NEW_LINE if D >= 0 : NEW_LINE INDENT root1 = ( H * H + sqrt ( D ) ) / 2 NEW_LINE root2 = ( H * H - sqrt ( D ) ) / 2 NEW_LINE a = sqrt ( root1 ) NEW_LINE b = sqrt ( root2 ) NEW_LINE if b >= a : NEW_LINE INDENT print a , b , H NEW_LINE DEDENT else : NEW_LINE INDENT print b , a , H NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT DEDENT
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base // 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT return int ( 1 + n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
def findTriangle ( a , n ) : NEW_LINE INDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] * a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE x , y , z = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = i + 1 NEW_LINE q = i + 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT while ( p < n - 1 and b [ i ] + b [ j ] >= b [ p + 1 ] ) : NEW_LINE INDENT p += 1 NEW_LINE DEDENT q = max ( q , p ) NEW_LINE while ( q < n - 1 and a [ i ] + a [ j ] > a [ q + 1 ] ) : NEW_LINE INDENT q += 1 NEW_LINE DEDENT if ( b [ i ] + b [ j ] == b [ p ] ) : NEW_LINE INDENT x += max ( p - j - 1 , 0 ) NEW_LINE y += 1 NEW_LINE z += q - p NEW_LINE DEDENT else : NEW_LINE INDENT x += max ( p - j , 0 ) NEW_LINE z += q - p NEW_LINE DEDENT DEDENT DEDENT print ( " Acute ▁ Triangle : " , x ) NEW_LINE print ( " Right ▁ Triangle : " , y ) NEW_LINE print ( " Obtuse ▁ Triangle : " , z ) NEW_LINE DEDENT
def checkPoint ( radius , x , y , percent , startAngle ) : NEW_LINE INDENT endAngle = 360 / percent + startAngle NEW_LINE polarradius = math . sqrt ( x * x + y * y ) NEW_LINE Angle = math . atan ( y / x ) NEW_LINE if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : NEW_LINE INDENT print ( " Point ▁ ( " , x , " , " , y , " ) ▁ " " exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Point ▁ ( " , x , " , " , y , " ) ▁ " " does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT DEDENT
def countLattice ( r ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 4 NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT ySquare = r * r - x * x NEW_LINE y = int ( math . sqrt ( ySquare ) ) NEW_LINE if ( y * y == ySquare ) : NEW_LINE INDENT result += 4 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE DEDENT return int ( abs ( area / 2.0 ) ) NEW_LINE DEDENT
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT
def minimumAdditionOperation ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N ) : NEW_LINE INDENT if ( N & 1 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N = N >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minimumSizeArr ( A , B ) : NEW_LINE INDENT currXor = 0 NEW_LINE reminder = ( A - 1 ) % 4 NEW_LINE if ( reminder == 0 ) : NEW_LINE INDENT currXor = A - 1 NEW_LINE DEDENT elif ( reminder == 1 ) : NEW_LINE INDENT currXor = 1 NEW_LINE DEDENT elif ( reminder == 2 ) : NEW_LINE INDENT currXor = A NEW_LINE DEDENT minSize = A NEW_LINE if ( currXor == B ) : NEW_LINE INDENT return minSize NEW_LINE DEDENT elif ( currXor ^ B == A ) : NEW_LINE INDENT return minSize + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return minSize + 1 NEW_LINE DEDENT DEDENT
def countTriplets ( N ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for A in range ( 1 , N + 1 ) : NEW_LINE INDENT for B in range ( 1 , N // A + 1 ) : NEW_LINE INDENT cnt += N // ( A * B ) ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def subfactorial ( N ) : NEW_LINE INDENT res = 0 NEW_LINE fact = 1 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( count % 2 == 0 ) : NEW_LINE INDENT res = res - ( 1 / fact ) NEW_LINE DEDENT else : NEW_LINE INDENT res = res + ( 1 / fact ) NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return fact * ( 1 + res ) NEW_LINE DEDENT
def minOperations ( A , B , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < N and i < N ) : NEW_LINE INDENT if ( B [ i ] == A [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def countPairs ( N ) : NEW_LINE INDENT res = 0 NEW_LINE for q in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT maxP = min ( 2 * N - q , N // q ) NEW_LINE if ( maxP < q ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = maxP - q + 1 NEW_LINE res += ( cnt // 2 + ( cnt & 1 ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countDistinctSums ( N , L , R ) : NEW_LINE INDENT minSum = L * N NEW_LINE maxSum = R * N NEW_LINE return maxSum - minSum + 1 NEW_LINE DEDENT
def countSubsequences ( arr ) : NEW_LINE INDENT odd = 0 NEW_LINE for x in arr : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT return ( 1 << odd ) - 1 NEW_LINE DEDENT
def maxPlanes ( A , B , N ) : NEW_LINE INDENT St = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = 1 if ( A [ i ] % B [ i ] > 0 ) else 0 NEW_LINE t += ( A [ i ] // B [ i ] ) + t NEW_LINE St . add ( t ) NEW_LINE DEDENT return len ( St ) NEW_LINE DEDENT
def checkSameDigits ( N ) : NEW_LINE INDENT digit = N % 10 ; NEW_LINE while ( N != 0 ) : NEW_LINE INDENT current_digit = N % 10 ; NEW_LINE N = N // 10 ; NEW_LINE if ( current_digit != digit ) : NEW_LINE INDENT return " No " ; NEW_LINE DEDENT DEDENT return " Yes " ; NEW_LINE DEDENT
def checkSameDigits ( N ) : NEW_LINE INDENT length = int ( math . log10 ( N ) ) + 1 ; NEW_LINE M = ( int ( math . pow ( 10 , length ) ) - 1 ) // ( 10 - 1 ) ; NEW_LINE M *= N % 10 ; NEW_LINE if ( M == N ) : NEW_LINE INDENT return " Yes " ; NEW_LINE DEDENT return " No " ; NEW_LINE DEDENT
def positionAfterKJumps ( X , Y , K ) : NEW_LINE INDENT addY = Y * ( K // 2 ) NEW_LINE reduceX = - 1 * X * ( K // 2 + K % 2 ) NEW_LINE return addY + reduceX NEW_LINE DEDENT
def count ( N ) : NEW_LINE INDENT odd_indices = N // 2 NEW_LINE even_indices = N // 2 + N % 2 NEW_LINE arrange_odd = 4 ** odd_indices NEW_LINE arrange_even = 5 ** even_indices NEW_LINE return arrange_odd * arrange_even NEW_LINE DEDENT
def predictTheWinner ( K , N ) : NEW_LINE INDENT if ( N % ( K + 1 ) == 0 ) : NEW_LINE INDENT print ( " Bob " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Alice " ) NEW_LINE DEDENT DEDENT
def maxRightmostElement ( N , k , p , arr ) : NEW_LINE INDENT while ( k ) : NEW_LINE INDENT for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= p ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - p NEW_LINE arr [ i + 1 ] = arr [ i + 1 ] + p NEW_LINE break NEW_LINE DEDENT DEDENT k = k - 1 NEW_LINE DEDENT print ( arr [ N - 1 ] ) NEW_LINE DEDENT
def maxRightmostElement ( N , k , arr ) : NEW_LINE INDENT ans = arr [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT d = min ( arr [ i ] // 2 , k // ( N - 1 - i ) ) NEW_LINE k -= d * ( N - 1 - i ) NEW_LINE ans += d * 2 NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans , end = " ▁ " ) NEW_LINE DEDENT
def findMaxK ( N ) : NEW_LINE INDENT K = N NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT K &= i NEW_LINE if ( K == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def findMaxK ( N ) : NEW_LINE INDENT p = math . log ( N ) // math . log ( 2 ) ; NEW_LINE return int ( pow ( 2 , p ) ) ; NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ j ] % arr [ i ] == 0 ) and ( j + 1 ) % ( i + 1 ) == 0 and ( arr [ j ] // arr [ i ] == ( j + 1 ) // ( i + 1 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def smallestMaximum ( N , K ) : NEW_LINE INDENT sum = ( ( N + K - 1 ) // K ) * K NEW_LINE if ( sum % N != 0 ) : NEW_LINE INDENT return ( sum // N ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sum // N NEW_LINE DEDENT DEDENT
def findMinMax ( a ) : NEW_LINE INDENT min_val = 1000000000 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) NEW_LINE DEDENT return min_val NEW_LINE DEDENT
def performQueries ( n , q , k , arr , query ) : NEW_LINE INDENT for i in range ( 1 , q + 1 , 1 ) : NEW_LINE count = 0 NEW_LINE if ( query [ i - 1 ] [ 0 ] == 1 ) : NEW_LINE DEDENT for j in range ( query [ i - 1 ] [ 1 ] , query [ i - 1 ] [ 2 ] + 1 , 1 ) : NEW_LINE INDENT if ( arr [ j ] == k ) : NEW_LINE DEDENT count += 1 NEW_LINE INDENT print ( count ) NEW_LINE else : NEW_LINE DEDENT arr [ query [ i - 1 ] [ 1 ] ] = query [ i - 1 ] [ 2 ] NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 5 , 7 , 6 , 9 , 0 , 0 , 0 , 0 , 5 , 6 , 7 , 3 , 9 , 0 , 7 , 0 , 9 , 0 ] NEW_LINE Q = 5 NEW_LINE INDENT query = [ [ 1 , 5 , 14 ] , [ 2 , 6 , 1 ] , [ 1 , 0 , 8 ] , [ 2 , 13 , 0 ] , [ 1 , 6 , 18 ] ] NEW_LINE DEDENT N = len ( arr ) NEW_LINE DEDENT K = 0 NEW_LINE INDENT performQueries ( N , Q , K , arr , query ) NEW_LINE DEDENT
def isPossible ( arr , n ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT mini = min ( mini , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == mini ) : NEW_LINE INDENT continue NEW_LINE DEDENT Max = ( arr [ i ] + 1 ) // 2 - 1 NEW_LINE if ( mini < 0 or mini > Max ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def performQuery ( arr , Q ) : NEW_LINE INDENT for i in range ( 0 , len ( Q ) ) : NEW_LINE INDENT orr = 0 NEW_LINE x = Q [ i ] [ 0 ] NEW_LINE arr [ x - 1 ] = Q [ i ] [ 1 ] NEW_LINE for j in range ( 0 , len ( arr ) ) : NEW_LINE INDENT orr = orr | arr [ j ] NEW_LINE DEDENT print ( orr , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findSumOfAllSubsets ( arr , n , k ) : NEW_LINE INDENT factorial_N = 1 NEW_LINE factorial_d = 1 NEW_LINE factorial_D = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT factorial_N *= i NEW_LINE DEDENT for i in range ( 1 , k , 1 ) : NEW_LINE INDENT factorial_d *= i NEW_LINE DEDENT for i in range ( 1 , n - k + 1 , 1 ) : NEW_LINE INDENT factorial_D *= i NEW_LINE DEDENT freq = factorial_N // ( factorial_d * factorial_D ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum = sum * freq NEW_LINE print ( " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " , k , " ▁ is ▁ = > " , sum ) NEW_LINE DEDENT
def countQuadruples ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE freq = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] in freq : NEW_LINE INDENT ans += freq [ A [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT freq [ A [ i ] ] = 0 NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT for k in range ( j ) : NEW_LINE INDENT if A [ i ] * A [ j ] * A [ k ] in freq : NEW_LINE INDENT freq [ A [ i ] * A [ j ] * A [ k ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ A [ i ] * A [ j ] * A [ k ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countTriplets ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT c1 = odd * ( even * ( even - 1 ) ) // 2 NEW_LINE c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) // 6 NEW_LINE return c1 + c2 NEW_LINE DEDENT
def can_empty ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 4 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT m = min ( a , min ( b , c ) ) ; NEW_LINE if ( m < ( a + b + c ) // 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT
def minSumDifference ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ar [ i ] NEW_LINE DEDENT rem = sum % n NEW_LINE return rem * ( n - rem ) NEW_LINE DEDENT
def smallest ( k , d ) : NEW_LINE INDENT cnt = 1 NEW_LINE m = d % k NEW_LINE v = [ 0 for i in range ( k ) ] ; NEW_LINE v [ m ] = 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k NEW_LINE if ( v [ m ] == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT v [ m ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def getPairsCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - ( i % arr [ i ] ) , n , arr [ i ] ) : NEW_LINE INDENT if ( i < j and abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def minSteps ( N ) : NEW_LINE INDENT count = 1 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , N + 1 , count ) : NEW_LINE INDENT res = max ( res , count ) NEW_LINE count += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def minSteps ( N ) : NEW_LINE INDENT res = int ( ( sqrt ( 1 + 8 * N ) - 1 ) // 2 ) NEW_LINE return res NEW_LINE DEDENT
def oppositeFaceOfDice ( N ) : NEW_LINE INDENT ans = 7 - N NEW_LINE print ( ans ) NEW_LINE DEDENT
def findAandB ( N ) : NEW_LINE INDENT K = int ( log2 ( N ) ) NEW_LINE B = ( 1 << K ) NEW_LINE A = B ^ N NEW_LINE print ( A , B ) NEW_LINE DEDENT
def minDistance ( start , end , n , d ) : NEW_LINE INDENT left = - sys . maxsize NEW_LINE right = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT left = max ( left , start [ i ] ) NEW_LINE right = min ( right , end [ i ] ) NEW_LINE DEDENT if ( left > right ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( d >= left and d <= right ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( d < left ) : NEW_LINE INDENT return ( left - d ) NEW_LINE DEDENT if ( d > right ) : NEW_LINE INDENT return ( d - right ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == i + j : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT print ( answer ) NEW_LINE DEDENT
def checkDistribution ( R , B , D ) : NEW_LINE INDENT if ( max ( R , B ) <= min ( R , B ) * ( D + 1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def itemType ( n ) : NEW_LINE INDENT count = 0 NEW_LINE day = 1 NEW_LINE while ( True ) : NEW_LINE INDENT for type in range ( day , 0 , - 1 ) : NEW_LINE INDENT count += type NEW_LINE if ( count >= n ) : NEW_LINE INDENT return type NEW_LINE DEDENT DEDENT DEDENT DEDENT
def IsEvenPath ( Source , Destination ) : NEW_LINE INDENT x_dif = abs ( Source [ 0 ] - Destination [ 0 ] ) NEW_LINE y_dif = abs ( Source [ 1 ] - Destination [ 1 ] ) NEW_LINE minsteps = x_dif + y_dif NEW_LINE if ( minsteps % 2 == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def Avgdifference ( arr , N , K ) : NEW_LINE INDENT min = 1000000 ; NEW_LINE max = - 1 ; NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( K ) : NEW_LINE INDENT sum += arr [ i + j ] ; NEW_LINE DEDENT if ( min > sum ) : NEW_LINE INDENT min = sum ; NEW_LINE DEDENT if ( max < sum ) : NEW_LINE INDENT max = sum ; NEW_LINE DEDENT DEDENT return ( max - min ) / K ; NEW_LINE DEDENT
def Avgdifference ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT min = sum NEW_LINE max = sum NEW_LINE for i in range ( K , N - K + 2 , 1 ) : NEW_LINE INDENT sum += arr [ i ] - arr [ i - K ] NEW_LINE if ( min > sum ) : NEW_LINE INDENT min = sum NEW_LINE DEDENT if ( max < sum ) : NEW_LINE INDENT max = sum NEW_LINE DEDENT DEDENT return ( max - min ) / K NEW_LINE DEDENT
def perfectSquare ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT p = sqrt ( arr [ i ] ) NEW_LINE if ( p * p != arr [ i ] ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def countKAverageSubarrays ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for L in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for R in range ( L , n , 1 ) : NEW_LINE INDENT sum += arr [ R ] NEW_LINE len1 = ( R - L + 1 ) NEW_LINE if ( sum % len1 == 0 ) : NEW_LINE INDENT avg = sum // len1 NEW_LINE if ( avg == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def FractionSplit ( n , d ) : NEW_LINE INDENT UnitFactions = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = ( d + n - 1 ) // n NEW_LINE s = "1 / " + str ( x ) NEW_LINE UnitFactions . append ( s ) ; NEW_LINE n = n * x - d ; NEW_LINE d = d * x NEW_LINE DEDENT return UnitFactions ; NEW_LINE DEDENT n = 13 ; NEW_LINE d = 18 ; NEW_LINE res = FractionSplit ( n , d ) ; NEW_LINE for s in res : NEW_LINE INDENT print ( s + " , ▁ " , end = " ▁ " ) ; NEW_LINE DEDENT
def rangeSum ( arr , N , L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( L - 1 , R , 1 ) : NEW_LINE INDENT sum += arr [ i % N ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def rangeSum ( arr , N , L , R ) : NEW_LINE INDENT prefix = [ 0 for i in range ( N + 1 ) ] NEW_LINE prefix [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT leftsum = ( ( L - 1 ) // N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] NEW_LINE rightsum = ( R // N ) * prefix [ N ] + prefix [ R % N ] NEW_LINE print ( rightsum - leftsum ) NEW_LINE DEDENT
def addAP ( A , Q , operations ) : NEW_LINE INDENT for L , R , a , d in operations : NEW_LINE INDENT curr = a NEW_LINE for i in range ( L - 1 , R ) : NEW_LINE INDENT A [ i ] += curr NEW_LINE curr += d NEW_LINE DEDENT DEDENT for i in A : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def countOfPairs ( arr , N , X ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def ConcatenateArr ( arr , N ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT l = math . floor ( math . log10 ( arr [ i ] ) + 1 ) NEW_LINE ans = ans * math . pow ( 10 , l ) NEW_LINE ans += arr [ i ] NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def countXor ( N ) : NEW_LINE INDENT cnt = N // 2 + 1 NEW_LINE return cnt NEW_LINE DEDENT
def ExpoFactorial ( N ) : NEW_LINE INDENT res = 1 NEW_LINE mod = ( int ) ( 1000000007 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT res = pow ( i , res , mod ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findkey ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE cur = 1 NEW_LINE while ( A > 0 ) : NEW_LINE INDENT a = A % 10 NEW_LINE b = B % 10 NEW_LINE c = C % 10 NEW_LINE A = A // 10 NEW_LINE B = B // 10 NEW_LINE C = C // 10 NEW_LINE m = max ( a , max ( c , b ) ) NEW_LINE ans += cur * m NEW_LINE cur = cur * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printRectPattern ( c1 , c2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( max ( abs ( c1 - i ) , abs ( c2 - j ) ) , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( ( i & 1 ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countNumbers ( l , r ) : NEW_LINE INDENT return ( ( r // 2 ) - ( l - 1 ) // 2 ) NEW_LINE DEDENT
def sumOfFirstM ( A , N , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT sum = sum + A [ i % N ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findSmallestNumK ( n ) : NEW_LINE INDENT cummAnd = n NEW_LINE i = n - 1 NEW_LINE while ( cummAnd != 0 ) : NEW_LINE INDENT cummAnd = cummAnd & i NEW_LINE if ( cummAnd == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findMinInsertions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return 0 if ( str [ l ] == str [ h ] ) else 1 NEW_LINE DEDENT if ( str [ l ] == str [ h ] ) : NEW_LINE INDENT return findMinInsertions ( str , l + 1 , h - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) NEW_LINE DEDENT DEDENT
def maximumTurns ( arr , N ) : NEW_LINE INDENT Count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT Count += 1 NEW_LINE arr [ i ] = arr [ i ] // 2 NEW_LINE DEDENT DEDENT return Count NEW_LINE DEDENT
def findSet ( N , K ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i != K ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT MaxDistinct = ( N - K ) + ( K // 2 ) NEW_LINE a = a [ : : - 1 ] NEW_LINE for i in range ( MaxDistinct ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def isPossible ( W , B , D ) : NEW_LINE INDENT if ( W > B ) : NEW_LINE INDENT temp = W NEW_LINE W = B NEW_LINE B = temp NEW_LINE DEDENT if ( B > W * ( D + 1 ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def factorialWithoutMul ( N ) : NEW_LINE INDENT ans = N NEW_LINE i = N - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ans NEW_LINE DEDENT ans = sum NEW_LINE i -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def noOfWays ( N , K ) : NEW_LINE INDENT S = str ( N ) NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT count = 1 NEW_LINE while ( i < len ( S ) and ord ( S [ i ] ) + ord ( S [ i - 1 ] ) - 2 * ord ( '0' ) == K ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( count % 2 ) : NEW_LINE INDENT ans *= ( count + 1 ) // 2 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def tripletAndSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT ans += arr [ i ] & arr [ j ] & arr [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def tripletAndSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for bit in range ( 32 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << bit ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) // 6 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countOfBase ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT highestPower = int ( math . log ( N ) / math . log ( i ) ) NEW_LINE firstDigit = int ( N / int ( math . pow ( i , highestPower ) ) ) NEW_LINE if ( firstDigit == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maximumSubsequenceSum ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] - i in mp ) : NEW_LINE INDENT mp [ A [ i ] - i ] += A [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] - i ] = A [ i ] NEW_LINE DEDENT ans = max ( ans , mp [ A [ i ] - i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def nearestPerfectSquare ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT sr = math . floor ( math . sqrt ( arr [ i ] ) ) NEW_LINE a = sr * sr NEW_LINE b = ( sr + 1 ) * ( sr + 1 ) NEW_LINE if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) : NEW_LINE print ( a , end = " ▁ " ) NEW_LINE else : NEW_LINE print ( b , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countXorPartition ( N ) : NEW_LINE INDENT a = 2 ** floor ( N - log ( N + 1 ) / log ( 2 ) ) NEW_LINE print ( int ( a ) ) NEW_LINE DEDENT
def floorDifference ( A , N , X ) : NEW_LINE INDENT totalSum = 0 NEW_LINE perElementSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalSum += A [ i ] NEW_LINE perElementSum += A [ i ] // X NEW_LINE DEDENT totalFloorSum = totalSum // X NEW_LINE return abs ( totalFloorSum - perElementSum ) NEW_LINE DEDENT
def maximumSum ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for bit in range ( 32 ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << bit ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT ans = max ( ans , sum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isDivisibleByDivisor ( S , D ) : NEW_LINE INDENT S %= D NEW_LINE hashMap = set ( ) NEW_LINE hashMap . add ( S ) NEW_LINE for i in range ( D + 1 ) : NEW_LINE INDENT S += ( S % D ) NEW_LINE S %= D NEW_LINE if ( S in hashMap ) : NEW_LINE INDENT if ( S == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT else : NEW_LINE INDENT hashMap . add ( S ) NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
def EditDistDP ( str1 , str2 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE DP = [ [ 0 for i in range ( len1 + 1 ) ] for j in range ( 2 ) ] ; NEW_LINE for i in range ( 0 , len1 + 1 ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i NEW_LINE DEDENT for i in range ( 1 , len2 + 1 ) : NEW_LINE INDENT for j in range ( 0 , len1 + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT DP [ i % 2 ] [ j ] = i NEW_LINE DEDENT elif ( str1 [ j - 1 ] == str2 [ i - 1 ] ) : NEW_LINE INDENT DP [ i % 2 ] [ j ] = DP [ ( i - 1 ) % 2 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i % 2 ] [ j ] = ( 1 + min ( DP [ ( i - 1 ) % 2 ] [ j ] , min ( DP [ i % 2 ] [ j - 1 ] , DP [ ( i - 1 ) % 2 ] [ j - 1 ] ) ) ) NEW_LINE DEDENT DEDENT DEDENT print ( DP [ len2 % 2 ] [ len1 ] , " " ) NEW_LINE DEDENT
def findWinner ( X , Y ) : NEW_LINE INDENT first = ( X ^ Y ) NEW_LINE second = ( X + Y ) NEW_LINE if ( first == second ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
def maxFrequency ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE sum = 0 NEW_LINE res = 0 NEW_LINE for end in range ( N ) : NEW_LINE INDENT sum += arr [ end ] NEW_LINE while ( ( end - start + 1 ) * arr [ end ] - sum > K ) : NEW_LINE INDENT sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT res = max ( res , end - start + 1 ) NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def findAverage ( N ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S += i * i * i * i NEW_LINE DEDENT return round ( S / N , 4 ) NEW_LINE DEDENT
def findAverage ( N ) : NEW_LINE INDENT avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30 NEW_LINE return avg NEW_LINE DEDENT
def ToCheckPowerofX ( n , x ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT rem = n % x NEW_LINE if ( rem >= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // x NEW_LINE DEDENT return True NEW_LINE DEDENT
def findbitwiseOR ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sub_array = a [ i ] NEW_LINE res = res | curr_sub_array NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_sub_array = curr_sub_array & a [ j ] NEW_LINE res = res | curr_sub_array NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def findbitwiseOR ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = res | a [ i ] NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def sumOfDivisors ( N ) : NEW_LINE INDENT return N NEW_LINE DEDENT
def findDecimal ( arr , N ) : NEW_LINE INDENT power = 0 ; NEW_LINE result = 0 ; NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT bit = abs ( int ( arr [ i ] ) - round ( arr [ i ] ) ) ; NEW_LINE if ( bit ) : NEW_LINE INDENT result += pow ( 2 , power ) ; NEW_LINE DEDENT power += 1 ; NEW_LINE DEDENT print ( result ) ; NEW_LINE DEDENT
def totalMoney ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT ans += i / 7 NEW_LINE ans += ( i % 7 + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT sumOfDigit = 0 NEW_LINE prodOfDigit = 1 NEW_LINE while n > 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE sumOfDigit += rem NEW_LINE prodOfDigit *= rem NEW_LINE n = n // 10 NEW_LINE DEDENT if sumOfDigit > prodOfDigit : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def FindSum ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT power = int ( log2 ( arr [ i ] ) ) NEW_LINE LesserValue = pow ( 2 , power ) NEW_LINE LargerValue = pow ( 2 , power + 1 ) NEW_LINE if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def minOperation ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return ( N / 2 ) * ( N / 2 ) NEW_LINE DEDENT k = ( N - 1 ) / 2 NEW_LINE return ( k * ( k + 1 ) ) NEW_LINE DEDENT
def findXORS ( arr1 , arr2 , N , M ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT temp = arr1 [ i ] & arr2 [ j ] NEW_LINE res ^= temp NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countNum ( N ) : NEW_LINE INDENT ans = int ( math . log2 ( N ) ) + 1 NEW_LINE print ( ans ) NEW_LINE DEDENT
def findLast ( mat ) : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE rows = set ( ) NEW_LINE cols = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] : NEW_LINE INDENT rows . add ( i ) NEW_LINE cols . add ( j ) NEW_LINE DEDENT DEDENT DEDENT avRows = m - len ( list ( rows ) ) NEW_LINE avCols = n - len ( list ( cols ) ) NEW_LINE choices = min ( avRows , avCols ) NEW_LINE if choices & 1 : NEW_LINE INDENT print ( ' P1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' P2' ) NEW_LINE DEDENT DEDENT
def ceilDifference ( arr , n , x ) : NEW_LINE INDENT totalSum = 0 NEW_LINE perElementSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT totalSum += arr [ i ] NEW_LINE perElementSum += ceil ( arr [ i ] / x ) NEW_LINE DEDENT totalCeilSum = ceil ( totalSum / x ) NEW_LINE return abs ( perElementSum - totalCeilSum ) NEW_LINE DEDENT
def countTriplets ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i * j > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += N // ( i * j ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findSumOfGP ( a , r ) : NEW_LINE INDENT if ( abs ( r ) >= 1 ) : NEW_LINE INDENT print ( " Infinite " ) NEW_LINE return NEW_LINE DEDENT sum = a / ( 1 - r ) NEW_LINE print ( int ( sum ) ) NEW_LINE DEDENT
def sumOfInfiniteAGP ( a , d , r ) : NEW_LINE INDENT ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; NEW_LINE print ( round ( ans , 6 ) ) NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def minStepK ( arr , N , K ) : NEW_LINE INDENT E = 0 NEW_LINE S = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT E += 1 NEW_LINE DEDENT DEDENT if ( S >= K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( S + E < K ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return K - S NEW_LINE DEDENT DEDENT
def minimumDiff ( arr , N ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE sum1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += arr [ i ] NEW_LINE DEDENT min_diff = sum1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( abs ( sum1 - ( arr [ i ] * N ) ) < min_diff ) : NEW_LINE INDENT min_diff = abs ( sum1 - ( arr [ i ] * N ) ) NEW_LINE res = arr [ i ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def check ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def expectedValue ( P , a , b , N ) : NEW_LINE INDENT expValue = P + ( N * 0.5 * ( a + b ) ) NEW_LINE print ( int ( expValue ) ) NEW_LINE DEDENT
def findMinSum ( mat , N ) : NEW_LINE INDENT sum1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT res |= mat [ i ] [ j ] NEW_LINE DEDENT DEDENT sum1 += res NEW_LINE DEDENT return sum1 NEW_LINE DEDENT
def findMedian ( Mean , Mode ) : NEW_LINE INDENT Median = ( 2 * Mean + Mode ) // 3 NEW_LINE print ( Median ) NEW_LINE DEDENT
def vectorMagnitude ( x , y , z ) : NEW_LINE INDENT sum = x * x + y * y + z * z NEW_LINE return sqrt ( sum ) NEW_LINE DEDENT
def sumOfSquaredDifferences ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE sumA , sumB = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sumA += ( arr [ i ] * arr [ i ] ) NEW_LINE sumB += arr [ i ] NEW_LINE DEDENT sumA = N * sumA NEW_LINE sumB = ( sumB * sumB ) NEW_LINE ans = sumA - sumB NEW_LINE print ( ans ) NEW_LINE DEDENT
def minimumSteps ( x , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( x != 0 and y != 0 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT cnt += x / y NEW_LINE x %= y NEW_LINE DEDENT else : NEW_LINE INDENT cnt += y / x NEW_LINE y %= x NEW_LINE DEDENT DEDENT cnt -= 1 NEW_LINE if ( x > 1 or y > 1 ) : NEW_LINE INDENT cnt = - 1 NEW_LINE DEDENT print ( int ( cnt ) ) NEW_LINE DEDENT
def minimumMEX ( arr , N , K ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , N + 2 , 1 ) : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT for i in range ( K ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT mex = list ( s ) [ 0 ] NEW_LINE for i in range ( K , N , 1 ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE s . add ( arr [ i - K ] ) NEW_LINE firstElem = list ( s ) [ 0 ] NEW_LINE mex = min ( mex , firstElem ) NEW_LINE DEDENT print ( mex ) NEW_LINE DEDENT
def smallerNumbers ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def truncMod ( a , n ) : NEW_LINE INDENT q = a // n NEW_LINE return a - n * q NEW_LINE DEDENT
def findXOR ( mat , N ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT if ( ( i == j and j == k ) ) : NEW_LINE INDENT XOR ^= mat [ i ] [ j ] [ k ] NEW_LINE XOR ^= mat [ i ] [ j ] [ N - k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( XOR ) NEW_LINE DEDENT
def findXOR ( mat , N ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT XOR ^= mat [ i ] [ i ] [ i ] NEW_LINE XOR ^= mat [ i ] [ i ] [ N - i - 1 ] NEW_LINE DEDENT print ( XOR ) NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE mp = defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = 1.0 * arr [ i ] NEW_LINE idx = 1.0 * ( i + 1 ) NEW_LINE count += mp [ val / idx ] NEW_LINE mp [ val / idx ] += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def checkEvenPower ( n ) : NEW_LINE INDENT x = 0 NEW_LINE while ( x < n ) : NEW_LINE INDENT value = pow ( 2 , x ) NEW_LINE if ( value == n ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT x += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def checkEvenPower ( n ) : NEW_LINE INDENT low , high = 0 , n NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE value = pow ( 2 , mid ) NEW_LINE if ( value == n ) : NEW_LINE INDENT if ( mid % 2 == 1 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT else : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT DEDENT elif ( value < n ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return " No " NEW_LINE DEDENT
def checkEvenPower ( N ) : NEW_LINE INDENT if ( ( N & ( N - 1 ) ) != 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT N = N & 0x55555555 NEW_LINE return ( N > 0 ) NEW_LINE DEDENT
def multiplyByMersenne ( N , M ) : NEW_LINE INDENT x = int ( math . log2 ( M + 1 ) ) NEW_LINE return ( ( N << x ) - N ) NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT ans += N // i NEW_LINE i = i * K NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def countAPs ( S , D ) : NEW_LINE INDENT S = S * 2 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , S ) : NEW_LINE INDENT if i * i > S : NEW_LINE INDENT break NEW_LINE DEDENT if ( S % i == 0 ) : NEW_LINE INDENT if ( ( ( S // i ) - D * i + D ) % 2 == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT if ( ( D * i - ( S // i ) + D ) % 2 == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def countSubsequences ( A ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for el in A : NEW_LINE INDENT if ( el % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 << len ( A ) - 1 ) NEW_LINE DEDENT DEDENT
def maxModProdSubarr ( arr , n , M ) : NEW_LINE INDENT ans = 0 NEW_LINE length = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = 1 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT product = ( product * arr [ i ] ) % M NEW_LINE if ( product > ans ) : NEW_LINE INDENT ans = product NEW_LINE if ( length > j - i + 1 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Maximum ▁ subarray ▁ product ▁ is " , ans ) NEW_LINE print ( " Minimum ▁ length ▁ of ▁ the ▁ maximum ▁ product ▁ subarray ▁ is " , length ) NEW_LINE DEDENT
def lastElement ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT multiplier = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT multiplier = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * multiplier NEW_LINE multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT ans = ( N - odd + odd // 2 - 1 ) + odd // 2 NEW_LINE return ans NEW_LINE DEDENT
def solve ( A , n , Q , q ) : NEW_LINE INDENT one = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT glows = 0 NEW_LINE count = 0 NEW_LINE if ( one >= int ( math . ceil ( n / 2 ) ) ) : NEW_LINE INDENT glows = 1 NEW_LINE DEDENT for i in range ( 0 , q ) : NEW_LINE INDENT prev = glows NEW_LINE if ( A [ Q [ i ] - 1 ] == 1 ) : NEW_LINE INDENT one -= 1 NEW_LINE DEDENT if ( A [ Q [ i ] - 1 ] == 0 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT A [ Q [ i ] - 1 ] ^= 1 NEW_LINE if ( one >= int ( math . ceil ( n / 2.0 ) ) ) : NEW_LINE INDENT glows = 1 NEW_LINE DEDENT else : NEW_LINE INDENT glows = 0 NEW_LINE DEDENT if ( prev != glows ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def minimumDifference ( N ) : NEW_LINE INDENT sum1 = ( 1 << N ) NEW_LINE sum2 = 0 NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT sum1 += ( 1 << i ) NEW_LINE DEDENT for i in range ( N // 2 , N ) : NEW_LINE INDENT sum2 += ( 1 << i ) NEW_LINE DEDENT print ( sum1 - sum2 ) NEW_LINE DEDENT
def sumOfTwoPerfectCubes ( N ) : NEW_LINE INDENT cubes = { } NEW_LINE i = 1 NEW_LINE while i * i * i <= N : NEW_LINE INDENT cubes [ i * i * i ] = i NEW_LINE i += 1 NEW_LINE DEDENT for itr in cubes : NEW_LINE INDENT firstNumber = itr NEW_LINE secondNumber = N - itr NEW_LINE if secondNumber in cubes : NEW_LINE INDENT print ( " True " , end = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " False " , end = " " ) NEW_LINE DEDENT
def sumOfTwoCubes ( n ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = round ( math . pow ( n , 1 / 3 ) ) NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT curr = ( lo * lo * lo + hi * hi * hi ) NEW_LINE if ( curr == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( curr < n ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT N = 28 NEW_LINE if ( sumOfTwoCubes ( N ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ j ] != 0 and a [ i ] % a [ j ] == 0 ) : NEW_LINE INDENT if ( ( a [ i ] + a [ j ] ) == ( a [ i ] // a [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def numberOfTiles ( N , M ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( N * M ) // 2 NEW_LINE DEDENT
def findNthNumber ( N ) : NEW_LINE INDENT result = 0 NEW_LINE p = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT result += ( p * ( N % 9 ) ) NEW_LINE N = N // 9 NEW_LINE p = p * 10 NEW_LINE DEDENT return result NEW_LINE DEDENT
def checkSamePosition ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = ( ( i + arr [ i ] ) % n + n ) % n NEW_LINE if temp in mp : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT if ( temp in mp ) : NEW_LINE INDENT mp [ temp ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ temp ] = mp . get ( temp , 0 ) + 1 NEW_LINE DEDENT DEDENT print ( " No " ) NEW_LINE DEDENT
def sumFib ( N ) : NEW_LINE INDENT num = round ( pow ( ( pow ( 5 , 1 / 2 ) + 1 )   \ / 2.0 , N + 2 ) / pow ( 5 , 1 / 2 ) ) ; NEW_LINE print ( num - 1 ) ; NEW_LINE DEDENT
def sumFib ( N ) : NEW_LINE INDENT num = ( 1 - math . sqrt ( 5 ) ) / 2 NEW_LINE val = round ( abs ( 1 / ( pow ( num , N + 2 ) + pow ( num , N + 1 ) + pow ( num , N ) + pow ( num , N - 1 ) ) ) - 1 ) NEW_LINE print ( val ) NEW_LINE DEDENT
def poorPigs ( buckets , minutesToDie , minutesToTest ) : NEW_LINE INDENT print ( math . ceil ( math . log ( buckets ) // math . log ( ( minutesToTest   \ // minutesToDie ) + 1 ) ) ) ; NEW_LINE DEDENT
def countTrailingZeroes ( N ) : NEW_LINE INDENT res = int ( log2 ( N ^ ( N - 1 ) ) ) NEW_LINE return res if res >= 0 else 0 NEW_LINE DEDENT
def convertToASCII ( N ) : NEW_LINE INDENT num = str ( N ) NEW_LINE i = 0 NEW_LINE for ch in num : NEW_LINE INDENT print ( ch , " ( " , ord ( ch ) , " ) " ) NEW_LINE DEDENT DEDENT
def sameProductQuadruples ( nums , N ) : NEW_LINE INDENT umap = { } ; NEW_LINE res = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT prod = nums [ i ] * nums [ j ] ; NEW_LINE if prod in umap : NEW_LINE INDENT res += 8 * umap [ prod ] ; NEW_LINE umap [ prod ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT umap [ prod ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) ; NEW_LINE DEDENT
def oddDivisors ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT powerOfTwo = 2 ; NEW_LINE count = 0 ; NEW_LINE while ( powerOfTwo <= arr [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE powerOfTwo = 2 * powerOfTwo ; NEW_LINE DEDENT print ( count , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def highestPowerOfTwo ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT print ( "0" ) NEW_LINE continue NEW_LINE DEDENT lg = int ( math . log2 ( ord ( s [ i ] ) - 48 ) ) NEW_LINE p = pow ( 2 , lg ) NEW_LINE print ( chr ( p + 48 ) , end = " " ) NEW_LINE DEDENT DEDENT
def singleDigitSubarrayCount ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] <= 9 ) : NEW_LINE INDENT count += 1 NEW_LINE res += count NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def maxSumAfterKReverse ( arr , K , N ) : NEW_LINE INDENT sum = - sys . maxsize - 1 NEW_LINE if ( K & 1 ) : NEW_LINE INDENT arr . reverse ( ) NEW_LINE DEDENT currsum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT currsum += arr [ i ] NEW_LINE sum = max ( sum , currsum ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def countElements ( N ) : NEW_LINE INDENT Cur_Ele = 1 NEW_LINE Count = 0 NEW_LINE while ( Cur_Ele <= N ) : NEW_LINE INDENT Count += 1 NEW_LINE Cur_Ele = Cur_Ele * 2 NEW_LINE DEDENT print ( N - Count ) NEW_LINE DEDENT
def SubMasks ( N ) : NEW_LINE INDENT S = N NEW_LINE while S > 0 : NEW_LINE INDENT print ( S , end = ' ▁ ' ) NEW_LINE S = ( S - 1 ) & N NEW_LINE DEDENT DEDENT
def isCycleExists ( arr , N ) : NEW_LINE INDENT valley = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " No " ) NEW_LINE DEDENT
def totalInversions ( arr , K , N ) : NEW_LINE INDENT inv = 0 NEW_LINE X = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and i < j ) : NEW_LINE INDENT inv += 1 NEW_LINE DEDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT X += 1 NEW_LINE DEDENT DEDENT DEDENT totalInv = X * K * ( K - 1 ) // 2 + inv * K NEW_LINE print ( totalInv ) NEW_LINE DEDENT
def flippingBits ( N , K ) : NEW_LINE INDENT X = ( 1 << ( K - 1 ) ) - 1 NEW_LINE N = X - N NEW_LINE print ( N ) NEW_LINE DEDENT
def getMax ( arr , N , K ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT cur_val = arr [ i ] NEW_LINE while ( K >= i ) : NEW_LINE INDENT if ( cur_val > 0 ) : NEW_LINE INDENT arr [ 0 ] = arr [ 0 ] + 1 NEW_LINE cur_val = cur_val - 1 NEW_LINE K = K - i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( arr [ 0 ] ) NEW_LINE DEDENT
def numberOfWays ( n , k ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n >= pow ( 2 , k ) ) : NEW_LINE INDENT curr_val = pow ( 2 , k ) NEW_LINE return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( n , k - 1 ) NEW_LINE DEDENT DEDENT
def possibleTriplets ( arr , N ) : NEW_LINE INDENT freq = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT DEDENT return ( freq * ( freq - 1 ) * ( freq - 2 ) ) // 6 NEW_LINE DEDENT
def findDay ( Y , B ) : NEW_LINE INDENT lyear , rest , totaldays , day = 0 , 0 , 0 , 0 ; NEW_LINE Y = ( Y - 1 ) - B ; NEW_LINE lyear = Y // 4 ; NEW_LINE rest = Y - lyear ; NEW_LINE totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; NEW_LINE day = ( totaldays % 7 ) ; NEW_LINE if ( day == 0 ) : NEW_LINE INDENT print ( " Monday " ) ; NEW_LINE DEDENT elif ( day == 1 ) : NEW_LINE INDENT print ( " Tuesday " ) ; NEW_LINE DEDENT elif ( day == 2 ) : NEW_LINE INDENT print ( " Wednesday " ) ; NEW_LINE DEDENT elif ( day == 3 ) : NEW_LINE INDENT print ( " Thursday " ) ; NEW_LINE DEDENT elif ( day == 4 ) : NEW_LINE INDENT print ( " Friday " ) ; NEW_LINE DEDENT elif ( day == 5 ) : NEW_LINE INDENT print ( " Saturday " ) ; NEW_LINE DEDENT elif ( day == 6 ) : NEW_LINE INDENT print ( " Sunday " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " INPUT ▁ YEAR ▁ IS ▁ WRONG ! " ) ; NEW_LINE DEDENT DEDENT
def findPoint ( n , h ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT print ( " { 0 : . 2f } " . format ( ( ( i / n ) ** 0.5 ) * h ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def isInteger ( N ) : NEW_LINE INDENT X = int ( N ) NEW_LINE temp2 = N - X NEW_LINE if ( temp2 > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def nearestPowerOfTwo ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT lg = ( int ) ( math . log2 ( arr [ i ] ) ) NEW_LINE a = ( int ) ( math . pow ( 2 , lg ) ) NEW_LINE b = ( int ) ( math . pow ( 2 , lg + 1 ) ) NEW_LINE if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def Conversion ( centi ) : NEW_LINE INDENT pixels = ( 96 * centi ) / 2.54 NEW_LINE print ( round ( pixels , 2 ) ) NEW_LINE DEDENT
def maxNumTrailNine ( n , d ) : NEW_LINE INDENT res = n NEW_LINE cntDigits = int ( log10 ( n ) + 1 ) NEW_LINE p10 = 10 NEW_LINE for i in range ( 1 , cntDigits + 1 ) : NEW_LINE INDENT if ( n % p10 >= d ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = n - n % p10 - 1 NEW_LINE DEDENT p10 = p10 * 10 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def MinimumNoOfWays ( arr , n ) : NEW_LINE INDENT min_no_of_ways = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT mini_no_of_ways = n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT mini_no_of_ways = n // 2 + 1 NEW_LINE DEDENT return mini_no_of_ways NEW_LINE DEDENT
def count_setbit ( N ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE if ( ( 1 << i ) & N ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT
def cntWaysConsArray ( A , N ) : NEW_LINE INDENT total = 1 ; NEW_LINE oddArray = 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT total = total * 3 ; NEW_LINE if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT oddArray *= 2 ; NEW_LINE DEDENT DEDENT print ( total - oddArray ) ; NEW_LINE DEDENT
def countNumberHavingKthBitSet ( N , K ) : NEW_LINE INDENT numbers_rightmost_setbit_K = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT numbers_rightmost_bit_i = ( N + 1 ) // 2 NEW_LINE N -= numbers_rightmost_bit_i NEW_LINE if ( i == K ) : NEW_LINE INDENT numbers_rightmost_setbit_K = numbers_rightmost_bit_i NEW_LINE DEDENT DEDENT print ( numbers_rightmost_setbit_K ) NEW_LINE DEDENT
def countSetBits ( N : int ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N ) : NEW_LINE INDENT N = N & ( N - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minMoves ( arr , N ) : NEW_LINE INDENT odd_element_cnt = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT odd_element_cnt += 1 ; NEW_LINE DEDENT DEDENT moves = ( odd_element_cnt ) // 2 ; NEW_LINE if ( odd_element_cnt % 2 != 0 ) : NEW_LINE INDENT moves += 2 ; NEW_LINE DEDENT print ( moves ) ; NEW_LINE DEDENT
def find_Variance ( n ) : NEW_LINE INDENT numerator = n * n - 1 NEW_LINE ans = ( numerator * 1.0 ) / 12 NEW_LINE return ans NEW_LINE DEDENT
def countDigit ( arr ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT X = arr [ i ] [ j ] NEW_LINE d = floor ( log10 ( X ) * 1.0 ) + 1 NEW_LINE print ( d , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def noOfArraysPossible ( N , M ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = ans * ( M - i ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def TotalAndPair ( arr , N ) : NEW_LINE INDENT totalAND = ( 1 << 30 ) - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT totalAND &= ( arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return totalAND NEW_LINE DEDENT
def findTripleSum ( A , B , C ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M NEW_LINE sum = ( sum + prod ) % M NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def getMaximum ( N , M , mat ) : NEW_LINE INDENT global_max = - 1 * ( sys . maxsize ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT row_min = sys . maxsize NEW_LINE for k in range ( 0 , M ) : NEW_LINE INDENT m = max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) NEW_LINE row_min = min ( row_min , m ) NEW_LINE DEDENT global_max = max ( global_max , row_min ) NEW_LINE DEDENT DEDENT return global_max NEW_LINE DEDENT
def minvalue_y ( x ) : NEW_LINE INDENT n = int ( pow ( x , 1 / 2 ) ) NEW_LINE if ( n * n == x ) : NEW_LINE INDENT return x + 1 NEW_LINE DEDENT return ( pow ( n + 1 , 2 ) ) NEW_LINE DEDENT
def alternatingSumOfFirst_N ( N ) : NEW_LINE INDENT alternateSum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT alternateSum += - i NEW_LINE DEDENT else : NEW_LINE INDENT alternateSum += i NEW_LINE DEDENT DEDENT return alternateSum NEW_LINE DEDENT
def alternatingSumOfFirst_N ( N ) : NEW_LINE INDENT alternateSum = 0 ; NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT alternateSum = ( - N ) // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT alternateSum = ( N + 1 ) // 2 ; NEW_LINE DEDENT return alternateSum ; NEW_LINE DEDENT
def minStartValue ( nums ) : NEW_LINE INDENT minValue = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT sum += nums [ i ] NEW_LINE minValue = min ( minValue , sum ) NEW_LINE DEDENT startValue = 1 - minValue NEW_LINE return startValue NEW_LINE DEDENT
def countXORSetBitsAdjElemRange1_N ( N ) : NEW_LINE INDENT total_set_bits = 0 NEW_LINE bit_Position = 1 NEW_LINE while ( N ) : NEW_LINE INDENT total_set_bits += ( ( N + 1 ) // 2 * bit_Position ) NEW_LINE N -= ( N + 1 ) // 2 NEW_LINE bit_Position += 1 NEW_LINE DEDENT return total_set_bits NEW_LINE DEDENT
def TotalBitwiseORPair ( arr , N ) : NEW_LINE INDENT totalOR = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalOR |= arr [ i ] ; NEW_LINE DEDENT return totalOR ; NEW_LINE DEDENT
def checkSolveable ( n , m ) : NEW_LINE INDENT if n == 1 or m == 1 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT elif m == 2 and n == 2 : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findNumbers ( n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( 2 * i * i + 4 * i + 1 + i % 2 , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def sumOfProd ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum * sum NEW_LINE DEDENT
def xor_operations ( N , arr , M , K ) : NEW_LINE INDENT if M < 0 or M >= N : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if K < 0 or K >= N - M : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for _ in range ( M ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT value = arr [ i ] ^ arr [ i + 1 ] NEW_LINE temp . append ( value ) NEW_LINE DEDENT arr = temp [ : ] NEW_LINE DEDENT ans = arr [ K ] NEW_LINE return ans NEW_LINE DEDENT
def checkPalindromeB ( N , B ) : NEW_LINE INDENT rev = 0 ; NEW_LINE N1 = N ; NEW_LINE while ( N1 > 0 ) : NEW_LINE INDENT rev = rev * B + N1 % B ; NEW_LINE N1 = N1 // B ; NEW_LINE DEDENT return N == rev ; NEW_LINE DEDENT
def countEqual ( n ) : NEW_LINE INDENT return ( n + 1 ) // 2 NEW_LINE DEDENT
def balancedTernary ( n ) : NEW_LINE INDENT output = " " NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 3 NEW_LINE n = n // 3 NEW_LINE if ( rem == 2 ) : NEW_LINE INDENT rem = - 1 NEW_LINE n += 1 NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT output = '0' + output NEW_LINE DEDENT else : NEW_LINE INDENT if ( rem == 1 ) : NEW_LINE INDENT output = '1' + output NEW_LINE DEDENT else : NEW_LINE INDENT output = ' Z ' + output NEW_LINE DEDENT DEDENT DEDENT return output NEW_LINE DEDENT
def max_valid_triplet ( A , n ) : NEW_LINE INDENT ans = - 1 ; NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( A [ i ] < A [ j ] and A [ j ] < A [ k ] ) : NEW_LINE INDENT value = A [ i ] + A [ j ] * A [ k ] ; NEW_LINE if ( value > ans ) : NEW_LINE INDENT ans = value ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT
def highestPower ( n ) : NEW_LINE INDENT return int ( ( math . log ( n ) // math . log ( 2 ) ) ) ; NEW_LINE DEDENT
def checkFactors ( N ) : NEW_LINE INDENT ev_count = 0 ; od_count = 0 ; NEW_LINE for i in range ( 1 , int ( pow ( N , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == N / i ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT if ( ( N / i ) % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ev_count % 2 == 0 and od_count % 2 == 1 ) : NEW_LINE INDENT print ( " Yes " + " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " + " " ) ; NEW_LINE DEDENT DEDENT
def countofPermutations ( N ) : NEW_LINE INDENT return int ( ( 3 * pow ( 2 , N - 1 ) ) ) ; NEW_LINE DEDENT
def answer ( L , R ) : NEW_LINE INDENT if ( 2 * L <= R ) : NEW_LINE INDENT print ( L , " , " , 2 * L ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def getProduct ( a , n ) : NEW_LINE INDENT p = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT p *= abs ( a [ i ] - a [ j ] ) NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT
def Kmultiples ( n , k ) : NEW_LINE INDENT a = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( " { } ▁ * ▁ { } ▁ = ▁ { } " . format ( n , i , a ) ) NEW_LINE j = 0 NEW_LINE while ( n >= ( 1 << j ) ) : NEW_LINE INDENT a += n & ( 1 << j ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def totalCountDifference ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n + totalCountDifference ( n // 2 ) NEW_LINE DEDENT
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left + 1 NEW_LINE d = arr [ 1 ] // arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] NEW_LINE if d == 1 : NEW_LINE INDENT ans = ans * d * k NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans * ( d ** k - 1 ) // ( d - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT res = 1 NEW_LINE if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def canBreakN ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT m = i * ( i + 1 ) // 2 NEW_LINE if ( m > n ) : NEW_LINE INDENT break NEW_LINE DEDENT k = n - m NEW_LINE if ( k % i ) : NEW_LINE INDENT continue NEW_LINE DEDENT print ( i ) NEW_LINE return NEW_LINE DEDENT print ( " - 1" ) NEW_LINE DEDENT
def isTriplet ( ar , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( abs ( ar [ i ] - ar [ j ] ) == 1 or abs ( ar [ j ] - ar [ k ] ) == 1 or abs ( ar [ i ] - ar [ k ] ) == 1 ) : NEW_LINE INDENT x = ar [ i ] * ar [ i ] NEW_LINE y = ar [ j ] * ar [ j ] NEW_LINE z = ar [ k ] * ar [ k ] NEW_LINE if ( x == y + z or y == x + z or z == x + y ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def is_possible ( x , y ) : NEW_LINE INDENT if ( x < 2 and y != 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT y = y - x + 1 NEW_LINE if ( y % 2 == 0 and y >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findTemperature ( x , y , s ) : NEW_LINE INDENT diff = ( x - y ) * 6 NEW_LINE Day2 = ( diff + s ) // 2 NEW_LINE Day1 = s - Day2 NEW_LINE print ( " Day1 ▁ : ▁ " , Day1 ) NEW_LINE print ( " Day2 ▁ : ▁ " , Day2 ) NEW_LINE DEDENT
def MinimumString ( x ) : NEW_LINE INDENT b = 1 NEW_LINE left_lim = sqrt ( x ) + 1.0 NEW_LINE right_lim = sqrt ( x ) + 2.0 NEW_LINE for i in range ( int ( left_lim ) , int ( right_lim ) + 1 ) : NEW_LINE INDENT if ( i > left_lim and i < right_lim ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT return b + r NEW_LINE DEDENT
def is_distinct ( n , k ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT tmp = n % i NEW_LINE if ( tmp in s ) : NEW_LINE INDENT return False NEW_LINE DEDENT s . add ( tmp ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def getDivisors ( min , n ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( min , n ) : NEW_LINE INDENT if ( n % i == 0 and n // i >= i ) : NEW_LINE INDENT total += 1 NEW_LINE if ( n // i > i ) : NEW_LINE INDENT total += getDivisors ( i , n // i ) NEW_LINE DEDENT DEDENT DEDENT return total NEW_LINE DEDENT
def findMinDenomin ( n ) : NEW_LINE INDENT return log2 ( n ) + 1 NEW_LINE DEDENT
def calculate ( p , q ) : NEW_LINE INDENT mod = 998244353 NEW_LINE expo = 0 NEW_LINE expo = mod - 2 NEW_LINE while ( expo ) : NEW_LINE INDENT if ( expo & 1 ) : NEW_LINE INDENT p = ( p * q ) % mod NEW_LINE DEDENT q = ( q * q ) % mod NEW_LINE expo >>= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def powerOptimised ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT last_bit = ( n & 1 ) NEW_LINE if ( last_bit ) : NEW_LINE INDENT ans = ans * a NEW_LINE DEDENT a = a * a NEW_LINE n = n >> 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxGCD ( N ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return N // i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def findMaximumGcd ( n ) : NEW_LINE INDENT max_gcd = 1 NEW_LINE i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if ( i > max_gcd ) : NEW_LINE INDENT max_gcd = i NEW_LINE DEDENT if ( ( n / i != i ) and ( n / i != n ) and ( ( n / i ) > max_gcd ) ) : NEW_LINE INDENT max_gcd = n / i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( int ( max_gcd ) ) NEW_LINE DEDENT
def linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) : NEW_LINE INDENT randomNums [ 0 ] = Xo NEW_LINE for i in range ( 1 , noOfRandomNums ) : NEW_LINE INDENT randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m NEW_LINE DEDENT DEDENT
def multiplicativeCongruentialMethod ( Xo , m , a , randomNums , noOfRandomNums ) : NEW_LINE INDENT randomNums [ 0 ] = Xo NEW_LINE for i in range ( 1 , noOfRandomNums ) : NEW_LINE INDENT randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m NEW_LINE DEDENT DEDENT
def additiveCongruentialMethod ( Xo , m , c , randomNums , noOfRandomNums ) : NEW_LINE INDENT randomNums [ 0 ] = Xo NEW_LINE for i in range ( 1 , noOfRandomNums ) : NEW_LINE INDENT randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m NEW_LINE DEDENT DEDENT
def numberOfObjects ( N , M ) : NEW_LINE INDENT initial = min ( N , M ) NEW_LINE final = ( N + M ) // 3 NEW_LINE return min ( initial , final ) NEW_LINE DEDENT
def SquareRoot ( num ) : NEW_LINE INDENT count = 0 NEW_LINE for n in range ( 1 , num + 1 , 2 ) : NEW_LINE INDENT num = num - n NEW_LINE count = count + 1 NEW_LINE if ( num == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def solve ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT temp = X NEW_LINE X = Y NEW_LINE Y = temp NEW_LINE DEDENT if ( X == Y ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( Y % X == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT
def DiStirngMatch ( Str ) : NEW_LINE INDENT N = len ( Str ) NEW_LINE arr = ( N + 1 ) * [ 0 ] NEW_LINE START , END = 0 , N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( Str [ i ] == ' I ' ) : NEW_LINE INDENT arr [ i ] = START NEW_LINE START += 1 NEW_LINE DEDENT if ( Str [ i ] == ' D ' ) : NEW_LINE INDENT arr [ i ] = END NEW_LINE END -= 1 NEW_LINE DEDENT DEDENT arr [ N ] = START NEW_LINE return arr NEW_LINE DEDENT
def IsPrime ( i ) : NEW_LINE INDENT if ( i % 2 == 0 and i != 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( 3 , int ( math . sqrt ( i ) + 1 ) , 2 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT DEDENT c = 0 ; NEW_LINE N = 72 ; NEW_LINE for i in range ( 2 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( IsPrime ( i ) ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT c = c + 1 NEW_LINE if ( IsPrime ( N / i ) and i != ( N / i ) ) : NEW_LINE INDENT c = c + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def isEqualFactors ( N ) : NEW_LINE INDENT ev_count = 0 NEW_LINE od_count = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( N ) ) + 2 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == N // i ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 NEW_LINE DEDENT if ( ( N // i ) % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ev_count == od_count ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def isEqualFactors ( N ) : NEW_LINE INDENT if ( ( N % 2 == 0 ) and ( N % 4 != 0 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findNumbers ( n , b ) : NEW_LINE INDENT largest = pow ( b , n ) - 1 NEW_LINE print ( largest ) NEW_LINE DEDENT
def compute ( a , N , K ) : NEW_LINE INDENT eqVal = defaultdict ( int ) NEW_LINE maxX = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = a [ i ] % K NEW_LINE if ( val != 0 ) : NEW_LINE INDENT val = K - val NEW_LINE DEDENT if ( val == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( val in eqVal ) : NEW_LINE INDENT numVal = eqVal [ val ] NEW_LINE maxX = max ( maxX , val + ( K * numVal ) ) NEW_LINE eqVal [ val ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT eqVal [ val ] += 1 NEW_LINE maxX = max ( maxX , val ) NEW_LINE DEDENT DEDENT if maxX == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( maxX + 1 ) NEW_LINE DEDENT DEDENT
def pen_hex ( n ) : NEW_LINE INDENT pn = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pn = ( int ) ( i * ( 3 * i - 1 ) / 2 ) NEW_LINE if ( pn > n ) : NEW_LINE INDENT break NEW_LINE DEDENT seqNum = ( 1 + math . sqrt ( 8 * pn + 1 ) ) / 4 NEW_LINE if ( seqNum == ( int ) ( seqNum ) ) : NEW_LINE INDENT print ( pn , end = " , ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT max_value = max ( arr ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( max_value arr [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def print_product ( a , b , c , d ) : NEW_LINE INDENT prod1 = a * c NEW_LINE prod2 = b * d NEW_LINE prod3 = ( a + b ) * ( c + d ) NEW_LINE real = prod1 - prod2 NEW_LINE imag = prod3 - ( prod1 + prod2 ) NEW_LINE print ( real , " ▁ + ▁ " , imag , " i " ) NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT if ( N < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = ( ( N - 1 ) * ( N - 2 ) ) // 2 NEW_LINE s = 0 NEW_LINE for i in range ( 2 , N - 2 , 1 ) : NEW_LINE INDENT for j in range ( 1 , i , 1 ) : NEW_LINE INDENT if ( N == 2 * i + j ) : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT s = 3 * s + 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = 3 * s NEW_LINE DEDENT return ans - s NEW_LINE DEDENT
def get_concentration ( mass , volume ) : NEW_LINE INDENT if ( volume == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( mass / volume ) * 1000 ; NEW_LINE DEDENT DEDENT
def PentacontahenagonNum ( N ) : NEW_LINE INDENT return ( 49 * N * N - 47 * N ) // 2 ; NEW_LINE DEDENT
def isInsolite ( n ) : NEW_LINE INDENT N = n ; NEW_LINE sum = 0 ; NEW_LINE product = 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 ; NEW_LINE sum = sum + r * r ; NEW_LINE product = product * r * r ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return ( ( N % sum == 0 ) and ( N % product == 0 ) ) ; NEW_LINE DEDENT
def isSaintExuperyNum ( n ) : NEW_LINE INDENT for i in range ( 1 , ( n // 3 ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , ( n // 2 ) + 1 ) : NEW_LINE INDENT k = n / i / j NEW_LINE if i * i + j * j == k * k : NEW_LINE INDENT if i * j * k == n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT N = 60 NEW_LINE if isSaintExuperyNum ( N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isRepdigit ( num , b ) : NEW_LINE INDENT prev = - 1 NEW_LINE while ( num ) : NEW_LINE INDENT digit = num % b NEW_LINE num //= b NEW_LINE if ( prev != - 1 and digit != prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = digit NEW_LINE DEDENT return True NEW_LINE DEDENT num = 2000 NEW_LINE base = 7 NEW_LINE if ( isRepdigit ( num , base ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * ( 3 * n + 1 ) // 2 , end = " ▁ " ) ; NEW_LINE DEDENT
def isIdoneal ( n ) : NEW_LINE INDENT for a in range ( 1 , n + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , n + 1 ) : NEW_LINE INDENT for c in range ( b + 1 , n + 1 ) : NEW_LINE INDENT if ( a * b + b * c + c * a == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT N = 10 NEW_LINE if ( isIdoneal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printhexa ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE third = 0 NEW_LINE fourth = 0 NEW_LINE fifth = 0 NEW_LINE sixth = 1 NEW_LINE curr = 0 NEW_LINE if ( n < 6 ) : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT print ( sixth ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 6 , n ) : NEW_LINE INDENT curr = first + second + third + fourth + fifth + sixth NEW_LINE first = second NEW_LINE second = third NEW_LINE third = fourth NEW_LINE fourth = fifth NEW_LINE fifth = sixth NEW_LINE sixth = curr NEW_LINE DEDENT DEDENT print ( curr ) NEW_LINE DEDENT
def isRepunitNum ( n , b ) : NEW_LINE INDENT length = 0 ; NEW_LINE countOne = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % b ; NEW_LINE length += 1 ; NEW_LINE if ( r == 1 ) : NEW_LINE INDENT countOne += 1 ; NEW_LINE DEDENT n = n // b ; NEW_LINE DEDENT return countOne >= 3 and countOne == length ; NEW_LINE DEDENT
def isPossible ( A , B , N , K , L ) : NEW_LINE INDENT needa = 0 NEW_LINE needb = 0 NEW_LINE if ( A % K == 0 ) : NEW_LINE INDENT needa = A // K ; NEW_LINE DEDENT else : NEW_LINE INDENT needa = A // K + 1 NEW_LINE DEDENT if ( B % L == 0 ) : NEW_LINE INDENT needb = B // L NEW_LINE DEDENT else : NEW_LINE INDENT needb = B // L + 1 NEW_LINE DEDENT total = needa + needb NEW_LINE if ( total > N ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def sumOfSumSeries ( N ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT _sum = _sum + ( i * ( i + 1 ) ) // 2 NEW_LINE DEDENT return _sum NEW_LINE DEDENT
def sumOfSumSeries ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) ) // 6 NEW_LINE DEDENT
def placeValue ( N , num ) : NEW_LINE INDENT total = 1 NEW_LINE value = 0 NEW_LINE rem = 0 NEW_LINE while ( True ) : NEW_LINE INDENT rem = N % 10 NEW_LINE N = N // 10 NEW_LINE if ( rem == num ) : NEW_LINE INDENT value = total * rem NEW_LINE break NEW_LINE DEDENT total = total * 10 NEW_LINE DEDENT return value NEW_LINE DEDENT
def BeattySequence ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = math . floor ( i * math . sqrt ( 2 ) ) NEW_LINE print ( ans , end = ' , ▁ ' ) NEW_LINE DEDENT DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for j in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
def icosikaienneagonalNum ( n ) : NEW_LINE INDENT return ( 27 * n * n - 25 * n ) // 2 NEW_LINE DEDENT
def SubArrayProdct ( arr , n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result *= pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
def averageRuns ( runs , matches , notout ) : NEW_LINE INDENT out = matches - notout ; NEW_LINE if ( out == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT avg = runs // out ; NEW_LINE return avg ; NEW_LINE DEDENT runs = 10000 ; NEW_LINE matches = 250 ; NEW_LINE notout = 50 ; NEW_LINE avg = averageRuns ( runs , matches , notout ) ; NEW_LINE if ( avg == - 1 ) : NEW_LINE INDENT print ( " NA " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( avg ) ; NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE currProd = 1 ; NEW_LINE currSum = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT currProd *= i ; NEW_LINE currSum += i ; NEW_LINE sum1 += currProd - currSum ; NEW_LINE DEDENT return sum1 ; NEW_LINE DEDENT
def solve ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT ans += N NEW_LINE N //= 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def maximumAND ( L , R ) : NEW_LINE INDENT return R NEW_LINE DEDENT
def count ( a , n ) : NEW_LINE INDENT countElements = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT flag = True NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i ] % a [ j ] == 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT countElements += 1 NEW_LINE DEDENT DEDENT return countElements NEW_LINE DEDENT
def countPairs ( A , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 0 and A [ j ] % 2 == 0 ) or ( A [ i ] % 2 != 0 and A [ j ] % 2 != 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT L = pow ( 10 , N ) - 1 ; NEW_LINE S = pow ( 10 , N - 1 ) ; NEW_LINE for i in range ( S , L ) : NEW_LINE INDENT if ( i % N == 0 ) : NEW_LINE INDENT print ( i ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT return N * math . ceil ( pow ( 10 , ( N - 1 ) ) // N ) ; NEW_LINE DEDENT
def CountPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 or arr [ j ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def CountPairs ( arr , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT return ( ( even * ( even - 1 ) ) // 2 + ( even * odd ) ) NEW_LINE DEDENT
def isPal ( a , n , m ) : NEW_LINE INDENT for i in range ( 0 , n // 2 ) : NEW_LINE INDENT for j in range ( 0 , m - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT
def smallestNum ( n ) : NEW_LINE INDENT return ( ( n * n % 9 + 1 ) * pow ( 10 , int ( n * n / 9 ) ) - 1 ) NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT print ( ( N % 9 + 1 ) * pow ( 10 , ( N // 9 ) ) - 1 ) NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * ( 5 * n + 3 ) // 2 ) NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * ( 2 * n + 1 ) ) NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * ( 4 * n + 3 ) ) NEW_LINE DEDENT
def isStraighLineNum ( N ) : NEW_LINE INDENT if ( N <= 99 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT str1 = str ( N ) ; NEW_LINE d = int ( str1 [ 1 ] ) - int ( str1 [ 0 ] ) ; NEW_LINE for i in range ( 2 , len ( str1 ) ) : NEW_LINE INDENT if ( int ( str1 [ i ] ) - int ( str1 [ i - 1 ] ) != d ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT N = 135 ; NEW_LINE if ( isStraighLineNum ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( pow ( 2 , n ) - 2 * n ) ; NEW_LINE DEDENT
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * n - n + 1 ) NEW_LINE DEDENT
def DecakismyriagonNum ( N ) : NEW_LINE INDENT return ( 99998 * N * N - 99996 * N ) // 2 ; NEW_LINE DEDENT
def iszygodromeNum ( N ) : NEW_LINE INDENT s = str ( N ) ; NEW_LINE s = ' ▁ ' + s + ' ▁ ' ; NEW_LINE i = 1 NEW_LINE while i < len ( s ) - 1 : NEW_LINE INDENT if ( ( s [ i ] != s [ i - 1 ] ) and ( s [ i ] != s [ i + 1 ] ) ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True ; NEW_LINE DEDENT
def isLoeschian ( n ) : NEW_LINE INDENT for x in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT for y in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( x * x + x * y + y * y == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT N = 19 NEW_LINE if ( isLoeschian ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printSeries ( N ) : NEW_LINE INDENT ith_term = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; NEW_LINE print ( int ( ith_term ) , " , ▁ " , end = " " ) ; NEW_LINE DEDENT DEDENT
def strikerate ( bowls , runs ) : NEW_LINE INDENT z = ( float ( runs ) / bowls ) * 100 ; NEW_LINE return z ; NEW_LINE DEDENT
def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def check ( n ) : NEW_LINE INDENT digits = set ( ) NEW_LINE temp = n NEW_LINE Sum = 0 NEW_LINE count = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT Sum += temp % 10 NEW_LINE digits . add ( temp % 10 ) NEW_LINE count += 1 NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( ( Sum % count == 0 ) and ( ( int ) ( Sum / count ) in digits ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findPosition ( n ) : NEW_LINE INDENT i = 0 NEW_LINE pos = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == 7 ) : NEW_LINE INDENT pos = pos + pow ( 2 , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = pos + pow ( 2 , i ) NEW_LINE DEDENT i += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT print ( pos ) NEW_LINE DEDENT
def findAverageOfCube ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i * i NEW_LINE DEDENT return round ( sum / n , 6 ) NEW_LINE DEDENT
def greatestOddFactor ( n ) : NEW_LINE INDENT pow_2 = int ( math . log ( n , 2 ) ) NEW_LINE i = 1 NEW_LINE while i <= pow_2 : NEW_LINE INDENT fac_2 = ( 2 ** i ) NEW_LINE if ( n % fac_2 == 0 ) : NEW_LINE if ( ( n // fac_2 ) % 2 == 1 ) : NEW_LINE INDENT print ( n // fac_2 ) NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def canReplace ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE count = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == 0 and ( i == 0 or arr [ i - 1 ] == 0 ) and ( i == n - 1 or arr [ i + 1 ] == 0 ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countSmaller ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ j ] < str [ i ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT print ( cnt , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def sum_star_num ( n ) : NEW_LINE INDENT summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n NEW_LINE return summ NEW_LINE DEDENT
def gonNum65537 ( n ) : NEW_LINE INDENT return ( 65535 * n * n - 65533 * n ) // 2 ; NEW_LINE DEDENT
def EnneacontahexagonNum ( n ) : NEW_LINE INDENT return ( 94 * n * n - 92 * n ) // 2 ; NEW_LINE DEDENT
def MegagonNum ( n ) : NEW_LINE INDENT return ( 999998 * n * n - 999996 * n ) // 2 ; NEW_LINE DEDENT
def gonNum360 ( n ) : NEW_LINE INDENT return ( 358 * n * n - 356 * n ) // 2 ; NEW_LINE DEDENT
def gonNum120 ( n ) : NEW_LINE INDENT return ( 118 * n * n - 116 * n ) // 2 ; NEW_LINE DEDENT
def TetracontaoctagonalNum ( n ) : NEW_LINE INDENT return ( 46 * n * n - 44 * n ) / 2 ; NEW_LINE DEDENT
def gonNum257 ( n ) : NEW_LINE INDENT return ( 255 * n * n - 253 * n ) // 2 ; NEW_LINE DEDENT
def TetracontadigonalNum ( n ) : NEW_LINE INDENT return int ( ( 40 * n * n - 38 * n ) / 2 ) NEW_LINE DEDENT
def HexacontatetragonNum ( n ) : NEW_LINE INDENT return ( 62 * n * n - 60 * n ) / 2 ; NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT x = math . sqrt ( 2 * math . pow ( 10 , ( n - 1 ) ) ) ; NEW_LINE return round ( x ) ; NEW_LINE DEDENT
def isPossible ( A , B ) : NEW_LINE INDENT return ( A - B > 1 ) ; NEW_LINE DEDENT A = 10 ; B = 4 ; NEW_LINE if ( isPossible ( A , B ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def smallestSumpair ( arr , n ) : NEW_LINE INDENT pair = [ ] NEW_LINE min_sum = sys . maxsize NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if min_sum > ( arr [ i ] + arr [ i - 1 ] ) : NEW_LINE INDENT min_sum = arr [ i ] + arr [ i - 1 ] NEW_LINE if pair == [ ] : NEW_LINE INDENT pair . append ( arr [ i - 1 ] ) NEW_LINE pair . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT pair [ 0 ] = arr [ i - 1 ] NEW_LINE pair [ 1 ] = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return pair NEW_LINE DEDENT
def findLCMPrime ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return a * b ; NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT print ( N * ceil ( pow ( 2 , ( N - 1 ) ) / N ) ) NEW_LINE DEDENT
def smallestNumber ( N ) : NEW_LINE INDENT print ( N * floor ( ( pow ( 10 , N ) - 1 ) / N ) ) NEW_LINE DEDENT
def icosikaipentagonNum ( N ) : NEW_LINE INDENT return ( 23 * N * N - 21 * N ) // 2 NEW_LINE DEDENT
def icosikaiheptagonalNum ( n ) : NEW_LINE INDENT return ( 25 * n * n - 23 * n ) // 2 ; NEW_LINE DEDENT
def istriacontagonal ( N ) : NEW_LINE INDENT n = ( 26 + math . sqrt ( 224 * N + 676 ) ) // 56 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT i = 30 ; NEW_LINE if ( istriacontagonal ( i ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def getParity ( n , A ) : NEW_LINE INDENT for x in A : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Odd " ) NEW_LINE DEDENT
def numberOfDigits ( N ) : NEW_LINE INDENT nod = floor ( log10 ( N ) + 1 ) ; NEW_LINE toDecrease = ( pow ( 10 , nod ) - 1 ) // 9 NEW_LINE print ( ( N + 1 ) * nod - toDecrease ) NEW_LINE DEDENT
def lastTwoDigits ( N ) : NEW_LINE INDENT if ( N >= 10 ) : NEW_LINE INDENT print ( "00" , end = " " ) NEW_LINE return NEW_LINE DEDENT fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = ( fac * i ) % 100 NEW_LINE DEDENT print ( fac ) NEW_LINE DEDENT
def productOfGP ( a , r , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * a ; NEW_LINE a = a * r ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT
def productOfGP ( a , r , n ) : NEW_LINE INDENT return pow ( a , n ) * pow ( r , n * ( n - 1 ) // 2 ) ; NEW_LINE DEDENT
def productOfGP ( a , r , n ) : NEW_LINE INDENT an = a * pow ( r , n - 1 ) ; NEW_LINE return ( math . sqrt ( pow ( a * an , n ) ) ) NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT for x in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % x == 0 ) : NEW_LINE INDENT small = x ; NEW_LINE big = n // x ; NEW_LINE if ( small % 2 == big % 2 ) : NEW_LINE INDENT a = ( small + big ) // 2 ; NEW_LINE b = ( big - small ) // 2 ; NEW_LINE print ( a , b ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) ; NEW_LINE DEDENT
def is_Chiliagon ( N ) : NEW_LINE INDENT n = ( 996 + math . sqrt ( 7984 * N + 992016 ) ) // 1996 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT N = 1000 ; NEW_LINE if ( is_Chiliagon ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def checkDivisbility ( num ) : NEW_LINE INDENT digit = 0 NEW_LINE N = num NEW_LINE while ( num != 0 ) : NEW_LINE INDENT digit = num % 10 NEW_LINE num = num // 10 NEW_LINE if ( digit == 0 or N % digit != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findArrangement ( N ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) // 3 ; NEW_LINE DEDENT
def CheckBinaryEquivalent ( N ) : NEW_LINE INDENT return ( N - 1 ) % 8 == 0 ; NEW_LINE DEDENT
def maxDivision ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE mxdiv = arr [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT mxdiv = mxdiv / arr [ i ] NEW_LINE DEDENT return arr [ 0 ] / mxdiv NEW_LINE DEDENT
def sumOfProductOfDigits ( n1 , n2 ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE while ( n1 > 0 and n2 > 0 ) : NEW_LINE INDENT sum1 += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; NEW_LINE n1 = n1 // 10 ; NEW_LINE n2 = n2 // 10 ; NEW_LINE DEDENT return sum1 ; NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT upper_limit = ceil ( pow ( n , 1.0 / 4 ) ) ; NEW_LINE for x in range ( upper_limit + 1 ) : NEW_LINE INDENT for y in range ( upper_limit + 1 ) : NEW_LINE INDENT num1 = x * x * x * x ; NEW_LINE num2 = y * y * y * y ; NEW_LINE if ( num1 - num2 == n ) : NEW_LINE INDENT print ( " x ▁ = " , x , " , ▁ y ▁ = " , y ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) ; NEW_LINE DEDENT
def productPairs ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; NEW_LINE product = product % mod ; NEW_LINE DEDENT DEDENT return product % mod ; NEW_LINE DEDENT
def operation ( arr , N ) : NEW_LINE INDENT right = 0 ; ans = 0 ; NEW_LINE num = 0 ; NEW_LINE for left in range ( 0 , N ) : NEW_LINE INDENT while ( right < N and num + arr [ right ] == ( num ^ arr [ right ] ) ) : NEW_LINE INDENT num += arr [ right ] ; NEW_LINE right += 1 ; NEW_LINE DEDENT ans += right - left ; NEW_LINE if ( left == right ) : NEW_LINE INDENT right += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT num -= arr [ left ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def divisorsSame ( n ) : NEW_LINE INDENT return ( n - 2 ) % 4 == 0 ; NEW_LINE DEDENT N = 6 ; NEW_LINE if ( divisorsSame ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def Convert ( degree ) : NEW_LINE INDENT pi = 3.14159265359 ; NEW_LINE return ( degree * ( pi / 180 ) ) ; NEW_LINE DEDENT
def checkSolution ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT return ( ( a1 / a2 ) == ( b1 / b2 ) and ( b1 / b2 ) == ( c1 / c2 ) ) NEW_LINE DEDENT a1 , b1 , c1 = 1 , - 5 , 6 NEW_LINE a2 , b2 , c2 = 2 , - 10 , 12 NEW_LINE if ( checkSolution ( a1 , b1 , c1 , a2 , b2 , c2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def chiliagonNum ( n ) : NEW_LINE INDENT return ( 998 * n * n - 996 * n ) // 2 ; NEW_LINE DEDENT
def checkSolution ( a , b , c ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def pentacontagonNum ( n ) : NEW_LINE INDENT return ( 48 * n * n - 46 * n ) // 2 NEW_LINE DEDENT
def findPair ( x ) : NEW_LINE INDENT lim = 120 NEW_LINE for i in range ( - lim , lim + 1 ) : NEW_LINE INDENT for j in range ( - lim , lim + 1 ) : NEW_LINE INDENT if ( math . pow ( i , 5 ) - math . pow ( j , 5 ) == x ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE print ( j , end =   ' ' ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT
def checkIsFibonacci ( arr , n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT
def lastDigitFactorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : return 1 NEW_LINE elif ( n <= 2 ) : return n NEW_LINE elif ( n == 3 ) : return 6 NEW_LINE elif ( n == 4 ) : return 4 NEW_LINE else : return 0 NEW_LINE DEDENT
def lastDigit2PowerN ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n % 4 == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif n % 4 == 2 : NEW_LINE INDENT return 4 NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT return 8 NEW_LINE DEDENT else : NEW_LINE DEDENT for n in range ( 20 ) : NEW_LINE INDENT print ( lastDigit2PowerN ( n ) , end = " ▁ " ) NEW_LINE DEDENT
def findSum ( n , k ) : NEW_LINE INDENT val = ( k // ( n - 1 ) ) * n ; NEW_LINE rem = k % ( n - 1 ) ; NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT val = val - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT val = val + rem ; NEW_LINE DEDENT sum = ( val * ( val + 1 ) ) // 2 ; NEW_LINE x = k // ( n - 1 ) ; NEW_LINE sum_of_multiples = ( x * ( x + 1 ) * n ) // 2 ; NEW_LINE sum -= sum_of_multiples ; NEW_LINE return sum ; NEW_LINE DEDENT
def bcdToHexaDecimal ( s ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE check = 0 NEW_LINE num = 0 NEW_LINE sum = 0 NEW_LINE mul = 1 NEW_LINE ans = [ ] NEW_LINE i = len1 - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT sum += ( ord ( s [ i ] ) - ord ( '0' ) ) * mul NEW_LINE mul *= 2 NEW_LINE check += 1 NEW_LINE if ( check == 4 or i == 0 ) : NEW_LINE INDENT if ( sum <= 9 ) : NEW_LINE INDENT ans . append ( chr ( sum + ord ( '0' ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( chr ( sum + 55 ) ) ; NEW_LINE DEDENT check = 0 NEW_LINE sum = 0 NEW_LINE mul = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT len1 = len ( ans ) NEW_LINE i = len1 - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT
def isMyriagon ( N ) : NEW_LINE INDENT n = ( 9996 + math . sqrt ( 79984 * N + 99920016 ) ) / 19996 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT n = 10000 NEW_LINE if ( isMyriagon ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isdecagonal ( N ) : NEW_LINE INDENT n = ( 3 + math . sqrt ( 16 * N + 9 ) ) / 8 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isOctadecagon ( N ) : NEW_LINE INDENT n = ( 14 + math . sqrt ( 128 * N + 196 ) ) // 32 NEW_LINE return ( ( n - int ( n ) ) == 0 ) NEW_LINE DEDENT
def isoctagonal ( N ) : NEW_LINE INDENT n = ( 2 + sqrt ( 12 * N + 4 ) ) / 6 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT
def isheptagonal ( N ) : NEW_LINE INDENT n = ( 3 + math . sqrt ( 40 * N + 9 ) ) / 10 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT N = 7 NEW_LINE if ( isheptagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPentadecagon ( N ) : NEW_LINE INDENT n = ( 11 + sqrt ( 104 * N + 121 ) ) / 26 ; NEW_LINE return ( n - int ( n ) == 0 ) ; NEW_LINE DEDENT
def longestEvenOddSubarray ( arr , n ) : NEW_LINE INDENT longest = 1 NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ i + 1 ] ) % 2 == 1 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT else : NEW_LINE INDENT longest = max ( longest , cnt ) NEW_LINE cnt = 1 NEW_LINE DEDENT DEDENT if ( longest == 1 ) : NEW_LINE return 0 NEW_LINE return max ( cnt , longest ) NEW_LINE DEDENT
def ishendecagonal ( N ) : NEW_LINE INDENT n = ( 7 + math . sqrt ( 72 * N + 49 ) ) // 18 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT N = 11 ; NEW_LINE if ( ishendecagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def istetradecagonal ( N ) : NEW_LINE INDENT n = ( 10 + math . sqrt ( 96 * N + 100 ) ) / 24 NEW_LINE if ( n - int ( n ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT N = 11 NEW_LINE if ( istetradecagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def ishexadecagonal ( N ) : NEW_LINE INDENT n = ( 12 + sqrt ( 112 * N + 144 ) ) / 28 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT
def isnonagonal ( N ) : NEW_LINE INDENT n = ( 5 + pow ( ( 56 * N + 25 ) , 1 / 2 ) ) / 14 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT
def isenneadecagonal ( N ) : NEW_LINE INDENT n = ( 15 + math . sqrt ( 136 * N + 225 ) ) / 34 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT N = 19 NEW_LINE if ( isenneadecagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def divParts ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT print ( ( N / 2 ) - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( N / 2 ) ; NEW_LINE DEDENT DEDENT
def getMinSteps ( n , jump ) : NEW_LINE INDENT quotient = int ( n / jump ) NEW_LINE remainder = n % jump NEW_LINE steps = quotient + remainder NEW_LINE return steps NEW_LINE DEDENT
def constructArray ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def isCenteredtridecagonal ( N ) : NEW_LINE INDENT n = ( 13 + np . sqrt ( 104 * N + 65 ) ) / 26 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT N = 14 NEW_LINE if ( isCenteredtridecagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isCenteredpentagonal ( N ) : NEW_LINE INDENT n = ( 5 + np . sqrt ( 40 * N - 15 ) ) / 10 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT N = 6 NEW_LINE if ( isCenteredpentagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isCentereddecagonal ( N ) : NEW_LINE INDENT n = ( 5 + np . sqrt ( 20 * N + 5 ) ) / 10 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT N = 11 NEW_LINE if ( isCentereddecagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isdodecagonal ( N ) : NEW_LINE INDENT n = ( 4 + np . sqrt ( 20 * N + 16 ) ) / 10 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT N = 12 NEW_LINE if ( isdodecagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def nDigitPerfectSquares ( n , b ) : NEW_LINE INDENT largest = pow ( math . ceil ( math . sqrt ( pow ( b , n ) ) ) - 1 , 2 ) NEW_LINE print ( largest ) NEW_LINE DEDENT
def findNum ( n , k ) : NEW_LINE INDENT q = k // ( n - 1 ) NEW_LINE r = k % ( n - 1 ) NEW_LINE if ( r != 0 ) : NEW_LINE INDENT a = ( n * q ) + r NEW_LINE DEDENT else : NEW_LINE INDENT a = ( n * q ) - 1 NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT
def cubeRoot ( n ) : NEW_LINE INDENT ans = pow ( 3 , ( 1.0 / 3 ) * ( np . log ( n ) / np . log ( 3 ) ) ) NEW_LINE return ans NEW_LINE DEDENT
def floorMax ( A , B , N ) : NEW_LINE INDENT x = min ( B - 1 , N ) NEW_LINE return ( A * x ) // B NEW_LINE DEDENT
def calculateMoves ( n ) : NEW_LINE INDENT count = 0 NEW_LINE layers = n // 2 NEW_LINE for k in range ( 1 , layers + 1 ) : NEW_LINE INDENT count += 8 * k * k NEW_LINE DEDENT return count NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N - 1 ) * ( N - 2 ) / 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def isSumSquare ( N ) : NEW_LINE INDENT n = ( 2 + math . sqrt ( 8 * N - 4 ) ) / 2 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isCenteredheptagonal ( N ) : NEW_LINE INDENT n = ( 7 + math . sqrt ( 56 * N - 7 ) ) / 14 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT n = 8 NEW_LINE if ( isCenteredheptagonal ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isCenterednonadecagonal ( N ) : NEW_LINE INDENT n = ( 19 + math . sqrt ( 152 * N + 209 ) ) / 38 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT n = 20 ; NEW_LINE if ( isCenterednonadecagonal ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def isCenteredOctadecagonal ( N ) : NEW_LINE INDENT n = ( 9 + math . sqrt ( 36 * N + 45 ) ) / 18 ; NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( math . ceil ( math . log ( n ) // math . log ( 2 ) ) == math . floor ( math . log ( n ) // math . log ( 2 ) ) ) ; NEW_LINE DEDENT
def kth_root ( n , k ) : NEW_LINE INDENT return ( pow ( k , ( ( 1.0 / k ) * ( math . log ( n ) / math . log ( k ) ) ) ) ) NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT return ( math . floor ( math . log10 ( n ) + 1 ) ) NEW_LINE DEDENT
def isPower ( n , k ) : NEW_LINE INDENT res1 = int ( log ( n ) / log ( k ) ) NEW_LINE res2 = log ( n ) / log ( k ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT
def subarray ( arr , n ) : NEW_LINE INDENT ans , temp = 1 , 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT temp = temp + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , temp ) NEW_LINE temp = 1 NEW_LINE DEDENT DEDENT ans = max ( ans , temp ) NEW_LINE return ans NEW_LINE DEDENT
def first_digit ( x , y ) : NEW_LINE INDENT length = int ( math . log ( x ) / math . log ( y ) + 1 ) NEW_LINE first_digit = x / math . pow ( y , length - 1 ) NEW_LINE print ( int ( first_digit ) ) NEW_LINE DEDENT
def kthRoot ( n , k ) : NEW_LINE INDENT return pow ( k , ( ( 1.0 / k ) * ( np . log ( n ) / np . log ( k ) ) ) ) NEW_LINE DEDENT
def checksum ( n , k ) : NEW_LINE INDENT first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 NEW_LINE if ( first_term - int ( first_term ) == 0 ) : NEW_LINE INDENT for i in range ( int ( first_term ) , int ( first_term ) + k ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT
def distributeN ( A , B , C , n ) : NEW_LINE INDENT maximum = max ( A , B , C ) NEW_LINE sum = A + B + C NEW_LINE p = ( 3 * maximum ) - sum NEW_LINE diff = n - p NEW_LINE if diff < 0 or diff % 3 : NEW_LINE INDENT print " No " NEW_LINE DEDENT else : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT DEDENT
def minimumSteps ( a , b , c ) : NEW_LINE INDENT if a < 1 or b < 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if a == 1 and b == 1 : NEW_LINE INDENT return c NEW_LINE DEDENT if a < b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return minimumSteps ( a - b , b , c + 1 ) NEW_LINE DEDENT
def count_pairs ( x ) : NEW_LINE INDENT ans = 1 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 2 == 1 ) : NEW_LINE INDENT ans = ans * 3 ; NEW_LINE DEDENT x = x // 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT r = math . ceil ( math . sqrt ( math . pow ( 10 , n ) ) ) ; NEW_LINE l = math . ceil ( math . sqrt ( math . pow ( 10 , n - 1 ) ) ) ; NEW_LINE return r - l ; NEW_LINE DEDENT
def summation ( N ) : NEW_LINE INDENT co = ( N + 1 ) / 2 NEW_LINE co = int ( co ) NEW_LINE ce = N / 2 NEW_LINE ce = int ( ce ) NEW_LINE se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) NEW_LINE so = ( co * co ) * ( 2 * ( co * co ) - 1 ) NEW_LINE return so - se NEW_LINE DEDENT
def isStar ( N ) : NEW_LINE INDENT n = ( math . sqrt ( 24 * N + 12 ) + 6 ) / 6 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT i = 13 NEW_LINE if isStar ( i ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def sumEvenNumbers ( N , K ) : NEW_LINE INDENT check = N - 2 * ( K - 1 ) NEW_LINE if ( check > 0 and check % 2 == 0 ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( "2 ▁ " , end = " " ) NEW_LINE DEDENT print ( check ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def computeMaxValue ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT val = max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) NEW_LINE ans = max ( ans , val ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def checkIfCurzonNumber ( N ) : NEW_LINE INDENT powerTerm , productTerm = 0 , 0 NEW_LINE powerTerm = pow ( 2 , N ) + 1 NEW_LINE productTerm = 2 * N + 1 NEW_LINE if ( powerTerm % productTerm == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def kthNonDivisible ( N , K ) : NEW_LINE INDENT return K + math . floor ( ( K - 1 ) / ( N - 1 ) ) NEW_LINE DEDENT
def isHexagonal ( N ) : NEW_LINE INDENT val = 8 * N + 1 NEW_LINE x = 1 + sqrt ( val ) NEW_LINE n = x / 4 NEW_LINE if ( ( n - int ( n ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def minCount ( n ) : NEW_LINE INDENT hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] NEW_LINE if ( n > 69 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( n >= hasharr [ n % 10 ] * 7 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT
def Solve ( arr , n ) : NEW_LINE INDENT temp = 0 ; count = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp = temp + arr [ j ] ; NEW_LINE if ( ( temp + 2 ) % 4 != 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def prodSquare ( n ) : NEW_LINE INDENT for i in range ( 2 , ( n ) + 1 ) : NEW_LINE INDENT if ( i * i < ( n + 1 ) ) : NEW_LINE INDENT for j in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( ( i * i * j * j ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return False ; NEW_LINE DEDENT
def prodSquare ( n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT s [ i * i ] = 1 NEW_LINE if ( ( n // ( i * i ) ) in s ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def printPair ( n ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE print ( n - 1 ) NEW_LINE DEDENT
def printArr ( n ) : NEW_LINE INDENT if ( n % 4 == 0 ) : NEW_LINE INDENT for i in range ( 1 , ( n / 2 ) + 1 ) : NEW_LINE INDENT print ( i * 2 , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n / 2 ) : NEW_LINE INDENT print ( i * 2 - 1 , end = " ▁ " ) NEW_LINE DEDENT print ( n + n / 2 - 1 , end =   " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def maxOR ( arr , n ) : NEW_LINE INDENT max_value = max ( arr ) NEW_LINE number_of_bits = floor ( log2 ( max_value ) ) + 1 NEW_LINE complement = ( ( ( 1 << number_of_bits ) - 1 ) ^ max_value ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != max_value ) : NEW_LINE INDENT c = max ( c , ( complement & arr [ i ] ) ) NEW_LINE DEDENT DEDENT return ( max_value + c ) NEW_LINE DEDENT
def findNumbers ( N ) : NEW_LINE INDENT for i in range ( 1 , N // 2 + 1 ) : NEW_LINE INDENT print ( i , end = ' , ▁ ' ) NEW_LINE print ( - i , end = ' , ▁ ' ) NEW_LINE DEDENT if N % 2 == 1 : NEW_LINE INDENT print ( 0 , end = ' ' ) NEW_LINE DEDENT DEDENT
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE multi = x NEW_LINE print ( 1 , end = " ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT total = total + multi NEW_LINE print ( ' % .1f ' % multi , end = " ▁ " ) NEW_LINE multi = multi * x NEW_LINE DEDENT print ( ' ' ) NEW_LINE return total ; NEW_LINE DEDENT
def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def factors ( n ) : NEW_LINE INDENT print ( "1 ▁ - - > 1" ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( i , " ▁ - - > " , end = " " ) ; NEW_LINE for j in range ( 1 , int ( pow ( i , 1 ) ) ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT print ( j , " , ▁ " , end = " " ) ; NEW_LINE if ( i // j != j ) : NEW_LINE INDENT print ( i // j , " , ▁ " , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT print ( end =   " " ) ; NEW_LINE DEDENT DEDENT
def countPalindromic ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT count = pow ( 9 , ( n - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT count = pow ( 9 , ( n - 2 ) // 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def countSubArrayWithOddProduct ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE last = - 1 NEW_LINE K = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT K = ( i - last - 1 ) NEW_LINE count += ( K * ( K + 1 ) / 2 ) NEW_LINE last = i NEW_LINE DEDENT DEDENT K = ( N - last - 1 ) NEW_LINE count += ( K * ( K + 1 ) / 2 ) NEW_LINE return count NEW_LINE DEDENT
def findMinXORSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return NEW_LINE DEDENT res_index = 0 NEW_LINE curr_xor = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ i ] NEW_LINE DEDENT min_xor = curr_xor NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) NEW_LINE if ( curr_xor < min_xor ) : NEW_LINE INDENT min_xor = curr_xor NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( min_xor , end =   ' ' ) NEW_LINE DEDENT
def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT
def findProb ( l , r ) : NEW_LINE INDENT countOfPS = ( math . floor ( math . sqrt ( r ) ) - math . ceil ( math . sqrt ( l ) ) + 1 ) NEW_LINE total = r - l + 1 NEW_LINE prob = countOfPS / total NEW_LINE return prob NEW_LINE DEDENT
def minNum ( n , k ) : NEW_LINE INDENT x = int ( ( math . log ( n ) // math . log ( k ) ) ) + 1 NEW_LINE mn = pow ( k , x ) - n NEW_LINE return mn NEW_LINE DEDENT
def findCount ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] % 2 == 0 ) and ( arr [ j ] % 2 == 1 ) ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def findCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + count NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def product ( arr ) : NEW_LINE INDENT occurrence = pow ( 2 , len ( arr ) - 1 ) ; NEW_LINE product = 1 ; NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT product *= pow ( arr [ i ] , occurrence ) ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT
def calcCount ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( k % arr [ i ] == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def modifiedBinaryPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 , 1 ) : NEW_LINE INDENT if ( j == 1 or j == i ) : NEW_LINE INDENT print ( 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE DEDENT DEDENT print ( ' ' , end = " " ) NEW_LINE DEDENT DEDENT
def maxPointCount ( arr , K , size ) : NEW_LINE INDENT curr_points = 0 NEW_LINE max_points = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT curr_points += arr [ i ] NEW_LINE DEDENT max_points = curr_points NEW_LINE j = size - 1 NEW_LINE for i in range ( K - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_points = ( curr_points + arr [ j ] - arr [ i ] ) NEW_LINE max_points = max ( curr_points , max_points ) NEW_LINE j -= 1 NEW_LINE DEDENT return max_points NEW_LINE DEDENT
def count ( N , B ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += ( B - 1 ) * pow ( B , i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def SmallestPerfectSquare ( N ) : NEW_LINE INDENT X = 1e9 NEW_LINE for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if N % i == 0 : NEW_LINE INDENT a = i NEW_LINE b = N // i NEW_LINE if b - a != 0 and ( b - a ) % 2 == 0 : NEW_LINE INDENT X = min ( X , ( b - a ) // 2 ) NEW_LINE DEDENT DEDENT DEDENT return ( X * X if X != 1e9 else - 1 ) NEW_LINE DEDENT
def CountWays ( N , M ) : NEW_LINE INDENT count = 1 NEW_LINE count = pow ( 3 , M + N ) NEW_LINE count *= pow ( 2 , M * N ) ; NEW_LINE return count NEW_LINE DEDENT
def minCost ( arr , n , circumference ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE arr2 = [ 0 ] * ( 2 * n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] NEW_LINE arr2 [ i + n ] = arr [ i ] + circumference NEW_LINE DEDENT res = 9999999999999999999 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def CountWays ( n ) : NEW_LINE INDENT ans = ( n - 1 ) // 2 NEW_LINE return ans NEW_LINE DEDENT
def findNthNumber ( N ) : NEW_LINE INDENT arr = [ 0 for i in range ( N + 1 ) ] NEW_LINE q = [ ] NEW_LINE for i in range ( 1 , 10 , 1 ) : NEW_LINE INDENT q . append ( i ) NEW_LINE DEDENT for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = q [ 0 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE if ( arr [ i ] % 10 != 0 ) : NEW_LINE INDENT q . append ( arr [ i ] * 10 + arr [ i ] % 10 - 1 ) NEW_LINE DEDENT q . append ( arr [ i ] * 10 + arr [ i ] % 10 ) NEW_LINE if ( arr [ i ] % 10 != 9 ) : NEW_LINE INDENT q . append ( arr [ i ] * 10 + arr [ i ] % 10 + 1 ) NEW_LINE DEDENT DEDENT print ( arr [ N ] ) NEW_LINE DEDENT
def findUniqueElements ( arr , N , K ) : NEW_LINE INDENT s = set ( ) NEW_LINE for x in arr : NEW_LINE INDENT s . add ( x ) NEW_LINE DEDENT arr_sum = sum ( arr ) NEW_LINE set_sum = 0 NEW_LINE for x in s : NEW_LINE INDENT set_sum += x NEW_LINE DEDENT print ( ( K * set_sum - arr_sum ) // ( K - 1 ) ) NEW_LINE DEDENT
def stepRequired ( N ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE while ( N > 0 ) : NEW_LINE INDENT N = N & ( N - 1 ) ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT
def findEquation ( a , b , c ) : NEW_LINE INDENT X = ( a + b + c ) ; NEW_LINE Y = ( a * b ) + ( b * c ) + ( c * a ) ; NEW_LINE Z = ( a * b * c ) ; NEW_LINE print ( " x ^ 3 ▁ - ▁ " , X , " x ^ 2 ▁ + ▁ " , Y , " x ▁ - ▁ " , Z , " ▁ = ▁ 0" ) ; NEW_LINE DEDENT
def numPrimeArrangements ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT factor = 2 NEW_LINE while factor * i <= n : NEW_LINE INDENT prime [ factor * i ] = False NEW_LINE factor += 1 NEW_LINE DEDENT DEDENT DEDENT primeIndices = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT primeIndices += 1 NEW_LINE DEDENT DEDENT mod = 1000000007 NEW_LINE res = 1 NEW_LINE for i in range ( 1 , primeIndices + 1 ) : NEW_LINE INDENT res = ( res * i ) % mod NEW_LINE DEDENT for i in range ( 1 , n - primeIndices + 1 ) : NEW_LINE INDENT res = ( res * i ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def PrintReverseOrder ( N ) : NEW_LINE INDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def PrintReverseOrder ( N ) : NEW_LINE INDENT if ( N <= 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , end = " ▁ " ) ; NEW_LINE PrintReverseOrder ( N - 1 ) ; NEW_LINE DEDENT DEDENT
def XOROfElements ( arr , n ) : NEW_LINE INDENT FirstHalfXOR = 0 ; NEW_LINE SecondHalfXOR = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT FirstHalfXOR ^= arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT SecondHalfXOR ^= arr [ i ] ; NEW_LINE DEDENT DEDENT print ( FirstHalfXOR , " , " , SecondHalfXOR ) ; NEW_LINE DEDENT
def movesRequired ( a , b ) : NEW_LINE INDENT total_moves = a % b NEW_LINE print ( total_moves ) NEW_LINE DEDENT
def Volume_of_cone ( R ) : NEW_LINE INDENT V = ( 1 / 3 ) * ( 3.14 ) * ( 2 * ( R ** 2 ) ) * ( 4 * R ) NEW_LINE return V NEW_LINE DEDENT
def check ( X , K ) : NEW_LINE INDENT prime = 0 NEW_LINE temp = X NEW_LINE sqr = int ( sqrt ( X ) ) NEW_LINE for i in range ( 2 , sqr + 1 , 1 ) : NEW_LINE INDENT while ( temp % i == 0 ) : NEW_LINE INDENT temp = temp // i NEW_LINE prime += 1 NEW_LINE DEDENT DEDENT if ( temp > 2 ) : NEW_LINE INDENT prime += 1 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( prime == 1 and K == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( prime >= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def maxAlternatingSum ( arr , n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT current_max = arr [ i ] NEW_LINE k = i NEW_LINE while k < n and ( ( arr [ i ] > 0 and arr [ k ] > 0 ) or ( arr [ i ] < 0 and arr [ k ] < 0 ) ) : NEW_LINE INDENT current_max = max ( current_max , arr [ k ] ) NEW_LINE k += 1 NEW_LINE DEDENT max_sum += current_max NEW_LINE i = k NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
def CntcontSubs ( a , n ) : NEW_LINE INDENT c = 0 NEW_LINE d = 0 NEW_LINE sum = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 != 0 or a [ i ] % 4 == 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT sum = a [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum * a [ j ] NEW_LINE if ( sum % 2 != 0 or sum % 4 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT sum = 1 NEW_LINE DEDENT return c + d NEW_LINE DEDENT
def countSubsets ( a , n ) : NEW_LINE INDENT answer = 0 ; NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT bitwiseAND = - 1 ; NEW_LINE bitwiseOR = 0 ; NEW_LINE bitwiseXOR = 0 ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( bitwiseAND == - 1 ) : NEW_LINE INDENT bitwiseAND = a [ j ] ; NEW_LINE DEDENT else : NEW_LINE INDENT bitwiseAND &= a [ j ] ; NEW_LINE DEDENT bitwiseOR |= a [ j ] ; NEW_LINE bitwiseXOR ^= a [ j ] ; NEW_LINE DEDENT DEDENT if ( bitwiseAND == bitwiseOR and bitwiseOR == bitwiseXOR ) : NEW_LINE INDENT answer = ( answer + 1 ) % mod ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT
def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT
def convertToDecimal ( N ) : NEW_LINE INDENT print ( " Decimal ▁ number ▁ of " , N , " is : " , end = " ▁ " ) ; NEW_LINE if ( N != 0 ) : NEW_LINE INDENT decimalNumber = 0 ; NEW_LINE i = 0 ; NEW_LINE remainder = 0 ; NEW_LINE while ( N != 0 ) : NEW_LINE INDENT remainder = N % 10 ; NEW_LINE N = N // 10 ; NEW_LINE decimalNumber += remainder * math . pow ( 3 , i ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT print ( decimalNumber ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) ; NEW_LINE DEDENT DEDENT
def product ( mat , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d1 += mat [ i ] [ i ] NEW_LINE d2 += mat [ i ] [ n - i - 1 ] NEW_LINE DEDENT return d1 * d2 NEW_LINE DEDENT
def getPercentile ( rank , students ) : NEW_LINE INDENT result = ( students - rank ) / students * 100 ; NEW_LINE return result ; NEW_LINE DEDENT
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left ; NEW_LINE d = arr [ 1 ] - arr [ 0 ] ; NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) ; NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 ; NEW_LINE return ans ; NEW_LINE DEDENT
def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT
def findRealAndImag ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE if ( s . find ( ' + ' ) != - 1 ) : NEW_LINE INDENT i = s . find ( ' + ' ) NEW_LINE DEDENT else : NEW_LINE INDENT i = s . find ( ' - ' ) ; NEW_LINE DEDENT real = s [ : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE print ( " Real ▁ part : " , real ) NEW_LINE print ( " Imaginary ▁ part : " , imaginary ) NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE position [ i ] = pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def rangeSum ( l , r ) : NEW_LINE INDENT a = 1 NEW_LINE b = 9 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT L = max ( l , a ) NEW_LINE R = min ( r , b ) NEW_LINE if ( L <= R ) : NEW_LINE INDENT sum = ( L + R ) * ( R - L + 1 ) // 2 NEW_LINE res += pow ( i , i ) * ( sum % MOD ) NEW_LINE res %= MOD NEW_LINE DEDENT a = a * 10 NEW_LINE b = b * 10 + 9 NEW_LINE DEDENT return res NEW_LINE DEDENT
def TrialDivision ( N ) : NEW_LINE INDENT i = 2 NEW_LINE k = int ( N ** 0.5 ) NEW_LINE while ( i <= k ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def pairs ( n ) : NEW_LINE INDENT c = [ [ 0 for i in range ( 10 ) ] for i in range ( 10 ) ] NEW_LINE tmp = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i >= tmp * 10 ) : NEW_LINE INDENT tmp *= 10 NEW_LINE DEDENT c [ i // tmp ] [ i % 10 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 1 , 10 ) : NEW_LINE INDENT ans += c [ i ] [ j ] * c [ j ] [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countWays ( A , B , C ) : NEW_LINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) // 2 ) NEW_LINE count_ways = max ( C - minAddA + 1 , 0 ) NEW_LINE return count_ways NEW_LINE DEDENT
def printSeries ( N ) : NEW_LINE INDENT ith_term = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ith_term = 0 ; NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT ith_term = 2 * i * i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ith_term = 2 * i * i - 1 ; NEW_LINE DEDENT print ( ith_term , end = " , ▁ " ) ; NEW_LINE DEDENT DEDENT
def findNthTerm ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ans = ans + 6 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sum += i / ( i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= i / ( i + 1 ) ; NEW_LINE DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT
def printSeriessumm ( N ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT summ += pow ( i , i - 1 ) NEW_LINE DEDENT print ( summ ) NEW_LINE DEDENT
def printSumSeries ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += 1.0 / ( 2 * i - 1 ) ; NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE a = 1 ; NEW_LINE cnt = 0 ; NEW_LINE flag = True ; NEW_LINE sum += a ; NEW_LINE while ( cnt < N ) : NEW_LINE INDENT nextElement = None ; NEW_LINE if ( flag ) : NEW_LINE INDENT nextElement = a * 2 ; NEW_LINE sum += nextElement ; NEW_LINE flag = not flag ; NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * ( 3 / 2 ) ; NEW_LINE sum += nextElement ; NEW_LINE flag = not flag ; NEW_LINE DEDENT a = nextElement ; NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT
def sumBaseB ( a , b , base ) : NEW_LINE INDENT len_a = len ( a ) NEW_LINE len_b = len ( b ) NEW_LINE s = " " ; NEW_LINE sum = " " ; NEW_LINE diff = abs ( len_a - len_b ) ; NEW_LINE for i in range ( 1 , diff + 1 ) : NEW_LINE INDENT s += "0" NEW_LINE DEDENT if ( len_a < len_b ) : NEW_LINE INDENT a = s + a NEW_LINE DEDENT else : NEW_LINE INDENT b = s + b ; NEW_LINE DEDENT carry = 0 ; NEW_LINE for i in range ( max ( len_a , len_b ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr = carry + ( ord ( a [ i ] ) - ord ( '0' ) ) + ( ord ( b [ i ] ) - ord ( '0' ) ) ; NEW_LINE carry = curr // base NEW_LINE curr = curr % base ; NEW_LINE sum = chr ( curr + ord ( '0' ) ) + sum NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT sum = chr ( carry + ord ( '0' ) ) + sum ; NEW_LINE DEDENT return sum NEW_LINE DEDENT
def quadrant ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE if ( ' + ' in s ) : NEW_LINE INDENT i = s . index ( ' + ' ) NEW_LINE 1 INDENT else : NEW_LINE INDENT i = s . index ( ' - ' ) NEW_LINE DEDENT real = s [ 0 : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE if ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( " Quadrant ▁ 1" ) NEW_LINE DEDENT elif ( x < 0 and y > 0 ) : NEW_LINE INDENT print ( " Quadrant ▁ 2" ) NEW_LINE DEDENT elif ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( " Quadrant ▁ 3" ) NEW_LINE DEDENT elif ( x > 0 and y < 0 ) : NEW_LINE INDENT print ( " Quadrant ▁ 4" ) NEW_LINE DEDENT elif ( x == 0 and y > 0 ) : NEW_LINE INDENT print ( " Lies ▁ on ▁ positive " , " Imaginary ▁ axis " ) NEW_LINE DEDENT elif ( x == 0 and y < 0 ) : NEW_LINE INDENT print ( " Lies ▁ on ▁ negative " , " Imaginary ▁ axis " ) NEW_LINE DEDENT elif ( y == 0 and x < 0 ) : NEW_LINE INDENT print ( " Lies ▁ on ▁ negative " , " X - axis " ) NEW_LINE DEDENT elif ( y == 0 and x > 0 ) : NEW_LINE INDENT print ( " Lies ▁ on ▁ positive " , " X - axis " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Lies ▁ on ▁ the ▁ Origin " ) NEW_LINE DEDENT DEDENT
def countdigits ( n , k ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT digit = n % 10 NEW_LINE if digit == k : NEW_LINE INDENT return 1 + countdigits ( n / 10 , k ) NEW_LINE DEDENT return countdigits ( n / 10 , k ) NEW_LINE DEDENT
def product_subarrays ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT product *= arr [ k ] ; NEW_LINE DEDENT DEDENT DEDENT print ( product ,   " " ) ; NEW_LINE DEDENT
def product_subarrays ( arr , n ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = 1 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT product *= arr [ j ] ; NEW_LINE res = res * product NEW_LINE DEDENT DEDENT print ( res ) ; NEW_LINE DEDENT
def printModulus ( X , Y ) : NEW_LINE INDENT n = max ( X , Y ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( X % i == Y % i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def printModulus ( X , Y ) : NEW_LINE INDENT d = abs ( X - Y ) ; NEW_LINE i = 1 ; NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT print ( i , end = " " ) ; NEW_LINE if ( d // i != i ) : NEW_LINE INDENT print ( d // i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT
def difSquare ( n ) : NEW_LINE INDENT if ( n % 4 != 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def makearrayequal ( arr , n ) : NEW_LINE INDENT x = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT x += arr [ i ] & 1 ; NEW_LINE DEDENT print ( min ( x , n - x ) ) ; NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( d == 2 or d == 3 or d == 5 or d == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT return " Odd " ; NEW_LINE DEDENT else : NEW_LINE INDENT return " Even " ; NEW_LINE DEDENT DEDENT
def check ( Arr , n , M , K ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Arr [ i ] == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT if ( K % 2 != 0 and flag == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT else : NEW_LINE INDENT return " Yes " ; NEW_LINE DEDENT DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) ; NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT
def checkPalindrome ( num ) : NEW_LINE INDENT string = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( string ) - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( string [ l ] != string [ r ] ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return ; NEW_LINE DEDENT l = l + 1 ; NEW_LINE r = r - 1 ; NEW_LINE DEDENT print ( " Yes " ) NEW_LINE return ; NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' or N [ l - 1 ] == '8' or N [ l - 1 ] == ' A ' or N [ l - 1 ] == ' C ' or N [ l - 1 ] == ' E ' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT
def printf ( n , k ) : NEW_LINE INDENT print ( int ( k ) , end = " ▁ " ) NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT x = pow ( k , i ) - pow ( k , i - 1 ) NEW_LINE print ( int ( x ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT prime = [ False ] * 10 NEW_LINE prime [ 2 ] = True NEW_LINE prime [ 3 ] = True ; NEW_LINE prime [ 5 ] = True NEW_LINE prime [ 7 ] = True ; NEW_LINE temp = n NEW_LINE count = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 ; NEW_LINE temp //= 10 ; NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( ( i * i * i ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i // j == j ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i // j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( n // i ) * i NEW_LINE DEDENT return sum - n * ( n + 1 ) // 2 NEW_LINE DEDENT
def maxValue ( a ) : NEW_LINE INDENT a = bin ( a ) [ 2 : ] NEW_LINE b = ' ' NEW_LINE for i in list ( a ) : NEW_LINE INDENT b += str ( int ( not int ( i ) ) ) NEW_LINE DEDENT print ( int ( b , 2 ) ) NEW_LINE return int ( b , 2 ) NEW_LINE DEDENT
def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT
def canBeReduced ( x , y ) : NEW_LINE INDENT maxi = max ( x , y ) NEW_LINE mini = min ( x , y ) NEW_LINE if ( ( ( x + y ) % 3 ) == 0 and maxi <= 2 * mini ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) NEW_LINE return floor ( x ) + 1 NEW_LINE DEDENT
def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findDistinctOddsumm ( n , k ) : NEW_LINE INDENT if ( ( k * k ) <= n and ( n + k ) % 2 == 0 ) : NEW_LINE INDENT val = 1 NEW_LINE summ = 0 NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT print ( val , end = " ▁ " ) NEW_LINE summ += val NEW_LINE val += 2 NEW_LINE DEDENT print ( n - summ ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if j * j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if j * j * j == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def countCubes ( a , b ) : NEW_LINE INDENT return ( floor ( b ** ( 1. / 3. ) ) - ceil ( a ** ( 1. / 3. ) ) + 1 ) NEW_LINE DEDENT
def perfectCube ( N ) : NEW_LINE INDENT cube_root = round ( N ** ( 1 / 3 ) ) ; NEW_LINE if cube_root * cube_root * cube_root == N : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT
def check ( arr , N ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT DEDENT if ( even == N or odd == N ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def findSum ( N ) : NEW_LINE INDENT sum = ( N ) * ( N + 1 ) // 2 NEW_LINE r = log2 ( N ) + 1 NEW_LINE expSum = pow ( 2 , r ) - 1 NEW_LINE print ( int ( sum - expSum ) ) NEW_LINE DEDENT
def findNumbers ( n , b ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE if ( b % 2 == 0 ) : NEW_LINE INDENT even = pow ( b , n ) - 2 ; NEW_LINE odd = pow ( b , n ) - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even = pow ( b , n ) - 1 ; NEW_LINE odd = pow ( b , n ) - 2 ; NEW_LINE DEDENT print ( " Even ▁ Number ▁ = ▁ " , int ( even ) ) ; NEW_LINE print ( " Odd ▁ Number ▁ = ▁ " , int ( odd ) ) ; NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = int ( sqrt ( x ) ) ; NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def printPairs ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , " , arr [ j ] , " ) " , end = " , ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def countSteps ( n ) : NEW_LINE INDENT steps = 0 NEW_LINE while ( n ) : NEW_LINE INDENT largest = floor ( n ** ( 1 / 3 ) ) NEW_LINE n -= ( largest * largest * largest ) NEW_LINE steps += 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT
def product ( N ) : NEW_LINE INDENT ans = 1 ; NEW_LINE val = 2 ** ( N - 1 ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans *= ( i ** val ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT
def mul_table ( N , i ) : NEW_LINE INDENT if ( i > 10 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( N , " * " , i , " = " , N * i ) NEW_LINE return mul_table ( N , i + 1 ) NEW_LINE DEDENT
def printValueOfPi ( N ) : NEW_LINE INDENT b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE print ( pi ) ; NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT sum += ( i * i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= ( i * i ) ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT abs_sum = n * ( n + 1 ) // 2 ; NEW_LINE sign = 1 if ( ( n + 1 ) % 2 == 0 ) else - 1 ; NEW_LINE result_sum = sign * abs_sum ; NEW_LINE return result_sum ; NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
def precompute ( ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , 19 ) : NEW_LINE INDENT fact = fact * i ; NEW_LINE m [ fact ] = i ; NEW_LINE DEDENT DEDENT
def sumOfParts ( arr , N ) : NEW_LINE INDENT sum_part1 , sum_part2 , sum_part3 , sum_part4 = 0 , 0 , 0 , 0 NEW_LINE totalsum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if i + j < N - 1 : NEW_LINE INDENT if ( i < j and i != j and i + j ) : NEW_LINE INDENT sum_part1 += arr [ i ] [ j ] NEW_LINE DEDENT elif i != j : NEW_LINE INDENT sum_part2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i > j and i + j != N - 1 : NEW_LINE INDENT sum_part3 += arr [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT if i + j != N - 1 and i != j : NEW_LINE INDENT sum_part4 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return sum_part1 + sum_part2 + sum_part3 + sum_part4 NEW_LINE DEDENT
def noOfCards ( n ) : NEW_LINE INDENT return n * ( 3 * n + 1 ) // 2 NEW_LINE DEDENT
def subsetSum ( arr , n , i , sum , count ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) NEW_LINE count = subsetSum ( arr , n , i + 1 , sum , count ) NEW_LINE return count NEW_LINE DEDENT
def log_a_to_base_b ( a , b ) : NEW_LINE INDENT return log ( a ) // log ( b ) ; NEW_LINE DEDENT
def log_a_to_base_b ( a , b ) : NEW_LINE INDENT rslt = ( 1 + log_a_to_base_b ( a // b , b ) ) if ( a > ( b - 1 ) ) else 0 ; NEW_LINE return rslt ; NEW_LINE DEDENT
def count ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT sum += 7 * ( 8 ** ( i - 1 ) ) ; NEW_LINE DEDENT return int ( sum ) ; NEW_LINE DEDENT
def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT factors ( n , i + 1 ) ; NEW_LINE DEDENT DEDENT
def maxValue ( n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT ans = ( n * n // 4 ) NEW_LINE return ans NEW_LINE DEDENT
def prMultiples ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( ( i * j ) , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def SubarraysWithSumS ( n , k , s ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( s , end = " ▁ " ) NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT print ( s + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def pay ( n ) : NEW_LINE INDENT cuts = int ( math . log ( n , 2 ) ) NEW_LINE return cuts NEW_LINE DEDENT
def pairCount ( n , m ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for b in range ( int ( pow ( m , 1 / 2 ) ) ) : NEW_LINE INDENT a = m - b * b ; NEW_LINE if ( a * a + b == n ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT
def nthDigit ( a , n , b ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a = a // b NEW_LINE DEDENT return a % b NEW_LINE DEDENT
def squareRoot ( n , l ) : NEW_LINE INDENT x = n NEW_LINE count = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT count += 1 NEW_LINE root = 0.5 * ( x + ( n / x ) ) NEW_LINE if ( abs ( root - x ) < l ) : NEW_LINE INDENT break NEW_LINE DEDENT x = root NEW_LINE DEDENT return root NEW_LINE DEDENT
def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT print ( arr [ n - 1 ] ) ; NEW_LINE DEDENT
def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 ; NEW_LINE currSum = 0 ; NEW_LINE while ( currSum <= S ) : NEW_LINE INDENT currSum += N ; NEW_LINE N = N - 1 ; NEW_LINE countElements = countElements + 1 ; NEW_LINE DEDENT return countElements ; NEW_LINE DEDENT
def usingBinarySearch ( start , end , N , S ) : NEW_LINE INDENT if ( start >= end ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = start + ( end - start ) // 2 ; NEW_LINE totalSum = ( N * ( N + 1 ) ) // 2 ; NEW_LINE midSum = ( mid * ( mid + 1 ) ) // 2 ; NEW_LINE if ( ( totalSum - midSum ) <= S ) : NEW_LINE INDENT return usingBinarySearch ( start , mid , N , S ) ; NEW_LINE DEDENT return usingBinarySearch ( mid + 1 , end , N , S ) ; NEW_LINE DEDENT
def min_index ( p , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE mini = INT_MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] <= mini ) : NEW_LINE INDENT mini = p [ i ] ; NEW_LINE DEDENT if ( mini == p [ i ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def equal_xor_sum ( arr , n ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE Xor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = Sum + arr [ i ] ; NEW_LINE Xor = Xor ^ arr [ i ] ; NEW_LINE DEDENT if ( Sum == Xor ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE n //= 2 NEW_LINE while ( n ) : NEW_LINE INDENT ans += n // 5 NEW_LINE n //= 5 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
def maxGCD ( N , K ) : NEW_LINE INDENT minSum = ( K * ( K + 1 ) ) / 2 NEW_LINE if ( N < minSum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = ceil ( sqrt ( N ) ) NEW_LINE res = 1 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i >= minSum ) : NEW_LINE INDENT res = max ( res , N / i ) NEW_LINE DEDENT if ( N / i >= minSum ) : NEW_LINE INDENT res = max ( res , i ) NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxHeight ( h1 , h2 ) : NEW_LINE INDENT return ( ( h1 * h2 ) - h1 - h2 ) NEW_LINE DEDENT
def checkZeroArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maximum = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT if ( sum % 2 == 0 and maximum <= sum // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 2 , 1 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkZeroArray ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT sum = 45.0 ; NEW_LINE DEDENT else : NEW_LINE INDENT sum = ( 99.0 / 2.0 ) * pow ( 10 , n - 1 ) * pow ( 10 , ( n - 1 ) / 2 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def cntSubSeq ( arr , n ) : NEW_LINE INDENT pos_count = 0 ; NEW_LINE neg_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_count += 1 NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg_count += 1 NEW_LINE DEDENT DEDENT result = int ( math . pow ( 2 , pos_count ) ) NEW_LINE if ( neg_count > 0 ) : NEW_LINE INDENT result *= int ( math . pow ( 2 , neg_count - 1 ) ) NEW_LINE DEDENT result -= 1 NEW_LINE return result NEW_LINE DEDENT
def countTriangles ( n ) : NEW_LINE INDENT curr = 1 NEW_LINE Tri_count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT Tri_count = ( curr * 3 ) + 2 NEW_LINE curr = Tri_count NEW_LINE DEDENT return Tri_count NEW_LINE DEDENT
def findNums ( arr , n ) : NEW_LINE INDENT S = 0 ; X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] ; NEW_LINE X ^= arr [ i ] ; NEW_LINE DEDENT print ( X , X + S ) ; NEW_LINE DEDENT
def solve ( A , B ) : NEW_LINE INDENT p = B / 2 NEW_LINE M = int ( 4 * p ) NEW_LINE N = 1 NEW_LINE O = - 2 * A NEW_LINE Q = int ( A * A + 4 * p * p ) NEW_LINE return [ M , N , O , Q ] NEW_LINE DEDENT
def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return n - cnt ; NEW_LINE DEDENT
def find_composite_nos ( n ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) ; NEW_LINE DEDENT
def maxXOR ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( xorArr ^ arr [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minOR ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT pre = [ 0 ] * n NEW_LINE suf = [ 0 ] * n NEW_LINE pre [ 0 ] = arr [ 0 ] NEW_LINE suf [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) NEW_LINE DEDENT ans = min ( pre [ n - 2 ] , suf [ 1 ] ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT ans = min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPossible ( x , y ) : NEW_LINE INDENT if ( ( x - y ) == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT x = 100 NEW_LINE y = 98 NEW_LINE if ( isPossible ( x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def numSeq ( n ) : NEW_LINE INDENT return ( pow ( 3 , n ) + 3 * pow ( - 1 , n ) ) // 4 NEW_LINE DEDENT
def perfectSquares ( l , r ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i ** ( .5 ) == int ( i ** ( .5 ) ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def perfectSquares ( l , r ) : NEW_LINE INDENT number = ceil ( sqrt ( l ) ) ; NEW_LINE n2 = number * number ; NEW_LINE number = ( number * 2 ) + 1 ; NEW_LINE while ( ( n2 >= l and n2 <= r ) ) : NEW_LINE INDENT print ( n2 , end = " ▁ " ) ; NEW_LINE n2 = n2 + number ; NEW_LINE number += 2 ; NEW_LINE DEDENT DEDENT
def xorK ( n , k ) : NEW_LINE INDENT res = n NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT res = ( res ^ n ) NEW_LINE DEDENT return n NEW_LINE DEDENT
def xorK ( n , k ) : NEW_LINE INDENT if ( k % 2 == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def findRemainders ( n ) : NEW_LINE INDENT vc = dict ( ) NEW_LINE for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT vc [ n // i ] = 1 NEW_LINE DEDENT for i in range ( n // ceil ( sqrt ( n ) ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT vc [ i ] = 1 NEW_LINE DEDENT for it in sorted ( vc ) : NEW_LINE INDENT print ( it , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findWinner ( n ) : NEW_LINE INDENT if ( ( n - 1 ) % 6 == 0 ) : NEW_LINE INDENT print ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; NEW_LINE DEDENT DEDENT
def countIndices ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE max = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max < arr [ i ] ) : NEW_LINE INDENT max = arr [ i ] ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def min_changes ( a , n ) : NEW_LINE INDENT ans_a = 0 ; NEW_LINE ans_b = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT ans_a += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans_b += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT ans_b += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans_a += 1 ; NEW_LINE DEDENT DEDENT DEDENT return min ( ans_a , ans_b ) ; NEW_LINE DEDENT
def ans ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( "1" , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) ; NEW_LINE DEDENT DEDENT
def isPossible ( w , h , x , y ) : NEW_LINE INDENT if ( x * 2 == w and y * 2 == h ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findNthDigit ( p , q , N ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT N -= 1 ; NEW_LINE p *= 10 ; NEW_LINE res = p // q ; NEW_LINE p %= q ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def minsteps ( n , m ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) // 2 + m - 1 ) // m * m ; NEW_LINE DEDENT DEDENT
def findNum ( x ) : NEW_LINE INDENT for i in range ( NumUnsignBits - 1 ) : NEW_LINE INDENT if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) : NEW_LINE INDENT x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; NEW_LINE return x ; NEW_LINE DEDENT DEDENT DEDENT
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 ; cntOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 ; NEW_LINE DEDENT DEDENT evenPairs = 0 ; NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) ; NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) ; NEW_LINE oddPairs = 0 ; NEW_LINE oddPairs += ( cntEven * cntOdd ) ; NEW_LINE print ( " Odd ▁ pairs ▁ = ▁ " , oddPairs ) ; NEW_LINE print ( " Even ▁ pairs ▁ = ▁ " , evenPairs ) ; NEW_LINE DEDENT
def cntSquares ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) NEW_LINE DEDENT
def findCnt ( arr , n , k ) : NEW_LINE INDENT ret = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT x = max ( 0 , j - i - k ) ; NEW_LINE ret += ( x * ( x + 1 ) ) / 2 ; NEW_LINE i = j ; NEW_LINE DEDENT return ret ; NEW_LINE DEDENT
def countElements ( p , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) ; NEW_LINE i = j ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT min_val = min ( arr ) ; NEW_LINE freq = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_val ) : NEW_LINE INDENT freq += 1 ; NEW_LINE DEDENT DEDENT return freq ; NEW_LINE DEDENT
def print_primes_till_N ( N ) : NEW_LINE INDENT i , j , flag = 0 , 0 , 0 ; NEW_LINE print ( " Prime ▁ numbers ▁ between ▁ 1 ▁ and ▁ " , N , " ▁ are : " ) ; NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( i == 1 or i == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT flag = 1 ; NEW_LINE for j in range ( 2 , ( ( i // 2 ) + 1 ) , 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def last_digit ( X , Y ) : NEW_LINE INDENT print ( X % Y ) ; NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT return ( pow ( n , 2 ) - ( 2 * n ) + 2 ) ; NEW_LINE DEDENT
def geometricMean ( n ) : NEW_LINE INDENT return int ( sqrt ( n ) ) ; NEW_LINE DEDENT
def two_sets ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE return ( a [ n // 2 ] - a [ ( n // 2 ) - 1 ] ) ; NEW_LINE DEDENT
def min_moves ( n ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans = min ( ans , i + n // i - 2 ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def findX ( A , B ) : NEW_LINE INDENT X = 0 ; NEW_LINE for bit in range ( MAX ) : NEW_LINE INDENT tempBit = 1 << bit ; NEW_LINE bitOfX = A & B & tempBit ; NEW_LINE X += bitOfX ; NEW_LINE DEDENT return X ; NEW_LINE DEDENT
def cntPairs ( a , n ) : NEW_LINE INDENT odd = 0 ; even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT elif ( ( a [ i ] / 2 ) % 2 == 1 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT DEDENT ans = odd * even + ( odd * ( odd - 1 ) ) // 2 ; NEW_LINE return ans ; NEW_LINE DEDENT
def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] ; NEW_LINE cur -= 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] ; NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 ; NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT cur = nxt ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT
def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT DEDENT
def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n ; NEW_LINE pre [ 0 ] = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE suf [ n - 1 ] = a [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = " ▁ " ) ; NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def kthNum ( n , k ) : NEW_LINE INDENT a = ( n + 1 ) // 2 ; NEW_LINE if ( k > a ) : NEW_LINE INDENT return ( 2 * ( k - a ) ) ; NEW_LINE DEDENT return ( 2 * k - 1 ) ; NEW_LINE DEDENT
def find_numbers ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( - 1 , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , N + 1 , N * ( N + 1 ) ) ; NEW_LINE DEDENT DEDENT
def find_k ( a , b ) : NEW_LINE INDENT if ( ( a + b ) % 2 == 0 ) : NEW_LINE INDENT return ( ( a + b ) // 2 ) ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT
def isPossible ( a , n ) : NEW_LINE INDENT k = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != i + 1 ) : NEW_LINE INDENT k += 1 ; NEW_LINE DEDENT DEDENT if ( k <= 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def odd_digits ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT elif ( n / 10 < 10 ) : NEW_LINE INDENT return 9 ; NEW_LINE DEDENT elif ( n / 100 < 10 ) : NEW_LINE INDENT return 9 + n - 99 ; NEW_LINE DEDENT elif ( n / 1000 < 10 ) : NEW_LINE INDENT return 9 + 900 ; NEW_LINE DEDENT elif ( n / 10000 < 10 ) : NEW_LINE INDENT return 909 + n - 9999 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 90909 ; NEW_LINE DEDENT DEDENT
def nDigitPalindromes ( n ) : NEW_LINE INDENT return ( 9 * pow ( 10 , ( n - 1 ) // 2 ) ) ; NEW_LINE DEDENT
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) ; NEW_LINE DEDENT
def cntSubSets ( arr , n ) : NEW_LINE INDENT maxVal = max ( arr ) ; NEW_LINE cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == maxVal ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return ( ( 2 ** cnt ) - 1 ) ; NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT return ( ( n - 1 ) + pow ( n , 2 ) ) ; NEW_LINE DEDENT
def cntEdges ( n ) : NEW_LINE INDENT edges = 2 ** n - 2 ; NEW_LINE return edges ; NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) // 2 ; NEW_LINE DEDENT
def cntCells ( n ) : NEW_LINE INDENT cells = pow ( n , 2 ) + pow ( n - 1 , 2 ) ; NEW_LINE return cells ; NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return n ** 3 ; NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT return 15 * pow ( 16 , n - 1 ) ; NEW_LINE DEDENT
def findNumbers ( N ) : NEW_LINE INDENT ans = '7' * ( N - 1 ) NEW_LINE even = ans + '6' ; NEW_LINE odd = ans + '7' ; NEW_LINE print ( " Even ▁ : ▁ " , even ) ; NEW_LINE print ( " Odd ▁ : ▁ " , odd ) ; NEW_LINE DEDENT
def nth_term ( a , b , n ) : NEW_LINE INDENT z = 0 NEW_LINE if ( n % 6 == 1 ) : NEW_LINE INDENT z = a NEW_LINE DEDENT elif ( n % 6 == 2 ) : NEW_LINE INDENT z = b NEW_LINE DEDENT elif ( n % 6 == 3 ) : NEW_LINE INDENT z = b - a NEW_LINE DEDENT elif ( n % 6 == 4 ) : NEW_LINE INDENT z = - a NEW_LINE DEDENT elif ( n % 6 == 5 ) : NEW_LINE INDENT z = - b NEW_LINE DEDENT if ( n % 6 == 0 ) : NEW_LINE INDENT z = - ( b - a ) NEW_LINE DEDENT return z NEW_LINE DEDENT
def inProportion ( arr ) : NEW_LINE INDENT n = 4 ; NEW_LINE arr . sort ( ) NEW_LINE extremes = arr [ 0 ] * arr [ 3 ] ; NEW_LINE means = arr [ 1 ] * arr [ 2 ] ; NEW_LINE if ( extremes == means ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def findMissing ( arr , n , k , avg ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT num = ( avg * ( n + k ) ) - sum ; NEW_LINE den = k ; NEW_LINE if ( num % den != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ( int ) ( num / den ) ; NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT return ( - 1 + sqrt ( 1 + 8 * n ) ) // 2 ; NEW_LINE DEDENT
def previousFibonacci ( n ) : NEW_LINE INDENT a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) NEW_LINE return round ( a ) NEW_LINE DEDENT
def findEquation ( a , b ) : NEW_LINE INDENT summ = ( a + b ) NEW_LINE product = ( a * b ) NEW_LINE print ( " x ^ 2 ▁ - ▁ ( " , summ , " x ) ▁ + ▁ ( " , product , " ) ▁ = ▁ 0" ) NEW_LINE DEDENT
def cal ( n ) : NEW_LINE INDENT res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) NEW_LINE return int ( res ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT
def summ ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT
def findNums ( n ) : NEW_LINE INDENT if ( n <= 11 ) : NEW_LINE INDENT if ( n == 8 ) : NEW_LINE INDENT print ( "4 ▁ 4" , end = " ▁ " ) NEW_LINE DEDENT if ( n == 10 ) : NEW_LINE INDENT print ( "4 ▁ 6" , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" , end = " ▁ " ) NEW_LINE DEDENT DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( "4 ▁ " , ( n - 4 ) , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "9 ▁ " , n - 9 , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) NEW_LINE DEDENT
def nextFibonacci ( n ) : NEW_LINE INDENT a = n * ( 1 + sqrt ( 5 ) ) / 2.0 NEW_LINE return round ( a ) NEW_LINE DEDENT
def summ ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) NEW_LINE DEDENT
def product ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE val = pow ( 2 , n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans *= pow ( a [ i ] , val ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def oddFib ( n ) : NEW_LINE INDENT n = ( 3 * n + 1 ) // 2 NEW_LINE a = - 1 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT
def sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in arr : NEW_LINE INDENT sum += i NEW_LINE DEDENT sum = sum * pow ( 2 , n - 1 ) NEW_LINE return sum NEW_LINE DEDENT
def ways ( n ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT
def no_of_ways ( a , n ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT DEDENT if ( count_1 % 2 == 0 ) : NEW_LINE INDENT return count_0 NEW_LINE DEDENT else : NEW_LINE INDENT return count_1 NEW_LINE DEDENT DEDENT
def maxInt ( string ) : NEW_LINE INDENT string2 = " " NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if ( string [ i ] < '5' ) : NEW_LINE INDENT string2 += str ( ( ord ( '9' ) - ord ( string [ i ] ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT string2 += str ( string [ i ] ) NEW_LINE DEDENT DEDENT if ( string2 [ 0 ] == '0' ) : NEW_LINE INDENT string2 [ 0 ] = '9' NEW_LINE DEDENT return string2 NEW_LINE DEDENT
def isPossible ( x , y , k ) : NEW_LINE INDENT minMoves = abs ( x ) + abs ( y ) NEW_LINE if ( k >= minMoves and ( k - minMoves ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT x = 5 NEW_LINE y = 8 NEW_LINE k = 20 NEW_LINE if ( isPossible ( x , y , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ arr [ i ] - i ] = map . get ( arr [ i ] - i , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in map : NEW_LINE INDENT cnt = map [ x ] NEW_LINE res += ( ( cnt * ( cnt - 1 ) ) // 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def minInt ( str1 ) : NEW_LINE INDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] >= 5 ) : NEW_LINE INDENT str1 [ i ] = ( 9 - str1 [ i ] ) NEW_LINE DEDENT DEDENT if ( str1 [ 0 ] == 0 ) : NEW_LINE INDENT str1 [ 0 ] = 9 NEW_LINE DEDENT temp = " " NEW_LINE for i in str1 : NEW_LINE INDENT temp += str ( i ) NEW_LINE DEDENT return temp NEW_LINE DEDENT
def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return ( sum // n ) + 1 NEW_LINE DEDENT
def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n = n // 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 40585 NEW_LINE if ( isFactorion ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT
def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n //= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT
def findMaximumNum ( st , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( k < 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( st [ i ] != '9' ) : NEW_LINE INDENT st = st [ 0 : i ] + '9' + st [ i + 1 : ] NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 ; NEW_LINE DEDENT
def isDivisible ( arr , n ) : NEW_LINE INDENT lastDigit = arr [ n - 1 ] % 10 ; NEW_LINE if ( lastDigit == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT
def getArray ( n ) : NEW_LINE INDENT ans = [ ] ; NEW_LINE p2 = 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT ans . append ( p2 ) ; NEW_LINE DEDENT n >>= 1 ; NEW_LINE p2 *= 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def getIndex ( n , shuffle ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if ( shuffle [ i ] [ 0 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 1 ] ; NEW_LINE DEDENT elif ( shuffle [ i ] [ 1 ] == n ) : NEW_LINE INDENT n = shuffle [ i ] [ 0 ] ; NEW_LINE DEDENT DEDENT print ( n ) ; NEW_LINE DEDENT
def calculate ( n , k , m , power ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT if power == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return power - 1 NEW_LINE DEDENT DEDENT elif n == m : NEW_LINE INDENT return power NEW_LINE DEDENT else : NEW_LINE INDENT return calculate ( n * k , k , m , power + 1 ) NEW_LINE DEDENT DEDENT
def printNumber ( holes ) : NEW_LINE INDENT if ( holes == 0 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif ( holes == 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE quo = 0 NEW_LINE rem = holes % 2 NEW_LINE quo = holes // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT print ( "4" , end = " " ) NEW_LINE DEDENT for i in range ( quo ) : NEW_LINE INDENT print ( "8" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT
def sumPairs ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] * ( 2 * n ) ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 4 < 2 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT
def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE k = ( n ) ** ( .5 ) NEW_LINE for i in range ( 1 , floor ( k ) + 1 ) : NEW_LINE INDENT summ += floor ( n / i ) NEW_LINE DEDENT summ *= 2 NEW_LINE summ -= pow ( floor ( k ) , 2 ) NEW_LINE return summ NEW_LINE DEDENT
def distinctRemainders ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT return ( ( n // 2 ) + 1 ) NEW_LINE DEDENT
def countUnsetBits ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = i ; NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 2 == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT temp = temp // 2 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def graphExists ( a ) : NEW_LINE INDENT while True : NEW_LINE INDENT a = sorted ( a , reverse = True ) NEW_LINE if a [ 0 ] == 0 and a [ len ( a ) - 1 ] == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT v = a [ 0 ] NEW_LINE a = a [ 1 : ] NEW_LINE if v > len ( a ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( v ) : NEW_LINE INDENT a [ i ] -= 1 NEW_LINE if a [ i ] < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT a = [ 3 , 3 , 3 , 3 ] NEW_LINE if ( graphExists ( a ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT
def difference ( n ) : NEW_LINE INDENT S = ( n * ( n + 1 ) ) // 2 ; NEW_LINE res = S * ( S - 1 ) ; NEW_LINE return res ; NEW_LINE DEDENT
def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // COST ; NEW_LINE x %= COST ; NEW_LINE type2 = y // COST ; NEW_LINE y %= COST ; NEW_LINE type3 = z // COST ; NEW_LINE z %= COST ; NEW_LINE type4 = min ( x , min ( y , z ) ) ; NEW_LINE maxItems = type1 + type2 + type3 + type4 ; NEW_LINE return maxItems ; NEW_LINE DEDENT
def getCount ( l , r , p ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE val = p ; NEW_LINE while ( True ) : NEW_LINE INDENT a = r // val ; NEW_LINE b = ( l - 1 ) // val ; NEW_LINE val *= p ; NEW_LINE if ( a - b ) : NEW_LINE INDENT cnt += ( a - b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return int ( cnt ) ; NEW_LINE DEDENT
def topsyTurvy ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == '2' or string [ i ] == '4' or string [ i ] == '5' or string [ i ] == '6' or string [ i ] == '7' or string [ i ] == '9' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT
def countSubSeq ( arr , n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( 2 ** count - 1 ) ; NEW_LINE DEDENT
def printMatrix ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( k , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT DEDENT
def possible ( n ) : NEW_LINE INDENT if ( n > 3 ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 ; NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT
def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT
def checkType ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing " ) ; NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Decreasing " ) ; NEW_LINE DEDENT elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing ▁ then ▁ decreasing " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Decreasing ▁ then ▁ increasing " ) ; NEW_LINE DEDENT DEDENT
def cal_IST ( h , r ) : NEW_LINE INDENT IST = round ( ( h * r * 1.0 ) / 360 , 3 ) ; NEW_LINE int_IST = int ( IST ) ; NEW_LINE float_IST = ceil ( ( IST - int_IST ) * 60 ) ; NEW_LINE print ( int_IST , " : " , float_IST ) ; NEW_LINE DEDENT
def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
def compareVal ( x , y ) : NEW_LINE INDENT a = y * log ( x ) ; NEW_LINE b = x * log ( y ) ; NEW_LINE if ( a > b ) : NEW_LINE INDENT print ( x , " ^ " , y , " > " , y , " ^ " , x ) ; NEW_LINE DEDENT elif ( a < b ) : NEW_LINE INDENT print ( x , " ^ " , y , " < " , y , " ^ " , x ) ; NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( x , " ^ " , y , " = " , y , " ^ " , x ) ; NEW_LINE DEDENT DEDENT
def solve ( n ) : NEW_LINE INDENT n_2 = n // 2 ; NEW_LINE den = "1" ; NEW_LINE while ( n_2 ) : NEW_LINE INDENT den += '0' ; NEW_LINE n_2 -= 1 NEW_LINE DEDENT print ( str ( 1 ) + " / " + str ( den ) ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT return ( ( ( 2 ** n ) - 1 ) % MOD ) NEW_LINE DEDENT
def findMin ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE min = arr [ 0 ] NEW_LINE max = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT num = arr [ i ] NEW_LINE total = num + min NEW_LINE for j in range ( 2 , num + 1 ) : NEW_LINE INDENT if ( num % j == 0 ) : NEW_LINE INDENT d = j NEW_LINE now = ( num // d ) + ( min * d ) NEW_LINE reduce = total - now NEW_LINE if ( reduce > max ) : NEW_LINE INDENT max = reduce NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( sum - max ) NEW_LINE DEDENT
def Survives ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( i > n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n -= n // i ; NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def nthXorFib ( n , a , b ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return b NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return a ^ b NEW_LINE DEDENT return nthXorFib ( n % 3 , a , b ) NEW_LINE DEDENT
def find_Solution ( x , n ) : NEW_LINE INDENT Sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE Sum += ( o / e ) * ( pow ( x , p ) / p ) NEW_LINE o = o * ( o + 2 ) NEW_LINE e = e * ( e + 2 ) NEW_LINE DEDENT print ( round ( Sum , 10 ) ) NEW_LINE DEDENT x = - 0.5 NEW_LINE if ( abs ( x ) >= 1 ) : NEW_LINE INDENT print ( " Invalid Input " ) NEW_LINE DEDENT
def totalPay ( totalItems , priceOfOneItem , N , M ) : NEW_LINE INDENT freeItems = 0 NEW_LINE actual = 0 NEW_LINE freeItems = totalItems // ( N + M ) NEW_LINE actual = totalItems - freeItems NEW_LINE amount = actual * priceOfOneItem NEW_LINE return amount NEW_LINE DEDENT
def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT
def findBalance ( x , bal ) : NEW_LINE INDENT if ( x % 10 == 0 and ( x + 1.50 ) <= bal ) : NEW_LINE INDENT print ( round ( bal - x - 1.50 , 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( round ( bal , 2 ) ) NEW_LINE DEDENT DEDENT
def increaseInVol ( l , b , h ) : NEW_LINE INDENT percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) NEW_LINE percentInc -= 1 NEW_LINE percentInc *= 100 NEW_LINE return percentInc NEW_LINE DEDENT
def countOccurrances ( n , d ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == d ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findFactors ( a , b ) : NEW_LINE INDENT c = a + b - 1 NEW_LINE print ( c ) NEW_LINE DEDENT
def TwentyoneMatchstick ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( 5 - arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def proizvolov ( a , b , n ) : NEW_LINE INDENT return n * n NEW_LINE DEDENT
def compareValues ( a , b , c , d ) : NEW_LINE INDENT log1 = math . log10 ( a ) NEW_LINE num1 = log1 * b NEW_LINE log2 = math . log10 ( c ) NEW_LINE num2 = log2 * d NEW_LINE if num1 > num2 : NEW_LINE INDENT print ( a , ' ^ ' , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , ' ^ ' , d ) NEW_LINE DEDENT DEDENT
def sum ( a , b , c , d , x ) : NEW_LINE INDENT ans = ( ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT
def min_visible_bottles ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE ans = max ( ans , m [ arr [ i ] ] ) NEW_LINE DEDENT print ( " Minimum ▁ number ▁ of " , " Visible ▁ Bottles ▁ are : ▁ " , ans ) NEW_LINE DEDENT
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , " , c / ( a * 1.0 ) ) NEW_LINE DEDENT
def Cells ( n , x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 and x / i <= n ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def Cells ( n , x ) : NEW_LINE INDENT if ( n <= 0 or x <= 0 or x > n * n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( i * i < x ) : NEW_LINE INDENT if ( x % i == 0 and x <= n * i ) : NEW_LINE INDENT count += 2 ; NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i * i == x ) : NEW_LINE INDENT return count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return count NEW_LINE DEDENT DEDENT
def Sum ( A , B , R ) : NEW_LINE INDENT ssum = 0 NEW_LINE for i in range ( 1 , R + 1 ) : NEW_LINE INDENT ssum = ssum + ( i * A ) NEW_LINE A = A + B NEW_LINE DEDENT return ssum NEW_LINE DEDENT
def nambiarNumber ( Str , i ) : NEW_LINE INDENT if ( i >= len ( Str ) ) : NEW_LINE INDENT return " " NEW_LINE DEDENT firstDigit = ord ( Str [ i ] ) - ord ( '0' ) NEW_LINE digitParity = firstDigit % 2 NEW_LINE sumDigits = 0 NEW_LINE while ( i < len ( Str ) ) : NEW_LINE INDENT sumDigits += ( ord ( Str [ i ] ) - ord ( '0' ) ) NEW_LINE sumParity = sumDigits % 2 NEW_LINE if ( digitParity != sumParity ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( " " + str ( sumDigits ) + nambiarNumber ( Str , i + 1 ) ) NEW_LINE DEDENT
def evenNumSubstring ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def Depreciation ( v , r , t ) : NEW_LINE INDENT D = v * pow ( ( 1 - r / 100 ) , t ) NEW_LINE return D NEW_LINE DEDENT
def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( ( n ** ( 1 / 2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE if ( ( x ** 4 ) == n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 ; NEW_LINE return ( x ** 4 ) ; NEW_LINE DEDENT DEDENT
def speedOfTrain ( X , Y ) : NEW_LINE INDENT Speed = 0 NEW_LINE Speed = 1188 * ( ( X - Y ) / Y ) NEW_LINE return Speed NEW_LINE DEDENT
def Division ( a , n ) : NEW_LINE INDENT maxi = - 10 ** 9 NEW_LINE mini = 10 ** 9 NEW_LINE for i in a : NEW_LINE INDENT maxi = max ( i , maxi ) NEW_LINE mini = min ( i , mini ) NEW_LINE DEDENT return maxi // mini NEW_LINE DEDENT
def validQuadruple ( arr , n ) : NEW_LINE INDENT if ( n >= MAX ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( validQuadruple ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE p = 0 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT b [ p ] = arr [ i ] NEW_LINE i -= 1 NEW_LINE if ( i >= 0 ) : NEW_LINE INDENT b [ n - 1 - p ] = arr [ i ] NEW_LINE DEDENT p += 1 NEW_LINE i -= 1 NEW_LINE DEDENT return b NEW_LINE DEDENT
def countElements ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT mean = Sum / n NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT newMean = ( Sum - arr [ i ] ) / ( n - 1 ) NEW_LINE if ( newMean == mean ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def sum_of_elements ( arr , n ) : NEW_LINE INDENT sumfirst = 0 ; NEW_LINE sumsecond = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT sumfirst += arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT sumsecond += arr [ i ] ; NEW_LINE DEDENT DEDENT print ( " Sum ▁ of ▁ first ▁ half ▁ elements ▁ is " , sumfirst , end =   " " ) ; NEW_LINE print ( " Sum ▁ of ▁ second ▁ half ▁ elements ▁ is " , sumsecond , end =   " " ) ; NEW_LINE DEDENT
def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 ; NEW_LINE Min = ( ( S - S1 ) / math . floor ( S ) ) * 60 ; NEW_LINE return int ( Min ) ; NEW_LINE DEDENT
def FindElement ( a , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + a [ i ] NEW_LINE DEDENT if s % n == 0 : NEW_LINE INDENT m = s // n NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] == m : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def Digits ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 9 NEW_LINE while ( n ) : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT print ( largest , smallest ) NEW_LINE DEDENT
def count ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE cnt = 0 ; NEW_LINE DEDENT i = 0 ; j = 1 ; NEW_LINE INDENT while ( i < n and j < n ) : NEW_LINE if j <= i : NEW_LINE j = i + 1 NEW_LINE else : NEW_LINE j = j NEW_LINE while ( j < n and ( arr [ j ] - arr [ i ] ) < k ) : NEW_LINE j += 1 ; NEW_LINE cnt += ( n - j ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE INDENT return cnt ; NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT n += 1 ; NEW_LINE powerOf2 = 2 ; NEW_LINE cnt = n // 2 ; NEW_LINE while ( powerOf2 <= n ) : NEW_LINE INDENT totalPairs = n // powerOf2 ; NEW_LINE cnt += ( totalPairs // 2 ) * powerOf2 ; NEW_LINE if ( totalPairs & 1 ) : NEW_LINE INDENT cnt += ( n % powerOf2 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 0 NEW_LINE DEDENT powerOf2 <<= 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT
def decimalToBinary ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) ; NEW_LINE return ; NEW_LINE DEDENT decimalToBinary ( n // 2 ) ; NEW_LINE print ( n % 2 , end = " " ) ; NEW_LINE DEDENT
def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT
def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT
def volumeRec ( a , b , e , h ) : NEW_LINE INDENT return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; NEW_LINE DEDENT
def firstSetBit ( n ) : NEW_LINE INDENT x = n & ( n - 1 ) NEW_LINE return ( n ^ x ) NEW_LINE DEDENT
def findHours ( a , b , k ) : NEW_LINE INDENT if ( a >= b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT time = k // ( b - a ) NEW_LINE time = time + 1 NEW_LINE return time NEW_LINE DEDENT
def minimum_sum ( n , k ) : NEW_LINE INDENT if ( k % n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def Vertices ( x , y ) : NEW_LINE INDENT val = abs ( x ) + abs ( y ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE DEDENT print ( val * x , "0" , end = " ▁ " ) ; NEW_LINE if y < 0 : NEW_LINE INDENT y = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT y = 1 NEW_LINE DEDENT print ( "0" , val * y ) ; NEW_LINE DEDENT
def SumofInverseDivisors ( N , Sum ) : NEW_LINE INDENT ans = float ( Sum ) * 1.0 / float ( N ) ; NEW_LINE return round ( ans , 2 ) ; NEW_LINE DEDENT
def getX ( a , b , c , d ) : NEW_LINE INDENT X = ( b * c - a * d ) // ( d - c ) NEW_LINE return X NEW_LINE DEDENT
def countNum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT count = pow ( 2 , n - 2 ) NEW_LINE return count NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT num = n - 1 ; NEW_LINE num = 2 * ( 4 ** num ) ; NEW_LINE num = num // 3 ; NEW_LINE return num ; NEW_LINE DEDENT
def MinRemove ( a , n , k ) : NEW_LINE INDENT cnt = [ 0 ] * k NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT cnt [ 0 ] += 1 ; NEW_LINE DEDENT elif ( cnt [ a [ i ] - 1 ] > 0 ) : NEW_LINE INDENT cnt [ a [ i ] - 1 ] -= 1 ; NEW_LINE cnt [ a [ i ] ] += 1 ; NEW_LINE DEDENT DEDENT return n - ( k * cnt [ k - 1 ] ) ; NEW_LINE DEDENT
def sum_of_4_squares ( n ) : NEW_LINE INDENT i , odd , even = 0 , 0 , 0 NEW_LINE for i in range ( 1 , int ( n ** ( .5 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even += i NEW_LINE DEDENT else : NEW_LINE INDENT odd += i NEW_LINE DEDENT if ( ( n // i ) != i ) : NEW_LINE INDENT if ( ( n // i ) % 2 == 0 ) : NEW_LINE INDENT even += ( n // i ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += ( n // i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 8 * ( odd + even ) NEW_LINE DEDENT else : NEW_LINE INDENT return 24 * ( odd ) NEW_LINE DEDENT DEDENT
def mosaic ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and n > 0 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n //= i NEW_LINE count += 1 NEW_LINE DEDENT ans *= count * i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def lowerWythoff ( n ) : NEW_LINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = floor ( i * phi ) ; NEW_LINE print ( ans , end = " " ) ; NEW_LINE if ( i != n ) : NEW_LINE INDENT print ( " , ▁ " , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT
def Total_Ways ( n ) : NEW_LINE INDENT fac = 1 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fac = fac * i ; NEW_LINE DEDENT return ( fac * 2 ) ; NEW_LINE DEDENT
def UpperHessenbergMatrix ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( j > i + 1 ) : NEW_LINE INDENT print ( '0' , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( random . randint ( 1 , 10 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def UpperHessenbergMatrix ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > j + 1 ) : NEW_LINE INDENT print ( '0' , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( random . randint ( 1 , 10 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def count ( N ) : NEW_LINE INDENT a = 0 ; NEW_LINE a = ( N * ( N + 1 ) ) / 2 ; NEW_LINE return int ( a ) ; NEW_LINE DEDENT
def specialSieve ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE prime = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE for j in range ( i , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = cnt ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( prime [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def sameLength ( A , B ) : NEW_LINE INDENT while ( A > 0 and B > 0 ) : NEW_LINE INDENT A = A / 10 ; NEW_LINE B = B / 10 ; NEW_LINE DEDENT if ( A == 0 and B == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT A = 21 ; B = 1 ; NEW_LINE if ( sameLength ( A , B ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def isValidSeq ( a , n ) : NEW_LINE INDENT nodes = n + 2 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] < 1 or a [ i ] > nodes ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT
def e ( x , n ) : NEW_LINE INDENT global p , f NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT r = e ( x , n - 1 ) NEW_LINE p = p * x NEW_LINE f = f * n NEW_LINE return ( r + p / f ) NEW_LINE DEDENT
def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT
def numberOfMen ( D , m , d ) : NEW_LINE INDENT Men = ( m * ( D - d ) ) / d ; NEW_LINE return int ( Men ) ; NEW_LINE DEDENT
def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i * i <= x : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
def maxPeople ( p ) : NEW_LINE INDENT tmp = 0 ; count = 0 ; NEW_LINE for i in range ( 1 , int ( sqrt ( p ) ) + 1 ) : NEW_LINE INDENT tmp = tmp + ( i * i ) ; NEW_LINE if ( tmp <= p ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def getAverage ( x , y ) : NEW_LINE INDENT avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; NEW_LINE return avg NEW_LINE DEDENT
def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def closetAND ( arr , n , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = arr [ i ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT X &= arr [ j ] NEW_LINE ans = min ( ans , abs ( k - X ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def closetAND ( arr , n , k ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = arr [ i ] ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT X &= arr [ j ] ; NEW_LINE ans = min ( ans , abs ( k - X ) ) ; NEW_LINE if ( X <= k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT
def count_square ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT k = n - i + 1 ; NEW_LINE count += ( k * k ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def Rate ( N1 , N2 ) : NEW_LINE INDENT rate = ( N2 - N1 ) * 100 // ( N1 ) ; NEW_LINE return rate NEW_LINE DEDENT
def solve ( a , n ) : NEW_LINE INDENT ones , twos = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT twos += 1 NEW_LINE DEDENT DEDENT ind = 0 NEW_LINE if ( twos ) : NEW_LINE INDENT a [ ind ] = 2 NEW_LINE ind += 1 NEW_LINE DEDENT if ones % 2 == 0 : NEW_LINE INDENT evenOnes = True NEW_LINE DEDENT else : NEW_LINE INDENT evenOnes = False NEW_LINE DEDENT if ( evenOnes ) : NEW_LINE INDENT ones -= 1 NEW_LINE DEDENT for i in range ( ones ) : NEW_LINE INDENT a [ ind ] = 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( twos - 1 ) : NEW_LINE INDENT a [ ind ] = 2 NEW_LINE ind += 1 NEW_LINE DEDENT if ( evenOnes ) : NEW_LINE INDENT a [ ind ] = 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT
def maxEdges ( N ) : NEW_LINE INDENT edges = 0 ; NEW_LINE edges = ( N * N ) // 4 ; NEW_LINE return edges ; NEW_LINE DEDENT
def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A or B ) : NEW_LINE INDENT if ( ( A & 1 ) and ( B & 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def isSumEqual ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += ar [ i ] NEW_LINE DEDENT if ( sum == ar [ n - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findIndex ( a , n ) : NEW_LINE INDENT res , min_diff = None , float ( ' inf ' ) NEW_LINE prod = [ None ] * n NEW_LINE prod [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prod [ i ] = prod [ i - 1 ] * a [ i ] NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT curr_diff = abs ( ( prod [ n - 1 ] // prod [ i ] ) - prod [ i ] ) NEW_LINE if curr_diff < min_diff : NEW_LINE INDENT min_diff = curr_diff NEW_LINE res = i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def count_unique ( s , n ) : NEW_LINE INDENT if ( s . count ( n ) ) : NEW_LINE INDENT return ; NEW_LINE DEDENT s . append ( n ) ; NEW_LINE n += 1 ; NEW_LINE while ( n % 10 == 0 ) : NEW_LINE INDENT n = n // 10 ; NEW_LINE DEDENT count_unique ( s , n ) ; NEW_LINE DEDENT
def vertices ( N , A , B ) : NEW_LINE INDENT position = 0 NEW_LINE miniSum = 10 ** 9 NEW_LINE Sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i == A or i == B ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT x = abs ( i - A ) NEW_LINE y = abs ( i - B ) NEW_LINE Sum = x + y NEW_LINE if ( Sum < miniSum ) : NEW_LINE INDENT miniSum = Sum NEW_LINE position = i NEW_LINE DEDENT DEDENT DEDENT return position NEW_LINE DEDENT
def getValueOfF ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT cnt = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n /= 2 NEW_LINE DEDENT return 2 * cnt NEW_LINE DEDENT
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT
def oddTriangularNumber ( N ) : NEW_LINE INDENT return ( N * ( ( 2 * N ) - 1 ) ) NEW_LINE DEDENT
def idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT if ( ( a1 // a2 == b1 // b2 ) and ( a1 // a2 == c1 // c2 ) and ( b1 // b2 == c1 // c2 ) ) : NEW_LINE INDENT print ( " The ▁ given ▁ straight ▁ lines " , " are ▁ identical " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ given ▁ straight ▁ lines " , " are ▁ not ▁ identical " ) ; NEW_LINE DEDENT DEDENT
def area ( a , b , c ) : NEW_LINE INDENT d = abs ( ( c * c ) / ( 2 * a * b ) ) NEW_LINE return d NEW_LINE DEDENT
def line ( x0 , y0 ) : NEW_LINE INDENT c = 2 * y0 * x0 NEW_LINE print ( y0 , " x " , " + " , x0 , " y = " , c ) NEW_LINE DEDENT
def printOriginalMatrix ( a , b , mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT print ( min ( a [ i ] , b [ j ] ) , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT
def isOsiris ( n ) : NEW_LINE INDENT a = n % 10 NEW_LINE b = ( n // 10 ) % 10 NEW_LINE c = n // 100 NEW_LINE digit_sum = a + b + c NEW_LINE if ( n == ( 2 * ( digit_sum ) * 11 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isDudeney ( n ) : NEW_LINE INDENT cube_rt = int ( round ( ( pow ( n , 1.0 / 3.0 ) ) ) ) NEW_LINE if cube_rt * cube_rt * cube_rt != n : NEW_LINE INDENT return False NEW_LINE DEDENT dig_sum = 0 NEW_LINE temp = n NEW_LINE while temp > 0 : NEW_LINE INDENT rem = temp % 10 NEW_LINE dig_sum += rem NEW_LINE temp //= 10 NEW_LINE DEDENT if cube_rt != dig_sum : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def countTriangles ( a , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE pairs = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT pairs += a [ i ] // 2 NEW_LINE if ( a [ i ] % 2 == 1 and pairs > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE pairs -= 1 NEW_LINE DEDENT DEDENT cnt += ( 2 * pairs ) // 3 NEW_LINE return cnt NEW_LINE DEDENT
def smallestMultiple ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE i , Sum = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] - ( Sum - arr [ i ] ) ) > k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def getHCF ( x , y ) : NEW_LINE INDENT minimum = min ( x , y ) NEW_LINE if ( x % minimum == 0 and y % minimum == 0 ) : NEW_LINE INDENT return minimum NEW_LINE DEDENT for i in range ( minimum // 2 , 1 , - 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if j * i <= n : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findMaxCock ( ar ) : NEW_LINE INDENT if ( R < 3 or C < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_sum = - sys . maxsize - 1 NEW_LINE for i in range ( R - 2 ) : NEW_LINE INDENT for j in range ( C - 2 ) : NEW_LINE INDENT sum = ( ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ) NEW_LINE max_sum = max ( max_sum , sum ) NEW_LINE DEDENT DEDENT return max_sum ; NEW_LINE DEDENT
def segments ( n , p , m ) : NEW_LINE INDENT c = dict ( ) NEW_LINE c [ 0 ] = 1 NEW_LINE has = False NEW_LINE Sum = 0 NEW_LINE ans = 0 NEW_LINE for r in range ( n ) : NEW_LINE INDENT if ( p [ r ] < m ) : NEW_LINE INDENT Sum -= 1 NEW_LINE DEDENT elif ( p [ r ] > m ) : NEW_LINE INDENT Sum += 1 NEW_LINE DEDENT if ( p [ r ] == m ) : NEW_LINE INDENT has = True NEW_LINE DEDENT if ( has ) : NEW_LINE INDENT if ( Sum in c . keys ( ) ) : NEW_LINE INDENT ans += c [ Sum ] NEW_LINE DEDENT if Sum - 1 in c . keys ( ) : NEW_LINE INDENT ans += c [ Sum - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT c [ Sum ] = c . get ( Sum , 0 ) + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def ellipsearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = ( 3.14 * r * r ) / 4 ; NEW_LINE return a ; NEW_LINE DEDENT
def decideWinner ( a , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE count3 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 4 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 2 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 3 ) : NEW_LINE INDENT count3 += 1 NEW_LINE DEDENT DEDENT if ( count0 % 2 == 0 and count1 % 2 == 0 and count2 % 2 == 0 and count3 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT a = [ 4 , 8 , 5 , 9 ] NEW_LINE n = len ( a ) NEW_LINE if ( decideWinner ( a , n ) == 1 ) : NEW_LINE INDENT print ( " X ▁ wins " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Y ▁ wins " ) NEW_LINE DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT mp = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 ; NEW_LINE DEDENT maxFreq = - ( sys . maxsize - 1 ) ; NEW_LINE for key in mp : NEW_LINE INDENT maxFreq = max ( maxFreq , mp [ key ] ) ; NEW_LINE DEDENT return ( n - maxFreq ) ; NEW_LINE DEDENT
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( ( number % x == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT number = ( number * 2 + arr [ i ] ) % x NEW_LINE if number == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT
def countCon ( ar , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ar [ i ] == ar [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def printElements ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def noOfYears ( t1 , n1 , t2 ) : NEW_LINE INDENT years = ( t2 - 1 ) * n1 / ( t1 - 1 ) NEW_LINE return years NEW_LINE DEDENT
def numLen ( K ) : NEW_LINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT number = 0 NEW_LINE len = 1 NEW_LINE for len in range ( 1 , K + 1 ) : NEW_LINE INDENT number = ( number * 10 + 1 ) % K NEW_LINE if number == 0 : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def precomputation ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum1 [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum2 [ j ] += ( sum1 [ j ] - i ) * i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum2 [ i ] = int ( sum2 [ i ] / 2 ) NEW_LINE DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum3 [ i ] = int ( sum3 [ i ] / 3 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum3 [ arr [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def sum ( k , n ) : NEW_LINE INDENT sum = ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) ; NEW_LINE return sum ; NEW_LINE DEDENT
def isPossible ( n ) : NEW_LINE INDENT fac = [ 0 for i in range ( 10 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE fac [ 1 ] = 1 NEW_LINE for i in range ( 2 , 10 , 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT sum = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT sum += fac [ x % 10 ] NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT if ( sum % n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def computeXOR ( n ) : NEW_LINE INDENT switch = { 0 : n , 1 : 1 , 2 : n + 1 , 3 : 0 , } NEW_LINE return switch . get ( n & 3 , " " ) NEW_LINE DEDENT
def countNumbers ( x , n ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ) NEW_LINE DEDENT
def countSquares ( r , c , m ) : NEW_LINE INDENT squares = 0 NEW_LINE for i in range ( 1 , 9 ) : NEW_LINE INDENT for j in range ( 1 , 9 ) : NEW_LINE INDENT if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) : NEW_LINE INDENT squares = squares + 1 NEW_LINE DEDENT DEDENT DEDENT return squares NEW_LINE DEDENT
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len = 1 ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] <= arr [ i ] ) : NEW_LINE INDENT len += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) ; NEW_LINE len = 1 ; NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) ; NEW_LINE DEDENT return int ( cnt ) ; NEW_LINE DEDENT
def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) NEW_LINE DEDENT
def wastedWater ( V , M , N ) : NEW_LINE INDENT amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT
def sphereSide ( h , r ) : NEW_LINE INDENT if h < 0 and r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = ( ( ( h * r * math . sqrt ( 2 ) ) ) / ( h + math . sqrt ( 2 ) * r ) / 2 ) NEW_LINE return R NEW_LINE DEDENT
def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( " Loss ▁ = " , round ( loss , 3 ) ) NEW_LINE DEDENT
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT return n // 4 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 ; NEW_LINE DEDENT DEDENT
def countSubarrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT product = 1 NEW_LINE for x in range ( i , j + 1 ) : NEW_LINE INDENT product *= arr [ x ] NEW_LINE DEDENT if ( product % K == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def Permutations ( n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE if k >= 2 : NEW_LINE INDENT ans += ( n ) * ( n - 1 ) // 2 NEW_LINE DEDENT if k >= 3 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * 2 // 6 ) NEW_LINE DEDENT if k >= 4 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 // 24 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE rem = [ 0 ] * K ; NEW_LINE rem [ 0 ] = N // K ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 ; NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 ; NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] ; NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 ; NEW_LINE for i in rage ( 1 , K // 2 + 1 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
def nDigitPerfectSquares ( n ) : NEW_LINE INDENT print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) , end = " ▁ " ) ; NEW_LINE print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ) ; NEW_LINE DEDENT
def MaxTraceSub ( mat ) : NEW_LINE INDENT max_trace = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r = i NEW_LINE s = j NEW_LINE trace = 0 NEW_LINE while ( r < N and s < N ) : NEW_LINE INDENT trace += mat [ r ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE max_trace = max ( trace , max_trace ) NEW_LINE DEDENT DEDENT DEDENT return max_trace NEW_LINE DEDENT
def lastDigit ( a , b ) : NEW_LINE INDENT lastDig = ( ( int ( a [ len ( a ) - 1 ] ) - int ( '0' ) ) * ( int ( b [ len ( b ) - 1 ] ) - int ( '0' ) ) ) NEW_LINE print ( lastDig % 10 ) NEW_LINE DEDENT
def printPalindrome ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Smallest ▁ Palindrome : ▁ 0" ) NEW_LINE print ( " Largest ▁ Palindrome : ▁ 9" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Smallest ▁ Palindrome : " , int ( pow ( 10 , n - 1 ) ) + 1 ) NEW_LINE print ( " Largest ▁ Palindrome : " , int ( pow ( 10 , n ) ) - 1 ) NEW_LINE DEDENT DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a // b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT return math . floor ( math . log10 ( abs ( a ) ) - math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT
def smallestOdd ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return pow ( 10 , n - 1 ) + 1 NEW_LINE DEDENT
def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( ceil ( ( pow ( 10 , ( n - 1 ) ) ) ** ( 1 / 3 ) ) , 3 ) , end = " ▁ " ) NEW_LINE print ( pow ( ceil ( ( pow ( 10 , ( n ) ) ) ** ( 1 / 3 ) ) - 1 , 3 ) ) NEW_LINE DEDENT
def findNumbers ( n ) : NEW_LINE INDENT odd = pow ( 10 , n ) - 1 NEW_LINE even = odd - 1 NEW_LINE print ( " Even ▁ = ▁ " , even ) NEW_LINE print ( " Odd ▁ = ▁ " , odd ) NEW_LINE DEDENT
def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def smallestEven ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT
def printBalancedExpression ( a , b , c , d ) : NEW_LINE INDENT if ( ( a == d and a ) or ( a == 0 and c == 0 and d == 0 ) ) : NEW_LINE INDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT print ( " ( ( " , end = " " ) NEW_LINE DEDENT for i in range ( 1 , c + 1 ) : NEW_LINE INDENT print ( " ) ( " , end = " " ) NEW_LINE DEDENT for i in range ( 1 , d + 1 ) : NEW_LINE INDENT print ( " ) ) " , end = " " ) NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT print ( " ( ) " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT ans = pow ( n % MOD , 2 ) NEW_LINE return ( ans % MOD ) NEW_LINE DEDENT
def kthOdd ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return arr [ i ] ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( ( int ) ( n / 10000 ) * 10000 + ( ( int ) ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( int ) ( n / 10 ) % 10 ) * 10 + ( int ) ( n / 1000 ) % 10 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def maxValue ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( n * n // 2 ) - 1 ) NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * pow ( 10 , n // 2 - 1 ) ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT
def sumN ( n ) : NEW_LINE INDENT n = ( n + 1 ) // 2 ; NEW_LINE return ( n * n ) ; NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT return ( n - n // 2 - n // 3 - n // 5 - n // 7 + n // 6 + n // 10 + n // 14 + n // 15 + n // 21 + n // 35 - n // 30 - n // 42 - n // 70 - n // 105 + n // 210 ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( n , n ) + sum ( n - 1 ) NEW_LINE DEDENT DEDENT
def findThirdDigit ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 if n and 1 else 6 NEW_LINE DEDENT
def maxPrmimes ( n ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT
def Sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) // 3 NEW_LINE DEDENT
def numbers ( n ) : NEW_LINE INDENT return pow ( 2 , n + 1 ) - 2 NEW_LINE DEDENT
def NumbersofWays ( n ) : NEW_LINE INDENT x = ( n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) // ( 4 * 3 * 2 * 1 ) NEW_LINE y = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) NEW_LINE return x * y NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT return n // 2520 NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT nth += pow ( i , i ) NEW_LINE DEDENT return nth NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE nth = ( N * N * ( N + 1 ) ) // 2 NEW_LINE return nth NEW_LINE DEDENT
def kthSmallest ( n , k ) : NEW_LINE INDENT return 2 * k NEW_LINE DEDENT
def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT n = 10 NEW_LINE if isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT print ( ( 2 * i ) - 1 , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def getTime ( u , v , x ) : NEW_LINE INDENT speed = u + v NEW_LINE time = x / speed NEW_LINE return time NEW_LINE DEDENT
def getProbability ( a , b , c , d ) : NEW_LINE INDENT p = a / b ; NEW_LINE q = c / d ; NEW_LINE ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; NEW_LINE return round ( ans , 5 ) ; NEW_LINE DEDENT
def findMinimum ( x , y ) : NEW_LINE INDENT low = 0 NEW_LINE high = y NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( ( mid * 2 + ( y - mid ) ) >= x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT
def getResult ( n ) : NEW_LINE INDENT proOdd = 1 NEW_LINE proEven = 1 NEW_LINE num = str ( n ) NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT proOdd = proOdd * int ( num [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT proEven = proEven * int ( num [ i ] ) NEW_LINE DEDENT DEDENT if ( proOdd == proEven ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def LucasSum ( N ) : NEW_LINE INDENT Sum = 0 NEW_LINE a = 2 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE Sum += a NEW_LINE while ( b <= N ) : NEW_LINE INDENT Sum += b NEW_LINE c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def countNumbers ( l , r ) : NEW_LINE INDENT return ( ( r // 6 ) - ( l - 1 ) // 6 ) ; NEW_LINE DEDENT
def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT
def BalanceArray ( A , Q ) : NEW_LINE INDENT ANS = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += A [ i ] ; NEW_LINE DEDENT DEDENT for i in range ( len ( Q ) ) : NEW_LINE INDENT index = Q [ i ] [ 0 ] ; NEW_LINE value = Q [ i ] [ 1 ] ; NEW_LINE if ( A [ index ] % 2 == 0 ) : NEW_LINE INDENT sum -= A [ index ] ; NEW_LINE DEDENT A [ index ] += value ; NEW_LINE if ( A [ index ] % 2 == 0 ) : NEW_LINE INDENT sum += A [ index ] ; NEW_LINE DEDENT ANS . append ( sum ) ; NEW_LINE DEDENT for i in range ( len ( ANS ) ) : NEW_LINE INDENT print ( ANS [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def findMinSum ( arr , n ) : NEW_LINE INDENT occ = n - 1 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] * pow ( 2 , occ ) NEW_LINE occ -= 1 NEW_LINE DEDENT return Sum NEW_LINE DEDENT
def findMinSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] * ( n - i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getPosition ( n , m ) : NEW_LINE INDENT if ( m > ( n // 2 ) ) : NEW_LINE INDENT return ( m - ( n // 2 ) ) NEW_LINE DEDENT return ( m + ( n // 2 ) ) NEW_LINE DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT Sum = 0 NEW_LINE largestDivisible , minimum = - 1 , arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return Sum NEW_LINE DEDENT sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) ) NEW_LINE return min ( Sum , sumAfterOperation ) NEW_LINE DEDENT
def submatrixXor ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT top_left = ( i + 1 ) * ( j + 1 ) NEW_LINE bottom_right = ( n - i ) * ( n - j ) NEW_LINE if ( top_left % 2 == 1 and bottom_right % 2 == 1 ) : NEW_LINE INDENT ans = ( ans ^ arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findAnswer ( X , N ) : NEW_LINE INDENT return ( N - 1 ) * 9 + X ; NEW_LINE DEDENT
def count ( N , K , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % K == R ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def getCount ( a , b , c ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , 82 ) : NEW_LINE INDENT cr = b * pow ( i , a ) + c NEW_LINE tmp = cr NEW_LINE sm = 0 NEW_LINE while ( tmp ) : NEW_LINE INDENT sm += tmp % 10 NEW_LINE tmp //= 10 NEW_LINE DEDENT if ( sm == i and cr < 10 ** 9 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isSpiltPossible ( n , a ) : NEW_LINE INDENT Sum = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( Sum % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( Sum // 2 ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 3 NEW_LINE a = [ 1 , 1 , 2 ] NEW_LINE if ( isSpiltPossible ( n , a ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def matrixSum ( arr ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT top_left = ( i + 1 ) * ( j + 1 ) ; NEW_LINE bottom_right = ( n - i ) * ( n - j ) ; NEW_LINE sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT
def maxAND ( L , R ) : NEW_LINE INDENT maximum = L & R NEW_LINE for i in range ( L , R , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 , 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i & j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT
def maxAND ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L ; NEW_LINE DEDENT elif ( ( R - L ) == 1 ) : NEW_LINE INDENT return ( R & L ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) : NEW_LINE INDENT return ( ( R - 1 ) & R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( R - 2 ) & ( R - 1 ) ) ; NEW_LINE DEDENT DEDENT DEDENT
def checkArray ( arr , n ) : NEW_LINE INDENT return ( ( arr [ 0 ] % 2 ) and ( arr [ n - 1 ] % 2 ) and ( n % 2 ) ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) ; NEW_LINE if checkArray ( arr , n ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
def findCount ( arr , n ) : NEW_LINE INDENT countOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT countOdd += 1 ; NEW_LINE DEDENT DEDENT if ( countOdd % 2 == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT
def Cycles ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE result = N - 1 NEW_LINE i = result NEW_LINE while ( i > 0 ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact // 2 NEW_LINE DEDENT
def getMaxNum ( a , b , c ) : NEW_LINE INDENT if ( b % c == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT x = ( ( b // c ) * c ) NEW_LINE if ( x >= a and x <= b ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def printPermutation ( n , k ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = 2 * i - 1 ; NEW_LINE y = 2 * i ; NEW_LINE if ( i <= k ) : NEW_LINE INDENT print ( y , x , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , y , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def isPossible ( Sx , Sy , Dx , Dy , x , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT Sx = 0 ; NEW_LINE Sy = 0 ; NEW_LINE Dx = 0 ; NEW_LINE Dy = 0 ; NEW_LINE x = 3 ; NEW_LINE y = 4 ; NEW_LINE if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def getPairs ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( a ) ) : NEW_LINE INDENT if ( a [ i ] < a [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def getPairs ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE count = ( n * ( n - 1 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT
def calcNodes ( N , I ) : NEW_LINE INDENT result = 0 NEW_LINE result = I * ( N - 1 ) + 1 NEW_LINE return result NEW_LINE DEDENT
def countRhombi ( h , w ) : NEW_LINE INDENT ct = 0 ; NEW_LINE for i in range ( 2 , h + 1 , 2 ) : NEW_LINE INDENT for j in range ( 2 , w + 1 , 2 ) : NEW_LINE INDENT ct += ( h - i + 1 ) * ( w - j + 1 ) NEW_LINE DEDENT DEDENT return ct NEW_LINE DEDENT
def maxSum ( N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for u in range ( 1 , N + 1 ) : NEW_LINE INDENT for v in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( u == v ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT degreeU = 2 ; NEW_LINE if ( u == 1 or u == N ) : NEW_LINE INDENT degreeU = 1 ; NEW_LINE DEDENT degreeV = 2 ; NEW_LINE if ( v == 1 or v == N ) : NEW_LINE INDENT degreeV = 1 ; NEW_LINE DEDENT ans += ( degreeU * degreeV ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def countSquares ( row , column ) : NEW_LINE INDENT topLeft = min ( row , column ) - 1 NEW_LINE bottomRight = 8 - max ( row , column ) NEW_LINE topRight = min ( row , 9 - column ) - 1 NEW_LINE bottomLeft = 8 - max ( row , 9 - column ) NEW_LINE return ( topLeft + topRight + bottomRight + bottomLeft ) NEW_LINE DEDENT
def canTakeDown ( bishopX , bishopY , pawnX , pawnY ) : NEW_LINE INDENT if ( pawnX - bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( - pawnX + bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT bishopX = 5 NEW_LINE bishopY = 5 NEW_LINE pawnX = 1 NEW_LINE pawnY = 1 NEW_LINE if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def calculateArea ( x , y ) : NEW_LINE INDENT pi = 3.1415926536 NEW_LINE arx = pi * x * x NEW_LINE ary = pi * y * y NEW_LINE return arx - ary NEW_LINE DEDENT
def findValues ( a , b ) : NEW_LINE INDENT if ( ( a - b ) % 2 == 1 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( ( a - b ) // 2 , ( a + b ) // 2 ) ; NEW_LINE DEDENT
def findPrimeFactors ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( primeFactors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT primeFactors [ j ] = primeFactors [ j // i ] + 1 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT primeFactors [ i ] += primeFactors [ i - 1 ] ; NEW_LINE DEDENT DEDENT
def minValue ( n , x , y ) : NEW_LINE INDENT val = ( y * n ) / 100 NEW_LINE if x >= val : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( val ) - x NEW_LINE DEDENT DEDENT
def mixtureConcentration ( n , p ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += p [ i ] ; NEW_LINE DEDENT res /= n ; NEW_LINE return res ; NEW_LINE DEDENT
def isPossible ( n , k , arr ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT if ( int ( maxVal ) > int ( ( sum + k ) / n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def countOddSquares ( n , m ) : NEW_LINE INDENT return ( int ( pow ( m , 0.5 ) ) - int ( pow ( n - 1 , 0.5 ) ) ) NEW_LINE DEDENT
def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT
def findNumber ( n , m ) : NEW_LINE INDENT num = ( m - 1 ) * 9 + n ; NEW_LINE return num ; NEW_LINE DEDENT
def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if ( floor ( z ) == ceil ( z ) ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT
def make_sequence ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 2 NEW_LINE DEDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % 2 == 1 ) : NEW_LINE INDENT arr [ 2 ] = 3 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countOdd ( L , R ) : NEW_LINE INDENT N = ( R - L ) // 2 NEW_LINE if ( R % 2 != 0 or L % 2 != 0 ) : NEW_LINE INDENT N += 1 NEW_LINE DEDENT return N NEW_LINE DEDENT
def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT
def generateSequence ( n , g ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i * g , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT
def isEvenOrOdd ( L , R ) : NEW_LINE INDENT oddCount = ( R - L ) / 2 NEW_LINE if ( R % 2 == 1 or L % 2 == 1 ) : NEW_LINE INDENT oddCount = oddCount + 1 NEW_LINE DEDENT if ( oddCount % 2 == 0 ) : NEW_LINE INDENT return " Even " NEW_LINE DEDENT else : NEW_LINE INDENT return " Odd " NEW_LINE DEDENT DEDENT
def countPairs ( n ) : NEW_LINE INDENT num = ( ( n // 2 ) + 1 ) NEW_LINE Max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == Max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT num = ( ( n // 2 ) + 1 ) ; NEW_LINE max = n % num ; NEW_LINE count = n - max ; NEW_LINE return count NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 ; NEW_LINE sum += k ; NEW_LINE n /= 10 ; NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " ; NEW_LINE DEDENT return " NO " ; NEW_LINE DEDENT
def getResult ( n ) : NEW_LINE INDENT st = str ( n ) NEW_LINE sum = 0 NEW_LINE length = len ( st ) NEW_LINE for i in st : NEW_LINE INDENT sum = sum + int ( i ) NEW_LINE DEDENT if ( n % sum == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT
def alter ( x , y ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( x == 0 or y == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( x >= 2 * y ) : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif ( y >= 2 * x ) : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " X ▁ = " , x , " , ▁ " , " Y ▁ = " , y ) NEW_LINE DEDENT
def secondary_polygon ( Angle ) : NEW_LINE INDENT edges_primary = 360 // Angle NEW_LINE if edges_primary >= 6 : NEW_LINE INDENT edges_max_secondary = edges_primary // 2 NEW_LINE return edges_max_secondary + 3 NEW_LINE DEDENT else : NEW_LINE INDENT return " Not ▁ Possible " NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 NEW_LINE if ( temp % k == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n /= 10 ; NEW_LINE DEDENT return " NO " NEW_LINE DEDENT
def getResult ( n ) : NEW_LINE INDENT st = str ( n ) NEW_LINE for i in st : NEW_LINE INDENT if ( n % int ( i ) == 0 ) : NEW_LINE INDENT return ' Yes ' NEW_LINE DEDENT DEDENT return ' No ' NEW_LINE DEDENT
def largestCoprime ( N ) : NEW_LINE INDENT if N == 6 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif N % 4 == 0 : NEW_LINE INDENT return N // 2 - 1 NEW_LINE DEDENT elif N % 2 == 0 : NEW_LINE INDENT return N // 2 - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) // 2 NEW_LINE DEDENT DEDENT
def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def nthTermOfTheSeries ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT nthTerm = pow ( n - 1 , 2 ) + n NEW_LINE DEDENT else : NEW_LINE INDENT nthTerm = pow ( n + 1 , 2 ) + n NEW_LINE DEDENT return nthTerm NEW_LINE DEDENT
def divide ( a , b ) : NEW_LINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( " A ▁ = " , a , " , ▁ B ▁ = " , b ) NEW_LINE DEDENT
def minAbsDiff ( n ) : NEW_LINE INDENT left = 1 << ( int ) ( math . floor ( math . log2 ( n ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT
def find_probability ( p , q , r , s ) : NEW_LINE INDENT t = ( 1 - p / q ) * ( 1 - r / s ) NEW_LINE ans = ( p / q ) / ( 1 - t ) ; NEW_LINE return round ( ans , 9 ) NEW_LINE DEDENT
def Nthterm ( n ) : NEW_LINE INDENT numerator = n ** 2 - 1 NEW_LINE denomenator = 2 * n - 3 NEW_LINE print ( numerator , " / " , denomenator ) NEW_LINE DEDENT
def sumArray ( arr , n ) : NEW_LINE INDENT leftSum = [ 0 for i in range ( n ) ] NEW_LINE rightSum = [ 0 for i in range ( n ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE i , j = 0 , 0 NEW_LINE leftSum [ 0 ] = 0 NEW_LINE rightSum [ n - 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] = leftSum [ i ] + rightSum [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( Sum [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def calSum ( n ) : NEW_LINE INDENT return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; NEW_LINE DEDENT
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 1 for i in range ( n + 1 ) ] NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def nthterm ( n ) : NEW_LINE INDENT An = ( 1 ** n + 2 ** n ) * ( 3 ** n ) NEW_LINE return An ; NEW_LINE DEDENT
def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i NEW_LINE sec = n // i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 // k ) * ( num1 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num1 , mini ) NEW_LINE DEDENT num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return mini NEW_LINE DEDENT
def minimumX ( n , k ) : NEW_LINE INDENT ans = 10 ** 18 NEW_LINE for i in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans = min ( ans , i + ( n / i ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getSum ( arr , p ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT
def getHermiteNumber ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ) NEW_LINE DEDENT DEDENT
def find ( n ) : NEW_LINE INDENT b = n NEW_LINE a = b * ( n - 1 ) NEW_LINE if a * b > n and a // b < n : NEW_LINE INDENT print ( " a ▁ = ▁ { } , ▁ b ▁ = ▁ { } " . format ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def SquareCube ( N ) : NEW_LINE INDENT cnt , i = 0 , 1 NEW_LINE while ( i ** 6 <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( d <= n ) : NEW_LINE INDENT sum += d NEW_LINE d += 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT d = 2 NEW_LINE a1 = 0 NEW_LINE An = a1 + ( n - 1 ) * d NEW_LINE An = An ** 3 NEW_LINE return An ; NEW_LINE DEDENT
def printThreeParts ( N ) : NEW_LINE INDENT if ( N % 3 == 0 ) : NEW_LINE INDENT print ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " , N - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " , N - 3 ) NEW_LINE DEDENT DEDENT
def countDigitsToBeRemoved ( N , K ) : NEW_LINE INDENT s = str ( N ) ; NEW_LINE res = 0 ; NEW_LINE f_zero = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT f_zero = 1 ; NEW_LINE K -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT res += 1 ; NEW_LINE DEDENT DEDENT if ( K == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT elif ( f_zero > 0 ) : NEW_LINE INDENT return len ( s ) - 1 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE x = 1 NEW_LINE while x <= n : NEW_LINE INDENT sum = sum + x NEW_LINE x = x + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def check ( a , y ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = math . sqrt ( a [ i ] ) NEW_LINE if ( math . floor ( x ) == math . ceil ( x ) ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT DEDENT if ( sum % y == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE x = 13 NEW_LINE if check ( a , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findLargestDivisor ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT while ( n % ( i * i ) == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def findMedian ( a , n ) : NEW_LINE INDENT sorted ( a ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT return float ( a [ n // 2 ] ) NEW_LINE DEDENT return float ( ( a [ int ( ( n - 1 ) / 2 ) ] + a [ int ( n / 2 ) ] ) / 2.0 ) NEW_LINE DEDENT
def printAMeans ( A , B , N ) : NEW_LINE INDENT d = ( B - A ) / ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( int ( A + i * d ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while finalNum * 2 <= n : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT
def isTriPerfect ( n ) : NEW_LINE INDENT sum = 1 + n NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == 3 * n and n != 1 else False ) NEW_LINE DEDENT n = 120 NEW_LINE if isTriPerfect ( n ) : NEW_LINE INDENT print ( n , " is ▁ a ▁ Triperfect ▁ number " ) NEW_LINE DEDENT
def MinimumMaximumPairs ( n , m ) : NEW_LINE INDENT max_pairs = ( ( n - m + 1 ) * ( n - m ) ) // 2 ; NEW_LINE min_pairs = ( m * ( ( ( n - m ) // m + 1 ) * ( ( n - m ) // m ) ) // 2 + ceil ( ( n - m ) / ( m ) ) * ( ( n - m ) % m ) ) NEW_LINE print ( " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " , min_pairs ) NEW_LINE print ( " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " , max_pairs ) NEW_LINE DEDENT
def sum ( N , X , Y ) : NEW_LINE INDENT S1 = floor ( floor ( N / X ) * floor ( 2 * X + floor ( N / X - 1 ) * X ) / 2 ) NEW_LINE S2 = floor ( floor ( N / Y ) ) * floor ( 2 * Y + floor ( N / Y - 1 ) * Y ) / 2 NEW_LINE S3 = floor ( floor ( N / ( X * Y ) ) ) * floor ( 2 * ( X * Y ) + floor ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT
def findTwoThreePrime ( l , r ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE while ( num % 2 == 0 ) : NEW_LINE INDENT num //= 2 ; NEW_LINE DEDENT while ( num % 3 == 0 ) : NEW_LINE INDENT num //= 3 NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countIntervals ( arr , V , N ) : NEW_LINE INDENT minimum = float ( " inf " ) NEW_LINE maximum = 0 NEW_LINE freq = [ 0 ] * ( MAX_VAL ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE freq [ li ] = freq [ li ] + 1 NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE freq [ ri + 1 ] = freq [ ri + 1 ] - 1 NEW_LINE if li < minimum : NEW_LINE INDENT minimum = li NEW_LINE DEDENT if ri > maximum : NEW_LINE INDENT maximum = ri NEW_LINE DEDENT DEDENT for i in range ( minimum , maximum + 1 ) : NEW_LINE INDENT freq [ i ] = freq [ i ] + freq [ i - 1 ] NEW_LINE DEDENT return freq [ V ] NEW_LINE DEDENT
def findNth ( N ) : NEW_LINE INDENT b = 14 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT b = b * 2 NEW_LINE DEDENT else : NEW_LINE INDENT b = b - 8 NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT
def addNDigits ( a , b , n ) : NEW_LINE INDENT num = a NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT tmp = a * 10 + i NEW_LINE if ( tmp % b == 0 ) : NEW_LINE INDENT a = tmp NEW_LINE break NEW_LINE DEDENT DEDENT if ( num == a ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for j in range ( n - 1 ) : NEW_LINE INDENT a *= 10 NEW_LINE DEDENT return a NEW_LINE DEDENT
def countMoves ( n ) : NEW_LINE INDENT ct = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ct += i * ( n - i ) NEW_LINE DEDENT ct += n NEW_LINE return ct NEW_LINE DEDENT
def Triplets ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = i * i + j * j NEW_LINE y = int ( math . sqrt ( x ) ) NEW_LINE if ( y * y == x and y <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def Valid ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c == 180 ) and a != 0 and b != 0 and c != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def countNumber ( n ) : NEW_LINE INDENT return ( pow ( 10 , n ) - 1 ) - ( pow ( 10 , n ) - pow ( 8 , n ) ) // 2 NEW_LINE DEDENT
def calcDeterminant ( arr , n ) : NEW_LINE INDENT determinant = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT determinant += pow ( arr [ i ] , 3 ) NEW_LINE DEDENT determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] NEW_LINE return determinant NEW_LINE DEDENT
def minimumMoves ( k , l , r ) : NEW_LINE INDENT count = r - l + 1 NEW_LINE if ( count % k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( k - ( count % k ) ) NEW_LINE DEDENT
def Alphabet_N_Pattern ( N ) : NEW_LINE INDENT Right = 1 NEW_LINE Left = 1 NEW_LINE Diagonal = 2 NEW_LINE for index in range ( N ) : NEW_LINE INDENT print ( Left , end = " " ) NEW_LINE Left += 1 NEW_LINE for side_index in range ( 0 , 2 * ( index ) , 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT if ( index != 0 and index != N - 1 ) : NEW_LINE INDENT print ( Diagonal , end = " " ) NEW_LINE Diagonal += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for side_index in range ( 0 , 2 * ( N - index - 1 ) , 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( Right , end = " " ) NEW_LINE Right += 1 NEW_LINE print ( " " , ▁ end ▁ = ▁ " " ) NEW_LINE DEDENT DEDENT
def printGroups ( n ) : NEW_LINE INDENT x = 1 NEW_LINE y = n * n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT print ( " { " , x , " , " , y , " } " , end = " ▁ " ) NEW_LINE x += 1 NEW_LINE y -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == sum - arr [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == prod / arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE if res != 0 : NEW_LINE res = math . ceil ( exp / earn ) NEW_LINE else : NEW_LINE res = float ( ' inf ' ) NEW_LINE return res NEW_LINE DEDENT
def otherNumber ( a , Lcm , Hcf ) : NEW_LINE INDENT return ( Lcm * Hcf ) // A NEW_LINE DEDENT
def sum ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , min ( a , b ) ) : NEW_LINE INDENT if ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s / n + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return s / n ; NEW_LINE DEDENT DEDENT
def contiguousPerfectSquare ( arr , n ) : NEW_LINE INDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT b = sqrt ( arr [ i ] ) NEW_LINE a = int ( b ) NEW_LINE if ( a == b ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT
def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp /= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp /= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp /= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return " YES " NEW_LINE DEDENT DEDENT return " NO " NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def getSum ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i / math . pow ( a , i ) ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = pow ( i - mx , i - mx ) NEW_LINE finalDenominator = ( finalDenominator * denominator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT
def getResult ( n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - sqrt ( val ) ) / 2.0 NEW_LINE print ( " a ▁ = " , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( " b ▁ = " , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT
def minOperations ( A , n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zeros , consZeros , ones = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( i + 1 < n ) : NEW_LINE INDENT if A [ i ] == 0 and A [ i + 1 ] == 0 : NEW_LINE INDENT consZeros += 1 NEW_LINE DEDENT DEDENT DEDENT if A [ 0 ] == A [ n - 1 ] and A [ 0 ] == 0 : NEW_LINE INDENT consZeros += 1 NEW_LINE DEDENT if zeros == ones : NEW_LINE INDENT return consZeros NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
def profitLoss ( N , M ) : NEW_LINE INDENT if ( N == M ) : NEW_LINE INDENT print ( " No ▁ Profit ▁ nor ▁ Loss " ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0.0 NEW_LINE result = float ( abs ( N - M ) ) / M NEW_LINE if ( N - M < 0 ) : NEW_LINE INDENT print ( " Loss ▁ = ▁ - " , ' { 0 : . 6 } ' . format ( result * 100 ) , " % " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Profit ▁ = ▁ " , ' { 0 : . 6 } ' . format ( result * 100 ) , " % " ) NEW_LINE DEDENT DEDENT DEDENT
def countPieces ( N ) : NEW_LINE INDENT return 2 * N NEW_LINE DEDENT
def SellingPrice ( CP , PP ) : NEW_LINE INDENT Pdecimal = 1 + ( PP / 100 ) NEW_LINE res = Pdecimal * CP NEW_LINE return res NEW_LINE DEDENT
def lastCoordinate ( n , a , b ) : NEW_LINE INDENT return ( ( ( n + 1 ) // 2 ) * a - ( n // 2 ) * b ) NEW_LINE DEDENT
def findNum ( N , K ) : NEW_LINE INDENT rem = ( N + K ) % K ; NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return ( N + K - rem ) NEW_LINE DEDENT DEDENT
def minimum ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE DEDENT product = product * i NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT product = product * n NEW_LINE DEDENT return product NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE product = 1 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( d > 0 and n % d == 0 ) : NEW_LINE INDENT sum += d NEW_LINE product *= d NEW_LINE DEDENT DEDENT print ( " Sum ▁ = " , sum ) NEW_LINE print ( " Product ▁ = " , product ) NEW_LINE DEDENT
def findNum ( N , K ) : NEW_LINE INDENT rem = N % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N - rem NEW_LINE DEDENT DEDENT
def countNumbers ( N ) : NEW_LINE INDENT return int ( math . sqrt ( N ) ) - 1 NEW_LINE DEDENT
def countOrderedPairs ( N ) : NEW_LINE INDENT count_pairs = 0 NEW_LINE p = int ( sqrt ( N - 1 ) ) + 1 NEW_LINE q = int ( sqrt ( N ) ) + 2 NEW_LINE for i in range ( 1 , p , 1 ) : NEW_LINE INDENT for j in range ( i , q , 1 ) : NEW_LINE INDENT count_pairs += 1 NEW_LINE DEDENT DEDENT count_pairs *= 2 NEW_LINE count_pairs -= int ( sqrt ( N - 1 ) ) NEW_LINE return count_pairs NEW_LINE DEDENT
def pairwiseDifference ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE print ( diff , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def GIF ( n ) : NEW_LINE INDENT return int ( math . floor ( n ) ) ; NEW_LINE DEDENT
def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT
def countRabbits ( Heads , Legs ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( Legs ) - 2 * ( Heads ) NEW_LINE count = count / 2 NEW_LINE return count NEW_LINE DEDENT
def SumDivisible ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE position = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( position % 2 == 1 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE position += 1 NEW_LINE DEDENT if ( sum % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isTriangleExists ( a , b , c ) : NEW_LINE INDENT if ( a != 0 and b != 0 and c != 0 and ( a + b + c ) == 180 ) : NEW_LINE INDENT if ( ( a + b ) >= c or ( b + c ) >= a or ( a + c ) >= b ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT maxAnd = max ( a ) NEW_LINE maxOR = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxOR |= a [ i ] NEW_LINE DEDENT print ( maxAnd + maxOR ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT
def countBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( count > 1 ) ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 12 ; NEW_LINE k = 5 ; NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT div_count = ( r // k ) - ( l // k ) NEW_LINE if l % k == 0 : NEW_LINE INDENT div_count += 1 NEW_LINE DEDENT return div_count > 1 NEW_LINE DEDENT
def sum ( N ) : NEW_LINE INDENT S1 = ( ( N // 2 ) ) * ( 2 * 2 + ( N // 2 - 1 ) * 2 ) // 2 NEW_LINE S2 = ( ( N // 7 ) ) * ( 2 * 7 + ( N // 7 - 1 ) * 7 ) // 2 NEW_LINE S3 = ( ( N // 14 ) ) * ( 2 * 14 + ( N // 14 - 1 ) * 14 ) // 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT
def printPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 2 != 0 or a + b < c ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) // 6 NEW_LINE DEDENT
def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 2 * n + 7 ) // 3 NEW_LINE DEDENT
def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) // ( 2 ) NEW_LINE DEDENT
def countPermutations ( N , B ) : NEW_LINE INDENT x = B ** N NEW_LINE y = B ** ( N - 1 ) NEW_LINE print ( x - y ) NEW_LINE DEDENT
def EqualNumbers ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT if ( sum % n ) : NEW_LINE INDENT return n - 1 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT
def printNumberWithDR ( k , d ) : NEW_LINE INDENT if d == 0 and k != 1 : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE k -= 1 NEW_LINE while k : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT
def findSteps ( n , m , a ) : NEW_LINE INDENT cur = 1 NEW_LINE steps = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( a [ i ] >= cur ) : NEW_LINE INDENT steps += ( a [ i ] - cur ) NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( n - cur + a [ i ] ) NEW_LINE DEDENT cur = a [ i ] NEW_LINE DEDENT return steps NEW_LINE DEDENT
def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = int ( b / x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = " ▁ " ) NEW_LINE leastdivisible += x NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT result = result - pow ( i , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + pow ( i , 2 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT result = - ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT result = ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def numberOfDistinct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE if ( ( n // i ) != i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def calculateAlternateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT sum -= fibo [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += fibo [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def getValue ( n ) : NEW_LINE INDENT i = 0 ; NEW_LINE k = 1 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT i = i + k ; NEW_LINE k = k * 2 ; NEW_LINE DEDENT return int ( k / 2 ) ; NEW_LINE DEDENT
def nthKyneaNumber ( n ) : NEW_LINE INDENT n = ( 1 << n ) + 1 NEW_LINE n = n * n NEW_LINE n = n - 2 NEW_LINE return n NEW_LINE DEDENT
def nthKyneaNumber ( n ) : NEW_LINE INDENT return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) NEW_LINE DEDENT
def get_last_two_digit ( N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT ans = ans % 100 NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT N = 1 NEW_LINE for N in range ( 1 , 11 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = ▁ " , N , " : ▁ " , get_last_two_digit ( N ) , sep = ' ▁ ' ) NEW_LINE DEDENT
def isProductEven ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ i ] & 1 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isProductEven ( arr , n ) ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT
def get_unit_digit ( N ) : NEW_LINE INDENT if ( N == 0 or N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif ( N == 3 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT N = 1 NEW_LINE for N in range ( 11 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = ▁ " , N , " : " , get_unit_digit ( N ) , sep = ' ▁ ' ) NEW_LINE DEDENT
def calculateSquareSum ( n ) : NEW_LINE INDENT fibo = [ 0 ] * ( n + 1 ) ; NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT fibo [ 0 ] = 0 ; NEW_LINE fibo [ 1 ] = 1 ; NEW_LINE sum = ( ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = ( fibo [ i - 1 ] + fibo [ i - 2 ] ) ; NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT array = [ 0 ] * ( N + 1 ) NEW_LINE array [ 0 ] = 1 NEW_LINE array [ 1 ] = 1 NEW_LINE for i in range ( 2 , math . ceil ( math . sqrt ( N ) + 1 ) ) : NEW_LINE INDENT if array [ i ] == 0 : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT array [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT runningPrimeSum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if array [ i ] == 0 : NEW_LINE INDENT runningPrimeSum += i NEW_LINE DEDENT dp [ i ] = runningPrimeSum NEW_LINE DEDENT DEDENT
def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) // x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printLines ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEW_LINE DEDENT DEDENT
def NumberOfRectangles ( n , m ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * m NEW_LINE DEDENT elif ( m % 2 == 0 ) : NEW_LINE INDENT return ( m // 2 ) * n NEW_LINE DEDENT return ( n * m - 1 ) // 2 NEW_LINE DEDENT
def NumberOfSolutions ( x , y , z , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT temp = n - i - j NEW_LINE if temp >= 0 : NEW_LINE INDENT temp = min ( temp , z ) NEW_LINE ans += temp + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findkth ( n , k ) : NEW_LINE INDENT v1 = list ( ) NEW_LINE v2 = list ( ) NEW_LINE for i in range ( 1 , mt . ceil ( n ** ( .5 ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v1 . append ( i ) NEW_LINE if ( i != mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT v2 . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT v2 [ : : - 1 ] NEW_LINE if ( k > ( len ( v1 ) + len ( v2 ) ) ) : NEW_LINE INDENT print ( " Doesn ' t ▁ Exist " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k <= len ( v1 ) ) : NEW_LINE INDENT print ( v1 [ k - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( v2 [ k - len ( v1 ) - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT
def NumberOfSolutions ( a , b , c , d ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if d >= max ( c , i + 1 ) : NEW_LINE INDENT ans += d - max ( c , i + 1 ) + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def CountDigits ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum += ma . log ( i , 10 ) NEW_LINE DEDENT sum *= n NEW_LINE return ma . ceil ( sum ) NEW_LINE DEDENT
def findF_N ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = ans + ( i + 1 ) * ( n - i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findNumber ( n , d ) : NEW_LINE INDENT ans = " " NEW_LINE if ( d != 10 ) : NEW_LINE INDENT ans += str ( d ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += '0' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT ans += " Impossible " NEW_LINE DEDENT else : NEW_LINE INDENT ans += '1' NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += '0' NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return n ** 2 + 4 * n ; NEW_LINE DEDENT
def NthTerm ( N ) : NEW_LINE INDENT x = ( 3 * N * N ) % 1000000009 NEW_LINE return ( ( x - N + 1000000009 ) % 1000000009 ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 17 NEW_LINE if ( isPrime ( n ) and ( n % 16 == 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def sum ( N ) : NEW_LINE INDENT global S1 , S2 , S3 NEW_LINE S1 = ( ( ( N // 3 ) ) * ( 2 * 3 + ( N // 3 - 1 ) * 3 ) // 2 ) NEW_LINE S2 = ( ( ( N // 4 ) ) * ( 2 * 4 + ( N // 4 - 1 ) * 4 ) // 2 ) NEW_LINE S3 = ( ( ( N // 12 ) ) * ( 2 * 12 + ( N // 12 - 1 ) * 12 ) // 2 ) NEW_LINE return int ( S1 + S2 - S3 ) NEW_LINE DEDENT
def nextGreater ( N ) : NEW_LINE INDENT power_of_2 = 1 ; NEW_LINE shift_count = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT shift_count += 1 ; NEW_LINE power_of_2 = power_of_2 * 2 ; NEW_LINE DEDENT return ( N + power_of_2 ) ; NEW_LINE DEDENT
def area ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; NEW_LINE return area ; NEW_LINE DEDENT
def area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) NEW_LINE return area NEW_LINE DEDENT
def sumProductDifference ( a , b , c , d , e ) : NEW_LINE INDENT rootSum = ( - 1 * b ) / a NEW_LINE rootProduct = e / a NEW_LINE return abs ( rootSum - rootProduct ) NEW_LINE DEDENT
def heightCalculate ( H , n , m ) : NEW_LINE INDENT N = n * 1.0 NEW_LINE M = m * 1.0 NEW_LINE h = H * sqrt ( N / ( N + M ) ) NEW_LINE return h NEW_LINE DEDENT
def numberOfSolutions ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for x in range ( n + 1 ) : NEW_LINE INDENT if ( n == ( x + ( n ^ x ) ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def minimumLecture ( m , n ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( n < math . ceil ( 0.75 * m ) ) : NEW_LINE INDENT ans = math . ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countNumbers ( N ) : NEW_LINE INDENT return ( pow ( 10 , N ) - pow ( 8 , N ) ) // 2 NEW_LINE DEDENT
def findsolution ( n , x , y ) : NEW_LINE INDENT if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x or y < n ) : NEW_LINE INDENT print ( " No ▁ solution " ) ; NEW_LINE return ; NEW_LINE DEDENT print ( y - n + 1 ) ; NEW_LINE while ( n > 1 ) : NEW_LINE INDENT print ( 1 ) ; NEW_LINE n -= 1 ; NEW_LINE DEDENT DEDENT
def findPosition ( n , f , b ) : NEW_LINE INDENT return n - max ( f + 1 , n - b ) + 1 ; NEW_LINE DEDENT
def nthOdd ( n ) : NEW_LINE INDENT return ( 2 * n - 1 ) NEW_LINE DEDENT
def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def nthHarmonic ( N ) : NEW_LINE INDENT harmonic = 1.00 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT harmonic += 1 / i NEW_LINE DEDENT return harmonic NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + n - 3 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + n - 2 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + 2 * n - 5 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) - 4 * n + 2 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 3 * n + 2 NEW_LINE DEDENT
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 2 ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 + pow ( ( n * ( n + 1 ) // 2 ) , 2 ) ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 + n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ) + n * ( n + 1 ) // 2 + 2 * ( n ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return int ( 6 * pow ( n , 2 ) - 4 * n - 2 ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 7 * n + 3 NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) + 2 * n + 2 NEW_LINE DEDENT
def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( ( b * b ) - ( 4 * a * c ) ) > 0 : NEW_LINE INDENT print ( "2 ▁ solutions " ) NEW_LINE DEDENT elif ( ( b * b ) - ( 4 * a * c ) ) == 0 : NEW_LINE INDENT print ( "1 ▁ solution " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ solutions " ) NEW_LINE DEDENT DEDENT
def sum ( n ) : NEW_LINE INDENT ans = ( n * ( n - 1 ) ) / 2 ; NEW_LINE return ans NEW_LINE DEDENT
def getNthTerm ( N ) : NEW_LINE INDENT return ( pow ( N , 2 ) + N + 1 ) NEW_LINE DEDENT
def findSum ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ) NEW_LINE DEDENT
def getNthTerm ( N ) : NEW_LINE INDENT return 4 * pow ( N , 2 ) - 3 * N + 2 NEW_LINE DEDENT
def findSum ( N ) : NEW_LINE INDENT return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum2 = ( ( n // 2 ) * ( 4 + ( n // 2 - 1 ) * 2 ) ) // 2 NEW_LINE sum5 = ( ( n // 5 ) * ( 10 + ( n // 5 - 1 ) * 5 ) ) // 2 NEW_LINE sum10 = ( ( n // 10 ) * ( 20 + ( n // 10 - 1 ) * 10 ) ) // 2 NEW_LINE return sum2 + sum5 - sum10 ; NEW_LINE DEDENT
def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) ; NEW_LINE arr [ 1 ] = 3 NEW_LINE arr [ 2 ] = 5 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 3 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 5 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ) ; NEW_LINE DEDENT
def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 / 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( ( x ** 2 ) * ( x ** ( 2 * n ) - 1 ) ) // ( x ** 2 - 1 ) NEW_LINE sum2 = ( x * y * ( x ** n * y ** n - 1 ) ) // ( x * y - 1 ) NEW_LINE return ( sum1 + sum2 ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) / 3 NEW_LINE DEDENT
def solve_sum ( n ) : NEW_LINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / pow ( 9 , 3 ) - n * ( n + 1 ) / 18 NEW_LINE DEDENT
def solve_sum ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( n + 1 ) / 2 NEW_LINE DEDENT return - n / 2 NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) ** 2 NEW_LINE DEDENT
def printPair ( g , l ) : NEW_LINE INDENT print ( g , l ) NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT return int ( 1 + n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
def totEdge ( n ) : NEW_LINE INDENT result = ( n * ( n - 1 ) ) // 2 NEW_LINE return result NEW_LINE DEDENT
def rmsValue ( arr , n ) : NEW_LINE INDENT square = 0 NEW_LINE mean = 0.0 NEW_LINE root = 0.0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT square += ( arr [ i ] ** 2 ) NEW_LINE DEDENT mean = ( square / ( float ) ( n ) ) NEW_LINE root = math . sqrt ( mean ) NEW_LINE return root NEW_LINE DEDENT
def Mixture ( X , Y , Z ) : NEW_LINE INDENT result = 0.0 NEW_LINE result1 = 0.0 NEW_LINE result1 = ( ( X - Y ) / X ) NEW_LINE result = pow ( result1 , Z ) NEW_LINE result = result * X NEW_LINE return result NEW_LINE DEDENT
def coin ( totalRupees , X , Y , Z ) : NEW_LINE INDENT one = X * 1 NEW_LINE fifty = ( ( Y * 1 ) / 2.0 ) NEW_LINE twentyfive = ( ( Z * 1 ) / 4.0 ) NEW_LINE total = one + fifty + twentyfive NEW_LINE result = ( ( totalRupees ) / total ) NEW_LINE return int ( result ) NEW_LINE DEDENT
def sumOfSeries ( x , k ) : NEW_LINE INDENT return ( float ( x ) / 81 ) * ( 9 * k - 1 + 10 ** ( ( - 1 ) * k ) ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT a1 = 1 ; NEW_LINE a2 = 2 ; NEW_LINE r = 2 ; NEW_LINE d = 1 ; NEW_LINE return ( ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ) ; NEW_LINE DEDENT
def Race ( B , C ) : NEW_LINE INDENT result = 0 ; NEW_LINE result = ( ( C * 100 ) // B ) NEW_LINE return 100 - result NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n -= d * 5 NEW_LINE DEDENT return ( n % 17 == 0 ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; NEW_LINE DEDENT
def bridge_length ( trainLength , Speed , Time ) : NEW_LINE INDENT return ( ( Time * Speed ) - trainLength ) NEW_LINE DEDENT
def findN ( k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
def Circular ( n ) : NEW_LINE INDENT Result = 1 NEW_LINE while n > 0 : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT
def Time ( arr , n , Emptypipe ) : NEW_LINE INDENT fill = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT fill += ( 1 / arr [ i ] ) NEW_LINE DEDENT fill = fill - ( 1 / float ( Emptypipe ) ) NEW_LINE return int ( 1 / fill ) NEW_LINE DEDENT
def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) NEW_LINE area = ( totalSquares * size * size ) NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT
def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def printCombination ( n ) : NEW_LINE INDENT print ( "1 ▁ " , end = " " ) ; NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( "2" , n - 3 , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "1" , ( n - 2 ) , end = " " ) ; NEW_LINE DEDENT DEDENT
def checkPairs ( l , r ) : NEW_LINE INDENT if ( l - r ) % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def calTime ( arr , n ) : NEW_LINE INDENT work = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT work += 1 / arr [ i ] NEW_LINE DEDENT return 1 / work NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT if n % 11 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def percent ( a , b ) : NEW_LINE INDENT result = int ( ( ( b - a ) * 100 ) / a ) NEW_LINE return result NEW_LINE DEDENT
def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT
def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) ; NEW_LINE d = ( math . pow ( 10 , s ) ) ; NEW_LINE k = d ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( int ( n // d ) ) ; NEW_LINE d = int ( d / 10 ) ; NEW_LINE DEDENT n = int ( n % k ) ; NEW_LINE k = int ( k // 10 ) ; NEW_LINE d = k ; NEW_LINE DEDENT DEDENT
def check ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT if sum % 7 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def numberSequence ( n ) : NEW_LINE INDENT num = pow ( 4 , n ) - pow ( 2 , n ) - 1 NEW_LINE return num NEW_LINE DEDENT
def complement ( num ) : NEW_LINE INDENT i = 0 ; NEW_LINE len = 0 ; NEW_LINE comp = 0 ; NEW_LINE temp = num ; NEW_LINE while ( 1 ) : NEW_LINE INDENT len += 1 ; NEW_LINE num = int ( num / 10 ) ; NEW_LINE if ( abs ( num ) == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT num = temp ; NEW_LINE comp = math . pow ( 10 , len ) - num ; NEW_LINE return int ( comp ) ; NEW_LINE DEDENT
def calculate ( array , size ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( array [ i ] % 2 == 0 and array [ i ] != 0 and array [ i ] != 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findGreater ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT x = 4 ; NEW_LINE y = 9 ; NEW_LINE if ( findGreater ( x , y ) ) : NEW_LINE INDENT print ( "1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "2" ) ; NEW_LINE DEDENT
def print_C ( p0 ) : NEW_LINE INDENT i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT flag = 1 ; NEW_LINE x = pow ( 2 , i ) ; NEW_LINE p1 = x * p0 + ( x - 1 ) ; NEW_LINE for k in range ( 2 , p1 ) : NEW_LINE INDENT if ( p1 % k == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT print ( p1 , end = " ▁ " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT
def print_t ( p0 ) : NEW_LINE INDENT i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT flag = 1 ; NEW_LINE x = pow ( 2 , i ) ; NEW_LINE p1 = x * p0 - ( x - 1 ) ; NEW_LINE for k in range ( 2 , p1 ) : NEW_LINE INDENT if ( p1 % k == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT print ( p1 , end = " ▁ " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT
def boost_hyperfactorial ( num ) : NEW_LINE INDENT val = 1 ; NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT val = val * pow ( i , i ) ; NEW_LINE DEDENT return val ; NEW_LINE DEDENT
def boost_hyperfactorial ( num ) : NEW_LINE INDENT val = 1 ; NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT val *= i ; NEW_LINE DEDENT DEDENT return val ; NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N - 1 ) : NEW_LINE INDENT if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair = oddPair + 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count * ( count - 1 ) / 2 NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def isSurd ( n ) : NEW_LINE INDENT i = 2 NEW_LINE for i in range ( 2 , ( i * i ) + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n ) : NEW_LINE INDENT j = j * i NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def LastTwoDigit ( num ) : NEW_LINE INDENT one = num % 10 NEW_LINE num //= 10 NEW_LINE tens = num % 10 NEW_LINE tens *= 10 NEW_LINE num = tens + one NEW_LINE return num NEW_LINE DEDENT
def countOddSum ( ar , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT val = val + ar [ j ] NEW_LINE if ( val % 2 != 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT
def printPFsInPairs ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( pow ( n , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT print ( str ( i ) + " * " + str ( int ( n / i ) ) ) NEW_LINE DEDENT DEDENT DEDENT
def findAngle ( n ) : NEW_LINE INDENT interiorAngle = int ( ( n - 2 ) * 180 / n ) NEW_LINE exteriorAngle = int ( 360 / n ) NEW_LINE print ( " Interior ▁ angle : ▁ " , interiorAngle ) NEW_LINE print ( " Exterior ▁ angle : ▁ " , exteriorAngle ) NEW_LINE DEDENT
def rainDayProbability ( a , n ) : NEW_LINE INDENT count = a . count ( 1 ) NEW_LINE m = count / n NEW_LINE return m NEW_LINE DEDENT
def distance ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT d = math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) + math . pow ( z2 - z1 , 2 ) * 1.0 ) NEW_LINE print ( " Distance ▁ is ▁ " ) NEW_LINE print ( d ) NEW_LINE DEDENT
def twoEggDrop ( k ) : NEW_LINE INDENT return mt . ceil ( ( - 1.0 + mt . sqrt ( 1 + 8 * k ) ) / 2 ) NEW_LINE DEDENT
def DivisibleBy41 ( first , second , c , n ) : NEW_LINE INDENT digit = [ 0 ] * n NEW_LINE digit [ 0 ] = first NEW_LINE digit [ 1 ] = second NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 NEW_LINE DEDENT ans = digit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ans * 10 + digit [ i ] ) % 41 NEW_LINE DEDENT if ( ans % 41 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT first = 1 NEW_LINE second = 2 NEW_LINE c = 1 NEW_LINE n = 3 NEW_LINE if ( DivisibleBy41 ( first , second , c , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = int ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) // 24 ) NEW_LINE print ( num , end = ' ▁ ' ) ; NEW_LINE DEDENT DEDENT
def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE print ( num , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n ; NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT
def findNthNonSquare ( n ) : NEW_LINE INDENT x = n ; NEW_LINE ans = x + math . floor ( 0.5 + math . sqrt ( x ) ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT
def getMaxOnes ( n , x ) : NEW_LINE INDENT zeroes = ( int ) ( n / x ) ; NEW_LINE zeroes = zeroes * zeroes ; NEW_LINE total = n * n ; NEW_LINE ans = total - zeroes ; NEW_LINE return ans ; NEW_LINE DEDENT
def ways ( n ) : NEW_LINE INDENT first = 2 ; NEW_LINE second = 3 ; NEW_LINE res = 0 ; NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res = first + second ; NEW_LINE first = second ; NEW_LINE second = res ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def check ( n , m ) : NEW_LINE INDENT if ( n == 2 or m == 2 or n % m == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def MinimumMail ( n , k , x ) : NEW_LINE INDENT m = ( ( n - 1 ) + int ( math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + math . ceil ( n * 1.0 / x ) * ( k - n ) ) ) ; NEW_LINE return m ; NEW_LINE DEDENT
def findAllSequence ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return ( pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; NEW_LINE DEDENT DEDENT
def findArea ( a , b ) : NEW_LINE INDENT Area = 3.142 * a * b ; NEW_LINE print ( " Area : " , round ( Area , 2 ) ) ; NEW_LINE DEDENT
def calculate ( x , k , m ) : NEW_LINE INDENT result = x ; NEW_LINE k = k - 1 ; NEW_LINE while ( k ) : NEW_LINE INDENT result = math . pow ( result , x ) ; NEW_LINE if ( result > m ) : NEW_LINE INDENT result = result % m ; NEW_LINE DEDENT k = k - 1 ; NEW_LINE DEDENT return int ( result ) ; NEW_LINE DEDENT
def rev ( n , temp ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return temp ; NEW_LINE DEDENT temp = ( temp * 10 ) + ( n % 10 ) ; NEW_LINE return rev ( n / 10 , temp ) ; NEW_LINE DEDENT n = 121 ; NEW_LINE temp = rev ( n , 0 ) ; NEW_LINE if ( temp != n ) : NEW_LINE INDENT print ( " yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) ; NEW_LINE DEDENT
def countOnes ( n ) : NEW_LINE INDENT count = 1 ; NEW_LINE rem = 1 ; NEW_LINE while ( rem != 0 ) : NEW_LINE INDENT rem = ( rem * 10 + 1 ) % n ; NEW_LINE count = count + 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def findGreater ( a , b , n ) : NEW_LINE INDENT if ( ( n & 1 ) > 0 ) : NEW_LINE INDENT a = abs ( a ) ; NEW_LINE b = abs ( b ) ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT print ( " a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n " ) ; NEW_LINE DEDENT elif ( a > b ) : NEW_LINE INDENT print ( " a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n " ) ; NEW_LINE DEDENT DEDENT
def fibonacci ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT fib = ( ( pow ( ( 1 + math . sqrt ( 5 ) ) , i ) - pow ( ( 1 - math . sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * math . sqrt ( 5 ) ) ) ; NEW_LINE print ( int ( fib ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def findLCM ( a , b ) : NEW_LINE INDENT lar = max ( a , b ) NEW_LINE small = min ( a , b ) NEW_LINE i = lar NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( i % small == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += lar NEW_LINE DEDENT DEDENT
def largestNum ( a , b ) : NEW_LINE INDENT return a * ( bool ) ( a // b ) + b * ( bool ) ( b // a ) ; NEW_LINE DEDENT
def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT
def findNature ( a , b , n ) : NEW_LINE INDENT seq = [ 0 ] * MAX ; NEW_LINE seq [ 0 ] = a ; NEW_LINE seq [ 1 ] = b ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; NEW_LINE DEDENT return ( seq [ n ] & 1 ) ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE n = 3 ; NEW_LINE if ( findNature ( a , b , n ) ) : NEW_LINE INDENT print ( " Odd " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) ; NEW_LINE DEDENT
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( a & 1 ) ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( b & 1 ) ; NEW_LINE DEDENT if ( ( a & 1 ) == 0 ) : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( n % 3 != 0 ) else False ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return True if ( ( n - 1 ) % 3 != 0 ) else False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( ( n + 1 ) % 3 != 0 ) else False ; NEW_LINE DEDENT DEDENT DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE n = 3 ; NEW_LINE if ( findNature ( a , b , n ) == True ) : NEW_LINE INDENT print ( " Odd " , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " , end = " ▁ " ) ; NEW_LINE DEDENT
def check ( m , n ) : NEW_LINE INDENT RHS = m * math . log ( n ) ; NEW_LINE LHS = n * math . log ( m ) ; NEW_LINE if ( LHS > RHS ) : NEW_LINE INDENT print ( " m ^ n ▁ > ▁ n ^ m " ) ; NEW_LINE DEDENT elif ( LHS < RHS ) : NEW_LINE INDENT print ( " m ^ n ▁ < ▁ n ^ m " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " m ^ n ▁ = ▁ n ^ m " ) ; NEW_LINE DEDENT DEDENT
def subtractOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( ( x & m ) == False ) : NEW_LINE INDENT x = x ^ m NEW_LINE m = m << 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
def subtractOne ( x ) : NEW_LINE INDENT return ( ( x << 1 ) + ( ~ x ) ) ; NEW_LINE DEDENT
def meanVector ( mat ) : NEW_LINE INDENT print ( " [ ▁ " , end = " " ) ; NEW_LINE for i in range ( rows ) : NEW_LINE INDENT mean = 0.00 ; NEW_LINE sum = 0 ; NEW_LINE for j in range ( cols ) : NEW_LINE INDENT sum = sum + mat [ j ] [ i ] ; mean = int ( sum / rows ) ; print ( mean , end = " ▁ " ) ; print ( " ] " ) ; NEW_LINE DEDENT DEDENT DEDENT
def countDigits ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += math . log10 ( i ) NEW_LINE DEDENT ans = ans * n NEW_LINE return 1 + math . floor ( ans ) NEW_LINE DEDENT
def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 5 == 0 : NEW_LINE INDENT print ( int ( n / 5 - 2 ) , " ▁ " , int ( n / 5 - 1 ) , " ▁ " , int ( n / 5 ) , " ▁ " , int ( n / 5 + 1 ) , " ▁ " , int ( n / 5 + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans + i * i * i * i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 NEW_LINE DEDENT
def octahedral_num ( n ) : NEW_LINE INDENT return n * ( 2 * n * n + 1 ) // 3 NEW_LINE DEDENT
def countUnmarked ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return N / 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return N / 2 + 1 ; NEW_LINE DEDENT DEDENT
def Pentatope_number ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) // 24 ) NEW_LINE DEDENT
def minimumLength ( x , y , z ) : NEW_LINE INDENT return ( 1 + abs ( x - y ) + abs ( y - z ) ) NEW_LINE DEDENT
def endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) : NEW_LINE INDENT print ( " x2 ▁ = " , ( 2 * c1 - x1 ) , end = " ▁ " ) NEW_LINE print ( " y2 ▁ = " , ( 2 * c2 - y1 ) ) NEW_LINE DEDENT
def dodecahedral_num ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) // 2 NEW_LINE DEDENT
def centeredTetrahedralNumber ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 3 ) // 3 NEW_LINE DEDENT
def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT
def centeredIcosahedralNum ( n ) : NEW_LINE INDENT return ( ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) // 3 ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ = ( summ + ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
def checkHankelMatrix ( n , m ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def swap ( a , b , c , d ) : NEW_LINE INDENT a = a + b NEW_LINE b = a - b NEW_LINE a = a - b NEW_LINE b = b + c NEW_LINE c = b - c NEW_LINE b = b - c NEW_LINE c = c + d NEW_LINE d = c - d NEW_LINE c = c - d NEW_LINE print ( " values ▁ after ▁ swapping ▁ are ▁ : ▁ " ) NEW_LINE print ( " a ▁ = ▁ " , a ) NEW_LINE print ( " b ▁ = ▁ " , b ) NEW_LINE print ( " c ▁ = ▁ " , c ) NEW_LINE print ( " d ▁ = ▁ " , d ) NEW_LINE DEDENT
def seriessum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT
def checkCentrosymmetricted ( n , m ) : NEW_LINE INDENT mid_row = 0 ; NEW_LINE if ( ( n & 1 ) > 0 ) : NEW_LINE INDENT mid_row = n / 2 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mid_row = n / 2 ; NEW_LINE DEDENT for i in range ( int ( mid_row ) ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 3 , 5 ] , [ 6 , 8 , 6 ] , [ 5 , 3 , 1 ] ] ; NEW_LINE if ( checkCentrosymmetricted ( n , m ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def Centered_Triangular_num ( n ) : NEW_LINE INDENT return ( 3 * n * n + 3 * n + 2 ) // 2 NEW_LINE DEDENT
def Dodecagonal_number ( n ) : NEW_LINE INDENT return 5 * n * n - 4 * n NEW_LINE DEDENT
def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT f = math . log ( n ) / math . log ( x ) ; NEW_LINE if ( ( f - int ( f ) ) == 0.0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def number_of_digits ( n ) : NEW_LINE INDENT i = 4 NEW_LINE res = 1 NEW_LINE sum = 0 NEW_LINE while ( True ) : NEW_LINE INDENT i *= 4 NEW_LINE res += 1 NEW_LINE sum += i NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) // 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT
def Reverseorder ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( ( p * 2 ) , ( n + 1 ) , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT print ( p , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT N = 25 ; NEW_LINE print ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; NEW_LINE if ( N == 1 ) : NEW_LINE INDENT print ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; NEW_LINE DEDENT
def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) / 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printCollatz ( n ) : NEW_LINE INDENT while n != 1 : NEW_LINE INDENT print ( n , end = ' ▁ ' ) NEW_LINE if n & 1 : NEW_LINE INDENT n = 3 * n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT
def findpos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in n : NEW_LINE INDENT if i == '2' : NEW_LINE INDENT pos = pos * 4 + 1 NEW_LINE DEDENT elif i == '3' : NEW_LINE INDENT pos = pos * 4 + 2 NEW_LINE DEDENT elif i == '5' : NEW_LINE INDENT pos = pos * 4 + 3 NEW_LINE DEDENT elif i == '7' : NEW_LINE INDENT pos = pos * 4 + 4 NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
def checkVantieghemsTheorem ( limit ) : NEW_LINE INDENT prod = 1 NEW_LINE for n in range ( 2 , limit ) : NEW_LINE INDENT if n == 2 : NEW_LINE INDENT print ( 2 , " is ▁ prime " ) NEW_LINE DEDENT if ( ( ( prod - n ) % ( ( 1 << n ) - 1 ) ) == 0 ) : NEW_LINE INDENT print ( n , " is ▁ prime " ) NEW_LINE DEDENT prod *= ( ( 1 << n ) - 1 ) NEW_LINE DEDENT DEDENT
def magicOfSequence ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += ( i * i * i + i * 2 ) NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def magicOfSequence ( N ) : NEW_LINE INDENT return ( N * ( N + 1 ) / 2 ) + 2 * N NEW_LINE DEDENT
def repUnitValue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT rem = 1 NEW_LINE power = 1 NEW_LINE k = 1 NEW_LINE while ( rem % n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE power = power * 10 % n NEW_LINE rem = ( rem + power ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT
def isPossibleToZero ( a , n ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT odd += a [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT even += a [ i ] ; NEW_LINE DEDENT DEDENT return ( odd == even ) ; NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 0 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( isPossibleToZero ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def isPossibleToZero ( a , n ) : NEW_LINE INDENT num = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = num * 10 + a [ i ] ; NEW_LINE DEDENT return ( num % 11 == 0 ) ; NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 0 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( isPossibleToZero ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) ; NEW_LINE res = 1 ; NEW_LINE sign = 1 ; NEW_LINE fact = 1 ; NEW_LINE pow = 1 ; NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * ( - 1 ) ; NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; NEW_LINE pow = pow * x * x ; NEW_LINE res = res + sign * pow / fact ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def summingSeries ( n ) : NEW_LINE INDENT return math . pow ( n , 2 ) NEW_LINE DEDENT
def check ( N , D ) : NEW_LINE INDENT temp = N * ( N + 1 ) // 2 + D NEW_LINE return ( bool ( temp % 2 == 0 ) ) NEW_LINE DEDENT N = 5 NEW_LINE M = 7 NEW_LINE if check ( N , M ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT
def findNumberOfDigits ( n , base ) : NEW_LINE INDENT dig = ( math . floor ( math . log ( n ) / math . log ( base ) ) + 1 ) NEW_LINE print ( " The ▁ Number ▁ of ▁ digits ▁ of " . format ( n , base , dig ) ) DEDENT
def isValidNesbitt ( a , b , c ) : NEW_LINE INDENT A = a / ( b + c ) ; NEW_LINE B = b / ( a + c ) ; NEW_LINE C = c / ( a + b ) ; NEW_LINE inequality = A + B + C ; NEW_LINE return ( inequality >= 1.5 ) ; NEW_LINE DEDENT a = 1.0 ; NEW_LINE b = 2.0 ; NEW_LINE c = 3.0 ; NEW_LINE if ( isValidNesbitt ( a , b , c ) ) : NEW_LINE INDENT print ( " Nesbitt ' s ▁ inequality ▁ satisfied . " , " ▁ for ▁ real ▁ numbers ▁ " , a , " , ▁ " , b , " , ▁ " , c ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ satisfied " ) ; NEW_LINE DEDENT
def printFourSquares ( a ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i * i <= a ) : NEW_LINE INDENT j = i NEW_LINE while ( j * j <= a ) : NEW_LINE INDENT k = j NEW_LINE while ( k * k <= a ) : NEW_LINE INDENT l = k NEW_LINE while ( l * l <= a ) : NEW_LINE INDENT if ( i * i + j * j + k * k + l * l == a ) : NEW_LINE INDENT print ( " { } ▁ = ▁ { } * { } ▁ + ▁ { } * { } ▁ + " . format ( a , i , i , j , j ) , end = " ▁ " ) NEW_LINE print ( " { } * { } ▁ + ▁ { } * { } " . format ( k , k , l , l ) , end = " " ) NEW_LINE DEDENT l = l + 1 NEW_LINE DEDENT k = k + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
def no_of_digit ( a , b ) : NEW_LINE INDENT return ( ( int ) ( b * math . log10 ( a ) ) + 1 ) NEW_LINE DEDENT
def find_sum_of_two_squares ( a , b ) : NEW_LINE INDENT ab = a * b NEW_LINE i = 0 ; NEW_LINE while ( i * i <= ab ) : NEW_LINE INDENT j = i NEW_LINE while ( i * i + j * j <= ab ) : NEW_LINE INDENT if ( i * i + j * j == ab ) : NEW_LINE INDENT print ( i , " ^ 2 ▁ + ▁ " , j , " ^ 2 ▁ = ▁ " , ab ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def check_euler_four_square_identity ( a , b , ab ) : NEW_LINE INDENT s = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= ab ) : NEW_LINE INDENT s = i * i ; NEW_LINE j = i ; NEW_LINE while ( j * j <= ab ) : NEW_LINE INDENT s = j * j + i * i ; NEW_LINE k = j ; NEW_LINE while ( k * k <= ab ) : NEW_LINE INDENT s = k * k + j * j + i * i ; NEW_LINE l = k ; NEW_LINE while ( l * l <= ab ) : NEW_LINE INDENT s = l * l + k * k + j * j + i * i ; NEW_LINE if ( s == ab ) : NEW_LINE INDENT print ( " i ▁ = " , i ) ; NEW_LINE print ( " j ▁ = " , j ) ; NEW_LINE print ( " k ▁ = " , k ) ; NEW_LINE print ( " l ▁ = " , l ) ; NEW_LINE print ( " Product ▁ of ▁ " , a , " and " , b , end = " " ) ; NEW_LINE print ( " ▁ can ▁ be ▁ written ▁ as ▁ sum ▁ of " , " squares ▁ of ▁ i , ▁ j , ▁ k , ▁ l " ) ; NEW_LINE print ( ab , " = ▁ " , end = " " ) ; NEW_LINE print ( i , " * " , i , " + ▁ " , end = " " ) ; NEW_LINE print ( j , " * " , j , " + ▁ " , end = " " ) ; NEW_LINE print ( k , " * " , k , " + ▁ " , end = " " ) ; NEW_LINE print ( l , " * " , l ) ; NEW_LINE print ( " " ) ; NEW_LINE DEDENT l += 1 ; NEW_LINE DEDENT k += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT
def inversegrayCode ( n ) : NEW_LINE INDENT inv = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT inv = inv ^ n ; NEW_LINE n = n >> 1 ; NEW_LINE DEDENT return inv ; NEW_LINE DEDENT
def firstDigit ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE while ( fact % 10 == 0 ) : NEW_LINE INDENT fact = int ( fact / 10 ) NEW_LINE DEDENT DEDENT while ( fact >= 10 ) : NEW_LINE INDENT fact = int ( fact / 10 ) NEW_LINE DEDENT return math . floor ( fact ) NEW_LINE DEDENT
def possibleToReach ( a , b ) : NEW_LINE INDENT c = np . cbrt ( a * b ) NEW_LINE re1 = a // c NEW_LINE re2 = b // c NEW_LINE if ( ( re1 * re1 * re2 == a ) and ( re2 * re2 * re1 == b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def nthSquareCube ( n ) : NEW_LINE INDENT return n * n * n * n * n * n NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n * n * n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = 9 NEW_LINE n = findS ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
def findKthGoodNo ( n ) : NEW_LINE INDENT lastDig = n % 10 NEW_LINE if ( lastDig >= 0 and lastDig <= 4 ) : NEW_LINE INDENT return n << 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n << 1 ) + 1 NEW_LINE DEDENT DEDENT
def powerNumbers ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 2 , int ( math . pow ( n , 1.0 / 3.0 ) ) + 1 ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT j = j * i NEW_LINE s = int ( math . sqrt ( j ) ) NEW_LINE if ( s * s != j ) : NEW_LINE INDENT v . append ( j ) NEW_LINE DEDENT DEDENT DEDENT v . sort ( ) NEW_LINE v = list ( dict . fromkeys ( v ) ) NEW_LINE return len ( v ) + int ( math . sqrt ( n ) ) NEW_LINE DEDENT
def NicomachuTheorum_sum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k * k ; NEW_LINE DEDENT triNo = n * ( n + 1 ) / 2 ; NEW_LINE if ( sum == triNo * triNo ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def countDigits ( n ) : NEW_LINE INDENT return int ( n * math . log10 ( 2 ) + 1 ) ; NEW_LINE DEDENT
def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) NEW_LINE DEDENT
def calculateProbability ( N ) : NEW_LINE INDENT probability = N / ( N + 1 ) NEW_LINE return probability NEW_LINE DEDENT
def isUndulating ( n ) : NEW_LINE INDENT if ( len ( n ) <= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = "1212121" NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr = 19 ; NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 ; NEW_LINE x = curr ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr ; NEW_LINE DEDENT curr += 9 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT
def pythagoreanTriplet ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( n / 3 ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , " , ▁ " , j , " , ▁ " , k , sep = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ Triplet " ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sm = sm + i * j NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) // 2 NEW_LINE sm = multiTerms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiTerms = multiTerms - ( i - 1 ) NEW_LINE sm = sm + multiTerms * i NEW_LINE DEDENT return sm NEW_LINE DEDENT
def procal ( n ) : NEW_LINE INDENT return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) NEW_LINE DEDENT
def testSomeNumbers ( limit , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return NEW_LINE DEDENT for a in range ( 1 , limit + 1 ) : NEW_LINE INDENT for b in range ( a , limit + 1 ) : NEW_LINE INDENT pow_sum = pow ( a , n ) + pow ( b , n ) NEW_LINE c = pow ( pow_sum , 1.0 / n ) NEW_LINE c_pow = pow ( int ( c ) , n ) NEW_LINE if ( c_pow == pow_sum ) : NEW_LINE INDENT print ( " Count ▁ example ▁ found " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ counter ▁ example ▁ within ▁ given ▁ range ▁ and ▁ data " ) NEW_LINE DEDENT
def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = " ▁ " ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = int ( term * X * ( n - i + 1 ) / ( i * A ) ) NEW_LINE print ( term , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def fnMod ( n ) : NEW_LINE INDENT if ( n % 5 == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def totalSumDivisibleByNum ( n , number ) : NEW_LINE INDENT firstnum = pow ( 10 , n - 1 ) NEW_LINE lastnum = pow ( 10 , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( firstnum , lastnum ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def totalSumDivisibleByNum ( digit , number ) : NEW_LINE INDENT firstnum = pow ( 10 , digit - 1 ) NEW_LINE lastnum = pow ( 10 , digit ) NEW_LINE firstnum = ( firstnum - firstnum % number ) + number NEW_LINE lastnum = ( lastnum - lastnum % number ) NEW_LINE count = ( ( lastnum - firstnum ) / number + 1 ) NEW_LINE return int ( ( ( lastnum + firstnum ) * count ) / 2 ) NEW_LINE DEDENT
def numberofterm ( n , number ) : NEW_LINE INDENT firstnum = math . pow ( 10 , n - 1 ) NEW_LINE lastnum = math . pow ( 10 , n ) NEW_LINE count = 0 NEW_LINE for i in range ( int ( firstnum ) , int ( lastnum ) ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumofseries ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) NEW_LINE DEDENT
def seiresSum ( n , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT res -= a [ i ] * a [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def seiresSum ( n , a ) : NEW_LINE INDENT return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ) NEW_LINE DEDENT
def printGMeans ( A , B , N ) : NEW_LINE INDENT R = ( math . pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( int ( A * math . pow ( R , i ) ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( int ( n / 100 ) ) : NEW_LINE INDENT last_digit = int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE n += last_digit * 3 NEW_LINE DEDENT return ( n % 29 == 0 ) NEW_LINE DEDENT n = 348 NEW_LINE if ( isDivisible ( n ) != 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def pronic_check ( n ) : NEW_LINE INDENT x = ( int ) ( math . sqrt ( n ) ) NEW_LINE if ( x * ( x + 1 ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 56 NEW_LINE if ( pronic_check ( n ) == True ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def power ( n , r ) : NEW_LINE INDENT count = 0 ; i = r NEW_LINE while ( ( n / i ) >= 1 ) : NEW_LINE INDENT count += n / i NEW_LINE i = i * r NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
def isPrime ( p ) : NEW_LINE INDENT checkNumber = 2 ** p - 1 NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range ( 1 , p - 1 ) : NEW_LINE INDENT nextval = ( nextval * nextval - 2 ) % checkNumber NEW_LINE DEDENT if ( nextval == 0 ) : return True NEW_LINE else : return False NEW_LINE DEDENT p = 7 NEW_LINE checkNumber = 2 ** p - 1 NEW_LINE if isPrime ( p ) : NEW_LINE INDENT print ( checkNumber , ' is ▁ Prime . ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( checkNumber , ' is ▁ not ▁ Prime ' ) NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT if ( x >= 0 ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr * sr ) == float ( x ) ) NEW_LINE DEDENT return false NEW_LINE DEDENT x = 2502 NEW_LINE if ( isPerfectSquare ( x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def checkperfectsquare ( x ) : NEW_LINE INDENT if ( math . ceil ( math . sqrt ( n ) ) == math . floor ( math . sqrt ( n ) ) ) : NEW_LINE INDENT print ( " perfect ▁ square " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " not ▁ a ▁ perfect ▁ square " ) NEW_LINE DEDENT DEDENT
def printGP ( a , r , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_term = a * pow ( r , i ) NEW_LINE print ( curr_term , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def Nth_of_AP ( a , d , N ) : NEW_LINE INDENT return ( a + ( N - 1 ) * d ) NEW_LINE DEDENT
def checkFibinnary ( n ) : NEW_LINE INDENT prev_last = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) and prev_last ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_last = n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if ( checkFibinnary ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT
def Nonagonal ( n ) : NEW_LINE INDENT return int ( n * ( 7 * n - 5 ) / 2 ) NEW_LINE DEDENT
def Nonagonal ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( int ( i * ( 7 * i - 5 ) / 2 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def seriesFunc ( n ) : NEW_LINE INDENT sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE sumNatural = ( n * ( n + 1 ) / 2 ) NEW_LINE return ( sumSquare + sumNatural + 1 ) NEW_LINE DEDENT
def sum_series ( n ) : NEW_LINE INDENT nSquare = n * n NEW_LINE return int ( nSquare * ( nSquare - 1 ) / 4 ) NEW_LINE DEDENT
def day_of_the_week ( y , m , d ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE if ( m < 3 ) : NEW_LINE INDENT y = y - 1 NEW_LINE DEDENT return ( y + y // 4 - y // 100 + y // 400 + t [ m - 1 ] + d ) % 7 NEW_LINE DEDENT
def Div_by_8 ( n ) : NEW_LINE INDENT return ( ( ( n >> 3 ) << 3 ) == n ) NEW_LINE DEDENT n = 16 NEW_LINE if ( Div_by_8 ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ - 2 : ] ) NEW_LINE return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT num = "63284689320" NEW_LINE if ( divisibleBy20 ( num ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPrime ( n , i = 2 ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return True if ( n == 2 ) else False NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return true NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT n = 15 NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def subsetCount ( arr , n ) : NEW_LINE INDENT return 1 << n NEW_LINE DEDENT
def isSquareFree ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if isSquareFree ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findArea ( d ) : NEW_LINE INDENT return ( d * d ) / 2 NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) NEW_LINE DEDENT
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) ; NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT num = "12244824607284961224" NEW_LINE if ( isDvisibleBy12 ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def StepstoReachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE n = math . ceil ( ( - 1.0 + math . sqrt ( 1 + 8.0 * target ) ) / 2 ) NEW_LINE sum = n * ( n + 1 ) / 2 NEW_LINE if ( sum == target ) : NEW_LINE INDENT return n NEW_LINE DEDENT d = sum - target NEW_LINE if ( ( int ( d ) & 1 ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if ( int ( d ) & 1 ) : NEW_LINE INDENT return n + 2 NEW_LINE DEDENT return n + 1 NEW_LINE DEDENT DEDENT
def Calculate_GST ( org_cost , N_price ) : NEW_LINE INDENT return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; NEW_LINE DEDENT
def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + 2 * i NEW_LINE DEDENT return sum / n NEW_LINE DEDENT
def avg_of_even_num ( n ) : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT
def avg_of_odd_num ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 2 * i + 1 ) NEW_LINE DEDENT return sm // n NEW_LINE DEDENT
def avg_of_odd_num ( n ) : NEW_LINE INDENT return n NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE res = 0.0 ; NEW_LINE sign = True ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False ; NEW_LINE res = res + ( i + 1 ) / ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT sign = True ; NEW_LINE res = res - ( i + 1 ) / ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
def countSymmetric ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 1 << ( ( n * ( n + 1 ) ) // 2 ) ) NEW_LINE DEDENT
def SternSequenceFunc ( BrocotSequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT considered_element = BrocotSequence [ i ] NEW_LINE precedent = BrocotSequence [ i - 1 ] NEW_LINE BrocotSequence . append ( considered_element + precedent ) NEW_LINE BrocotSequence . append ( considered_element ) NEW_LINE DEDENT for i in range ( 0 , 15 ) : NEW_LINE INDENT print ( BrocotSequence [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def centeredNonagonal ( n ) : NEW_LINE INDENT return ( 3 * n - 2 ) * ( 3 * n - 1 ) // 2 NEW_LINE DEDENT
def printAP ( a , d , n ) : NEW_LINE INDENT curr_term NEW_LINE DEDENT curr_term = a NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE DEDENT print ( curr_term , end = ' ▁ ' ) NEW_LINE INDENT curr_term = curr_term + d NEW_LINE DEDENT
def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upQuant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= upCost ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 ; upCost = 30 NEW_LINE lowQuant = 5 ; upQuant = 12 ; r = 9 NEW_LINE if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def pattern ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE DEDENT print ( "2" , end = " ▁ " ) NEW_LINE print ( n + d ) NEW_LINE DEDENT
def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT
def oddNumSum ( n ) : NEW_LINE INDENT return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 NEW_LINE DEDENT
def isTrimorphic ( N ) : NEW_LINE INDENT cube = N * N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != cube % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N = N // 10 NEW_LINE cube = cube // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT N = 24 NEW_LINE if ( isTrimorphic ( N ) ) : NEW_LINE INDENT print ( " trimorphic " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " not ▁ trimporphic " ) NEW_LINE DEDENT
def reachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE sum = 0 NEW_LINE step = 0 NEW_LINE while ( sum < target or ( sum - target ) % 2 != 0 ) : NEW_LINE INDENT step = step + 1 NEW_LINE sum = sum + step NEW_LINE DEDENT return step NEW_LINE DEDENT
def averageEven ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 2 ) // 2 NEW_LINE DEDENT
def getLudic ( n ) : NEW_LINE INDENT ludics = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ludics . append ( i ) NEW_LINE DEDENT index = 1 NEW_LINE while ( index != len ( ludics ) ) : NEW_LINE INDENT first_ludic = ludics [ index ] NEW_LINE remove_index = index + first_ludic NEW_LINE while ( remove_index < len ( ludics ) ) : NEW_LINE INDENT ludics . remove ( ludics [ remove_index ] ) NEW_LINE remove_index = remove_index + first_ludic - 1 NEW_LINE DEDENT index += 1 NEW_LINE DEDENT return ludics NEW_LINE DEDENT
def fifthPowerSum ( n ) : NEW_LINE INDENT return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) // 12 NEW_LINE DEDENT
def maxFraction ( first , sec ) : NEW_LINE INDENT a = first [ 0 ] ; b = first [ 1 ] NEW_LINE c = sec [ 0 ] ; d = sec [ 1 ] NEW_LINE Y = a * d - b * c NEW_LINE return first if Y else sec NEW_LINE DEDENT
def find_distance ( n ) : NEW_LINE INDENT return n * ( ( 3 * n ) + 7 ) NEW_LINE DEDENT
def nearestPerfectSquare ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT sr = int ( math . sqrt ( arr [ i ] ) ) NEW_LINE if ( ( sr & 1 ) == ( arr [ i ] & 1 ) ) : NEW_LINE INDENT print ( sr * sr , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT sr += 1 NEW_LINE print ( sr * sr , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def squareSum ( n ) : NEW_LINE INDENT return int ( n * ( 4 * n * n - 1 ) / 3 ) NEW_LINE DEDENT
def squareSum ( n ) : NEW_LINE INDENT return int ( 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT
def kthdigit ( a , b , k ) : NEW_LINE INDENT p = a ** b NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count = count + 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p / 10 ; NEW_LINE DEDENT DEDENT
def isPentagonal ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT M = ( 3 * i * i - i ) / 2 NEW_LINE i += 1 NEW_LINE if ( M >= N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( M == N ) NEW_LINE DEDENT N = 12 NEW_LINE if ( isPentagonal ( N ) ) : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE print ( " is ▁ pentagonal ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE print ( " is ▁ not ▁ pentagonal " ) NEW_LINE DEDENT
def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 NEW_LINE DEDENT
def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def unitnumber ( x , y ) : NEW_LINE INDENT x = x % 10 NEW_LINE if y != 0 : NEW_LINE INDENT y = y % 4 + 4 NEW_LINE DEDENT return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 ) NEW_LINE DEDENT
def aliquotSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sm = sm + i NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT
def findDivisor ( x , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT return y NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT
def AvgofSquareN ( n ) : NEW_LINE INDENT return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEW_LINE DEDENT
def sumofFactors ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE n = n // i NEW_LINE if ( i == 2 and count == 1 ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE DEDENT curr_term = curr_term * i NEW_LINE curr_sum = curr_sum + curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxArea ( A , Len ) : NEW_LINE INDENT area = 0 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT for j in range ( i + 1 , Len ) : NEW_LINE INDENT area = max ( area , min ( A [ j ] , A [ i ] ) * ( j - i ) ) NEW_LINE DEDENT DEDENT return area NEW_LINE DEDENT
def maxArea ( A ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( A ) - 1 NEW_LINE area = 0 NEW_LINE while l < r : NEW_LINE INDENT area = max ( area , min ( A [ l ] , A [ r ] ) * ( r - l ) ) NEW_LINE if A [ l ] < A [ r ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return area NEW_LINE DEDENT
def sumofoddFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n = n // i NEW_LINE curr_term *= i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res *= curr_sum NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT res *= ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSolutions ( n , val ) : NEW_LINE INDENT total = 0 NEW_LINE if n == 1 and val >= 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( val + 1 ) : NEW_LINE INDENT total += countSolutions ( n - 1 , val - i ) NEW_LINE DEDENT return total NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT
def sumofNterm ( a , d , b , r , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( a + ( i - 1 ) * d ) * ( b * math . pow ( r , i - 1 ) ) ) NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += 1.0 / ( i * ( i + 1 ) ) ; NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT root = ( int ) ( math . sqrt ( n ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans = ans + n // i NEW_LINE DEDENT ans = 2 * ans - ( root * root ) NEW_LINE return ans NEW_LINE DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT k = 2 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum = sum + k ; NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum_n = int ( ( n * ( n + 1 ) / 2 ) ) ; NEW_LINE sum_sq_n = int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE return ( sum_n + sum_sq_n ) ; NEW_LINE DEDENT
def sumofsquare ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return ( ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ) NEW_LINE DEDENT
def evenSum ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n + 1 ) ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT sum = sum + C [ n ] [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def Series ( n ) : NEW_LINE INDENT sums = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ser = 1 / ( i ** i ) NEW_LINE sums += ser NEW_LINE DEDENT return sums NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 1 ; NEW_LINE while i <= n : NEW_LINE INDENT sum = sum + i * ( i + 1 ) * ( i + 2 ) NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def Series ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sums += ( i * i ) ; NEW_LINE DEDENT return sums NEW_LINE DEDENT
def Series ( x , n ) : NEW_LINE INDENT sum = 1 NEW_LINE term = 1 NEW_LINE fct = 1 NEW_LINE p = 1 NEW_LINE multi = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fct = fct * multi * ( multi + 1 ) NEW_LINE p = p * x * x NEW_LINE term = ( - 1 ) * term NEW_LINE multi += 2 NEW_LINE sum = sum + ( term * p ) / fct NEW_LINE DEDENT return sum NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
def first ( a , b , c ) : NEW_LINE INDENT a %= b NEW_LINE for i in range ( 1 , b + 1 ) : NEW_LINE INDENT a = a * 10 NEW_LINE if int ( a / b ) == c : NEW_LINE INDENT return i NEW_LINE DEDENT a %= b NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def timeToMeet ( s , v ) : NEW_LINE INDENT V = 3 * v / 2 ; NEW_LINE time = s / V ; NEW_LINE print ( time ) ; NEW_LINE DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum += k NEW_LINE k += 2 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def sumOfTheSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT
def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( int ( n / 3 - 1 ) , " ▁ " , int ( n / 3 ) , " ▁ " , int ( n / 3 + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( " x ▁ = ▁ " , i , " , ▁ y ▁ = ▁ " , int ( ( n - ( i * a ) ) / b ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i / j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i / j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += int ( n / i ) * i NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT
def sum_all_divisors ( num ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , math . floor ( math . sqrt ( num ) ) + 1 ) : NEW_LINE INDENT sum += t1 + t2 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return sum ( [ i * ( i + 1 ) / 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT
def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ▁ ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) / x NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ▁ ' ) NEW_LINE DEDENT print ( " " , end = ' ' ) NEW_LINE DEDENT DEDENT
def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) ; NEW_LINE DEDENT
def evenPowerSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 2 * i ; NEW_LINE sum = sum + ( j * j * j * j ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; NEW_LINE DEDENT
def quadrant ( x , y ) : NEW_LINE INDENT if ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ First ▁ quadrant " ) NEW_LINE DEDENT elif ( x < 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Second ▁ quadrant " ) NEW_LINE DEDENT elif ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Third ▁ quadrant " ) NEW_LINE DEDENT elif ( x > 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Fourth ▁ quadrant " ) NEW_LINE DEDENT elif ( x == 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) NEW_LINE DEDENT elif ( x == 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) NEW_LINE DEDENT elif ( y == 0 and x < 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) NEW_LINE DEDENT elif ( y == 0 and x > 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " lies ▁ at ▁ origin " ) NEW_LINE DEDENT DEDENT
def squaresum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT
def squaresum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 NEW_LINE DEDENT
def counLastDigitK ( low , high , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( i % 10 == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def counLastDigitK ( low , high , k ) : NEW_LINE INDENT mlow = 10 * math . ceil ( low / 10.0 ) NEW_LINE mhigh = 10 * int ( high / 10.0 ) NEW_LINE count = ( mhigh - mlow ) / 10 NEW_LINE if ( high % 10 >= k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( low % 10 <= k and ( low % 10 ) > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
def Polite ( n ) : NEW_LINE INDENT n = n + 1 NEW_LINE return ( int ) ( n + ( math . log ( ( n + math . log ( n , 2 ) ) , 2 ) ) ) NEW_LINE DEDENT
def numberOfTriangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 ; NEW_LINE return ans ; NEW_LINE DEDENT
def motzkin ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ) ; NEW_LINE DEDENT
def getResult ( st ) : NEW_LINE INDENT sum = 0 NEW_LINE length = len ( st ) NEW_LINE for i in st : NEW_LINE INDENT sum = sum + int ( i ) ** length NEW_LINE DEDENT number = int ( st ) NEW_LINE if ( number == sum ) : NEW_LINE INDENT return " true " NEW_LINE DEDENT else : NEW_LINE INDENT return " false " NEW_LINE DEDENT DEDENT
def solve ( low , high , T ) : NEW_LINE INDENT while low <= high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( mid * ( mid + 1 ) ) == T : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and ( mid * ( mid + 1 ) ) > T and ( mid * ( mid - 1 ) ) <= T ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( mid * ( mid + 1 ) ) > T : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT T = 15 NEW_LINE ans = solve ( 1 , T , 2 * T ) NEW_LINE if ans != - 1 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT
def nthSHN ( n , dp ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT dp [ n ] = 1 NEW_LINE return dp [ n ] NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n NEW_LINE return dp [ n ] NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT
def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if ( a == ( result // b ) ) : NEW_LINE INDENT print ( result // b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def evensum ( n ) : NEW_LINE INDENT curr = 2 NEW_LINE sum = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum += curr NEW_LINE curr += 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def evensum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) NEW_LINE DEDENT
def kthgroupsum ( k ) : NEW_LINE INDENT cur = int ( ( k * ( k - 1 ) ) + 1 ) NEW_LINE sum = 0 NEW_LINE while k : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k = k - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def kthgroupsum ( k ) : NEW_LINE INDENT return k * k * k NEW_LINE DEDENT
def oddSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE curr = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + curr NEW_LINE curr = curr + 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def oddSum ( n ) : NEW_LINE INDENT return ( n * n ) ; NEW_LINE DEDENT
def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 / pi ) NEW_LINE return degree NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT
def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime = [ True ] * ( B + 1 ) NEW_LINE p_factors = [ 0 ] * ( B + 1 ) NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if ( p_factors [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] = p_factors [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( p_factors [ i ] == K ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) * 1.0 ) NEW_LINE DEDENT
def printXYZ ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x ▁ is ▁ " , n ) NEW_LINE print ( " y ▁ is ▁ " , n + 1 ) NEW_LINE print ( " z ▁ is ▁ " , n * ( n + 1 ) ) NEW_LINE DEDENT DEDENT
def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans + i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE DEDENT
def avgOfFirstN ( n ) : NEW_LINE INDENT return ( float ) ( 1 + n ) / 2 ; NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT return int ( ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ) ; NEW_LINE DEDENT
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE multi = x NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + multi / i NEW_LINE multi = multi * x NEW_LINE DEDENT return total NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT x = ( ( ( 1 ) + math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) NEW_LINE return x NEW_LINE DEDENT
def isMember ( a , d , x ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return x == a NEW_LINE DEDENT return ( ( x - a ) % d == 0 and int ( ( x - a ) / d ) >= 0 ) NEW_LINE DEDENT a = 1 NEW_LINE x = 7 NEW_LINE d = 3 NEW_LINE if isMember ( a , d , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def compute ( a , b ) : NEW_LINE INDENT AM = ( a + b ) / 2 NEW_LINE GM = math . sqrt ( a * b ) NEW_LINE HM = ( GM * GM ) / AM NEW_LINE return HM NEW_LINE DEDENT
def minOp ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE if ( not ( rem == 3 or rem == 8 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def sumSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j <= n ) : NEW_LINE INDENT if ( i * i + j * j == n ) : NEW_LINE INDENT print ( i , " ^ 2 ▁ + ▁ " , j , " ^ 2" ) NEW_LINE return True NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 25 NEW_LINE if ( sumSquare ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def sumSquare ( n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT s [ i * i ] = 1 NEW_LINE if ( n - i * i ) in s . keys ( ) : NEW_LINE INDENT print ( ( n - i * i ) ** ( 1 / 2 ) , " ^ 2 ▁ + " , i , " ^ 2" ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 1 NEW_LINE if n == 1 : NEW_LINE INDENT print ( '0 ^ 2 ▁ + ▁ 1 ^ 2' ) NEW_LINE DEDENT elif ( sumSquare ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def judgeSquareSum ( n ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( i % 4 == 3 and count % 2 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return n % 4 != 3 ; NEW_LINE DEDENT n = 17 ; NEW_LINE if ( judgeSquareSum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def findK ( n , k ) : NEW_LINE INDENT a = list ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT a . append ( i ) NEW_LINE i = i + 2 NEW_LINE DEDENT i = 2 NEW_LINE while i < n : NEW_LINE INDENT a . append ( i ) NEW_LINE i = i + 2 NEW_LINE DEDENT return ( a [ k - 1 ] ) NEW_LINE DEDENT
def sumDivisible ( L , R ) : NEW_LINE INDENT p = int ( R / 6 ) NEW_LINE q = int ( ( L - 1 ) / 6 ) NEW_LINE sumR = 3 * ( p * ( p + 1 ) ) NEW_LINE sumL = ( q * ( q + 1 ) ) * 3 NEW_LINE return sumR - sumL NEW_LINE DEDENT
def max_area ( n , m , k ) : NEW_LINE INDENT if ( k > ( n + m - 2 ) ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k < max ( m , n ) - 1 ) : NEW_LINE INDENT result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT
def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT str1 = str ( i ) ; NEW_LINE countr += str1 . count ( "1" ) ; NEW_LINE DEDENT return countr ; NEW_LINE DEDENT
def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT divider = i * 10 ; NEW_LINE countr += ( int ( n / divider ) * i + min ( max ( n % divider - i + 1 , 0 ) , i ) ) ; NEW_LINE i *= 10 ; NEW_LINE DEDENT return countr ; NEW_LINE DEDENT
def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) / w ; NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) / w ; NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m / w ; NEW_LINE DEDENT else : NEW_LINE DEDENT return ( m == 0 ) ; NEW_LINE DEDENT w = 3 ; NEW_LINE m = 7 ; NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def divisible ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sum_ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_ += int ( num [ i ] ) NEW_LINE DEDENT if ( sum_ % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( sum_ % 3 == int ( num [ i ] ) % 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( n == 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def calculate ( n , power ) : NEW_LINE INDENT return sum ( [ int ( i ) for i in str ( pow ( n , power ) ) ] ) NEW_LINE DEDENT
def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEW_LINE DEDENT
def coutSubSeq ( A , N , M ) : NEW_LINE INDENT sum = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE INDENT sum = A [ i ] + A [ j ] + A [ k ] NEW_LINE if ( sum % M == 0 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findTerm ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) ; NEW_LINE DEDENT DEDENT return term ; NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE i = 1 NEW_LINE while n >= 0 : NEW_LINE INDENT n -= i NEW_LINE i += 1 NEW_LINE DEDENT return ( n + i ) NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT x = int ( math . floor ( ( - 1 + math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ) NEW_LINE base = ( x * ( x + 1 ) ) / 2 + 1 NEW_LINE return n - base + 1 NEW_LINE DEDENT
def correlationCoefficient ( X , Y , n ) : NEW_LINE INDENT sum_X = 0 NEW_LINE sum_Y = 0 NEW_LINE sum_XY = 0 NEW_LINE squareSum_X = 0 NEW_LINE squareSum_Y = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum_X = sum_X + X [ i ] NEW_LINE sum_Y = sum_Y + Y [ i ] NEW_LINE sum_XY = sum_XY + X [ i ] * Y [ i ] NEW_LINE squareSum_X = squareSum_X + X [ i ] * X [ i ] NEW_LINE squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / NEW_LINE INDENT ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) NEW_LINE DEDENT return corr NEW_LINE DEDENT
def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT
def weightedMean ( X , W , n ) : NEW_LINE INDENT sum = 0 NEW_LINE numWeight = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT numWeight = numWeight + X [ i ] * W [ i ] NEW_LINE sum = sum + W [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT return ( float ) ( numWeight / sum ) NEW_LINE DEDENT X = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE W = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( X ) NEW_LINE m = len ( W ) NEW_LINE if ( n == m ) : NEW_LINE INDENT print weightedMean ( X , W , n ) NEW_LINE DEDENT else : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT
def weightedMean ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) / 3 NEW_LINE DEDENT
def series ( n ) : NEW_LINE INDENT print ( ( 8 * n ** 2 ) + 1 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return gcd ( b , a ) NEW_LINE DEDENT if ( abs ( b ) < 0.001 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( b , a - math . floor ( a / b ) * b ) ) NEW_LINE DEDENT DEDENT
def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 1 ) / arr [ i ] ; NEW_LINE DEDENT return n / sm NEW_LINE DEDENT
def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT sm = 0 NEW_LINE frequency_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + freq [ i ] / arr [ i ] NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE DEDENT return ( round ( frequency_sum / sm , 4 ) ) NEW_LINE DEDENT
def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] / mul ) NEW_LINE print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N / a NEW_LINE sum = m * ( m + 1 ) / 2 NEW_LINE ans = a * sum NEW_LINE print ( " Sum ▁ of ▁ multiples ▁ of ▁ " , a , " ▁ up ▁ to ▁ " , N , " ▁ = ▁ " , ans ) NEW_LINE DEDENT
def bomb_required ( n ) : NEW_LINE INDENT print ( n + n // 2 ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def gcdMax ( a , b , n , N ) : NEW_LINE INDENT cnt = [ 0 ] * N NEW_LINE first = [ 0 ] * N NEW_LINE second = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] ) : NEW_LINE INDENT first [ i ] = max ( first [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT cnt = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT second [ i ] = max ( second [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT i = N - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( first [ i ] > 0 and second [ i ] > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( str ( first [ i ] ) + " ▁ " + str ( second [ i ] ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE DEDENT
def ispowerof2 ( num ) : NEW_LINE INDENT if ( ( num & ( num - 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def isWoodall ( x ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = 0 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x / 2 NEW_LINE p = p + 1 NEW_LINE if ( p == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT x = 383 NEW_LINE if ( isWoodall ( x ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def print_result ( a , n , k , m ) : NEW_LINE INDENT v = [ [ ] for i in range ( m ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT rem = a [ i ] % m NEW_LINE v [ rem ] . append ( a [ i ] ) NEW_LINE if ( len ( v [ rem ] ) == k ) : NEW_LINE INDENT for j in range ( 0 , k ) : NEW_LINE INDENT print ( v [ rem ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def complement ( number ) : NEW_LINE INDENT for i in range ( 0 , len ( number ) ) : NEW_LINE INDENT if ( number [ i ] != ' . ' ) : NEW_LINE INDENT a = 9 - int ( number [ i ] ) NEW_LINE number = ( number [ : i ] + str ( a ) + number [ i + 1 : ] ) NEW_LINE DEDENT DEDENT print ( "9 ' s ▁ complement ▁ is ▁ : ▁ " , number ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( ( i * i ) < n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def isPowerOfK ( n , k ) : NEW_LINE INDENT oneSeen = False NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % k NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT if ( oneSeen ) : NEW_LINE INDENT return False NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT n //= k NEW_LINE DEDENT return True NEW_LINE DEDENT n = 64 NEW_LINE k = 4 NEW_LINE if ( isPowerOfK ( n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printFactorialNums ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while fact <= n : NEW_LINE INDENT print ( fact , end = " ▁ " ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
def Cel_To_Fah ( n ) : NEW_LINE INDENT return ( n * 1.8 ) + 32 NEW_LINE DEDENT
def countCompositions ( n ) : NEW_LINE INDENT return ( 2 ** ( n - 1 ) ) NEW_LINE DEDENT
def computeLastDigit ( A , B ) : NEW_LINE INDENT variable = 1 NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( ( B - A ) >= 5 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( A + 1 , B + 1 ) : NEW_LINE INDENT variable = ( variable * ( i % 10 ) ) % 10 NEW_LINE DEDENT return variable % 10 NEW_LINE DEDENT DEDENT
def findSumSubsets ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE x = m . exp ( _sum / n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT x = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT x = ( n / 2 ) * ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = ( ( n + 1 ) / 2 ) * n NEW_LINE DEDENT return ( int ) ( x * x ) NEW_LINE DEDENT
def findValue ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT ans = ans if ans > ( abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ) else ( abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
def countsubarray ( array , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if array [ i ] < k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT mul = array [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mul = mul * array [ j ] NEW_LINE if mul < k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def multiplyFactors ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE DEDENT else : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE prod = ( prod * n / i ) % M NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return prod NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT if n / 10 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + countDigit ( n // 10 ) NEW_LINE DEDENT
def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = dp [ 1 ] = 0 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
def printTrib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE third = 1 NEW_LINE print ( first , " ▁ " , end = " " ) NEW_LINE if ( n > 1 ) : NEW_LINE INDENT print ( second , " ▁ " , end = " " ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( second , " ▁ " , end = " " ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT curr = first + second + third NEW_LINE first = second NEW_LINE second = third NEW_LINE third = curr NEW_LINE print ( curr , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
def digit_product_Sum ( N ) : NEW_LINE INDENT a = [ 0 ] * ( N + 1 ) ; NEW_LINE product = 1 ; NEW_LINE a [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = int ( a [ i - 1 ] / 10 ) ; NEW_LINE if ( product == 0 ) : NEW_LINE INDENT product = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT product = a [ i - 1 ] % 10 ; NEW_LINE DEDENT val = int ( a [ i - 1 ] / 10 ) ; NEW_LINE if ( val == 0 ) : NEW_LINE INDENT val = a [ i - 1 ] ; NEW_LINE DEDENT a [ i ] = a [ i - 1 ] + ( val * product ) ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def geometricMean ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT gm = ( float ) ( math . pow ( product , ( 1 / n ) ) ) NEW_LINE return ( float ) ( gm ) NEW_LINE DEDENT
def geometricMean ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + math . log ( arr [ i ] ) ; NEW_LINE DEDENT sum = sum / n ; NEW_LINE return math . exp ( sum ) ; NEW_LINE DEDENT
def printTaxicab2 ( N ) : NEW_LINE INDENT i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , math . ceil ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , math . ceil ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , " ▁ " , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def isMagic ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum ; NEW_LINE sum = 0 ; NEW_LINE DEDENT sum = sum + n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return True if ( sum == 1 ) else False ; NEW_LINE DEDENT n = 1234 ; NEW_LINE if ( isMagic ( n ) ) : NEW_LINE INDENT print ( " Magic ▁ Number " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ magic ▁ Number " ) ; NEW_LINE DEDENT
def productOfSingelDgt ( n ) : NEW_LINE INDENT if n >= 0 and n <= 9 : NEW_LINE INDENT return True NEW_LINE DEDENT prime = [ 2 , 3 , 5 , 7 ] NEW_LINE i = 0 NEW_LINE while i < SIZE and n > 1 : NEW_LINE INDENT while n % prime [ i ] == 0 : NEW_LINE INDENT n = n / prime [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n == 1 NEW_LINE DEDENT n = 24 NEW_LINE if productOfSingelDgt ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE x = 1 NEW_LINE while x <= n : NEW_LINE INDENT sum = sum + x NEW_LINE x = x + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE return ( ( n + 1 ) / 2 ) * n NEW_LINE DEDENT
def sackRace ( p1 , s1 , p2 , s2 ) : NEW_LINE INDENT return ( ( s1 > s2 and ( p2 - p1 ) % ( s1 - s2 ) == 0 ) or ( s2 > s1 and ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) NEW_LINE DEDENT p1 = 4 NEW_LINE s1 = 4 NEW_LINE p2 = 8 NEW_LINE s2 = 2 NEW_LINE if ( sackRace ( p1 , s1 , p2 , s2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def count ( x , y ) : NEW_LINE INDENT m = dict ( ) NEW_LINE while x % y != 0 : NEW_LINE INDENT x %= y NEW_LINE ans += 1 NEW_LINE if x in m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def xorCalc ( k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( ( k + 1 ) & k ) == 0 ) : NEW_LINE INDENT return k / 2 NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT
def divCount ( n ) : NEW_LINE INDENT hh = [ 1 ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( ( p * p ) < n ) : NEW_LINE INDENT if ( hh [ p ] == 1 ) : NEW_LINE INDENT for i in range ( ( p * 2 ) , n , p ) : NEW_LINE INDENT hh [ i ] = 0 ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT total = 1 ; NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( hh [ p ] == 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n % p == 0 ) : NEW_LINE INDENT while ( n % p == 0 ) : NEW_LINE INDENT n = int ( n / p ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT total *= ( count + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT return total ; NEW_LINE DEDENT
def maxPrimefactorNum ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT arr = [ True ] * ( N + 1 ) ; NEW_LINE prod = 1 ; NEW_LINE res = 0 ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( arr [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT arr [ i ] = False ; NEW_LINE DEDENT prod *= p ; NEW_LINE if ( prod > N ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT res += 1 ; NEW_LINE DEDENT p += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def arraySum ( arr , n ) : NEW_LINE INDENT x = ( n + 1 ) / 2 NEW_LINE return ( arr [ 0 ] - 1 ) * n + x * x NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT
def multiple ( a , b , x ) : NEW_LINE INDENT if ( b < 0 ) : NEW_LINE INDENT if ( a == 1 and x == 1 ) : NEW_LINE INDENT print ( "1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) ; NEW_LINE DEDENT DEDENT mul = int ( pow ( a , b ) ) ; NEW_LINE ans = int ( mul / x ) ; NEW_LINE ans1 = x * ans ; NEW_LINE ans2 = x * ( ans + 1 ) ; NEW_LINE if ( ( mul - ans1 ) <= ( ans2 - mul ) ) : NEW_LINE INDENT print ( ans1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans2 ) ; NEW_LINE DEDENT DEDENT
def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n / divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) // 10 NEW_LINE divisor = divisor / 100 NEW_LINE DEDENT return True NEW_LINE DEDENT if ( isPalindrome ( 1001 ) ) : NEW_LINE INDENT print ( ' Yes , ▁ it ▁ is ▁ palindrome ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No , ▁ not ▁ palindrome ' ) NEW_LINE DEDENT
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE return m + k - 1 NEW_LINE m = m - ( n - k + 1 ) NEW_LINE if ( m % n == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return m % n NEW_LINE DEDENT DEDENT
def maxSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ) NEW_LINE DEDENT DEDENT
def primesInRange ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for k in range ( 2 , n ) : NEW_LINE INDENT fact = fact * ( k - 1 ) NEW_LINE if ( ( fact + 1 ) % k == 0 ) : NEW_LINE INDENT print k NEW_LINE DEDENT DEDENT DEDENT
def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT n = 9 NEW_LINE if ( check ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def productPuzzle ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log10 ( a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print int ( ( EPS + pow ( 10.00 , sum - math . log10 ( a [ i ] ) ) ) ) , NEW_LINE DEDENT return NEW_LINE DEDENT
def changeEvenBits ( n ) : NEW_LINE INDENT to_subtract = 0 NEW_LINE m = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT to_subtract += ( 1 << m ) NEW_LINE DEDENT m += 2 NEW_LINE x >>= 2 NEW_LINE DEDENT return n - to_subtract NEW_LINE DEDENT
def closestNumber ( n , m ) : NEW_LINE INDENT q = int ( n / m ) NEW_LINE n1 = m * q NEW_LINE if ( ( n * m ) > 0 ) : NEW_LINE INDENT n2 = ( m * ( q + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n2 = ( m * ( q - 1 ) ) NEW_LINE DEDENT if ( abs ( n - n1 ) < abs ( n - n2 ) ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT
def checkPronic ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= ( int ) ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if ( x == i * ( i + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT i = 0 NEW_LINE while ( i <= 200 ) : NEW_LINE INDENT if checkPronic ( i ) : NEW_LINE INDENT print i , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT
def countConsecutive ( N ) : NEW_LINE INDENT count = 0 NEW_LINE L = 1 NEW_LINE while ( L * ( L + 1 ) < 2 * N ) : NEW_LINE INDENT a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) NEW_LINE if ( a - int ( a ) == 0.0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT L += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findMinSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 2 NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE num /= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum += num NEW_LINE return sum NEW_LINE DEDENT
def compute_average ( a , b ) : NEW_LINE INDENT return floor ( ( a + b ) / 2 ) NEW_LINE DEDENT
def minNum ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if ( odd % 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def minNum ( arr , n ) : NEW_LINE INDENT odd = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd = not odd NEW_LINE DEDENT DEDENT if ( odd ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def checkJumbled ( num ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( num != 0 ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT digit1 = num % 10 NEW_LINE digit2 = ( num / 10 ) % 10 NEW_LINE if ( abs ( digit2 - digit1 ) > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = num / 10 NEW_LINE DEDENT return True NEW_LINE DEDENT num = - 1234 NEW_LINE if ( checkJumbled ( abs ( num ) ) ) : NEW_LINE INDENT print " True ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT print " False " NEW_LINE DEDENT num = - 1247 NEW_LINE if ( checkJumbled ( abs ( num ) ) ) : NEW_LINE INDENT print " True ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT print " False " NEW_LINE DEDENT
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) NEW_LINE DEDENT
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = 2 * b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT
def printDemlo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE res = " " NEW_LINE for i in range ( 1 , l + 1 ) : NEW_LINE INDENT res = res + str ( i ) NEW_LINE DEDENT for i in range ( l - 1 , 0 , - 1 ) : NEW_LINE INDENT res = res + str ( i ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def NumberofTimes ( s ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( s ) > 1 ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temporary_sum += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT s = str ( temporary_sum ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def calculateLeaps ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT leaps = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leaps = leaps + calculateLeaps ( i ) ; NEW_LINE DEDENT return leaps ; NEW_LINE DEDENT DEDENT
def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n / k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n / imin NEW_LINE DEDENT return ans NEW_LINE DEDENT
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def totalDigits ( n ) : NEW_LINE INDENT number_of_digits = 0 ; NEW_LINE for i in range ( 1 , n , 10 ) : NEW_LINE INDENT number_of_digits = ( number_of_digits + ( n - i + 1 ) ) ; NEW_LINE DEDENT return number_of_digits ; NEW_LINE DEDENT
def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = " ▁ " ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) NEW_LINE i = i + 1 NEW_LINE DEDENT n = int ( n / 16 ) NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( ( hexaDeciNum [ j ] ) , end = " " ) NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT
def decimalToBinary ( N ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = pow ( 10 , cnt ) NEW_LINE B_Number += rem * c NEW_LINE N //= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base = 1 ; NEW_LINE temp = num ; NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE dec_value += last_digit * base ; NEW_LINE base = base * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT
def stirlingFactorial ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT e = 2.71 NEW_LINE z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) NEW_LINE return math . floor ( z ) NEW_LINE DEDENT
def countXorPair ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countXorPair ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT return odd * even NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( n + 1 ) * ( n + 2 ) // 2 NEW_LINE return count NEW_LINE DEDENT
def numOfCombinations ( arr , N ) : NEW_LINE INDENT C = [ 0 , 0 , 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ arr [ i ] % 3 ] = C [ arr [ i ] % 3 ] + 1 NEW_LINE DEDENT return ( C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ) NEW_LINE DEDENT
def findRectNum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) NEW_LINE DEDENT
def nthprimedigitsnumber ( number ) : NEW_LINE INDENT num = " " ; NEW_LINE while ( number > 0 ) : NEW_LINE INDENT rem = number % 4 ; NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT num += '2' ; NEW_LINE DEDENT if ( rem == 2 ) : NEW_LINE INDENT num += '3' ; NEW_LINE DEDENT if ( rem == 3 ) : NEW_LINE INDENT num += '5' ; NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT num += '7' ; NEW_LINE DEDENT if ( number % 4 == 0 ) : NEW_LINE INDENT number = number - 1 NEW_LINE DEDENT number = number // 4 ; NEW_LINE DEDENT return num [ : : - 1 ] ; NEW_LINE DEDENT
def findNoIsDivisibleOrNot ( n , l = [ ] ) : NEW_LINE INDENT for i in range ( 0 , len ( l ) ) : NEW_LINE INDENT if l [ i ] % n != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT l = [ 14 , 12 , 4 , 18 ] NEW_LINE n = 2 NEW_LINE if findNoIsDivisibleOrNot ( n , l ) == 1 : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( math . pow ( N , 1 / 3 ) + 1 ) ) : NEW_LINE INDENT cb = i * i * i NEW_LINE diff = N - cb NEW_LINE cbrtDiff = int ( math . pow ( diff , 1 / 3 ) ) NEW_LINE if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( ' For ▁ n ▁ = ▁ ' , i , ' , ▁ ' , countPairs ( i ) , ' ▁ pair ▁ exists ' ) NEW_LINE DEDENT
def sumOfTermsInNthRow ( n ) : NEW_LINE INDENT sum = n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE return sum NEW_LINE DEDENT
def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x // 10 NEW_LINE DEDENT return x NEW_LINE DEDENT
def FirstDigit ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + math . log10 ( arr [ i ] * 1.0 ) NEW_LINE DEDENT fract_S = S - math . floor ( S ) NEW_LINE ans = math . pow ( 10 , fract_S ) NEW_LINE return ans NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while temp != 0 : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if d > 0 and n % d == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def getOccurence ( n , d ) : NEW_LINE INDENT result = 0 ; NEW_LINE itr = d ; NEW_LINE while ( itr <= n ) : NEW_LINE INDENT if ( itr % 10 == d ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT if ( itr != 0 and math . floor ( itr / 10 ) == d ) : NEW_LINE INDENT result += 1 ; NEW_LINE itr += 1 ; NEW_LINE DEDENT elif ( math . floor ( itr / 10 ) == d - 1 ) : NEW_LINE INDENT itr = itr + ( 10 - d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT itr = itr + 10 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT
def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = 1 NEW_LINE cosx = x1 NEW_LINE cosval = cos ( n ) NEW_LINE i = 1 NEW_LINE denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE while ( accuracy <= fabs ( cosval - cosx ) ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT print ( ' { 0 : . 6 } ' . format ( cosx ) ) NEW_LINE DEDENT
def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number = number + 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) // 2 NEW_LINE c = ( n * n + 1 ) // 2 NEW_LINE print ( " b ▁ = " , b , " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n // 4 - 1 NEW_LINE c = n * n // 4 + 1 NEW_LINE print ( " b ▁ = " , b " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT DEDENT
def makeOdd ( n ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 and ( int ) ( n / i ) % 2 == 1 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT
def makeOdd ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT resul = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 ; NEW_LINE resul = resul * 2 ; NEW_LINE DEDENT return resul ; NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , N , 2 ) : NEW_LINE INDENT res ^= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x / 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT
def isAutomorphic ( N ) : NEW_LINE INDENT sq = N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != sq % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N /= 10 NEW_LINE sq /= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT N = 5 NEW_LINE if isAutomorphic ( N ) : NEW_LINE INDENT print " Automorphic " NEW_LINE DEDENT else : NEW_LINE INDENT print " Not ▁ Automorphic " NEW_LINE DEDENT
def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) ; NEW_LINE arr [ 1 ] = 4 NEW_LINE arr [ 2 ] = 7 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 4 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 7 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT
def maxSumLCM ( n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT max_sum = max_sum + i NEW_LINE if ( n // i != i ) : NEW_LINE INDENT max_sum = max_sum + ( n // i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( j ** 3 , i + 1 ) : NEW_LINE INDENT if ( j ** 3 == i ) : NEW_LINE INDENT print ( j ** 3 , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def func ( a , k , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT a = [ 14 , 27 , 38 , 76 , 84 ] NEW_LINE k = 19 NEW_LINE res = func ( a , k , 5 ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( " true " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " false " ) NEW_LINE DEDENT
def tidyNum ( str , len ) : NEW_LINE INDENT for i in range ( len - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] > str [ i + 1 ] ) : NEW_LINE INDENT str [ i ] -= 1 NEW_LINE for j in range ( i + 1 , len ) : NEW_LINE INDENT str [ j ] = 9 NEW_LINE DEDENT DEDENT DEDENT return str NEW_LINE DEDENT str = [ 1 , 1 , 3 , 3 , 3 , 4 , 4 , 5 , 5 , 3 , 8 ] NEW_LINE len = len ( str ) NEW_LINE num = tidyNum ( str , len ) NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT
def findCount ( m , n ) : NEW_LINE INDENT num1 = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT num1 = ( num1 * 10 ) + 9 NEW_LINE DEDENT num2 = 0 NEW_LINE for i in range ( 0 , ( m - 1 ) ) : NEW_LINE INDENT num2 = ( num2 * 10 ) + 9 NEW_LINE DEDENT return int ( ( num1 / n ) - ( num2 / n ) ) NEW_LINE DEDENT
def findNthEvenDigitNumber ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT curr = i ; NEW_LINE isCurrEvenDigit = True ; NEW_LINE while ( curr != 0 ) : NEW_LINE INDENT if ( curr % 10 == 1 or curr % 10 == 3 or curr % 10 == 5 or curr % 10 == 7 or curr % 10 == 9 ) : NEW_LINE INDENT isCurrEvenDigit = False ; NEW_LINE DEDENT curr = curr // 10 ; NEW_LINE DEDENT if ( isCurrEvenDigit == True ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT
def toBinary ( n ) : NEW_LINE INDENT if ( n >= 1 or n <= 0 ) : NEW_LINE INDENT return " ERROR " ; NEW_LINE DEDENT frac = 0.5 ; NEW_LINE answer = " . " ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( len ( answer ) >= 32 ) : NEW_LINE INDENT return " ERROR " ; NEW_LINE DEDENT if ( n >= frac ) : NEW_LINE INDENT answer += "1" ; NEW_LINE n = n - frac ; NEW_LINE DEDENT else : NEW_LINE INDENT answer += "0" ; NEW_LINE DEDENT frac = ( frac / 2 ) ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT
def isMultipleOf10 ( n ) : NEW_LINE INDENT return ( n % 15 == 0 ) NEW_LINE DEDENT n = 30 NEW_LINE if ( isMultipleOf10 ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def isDivisibleBy25 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( int ) ( st [ n - 1 ] ) == 0 and ( ( int ) ( st [ n - 2 ] ) == 0 ) or ( ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) % 25 == 0 ) ) NEW_LINE DEDENT st = "76955" NEW_LINE if ( isDivisibleBy25 ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 and n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( st [ n - 1 ] ) % 16 == 0 ) ) NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return ( ( ( int ) ( st [ n - 3 ] ) * 100 + ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) ) % 16 == 0 ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE fourth_last = ( int ) ( st [ n - 4 ] ) NEW_LINE return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) NEW_LINE DEDENT st = "769528" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product // pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT
def checkPandigital ( b , n ) : NEW_LINE INDENT if ( len ( n ) < b ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT hash = [ 0 ] * b ; NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] >= '0' and n [ i ] <= '9' ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( '0' ) ] = 1 ; NEW_LINE DEDENT elif ( ord ( n [ i ] ) - ord ( ' A ' ) <= b - 11 ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( ' A ' ) + 10 ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( b ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT b = 13 ; NEW_LINE n = "1298450376ABC " ; NEW_LINE if ( checkPandigital ( b , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def conver ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + conver ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + conver ( m , n / 2 ) NEW_LINE DEDENT DEDENT
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT a = a % mod ; NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( 2 * a ) % mod ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def numberOf2sinRange ( n ) : NEW_LINE INDENT s = " " NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT s += str ( i ) NEW_LINE DEDENT return ( list ( s ) . count ( '2' ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT M = 1000000007 NEW_LINE f = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE return f NEW_LINE DEDENT
def mod ( a , m ) : NEW_LINE INDENT return ( a % m + m ) % m NEW_LINE DEDENT
def findStarNum ( n ) : NEW_LINE INDENT return ( 6 * n * ( n - 1 ) + 1 ) NEW_LINE DEDENT
def isDivisibleBy5 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE return ( ( st [ n - 1 ] == '0' ) or ( st [ n - 1 ] == '5' ) ) NEW_LINE DEDENT st = "76955" NEW_LINE if isDivisibleBy5 ( st ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No ▁ " NEW_LINE DEDENT
def isTidy ( num ) : NEW_LINE INDENT prev = 10 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE num /= 10 NEW_LINE if rem > prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = rem NEW_LINE DEDENT return True NEW_LINE DEDENT num = 1556 NEW_LINE if isTidy ( num ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minToggle ( arr , n ) : NEW_LINE INDENT zero = [ 0 for i in range ( n + 1 + 1 ) ] NEW_LINE zero [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] == 0 ) : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] NEW_LINE DEDENT DEDENT ans = n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for x in range ( n , 0 , - 1 ) : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while ( no != 0 ) : NEW_LINE INDENT if ( prev_dig < no % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no //= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
def countDivisors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE cnt = cnt + 2 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def validate ( n ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT temp = n ; NEW_LINE count = 0 ; NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 10 == i ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count > i ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT temp //= 10 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT
def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT two_digit_num = ( ( ( int ) ( num [ l - 2 ] ) ) * 10 + ( int ) ( num [ l - 1 ] ) ) NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT sm = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sm = sm + ( int ) ( num [ i ] ) NEW_LINE DEDENT if ( sm % 9 != 0 ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT return ( " Yes " ) NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT st = "99333" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT st = "1332" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( int ) ( st [ 0 ] ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( str [ n - 1 ] ) % 8 == 0 ) ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = "76952" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) NEW_LINE DEDENT
def politness ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , int ( math . sqrt ( 2 * n ) ) + 1 ) : NEW_LINE INDENT if ( ( 2 * n ) % i != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT a = 2 * n NEW_LINE a = a / i NEW_LINE a = a - ( i - 1 ) NEW_LINE if ( a % 2 != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT a /= 2 NEW_LINE if ( a > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isRefactorableNumber ( n ) : NEW_LINE INDENT divCount = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT divCount += 1 NEW_LINE divCount += 2 NEW_LINE DEDENT DEDENT DEDENT return n % divCount == 0 NEW_LINE DEDENT n = 8 NEW_LINE if isRefactorableNumber ( n ) : NEW_LINE INDENT print " yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " no " NEW_LINE DEDENT n = 14 NEW_LINE if ( isRefactorableNumber ( n ) ) : NEW_LINE INDENT print " yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " no " NEW_LINE DEDENT
def check ( num ) : NEW_LINE INDENT digitSum = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rem = num % 10 NEW_LINE digitSum = digitSum + rem NEW_LINE num = num / 10 NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT num = 1332 NEW_LINE if ( check ( num ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def nthPalindrome ( n , k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT temp = k // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = k // 2 - 1 NEW_LINE DEDENT palindrome = 10 ** temp NEW_LINE palindrome = palindrome + n - 1 NEW_LINE print ( palindrome , end = " " ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while ( palindrome ) : NEW_LINE INDENT print ( palindrome % 10 , end = " " ) NEW_LINE palindrome = palindrome // 10 NEW_LINE DEDENT DEDENT
def findMax ( n , a , b , k , m ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT lowerbound = a [ i ] NEW_LINE upperbound = b [ i ] NEW_LINE for j in range ( lowerbound , upperbound + 1 ) : NEW_LINE arr [ j ] += k [ i ] NEW_LINE res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE return res NEW_LINE DEDENT DEDENT DEDENT
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def SubArraySum ( arr , n ) : NEW_LINE INDENT temp , result = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += arr [ j ] NEW_LINE result += temp NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def SubArraySum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def nthElement ( a , b , n ) : NEW_LINE INDENT seq = [ ] ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT seq . append ( a * i ) ; NEW_LINE DEDENT seq . sort ( ) ; NEW_LINE i = 1 ; NEW_LINE k = n ; NEW_LINE while ( i <= n and k > 0 ) : NEW_LINE INDENT try : NEW_LINE INDENT z = seq . index ( b * i ) ; NEW_LINE DEDENT except ValueError : NEW_LINE INDENT seq . append ( b * i ) ; NEW_LINE seq . sort ( ) ; NEW_LINE k -= 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return seq [ n - 1 ] ; NEW_LINE DEDENT
def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT y = int ( n / x ) NEW_LINE ans += ( y * x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def lastNon0Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def minPower ( n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( n % x ) NEW_LINE n //= x NEW_LINE DEDENT return ans NEW_LINE DEDENT
def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE INDENT return 3 NEW_LINE return 3 NEW_LINE return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n = n - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findKHCF ( x , y , k ) : NEW_LINE INDENT small = min ( x , y ) NEW_LINE count = 1 NEW_LINE for i in range ( 2 , small + 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( fact % x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def highestPowerof2 ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( ( i & ( i - 1 ) ) == 0 ) : NEW_LINE INDENT res = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) ; NEW_LINE return int ( pow ( 2 , p ) ) ; NEW_LINE DEDENT
def countMaxChoco ( money , price , wrap ) : NEW_LINE INDENT if ( money < price ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT choc = int ( money / price ) NEW_LINE choc = choc + ( choc - 1 ) / ( wrap - 1 ) NEW_LINE return int ( choc ) NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE y = N / K ; NEW_LINE x = N % K ; NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT
def maxHandshake ( n ) : NEW_LINE INDENT return int ( ( n * ( n - 1 ) ) / 2 ) NEW_LINE DEDENT
def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for i in range ( n + 2 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def canBeSumofConsec ( n ) : NEW_LINE INDENT return ( ( n & ( n - 1 ) ) and n ) NEW_LINE DEDENT n = 15 NEW_LINE if ( canBeSumofConsec ( n ) ) : NEW_LINE INDENT print ( " true " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " false " ) NEW_LINE DEDENT
def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT
def evenFib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return math . floor ( x / y ) ; NEW_LINE DEDENT return math . floor ( ( x / y ) + countSteps ( y , x % y ) ) ; NEW_LINE DEDENT
def findCountOfSolutions ( n , p ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for x in range ( 1 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == 1 ) : NEW_LINE INDENT last = x + p * ( n / p ) ; NEW_LINE if ( last > n ) : NEW_LINE INDENT last -= p ; NEW_LINE DEDENT ans += ( ( last - x ) / p + 1 ) ; NEW_LINE DEDENT DEDENT return int ( ans ) ; NEW_LINE DEDENT
def spellsCount ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE result = 1 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 ; NEW_LINE while ( i < n - 1 and num [ i + 1 ] == num [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT result = result * int ( pow ( 2 , count - 1 ) ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
def sqroot ( s ) : NEW_LINE INDENT pSq = 0 ; NEW_LINE N = 0 ; NEW_LINE for i in range ( int ( s ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i ; NEW_LINE N = j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT d = s - pSq ; NEW_LINE P = d / ( 2.0 * N ) ; NEW_LINE A = N + P ; NEW_LINE INDENT sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; NEW_LINE return sqrt_of_s ; NEW_LINE DEDENT
def maxProd ( n ) : NEW_LINE INDENT if ( n == 2 or n == 3 ) : NEW_LINE INDENT return ( n - 1 ) ; NEW_LINE DEDENT res = 1 ; NEW_LINE while ( n > 4 ) : NEW_LINE INDENT n -= 3 ; NEW_LINE res *= 3 ; NEW_LINE DEDENT return ( n * res ) ; NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n /= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE return ( n % 9 ) NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT return n / 3 + n / 7 - n / 21 ; NEW_LINE DEDENT
def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev = 1 NEW_LINE prev = 2 NEW_LINE curr = 3 NEW_LINE while n > 0 : NEW_LINE INDENT prevPrev = prev NEW_LINE prev = curr NEW_LINE curr = prevPrev + prev NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT
def countOddSquares ( n , m ) : NEW_LINE INDENT return int ( m ** 0.5 ) - int ( ( n - 1 ) ** 0.5 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( ( ~ a & 1 ) == 1 ) : NEW_LINE INDENT if ( ( b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a >> 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( a >> 1 , b >> 1 ) << 1 ) NEW_LINE DEDENT DEDENT if ( ( ~ b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a , b >> 1 ) NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( ( a - b ) >> 1 , b ) NEW_LINE DEDENT return gcd ( ( b - a ) >> 1 , a ) NEW_LINE DEDENT
def findPieces ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) // 2 + 1 NEW_LINE DEDENT
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) ; NEW_LINE return math . floor ( x ) + 1 ; NEW_LINE DEDENT
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT digits = 0 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) ; NEW_LINE DEDENT return math . floor ( digits ) + 1 ; NEW_LINE DEDENT
def findPairs ( n ) : NEW_LINE INDENT cubeRoot = int ( math . pow ( n , 1.0 / 3.0 ) ) ; NEW_LINE cube = [ 0 ] * ( cubeRoot + 1 ) ; NEW_LINE for i in range ( 1 , cubeRoot + 1 ) : NEW_LINE INDENT cube [ i ] = i * i * i ; NEW_LINE DEDENT l = 1 ; NEW_LINE r = cubeRoot ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( cube [ l ] + cube [ r ] < n ) : NEW_LINE INDENT l += 1 ; NEW_LINE DEDENT elif ( cube [ l ] + cube [ r ] > n ) : NEW_LINE INDENT r -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ( " , l , " , ▁ " , math . floor ( r ) , " ) " , end = " " ) ; NEW_LINE print ( ) ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT DEDENT DEDENT
def countEvenSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE if ( sum % 2 == 0 ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT
def countEvenSum ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE s = 0 NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT if arr [ i ] % 2 == 1 : NEW_LINE INDENT s = n - i - 1 - s NEW_LINE DEDENT else : NEW_LINE INDENT s = s + 1 NEW_LINE DEDENT res = res + s NEW_LINE DEDENT return res NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 1 ] = 1 NEW_LINE sm = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sm = sm + fibo [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT res1 = math . log ( y ) // math . log ( x ) ; NEW_LINE res2 = math . log ( y ) / math . log ( x ) ; NEW_LINE return 1 if ( res1 == res2 ) else 0 ; NEW_LINE DEDENT
def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE the_sum = 0 NEW_LINE while the_sum < n : NEW_LINE INDENT the_sum += i NEW_LINE if the_sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findCount ( d ) : NEW_LINE INDENT return 9 * ( ( int ) ( math . pow ( 10 , d - 1 ) ) - ( int ) ( math . pow ( 9 , d - 1 ) ) ) ; NEW_LINE DEDENT
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT
def countDivisors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 2 NEW_LINE DEDENT DEDENT DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT DEDENT
def printDivisors ( n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE list . append ( int ( n / i ) ) NEW_LINE DEDENT DEDENT DEDENT for i in list [ : : - 1 ] : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print i , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT print i , NEW_LINE DEDENT else : NEW_LINE INDENT print i , n / i , NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum , n = 0 , 1 NEW_LINE while ( sum <= num ) : NEW_LINE INDENT sum = sum + n NEW_LINE if ( sum == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 55 NEW_LINE if ( isTriangular ( n ) ) : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 55 NEW_LINE if ( isTriangular ( n ) ) : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT
def fractionToDecimal ( numr , denr ) : NEW_LINE INDENT res = " " NEW_LINE mp = { } NEW_LINE rem = numr % denr NEW_LINE while ( ( rem != 0 ) and ( rem not in mp ) ) : NEW_LINE INDENT mp [ rem ] = len ( res ) NEW_LINE rem = rem * 10 NEW_LINE res_part = rem // denr NEW_LINE res += str ( res_part ) NEW_LINE rem = rem % denr NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT return " " NEW_LINE DEDENT else : NEW_LINE INDENT return res [ mp [ rem ] : ] NEW_LINE DEDENT DEDENT numr , denr = 50 , 22 NEW_LINE res = fractionToDecimal ( numr , denr ) NEW_LINE if ( res == " " ) : NEW_LINE INDENT print ( " No ▁ recurring ▁ sequence " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Recurring ▁ sequence ▁ is " , res ) NEW_LINE DEDENT
def greyConverter ( n ) : NEW_LINE INDENT return n ^ ( n >> 1 ) NEW_LINE DEDENT
def seriesSum ( calculated , current , N ) : NEW_LINE INDENT i = calculated ; NEW_LINE cur = 1 ; NEW_LINE if ( current == N + 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( i < calculated + current ) : NEW_LINE INDENT cur *= i ; NEW_LINE i += 1 ; NEW_LINE DEDENT return cur + seriesSum ( i , current + 1 , N ) ; NEW_LINE DEDENT
def SieveOfSundaram ( n ) : NEW_LINE INDENT nNew = int ( ( n - 1 ) / 2 ) ; NEW_LINE marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) ; NEW_LINE DEDENT for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def modFact ( n , p ) : NEW_LINE INDENT if n >= p : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result = ( result * i ) % p NEW_LINE DEDENT return result NEW_LINE DEDENT
def findMinX ( num , rem , k ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT j = 0 ; NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( x % num [ j ] != rem [ j ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( j == k ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT x += 1 ; NEW_LINE DEDENT DEDENT
def countSquares ( m , n ) : NEW_LINE INDENT if ( n < m ) : NEW_LINE INDENT temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT return ( ( m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ) ) NEW_LINE DEDENT
def countSquares ( m , n ) : NEW_LINE INDENT if ( n < m ) : NEW_LINE INDENT temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT return n * ( n + 1 ) * ( 3 * m - n + 1 ) // 6 NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT
def pairAndSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] & arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def computeTotient ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " Totient ▁ of ▁ " , i , " ▁ is ▁ " , phi [ i ] ) NEW_LINE DEDENT DEDENT
def isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE INDENT if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT x = 1 ; NEW_LINE y = 1 ; NEW_LINE circle_x = 0 ; NEW_LINE circle_y = 1 ; NEW_LINE rad = 2 ; NEW_LINE if ( isInside ( circle_x , circle_y , rad , x , y ) ) : NEW_LINE INDENT print ( " Inside " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) ; NEW_LINE DEDENT
def isFancy ( num ) : NEW_LINE INDENT fp = { } NEW_LINE fp [ '0' ] = '0' NEW_LINE fp [ '1' ] = '1' NEW_LINE fp [ '6' ] = '9' NEW_LINE fp [ '8' ] = '8' NEW_LINE fp [ '9' ] = '6' NEW_LINE n = len ( num ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( num [ l ] not in fp or fp [ num [ l ] ] != num [ r ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def sumBitDifferences ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans += ( count * ( n - count ) * 2 ) ; NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == n and n != 1 else False ) NEW_LINE DEDENT print ( " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000" ) NEW_LINE n = 2 NEW_LINE for n in range ( 10000 ) : NEW_LINE INDENT if isPerfect ( n ) : NEW_LINE INDENT print ( n , " ▁ is ▁ a ▁ perfect ▁ number " ) NEW_LINE DEDENT DEDENT
def isLucky ( n ) : NEW_LINE INDENT ar = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = math . floor ( n % 10 ) NEW_LINE if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar [ digit ] = 1 NEW_LINE n = n / 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT arr = [ 1291 , 897 , 4566 , 1232 , 80 , 700 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE if ( isLucky ( k ) ) : NEW_LINE INDENT print ( k , " ▁ is ▁ Lucky ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k , " ▁ is ▁ not ▁ Lucky ▁ " ) NEW_LINE DEDENT DEDENT
def mod ( num , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) ) % a NEW_LINE DEDENT return res NEW_LINE DEDENT
def nthMagicNo ( n ) : NEW_LINE INDENT pow = 1 NEW_LINE answer = 0 NEW_LINE while ( n ) : NEW_LINE INDENT pow = pow * 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT answer += pow NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE y = 0 NEW_LINE x = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = y NEW_LINE y = x - q * y NEW_LINE x = t NEW_LINE DEDENT if ( x < 0 ) : NEW_LINE INDENT x = x + m0 NEW_LINE DEDENT return x NEW_LINE DEDENT
def phi ( n ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if n % p == 0 : NEW_LINE INDENT while n % p == 0 : NEW_LINE INDENT n = n // p NEW_LINE DEDENT result = result * ( 1.0 - ( 1.0 / float ( p ) ) ) NEW_LINE DEDENT p = p + 1 NEW_LINE DEDENT if n > 1 : NEW_LINE INDENT result = result * ( 1.0 - ( 1.0 / float ( n ) ) ) NEW_LINE DEDENT return int ( result ) NEW_LINE DEDENT for n in range ( 1 , 11 ) : NEW_LINE INDENT print ( " phi ( " , n , " ) ▁ = ▁ " , phi ( n ) ) NEW_LINE DEDENT
def largestPower ( n , p ) : NEW_LINE INDENT x = 0 NEW_LINE while n : NEW_LINE INDENT n /= p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE DEDENT
def countOfMultiples ( n ) : NEW_LINE INDENT return ( int ( n / 3 ) + int ( n / 5 ) - int ( n / 15 ) ) ; NEW_LINE DEDENT
def getPeriod ( n ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 1 , n + 2 ) : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE DEDENT d = rem NEW_LINE count = 0 NEW_LINE rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE while rem != d : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT while ( num >= divisor ) : NEW_LINE INDENT num -= divisor ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE sum += 1.0 / fact NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
def Print ( n , k ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = " " ) NEW_LINE rem = ( 10 * rem ) % n NEW_LINE DEDENT DEDENT
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT print ( square , end = " ▁ " ) NEW_LINE DEDENT square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT
def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( f1 , end = " ▁ " ) NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT print ( f2 , end = " ▁ " ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT
def factorial ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def gcd ( a , b ) : ' NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def isMultipleof5 ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT n = n - 5 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT i = 19 NEW_LINE if ( isMultipleof5 ( i ) == 1 ) : NEW_LINE INDENT print ( i , " is ▁ multiple ▁ of ▁ 5" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , " is ▁ not ▁ a ▁ multiple ▁ of ▁ 5" ) NEW_LINE DEDENT
def isMultipleof5 ( n ) : NEW_LINE INDENT s = str ( n ) ; NEW_LINE l = len ( s ) ; NEW_LINE if ( s [ l - 1 ] == '5' or s [ l - 1 ] == '0' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 19 ; NEW_LINE if ( isMultipleof5 ( n ) == True ) : NEW_LINE INDENT print ( n , " is ▁ multiple ▁ of ▁ 5" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is ▁ not ▁ a ▁ multiple ▁ of ▁ 5" ) ; NEW_LINE DEDENT
def powerof2 ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT elif n % 2 != 0 or n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return powerof2 ( n / 2 ) NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def isPowerofTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( n & ( ~ ( n - 1 ) ) ) == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( isPowerofTwo ( 30 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerofTwo ( 128 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num / 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
def countSubsequences ( arr ) : NEW_LINE INDENT odd = 0 ; NEW_LINE even = 0 ; NEW_LINE for x in arr : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT DEDENT return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; NEW_LINE DEDENT
def XorSum ( A , B , N , M ) : NEW_LINE INDENT ans = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( ans == - 1 ) : NEW_LINE INDENT ans = ( A [ i ] & B [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans ^= ( A [ i ] & B [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def XorSum ( A , B , N , M ) : NEW_LINE INDENT ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans1 = ans1 ^ A [ i ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT ans2 = ans2 ^ B [ i ] NEW_LINE DEDENT return ( ans1 & ans2 ) NEW_LINE DEDENT
def getBit ( num , i ) : NEW_LINE INDENT return ( ( num & ( 1 << i ) ) != 0 ) NEW_LINE DEDENT
def clearBit ( num , i ) : NEW_LINE INDENT mask = ~ ( 1 << i ) NEW_LINE return num & mask NEW_LINE DEDENT
def countPairs ( arr , N , K ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cnt += mp [ K - arr [ i ] ] NEW_LINE mp [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT
def printORSumforEachElement ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT req_sum = 0 NEW_LINE for j in range ( 0 , N ) : NEW_LINE INDENT req_sum += ( arr [ i ] arr [ j ] ) NEW_LINE DEDENT print ( req_sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def constructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N ; NEW_LINE totalXOR = A [ 0 ] ^ K ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ i ] = totalXOR ^ A [ i ] ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def countPairs ( arr , k , size ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( size - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT x = arr [ i ] | arr [ j ] NEW_LINE if ( x == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def ConstructList ( Q ) : NEW_LINE INDENT xor = 0 NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( Q ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( Q [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT ans . append ( Q [ i ] [ 1 ] ^ xor ) NEW_LINE DEDENT else : NEW_LINE INDENT xor ^= Q [ i ] [ 1 ] NEW_LINE DEDENT DEDENT ans . append ( xor ) NEW_LINE ans . sort ( ) NEW_LINE return ans NEW_LINE DEDENT
def findMinXORSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return ; NEW_LINE DEDENT res_index = 0 ; NEW_LINE curr_xor = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_xor ^= arr [ i ] ; NEW_LINE DEDENT min_xor = curr_xor ; NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; NEW_LINE if ( curr_xor < min_xor ) : NEW_LINE INDENT min_xor = curr_xor ; NEW_LINE res_index = ( i - k + 1 ) ; NEW_LINE DEDENT DEDENT print ( min_xor ) ; NEW_LINE DEDENT
def maxAndXor ( arr , n ) : NEW_LINE INDENT ans = float ( ' inf ' ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans = min ( ans , arr [ i ] ^ arr [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def NoCarrySum ( N , M ) : NEW_LINE INDENT return N ^ M NEW_LINE DEDENT
def FlipBits ( n ) : NEW_LINE INDENT for bit in range ( 32 ) : NEW_LINE INDENT if ( ( n >> bit ) & 1 ) : NEW_LINE INDENT n = n ^ ( 1 << bit ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( " The ▁ number ▁ after ▁ unsetting ▁ the " , end = " ▁ " ) NEW_LINE print ( " rightmost ▁ set ▁ bit " , n ) NEW_LINE DEDENT
def FlipBits ( n ) : NEW_LINE INDENT n -= ( n & ( - n ) ) ; NEW_LINE return n ; NEW_LINE DEDENT
def constructXORArray ( A , n , K ) : NEW_LINE INDENT B = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT B [ i ] = A [ i ] ^ K ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT
def find_and ( arr ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT ans = ans & arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findNthNum ( N ) : NEW_LINE INDENT bit_L = 1 ; NEW_LINE last_num = 0 ; NEW_LINE while ( bit_L * ( bit_L + 1 ) / 2 < N ) : NEW_LINE INDENT last_num = last_num + bit_L ; NEW_LINE bit_L += 1 ; NEW_LINE DEDENT bit_R = N - last_num - 1 ; NEW_LINE print ( ( 1 << bit_L ) + ( 1 << bit_R ) ) ; NEW_LINE DEDENT
def xorOfArray ( arr , n ) : NEW_LINE INDENT xor_arr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xor_arr = xor_arr ^ arr [ i ] NEW_LINE DEDENT return xor_arr NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT if ( n ^ 1 == n + 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT
def bitwiseOrTillN ( n ) : NEW_LINE INDENT result = 2 ; NEW_LINE for i in range ( 4 , n + 1 , 2 ) : NEW_LINE INDENT result = result | i NEW_LINE DEDENT return result NEW_LINE DEDENT
def bitwiseOrTillN ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT bitCount = int ( log2 ( n ) ) + 1 ; NEW_LINE return pow ( 2 , bitCount ) - 2 ; NEW_LINE DEDENT
def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
def bitwiseAndOdd ( n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT
def genSequence ( n , val ) : NEW_LINE INDENT for i in range ( 1 << n ) : NEW_LINE INDENT x = i ^ ( i >> 1 ) ^ val ; NEW_LINE print ( x , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def minTrees ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def extraElement ( A , B , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans ^= A [ i ] ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans ^= B [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def findLen ( arr , n , m ) : NEW_LINE INDENT filter = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] & m ) == m ) : NEW_LINE INDENT filter . append ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( filter ) == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_and = filter [ 0 ] ; NEW_LINE for i in range ( 1 , len ( filter ) ) : NEW_LINE INDENT c_and &= filter [ i ] ; NEW_LINE DEDENT if ( c_and == m ) : NEW_LINE INDENT return len ( filter ) ; NEW_LINE DEDENT DEDENT
def findLen ( arr , n , m ) : NEW_LINE INDENT filter = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] m ) == m ) : NEW_LINE INDENT filter . append ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( filter ) == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_or = filter [ 0 ] ; NEW_LINE for i in range ( 1 , len ( filter ) ) : NEW_LINE INDENT c_or |= filter [ i ] ; NEW_LINE DEDENT if ( c_or == m ) : NEW_LINE INDENT return len ( filter ) ; NEW_LINE DEDENT DEDENT
def toggleBit ( n , k ) : NEW_LINE INDENT return ( n ^ ( 1 << ( k - 1 ) ) ) ; NEW_LINE DEDENT
def clearBit ( n , k ) : NEW_LINE INDENT return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) NEW_LINE DEDENT
def maximizeExpression ( a , b ) : NEW_LINE INDENT result = a NEW_LINE for bit in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT bitOfD = 1 << bit NEW_LINE x = b & bitOfD NEW_LINE if ( x == bitOfD ) : NEW_LINE INDENT y = result & bitOfD NEW_LINE if ( y == 0 ) : NEW_LINE INDENT result = result ^ bitOfD NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def cntElements ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def max_xor ( arr , n ) : NEW_LINE INDENT maxXor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxXor = max ( maxXor , \ arr [ i ] ^ arr [ j ] ) ; NEW_LINE DEDENT DEDENT return maxXor ; NEW_LINE DEDENT
def CountTriplets ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT first ^= arr [ j ] NEW_LINE if ( first == 0 ) : NEW_LINE INDENT ans += ( j - i ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT Len = 32 NEW_LINE number = 0 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > ( n // 2 ) ) : NEW_LINE INDENT number += ( 1 << i ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == number ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > ( n // 2 ) ) : NEW_LINE INDENT print ( number ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Majority ▁ Element ▁ Not ▁ Present " ) NEW_LINE DEDENT DEDENT
def countBits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a or b ) : NEW_LINE INDENT last_bit_a = a & 1 NEW_LINE last_bit_b = b & 1 NEW_LINE if ( last_bit_a != last_bit_b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def CountSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) ; NEW_LINE DEDENT DEDENT
def pairORSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] | arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def multiplyByFifteen ( n ) : NEW_LINE INDENT prod = ( n << 4 ) NEW_LINE prod = prod - n NEW_LINE return prod NEW_LINE DEDENT
def multiplyByFifteen ( n ) : NEW_LINE INDENT prod = ( n << 3 ) NEW_LINE prod += ( n << 2 ) NEW_LINE prod += ( n << 1 ) NEW_LINE prod += n NEW_LINE return prod NEW_LINE DEDENT
def CalculatePairs ( a , n ) : NEW_LINE INDENT cnt_zero = 0 NEW_LINE cnt_one = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 NEW_LINE DEDENT DEDENT total_XOR_pairs = cnt_zero * cnt_one NEW_LINE total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 NEW_LINE total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 NEW_LINE print ( " cntXOR ▁ = ▁ " , int ( total_XOR_pairs ) ) NEW_LINE print ( " cntAND ▁ = ▁ " , int ( total_AND_pairs ) ) NEW_LINE print ( " cntOR ▁ = ▁ " , int ( total_OR_pairs ) ) NEW_LINE DEDENT
def isDefeat ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( s1 [ i ] == '0' and s2 [ i ] == '1' ) or ( s1 [ i ] == '1' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( s1 [ i ] == '0' and s2 [ i ] == ' Z ' ) or ( s1 [ i ] == ' Z ' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s1 = "01001101ZZ " NEW_LINE s2 = "10Z1001000" NEW_LINE n = 10 NEW_LINE if ( isDefeat ( s1 , s2 , n ) ) : NEW_LINE INDENT print ( " Defeat " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Victory " ) NEW_LINE DEDENT
def FindIndexKthBit ( n , k ) : NEW_LINE INDENT cnt , ind = 0 , 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt == k : NEW_LINE INDENT return ind NEW_LINE DEDENT ind += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def minAND ( arr , n ) : NEW_LINE INDENT s = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s = s & arr [ i ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countX ( n ) : NEW_LINE INDENT binary = " { 0 : b } " . format ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( binary ) ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT answer = int ( pow ( 2 , count ) ) NEW_LINE return answer NEW_LINE DEDENT
def hasEqualBlockFrequency ( N ) : NEW_LINE INDENT S = bin ( N ) . replace ( "0b " , " " ) NEW_LINE p = set ( ) NEW_LINE c = 1 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT if ( S [ i ] == S [ i + 1 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p . add ( c ) NEW_LINE c = 1 NEW_LINE DEDENT p . add ( c ) NEW_LINE DEDENT if ( len ( p ) == 1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def binToDecimal3 ( n ) : NEW_LINE INDENT last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; NEW_LINE n = n >> 3 NEW_LINE while ( n > 7 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE DEDENT first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) NEW_LINE print ( first_3 , last_3 ) NEW_LINE DEDENT
def minDistance ( n1 , n2 ) : NEW_LINE INDENT bitCount1 = int ( log2 ( n1 ) ) + 1 NEW_LINE bitCount2 = int ( log2 ( n2 ) ) + 1 NEW_LINE bitDiff = abs ( bitCount1 - bitCount2 ) NEW_LINE maxBitCount = max ( bitCount1 , bitCount2 ) NEW_LINE if ( bitCount1 > bitCount2 ) : NEW_LINE INDENT n2 = int ( n2 * pow ( 2 , bitDiff ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 = int ( n1 * pow ( 2 , bitDiff ) ) NEW_LINE DEDENT xorValue = n1 ^ n2 NEW_LINE if xorValue == 0 : NEW_LINE INDENT bitCountXorValue = 1 NEW_LINE DEDENT else : NEW_LINE INDENT bitCountXorValue = int ( log2 ( xorValue ) ) + 1 NEW_LINE DEDENT disSimilarBitPosition = ( maxBitCount - bitCountXorValue ) NEW_LINE result = ( bitCount1 + bitCount2 - 2 * disSimilarBitPosition ) NEW_LINE return result NEW_LINE DEDENT
def printMaxAfterRemoval ( s ) : NEW_LINE INDENT flag = False NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if s [ i ] == '0' and flag == False : NEW_LINE INDENT flag = True NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def bitPos ( n1 , n2 ) : NEW_LINE INDENT if n1 == n2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT bitCount1 = floor ( log2 ( n1 ) ) + 1 NEW_LINE bitCount2 = floor ( log2 ( n2 ) ) + 1 NEW_LINE bitDiff = abs ( bitCount1 - bitCount2 ) NEW_LINE maxBitCount = max ( bitCount1 , bitCount2 ) NEW_LINE if ( bitCount1 > bitCount2 ) : NEW_LINE INDENT n2 *= pow ( 2 , bitDiff ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 *= pow ( 2 , bitDiff ) NEW_LINE DEDENT xorValue = n1 ^ n2 NEW_LINE bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 NEW_LINE disSimilarBitPosition = ( maxBitCount - bitCountXorValue + 1 ) NEW_LINE return disSimilarBitPosition NEW_LINE DEDENT
def countOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT evenPairCount = count * ( count - 1 ) / 2 NEW_LINE totPairs = N * ( N - 1 ) / 2 NEW_LINE return ( int ) ( totPairs - evenPairCount ) NEW_LINE DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT evenPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) : NEW_LINE INDENT evenPair += 1 NEW_LINE DEDENT DEDENT DEDENT return evenPair NEW_LINE DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT oddCount = count * ( count - 1 ) / 2 NEW_LINE return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount ) NEW_LINE DEDENT
def calculate ( X ) : NEW_LINE INDENT number_of_bits = 8 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ X NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( " After ▁ exchange " ) NEW_LINE print ( " x ▁ is " , x ) NEW_LINE DEDENT
def countZeros ( x ) : NEW_LINE INDENT total_bits = 32 NEW_LINE res = 0 NEW_LINE while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) : NEW_LINE INDENT x = ( x << 1 ) NEW_LINE res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def LeadingZeros ( x , y ) : NEW_LINE INDENT if ( ( x ^ y ) <= ( x & y ) ) : NEW_LINE INDENT print ( " Equal " ) NEW_LINE DEDENT elif ( ( x & ( ~ y ) ) > y ) : NEW_LINE INDENT print ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT
def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEW_LINE DEDENT
def solve ( A , B ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ different ▁ bits ▁ : " , count ) NEW_LINE DEDENT
def isSubsetAndZero ( array , length , N ) : NEW_LINE INDENT arrAnd = array [ 0 ] NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT arrAnd = arrAnd & array [ i ] NEW_LINE DEDENT if ( ( arrAnd & N ) == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def setRightmostUnsetBit ( n ) : NEW_LINE INDENT if n & ( n + 1 ) == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT return n | ( n + 1 ) NEW_LINE DEDENT
def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def AND ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans &= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def hammingDistance ( n1 , n2 ) : NEW_LINE INDENT x = n1 ^ n2 NEW_LINE setBits = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT setBits += x & 1 NEW_LINE x >>= 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT
def findParity ( x ) : NEW_LINE INDENT y = x ^ ( x >> 1 ) ; NEW_LINE y = y ^ ( y >> 2 ) ; NEW_LINE y = y ^ ( y >> 4 ) ; NEW_LINE y = y ^ ( y >> 8 ) ; NEW_LINE y = y ^ ( y >> 16 ) ; NEW_LINE if ( y & 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if ( findParity ( 9 ) == 0 ) : NEW_LINE INDENT print ( " Even ▁ Parity " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd Parity " ) ; NEW_LINE DEDENT if ( findParity ( 13 ) == 0 ) : NEW_LINE INDENT print ( " Even ▁ Parity " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd ▁ Parity " ) ; NEW_LINE DEDENT
def increment ( i ) : NEW_LINE INDENT i = - ( ~ i ) ; NEW_LINE return i ; NEW_LINE DEDENT
def increment ( i ) : NEW_LINE INDENT i = - ( ~ ord ( i ) ) ; NEW_LINE return chr ( i ) ; NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT
def xor_pair_sum ( ar , n ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total = total ^ ar [ i ] NEW_LINE DEDENT return 2 * total NEW_LINE DEDENT
def findEvenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( not ( A [ i ] & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( count - 1 ) // 2 NEW_LINE DEDENT
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return false NEW_LINE DEDENT n = 17 NEW_LINE l = 2 NEW_LINE r = 4 NEW_LINE if ( allBitsSetInTheGivenRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def checkSame ( n ) : NEW_LINE INDENT set , unset = 0 , 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n and 1 ) : NEW_LINE INDENT set + 1 NEW_LINE DEDENT else : NEW_LINE INDENT unset += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT if ( set == unset ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) NEW_LINE DEDENT n = 9 NEW_LINE if ( onlyFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getInteger ( L , R ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( L , R + 1 , 1 ) : NEW_LINE INDENT number += pow ( 2 , i ) NEW_LINE DEDENT return number NEW_LINE DEDENT
def setbitsfromLtoR ( L , R ) : NEW_LINE INDENT return ( ( 1 << ( R + 1 ) ) - ( 1 << L ) ) NEW_LINE DEDENT
def maxOR ( arr , n , k , x ) : NEW_LINE INDENT preSum = [ 0 ] * ( n + 1 ) NEW_LINE suffSum = [ 0 ] * ( n + 1 ) NEW_LINE pow = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT pow *= x NEW_LINE DEDENT preSum [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT preSum [ i + 1 ] = preSum [ i ] | arr [ i ] NEW_LINE DEDENT suffSum [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res = max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findXor ( arr , n ) : NEW_LINE INDENT xoR = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xoR = xoR ^ arr [ i ] NEW_LINE DEDENT return xoR * 2 NEW_LINE DEDENT
def turnOnK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n | ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
def printOdds ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT set_bit = res & ( ~ ( res - 1 ) ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & set_bit ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( x , y , end = " " ) NEW_LINE DEDENT
def findEletobeInserted ( A , n , k ) : NEW_LINE INDENT ans = k NEW_LINE for i in range ( n ) : NEW_LINE return ans NEW_LINE DEDENT
def printKthBit ( n , k ) : NEW_LINE INDENT print ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) NEW_LINE DEDENT
def andSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , BITS ) : NEW_LINE INDENT countSetBits = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT countSetBits = ( countSetBits + 1 ) NEW_LINE DEDENT DEDENT subset = ( ( 1 << countSetBits ) - 1 ) NEW_LINE subset = ( subset * ( 1 << i ) ) NEW_LINE ans = ans + subset NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def multiplyWith4 ( n ) : NEW_LINE INDENT return ( n << 2 ) NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT isEven = True ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if isEven == True : NEW_LINE INDENT isEven = False ; NEW_LINE DEDENT else : NEW_LINE INDENT isEven = True ; NEW_LINE DEDENT DEDENT return isEven ; NEW_LINE DEDENT n = 101 ; NEW_LINE if isEven ( n ) == True : NEW_LINE INDENT print ( " Even " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) ; NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( int ( n / 2 ) * 2 == n ) NEW_LINE DEDENT n = 101 NEW_LINE if ( isEven ( n ) != False ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT
def lastElement ( a , n ) : NEW_LINE INDENT steps = 1 NEW_LINE v = [ [ ] for i in range ( n ) ] NEW_LINE if n == 1 : return a [ 0 ] NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT v [ steps ] . append ( a [ i ] a [ i + 1 ] ) NEW_LINE DEDENT while len ( v [ steps ] ) > 1 : NEW_LINE INDENT steps += 1 NEW_LINE for i in range ( 0 , len ( v [ steps - 1 ] ) , 2 ) : NEW_LINE INDENT if steps & 1 : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] v [ steps - 1 ] [ i + 1 ] ) NEW_LINE v [ steps ] . append ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return v [ steps ] [ 0 ] NEW_LINE DEDENT
def findWinner ( A , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= A [ i ] NEW_LINE DEDENT if ( res == 0 or n % 2 == 0 ) : NEW_LINE INDENT return " Alice " NEW_LINE DEDENT else : NEW_LINE INDENT return " Bob " NEW_LINE DEDENT DEDENT
def printSubsets ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n & i ) == i ) : NEW_LINE INDENT print ( i , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def printSubsets ( n ) : NEW_LINE INDENT i = n NEW_LINE while ( i != 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE i = ( i - 1 ) & n NEW_LINE DEDENT print ( "0" ) NEW_LINE DEDENT
def isFibbinaryNum ( n ) : NEW_LINE INDENT if ( ( n & ( n >> 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 10 NEW_LINE if ( isFibbinaryNum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def maxXOR ( n , k ) : NEW_LINE INDENT c = int ( math . log ( n , 2 ) ) + 1 NEW_LINE return ( ( 1 << c ) - 1 ) NEW_LINE DEDENT
def divide ( dividend , divisor ) : NEW_LINE INDENT sign = ( - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 ) ; NEW_LINE dividend = abs ( dividend ) ; NEW_LINE divisor = abs ( divisor ) ; NEW_LINE quotient = 0 ; NEW_LINE temp = 0 ; NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( temp + ( divisor << i ) <= dividend ) : NEW_LINE INDENT temp += divisor << i ; NEW_LINE quotient |= 1 << i ; NEW_LINE DEDENT DEDENT if sign == - 1 : NEW_LINE quotient = - quotient ; NEW_LINE return quotient ; NEW_LINE DEDENT
def swapBitsInPair ( x ) : NEW_LINE INDENT return ( ( x & 0b10101010 ) >> 1 ) or ( ( x & 0b01010101 ) << 1 ) NEW_LINE DEDENT
def evenbitsetnumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE res = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( n res ) NEW_LINE DEDENT
def oddbitsetnumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE res = 0 NEW_LINE temp = n NEW_LINE while temp > 0 : NEW_LINE INDENT if count % 2 == 0 : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( n res ) NEW_LINE DEDENT
def toggleBits ( n1 , n2 ) : NEW_LINE INDENT return ( n1 ^ n2 ) NEW_LINE DEDENT
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT res = res | ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT
def setleftmostunsetbit ( n ) : NEW_LINE INDENT if not ( n & ( n + 1 ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT pos , temp , count = 0 , n , 0 NEW_LINE while temp : NEW_LINE INDENT if not ( temp & 1 ) : NEW_LINE INDENT pos = count NEW_LINE DEDENT count += 1 ; temp >>= 1 NEW_LINE DEDENT return ( n | ( 1 << ( pos ) ) ) NEW_LINE DEDENT
def maxXorSum ( n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT res = 1 NEW_LINE while res <= n : NEW_LINE INDENT res <<= 1 NEW_LINE DEDENT return res - 1 NEW_LINE DEDENT
def printNumHavingAltBitPatrn ( n ) : NEW_LINE INDENT curr_num = 1 NEW_LINE print ( curr_num ) NEW_LINE while ( 1 ) : NEW_LINE INDENT curr_num = curr_num << 1 ; NEW_LINE if ( n < curr_num ) : NEW_LINE INDENT break ; NEW_LINE DEDENT print ( curr_num ) NEW_LINE curr_num = ( ( curr_num ) << 1 ) ^ 1 ; NEW_LINE if ( n < curr_num ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( curr_num ) NEW_LINE DEDENT DEDENT
def MaximumSum ( a , b , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 |= a [ i ] NEW_LINE sum2 |= b [ i ] NEW_LINE DEDENT print ( sum1 + sum2 ) NEW_LINE DEDENT
def multiply ( x , n ) : NEW_LINE INDENT return x << n NEW_LINE DEDENT
def isDivBy2PowerM ( n , m ) : NEW_LINE INDENT if ( n & ( ( 1 << m ) - 1 ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 8 NEW_LINE m = 2 NEW_LINE if isDivBy2PowerM ( n , m ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findWinner ( N ) : NEW_LINE INDENT return N & 1 NEW_LINE DEDENT
def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if xs == 0 : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 ; count = 0 ; temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 0 ) : NEW_LINE INDENT res = res | ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT
def divide ( n , m ) : NEW_LINE INDENT print ( " Remainder ▁ = ▁ " , ( ( n ) & ( m - 1 ) ) ) NEW_LINE print ( " Quotient ▁ = ▁ " , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEW_LINE DEDENT
def perfectPowerOf2 ( n ) : NEW_LINE INDENT per_pow = 1 NEW_LINE while n > 0 : NEW_LINE INDENT per_pow = per_pow << 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return per_pow NEW_LINE DEDENT
def solve ( p , n ) : NEW_LINE INDENT G = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] % 2 != 0 ) : NEW_LINE INDENT G ^= ( p [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT G ^= ( p [ i ] - 1 ) NEW_LINE DEDENT DEDENT return G NEW_LINE DEDENT n = 3 NEW_LINE p = [ 32 , 49 , 58 ] NEW_LINE res = solve ( p , n ) NEW_LINE INDENT print ( " Player ▁ 2 ▁ wins " ) NEW_LINE print ( " Player ▁ 1 ▁ wins " ) NEW_LINE DEDENT
def isDivisibleby17 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 17 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 17 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) NEW_LINE DEDENT n = 35 NEW_LINE if ( isDivisibleby17 ( n ) ) : NEW_LINE INDENT print ( n , " is ▁ divisible ▁ by ▁ 17" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is ▁ not ▁ divisible ▁ by ▁ 17" ) NEW_LINE DEDENT
def answer ( n ) : NEW_LINE INDENT m = 2 ; NEW_LINE ans = 1 ; NEW_LINE r = 1 ; NEW_LINE while r < n : NEW_LINE INDENT r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) ; NEW_LINE if r < n : NEW_LINE INDENT ans = r ; NEW_LINE DEDENT m = m + 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = max ( res , arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def checking ( s ) : NEW_LINE INDENT c = 0 NEW_LINE n = len ( s ) NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c >= 6 and s [ i ] == '1' ) : NEW_LINE INDENT return True NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findUnique ( a , n , k ) : NEW_LINE INDENT INT_SIZE = 8 * sys . getsizeof ( int ) NEW_LINE count = [ 0 ] * INT_SIZE NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( a [ j ] & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT res += ( count [ i ] % k ) * ( 1 << i ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findUniquePair ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ unique ▁ pair ▁ is ▁ ( " , x , " , ▁ " , y , " ) " , sep = " " ) NEW_LINE DEDENT
def setallbitgivenrange ( n , l , r ) : NEW_LINE INDENT range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) NEW_LINE return ( n range ) NEW_LINE DEDENT
def countBits ( number ) : NEW_LINE INDENT return int ( ( math . log ( number ) / math . log ( 2 ) ) + 1 ) ; NEW_LINE DEDENT
def setBitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT msb = 0 ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = int ( n / 2 ) ; NEW_LINE msb += 1 ; NEW_LINE DEDENT return ( 1 << msb ) ; NEW_LINE DEDENT
def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT
def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) NEW_LINE return 1 << k NEW_LINE DEDENT
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
def toggle ( n ) : NEW_LINE INDENT temp = 1 NEW_LINE while ( temp <= n ) : NEW_LINE INDENT n = n ^ temp NEW_LINE temp = temp << 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
def checkPowerof8 ( n ) : NEW_LINE INDENT i = log ( n , 8 ) NEW_LINE return ( i - trunc ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 NEW_LINE if checkPowerof8 ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def adjacentSet ( n ) : NEW_LINE INDENT return ( n & ( n >> 1 ) ) NEW_LINE DEDENT
def posOfRightMostSameBit ( m , n ) : NEW_LINE INDENT loopCounter = 1 NEW_LINE while ( m > 0 or n > 0 ) : NEW_LINE INDENT a = m % 2 == 1 NEW_LINE b = n % 2 == 1 NEW_LINE if ( not ( a ^ b ) ) : NEW_LINE INDENT return loopCounter NEW_LINE DEDENT m = m >> 1 NEW_LINE n = n >> 1 NEW_LINE loopCounter += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( num == new_num ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
def printNonConsecutive ( n ) : NEW_LINE INDENT p = ( 1 << n ) NEW_LINE for i in range ( 1 , p ) : NEW_LINE INDENT if ( ( i & ( i << 1 ) ) == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def shuffle ( N , key ) : NEW_LINE INDENT NO_OF_BITS = N NEW_LINE reverse_num = 0 NEW_LINE for i in range ( NO_OF_BITS ) : NEW_LINE INDENT temp = ( key & ( 1 << i ) ) NEW_LINE if ( temp ) : NEW_LINE INDENT reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) NEW_LINE DEDENT DEDENT print ( reverse_num ) NEW_LINE DEDENT
def bitExtracted ( number , k , p ) : NEW_LINE INDENT return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; NEW_LINE DEDENT
def areSame ( a , b ) : NEW_LINE INDENT if ( not ( a - b ) ) : NEW_LINE INDENT print " Same " NEW_LINE DEDENT else : NEW_LINE INDENT print " Not ▁ Same " NEW_LINE DEDENT DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while ( ( 1 << i ) < n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT num = ( 1 << i ) + ( 1 << j ) NEW_LINE if ( num <= n ) : NEW_LINE INDENT sum += num NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findMax ( num ) : NEW_LINE INDENT num_copy = num NEW_LINE j = 4 * 8 - 1 ; NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i 1 << j ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT
def isAMultipleOf4 ( n ) : NEW_LINE INDENT if ( ( n & 3 ) == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
def posOfRightMostDiffBit ( m , n ) : NEW_LINE INDENT return floor ( log10 ( pow ( m ^ n , 2 ) ) ) + 2 NEW_LINE DEDENT
def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return " Yes " NEW_LINE DEDENT
def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << k ) n ) NEW_LINE DEDENT
def missingNumber ( arr1 , arr2 , n ) : NEW_LINE INDENT mnum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mnum = mnum ^ arr1 [ i ] NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT mnum = mnum ^ arr2 [ i ] NEW_LINE DEDENT return mnum NEW_LINE DEDENT
def toggleKthBit ( n , k ) : NEW_LINE INDENT return ( n ^ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
def countValues ( x ) : NEW_LINE INDENT count = 0 ; NEW_LINE n = 1 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT count += n ; NEW_LINE DEDENT n *= 2 ; NEW_LINE x /= 2 ; NEW_LINE x = int ( x ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
def constructXOR ( A , n ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT XOR ^= A [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT A [ i ] = XOR ^ A [ i ] NEW_LINE DEDENT DEDENT A = [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE n = len ( A ) NEW_LINE constructXOR ( A , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def countTrailingZero ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( ( x & 1 ) == 0 ) : NEW_LINE INDENT x = x >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countTrailingZero ( x ) : NEW_LINE INDENT lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] NEW_LINE return lookup [ ( - x & x ) % 37 ] NEW_LINE DEDENT
def totalFlips ( A , B , C , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] == B [ i ] and C [ i ] == '1' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT elif A [ i ] != B [ i ] and C [ i ] == '0' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT count += pow ( 2 , k ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def multiply ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE while ( m ) : NEW_LINE INDENT if ( m % 2 == 1 ) : NEW_LINE INDENT ans += n << count NEW_LINE DEDENT count += 1 NEW_LINE m = int ( m / 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def EqualNumber ( A , B ) : NEW_LINE INDENT return ( A ^ B ) NEW_LINE DEDENT
def areSetBitsIncreasing ( n ) : NEW_LINE INDENT prev_count = sys . maxsize NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( n > 0 and n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT curr_count = 1 NEW_LINE while ( n > 0 and n % 2 == 1 ) : NEW_LINE INDENT n = n / 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if ( curr_count >= prev_count ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_count = curr_count NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if ( areSetBitsIncreasing ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findPattern ( n ) : NEW_LINE INDENT prev = n % 2 NEW_LINE n = n // 2 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT curr = n % 2 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def countXOR ( n ) : NEW_LINE INDENT count0 , count1 = 0 , 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT return ( count0 ^ count1 ) NEW_LINE DEDENT
def xorPairCount ( arr , n , x ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x ^ arr [ i ] in s ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def xorPairCount ( arr , n , x ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = x ^ arr [ i ] NEW_LINE if ( curr_xor in m . keys ( ) ) : NEW_LINE INDENT result += m [ curr_xor ] NEW_LINE DEDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def isMultipleOf4 ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT XOR = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT XOR = XOR ^ i NEW_LINE DEDENT return ( XOR == n ) NEW_LINE DEDENT for n in range ( 0 , 43 ) : NEW_LINE INDENT if ( isMultipleOf4 ( n ) ) : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def multiplyTen ( n ) : NEW_LINE INDENT return ( n << 1 ) + ( n << 3 ) NEW_LINE DEDENT
def countValues ( n ) : NEW_LINE INDENT countV = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n + i ) == ( n ^ i ) ) : NEW_LINE INDENT countV += 1 ; NEW_LINE DEDENT DEDENT return countV ; NEW_LINE DEDENT
def countValues ( n ) : NEW_LINE INDENT unset_bits = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if n & 1 == 0 : NEW_LINE INDENT unset_bits += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return 1 << unset_bits NEW_LINE DEDENT
def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def swapThree ( a , b , c ) : NEW_LINE INDENT a [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE b [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE c [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE a [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE DEDENT
def findProffesion ( level , pos ) : NEW_LINE INDENT if ( level == 1 ) : NEW_LINE INDENT return ' e ' NEW_LINE DEDENT if ( findProffesion ( level - 1 , ( pos + 1 ) // 2 ) == ' d ' ) : NEW_LINE INDENT if ( pos % 2 ) : NEW_LINE INDENT return ' d ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' e ' NEW_LINE DEDENT DEDENT if ( pos % 2 ) : NEW_LINE INDENT return ' e ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' d ' NEW_LINE DEDENT DEDENT
def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( 1 << x ) + ( 1 << y ) , end = " ▁ " ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] NEW_LINE DEDENT
def findXOR ( Set , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return Set [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def myXOR ( x , y ) : NEW_LINE INDENT for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT b1 = x & ( 1 << i ) NEW_LINE b2 = y & ( 1 << i ) NEW_LINE b1 = min ( b1 , 1 ) NEW_LINE b2 = min ( b2 , 1 ) NEW_LINE xoredBit = 0 NEW_LINE if ( b1 & b2 ) : NEW_LINE INDENT xoredBit = 0 NEW_LINE DEDENT else : NEW_LINE INDENT xoredBit = ( b1 b2 ) NEW_LINE DEDENT res <<= 1 ; NEW_LINE res |= xoredBit NEW_LINE DEDENT return res NEW_LINE DEDENT
def myXOR ( x , y ) : NEW_LINE INDENT return ( ( x y ) & ( ~ x ~ y ) ) NEW_LINE DEDENT
def myXOR ( x , y ) : NEW_LINE INDENT return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) NEW_LINE DEDENT
def swapBits ( n , p1 , p2 ) : NEW_LINE INDENT bit1 = ( n >> p1 ) & 1 NEW_LINE bit2 = ( n >> p2 ) & 1 NEW_LINE x = ( bit1 ^ bit2 ) NEW_LINE x = ( x << p1 ) | ( x << p2 ) NEW_LINE result = n ^ x NEW_LINE return result NEW_LINE DEDENT
def swapBits ( n , p1 , p2 ) : NEW_LINE INDENT n ^= 1 << p1 NEW_LINE n ^= 1 << p2 NEW_LINE return n NEW_LINE DEDENT
def multiplyBySevenByEight ( n ) : NEW_LINE INDENT return ( n - ( n >> 3 ) ) NEW_LINE DEDENT
def subtract ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT borrow = ( ~ x ) & y NEW_LINE x = x ^ y NEW_LINE y = borrow << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def subtract ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT return subtract ( x ^ y , ( ~ x & y ) << 1 ) NEW_LINE DEDENT
def square ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT res = n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res += n NEW_LINE DEDENT return res NEW_LINE DEDENT for n in range ( 1 , 6 ) : NEW_LINE INDENT print ( " n ▁ = " , n , end = " , ▁ " ) NEW_LINE print ( " n ^ 2 ▁ = " , square ( n ) ) NEW_LINE DEDENT
def temp_convert ( F1 , B1 , F2 , B2 , T ) : NEW_LINE INDENT t2 = F2 + ( ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ) NEW_LINE return t2 NEW_LINE DEDENT
def Divisible ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT return count_even + ( n - count_even ) // 2 NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
def maxLength ( arr , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE i = 0 NEW_LINE j = i + 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ j ] ) : NEW_LINE INDENT maxLen = max ( maxLen , 2 ) NEW_LINE l = i - 1 NEW_LINE r = j + 1 NEW_LINE while ( l >= 0 and r < n and arr [ l ] == arr [ i ] and arr [ r ] == arr [ j ] ) : NEW_LINE INDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT maxLen = max ( maxLen , 2 * ( r - j ) ) NEW_LINE DEDENT i += 1 NEW_LINE j = i + 1 NEW_LINE DEDENT return maxLen NEW_LINE DEDENT
def maxLength ( a , n ) : NEW_LINE INDENT maxLen = 0 ; NEW_LINE prev_cnt = 0 ; curr_cnt = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] == a [ i - 1 ] ) : NEW_LINE INDENT curr_cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT prev_cnt = curr_cnt ; NEW_LINE curr_cnt = 1 ; NEW_LINE DEDENT maxLen = max ( maxLen , min ( prev_cnt , curr_cnt ) ) ; NEW_LINE DEDENT return ( 2 * maxLen ) ; NEW_LINE DEDENT
