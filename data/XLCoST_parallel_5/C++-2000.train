bool checkPowerof8 ( int n ) { double i = log ( n ) / log ( 8 ) ; return ( i - trunc ( i ) < 0.000001 ) ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
void sumFib ( int N ) { long num = ( long ) round ( pow ( ( sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / sqrt ( 5 ) ) ; cout << ( num - 1 ) ; }
void findEquation ( int a , int b ) { int sum = ( a + b ) ; int product = ( a * b ) ; cout << " x ^ 2 ▁ - ▁ ( " << sum << " x ) ▁ + ▁ ( " << product << " ) ▁ = ▁ 0" ; }
int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
int maxPeople ( int p ) { int tmp = 0 , count = 0 ; for ( int i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
int maxDistance ( int arr [ ] , int n ) { unordered_map < int , int > mp ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ i ] ] = i ; else max_dist = max ( max_dist , i - mp [ arr [ i ] ] ) ; } return max_dist ; }
int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
int PositionRightmostSetbit ( int n ) { int p = 1 ; while ( n > 0 ) { if ( n & 1 ) { return p ; } p ++ ; n = n >> 1 ; } return -1 ; }
int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
int sumofsquare ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
int maxEvenIntegers ( int arr [ ] , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = max ( ans , cnt ) ; } return ans ; }
void poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { cout << ceil ( log ( buckets ) / log ( ( minutesToTest / minutesToDie ) + 1 ) ) ; }
int find ( vector < int > arr , int N ) { int Sum = 0 ; for ( auto i : arr ) Sum += i ; if ( Sum % N ) return -1 ; int k = Sum / N ; int ans = 0 ; int i = 0 ; while ( i < N ) { ans = ans + abs ( k - arr [ i ] ) ; i += 1 ; } return ans / 2 ; }
int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { cout << " The ▁ shortest ▁ distance ▁ " << " between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " << sqrt ( ( pow ( ( x2 - x1 ) , 2 ) ) + ( pow ( ( y2 - y1 ) , 2 ) ) ) - r << endl ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
void checkSolution ( int a , int b , int c ) { if ( a == c ) cout << " Yes " ; else cout << " No " ; }
bool areVowelsInOrder ( string s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }
void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) cout << " odd " << endl ; else cout << " even " << endl ; }
int countways ( long long n ) { long long A [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
int largestNum ( int a , int b ) { return a * ( bool ) ( a / b ) + b * ( bool ) ( b / a ) ; }
int MaxRearrngeSum ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N , greater < int > ( ) ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxSum += abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
long product ( vector < vector < int > > & mat , int n ) { long long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1LL * d1 * d2 ; }
void checkVantieghemsTheorem ( int limit ) { long long unsigned prod = 1 ; for ( long long unsigned n = 2 ; n < limit ; n ++ ) { if ( ( ( prod - n ) % ( ( 1LL << n ) - 1 ) ) == 0 ) cout << n << " ▁ is ▁ prime STRNEWLINE " ; prod *= ( ( 1LL << n ) - 1 ) ; } }
int findMean ( int arr [ ] , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = floor ( sum / count ) ; return mean ; }
int countSubset ( int arr [ ] , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int t [ n + 1 ] [ sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; }
int fun ( unsigned int n ) { return n & ( n - 1 ) ; }
int hIndex ( vector < int > citations , int n ) { int hindex = 0 ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } cout << hindex << endl ; return hindex ; }
void allCharactersSame ( string s ) { set < char > s1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) s1 . insert ( s [ i ] ) ; if ( s1 . size ( ) == 1 ) cout << " YES " ; else cout << " NO " ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int no_of_ways ( int a [ ] , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
void countTotalFrequencies ( string S1 , string S2 ) { set < char > bset ; for ( auto x : S1 ) bset . insert ( x ) ; int count = 0 ; for ( auto x : S2 ) { if ( bset . find ( x ) != bset . end ( ) ) count += 1 ; } cout << count << endl ; }
bool checkIsFibonacci ( int arr [ ] , int n ) { if ( n == 1 n == 2 ) return true ; sort ( arr , arr + n ) ; for ( int i = 2 ; i < n ; i ++ ) if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; return true ; }
long numbers ( int n ) { return ( long long ) ( pow ( 2 , n + 1 ) ) - 2 ; }
int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = max ( a , max ( b , c ) ) ; int smallest = min ( a , min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } }
int findSmallestNumK ( int n ) { int cummAnd = n ; int i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return -1 ; }
bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
bool isEven ( int n ) { if ( n ^ 1 == n + 1 ) return true ; else return false ; }
int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int term ( int n ) { return n * ( n + 1 ) / 2 ; }
void check ( int n , int m ) { if ( n == 2 m == 2 n % m == 0 ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } }
int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
int EqualNumbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; }
void minimumTime ( int * arr , int n ) { int sum = 0 ; int T = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } cout << max ( 2 * T , sum ) ; }
bool findWinner ( int x , int y , int n ) { int dp [ n + 1 ] ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 and ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 and ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 and ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
bool isConvertible ( string str1 , string str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
void printMissingElements ( int arr [ ] , int N ) { int diff = arr [ 0 ] - 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { cout << i + diff << " ▁ " ; diff ++ ; } } } }
int countNums ( int n , int x , int y ) { vector < bool > arr ( n + 1 , false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
void odd_even ( int arr [ ] , int n ) { vector < int > odd_indexes ; vector < int > even_indexes ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . push_back ( arr [ i ] ) ; else even_indexes . push_back ( arr [ i ] ) ; } sort ( odd_indexes . begin ( ) , odd_indexes . end ( ) ) ; sort ( even_indexes . begin ( ) , even_indexes . end ( ) ) ; for ( int i = 0 ; i < odd_indexes . size ( ) ; i ++ ) cout << odd_indexes [ i ] << " ▁ " ; for ( int i = 0 ; i < even_indexes . size ( ) ; i ++ ) cout << even_indexes [ i ] << " ▁ " ; }
float Area ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }
void possibleNumbers ( set < int > & numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . insert ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; }
int clearLastBit ( int N , int K ) { int mask = ( -1 << K + 1 ) ; return N = N & mask ; }
void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( n ) { int r = n % 10 ; largest = max ( r , largest ) ; smallest = min ( r , smallest ) ; n = n / 10 ; } cout << largest << " ▁ " << smallest ; }
int smallest ( string s ) { vector < int > a ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) a [ i ] = s [ i ] - '0' ; vector < int > b ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( ( a [ i ] ) % 2 != 0 ) b . push_back ( a [ i ] ) ; } sort ( b . begin ( ) , b . end ( ) ) ; if ( b . size ( ) > 1 ) return ( b [ 0 ] ) * 10 + ( b [ 1 ] ) ; return -1 ; }
int rankLessThanK ( int * arr , int k , int n ) { int rank = 1 ; int position = 1 ; sort ( arr , arr + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
bool search ( int arr [ ] , int n , int x ) { int res = -1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == -1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
void printDuplicates ( int arr [ ] , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { cout << arr [ i ] % n << " ▁ " ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) cout << " - 1" ; }
void linearCongruentialMethod ( int Xo , int m , int a , int c , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } }
int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } cout << " Sum ▁ = ▁ " << sum ; cout << " Product = " }
int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
int binarySearch ( string arr [ ] , string x , int n ) { int l = 0 ; int r = n - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( x == ( arr [ m ] ) ) res = 0 ; if ( res == 0 ) return m ; if ( x > ( arr [ m ] ) ) l = m + 1 ; else r = m - 1 ; } return -1 ; }
int findKCF ( int x , int y , int k ) { int small = min ( x , y ) ; int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return -1 ; }
int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return pow ( 2 , E - 1 ) ; }
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != -1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
void contain ( int L , int U , int M ) { int count = 0 ; for ( int j = L ; j < U ; j ++ ) { set < string > num ; string str = to_string ( j ) ; num . insert ( str ) ; if ( j % M == 0 and num . find ( to_string ( M ) ) == num . end ( ) ) { count += 1 ; } } cout << count - 2 ; }
LLI totalTriangles ( LLI h , LLI v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; LLI Total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return Total ; }
int getM ( int n ) { if ( n == 1 ) return -1 ; else return n - 2 ; }
int countStrings ( int n , int m , string s [ ] ) { unordered_set < int > ind ; for ( int j = 0 ; j < m ; j ++ ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = max ( mx , ( int ) s [ i ] [ j ] - '0' ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] - '0' == mx ) ind . insert ( i ) ; } return ind . size ( ) ; }
bool isPowerOfK ( unsigned int n , unsigned int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
void completeSuquence ( string s ) { int n = s . length ( ) ; int open = 0 , close = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) open ++ ; else close ++ ; if ( close > open ) { cout << " Impossible " << endl ; return ; } } cout << s ; for ( int i = 0 ; i < open - close ; i ++ ) cout << ' ) ' ; cout << endl ; }
long countRhombi ( int h , int w ) { long long ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
int center_hexadecagonal_num ( long int n ) { return 8 * n * n - 8 * n + 1 ; }
void prevGreater ( int arr [ ] , int n ) { cout << " - 1 , ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { cout << arr [ j ] << " , ▁ " ; break ; } } if ( j == -1 ) cout << " - 1 , ▁ " ; } }
void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) cout << i << " ▁ " ; }
double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
float harmonicMean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }
void findNthTerm ( int n ) { cout << pow ( 2 , n ) - 2 * n << endl ; }
int minOperation ( int N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } int k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ; t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
int findCountOfSolutions ( int n , int p ) { ll ans = 0 ; for ( ll x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { ll last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
int perfectPowerOf2 ( unsigned int n ) { unsigned int per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
bool isSumEqual ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = 0 ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
void cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; cout << cosx ; }
void findPoint ( int n , int h ) { for ( int i = 1 ; i < n ; i ++ ) printf ( " % .2f ▁ " , sqrt ( i / ( n * 1.0 ) ) * h ) ; }
int find ( int index , int openbrk , int n , int adj [ ] [ 2 ] ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != -1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
int countSubarrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { ll product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
void canMakeEqual ( string S ) { int N = S . size ( ) ; int weightOfString = 0 ; for ( int i = 0 ; i < N ; i ++ ) { weightOfString += S [ i ] - ' a ' + 1 ; } if ( weightOfString % N == 0 ) cout << " Yes " ; else cout << " No " ; }
int minSumDifference ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; int rem = sum % n ; return rem * ( n - rem ) ; }
int singleNumber ( int nums [ ] , int n ) { map < int , int > m ; long sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( m [ nums [ i ] ] == 0 ) { sum1 += nums [ i ] ; m [ nums [ i ] ] ++ ; } sum2 += nums [ i ] ; } return 2 * ( sum1 ) - sum2 ; }
int areaSquare ( int L , int B ) { int large = max ( L , B ) ; int small = min ( L , B ) ; if ( large >= 2 * small ) return large * large ; else return ( 2 * small ) * ( 2 * small ) ; }
int LIS ( int a [ ] , int n ) { int dp [ N ] , d [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
int findMinDiff ( int arr [ ] , int n ) { int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] ) ; return diff ; }
bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
unsigned countOfMultiples ( unsigned n ) { return ( n / 3 + n / 5 - n / 15 ) ; }
int minSteps ( string str , int n , int k ) { if ( str [ n - 1 ] == '0' ) return -1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; int dp [ n ] ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( int i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) continue ; int steps = INT_MAX ; if ( i + k < n && str [ i + k ] == '1' ) steps = min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == '1' ) steps = min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == '1' ) steps = min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == INT_MAX ) ? steps : 1 + steps ; } if ( dp [ 0 ] == INT_MAX ) return -1 ; return dp [ 0 ] ; }
int totalSubSets ( ll n , ll l , ll r ) { ll zero = floor ( ( double ) r / 3 ) - ceil ( ( double ) l / 3 ) + 1 ; ll one = floor ( ( double ) ( r - 1 ) / 3 ) - ceil ( ( double ) ( l - 1 ) / 3 ) + 1 ; ll two = floor ( ( double ) ( r - 2 ) / 3 ) - ceil ( ( double ) ( l - 2 ) / 3 ) + 1 ; ll dp [ n ] [ 3 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( ll i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
int matrixSum ( int arr [ ] [ n ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
bool isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
string compute ( string str , int n ) { string reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " ; int l = str . length ( ) ; for ( int i = n ; i < l ; i ++ ) str [ i ] = reverseAlphabet [ str [ i ] - ' a ' ] ; return str ; }
int CountTriplets ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int first = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
int cntSubsets ( int * arr , int n ) { int a [ n ] , b [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } int result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
int findOddPair ( int A [ ] , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
int minimumAdjacentDifference ( vector < int > a , int n , int k ) { int minDiff = INT_MAX ; for ( int i = 0 ; i <= k ; i ++ ) { int maxDiff = INT_MIN ; for ( int j = 0 ; j < n - k - 1 ; j ++ ) { for ( int p = i ; p <= i + j ; p ++ ) { maxDiff = max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; } } minDiff = min ( minDiff , maxDiff ) ; } return minDiff ; }
int divisible ( string num ) { int n = num . length ( ) ; int sum = accumulate ( begin ( num ) , end ( num ) , 0 ) - '0' * 1 ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return -1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ; if ( n == 2 ) return -1 ; return 2 ; }
int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { cout << i << " ▁ " << j << " ▁ " << k ; return ; } } } } } } }
int MinOperation ( int a [ ] , int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result = result + abs ( a [ i ] - b [ i ] ) ; } return result ; }
int ceilDifference ( int arr [ ] , int n , int x ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += ceil ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int totalCeilSum = ceil ( ( double ) ( totalSum ) / ( double ) ( x ) ) ; return abs ( perElementSum - totalCeilSum ) ; }
void checkArrangement ( int A1 [ ] , int A2 [ ] , int n , int k ) { sort ( A1 , A1 + n ) ; sort ( A2 , A2 + n , greater < int > ( ) ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) cout << " No " ; else cout << " Yes " ; }
int findEletobeInserted ( int A [ ] , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) return ans ; }
int deleteElement ( int A [ ] , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
void compareVal ( int x , int y ) { long double a = y * log ( x ) ; long double b = x * log ( y ) ; if ( a > b ) cout << x << " ^ " << y << " ▁ > ▁ " << y << " ^ " << x ; else if ( a < b ) cout << x << " ^ " << y << " ▁ < ▁ " << y << " ^ " << x ; else if ( a == b ) cout << x << " ^ " << y << " ▁ = ▁ " << y << " ^ " << x ; }
int countStrings ( int n ) { int a [ n ] , b [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
void countSubstring ( string s ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int x = 0 ; for ( int j = i ; j < s . length ( ) ; j ++ ) { int temp = 1 << s [ j ] - ' a ' ; x ^= temp ; if ( ( x & ( x - 1 ) ) == 0 ) res ++ ; } } cout << res ; }
int noOfTriangles ( int n ) { return floor ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
void findAandB ( int N ) { int K = log2 ( N ) ; int B = ( 1 << K ) ; int A = B ^ N ; cout << A << ' ▁ ' << B ; }
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
int minServerLoads ( int n , vector < int > & servers ) { int totalLoad = 0 ; for ( int i : servers ) totalLoad += i ; int requiredLoad = totalLoad / 2 ; vector < vector < int > > dp ( n + 1 , vector < int > ( requiredLoad + 1 , 0 ) ) ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n ] [ requiredLoad ] ; }
void minimumOperations ( int arr [ ] , int N ) { int mx = 0 , pos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } cout << ( mx - 1 ) * N + pos + 1 ; }
int day_of_the_week ( int y , int m , int d ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ) ; }
long countPairsBruteForce ( long long X [ ] , long long Y [ ] , long long m , long long n ) { long long ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( pow ( X [ i ] , Y [ j ] ) > pow ( Y [ j ] , X [ i ] ) ) ans ++ ; return ans ; }
bool sumSquare ( int n ) { for ( long i = 1 ; i * i <= n ; i ++ ) for ( long j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { cout << i << " ^ 2 ▁ + ▁ " << j << " ^ 2" << endl ; return true ; } return false ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
int term ( int n ) { int x = ( ( ( 1 ) + ( double ) sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
int findCnt ( string & s , int i , int r ) { if ( i == s . size ( ) ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i ] [ r ] ; }
int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; }
void insertNames ( string arr [ ] , int n ) { unordered_set < string > set ; for ( int i = 0 ; i < n ; i ++ ) { if ( set . find ( arr [ i ] ) == set . end ( ) ) { cout << " No STRNEWLINE " ; set . insert ( arr [ i ] ) ; } else { cout << " Yes STRNEWLINE " ; } } }
void solve ( int a [ ] , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos ) a [ ind ++ ] = 2 ; bool evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; }
int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
int countStrings ( string s ) { int cnt = 0 ; for ( int i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
bool isReversible ( string str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
void longestAlternating ( int arr [ ] , int n ) { int count [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count [ i ] << " ▁ " ; }
void constructArray ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << i << " ▁ " ; } }
int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
char findExtraCharcter ( string strA , string strB ) { unordered_map < char , int > m1 ; for ( int i = 0 ; i < strB . length ( ) ; i ++ ) m1 [ strB [ i ] ] ++ ; for ( int i = 0 ; i < strA . length ( ) ; i ++ ) m1 [ strA [ i ] ] -- ; for ( auto h1 = m1 . begin ( ) ; h1 != m1 . end ( ) ; h1 ++ ) { if ( h1 -> second == 1 ) return h1 -> first ; } }
void generatepermutation ( int N ) { vector < int > answer ; answer . push_back ( N ) ; for ( int i = 1 ; i < N ; i ++ ) { answer . push_back ( i ) ; } for ( int i : answer ) cout << i << " ▁ " ; }
void EditDistDP ( string str1 , string str2 ) { int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; int DP [ 2 ] [ len1 + 1 ] ; memset ( DP , 0 , sizeof DP ) ; for ( int i = 0 ; i <= len1 ; i ++ ) DP [ 0 ] [ i ] = i ; for ( int i = 1 ; i <= len2 ; i ++ ) { for ( int j = 0 ; j <= len1 ; j ++ ) { if ( j == 0 ) DP [ i % 2 ] [ j ] = i ; else if ( str1 [ j - 1 ] == str2 [ i - 1 ] ) { DP [ i % 2 ] [ j ] = DP [ ( i - 1 ) % 2 ] [ j - 1 ] ; } else { DP [ i % 2 ] [ j ] = 1 + min ( DP [ ( i - 1 ) % 2 ] [ j ] , min ( DP [ i % 2 ] [ j - 1 ] , DP [ ( i - 1 ) % 2 ] [ j - 1 ] ) ) ; } } } cout << DP [ len2 % 2 ] [ len1 ] << endl ; }
int printPairs ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << endl ; }
int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
int largest ( int arr [ ] , int n ) { return * max_element ( arr , arr + n ) ; }
bool pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
int centeredDodecagonal ( long int n ) { return 6 * n * ( n - 1 ) + 1 ; }
void printString ( string str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; bool used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = 1 ; for ( int j = 0 ; j < ones ; j ++ ) cout << "1" ; } if ( str [ i ] != '1' ) cout << str [ i ] ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) cout << "1" ; }
int countTriangles ( int a [ ] , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; }
int mod ( string num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; }
bool isKPartitionPossible ( int arr [ ] , int N , int K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; int target = sum / K ; int dp [ ( 1 << 15 ) ] ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = -1 ; dp [ 0 ] = 0 ; for ( int mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == -1 ) continue ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! ( mask & ( 1 << i ) ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; }
void maxSum ( int a [ ] , int n ) { int maxAnd = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxAnd = max ( maxAnd , a [ i ] ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR = maxOR | a [ i ] ; } cout << maxAnd + maxOR ; }
int deleteElement ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; int prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { int curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
bool isNumber ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ; return true ; }
string check ( int current_row , int current_col , int destination_row , int destination_col ) { if ( current_row == destination_row ) return " POSSIBLE " ; else if ( current_col == destination_col ) return " POSSIBLE " ; else return " NOT ▁ POSSIBLE " ; }
void minimumOperations ( int arr [ ] , int N ) { int oddCnt = 0 , evenCnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } cout << min ( oddCnt , evenCnt ) ; }
void highestPowerOfTwo ( int num ) { string s = to_string ( num ) ; for ( int i = 0 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == '0' ) { cout << "0" ; continue ; } int lg = log2 ( int ( s [ i ] ) - 48 ) ; int p = pow ( 2 , lg ) ; cout << char ( p + 48 ) ; } }
int countPairs ( int arr [ ] , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } int ans = ( N - odd + odd / 2 - 1 ) + odd / 2 ; return ans ; }
double minAnglRot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; }
bool pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
string isAnBn ( string str ) { int n = str . length ( ) ; if ( n & 1 ) return " No " ; int i ; for ( i = 0 ; i < n / 2 ; i ++ ) if ( str [ i ] != ' a ' str [ n - i - 1 ] != ' b ' ) return " No " ; return " Yes " ; }
int reduceZero ( int N ) { vector < int > dp ( N + 1 , 1e9 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( char c : to_string ( i ) ) { dp [ i ] = min ( dp [ i ] , dp [ i - ( c - '0' ) ] + 1 ) ; } } return dp [ N ] ; }
void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; cout << res ; }
float angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; float den = sqrt ( pow ( ( x2 - x1 ) , 2 ) + pow ( ( y2 - y1 ) , 2 ) + pow ( ( z2 - z1 ) , 2 ) ) * sqrt ( pow ( ( x3 - x1 ) , 2 ) + pow ( ( y3 - y1 ) , 2 ) + pow ( ( z3 - z1 ) , 2 ) ) ; float angle = acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
bool areChractersUnique ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
int absSumDidd ( int a [ ] , int n ) { sort ( a , a + n ) ; int midValue = a [ ( int ) ( n / 2 ) ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + abs ( a [ i ] - midValue ) ; } return sum ; }
int possibleTriplets ( int arr [ ] , int N ) { int freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( freq * 1LL * ( freq - 1 ) * ( freq - 2 ) ) / 6 ; }
void checkSolveable ( int n , int m ) { if ( n == 1 or m == 1 ) cout << " YES " ; else if ( m == 2 and n == 2 ) cout << " YES " ; else cout << " NO " ; }
int lastRemaining ( int n , map < int , int > & dp ) { if ( dp . find ( n ) != dp . end ( ) ) return dp [ n ] ; if ( n == 1 ) return 1 ; else dp [ n ] = 2 * ( 1 + n / 2 - lastRemaining ( n / 2 , dp ) ) ; return dp [ n ] ; }
int findSteps ( int n , int m , int a [ ] ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
void checksum ( int n ) { if ( n % 3 == 0 ) cout << n / 3 - 1 << " ▁ " << n / 3 << " ▁ " << n / 3 + 1 ; else cout << " - 1" ; }
void minOpsToEmptyString ( string S , int N ) { int one = 0 , zero = 0 ; int x0 = 0 , x1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '0' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = max ( x0 , zero ) ; one = max ( x1 , one ) ; } cout << max ( one , zero ) << endl ; }
int smallestOdd ( int n ) { if ( n == 1 ) return 1 ; return pow ( 10 , n - 1 ) + 1 ; }
string largestSubStr ( string s ) { while ( s . size ( ) and s [ s . size ( ) - 1 ] == '1' ) s . pop_back ( ) ; if ( s . size ( ) == 0 ) return " - 1" ; else return s ; }
float areacircumscribed ( float a ) { return ( a * a * ( PI / 2 ) ) ; }
int minimumLength ( int x , int y , int z ) { return 1 + abs ( x - y ) + abs ( y - z ) ; }
int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { sort ( arr1 , arr1 + n1 ) ; sort ( arr2 , arr2 + n2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }
int countPairs ( int * P , int * Q , int N , int M ) { int A [ 2 ] = { 0 } , B [ 2 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
int distinctCount ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( abs ( arr [ i ] ) ) ; return s . size ( ) ; }
int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ; } else { return pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ; } }
int checkArray ( int arr [ ] , int N , int k ) { if ( N < 3 ) return -1 ; int i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; int R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; int Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
int solve ( int A [ ] , int N ) { int i = 0 ; int k = 0 ; for ( int j = 1 ; j < N ; j ++ ) { int tempK = min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
int longestSubsequenceCommonSegment ( int k , string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int lcs [ n + 1 ] [ m + 1 ] ; int cnt [ n + 1 ] [ m + 1 ] ; memset ( lcs , 0 , sizeof ( lcs ) ) ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
int cntPairs ( int a [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
int icosikaipentagonNum ( int N ) { return ( 23 * N * N - 21 * N ) / 2 ; }
int smallestNth ( int A , int B , int N ) { int res = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { int D = ( B - A ) / ( j - i ) ; int FirstTerm = A - ( i - 1 ) * D ; int NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = min ( res , NthTerm ) ; } } } return res ; }
bool sumSquare ( int n ) { unordered_map < int , int > s ; for ( int i = 0 ; i * i <= n ; ++ i ) { s [ i * i ] = 1 ; if ( s . find ( n - i * i ) != s . end ( ) ) { cout << sqrt ( n - i * i ) << " ^ 2 ▁ + ▁ " << i << " ^ 2" << endl ; return true ; } } return false ; }
double largestSumOfAverages ( vector < int > & A , int K ) { int n = A . size ( ) ; double pre_sum [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double dp [ n ] = { 0 } ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; }
int minAbsDiff ( int n ) { int left = 1 << ( ( int ) floor ( log2 ( n ) ) ) ; int right = left * 2 ; return min ( ( n - left ) , ( right - n ) ) ; }
long noOfTriples ( long long arr [ ] , int n ) { sort ( arr , arr + n ) ; long long count = 0 ; for ( long long i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
bool isTidy ( int num ) { int prev = 10 ; while ( num ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
int findSum ( int N , int K ) { int ans = 0 ; int i = 1 ; while ( i <= N ) { ans += N / i ; i = i * K ; } cout << ans ; }
void findNumbers ( int n ) { int i = 0 ; while ( i <= n ) { cout << 2 * i * i + 4 * i + 1 + i % 2 << " ▁ " ; i ++ ; } }
int getPairs ( int a [ ] ) { int n = sizeof ( a [ 0 ] ) ; int count = ( n * ( n - 1 ) ) / 2 ; return count ; }
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
int fib ( int n ) { if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } }
void findRightAngle ( int A , int H ) { long D = pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { long root1 = ( H * H + sqrt ( D ) ) / 2 ; long root2 = ( H * H - sqrt ( D ) ) / 2 ; long a = sqrt ( root1 ) ; long b = sqrt ( root2 ) ; if ( b >= a ) cout << a << " ▁ " << b << " ▁ " << H ; else cout << b << " ▁ " << a << " ▁ " << H ; } else cout << " - 1" ; }
void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( 1 << i ) & N ) { result ++ ; } } cout << result << endl ; }
double kthRoot ( double n , int k ) { return pow ( k , ( 1.0 / k ) * ( log ( n ) / log ( k ) ) ) ; }
double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
void find_composite_nos ( int n ) { cout << 9 * n << " ▁ " << 8 * n ; }
double Length_Diagonal ( int a , int b , double theta ) { double diagonal = sqrt ( ( pow ( a , 2 ) + pow ( b , 2 ) ) - 2 * a * b * cos ( theta * ( PI / 180 ) ) ) ; return diagonal ; }
void findTriangles ( int n ) { int num = n ; cout << num << " ▁ " ; cout << num * ( num - 4 ) * ( num - 5 ) / 6 ; }
int SubArraySum ( int arr [ ] , int n ) { long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
void positions ( string str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << ( str [ i ] & NUM ) << " ▁ " ; } }
int count_pairs ( int x ) { int ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = x / 2 ; } return ans ; }
int countOccurrences ( int N , int X ) { int count = 0 ; for ( int i = 1 ; i < sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { int a = i ; int b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; }
void checkWinner ( int N , int K ) { if ( N % ( K + 1 ) ) { cout << " A " ; } else { cout << " B " ; } }
int getTotalNumberOfSequences ( int m , int n ) { int T [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
int maxDistance ( int arr [ ] , int n ) { int max1 = INT_MIN , min1 = INT_MAX ; int max2 = INT_MIN , min2 = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { max1 = max ( max1 , arr [ i ] + i ) ; min1 = min ( min1 , arr [ i ] + i ) ; max2 = max ( max2 , arr [ i ] - i ) ; min2 = min ( min2 , arr [ i ] - i ) ; } return max ( max1 - min1 , max2 - min2 ) ; }
int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
int times ( int steps [ ] , int n ) { int current_level = 0 ; int previous_level = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; }
int maxValue ( int a [ ] , int n , int pos , int moves , int left , int dp [ ] [ k + 1 ] ) { if ( moves == 0 || ( pos > n - 1 pos < 0 ) ) return 0 ; if ( dp [ pos ] [ left ] != -1 ) return dp [ pos ] [ left ] ; int value = 0 ; if ( left > 0 && pos >= 1 ) value = max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) ; if ( pos <= n - 1 ) value = max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) ; return dp [ pos ] [ left ] = value ; }
bool checkLuhn ( const string & cardNo ) { int nDigits = cardNo . length ( ) ; int nSum = 0 , isSecond = false ; for ( int i = nDigits - 1 ; i >= 0 ; i -- ) { int d = cardNo [ i ] - '0' ; if ( isSecond == true ) d = d * 2 ; nSum += d / 10 ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; }
int maxiConsecutiveSubarray ( int arr [ ] , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = max ( maxi , cnt ) ; i = j ; } return maxi ; }
bool isAnyNotPalindrome ( string s ) { set < char > unique ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) unique . insert ( s [ i ] ) ; if ( unique . size ( ) > 1 ) return true ; else return false ; }
int lastDigitFactorial ( unsigned int n ) { if ( n == 0 ) return 1 ; else if ( n <= 2 ) return n ; else if ( n == 3 ) return 6 ; else if ( n == 4 ) return 4 ; else return 0 ; }
int findCount ( string s , int n , int a , int b ) { int res = 0 ; for ( int i = 0 ; i < b ; i ++ ) { if ( i == a ) res += ( s [ n - i - 1 ] != '1' ) ; else res += ( s [ n - i - 1 ] != '0' ) ; } return res ; }
int CountWays ( int N , int M ) { int count = 1 ; count = pow ( 3 , M + N ) ; count *= pow ( 2 , M * N ) ; return count ; }
void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { cout << ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ; }
void minimumCost ( int * cost , int n , int x ) { vector < int > dp ( n + 2 , 0 ) ; dp [ 0 ] = cost [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + min ( dp [ i - 1 ] , min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } cout << dp [ n - 1 ] ; }
int nthElement ( int a , int b , int n ) { vector < int > seq ; for ( int i = 1 ; i <= n ; i ++ ) seq . push_back ( a * i ) ; sort ( seq . begin ( ) , seq . end ( ) ) ; for ( int i = 1 , k = n ; i <= n && k ; i ++ ) { if ( ! binary_search ( seq . begin ( ) , seq . end ( ) , b * i ) ) { seq . push_back ( b * i ) ; sort ( seq . begin ( ) , seq . end ( ) ) ; k -- ; } } return seq [ n - 1 ] ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
int findIndex ( int n ) { float x = sqrt ( 2 * pow ( 10 , ( n - 1 ) ) ) ; return round ( x ) ; }
void LCMPairs ( int arr [ ] , int N ) { int total_pairs = ( N * ( N - 1 ) ) / 2 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; cout << " Even ▁ = ▁ " << total_pairs - odd << " , ▁ Odd ▁ = ▁ " << odd ; }
void PrintMinNumberForPattern ( string seq ) { string result ; stack < int > stk ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) seq [ i ] == ' I ' ) { while ( ! stk . empty ( ) ) { result += to_string ( stk . top ( ) ) ; result += " ▁ " ; stk . pop ( ) ; } } } cout << result << endl ; }
void findpair ( int l , int r ) { int c = 0 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { cout << i << " , ▁ " << j ; c = 1 ; break ; } } if ( c == 1 ) break ; } }
string isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return " Yes " ; return " No " ; }
bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
int maxLen ( int * arr , int n ) { int min_val = * min_element ( arr , arr + n ) ; int freq = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
float ellipse ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float x = ( 3.14 * l * b ) / 4 ; return x ; }
void isSequenceValid ( vector < int > & B , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { cout << " No " ; return ; } } cout << " Yes " ; }
void makeArray ( int a [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) cout << i * n << " ▁ " ; }
int evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
int CountPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; }
void redistribute ( int arr [ ] , int n , int x ) { sort ( arr , arr + n , greater < int > ( ) ) ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum / ( i + 1 ) < x ) { cout << i << endl ; break ; } } if ( i == n ) cout << n << endl ; }
void FindPairs ( int n , int k ) { cout << 1 << " ▁ " << n << endl ; k -- ; for ( long long i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { cout << 1 << " ▁ " << i << endl ; k -- ; if ( k == 0 ) break ; if ( i != n / i ) { cout << 1 << " ▁ " << n / i << endl ; k -- ; } if ( k == 0 ) break ; } } }
void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } cout << N - Count ; }
void nearestPowerOfTwo ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int lg = log2 ( arr [ i ] ) ; int a = pow ( 2 , lg ) ; int b = pow ( 2 , lg + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) cout << a << " ▁ " ; else cout << b << " ▁ " ; } }
int getPairs ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } cout << count ; }
int min_elimination ( int n , int arr [ ] ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
void printSumSimple ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; cout << sum << " ▁ " ; } cout << endl ; } }
int findMin ( int arr [ ] , int N , int k ) { int pairs = 0 ; for ( int i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return -1 ; else return 2 * k + N - 1 ; }
bool canBecomeEmpty ( string str , string sub_str ) { while ( str . size ( ) > 0 ) { int idx = str . find ( sub_str ) ; if ( idx == -1 ) break ; str . erase ( idx , sub_str . size ( ) ) ; } return ( str . size ( ) == 0 ) ; }
int rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; }
int countChars ( string str , int n ) { int i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == '0' ) i ++ ; else i += 2 ; cnt ++ ; } return cnt ; }
int minimumChar ( string S1 , string S2 ) { int n = S1 . size ( ) , m = S2 . size ( ) ; int ans = INT_MAX ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = min ( minRemovedChar , ans ) ; } return ans ; }
int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
void findkth ( int n , int k ) { vector < int > v1 ; vector < int > v2 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . push_back ( i ) ; if ( i != sqrt ( n ) ) v2 . push_back ( n / i ) ; } } reverse ( v2 . begin ( ) , v2 . end ( ) ) ; if ( k > ( v1 . size ( ) + v2 . size ( ) ) ) cout << " Doesn ' t ▁ Exist " ; else { if ( k <= v1 . size ( ) ) cout << v1 [ k - 1 ] ; else cout << v2 [ k - v1 . size ( ) - 1 ] ; } }
void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] < ' A ' s [ i ] > ' Z ' && s [ i ] < ' a ' s [ i ] > ' z ' ) { s . erase ( i , 1 ) ; i -- ; } } cout << s ; }
int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
void sortSquares ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] * arr [ i ] ; sort ( arr , arr + n ) ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; }
int bitwiseOrTillN ( int n ) { int result = 2 ; for ( int i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; }
int center_pentadecagonal_num ( long int n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int stringToInt ( string str ) { if ( str . length ( ) == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . substr ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * pow ( 10 , str . length ( ) - 1 ) + y ; return int ( x ) ; }
int evenbitsetnumber ( int n ) { int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
void swap ( int & a , int & b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; cout << " After ▁ swapping : ▁ a ▁ = ▁ " << a << " , ▁ b ▁ = ▁ " << b ; }
int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
int longestSubarray ( int arr [ ] , int n ) { int maxMean = 0 ; for ( int i = 1 ; i < n ; i ++ ) maxMean = max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int subarrayLength = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
int Occurrence ( string s , int position ) { int count = 0 ; for ( int i = 0 ; i < position - 1 ; i ++ ) if ( s [ i ] == s [ position - 1 ] ) count ++ ; return count ; }
long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
int maxCost ( int a [ ] , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = max ( mx , a [ i ] ) ; int count [ mx + 1 ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int res [ mx + 1 ] ; res [ 0 ] = 0 ; l = min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = max ( num - l - 1 , 0 ) ; res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; }
void printMaxOfMin ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = INT_MIN ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } cout << maxOfMin << " ▁ " ; } }
int addOne ( int x ) { return ( - ( ~ x ) ) ; }
void nDigitPerfectSquares ( int n ) { cout << pow ( ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) << " ▁ " ; cout << pow ( ceil ( sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ; }
void nearestPerfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = sqrt ( arr [ i ] ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) cout << a << " ▁ " ; else cout << b << " ▁ " ; } }
int countPS ( string str ) { int N = str . length ( ) ; int cps [ N + 1 ] [ N + 1 ] ; memset ( cps , 0 , sizeof ( cps ) ) ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } return cps [ 0 ] [ N - 1 ] ; }
int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }
void isCycleExists ( int arr [ ] , int N ) { bool valley = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { cout << " Yes " << endl ; return ; } } cout << " No " ; }
int countDigitsToBeRemoved ( int N , int K ) { string s = to_string ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( ! K ) return res ; else if ( f_zero ) return s . size ( ) - 1 ; return -1 ; }
int longestSubArray ( int arr [ ] , int n ) { bool isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
bool check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return true ; } return false ; }
void areSame ( int a , int b ) { if ( ! ( a - b ) ) cout << " Same " ; else cout << " Not ▁ Same " ; }
int count ( int n ) { return 15 * pow ( 16 , n - 1 ) ; }
int solve ( int n , int k , int mod , int dp [ ] ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; int cnt = 0 ; for ( int i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; }
int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool marked [ nNew + 1 ] ; memset ( marked , false , sizeof ( marked ) ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) cout << 2 << " ▁ " ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) cout << 2 * i + 1 << " ▁ " ; }
int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; }
int seriesSum ( int n ) { int sum = 0 ; int currProd = 1 ; int currSum = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; }
bool IsPrime ( int i ) { if ( i % 2 == 0 && i != 2 ) return false ; else { for ( int j = 3 ; j <= sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) return false ; } return true ; } }
int equal_xor_sum ( int arr [ ] , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int maxSum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
int countOfSubarray ( int arr [ ] , int N ) { unordered_map < int , int > mp ; int answer = 0 ; int sum = 0 ; mp [ 1 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp [ sum - i ] ; mp [ sum - i ] ++ ; } cout << answer ; }
void generateString ( int K ) { string s = " " ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + char ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += char ( i ) ; s += char ( j ) ; } } s += char ( 97 ) ; cout << s ; }
int totalCircles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; }
int countQuadruples ( int A [ ] , int N ) { int ans = 0 ; unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { ans += freq [ A [ i ] ] ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { freq [ A [ i ] * A [ j ] * A [ k ] ] ++ ; } } } return ans ; }
string LexicographicalMaxString ( string str ) { string mx = " " ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) mx = max ( mx , str . substr ( i ) ) ; return mx ; }
void leastBricks ( vector < vector < int > > wall ) { unordered_map < int , int > map ; int res = 0 ; for ( vector < int > list : wall ) { int width = 0 ; for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { width += list [ i ] ; map [ width ] ++ ; res = max ( res , map [ width ] ) ; } } cout << wall . size ( ) - res ; }
void findFactors ( int a , int b ) { int c ; c = a + b - 1 ; cout << c ; }
int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; }
void lexNumbers ( int n ) { vector < string > s ; for ( int i = 1 ; i <= n ; i ++ ) { s . push_back ( to_string ( i ) ) ; } sort ( s . begin ( ) , s . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) ans . push_back ( stoi ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " ▁ " ; }
int calcScore ( string str ) { int score = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; ) { int chunkSize = 1 ; char currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == '1' ) score += pow ( chunkSize , 2 ) ; else score -= pow ( chunkSize , 2 ) ; } return score ; }
int countNestedPolygons ( int sides ) { int count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
int minCount ( int * arr , int n , int k ) { int ans = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; int l = 0 ; int r = 0 ; int tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
void printORSumforEachElement ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int req_sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { req_sum += ( arr [ i ] arr [ j ] ) ; } cout << req_sum << " ▁ " ; } }
int countPairs ( int A , int B ) { int countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; }
int subsetXOR ( int arr [ ] , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( log2 ( max_ele ) + 1 ) ) - 1 ; if ( k > m ) return 0 ; int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
void tripletAndSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } cout << ans ; }
int maxProfit ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - ( 1 * i ) ) > 0 ) ans += ( arr [ i ] - ( 1 * i ) ) ; if ( ( arr [ i ] - ( 1 * i ) ) == 0 ) break ; } return ans ; }
int findCycles ( int N ) { int res = 0 ; int finalResult = 0 ; int val = 2 * N - 1 ; int s = val ; res = ( N - 1 ) * ( N - 2 ) ; finalResult = res + s ; return finalResult ; }
float cubeSide ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float a = ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) ; return a ; }
int minFlips ( vector < vector < int > > & mat , string s ) { int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != s [ i + j ] - '0' ) { count ++ ; } } } return count ; }
int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
void diameter ( double r ) { cout << " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " << " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " << 2 * r << endl ; }
int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; }
void printMedian ( int arr [ ] , int n , int K ) { sort ( arr , arr + n ) ; cout << arr [ ( n + K ) / 2 ] ; }
int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
void generate_derangement ( int N ) { int S [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N && i % N != 0 ) { int temp = D [ N ] ; D [ N ] = D [ N - 1 ] ; D [ N - 1 ] = temp ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) printf ( " % d ▁ " , D [ i ] ) ; printf ( " STRNEWLINE " ) ; }
void PossibleValues ( int b , int x , int n ) { int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { cout << leastdivisible - b << " ▁ " ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag ) cout << -1 ; }
int longestEvenOddSubarray ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return max ( cnt , longest ) ; }
int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
int lds ( int arr [ ] , int n ) { int lds [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
ll F ( ll A , ll B ) { if ( A == 1 ) return ( 4 % B ) ; else { ll temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
double get_concentration ( double mass , double volume ) { if ( volume == 0 ) return -1 ; else return ( mass / volume ) * 1000 ; }
int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
bool check_order ( vector < int > arr ) { int cnt = 0 ; for ( int i = 0 ; i < arr . size ( ) - 1 ; i ++ ) { if ( abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( abs ( arr [ 0 ] - arr [ arr . size ( ) - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; }
float trianglearea ( float r ) { if ( r < 0 ) return -1 ; return r * r ; }
string isDivisibleByDivisor ( int S , int D ) { S %= D ; unordered_set < int > hashMap ; hashMap . insert ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . find ( S ) != hashMap . end ( ) ) { if ( S == 0 ) { return " Yes " ; } return " No " ; } else hashMap . insert ( S ) ; } return " Yes " ; }
double area_of_tetrahedron ( int side ) { return ( sqrt ( 3 ) * ( side * side ) ) ; }
int findInGrid ( int i , int j ) { if ( i == j ) return ( i * i - ( i - 1 ) ) ; else if ( i > j ) { if ( i % 2 == 0 ) return i * i - ( j - 1 ) ; else return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ; } else { if ( j % 2 == 0 ) return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ; else return j * j - ( i - 1 ) ; } }
int findBucketNo ( int p ) { return ceil ( ( sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
int countCrossLine ( int arr [ ] , int n ) { int count_crossline = 0 ; int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
int maxOnesIndex ( bool arr [ ] , int n ) { int max_count = 0 ; int max_index ; int prev_zero = -1 ; int prev_prev_zero = -1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
int distinctSubstring ( string & P , int N ) { unordered_set < string > S ; for ( int i = 0 ; i < N ; ++ i ) { vector < bool > freq ( 26 , false ) ; string s ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; if ( freq [ pos ] == true ) break ; freq [ pos ] = true ; s += P [ j ] ; S . insert ( s ) ; } } return S . size ( ) ; }
void flippingBits ( unsigned long N , unsigned long K ) { unsigned long X = ( 1 << ( K - 1 ) ) - 1 ; N = X - N ; cout << N ; }
bool check ( string str ) { int n = str . length ( ) ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - '0' ) * 100 + ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; int fourth_last = str [ n - 4 ] - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
int minCountOfNumbers ( int N ) { int k = N % 10 ; int z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else return -1 ; }
void factorsOf3 ( int arr [ ] , int N ) { int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 3 == 0 ) a ++ ; else if ( arr [ i ] % 3 == 1 ) b ++ ; else if ( arr [ i ] % 3 == 2 ) c ++ ; } if ( a >= 1 && a <= b + c + 1 ) cout << " Yes " << endl ; else if ( a == 0 && b == 0 && c > 0 ) cout << " Yes " << endl ; else if ( a == 0 && c == 0 && b > 0 ) cout << " Yes " << endl ; else cout << " No " << endl ; }
void getParity ( int n , const vector < int > & A ) { for ( auto x : A ) { if ( x & 1 ) { cout << " Even " << endl ; return ; } } cout << " Odd " << endl ; }
int findsubArray ( int arr [ ] , int N , int K ) { int res = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { int curr_prod = 1 ; for ( int j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; }
int sumOfSeries ( int n ) { ll ans = ( ll ) pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
int digSum ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; }
int countChar ( string str , char x ) { int count = 0 , n = 10 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) if ( str [ i ] == x ) count ++ ; int repetitions = n / str . size ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . size ( ) ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; }
int countPairs ( int arr [ ] , int n ) { unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; int res = 0 ; for ( auto x : map ) { int cnt = x . second ; res += ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } return res ; }
int numOfWays ( vector < vector < int > > a , int n , int i , set < int > & blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && blue . find ( j ) == blue . end ( ) ) { blue . insert ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . erase ( j ) ; } } return count ; }
int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = -1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = max ( ans , arr [ i - 1 ] ) ; } return ans ; }
void pendulumArrangement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int op [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; cout << " Pendulum ▁ arrangement : " << endl ; for ( i = 0 ; i < n ; i ++ ) cout << op [ i ] << " ▁ " ; cout << endl ; }
int solve ( double M , double N , double s ) { int ans = ( ( int ) ( ceil ( M / s ) ) * ( int ) ( ceil ( N / s ) ) ) ; return ans ; }
char maxRepeating ( string str ) { int n = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
int No_of_Triangle ( int N , int K ) { if ( N < K ) return -1 ; else { int Tri_up = 0 ; Tri_up = ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ; int Tri_down = 0 ; Tri_down = ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ; return Tri_up + Tri_down ; } }
void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { int A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { cout << " A ▁ = ▁ " << A / 3 << " , ▁ B ▁ = ▁ " << B << " , ▁ C ▁ = ▁ " << C << endl ; return ; } } } cout << -1 << endl ; }
int maxSum ( int arr [ ] , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
int maxFreq ( string s , int a , int b ) { int fre [ 10 ] = { 0 } ; int n = s . size ( ) ; if ( a > b ) swap ( a , b ) ; for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - '0' ] ++ ; if ( fre [ a ] == 0 and fre [ b ] == 0 ) return -1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
int minOperation ( string & s , int i , int j , int count ) { if ( ( i >= s . size ( ) && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] ) return count ; if ( i >= s . size ( ) ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; }
bool isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; }
void findSquareSum ( int Coordinates [ ] [ 2 ] , int N ) { long long xq = 0 , yq = 0 ; long long xs = 0 , ys = 0 ; long long res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int a , b ; a = Coordinates [ i ] [ 0 ] ; b = Coordinates [ i ] [ 1 ] ; res += xq ; res -= 2 * xs * a ; res += i * ( long long ) ( a * a ) ; xq += a * a ; xs += a ; res += yq ; res -= 2 * ys * b ; res += i * ( long long ) b * b ; yq += b * b ; ys += b ; } cout << res ; }
int isvalid ( ll int s ) { float k = ( -1 + sqrt ( 1 + 8 * s ) ) / 2 ; if ( ceil ( k ) == floor ( k ) ) return k ; else return -1 ; }
bool isicosihenagonal ( int N ) { float n = ( 17 + sqrt ( 152 * N + 289 ) ) / 38 ; return ( n - ( int ) n ) == 0 ; }
int countPairs ( int arr [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; }
int getPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; }
int icosidigonal_num ( long int n ) { return ( 20 * n * n - 18 * n ) / 2 ; }
int findMinCost ( vector < int > & a , int k ) { int n = ( int ) a . size ( ) ; int max_ele = * max_element ( a . begin ( ) , a . end ( ) ) ; ll dp [ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) dp [ i ] = INT_MAX ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int freq [ max_ele + 1 ] ; memset ( freq , 0 , sizeof freq ) ; for ( int j = i ; j < n ; ++ j ) { freq [ a [ j ] ] ++ ; int cost = 0 ; for ( int x = 0 ; x <= max_ele ; ++ x ) { cost += ( freq [ x ] == 1 ) ? 0 : freq [ x ] ; } dp [ j + 1 ] = min ( dp [ i ] + cost + k , dp [ j + 1 ] ) ; } } return dp [ n ] ; }
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
void findMaxValue ( int N , int K ) { int packages ; int maxi = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = max ( maxi , i ) ; } packages = N / maxi ; cout << packages << endl ; }
bool isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; }
int countWays ( string s ) { int count [ 26 ] = { 0 } ; for ( char x : s ) count [ x - ' a ' ] ++ ; count [ s [ 0 ] - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
int seiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
void parallel ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { cout << " Yes " ; } else { cout << " No " ; } }
int Balanced_Substring ( string str , int n ) { int ans = 0 ; vector < int > arr ( n / 2 + 1 , 0 ) ; int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) d ++ ; else { if ( d == 1 ) { for ( int j = 2 ; j <= n / 2 + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; }
void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) pow ( 10 , temp ) ; palindrome += n - 1 ; printf ( " % d " , palindrome ) ; if ( k & 1 ) palindrome /= 10 ; while ( palindrome ) { printf ( " % d " , palindrome % 10 ) ; palindrome /= 10 ; } printf ( " STRNEWLINE " ) ; }
long firstkdigits ( int n , int k ) { unsigned long long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; }
void waysToPaint ( int n ) { int same = 6 ; int diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } cout << ( same + diff ) ; }
double calculate_angle ( double n ) { double total_angle = 360 ; return total_angle / n ; }
int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; }
void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) cout << " ▁ " << i ; }
int countWords ( char str [ ] , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
int count ( int n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; int table [ n + 1 ] , i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
void print ( string str ) { cout << str [ 0 ] ; for ( int i = 1 ; str [ i ] != ' \0' ; i ++ ) { if ( ( str [ i ] == str [ i - 1 ] + 1 ) || ( str [ i ] == str [ i - 1 ] - 1 ) ) cout << str [ i ] ; else cout << " STRNEWLINE " << str [ i ] ; ; } }
void findBalance ( int x , float bal ) { if ( x % 10 == 0 && ( ( float ) x + 1.50 ) <= bal ) { cout << fixed << setprecision ( 2 ) << ( bal - x - 1.50 ) << endl ; } else { cout << fixed << setprecision ( 2 ) << ( bal ) << endl ; } }
void findMinAvgSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } cout << " Subarray ▁ between ▁ [ " << res_index << " , ▁ " << res_index + k - 1 << " ] ▁ has ▁ minimum ▁ average " ; }
int minCut ( string a ) { int cut [ a . length ( ) ] ; bool palindrome [ a . length ( ) ] [ a . length ( ) ] ; memset ( palindrome , false , sizeof ( palindrome ) ) ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { int minCut = i ; for ( int j = 0 ; j <= i ; j ++ ) { if ( a [ i ] == a [ j ] && ( i - j < 2 palindrome [ j + 1 ] [ i - 1 ] ) ) { palindrome [ j ] [ i ] = true ; minCut = min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . length ( ) - 1 ] ; }
int countSequences ( int arr [ ] , int n ) { int count = 1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
void precompute ( string s , string K ) { int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] + ( s . substr ( i , K . size ( ) ) == K ) ; } }
void solve ( int n ) { int n_2 = n / 2 ; string den ; den = "1" ; while ( n_2 -- ) den += '0' ; cout << 1 << " / " << den << " STRNEWLINE " ; }
void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) cout << " Yes " ; else cout << " No " ; }
float find ( int N , int sum ) { if ( dp [ N ] [ sum ] ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; }
double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = ( lat2 - lat1 ) * M_PI / 180.0 ; double dLon = ( lon2 - lon1 ) * M_PI / 180.0 ; lat1 = ( lat1 ) * M_PI / 180.0 ; lat2 = ( lat2 ) * M_PI / 180.0 ; double a = pow ( sin ( dLat / 2 ) , 2 ) + pow ( sin ( dLon / 2 ) , 2 ) * cos ( lat1 ) * cos ( lat2 ) ; double rad = 6371 ; double c = 2 * asin ( sqrt ( a ) ) ; return rad * c ; }
int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
long countWays ( int n ) { long dp [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
void rad ( double d , double h ) { cout << " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " << ( ( d * d ) / ( 8 * h ) + h / 2 ) << endl ; }
int findMissing ( int arr [ ] , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return -1 ; return ( num / den ) ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; unordered_set < int > us ; for ( int i = 0 ; i < m ; i ++ ) us . insert ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . find ( x - arr2 [ j ] ) != us . end ( ) ) count ++ ; return count ; }
int findCount ( int arr [ ] , int n ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count ++ ; else ans = ans + count ; } return ans ; }
void flip ( string & s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { while ( s [ i ] == '0' ) { s [ i ] = '1' ; i ++ ; } break ; } } }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }
int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return -1 ; }
void printModulus ( int X , int Y ) { int n = max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) cout << i << " ▁ " ; } }
int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
int maxGCD ( int n ) { return ( n / 2 ) ; }
int stirlingFactorial ( int n ) { if ( n == 1 ) return 1 ; long int z ; z = sqrt ( 2 * 3.14 * n ) * pow ( ( n / e ) , n ) ; return z ; }
int firstDigit ( int n ) { long long int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; }
void missing4 ( int arr [ ] , int n ) { int helper [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { int temp = abs ( arr [ i ] ) ; if ( temp <= n ) arr [ temp - 1 ] *= ( -1 ) ; else if ( temp > n ) { if ( temp % n != 0 ) helper [ temp % n - 1 ] = -1 ; else helper [ ( temp % n ) + n - 1 ] = -1 ; } } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) cout << ( i + 1 ) << " ▁ " ; for ( int i = 0 ; i < 4 ; i ++ ) if ( helper [ i ] >= 0 ) cout << ( n + i + 1 ) << " ▁ " ; return ; }
int superSeq ( char * X , char * Y , int m , int n ) { if ( ! m ) return n ; if ( ! n ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
int maxORminusXOR ( int N ) { int MSB = log2 ( N ) ; int M = 0 ; for ( int i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; }
void countXorPartition ( int N ) { double a = pow ( 2 , floor ( N - log ( N + 1 ) / log ( 2 ) ) ) ; cout << a ; }
void record_sum ( int record [ ] , int l , int r , int n , int adder ) { for ( int i = l ; i <= r ; i ++ ) record [ i ] += adder ; }
int calculateTriangles ( int sides [ ] ) { double count = pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= pow ( sides [ 0 ] , 2 ) ; count -= pow ( sides [ 2 ] , 2 ) ; count -= pow ( sides [ 4 ] , 2 ) ; return ( int ) ( count ) ; }
float polyapothem ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; }
int oddSum ( int n ) { return ( n * n ) ; }
int difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return abs ( d1 - d2 ) ; }
float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return -1 ; float x = r ; float V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 ; return V ; }
int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + n ^ x ) ++ c ; return c ; }
int LastTwoDigit ( long long int num ) { int one = num % 10 ; num /= 10 ; int tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
void printCase ( int n ) { if ( n <= 2 ) { cout << -1 ; return ; } for ( int i = n ; i >= 1 ; i -- ) cout << i << " ▁ " ; }
int length_substring ( string S , char K ) { int curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( S [ i ] == K ) { curr_cnt += 1 ; } else { prev_cnt = max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; }
void findMaxNumbers ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int opr = ceil ( log2 ( arr [ i ] ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } cout << cnt ; }
int minStepToDeleteString ( string str ) { int N = str . length ( ) ; int dp [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
int findDistinctSums ( int n ) { set < int > s ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . insert ( i + j ) ; } } return s . size ( ) ; }
void checkSumOfNatural ( int n ) { int i = 1 ; bool flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) cout << " YES " ; else cout << " NO " ; }
int substrDeletion ( string str , int len ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count0 ++ ; else count1 ++ ; } return min ( count0 , count1 ) ; }
int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * pow ( 8 , i - 1 ) ; } return sum ; }
ll findSum ( int n ) { ll sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }
int maxConsecutiveRopes ( int ropes [ ] , int N ) { int curSize = 0 ; sort ( ropes , ropes + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ropes [ i ] <= curSize + 1 ) { curSize = curSize + ropes [ i ] ; } else break ; } return curSize ; }
int FirstDigit ( int arr [ ] , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - floor ( S ) ; int ans = pow ( 10 , fract_S ) ; return ans ; }
int count ( string N , int X , string subStr , int index , int n ) { if ( index == n ) return 0 ; string a = subStr + N [ index ] ; int b = 0 ; if ( stoll ( a ) % X == 0 ) b = 1 ; int m1 = count ( N , X , a , index + 1 , n ) ; int m2 = b + count ( N , X , " " , index + 1 , n ) ; return max ( m1 , m2 ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int MinRemove ( int a [ ] , int n , int k ) { vector < int > cnt ( k , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }
bool isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( ceil ( a ) == 1 && floor ( a ) == 1 ) return true ; return false ; }
int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
void compute ( vector < int > query ) { vector < int > v ( 100001 ) , dp ( 100001 ) ; v [ 1 ] = 1 , v [ 2 ] = 0 ; dp [ 1 ] = 0 , dp [ 2 ] = 0 ; for ( int i = 3 ; i < 100001 ; i ++ ) { if ( i % 2 != 0 ) { if ( ( i / 2 ) % 2 == 0 ) { v [ i ] = 1 ; dp [ i ] = dp [ i - 1 ] ; } else { v [ i ] = v [ i / 2 ] + 1 ; dp [ i ] = dp [ i - 1 ] + v [ i ] - 1 ; } } else { v [ i ] = 0 ; dp [ i ] = dp [ i - 1 ] ; } } for ( auto x : query ) cout << dp [ x ] << endl ; }
int remainder ( string str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; }
int minsteps ( int n , int m ) { if ( m > n ) { return -1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
void minModulo ( int L , int R , int N ) { if ( R - L < N ) { int ans = INT_MAX ; for ( ll i = L ; i <= R ; i ++ ) for ( ll j = L ; j <= R ; j ++ ) if ( i != j ) ans = min ( 0ll + ans , ( i * j ) % N ) ; cout << ans ; } else { cout << 0 ; } }
int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }
bool isPanalphabeticWindow ( char s [ ] , int n ) { char ch = ' a ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch ++ ; if ( ch == ' z ' + 1 ) return true ; } return false ; }
void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { cout << fact << " ▁ " ; fact = fact * x ; x ++ ; } }
int minimum_sum ( int n , int k ) { if ( k % n == 0 ) return 0 ; return 1 ; }
int findSum ( int n ) { return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / pow ( 9 , 3 ) - n * ( n + 1 ) / 18 ; }
void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { cout << " NO " ; return ; } double a = ( N + sqrt ( val ) ) / 2.0 ; double b = ( N - sqrt ( val ) ) / 2.0 ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; }
void findSymPairs ( int arr [ ] [ 2 ] , int row ) { unordered_map < int , int > hM ; for ( int i = 0 ; i < row ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; if ( hM . find ( sec ) != hM . end ( ) && hM [ sec ] == first ) cout << " ( " << sec << " , ▁ " << first << " ) " << endl ; else hM [ first ] = sec ; } }
void isEqualSubstring ( string str , int x ) { int n = str . length ( ) ; int i = 0 ; while ( i < n && i < x ) { if ( str [ i ] != str [ n - i - 1 ] ) { cout << " false " ; return ; } i ++ ; } cout << " true " ; }
void evenproduct ( int arr [ ] , int length ) { int count = 0 ; for ( int i = 0 ; i < length + 1 ; i ++ ) { int product = 1 ; for ( int j = i ; j < length + 1 ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } cout << count ; }
int find_index ( int arr [ ] , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
int getValue ( int arr [ ] , int N ) { int dp [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int minn = arr [ i ] ; int maxx = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { minn = min ( arr [ j ] , minn ) ; maxx = max ( arr [ j ] , maxx ) ; dp [ i ] = max ( dp [ i ] , maxx - minn + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; }
int GIF ( float n ) { return floor ( n ) ; }
bool check ( int a [ ] , int n ) { bool flag = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = 1 ; } if ( flag ) return false ; else return true ; }
int maxLength ( int a [ ] , int n ) { int maxLen = 0 ; int prev_cnt = 0 , curr_cnt = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = max ( maxLen , min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; }
int MinDistK ( int arr [ ] , int N , int K ) { int res = INT_MAX ; int dist = 0 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = abs ( arr [ i ] ) + abs ( arr [ i + K - 1 ] ) + min ( abs ( arr [ i ] ) , abs ( arr [ i + K - 1 ] ) ) ; } res = min ( res , dist ) ; } return res ; }
int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; }
int count ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; }
int smallestSumSubarr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = max ( max_sum , sum_here ) ; } return ( -1 ) * max_sum ; }
string conVowUpp ( string & str ) { int N = str . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { str [ i ] = str [ i ] - ' a ' + ' A ' ; } } return str ; }
ll count_of_ways ( ll n ) { ll count ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
int minOperations ( int a [ ] , int b [ ] , int n ) { int minA = * min_element ( a , a + n ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = 1 ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = 0 ; break ; } } if ( check ) return operations ; } return -1 ; }
string even_or_odd ( string N ) { int len = N . size ( ) ; if ( N [ len - 1 ] == '0' N [ len - 1 ] == '2' N [ len - 1 ] == '4' N [ len - 1 ] == '6' N [ len - 1 ] == '8' N [ len - 1 ] == ' A ' N [ len - 1 ] == ' C ' N [ len - 1 ] == ' E ' ) return ( " Even " ) ; else return ( " Odd " ) ; }
void find_sum_of_two_squares ( int a , int b ) { int ab = a * b ; for ( int i = 0 ; i * i <= ab ; i ++ ) { for ( int j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) cout << i << " ^ 2 ▁ + ▁ " << j << " ^ 2 ▁ = ▁ " << ab << " STRNEWLINE " ; } } }
bool isOctadecagon ( int N ) { float n = ( 14 + sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - ( int ) n ) == 0 ; }
int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) { int res = 0 ; sort ( X , X + m , greater < int > ( ) ) ; sort ( Y , Y + n , greater < int > ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return sqrt ( r ) ; }
int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
void smallestNumber ( int N ) { cout << N * floor ( ( pow ( 10 , N ) - 1 ) / N ) ; }
int maxDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
void printDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } cout << " Principal ▁ Diagonal : " << principal << endl ; cout << " Secondary ▁ Diagonal : " << secondary << endl ; }
int MaxXOR ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; }
bool checkFittingArrays ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
string removeDuplicatesFromString ( string str ) { vector < int > table ( 256 , 0 ) ; vector < char > chars ; for ( auto i : str ) chars . push_back ( i ) ; int endIndex = 0 ; for ( int i = 0 ; i < chars . size ( ) ; i ++ ) { if ( table [ chars [ i ] ] == 0 ) { table [ chars [ i ] ] = -1 ; chars [ endIndex ++ ] = chars [ i ] ; } } string ans = " " ; for ( int i = 0 ; i < endIndex ; i ++ ) ans += chars [ i ] ; return ans ; }
double AreaofRectangle ( int L , int W ) { double area = ( W + L ) * ( W + L ) / 2 ; return area ; }
int TotalXorPair ( int arr [ ] , int N ) { int totalXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; }
int numberOfWays ( int x ) { int dp [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return n * ( n + 1 ) / 2 ; int d = log10 ( n ) ; int * a = new int [ d + 1 ] ; a [ 0 ] = 0 , a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ceil ( pow ( 10 , i - 1 ) ) ; int p = ceil ( pow ( 10 , d ) ) ; int msd = n / p ; return msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ; }
int countP ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
void checkPalindrome ( int num ) { string str = to_string ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { cout << " No " ; return ; } l ++ ; r -- ; } cout << " Yes " ; return ; }
void countNumbers ( int n , int d ) { int total = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } cout << total ; }
int count ( int N , int B ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( B - 1 ) * pow ( B , i - 1 ) ; } return sum ; }
void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; cout << real << " ▁ + ▁ " << imag << " i " ; }
void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) cout << arr [ i % n ] << " ▁ " ; }
void removeSpecialCharacter ( string s ) { int j = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } cout << s . substr ( 0 , j ) ; }
int convertToASCII ( int N ) { string num = to_string ( N ) ; for ( char ch : num ) { cout << ch << " ▁ ( " << ( int ) ch << " ) STRNEWLINE " ; } }
int minOperation ( int arr [ ] , int N ) { int minOp = INT_MIN ; int minNeg = 0 , maxPos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return abs ( minNeg ) + maxPos ; }
int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; unordered_map < char , int > m ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] and str [ i ] <= r ) ) { cnt ++ ; if ( m [ str [ i ] ] != 1 ) { cout << str [ i ] << " ▁ " ; m [ str [ i ] ] ++ ; } } } return cnt ; }
int truncMod ( int a , int n ) { int q = a / n ; return a - n * q ; }
int maxPrimes ( int n ) { return n / 2 ; }
int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
int squareSum ( int n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
void alter ( long long int x , long long int y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } cout << " X = " << x << " , ▁ " << " Y = " << y ; }
bool is_possible ( string s ) { int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( abs ( one - zero ) == 1 ) ; }
int MinOfCubedDP ( int k ) { int * DP = new int [ k + 1 ] , j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = INT_MAX ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( fabs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - floor ( a / b ) * b ) ) ; }
void printMaxSum ( int arr [ ] , int n ) { int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; }
int singleelement ( int arr [ ] , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; }
int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 7 * n + 3 ; }
int CountSubSet ( int arr [ ] , int n , int X ) { int N = pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
int reachTarget ( int target ) { target = abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { sort ( arrl , arrl + n ) ; sort ( exit , exit + n ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } cout << " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " << max_guests << " ▁ at ▁ time ▁ " << time ; }
int countarray ( int n , int k , int x ) { int dp [ MAXN ] = { 0 } ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
float ellipsearea ( float r ) { if ( r < 0 ) return -1 ; float a = ( 3.14 * r * r ) / 4 ; return a ; }
int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; vector < int > v ( k , 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return -1 ; v [ m ] = 1 ; cnt ++ ; } return -1 ; }
void LargestString ( string * na ) { int N = sizeof ( na ) / sizeof ( na [ 0 ] ) ; int c [ N ] ; int m = 1 ; for ( int j = 0 ; j < N ; j ++ ) { bool character [ 26 ] ; for ( int k = 0 ; k < na [ j ] . size ( ) ; k ++ ) { int x = ( int ) ( na [ j ] [ k ] - ' A ' ) ; if ( na [ j ] [ k ] != ' ▁ ' && character [ x ] == false ) { c [ j ] ++ ; character [ x ] = true ; } } if ( c [ j ] > c [ m ] ) m = j ; } cout << na [ m ] << endl ; }
int findMinSum ( int arr [ ] , int K , int L , int size ) { if ( K * L > size ) return -1 ; int minsum = 0 ; sort ( arr , arr + size ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; }
void factors ( int n ) { int i , j ; cout << "1 ▁ - - > 1 STRNEWLINE " ; for ( i = 2 ; i <= n ; i ++ ) { cout << i << " ▁ - - > " ; for ( j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { cout << j << " , ▁ " ; if ( i / j != j ) cout << i / j << " , ▁ " ; } } cout << " STRNEWLINE " ; } }
int countSymmetric ( unsigned int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
int findXOR ( int Set [ ] , int n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
double volumeRec ( double a , double b , double e , double h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
void findMajority ( int arr [ ] , int n ) { int len = sizeof ( int ) * 8 ; int number = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) count ++ ; } if ( count > ( n / 2 ) ) number += ( 1 << i ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > ( n / 2 ) ) cout << number ; else cout << " Majority ▁ Element ▁ Not ▁ Present " ; }
int bitPos ( int n1 , int n2 ) { if ( n1 == n2 ) return 0 ; int bitCount1 = floor ( log2 ( n1 ) ) + 1 ; int bitCount2 = floor ( log2 ( n2 ) ) + 1 ; int bitDiff = abs ( bitCount1 - bitCount2 ) ; int maxBitCount = max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * pow ( 2 , bitDiff ) ; } else { n1 = n1 * pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
bool isLucky ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
void printPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << " , ▁ " ; } } }
void findEquation ( int A , int B , int C ) { cout << " ( " << C << " ) " << " x ^ 2 ▁ + ( " << B << " ) x ▁ + ▁ ( " << A << " ) ▁ = ▁ 0" ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
int cntEdges ( int n ) { int edges = pow ( 2 , n ) - 2 ; return edges ; }
int maximumTurns ( int arr [ ] , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; }
bool isPossible ( int n , int k , int arr [ ] ) { int sum = arr [ 0 ] , maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; }
bool isdodecagonal ( int N ) { float n = ( 4 + sqrt ( 20 * N + 16 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
string findNumber ( int n , int d ) { string ans = " " ; if ( d != 10 ) { ans += to_string ( d ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += " Impossible " ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; }
int findCount ( string str ) { int result = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) if ( i == ( str [ i ] - ' a ' ) || i == ( str [ i ] - ' A ' ) ) result ++ ; return result ; }
int Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
void computePair ( double K ) { if ( K == 1 ) { cout << " No " ; return ; } else { cout << K * K / ( K - 1 ) << " ▁ " ; cout << K / ( K - 1 ) << endl ; } }
int findPosition ( int n , int f , int b ) { return n - max ( f + 1 , n - b ) + 1 ; }
int maxXorSum ( int n , int k ) { if ( k == 1 ) return n ; int res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
double mixtureConcentration ( int n , int p [ ] ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
int findWaysToPair ( int p ) { int dp [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }
int numberOfArithmeticSequences ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
int min_remove ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = min ( ans , n - j + i - 1 ) ; } } } return ans ; }
void maxGcd ( int a , int b ) { cout << abs ( a - b ) ; }
bool isCornerPresent ( string str , string corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substr ( 0 , cl ) . compare ( corner ) == 0 && str . substr ( n - cl , cl ) . compare ( corner ) == 0 ) ; }
int countSticks ( string str , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str [ i ] - '0' ] ) ; } return cnt ; }
int countFriendsPairings ( int n ) { int dp [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
bool isLucky ( int n ) { static int counter = 2 ; int next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }
int possibleBinaries ( int pos , int ones , int sum , int k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos ] [ ones ] [ sum ] != -1 ) return dp [ pos ] [ ones ] [ sum ] ; int ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos ] [ ones ] [ sum ] = ret ; return dp [ pos ] [ ones ] [ sum ] ; }
int maxDP ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
int minOperation ( int k ) { vector < int > dp ( k + 1 , 0 ) ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
bool graphExists ( vector < int > & a , int n ) { while ( 1 ) { sort ( a . begin ( ) , a . end ( ) , greater < > ( ) ) ; if ( a [ 0 ] == 0 ) return true ; int v = a [ 0 ] ; a . erase ( a . begin ( ) + 0 ) ; if ( v > a . size ( ) ) return false ; for ( int i = 0 ; i < v ; i ++ ) { a [ i ] -- ; if ( a [ i ] < 0 ) return false ; } } }
float Area ( int d , int h1 , int h2 ) { float area ; area = 0.5 * d * ( h1 + h2 ) ; return area ; }
void evenSubMatrix ( int N ) { int even = 1 ; int odd = 2 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( i + j ) % 2 == 0 ) { cout << even << " ▁ " ; even += 2 ; } else { cout << odd << " ▁ " ; odd += 2 ; } } cout << " STRNEWLINE " ; } }
int minsteps ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += abs ( arr [ i ] - pow ( 2 , i ) ) ; } return ans ; }
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return -1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return -1 ; }
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
void findNumbers ( int n ) { int odd = pow ( 10 , n ) - 1 ; int even = odd - 1 ; cout << " Even ▁ = ▁ " << even << endl ; cout << " Odd ▁ = ▁ " << odd ; }
void findUniquePair ( int arr [ ] , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } printf ( " The ▁ unique ▁ pair ▁ is ▁ ( % d , ▁ % d ) " , x , y ) ; }
ll minimum ( ll n ) { ll product = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
int countSquares ( int row , int column ) { int topLeft = min ( row , column ) - 1 ; int bottomRight = 8 - max ( row , column ) ; int topRight = min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = sqrt ( temp ) ; return result ; }
bool canConvert ( string str1 , string str2 ) { int i = 0 , j = 0 ; while ( i < str1 . size ( ) && j < str2 . size ( ) ) { if ( str1 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == '0' && str2 [ j ] == '1' && i + 1 < str1 . size ( ) && str1 [ i + 1 ] == '0' ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i == str1 . size ( ) && j == str2 . size ( ) ) return true ; return false ; }
int countNum ( int arr [ ] , int n ) { int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
int minOperation ( bool arr [ N ] [ M ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == 0 ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; else arr [ k ] [ h ] = 1 ; } } } } } return ans ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = max ( max_sum , i + j ) ; } } return max_sum ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; sort ( arr , arr + n ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
int minimumX ( int n , int k ) { int mini = INT_MAX ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = min ( num2 , mini ) ; } } return mini ; }
void printPFsInPairs ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) cout << i << " * " << n / i << endl ; }
void checksum ( int n , int k ) { float first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ; if ( first_term - int ( first_term ) == 0 ) { for ( int i = first_term ; i <= first_term + k - 1 ; i ++ ) { cout << i << " ▁ " ; } } else cout << " - 1" ; }
int maxLenSub ( int arr [ ] , int n ) { int mls [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
int countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } cout << numbers_rightmost_setbit_K ; }
int main ( ) { string Str = " IDID " ; int N = Str . length ( ) ; int * ptr = DiStirngMatch ( Str ) ; for ( int i = 0 ; i <= N ; i ++ ) cout << ptr [ i ] << " ▁ " ; return 0 ; }
void uniqueElement ( int arr [ ] , int n ) { int x = arr [ 0 ] ; int flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != x ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << " Yes " ; else cout << " No " ; }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
string xoring ( string a , string b , int n ) { string ans = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == b [ i ] ) ans += "0" ; else ans += "1" ; } return ans ; }
int decideWinner ( int a [ ] , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
int findRectNum ( int n ) { return n * ( n + 1 ) ; }
int nextPerfectCube ( int N ) { int nextN = floor ( cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; }
void findPermutation ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) cout << i << " ▁ " ; cout << endl ; }
bool isStraighLineNum ( int N ) { if ( N <= 99 ) return false ; string str = to_string ( N ) ; int d = str [ 1 ] - str [ 0 ] ; for ( int i = 2 ; i < str . length ( ) ; i ++ ) if ( str [ i ] - str [ i - 1 ] != d ) return false ; return true ; }
int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; }
float Area ( float a ) { if ( a < 0 ) return -1 ; float h = 1.268 * a ; float A = 0.70477 * pow ( h , 2 ) ; return A ; }
string search ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return " Found " ; int backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( int i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " Found " ; return " Not ▁ Found " ; } } }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = pow ( 2 , temp ) ; if ( ( N + M ) % 2 != 0 ) cout << ans ; else cout << 2 * ans ; cout << endl ; }
int maxProfit ( int * prices , int n ) { int profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { int day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; }
int countdigits ( int n , int k ) { if ( n == 0 ) return 0 ; int digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }
int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
float find_prob ( int N , float P ) { double dp [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return dp [ N ] ; }
int countReduce ( string & str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += abs ( str [ i ] - str [ n - i - 1 ] ) ; return res ; }
double areaOftriangle ( int side ) { double a = sqrt ( pow ( side / 2 , 2 ) + pow ( side / 2 , 2 ) ) ; double b = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) ; double c = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) ; double s = ( a + b + c ) / 2 ; double area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area ; }
int minOpsToEmptyString ( string s ) { int ans = INT_MIN ; int cn0 = 0 ; int cn1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = max ( { ans , cn0 , cn1 } ) ; } cout << ans ; }
bool isCenteredOctadecagonal ( int N ) { float n = ( 9 + sqrt ( 36 * N + 45 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
bool checkEvenPower ( long long int N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; }
void amendSentence ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { str [ i ] = str [ i ] + 32 ; if ( i != 0 ) cout << " ▁ " ; cout << str [ i ] ; } else cout << str [ i ] ; } }
int minSum ( int a [ ] , int n ) { sort ( a , a + n ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
void findArea ( float a , float b ) { float Area ; Area = 3.142 * a * b ; cout << " Area : ▁ " << Area ; }
int solve ( int A [ ] , int n , int Q [ ] , int q ) { int one = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; int glows = 0 , count = 0 ; if ( one >= ceil ( n / 2 ) ) glows = 1 ; for ( int i = 0 ; i < q ; i ++ ) { int prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= ceil ( n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; }
int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ rhs + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
int longLenSub ( int arr [ ] , int n ) { unordered_map < int , int > um ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . find ( arr [ i ] - 1 ) != um . end ( ) && len < um [ arr [ i ] - 1 ] ) len = um [ arr [ i ] - 1 ] ; if ( um . find ( arr [ i ] + 1 ) != um . end ( ) && len < um [ arr [ i ] + 1 ] ) len = um [ arr [ i ] + 1 ] ; um [ arr [ i ] ] = len + 1 ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } return longLen ; }
int minimizeCost ( int A , int B , int C ) { int ans = A + B + C ; for ( int i = 1 ; i <= 2 * C ; i ++ ) { int j = 0 ; while ( i * j <= 2 * C ) { ans = min ( ans , abs ( A - i ) + abs ( B - j ) + abs ( i * j - C ) ) ; j ++ ; } } return ans ; }
int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
int maxCount ( vector < int > arr , int m , int V ) { vector < int > table ( V + 1 ) ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = -1 ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ j ] <= i ) { int sub_res = table [ i - arr [ j ] ] ; if ( sub_res != -1 && sub_res + 1 > table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
int countBits ( int n ) { int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
string lexicographicSubConcat ( string s ) { int n = s . length ( ) ; int sub_count = n * ( n + 1 ) / 2 ; string arr [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) arr [ index ++ ] = s . substr ( i , len ) ; sort ( arr , arr + sub_count ) ; string res = " " ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
int formQuadruplets ( int arr [ ] , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; }
int countXor ( int N ) { int cnt = N / 2 + 1 ; return cnt ; }
bool checkArray ( int arr [ ] , int n ) { return ( arr [ 0 ] % 2 ) && ( arr [ n - 1 ] % 2 ) && ( n % 2 ) ; }
int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; int smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return -1 ; int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { cout << " n ▁ Found ▁ at ▁ " << i << " , ▁ " << j ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } cout << " n ▁ Element ▁ not ▁ found " ; return 0 ; }
int maxPointCount ( int arr [ ] , int K , int size ) { int curr_points = 0 ; int max_points = 0 ; for ( int i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; int j = size - 1 ; for ( int i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = max ( curr_points , max_points ) ; j -- ; } return max_points ; }
int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = min ( c2 , min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += min ( c2 , c1 ) * 12 ; return sum ; }
void findXOR ( vector < vector < vector < int > > > & mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i ] [ j ] [ k ] ; XOR ^= mat [ i ] [ j ] [ N - k - 1 ] ; } } } } cout << XOR << " STRNEWLINE " ; }
int countConsecutive ( long int N ) { long int count = 0 ; for ( long int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; }
int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
int findOptimalSolution ( int a [ ] , int N ) { sort ( a , a + N ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; }
> ConstructList ( int Q [ N ] [ M ] ) { int xr = 0 ; list < int > ans ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( Q [ i ] [ 0 ] == 0 ) ans . push_back ( Q [ i ] [ 1 ] ^ xr ) ; else xr ^= Q [ i ] [ 1 ] ; } ans . push_back ( xr ) ; ans . sort ( ) ; return ans ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
void findMinXORSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } cout << min_xor << " STRNEWLINE " ; }
int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return -1 ; }
bool isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; }
bool check ( string s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; }
int minimumBox ( int arr [ ] , int n ) { queue < int > q ; queue < int > q ; sort ( arr , arr + n ) ; q . push ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . front ( ) ; if ( arr [ i ] >= 2 * now ) q . pop ( ) ; q . push ( arr [ i ] ) ; } return q . size ( ) ; }
int minSteps ( int N ) { int count = 1 , res = 0 ; for ( int i = 1 ; i <= N ; i += count ) { res = max ( res , count ) ; count ++ ; } return res ; }
string convert ( string s ) { int n = s . length ( ) ; s [ 0 ] = tolower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s [ i + 1 ] = tolower ( s [ i + 1 ] ) ; i ++ ; } else s [ i ] = toupper ( s [ i ] ) ; } return s ; }
int lucas ( int n ) { int a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
void maxModProdSubarr ( int arr [ ] , int n , int M ) { int ans = 0 ; int length = n ; for ( int i = 0 ; i < n ; i ++ ) { int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } cout << " Maximum ▁ subarray ▁ product ▁ is ▁ " << ans << endl ; cout << " Minimum ▁ length ▁ of ▁ the ▁ maximum ▁ product ▁ " << " subarray ▁ is ▁ " << length << endl ; }
void subString ( char str [ ] , int n ) { for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; for ( int k = i ; k <= j ; k ++ ) cout << str [ k ] ; cout << endl ; } } }
int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
int findMinSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = * max_element ( arr , arr + n ) ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = max ( ans , count ) ; } return ans ; }
int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; }
int countTriplets ( int N , int K ) { if ( K % 2 == 0 ) { long long int x = N / K ; long long int y = ( N + ( K / 2 ) ) / K ; return x * x * x + y * y * y ; } else { long long int x = N / K ; return x * x * x ; } }
void findString ( int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { cout << char ( ' A ' + i % K ) ; } }
int maximumK ( string & S ) { int N = S . length ( ) ; int ans = N ; int flag = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) { flag = 1 ; ans = min ( ans , max ( i + 1 , N - i - 1 ) ) ; } } if ( flag == 0 ) return 0 ; return ans ; }
void countPairsWithDiffK ( int arr [ ] , int N , int K ) { int vis [ N ] ; memset ( vis , 0 , sizeof ( vis ) ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( vis [ i ] == 1 ) continue ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( vis [ j ] == 1 ) continue ; if ( abs ( arr [ i ] - arr [ j ] ) >= K ) { count ++ ; vis [ i ] = 1 ; vis [ j ] = 1 ; break ; } } } cout << count << ' ▁ ' ; }
int getModulo ( unsigned int n , unsigned int d ) { return ( n & ( d - 1 ) ) ; }
int minSumPath ( vector < vector < int > > & A ) { int memo [ A . size ( ) ] ; int n = A . size ( ) - 1 ; for ( int i = 0 ; i < A [ n ] . size ( ) ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . size ( ) - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
int angle ( int n ) { return 2 * n ; }
int condition ( int a , int b ) { int d = abs ( a - b ) , count = 0 ; for ( int i = 1 ; i <= sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; }
int count_minimum_operations ( long long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
bool istriacontagonal ( int N ) { float n = ( 26 + sqrt ( 224 * N + 676 ) ) / 56 ; return ( n - ( int ) n ) == 0 ; }
int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
int longestCommonSum ( bool arr1 [ ] , bool arr2 [ ] , int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
void countFreq ( int a [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] ) { cout << a [ i ] << " - > " << cumul << endl ; } hm [ a [ i ] ] = 0 ; } }
long findTripleSum ( long long A , long long B , long long C ) { long long sum = 0 ; for ( long long i = 1 ; i <= A ; i ++ ) { for ( long long j = 1 ; j <= B ; j ++ ) { for ( long long k = 1 ; k <= C ; k ++ ) { long long prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
int findNthNonSquare ( int n ) { long double x = ( long double ) n ; long double ans = x + floor ( 0.5 + sqrt ( x ) ) ; return ( int ) ans ; }
int Moves_Calculator ( int x , int y , int row , int col ) { int total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; int king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
bool isEditDistanceOne ( string s1 , string s2 ) { int m = s1 . length ( ) , n = s2 . length ( ) ; if ( abs ( m - n ) > 1 ) return false ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; { i ++ ; j ++ ; } count ++ ; } { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; }
void isValid ( string s ) { int n = sqrt ( s . length ( ) ) ; char check = s [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = i , y = i ; while ( x >= 0 && y < n ) { if ( s [ ( n * x ) + y ] != check || s [ ( n * y ) + x ] != check ) { cout << " No " << endl ; return ; } x -- ; y ++ ; } } cout << " Yes " << endl ; }
void findLast ( int mat [ ] [ 3 ] ) { int m = 3 ; int n = 3 ; set < int > rows ; set < int > cols ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . insert ( i ) ; cols . insert ( j ) ; } } } int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ; int choices = min ( avRows , avCols ) ; if ( choices & 1 ) cout << " P1" ; else cout << " P2" ; }
int minDistance ( int start [ ] , int end [ ] , int n , int d ) { int left = INT_MIN ; int right = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { left = max ( left , start [ i ] ) ; right = min ( right , end [ i ] ) ; } if ( left > right ) return -1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return ( left - d ) ; if ( d > right ) return ( d - right ) ; }
int countOfSubstringWithOnlyOnes ( string s ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count = s [ i ] == '1' ? count + 1 : 0 ; res = ( res + count ) ; } return res ; }
int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; return solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
float findRadiusOfIncircle ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0 ) return -1 ; float p = ( a + b + c ) / 2 ; float area = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float radius = area / p ; return radius ; }
int maxOR ( long long arr [ ] , int n , int k , int x ) { long long preSum [ n + 1 ] , suffSum [ n + 1 ] ; long long res , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
bool check ( int X , int K ) { int prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = sqrt ( X ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = temp / i ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; }
int minDiffSubArray ( int arr [ ] , int n ) { int prefix_sum [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int suffix_sum [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int minDiff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
void findNumbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) cout << "1" << " ▁ " ; cout << "2" << " ▁ " ; cout << n + d << endl ; }
int calculateSum ( int n ) { return ( pow ( 2 , n + 1 ) + n - 2 ) ; }
float hexadiagonal ( float a ) { if ( a < 0 ) return -1 ; return 2 * a ; }
double findPCSlope ( double m ) { return -1.0 / m ; }
bool isProductEven ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) cout << " NO " ; else cout << " YES " ; }
int countTriplets ( int arr [ ] , int n , int sum ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; }
long largestNumber ( int N ) { if ( N > 45 ) return -1 ; int num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
int findWater ( int arr [ ] , int n ) { int left [ n ] ; int right [ n ] ; int water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) left [ i ] = max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) right [ i ] = max ( right [ i + 1 ] , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) water += min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; }
float geometricMean ( int arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + log ( arr [ i ] ) ; sum = sum / n ; return exp ( sum ) ; }
int minSteps ( string S ) { string new_str ; int N = S . length ( ) ; int i = 0 ; while ( i < N ) { new_str += S [ i ] ; int j = i ; while ( i < N && S [ i ] == S [ j ] ) ++ i ; } cout << ceil ( ( new_str . size ( ) + 1 ) / 2.0 ) ; }
int countSubstrings ( string s , char c ) { int n = s . length ( ) ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
void checkSamePosition ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . find ( temp ) != mp . end ( ) ) { cout << " Yes " ; return ; } mp [ temp ] ++ ; } cout << " No " ; }
float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }
int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
int myXOR ( int x , int y ) { return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) ; }
void possibleToReach ( int x , int y , int z ) { if ( z < abs ( x ) + abs ( y ) || ( z - abs ( x ) - abs ( y ) ) % 2 ) { cout << " Not ▁ Possible " << endl ; } else cout << " Possible " << endl ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = max ( l , a ) ; int R = min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { sort ( A , A + m ) ; sort ( B , B + n ) ; int a = 0 , b = 0 ; int result = INT_MAX ; while ( a < m && b < n ) { if ( abs ( A [ a ] - B [ b ] ) < result ) result = abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
long sum_all_divisors ( long long num ) { long long sum = 0 ; for ( long long i = 1 ; i <= sqrt ( num ) ; i ++ ) { sum += t1 + t2 ; } return sum ; }
int ways ( int n ) { return n / 2 ; }
bool canVote ( int a [ ] , int n , int x ) { int dp [ n + 1 ] [ x + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += a [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; return ( sum - dp [ n ] [ x ] <= x ) ; }
ll countMaxIntersect ( ll n ) { return ( n ) * ( n - 1 ) / 2 ; }
int findIndex ( int a [ ] , int n ) { int res ; ll min_diff = INT_MAX ; ll prod [ n ] ; prod [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ll curr_diff = abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
int maxSum ( int a [ ] , int n ) { int ans = 0 ; int * arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int * * dp = new int * [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = new int [ 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = max ( ans , dp [ i ] [ 0 ] ) ; ans = max ( ans , dp [ i ] [ 1 ] ) ; ans = max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
int findMaxK ( int N ) { int p = log2 ( N ) ; return pow ( 2 , p ) ; }
void translate ( char * str ) { if ( str [ 0 ] == ' ' ) return ; for ( int i = 1 ; str [ i ] != ' ' ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; for ( int j = i ; str [ j ] != ' ' ; j ++ ) str [ j ] = str [ j + 1 ] ; } } return ; }
void countEle ( stack < int > & s , int a [ ] , int N ) { unordered_map < int , bool > mp ; for ( int i = 0 ; i < N ; ++ i ) { int num = a [ i ] ; if ( mp . find ( num ) != mp . end ( ) ) cout << "0 ▁ " ; else { int cnt = 0 ; while ( s . top ( ) != num ) { mp [ s . top ( ) ] = true ; s . pop ( ) ; cnt ++ ; } s . pop ( ) ; cnt ++ ; cout << cnt << " ▁ " ; } } }
int getMinOps ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; }
bool isPerfectCubeString ( string str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) sum += ( int ) str [ i ] ; long double cr = round ( cbrt ( sum ) ) ; return ( cr * cr * cr == sum ) ; }
int countPairs ( int a [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
float area ( float a ) { if ( a < 0 ) return -1 ; float area = sqrt ( a ) / 6 ; return area ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; }
float productOfGP ( float a , float r , int n ) { return pow ( a , n ) * pow ( r , n * ( n - 1 ) / 2 ) ; }
int power ( long long x , unsigned int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; }
void PrintIndexes ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int currSubSum = 0 ; for ( int j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; int sq = sqrt ( currSubSum ) ; if ( sq * sq == currSubSum ) { cout << " ( " << i << " , ▁ " << j << " ) ▁ " ; } } } }
void printArray ( int * a , int n ) { sort ( a , a + n ) ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( i == j ) { cout << a [ i ] << " ▁ " ; } else { cout << a [ j ] << " ▁ " ; cout << a [ i ] << " ▁ " ; } i = i + 1 ; j = j - 1 ; } cout << endl ; }
int det ( int d [ ] [ 3 ] ) { int Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) ; Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) ; Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) ; return Sum ; }
void minSum ( int N ) { int ans = ceil ( 2 * sqrt ( N + 1 ) ) ; cout << ans ; }
void countSamePrefixSuffix ( string s , int n ) { string prefix = " " ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix += s [ i ] ; string suffix = s . substr ( n - 1 - i , n - 1 ) ; if ( prefix == suffix ) { cout << prefix . size ( ) << " ▁ " ; } } }
int findSingle ( int ar [ ] , int ar_size ) { int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
float rectanglearea ( float r ) { if ( r < 0 ) return -1 ; float a = r * r ; return a ; }
void operations ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; ll i = 0 , sum = 0 ; while ( k -- ) { while ( i < n && arr [ i ] - sum == 0 ) i ++ ; if ( i < n && arr [ i ] - sum > 0 ) { cout << arr [ i ] - sum << " ▁ " ; sum = arr [ i ] ; } else cout << 0 << endl ; } }
int find_next ( int n , int k ) { int M = n + 1 ; while ( 1 ) { if ( M & ( 1ll << k ) ) break ; M ++ ; } return M ; }
void findRange ( int arr [ ] , int N , int K ) { int L = INT_MIN ; int R = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { int l = ( int ) ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; int r = ( int ) ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = max ( L , l ) ; R = min ( R , r ) ; } cout << L << " ▁ " << R ; }
int countDigit ( int n ) { bool prime [ 10 ] ; memset ( prime , false , sizeof ( prime ) ) ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] ) count ++ ; } return count ; }
int minSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int x = arr [ n / 2 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += abs ( arr [ i ] - x ) ; return sum ; }
float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float R = ( ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) ) / 2 ; return R ; }
void checkValidPolygon ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) cout << " Yes " ; else cout << " No " ; }
void printSubstrings ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) { cout << str [ k ] ; } cout << endl ; } } }
bool isPower ( int x , int y ) { int res1 = log ( y ) / log ( x ) ; return ( res1 == res2 ) ; }
int max_sum ( int a [ ] , int n ) { vector < vector < int > > dp ( n + 1 , vector < int > ( 2 , 0 ) ) ; dp [ 0 ] [ 0 ] = 0 , dp [ 0 ] [ 1 ] = -999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; }
void path_to_root ( int node ) { while ( node >= 1 ) { cout << node << ' ▁ ' ; node /= 2 ; } }
bool Survives ( int n ) { int i ; for ( int i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= n / i ; } }
void printThreeParts ( int N ) { if ( N % 3 == 0 ) cout << " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " << N - 2 << endl ; else cout << " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " << N - 3 << endl ; }
int intersection ( int n ) { return n * ( n - 1 ) ; }
int calculateSum ( string arr [ ] , int n ) { if ( n == 0 ) return 0 ; string s = arr [ 0 ] ; int value = stoi ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; int value = stoi ( s ) ; char operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
int count_pairs ( int arr [ ] , int brr [ ] , int N , int M , int K ) { int i = 0 ; int j = 0 ; int cntPairs = 0 ; sort ( arr , arr + N ) ; sort ( brr , brr + M ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
bool isSortedArray ( int arr [ ] , int n ) { int l = 0 , r = ( n - 1 ) ; while ( ( l + 1 ) < r ) { if ( arr [ l ] >= max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l ++ ; r -- ; } else { return false ; } } return true ; }
int strScore ( string str [ ] , string s , int n ) { unordered_map < string , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ str [ i ] ] = i + 1 ; if ( m . find ( s ) == m . end ( ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) score += s [ i ] - ' a ' + 1 ; score = score * m [ s ] ; return score ; }
int findDivisor ( int x , int y ) { if ( x == y ) return y ; return 2 ; }
void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; }
void nDigitPerfectCubes ( int n ) { cout << pow ( ceil ( cbrt ( pow ( 10 , ( n - 1 ) ) ) ) , 3 ) << " ▁ " ; cout << ( int ) pow ( ceil ( cbrt ( pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ; }
bool isEven ( int n ) { bool isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
void differentStrings ( string s ) { int n = s . length ( ) ; vector dp ( n + 1 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] && ( s [ i ] == '1' s [ i ] == '2' ) ) dp [ i + 1 ] = dp [ i ] + dp [ i - 1 ] ; else dp [ i + 1 ] = dp [ i ] ; } cout << dp [ n ] << " STRNEWLINE " ; }
bool unique ( string s ) { sort ( s . begin ( ) , s . end ( ) ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { return false ; break ; } } return true ; }
int minIndex ( int arr [ ] , int n , int pos ) { int num = arr [ pos ] ; int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
void pairStar ( string & input , string & output , int i = 0 ) { output = output + input [ i ] ; if ( i == input . length ( ) - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' * ' ; pairStar ( input , output , i + 1 ) ; }
int findMinSoln ( int n , int k ) { int minSoln = INT_MAX ; for ( int i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; }
void rangeSum ( int arr [ ] , int N , int L , int R ) { int prefix [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; cout << rightsum - leftsum ; }
bool checkSequence ( string a , string b ) { if ( b . size ( ) == 0 ) return true ; if ( a . size ( ) == 0 ) return false ; if ( a [ 0 ] == b [ 0 ] ) return checkSequence ( a . substr ( 1 ) , b . substr ( 1 ) ) ; else return checkSequence ( a . substr ( 1 ) , b ) ; }
void printLargest ( int a [ ] , int n ) { int max = -1 ; int ind = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( int i = ind ; i < n ; i ++ ) cout << a [ i ] ; for ( int i = 0 ; i < ind ; i ++ ) cout << a [ i ] ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; sort ( arr , arr + n ) ; int left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
bool checkSentence ( char str [ ] ) { int len = strlen ( str ) ; if ( str [ 0 ] < ' A ' str [ 0 ] > ' Z ' ) return false ; if ( str [ len - 1 ] != ' . ' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( str [ index ] ) { if ( str [ index ] >= ' A ' && str [ index ] <= ' Z ' ) curr_state = 0 ; else if ( str [ index ] == ' ▁ ' ) curr_state = 1 ; else if ( str [ index ] >= ' a ' && str [ index ] <= ' z ' ) curr_state = 2 ; else if ( str [ index ] == ' . ' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( str [ index + 1 ] == ' \0' ) ; index ++ ; prev_state = curr_state ; } return false ; }
int minimumSwaps ( int arr [ ] , int n ) { int count = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; }
bool sameEulerTotient ( int N ) { return ( N & 1 ) ; }
int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; }
long polynomialRollingHash ( string const & str ) { int p = 31 ; int m = 1e9 + 9 ; long long power_of_p = 1 ; long long hash_val = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { hash_val = ( hash_val + ( str [ i ] - ' a ' + 1 ) * power_of_p ) % m ; power_of_p = ( power_of_p * p ) % m ; } return ( hash_val % m + m ) % m ; }
bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] [ n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ; for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i ] [ 0 ] = false ; for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } } return part [ sum / 2 ] [ n ] ; }
int octahedral_num ( int n ) { return n * ( 2 * n * n + 1 ) / 3 ; }
void rearrange ( int arr [ ] , int n ) { if ( arr == NULL n % 2 == 1 ) return ; int currIdx = ( n - 1 ) / 2 ; while ( currIdx > 0 ) { int count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } }
void decToHexa ( int n ) { char hexaDeciNum [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = temp + 48 ; i ++ ; } else { hexaDeciNum [ i ] = temp + 55 ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << hexaDeciNum [ j ] ; }
void findTriangle ( int a [ ] , int n ) { int b [ n + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; sort ( a , a + n ) ; sort ( b , b + n ) ; int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += max ( p - j , 0 ) ; z += q - p ; } } } cout << " Acute ▁ Triangle : ▁ " << x << endl ; cout << " Right ▁ Triangle : ▁ " << y << endl ; cout << " Obtuse ▁ Triangle : ▁ " << z << endl ; }
int twoEggDrop ( int k ) { return ceil ( ( -1.0 + sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; }
int make_permutation ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += abs ( i + 1 - arr [ i ] ) ; return ans ; }
boolean getBit ( int num , int i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }
int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
void maxSubmatrixSum ( vector < vector < int > > matrix ) { int r = matrix . size ( ) ; int c = matrix [ 0 ] . size ( ) ; int maxSubmatrix = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int k = i ; k < r ; k ++ ) { for ( int l = j ; l < c ; l ++ ) { int sumSubmatrix = 0 ; for ( int m = i ; m <= k ; m ++ ) { for ( int n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m ] [ n ] ; } } maxSubmatrix = max ( maxSubmatrix , sumSubmatrix ) ; } } } } cout << maxSubmatrix ; }
int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
void sumArray ( int arr [ ] , int n ) { int leftSum [ n ] , rightSum [ n ] , Sum [ n ] , i , j ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) cout << Sum [ i ] << " ▁ " ; }
int findDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = max ( max_count , count ) ; min_count = min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 and x < x2 and y > y1 and y < y2 ) return true ; return false ; }
int maximumXOR ( int arr [ ] , int n , int K ) { K ++ ; int maxXor = INT_MIN ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { if ( __builtin_popcount ( i ) == K ) { int cur_xor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) cur_xor = cur_xor ^ arr [ j ] ; } maxXor = max ( maxXor , cur_xor ) ; } } return maxXor ; }
int solve ( int A [ ] , int B [ ] , int C [ ] , int i , int j , int k ) { int min_diff , current_diff , max_term ; min_diff = Integer . MAX_VALUE ; while ( i != -1 && j != -1 && k != -1 ) { current_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
int findMinSum ( long long int a [ ] , long long int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ; return sum ; }
void max_valid_triplet ( int A [ ] , int n ) { int ans = -1 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { int value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } cout << ( ans ) ; }
float find ( int N , int a , int b ) { float probability = 0.0 ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = 1.0 / 6 ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; }
string smallest ( string s ) { int l = s . length ( ) ; string ans = " " ; for ( int i = 0 ; i < l - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) { for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) ans += s [ j ] ; } return ans ; } } ans = s . substr ( 0. , l - 1 ) ; return ans ; }
int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
int firstNonRepeating ( char * str ) { int arr [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = -1 ; for ( int i = 0 ; str [ i ] ; i ++ ) { if ( arr [ str [ i ] ] == -1 ) arr [ str [ i ] ] = i ; else arr [ str [ i ] ] = -2 ; } int res = INT_MAX ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = min ( res , arr [ i ] ) ; return res ; }
int countPairs ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
int countSticks ( string str ) { int cnt = 0 ; for ( int i = 0 ; str [ i ] ; i ++ ) { char ch = str [ i ] ; if ( ch >= ' A ' && ch <= ' Z ' ) { cnt += sticks [ ch - ' A ' ] ; } else { cnt += number [ ch - '0' ] ; } } return cnt ; }
int findProduct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) prod = prod * arr [ i ] ; } return prod ; }
int removeRecur ( long int n ) { int prev_digit = n % 10 ; long int pow = 10 ; long int res = prev_digit ; while ( n ) { int curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; }
void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) cout << a << " ▁ " ; if ( n >= 1 ) cout << b << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; cout << c << " ▁ " ; a = b ; b = c ; } }
int nextPowerOfFour ( int n ) { int x = floor ( sqrt ( sqrt ( n ) ) ) ; if ( pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return pow ( x , 4 ) ; } }
int countBT ( int h ) { long long int dp [ h + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod ; } return dp [ h ] ; }
int missingNumber ( int arr1 [ ] , int arr2 [ ] , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
int summation ( int N ) { int co = ( N + 1 ) / 2 ; int ce = ( N ) / 2 ; int se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; int so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; }
int XorSum ( int A [ ] , int B [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; }
int minOperations ( int A [ ] , int n ) { if ( n & 1 ) return -1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { A [ i ] == 0 ? zeros ++ : ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return -1 ; }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = max ( buy , sell - arr [ i ] ) ; sell = max ( sell , temp + arr [ i ] - transactionFee ) ; } return max ( sell , buy ) ; }
int minCost ( string s , int n ) { int minValue = 100000000 ; for ( int i = 0 ; i <= 25 ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { cnt += min ( abs ( i - ( s [ j ] - ' a ' ) ) , 26 - abs ( i - ( s [ j ] - ' a ' ) ) ) ; } minValue = min ( minValue , cnt ) ; } return minValue ; }
int countLastDigitK ( long long low , long long high , long long K ) { long long mlow = 10 * ceil ( low / 10.0 ) ; long long mhigh = 10 * floor ( high / 10.0 ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= K ) count ++ ; if ( low % 10 <= K && ( low % 10 ) ) count ++ ; return count ; }
bool DivisibleBy41 ( int first , int second , int c , int n ) { int digit [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
void generateStr ( char * a , char * b , string s , int count , int len ) { if ( count == len ) { cout << s << endl ; return ; } generateStr ( a + 1 , b + 1 , s + ( * a ) , count + 1 , len ) ; generateStr ( a + 1 , b + 1 , s + ( * b ) , count + 1 , len ) ; }
int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
void maxDivisions ( int arr [ ] , int N , int X ) { sort ( arr , arr + N , greater < int > ( ) ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } cout << maxSub << endl ; }
int HogbenNumber ( int a ) { int p = ( pow ( a , 2 ) - a + 1 ) ; return p ; }
void countPairs ( int A [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } cout << count ; }
string nthprimedigitsnumber ( int number ) { int rem ; string num ; while ( number ) { rem = number % 4 ; switch ( rem ) { case 1 : num . push_back ( '2' ) ; break ; case 2 : num . push_back ( '3' ) ; break ; case 3 : num . push_back ( '5' ) ; break ; case 0 : num . push_back ( '7' ) ; break ; } if ( number % 4 == 0 ) number -- ; number = number / 4 ; } reverse ( num . begin ( ) , num . end ( ) ) ; return num ; }
void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }
void occurredOnce ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; if ( arr [ 0 ] != arr [ 1 ] ) cout << arr [ 0 ] << " ▁ " ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) cout << arr [ i ] << " ▁ " ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) cout << arr [ n - 1 ] << " ▁ " ; }
int findMinRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
void checkIfCurzonNumber ( int N ) { long int powerTerm , productTerm ; powerTerm = pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; }
bool isMajority ( int arr [ ] , int n , int x ) { int i ; int last_index = n % 2 ? ( n / 2 + 1 ) : ( n / 2 ) ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return 1 ; } return 0 ; }
int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = INT_MAX ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { int x = abs ( i - A ) ; int y = abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ) ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i ] [ curr ] ; }
int minOperations ( int n , int m ) { int a = 0 , k = 1 ; int p = max ( n , m ) ; while ( n != m ) { float s = ( float ) ( p - n + p - m ) ; float q = ( -1 + sqrt ( 8 * s + 1 ) ) / 2 ; if ( q - floor ( q ) == 0 ) { a = q ; n = m ; } p = p + 1 ; } return a ; }
int lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } printf ( " % 05d " , ans ) ; }
float Length_Diagonal ( int a , int b , int d ) { float diagonal = sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; }
float rmsValue ( int arr [ ] , int n ) { int square = 0 ; float mean = 0.0 , root = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { square += pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = sqrt ( mean ) ; return root ; }
int maxArea ( int A [ ] , int len ) { int area = 0 ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { area = max ( area , min ( A [ j ] , A [ i ] ) * ( j - i ) ) ; } } return area ; }
bool isValidSeq ( int a [ ] , int n ) { int nodes = n + 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 a [ i ] > nodes ) return false ; } return true ; }
void findAngles ( double a , double b , double c , double d ) { double numerator = a * a + d * d - b * b - c * c ; double denominator = 2 * ( a * b + c * d ) ; double x = numerator / denominator ; cout << fixed << setprecision ( 2 ) << " A : ▁ " << ( acos ( x ) * 180 ) / 3.141592 << " ▁ degrees " ; numerator = a * a + b * b - c * c - d * d ; x = numerator / denominator ; cout << fixed << setprecision ( 2 ) << " STRNEWLINE B : ▁ " << ( acos ( x ) * 180 ) / 3.141592 << " ▁ degrees " ; numerator = c * c + b * b - a * a - d * d ; x = numerator / denominator ; cout << fixed << setprecision ( 2 ) << " STRNEWLINE C : ▁ " << ( acos ( x ) * 180 ) / 3.141592 << " ▁ degrees " ; numerator = d * d + c * c - a * a - b * b ; x = numerator / denominator ; cout << fixed << setprecision ( 2 ) << " STRNEWLINE D : ▁ " << ( acos ( x ) * 180 ) / 3.141592 << " ▁ degrees " ; }
int lenoflongestnonpalindrome ( string s ) { int max1 = 1 , len = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) len = 0 ; else if ( s [ i + 1 ] == s [ i - 1 ] && i > 0 ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
void incrementCount ( int arr [ ] , int N ) { int mini = arr [ 0 ] - arr [ 1 ] ; for ( int i = 2 ; i < N ; i ++ ) { mini = min ( mini , arr [ i - 1 ] - arr [ i ] ) ; } cout << mini ; }
void genSequence ( int n , int val ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int x = i ^ ( i >> 1 ) ^ val ; cout << x << " ▁ " ; } }
void maxValueAtIndexK ( int N , int K , int M ) { int S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; int X = ( M + S1 + S2 ) / N ; cout << X ; }
int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }
int getMin ( int arr [ ] , int n ) { int minVal = * min_element ( arr , arr + n ) ; return minVal ; }
int countkDist ( string str , int k ) { int n = str . length ( ) ; int res = 0 ; int cnt [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - ' a ' ] == 0 ) dist_count ++ ; cnt [ str [ j ] - ' a ' ] ++ ; if ( dist_count == k ) res ++ ; if ( dist_count > k ) break ; } } return res ; }
bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }
void performQuery ( vector < int > arr , vector < vector < int > > Q ) { for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { int or1 = 0 ; int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( int j = 0 ; j < arr . size ( ) ; j ++ ) { or1 = or1 | arr [ j ] ; } cout << or1 << " ▁ " ; } }
double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / pow ( 2 , fold ) ; }
float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return -1 ; float r1 = r ; float h1 = h ; float V = 3.14 * pow ( r1 , 2 ) * h1 ; return V ; }
int SquareRoot ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; }
double getTime ( int u , int v , int x ) { double speed = u + v ; double time = x / speed ; return time ; }
int waysOfDecoding ( string s ) { vector < int > dp ( ( int ) s . size ( ) + 1 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != '0' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ ( int ) s . size ( ) ] ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
void smallestNumber ( int N ) { cout << N * ceil ( pow ( 2 , ( N - 1 ) ) / N ) ; }
int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - pow ( i , 2 ) ; else result = result + pow ( i , 2 ) ; } return result ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int findXor ( int arr [ ] , int n ) { int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }
int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( max ( X , Y ) / min ( X , Y ) ) ; else return ( max ( 2 * X , Y ) / min ( 2 * X , Y ) ) ; }
double Area_of_Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * sqrt ( x ) ; return area ; }
float find_Area ( float a ) { float R = a * ( 2.0 - sqrt ( 2 ) ) ; float area = 3.14 * R * R / 2.0 ; return area ; }
void mulsum ( int arr [ ] , int n , int N ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } cout << sum ; }
int kthNonDivisible ( int N , int K ) { return K + floor ( ( K - 1 ) / ( N - 1 ) ) ; }
int concentric_Hexagon ( int n ) { return 3 * pow ( n , 2 ) / 2 ; }
bool check ( int arr [ ] , int n ) { int count = 0 ; int index = -1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) { count ++ ; index = i ; } } if ( count > 1 ) return false ; if ( count == 0 ) return true ; if ( index == n - 1 index == 1 ) return true ; if ( arr [ index - 1 ] < arr [ index + 1 ] ) return true ; if ( index - 2 >= 0 && arr [ index - 2 ] < arr [ index ] ) return true ; if ( index < 0 ) return true ; return false ; }
void SternSequenceFunc ( vector < int > & BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push_back ( considered_element + precedent ) ; BrocotSequence . push_back ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) cout << BrocotSequence [ i ] << " ▁ " ; }
unsigned countWords ( char * str ) { int state = OUT ; unsigned wc = 0 ; while ( * str ) { if ( * str == ' ▁ ' * str == ' ' * str == ' TABSYMBOL ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ str ; } return wc ; }
int oppositeFaceOfDice ( int N ) { int ans = 7 - N ; cout << ans ; }
int getOddOccurrence ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return -1 ; }
long count_strings ( long n ) { int x = 1 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( 1 << x ) ; } return x - 1 ; }
int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }
int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; }
void newvol ( double x ) { cout << " percentage ▁ increase ▁ " << " in ▁ the ▁ volume ▁ of ▁ the ▁ cylinder ▁ is ▁ " << x << " % " << endl ; }
int icosikaiheptagonalNum ( int n ) { return ( 25 * n * n - 23 * n ) / 2 ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 3 * n - 5 ; }
void findOptimalPairs ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << " ▁ " ; }
float area ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float A = a * b ; return A ; }
int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }
bool isWordPresent ( string sentence , string word ) { stringstream s ( sentence ) ; string temp ; while ( s >> temp ) { if ( temp . compare ( word ) == 0 ) { return true ; } } return false ; }
void solve ( int n , int d , int input [ ] ) { int a [ N ] ; int cnt [ V + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) a [ i ] = input [ i ] ; int answer = 0 ; for ( int i = 0 ; i < d ; ++ i ) cnt [ a [ i ] ] ++ ; for ( int i = d ; i <= n - 1 ; ++ i ) { int acc = 0 ; int low_median = -1 , high_median = -1 ; for ( int v = 0 ; v <= V ; ++ v ) { acc += cnt [ v ] ; if ( low_median == -1 && acc >= int ( floor ( ( d + 1 ) / 2.0 ) ) ) low_median = v ; if ( high_median == -1 && acc >= int ( ceil ( ( d + 1 ) / 2.0 ) ) ) high_median = v ; } int double_median = low_median + high_median ; if ( a [ i ] >= double_median ) answer ++ ; cnt [ a [ i - d ] ] -- ; cnt [ a [ i ] ] ++ ; } cout << answer << endl ; }
void minimumCost ( int arr [ ] , int cost [ ] , int N ) { vector < vector < int > > dp ( N , vector < int > ( 3 ) ) ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = cost [ 0 ] ; dp [ 0 ] [ 2 ] = cost [ 0 ] * 2 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int minimum = 1e6 ; if ( j + arr [ i ] != arr [ i - 1 ] ) minimum = min ( minimum , dp [ i - 1 ] [ 0 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 1 ) minimum = min ( minimum , dp [ i - 1 ] [ 1 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 2 ) minimum = min ( minimum , dp [ i - 1 ] [ 2 ] ) ; dp [ i ] [ j ] = j * cost [ i ] + minimum ; } } int ans = 1e6 ; for ( int i = 0 ; i < 3 ; i ++ ) ans = min ( ans , dp [ N - 1 ] [ i ] ) ; cout << ans << " STRNEWLINE " ; }
double distance ( int r , int R ) { double d = sqrt ( pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
int CtSubarr ( int arr [ ] , int N , int K ) { unordered_set < int > st ; int prefixSum = 0 ; st . insert ( prefixSum ) ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefixSum += arr [ i ] ; if ( st . count ( prefixSum - K ) ) { res += 1 ; prefixSum = 0 ; st . clear ( ) ; st . insert ( 0 ) ; } st . insert ( prefixSum ) ; } return res ; }
void shuffle ( int N , int key ) { unsigned int NO_OF_BITS = N ; unsigned int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } cout << reverse_num ; }
int nextFibonacci ( int n ) { double a = n * ( 1 + sqrt ( 5 ) ) / 2.0 ; return round ( a ) ; }
int nthOdd ( int n ) { return ( 2 * n - 1 ) ; }
void findpair ( int l , int r ) { int ans1 = l ; int ans2 = 2 * l ; cout << ans1 << " , ▁ " << ans2 << endl ; }
bool isCenteredtridecagonal ( int N ) { float n = ( 13 + sqrt ( 104 * N + 65 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; }
int printNumber ( int N , int K , int M ) { int sum = K * ( M * ( M + 1 ) / 2 ) ; return sum - N ; }
int minSteps ( int N ) { int res = ( sqrt ( 1 + 8 * N ) - 1 ) / 2 ; return res ; }
float sumOfSeries ( int x , int k ) { return ( float ( x ) / 81 ) * ( 9 * k - 1 + pow ( 10 , ( -1 ) * k ) ) ; }
void findEquation ( int A , int B , int C , int K ) { cout << A << " ▁ " << K * B << " ▁ " << K * K * C ; }
int steps ( int source , int step , int dest ) { if ( abs ( source ) > ( dest ) ) return INT_MAX ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return min ( pos , neg ) ; }
int xorOfArray ( int arr [ ] , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }
int solve ( int N , int M , int cp [ ] , int sp [ ] ) { int profit [ N ] ; for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; sort ( profit , profit + N , greater < int > ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
int minOperations ( int N ) { double x = log2 ( N ) ; int ans = ceil ( x ) ; return ans ; }
bool isTrimorphic ( int N ) { int cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N /= 10 ; cube /= 10 ; } return true ; }
void asciiToSentence ( string str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; cout << ch ; num = 0 ; } } }
int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }
int squares ( int l , int b , int a ) { return ceil ( l / ( double ) a ) * ceil ( b / ( double ) a ) ; }
int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; sort ( arr , arr + n ) ; if ( n < m ) return -1 ; int min_diff = INT_MAX ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
float squareArea ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( 1.268 , 2 ) * pow ( a , 2 ) ; return area ; }
int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; }
void FindTrip ( int arr [ ] , int N ) { for ( int i = 1 ; i < N - 1 ; i ++ ) { int p = arr [ i - 1 ] ; int q = arr [ i ] ; int r = arr [ i + 1 ] ; if ( p < q && q > r ) { cout << i - 1 << " ▁ " << i << " ▁ " << i + 1 ; return ; } } cout << -1 ; }
int sum ( long long int n ) { long long int root = sqrt ( n ) ; long long int ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }
int titleToNumber ( string s ) { int result = 0 ; for ( const auto & c : s ) { result *= 26 ; result += c - ' A ' + 1 ; } return result ; }
bool isPentadecagon ( int N ) { float n = ( 11 + sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; }
int minJumps ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int res = INT_MAX ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { int sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != INT_MAX ) res = min ( res , sub_res + 1 ) ; } } return res ; }
string make_string_S_to_T ( string S , string T ) { bool possible = false ; int M = T . length ( ) ; int N = S . length ( ) ; for ( int i = 0 ; i <= M ; i ++ ) { int prefix_length = i ; int suffix_length = M - i ; string prefix = S . substr ( 0 , prefix_length ) ; string suffix = S . substr ( N - suffix_length , suffix_length ) ; if ( prefix + suffix == T ) { possible = true ; break ; } } if ( possible ) return " YES " ; else return " NO " ; }
int complement ( int num ) { int i , len = 0 , temp , comp ; temp = num ; while ( 1 ) { len ++ ; num = num / 10 ; if ( abs ( num ) == 0 ) break ; } num = temp ; comp = pow ( 10 , len ) - num ; return comp ; }
bool isenneadecagonal ( int N ) { float n = ( 15 + sqrt ( 136 * N + 225 ) ) / 34 ; return ( n - ( int ) n ) == 0 ; }
void replaceOriginal ( string s , int n ) { string r ( n , ' ▁ ' ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != ' a ' && s [ i ] != ' e ' && s [ i ] != ' i ' && s [ i ] != ' o ' && s [ i ] != ' u ' ) { cout << r [ i ] ; } } cout << endl ; }
int minCost ( int arr [ ] , int arr_size ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } cout << min ( even , odd ) ; }
int numPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; }
string longestCommonPrefix ( string ar [ ] , int n ) { if ( n == 0 ) return " " ; if ( n == 1 ) return ar [ 0 ] ; sort ( ar , ar + n ) ; int en = min ( ar [ 0 ] . size ( ) , ar [ n - 1 ] . size ( ) ) ; string first = ar [ 0 ] , last = ar [ n - 1 ] ; int i = 0 ; while ( i < en && first [ i ] == last [ i ] ) i ++ ; string pre = first . substr ( 0 , i ) ; return pre ; }
bool prodSquare ( int n ) { unordered_map < float , float > s ; for ( int i = 2 ; i * i <= n ; ++ i ) { s [ i * i ] = 1 ; if ( s . find ( n / ( i * i ) ) != s . end ( ) ) return true ; } return false ; }
int findSubarrays ( int arr [ ] , int N , int K ) { return N - K + 1 ; }
int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return -1 ; }
int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + abs ( arr [ i ] - x ) ; } cout << " number ▁ is ▁ not ▁ present ! " ; return -1 ; }
int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = -1 ; return ans ; }
int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } cout << curr ; } }
void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; cout << ans << endl ; } else cout << ( budget / plastic ) << endl ; }
float heptdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.802 * a ; return d ; }
bool isFibbinaryNum ( unsigned int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
int minCount ( int A [ ] , int B [ ] , int N ) { int i = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) { i ++ ; } } return N - i ; }
int maxbalancedprefix ( char str [ ] , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
int DecreasingArray ( int a [ ] , int n ) { int sum = 0 , dif = 0 ; priority_queue < int , vector < int > , greater < int > > pq ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! pq . empty ( ) && pq . top ( ) < a [ i ] ) { dif = a [ i ] - pq . top ( ) ; sum += dif ; pq . pop ( ) ; } pq . push ( a [ i ] ) ; } return sum ; }
int previousFibonacci ( int n ) { double a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) ; return round ( a ) ; }
void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) cout << " Equal " else if ( ( x & ( ~ y ) ) > y ) cout << y ; else cout << x ; }
int cal ( int n ) { double res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return ( int ) res ; }
bool isnonagonal ( int N ) { float n = ( 5 + sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
int maximum_inversion ( int n , int k ) { int answer = 0 ; k = min ( k , n / 2 ) ; int left = 1 ; int right = n ; while ( k -- ) { answer += 2 * ( right - left ) - 1 ; left ++ ; right -- ; } cout << answer << endl ; }
void merge_and_sort ( int * output , int arr [ ] [ N ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i ] [ j ] ; } } sort ( output , output + n * k ) ; }
int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
bool isInteger ( double N ) { int X = N ; double temp2 = N - X ; if ( temp2 > 0 ) { return false ; } return true ; }
int checkPalindromeB ( int N , int B ) { int rev = 0 ; int N1 = N ; while ( N1 ) { rev = rev * B + N1 % B ; N1 = N1 / B ; } return N == rev ; }
int findSum ( int L , int R ) { vector < int > arr ; int i = 0 ; int x = 2 ; while ( i <= R ) { arr . push_back ( i + x ) ; if ( i + 1 <= R ) arr . push_back ( i + 1 + x ) ; x *= -1 ; i += 2 ; } int sum = 0 ; for ( int i = L ; i <= R ; ++ i ) sum += arr [ i ] ; return sum ; }
void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] *= -1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= -1 ; }
void checkSuffix ( int A , int B ) { string s1 = to_string ( A ) ; string s2 = to_string ( B ) ; bool result ; result = boost :: algorithm :: ends_with ( s1 , s2 ) ; if ( result ) { cout << " Yes " ; } else { cout << " No " ; } }
string getResult ( int n ) { string st = to_string ( n ) ; for ( int i = 0 ; i < st . length ( ) ; i ++ ) { int d = st [ i ] - 48 ; if ( n % d == 0 ) { return " Yes " ; } } return " No " ; }
int countNumbers ( int N ) { return int ( sqrt ( N ) ) - 1 ; }
float area_circumscribed ( float c ) { return ( c * c * ( PI / 4 ) ) ; }
void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { cout << k * ( 6 * i + 1 ) << " ▁ " << k * ( 6 * i + 2 ) << " ▁ " << k * ( 6 * i + 3 ) << " ▁ " << k * ( 6 * i + 5 ) << endl ; } }
int findCnt ( int * arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; int x = max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }
void Kroneckerproduct ( int A [ ] [ cola ] , int B [ ] [ colb ] ) { int C [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; cout << C [ i + l + 1 ] [ j + k + 1 ] << " ▁ " ; } } cout << endl ; } } }
bool check ( int arr [ ] , int N ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) cout << " Yes " ; else cout << " No " ; }
int minSum ( int A [ ] , int B [ ] , int C [ ] , int i , int n , int curr , int dp [ SIZE ] [ N ] ) { if ( n <= 0 ) return 0 ; if ( dp [ n ] [ curr ] != -1 ) return dp [ n ] [ curr ] ; if ( curr == 0 ) { return dp [ n ] [ curr ] = min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; }
int equvInverse ( int arr [ ] , int N , int P ) { int cntElem = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; }
string processWords ( char * input ) { char * p ; vector < string > s ; p = strtok ( input , " ▁ " ) ; while ( p != NULL ) { s . push_back ( p ) ; p = strtok ( NULL , " ▁ " ) ; } string charBuffer ; for ( string values : s ) charBuffer += values [ 0 ] ; return charBuffer ; }
int gonNum65537 ( int n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; }
int maximumAND ( int L , int R ) { return R ; }
int maxWeight ( int * arr , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != -1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; }
int get_subset_count ( int arr [ ] , int K , int N ) { sort ( arr , arr + N ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; }
string encryptString ( string str , int n ) { int i = 0 , cnt = 0 ; string encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; }
int NoCarrySum ( int N , int M ) { return N ^ M ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( -2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && floor ( root2 ) == root2 ) return true ; return false ; }
bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
void getSum ( int n ) { bool isOdd = ( n % 2 == 1 ) ? true : false ; int sumOdd = 0 , sumEven = 0 ; while ( n != 0 ) { if ( isOdd ) sumOdd += n % 10 ; else sumEven += n % 10 ; isOdd = ! isOdd ; n /= 10 ; } cout << " Sum ▁ odd ▁ = ▁ " << sumOdd << " STRNEWLINE " ; cout << " Sum ▁ even ▁ = ▁ " << sumEven ; }
void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = 3.14159 ; float A = ( 180 / pi ) * ( acos ( d ) ) ; cout << " Angle ▁ is ▁ " << A << " ▁ degree " ; }
int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; }
string NimGame ( int N , int A , int B ) { int sum = A + B ; if ( N % sum <= A - 1 ) return " Bob " ; else return " Alice " ; }
int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
void center ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " , ▁ " << ( float ) ( y1 + y2 ) / 2 ; }
void angleextcycquad ( int z ) { cout << " The ▁ exterior ▁ angle ▁ of ▁ the " << " ▁ cyclic ▁ quadrilateral ▁ is ▁ " << z << " ▁ degrees " << endl ; }
int proizvolov ( int a [ ] , int b [ ] , int n ) { return n * n ; }
int isPossible ( int w , int h , int x , int y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }
void quadrant ( string s ) { int l = s . length ( ) ; int i ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; } else { i = s . find ( ' - ' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - 1 ) ; int x = stoi ( real ) ; int y = stoi ( imaginary ) ; if ( x > 0 and y > 0 ) cout << " Quadrant ▁ 1" ; else if ( x < 0 and y > 0 ) cout << " Quadrant ▁ 2" ; else if ( x < 0 and y < 0 ) cout << " Quadrant ▁ 3" ; else if ( x > 0 and y < 0 ) cout << " Quadrant ▁ 4" ; else if ( x == 0 and y > 0 ) cout << " Lies ▁ on ▁ positive " << " ▁ Imaginary ▁ axis " ; else if ( x == 0 and y < 0 ) cout << " Lies ▁ on ▁ negative " << " ▁ Imaginary ▁ axis " ; else if ( y == 0 and x < 0 ) cout << " Lies ▁ on ▁ negative " << " ▁ X - axis " ; else if ( y == 0 and x > 0 ) cout << " Lies ▁ on ▁ positive " << " ▁ X - axis " ; else cout << " Lies ▁ on ▁ the ▁ Origin " ; }
void print ( int n ) { cout << n + n / 2 << endl ; for ( int i = 2 ; i <= n ; i += 2 ) cout << i << " ▁ " ; for ( int i = 1 ; i <= n ; i += 2 ) cout << i << " ▁ " ; for ( int i = 2 ; i <= n ; i += 2 ) cout << i << " ▁ " ; }
double innerCirclearea ( double radius ) { if ( radius < 0 ) { return -1 ; } double r = radius / 2 ; double Area = ( 3.14 * pow ( r , 2 ) ) ; return Area ; }
void dfs ( int * val , int * cost , vector < vector < int > > & tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . size ( ) ; i ++ ) { dfs ( val , cost , tr , tr [ u ] [ i ] , s ) ; } }
int countNumbers ( int N ) { return ( pow ( 10 , N ) - 1 ) - ( pow ( 10 , N ) - pow ( 8 , N ) ) / 2 ; }
int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; }
void Alphabet_N_Pattern ( int N ) { int index , side_index , size ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { cout << Left ++ ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) cout << " ▁ " ; if ( index != 0 && index != N - 1 ) cout << Diagonal ++ ; else cout << " ▁ " ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) cout << " ▁ " ; cout << Right ++ ; cout << endl ; } }
void findNthTerm ( int n ) { cout << n * ( 4 * n + 3 ) << endl ; }
int cntElements ( int arr [ ] , int n ) { int copy_arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }
void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; cout << arr [ line ] [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } }
bool arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; bool arr [ N + 1 ] ; memset ( arr , true , sizeof ( arr ) ) ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == true ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = false ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
void printElements ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) cout << arr [ i ] << " ▁ " ; } }
void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) cout << " Yes " ; else cout << " No " ; }
int nthTerm ( int n ) { return pow ( n , 2 ) + 4 * n ; }
void checkEvenOdd ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cout << " Even " ; return ; } } cout << " Odd " ; }
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
bool pointsAreOnSameSideOfLine ( int a , int b , int c , int x1 , int y1 , int x2 , int y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }
string getResult ( string st ) { int sum = 0 ; int length = st . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + pow ( st [ i ] - '0' , length ) ; } int number = stoi ( st ) ; if ( number == sum ) return " yes " ; else return " no " ; }
long countWaysToTileBoard ( long N ) { long dp [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } cout << dp [ N ] ; }
bool flipsPossible ( int a [ ] , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 && count_even % 2 ) return false ; else return true ; }
int countTripletsLessThanL ( int n , int L , int * arr ) { sort ( arr , arr + n ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
int countIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
bool topsyTurvy ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '2' str [ i ] == '4' str [ i ] == '5' str [ i ] == '6' str [ i ] == '7' str [ i ] == '9' ) { return false ; } } return true ; }
int minOps ( int arr [ ] , int n , int k ) { int max = * max_element ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return -1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { cout << i << " , ▁ " << j << " , ▁ " << k ; return ; } } } cout << " No ▁ Triplet " ; }
long nextGreater ( long long N ) { long long power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
int CountWays ( int r , int b , int l , int R , int B , int W , int dp [ RUNMAX ] [ BALLMAX ] [ WICKETMAX ] ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r ] [ b ] [ l ] != -1 ) return dp [ r ] [ b ] [ l ] ; int ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r ] [ b ] [ l ] = ans ; }
long factorial ( int n ) { const unsigned int M = 1000000007 ; unsigned long long f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) return f ; }
void compareValues ( int a , int b , int c , int d ) { double log1 = log10 ( a ) ; double num1 = log1 * b ; double log2 = log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) cout << a << " ^ " << b ; else cout << c << " ^ " << d ; }
int MinimumNoOfWays ( int arr [ ] , int n ) { int mini_no_of_ways ; if ( n % 2 == 0 ) { mini_no_of_ways = n / 2 ; } else { mini_no_of_ways = n / 2 + 1 ; } return mini_no_of_ways ; }
void printMaxNumber ( int n ) { if ( n & 1 ) { cout << "7" ; for ( int i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) cout << "1" ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) cout << "1" ; } }
int countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( N / i != i ) { count ++ ; } } } return count ; }
void insertAfter ( Node * prev_node , int new_data ) { if ( prev_node == NULL ) { cout << " the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL " ; return ; } Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = prev_node -> next ; prev_node -> next = new_node ; }
double findAverageOfCube ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; }
int countCubes ( int a , int b ) { return ( floor ( cbrt ( b ) ) - ceil ( cbrt ( a ) ) + 1 ) ; }
void rotate90Clockwise ( int arr [ N ] [ N ] ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) cout << arr [ i ] [ j ] << " ▁ " ; cout << ' ' ; } }
int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
float square ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; return x ; }
int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
int calcDeterminant ( int arr [ ] ) { int determinant = 0 ; for ( int i = 0 ; i < N ; i ++ ) { determinant += pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; }
void printKthBit ( unsigned int n , unsigned int k ) { cout << ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
int findLCS ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; } return mp . size ( ) ; }
int minOccupiedPosition ( int A [ ] , int n ) { int minPos = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; }
int countSubsequences ( string s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( unsigned int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' a ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' b ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' c ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ n ] ; memset ( count_jump , 0 , sizeof ( count_jump ) ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != -1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count_jump [ i ] << " ▁ " ; }
float sphere ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; return r ; }
int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( std :: sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return std :: ceil ( eq_root ) + l ; }
void printKPFNums ( int A , int B , int K ) { bool prime [ B + 1 ] = { true } ; int p_factors [ B + 1 ] = { 0 } ; for ( int p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( int i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( int i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) cout << i << " ▁ " ; }
int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
double cubeRoot ( double n ) { double ans = pow ( 3 , ( 1.0 / 3 ) * ( log ( n ) / log ( 3 ) ) ) ; return ans ; }
void check ( unsigned long long m , unsigned long long int n ) { double RHS = m * ( double ) log ( n ) ; double LHS = n * ( double ) log ( m ) ; if ( LHS > RHS ) cout << " m ^ n ▁ > ▁ n ^ m " ; else if ( LHS < RHS ) cout << " m ^ n ▁ < ▁ n ^ m " ; else cout << " m ^ n ▁ = ▁ n ^ m " ; }
string checkPattern ( int arr [ ] , int m , int k , int n ) { int count = 1 , t = 0 ; for ( int i = 0 ; i < n - m ; i ++ ) { if ( arr [ i ] == arr [ i + m ] ) { t ++ ; if ( t == m ) { t = 0 ; count ++ ; if ( count == k ) { return " Yes " ; } } } else { t = 0 ; count = 1 ; } } return " No " ; }
int maxModulosum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; }
int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2 ) { sort ( arr , arr + n ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
int lis ( int arr [ ] , int n ) { int lis [ n ] ; lis [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lis [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } return * max_element ( lis , lis + n ) ; }
int findMin ( int N ) { int digit = N % 10 ; switch ( digit ) { case 0 : if ( N >= 90 ) return 10 ; break ; case 1 : if ( N >= 81 ) return 9 ; break ; case 2 : if ( N >= 72 ) return 8 ; break ; case 3 : if ( N >= 63 ) return 7 ; break ; case 4 : if ( N >= 54 ) return 6 ; break ; case 5 : if ( N >= 45 ) return 5 ; break ; case 6 : if ( N >= 36 ) return 4 ; break ; case 7 : if ( N >= 27 ) return 3 ; break ; case 8 : if ( N >= 18 ) return 2 ; break ; case 9 : if ( N >= 9 ) return 1 ; break ; } return -1 ; }
bool isPowerOfTwo ( int n ) { return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; }
int rotate ( int arr [ ] , int N , int X ) { long long int nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return nextPower - N ; long long int prevPower = nextPower / 2 ; return 2 * ( N - prevPower ) + 1 ; }
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = INT_MAX ; int res_l , res_r ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } cout << " The ▁ closest ▁ pair ▁ is ▁ [ " << ar1 [ res_l ] << " , ▁ " << ar2 [ res_r ] << " ] ▁ STRNEWLINE " ; }
int longestSubseq ( string s ) { int n = s . length ( ) ; int pre_count_0 [ n + 2 ] ; int pre_count_1 [ n + 1 ] ; int post_count_0 [ n + 1 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s [ j - 1 ] == '0' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s [ n - j ] == '0' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; }
bool isPerfectSquareString ( string str ) { int sum = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] ; long double squareRoot = sqrt ( sum ) ; return ( ( squareRoot - floor ( squareRoot ) ) == 0 ) ; }
int kthNum ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; }
int getCount ( string str , int n ) { int cnt = 0 ; int i = 0 ; while ( i < n - 2 ) { if ( str [ i ] == str [ i + 1 ] && str [ i ] == str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else i ++ ; } return cnt ; }
int centeredTridecagonalNum ( long int n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
char stringPalindrome ( string A , string B ) { int countA [ MAX_CHAR ] = { 0 } ; int countB [ MAX_CHAR ] = { 0 } ; int l1 = A . length ( ) , l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' A ' ; return ' B ' ; }
float median ( int a , int b , int c ) { float n = sqrt ( 2 * b * b + 2 * c * c - a * a ) / 2 ; return n ; }
double findRadius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = sqrt ( a3 / 3.14 ) ; return r3 ; }
int maxProd ( int n ) { if ( n == 2 n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
ll findNumber ( int n ) { ll num = n - 1 ; num = 2 * ( ll ) pow ( 4 , num ) ; num = floor ( num / 3.0 ) ; return num ; }
void minCost ( int arr [ ] , int N , int X ) { sort ( arr , arr + N ) ; int sum = 0 ; int cost = 0 ; int min_cost = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { cost = abs ( arr [ i ] ) * X + ( sum - abs ( arr [ i ] ) * i ) ; sum += abs ( arr [ i ] ) ; min_cost = min ( min_cost , cost ) ; } } cout << min_cost ; }
void TwentyoneMatchstick ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i += 1 ) { cout << 5 - arr [ i ] << " ▁ " ; } cout << endl ; }
int largestPower ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; }
void countNum ( int N ) { int ans = log2 ( N ) + 1 ; cout << ans << " STRNEWLINE " ; }
void findRealAndImag ( string s ) { int l = s . length ( ) ; int i ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; } else { i = s . find ( ' - ' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - i - 2 ) ; cout << " Real ▁ part : ▁ " << real << " STRNEWLINE " ; cout << " Imaginary ▁ part : ▁ " << imaginary << " STRNEWLINE " ; }
bool canBeBalanced ( string s , int n ) { int count = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) count ++ ; else count -- ; count_1 = min ( count_1 , count ) ; } if ( count_1 >= -1 && count == 0 ) return true ; return false ; }
float angleOncirCumference ( float z ) { return ( z / 2 ) ; }
int Octadecagonal_num ( int n ) { return ( 16 * n * n - 14 * n ) / 2 ; }
int countNonEmptySubstr ( string str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
int countOccurrances ( long long int n , int d ) { long long int count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = n / 10 ; } return count ; }
bool checkZeroArray ( int * arr , int n ) { int sum = 0 , maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] ; maximum = max ( maximum , arr [ i ] ) ; } if ( sum % 2 == 0 && maximum <= sum / 2 ) return true ; return false ; }
char findProffesion ( int level , int pos ) { if ( level == 1 ) return ' e ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' d ' ) return ( pos % 2 ) ? ' d ' : ' e ' ; return ( pos % 2 ) ? ' e ' : ' d ' ; }
int getNthTerm ( long long int N ) { return ( pow ( N , 2 ) + N + 1 ) ; }
int largestAnagramSet ( string arr [ ] , int n ) { int maxSize = 0 ; unordered_map < string , int > count ; for ( int i = 0 ; i < n ; ++ i ) { sort ( arr [ i ] . begin ( ) , arr [ i ] . end ( ) ) ; count [ arr [ i ] ] += 1 ; maxSize = max ( maxSize , count [ arr [ i ] ] ) ; } return maxSize ; }
int minStepK ( int arr [ ] , int N , int K ) { int E = 0 ; int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 == 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return -1 ; else return K - S ; }
int log_a_to_base_b ( int a , int b ) { return ( a > b - 1 ) ? 1 + log_a_to_base_b ( a / b , b ) : 0 ; }
bool EqualNumber ( int A , int B ) { return ( A ^ B ) ; }
bool checkSuffix ( int A , int B ) { int digit_B = log10 ( B ) + 1 ; A -= B ; return ( A % int ( pow ( 10 , digit_B ) ) ) ; }
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << i << " ▁ and ▁ " << j - 1 ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } cout << " No ▁ subarray ▁ found " ; return 0 ; }
int optimalStrategyOfGame ( int * arr , int n ) { int table [ n ] [ n ] ; for ( int gap = 0 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { int x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; int y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; int z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { cout << ( ( 2 * i ) - 1 ) << " ▁ " ; i ++ ; } }
int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) pow ( i , res ) % mod ; return res ; }
int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( abs ( n - n1 ) < abs ( n - n2 ) ) return n1 ; return n2 ; }
bool possibleToReach ( int a , int b ) { int c = cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
int countKeyPressed ( string str , int len ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) count = count + arr [ str [ i ] - ' a ' ] ; return count ; }
void distributeN ( int A , int B , int C , int n ) { int max1 = max ( A , B ) ; int max2 = max ( B , C ) ; int maximum = max ( max1 , max2 ) ; int sum = A + B + C ; int p = ( 3 * maximum ) - sum ; int diff = n - p ; if ( diff < 0 diff % 3 ) cout << " No " ; else cout << " Yes " ; }
bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
int countConsecutive ( string s ) { int count = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) i ++ ; else count ++ ; } return count ; }
void sameProductQuadruples ( int nums [ ] , int N ) { unordered_map < int , int > umap ; int res = 0 ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = i + 1 ; j < N ; ++ j ) { int prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } cout << res ; }
void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { cout << " Second ▁ Player ▁ wins ▁ the ▁ game " ; } else { cout << " First ▁ Player ▁ wins ▁ the ▁ game " ; } }
int findWays ( int m , int n , int x ) { int table [ n + 1 ] [ x + 1 ] ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) for ( int k = 1 ; k <= m && k < j ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; return table [ n ] [ x ] ; }
int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
int findMinRooms ( string slots [ ] , int n , int m ) { int counts [ m ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; return * max_element ( counts , counts + m ) ; }
void findVolume ( db u , db v , db w , db U , db V , db W , db b ) { db uPow = pow ( u , 2 ) ; db vPow = pow ( v , 2 ) ; db wPow = pow ( w , 2 ) ; db UPow = pow ( U , 2 ) ; db VPow = pow ( V , 2 ) ; db WPow = pow ( W , 2 ) ; db a = 4 * ( uPow * vPow * wPow ) - uPow * pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; db vol = sqrt ( a ) ; vol /= b ; cout << fixed << setprecision ( 4 ) << vol ; }
string findString ( int n , int k ) { string res = " " ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' a ' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
int sumOfDigits ( string s ) { int curr = 0 ; int ret = 0 ; for ( auto & ch : s ) { if ( isdigit ( ch ) ) { curr = curr * 10 + ch - '0' ; } else { ret += curr ; curr = 0 ; } } ret += curr ; return ret ; }
int sumofproduct ( int n ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int y = n / x ; ans += ( y * x ) ; } return ans ; }
int minswaps ( int arr [ ] , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; }
void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; } }
int countPoints ( int D ) { int count = 0 ; for ( int x = 1 ; x * x < D * D ; x ++ ) { int y = ( int ) sqrt ( double ( D * D - x * x ) ) ; if ( x * x + y * y == D * D ) { count += 4 ; } } count += 4 ; return count ; }
void findEquation ( int a , int b , int c ) { int X = ( a + b + c ) ; int Y = ( a * b ) + ( b * c ) + ( c * a ) ; int Z = a * b * c ; cout << " x ^ 3 ▁ - ▁ " << X << " x ^ 2 ▁ + ▁ " << Y << " x ▁ - ▁ " << Z << " ▁ = ▁ 0" ; }
int tripletAndSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; }
bool isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n and n != 1 ) return true ; else false ; }
void complement ( string number ) { for ( int i = 0 ; i < number . length ( ) ; i ++ ) if ( number [ i ] != ' . ' ) number [ i ] = '9' - number [ i ] + '0' ; cout << "9 ' s ▁ complement ▁ is ▁ : ▁ " << number ; }
int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; }
int minRemoval ( string str ) { int hash [ MAX_CHAR ] ; memset ( hash , 0 , sizeof ( hash ) ) ; for ( int i = 0 ; str [ i ] ; i ++ ) hash [ str [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( hash [ i ] % 2 ) count ++ ; return ( count == 0 ) ? 0 : count - 1 ; }
void decrypt ( string Str , int Start , int End ) { if ( Start > End ) { return ; } int mid = ( Start + End ) >> 1 ; cout << Str [ mid ] ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
void MinimumMaximumPairs ( int n , int m ) { int max_pairs = ( ( n - m + 1 ) * ( n - m ) ) / 2 ; int min_pairs = m * ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 + ceil ( ( n - m ) / double ( m ) ) * ( ( n - m ) % m ) ; cout << " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " << min_pairs << " STRNEWLINE " ; cout << " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " << max_pairs << " STRNEWLINE " ; }
void findPhoneNumber ( int n ) { int temp = n ; int sum ; while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; } if ( sum < 10 ) cout << n << "0" << sum ; else cout << n << sum ; }
void Perimeter ( int a , int b ) { float perimeter ; perimeter = 2 * 3.14 * sqrt ( ( a * a + b * b ) / ( 2 * 1.0 ) ) ; cout << perimeter ; }
bool isCenterednonadecagonal ( int N ) { float n = ( 19 + sqrt ( 152 * N + 209 ) ) / 38 ; return ( n - ( int ) n ) == 0 ; }
int isSubstring ( string s1 , string s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return -1 ; }
int findevenPair ( int A [ ] , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return -1 ; }
float squareSide ( float a ) { if ( a < 0 ) return -1 ; float x = 0.423 * a ; return x ; }
void meanVector ( int mat [ rows ] [ cols ] ) { cout << " [ ▁ " ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; cout << mean << " ▁ " ; } cout << " ] " ; }
void ASCIISentence ( std :: string str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str [ i ] - NULL ; cout << convert ; } }
void printSubsequences ( int arr [ ] , int n ) { unsigned int opsize = pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) cout << arr [ j ] << " ▁ " ; } cout << endl ; } }
int countGroups ( int position , int previous_sum , int length , char * num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
bool isTridecagon ( int N ) { float n = ( 9 + sqrt ( 88 * N + 81 ) ) / 22 ; return ( n - ( int ) n ) == 0 ; }
void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { cout << " A " ; } else { cout << " B " ; } }
bool areElementsContiguous ( int arr [ ] , int n ) { int max = * max_element ( arr , arr + n ) ; int min = * min_element ( arr , arr + n ) ; int m = max - min + 1 ; if ( m > n ) return false ; bool visited [ m ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
int maxDiffSubsets ( int arr [ ] , int N ) { int totalSum = 0 ; bool pos = false , neg = false ; int min = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += abs ( arr [ i ] ) ; if ( arr [ i ] > 0 ) pos = true ; if ( arr [ i ] < 0 ) neg = true ; if ( arr [ i ] < min ) min = arr [ i ] ; } if ( pos && neg ) return totalSum ; else return totalSum - 2 * min ; }
int smallestNum ( int n ) { cout << pow ( 10 , n * n / 9 ) << endl ; return ( n * n % 9 + 1 ) * pow ( 10 , n * n / 9 ) - 1 ; }
int findCount ( int n ) { return log ( n ) / log ( 2 ) + 1 ; }
void FirstAndLast ( string str ) { int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == 0 ) cout << str [ i ] ; if ( i == str . length ( ) - 1 ) cout << str [ i ] ; if ( str [ i ] == ' ▁ ' ) { cout << str [ i - 1 ] << " ▁ " << str [ i + 1 ] ; } } }
void findSubsequence ( string str , int k ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l ; i ++ ) if ( a [ str [ i ] - ' a ' ] >= k ) cout << str [ i ] ; }
int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += log10 ( i ) ; return floor ( digits ) + 1 ; }
double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; }
int lastElement ( const int arr [ ] , int n ) { int sum = 0 ; int multiplier = n % 2 == 0 ? -1 : 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * multiplier ; multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( -1 ) ; } return sum ; }
bool checkSame ( int n ) { int set = 0 , unset = 0 ; while ( n ) { if ( n & 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; }
void maxSum ( int * a , int n ) { vector < int > l ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . push_back ( i + 1 ) ; else { l . push_back ( i + 1 ) ; l . push_back ( i ) ; } } cout << s << endl ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) cout << l [ i ] << " ▁ " ; }
void findPairs ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { cout << " ( " << i << " , ▁ " << N - i << " ) , ▁ " ; } }
void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; int cube [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { cout << " ( " << l << " , ▁ " << r << " ) " << endl ; l ++ ; r -- ; } } }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
int numberOfUniqueOutcomes ( int N , int S ) { if ( S < N ) return 0 ; if ( N == 1 N == S ) return 1 ; return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) ; }
void computeTotient ( int n ) { long long phi [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) cout << " Totient ▁ of ▁ " << i << " ▁ is ▁ " << phi [ i ] << endl ; }
int largestSubset ( int a [ ] , int n ) { int dp [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) mxm = max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; } return * max_element ( dp , dp + n ) ; }
int SubArrayProdct ( int arr [ ] , int n ) { long int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result *= pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; return result ; }
int findValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) ans = max ( ans , abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ) ; return ans ; }
bool isCenteredpentagonal ( int N ) { float n = ( 5 + sqrt ( 40 * N - 15 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
bool checkPalindrome ( string str ) { int n = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; }
int sumOfTermsInNthRow ( int n ) { int sum = n * ( 2 * pow ( n , 2 ) + 1 ) ; return sum ; }
int countOddSquares ( int n , int m ) { return ( int ) pow ( m , 0.5 ) - ( int ) pow ( n - 1 , 0.5 ) ; }
int productSubSeqCount ( vector < int > & arr , int k ) { int n = arr . size ( ) ; int dp [ k + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr [ j - 1 ] <= i ) dp [ i ] [ j ] += dp [ i / arr [ j - 1 ] ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }
int MinOp ( int N ) { if ( N <= 1 ) return N ; int bit = log2 ( N ) + 1 ; return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; }
void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { cout << arr [ i ] << " ▁ " << arr [ j ] << " ▁ " << arr [ k ] << endl ; } } } } }
void find_rectangle ( int area ) { int l , b ; int M = sqrt ( area ) , ans ; for ( int i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } cout << " l ▁ = ▁ " << l << " , ▁ b ▁ = ▁ " << b << endl ; }
int areaOfSquare ( int S ) { int area = S * S ; return area ; }
void printValueOfPi ( int N ) { double pi = 2 * acos ( 0.0 ) ; printf ( " % . * lf STRNEWLINE " , N , pi ) ; }
int minInsertionStepToSortArray ( int arr [ ] , int N ) { int lis [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }
int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) pow ( i , i ) ; int numerator = ( int ) pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return -1 ; }
int Divisible ( int arr [ ] , int n ) { int count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) count_even ++ ; return count_even + ( n - count_even ) / 2 ; }
void smallestNumber ( int N ) { cout << ( N % 9 + 1 ) * pow ( 10 , ( N / 9 ) ) - 1 ; }
double increaseInVol ( double l , double b , double h ) { double percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; }
void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " equation ▁ of ▁ plane ▁ is ▁ " << a << " ▁ x ▁ + ▁ " << b << " ▁ y ▁ + ▁ " << c << " ▁ z ▁ + ▁ " << d << " ▁ = ▁ 0 . " ; }
void printCoins ( int arr [ ] , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) cout << arr [ i ] << " ▁ " ; }
void findShifts ( int A [ ] , int N ) { int shift [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) cout << shift [ i ] << " ▁ " ; }
void printOdds ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; int set_bit = res & ( ~ ( res - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << x << " ▁ " << y ; }
int powerOfJump ( string s ) { int count = 1 ; int max_so_far = INT_MIN ; char ch = s [ s . length ( ) - 1 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
void countPairs ( int arr [ ] , int k , int size ) { int count = 0 , x ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < size ; j ++ ) { x = arr [ i ] | arr [ j ] ; if ( x == k ) count ++ ; } } cout << count ; }
int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
int maxLength ( char s [ ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ( ' && s [ i + 1 ] == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ( ' && s [ j ] == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
int get ( int x , int y , int z ) { if ( x > z ) return -1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; }
void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } cout << count << ' ▁ ' ; } }
bool linearSearch ( int a [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == key ) return true ; } return false ; }
int calculateSum ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; }
void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }
bool isPerfect ( long long int n ) { long long int sum = 1 ; for ( long long int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
int maxLengthSquare ( int row , int column , int arr [ ] [ 4 ] , int k ) { int sum [ row + 1 ] [ column + 1 ] ; for ( int i = 1 ; i <= row ; i ++ ) for ( int j = 0 ; j <= column ; j ++ ) sum [ i ] [ j ] = 0 ; int cur_max = 1 ; int max = 0 ; for ( int i = 1 ; i <= row ; i ++ ) { for ( int j = 1 ; j <= column ; j ++ ) { sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; }
float Area_of_Triangle ( int a , int b , int k ) { float area = ( float ) ( ( 1 / 2.0 ) * a * b * ( sin ( k ) ) ) ; return area ; }
int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
bool isPossible ( int n ) { int fac [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; }
bool isDivisible ( long long int n ) { while ( n / 100 ) { int last_digit = n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
int findK ( int arr [ ] , int size , int N ) { sort ( arr , arr + size ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return -1 ; }
void specialSieve ( int n ) { int cnt = 0 ; int prime [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) { cnt ++ ; for ( int j = i ; j <= n ; j += i ) prime [ j ] = cnt ; } } for ( int i = 2 ; i <= n ; i ++ ) cout << prime [ i ] << " ▁ " ; }
int countSteps ( int n ) { int steps = 0 ; while ( n ) { int largest = cbrt ( n ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) cout << i << " ▁ " ; }
int nthTerm ( int N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
int calculateMoves ( int n ) { int count = 0 ; int layers = n / 2 ; for ( int k = 1 ; k < layers + 1 ; k ++ ) { count += 8 * k * k ; } return count ; }
int TrialDivision ( int N ) { int i = 2 ; int k = ceil ( sqrt ( N ) ) ; while ( i <= k ) { if ( N % i == 0 ) return 0 ; i += 1 ; } return 1 ; }
bool isCentereddecagonal ( int N ) { float n = ( 5 + sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
void findNumbers ( int n ) { string ans = string ( n - 1 , '7' ) ; string even = ans + '6' ; string odd = ans + '7' ; cout << " Even ▁ : ▁ " << even << endl ; cout << " Odd ▁ : ▁ " << odd << endl ; }
float circlearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float A = ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ; return A ; }
int getMaxSum ( int a [ ] , int n ) { int dp [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 0 ] ; int max_sum = max ( dp [ 0 ] [ 0 ] , dp [ 0 ] [ 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = max ( a [ i ] , dp [ i - 1 ] [ 0 ] + a [ i ] ) ; dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] + a [ i ] , a [ i ] * a [ i ] ) ; dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] + a [ i ] * a [ i ] ) ; max_sum = max ( max_sum , dp [ i ] [ 1 ] ) ; max_sum = max ( max_sum , dp [ i ] [ 0 ] ) ; } return max_sum ; }
float Depreciation ( float v , float r , float t ) { float D = v * pow ( ( 1 - r / 100 ) , t ) ; return D ; }
int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; }
void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; cout << time ; }
ll findF_N ( ll n ) { ll ans = 0 ; for ( ll i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
float avgOfFirstN ( int n ) { return ( float ) ( 1 + n ) / 2 ; }
double findRadius ( double r1 , double r2 , double r3 ) { double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 ; }
int findNumberOfTriangles ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; }
void answer ( int L , int R ) { if ( 2 * L <= R ) cout << L << " , ▁ " << 2 * L << " STRNEWLINE " ; else cout << -1 ; }
int hexadecagonalNum ( long int n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
int nthTerm ( int n ) { return 2 * pow ( n , 3 ) + pow ( n , 2 ) ; }
long getcount ( long long n , int k ) { long long res = ( n >> ( k + 1 ) ) << k ; if ( ( n >> k ) & 1 ) res += n & ( ( 1ll << k ) - 1 ) ; return res ; }
int maxWater ( int arr [ ] , int n ) { int left = 0 ; int right = n - 1 ; int l_max = 0 ; int r_max = 0 ; int result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += max ( 0 , r_max - arr [ right ] ) ; r_max = max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += max ( 0 , l_max - arr [ left ] ) ; l_max = max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum = 0 ; for ( i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << " ▁ " ; }
int calculateEnergy ( int mat [ SIZE ] [ SIZE ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += abs ( i_des - i ) + abs ( j_des - j ) ; } } return tot_energy ; }
void findWinner ( int n , int m ) { int X = 0 ; int Y = 0 ; if ( n >= m ) { X = n - 1 ; Y = m ; } else { X = m - 1 ; Y = n ; } if ( X > Y ) cout << " X " ; else if ( Y > X ) cout << " Y " ; else cout << " - 1" ; }
int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
int sumN ( int n ) { n = ( n + 1 ) / 2 ; return ( n * n ) ; }
string toBinary ( double n ) { if ( n >= 1 n <= 0 ) return " ERROR " ; string answer ; double frac = 0.5 ; answer . append ( " . " ) ; while ( n > 0 ) { if ( answer . length ( ) >= 32 ) return " ERROR " ; if ( n >= frac ) { answer . append ( "1" ) ; n = n - frac ; } else { answer . append ( "0" ) ; } frac /= 2 ; } return answer ; }
void printRepeating ( int arr [ ] , int size ) { int * count = new int [ sizeof ( int ) * ( size - 2 ) ] ; int i ; cout << " ▁ Repeating ▁ elements ▁ are ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " ▁ " ; else count [ arr [ i ] ] ++ ; } }
int countX ( int n ) { string binary = bitset < 8 > ( n ) . to_string ( ) ; int count = 0 ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { if ( binary . at ( i ) == '1' ) count ++ ; } int answer = ( int ) pow ( 2 , count ) ; return answer ; }
int minimumReverse ( string s , int n ) { int k = 0 , l = 0 ; int sum1 = 0 , sum0 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) sum1 ++ ; else sum0 ++ ; if ( s [ i ] == s [ i - 1 ] && s [ i ] == '0' ) k ++ ; else if ( s [ i ] == s [ i - 1 ] && s [ i ] == '1' ) l ++ ; } if ( s [ 0 ] == '1' ) sum1 ++ ; sum0 ++ ; if ( abs ( sum1 - sum0 ) > 1 ) return -1 ; return max ( k , l ) ; }
void segregate0and1 ( int arr [ ] , int size ) { int type0 = 0 ; int type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else type0 ++ ; } }
void selectionSort ( node * head ) { node * temp = head ; while ( temp ) { node * min = temp ; node * r = temp -> next ; while ( r ) { if ( min -> data > r -> data ) min = r ; r = r -> next ; } int x = temp -> data ; temp -> data = min -> data ; min -> data = x ; temp = temp -> next ; } }
int findMaxSum ( int arr [ ] , int n ) { int preSum [ n ] ; int suffSum [ n ] ; int ans = INT_MIN ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = max ( ans , preSum [ i ] ) ; } return ans ; }
int greatestOddFactor ( int n ) { int pow_2 = ( int ) ( log ( n ) ) ; int i = 1 ; while ( i <= pow_2 ) { int fac_2 = ( 2 * i ) ; if ( n % fac_2 == 0 ) { if ( ( n / fac_2 ) % 2 == 1 ) { return ( n / fac_2 ) ; } } i += 1 ; } }
int totalArrays ( int N , int M ) { int end_with_one [ N + 1 ] ; int end_not_with_one [ N + 1 ] ; end_with_one [ 0 ] = 1 ; end_not_with_one [ 0 ] = 0 ; end_with_one [ 1 ] = 0 ; end_not_with_one [ 1 ] = M - 1 ; for ( int i = 2 ; i < N ; i ++ ) { end_with_one [ i ] = end_not_with_one [ i - 1 ] ; end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; } return end_with_one [ N - 1 ] ; }
bool function ( char str [ ] ) { int l = strlen ( str ) ; sort ( str , str + ( l / 2 ) ) ; sort ( str + ( l / 2 ) , str + l ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) if ( str [ i ] != str [ l / 2 + i ] ) return true ; return false ; }
int cntSubsets ( int * arr , int n ) { unsigned int max = pow ( 2 , n ) ; int result = 0 ; for ( int i = 0 ; i < max ; i ++ ) { int counter = i ; if ( counter & ( counter >> 1 ) ) continue ; result ++ ; } return result ; }
int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }
int check ( string str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
void oddDivisors ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int powerOfTwo = 2 ; int count = 0 ; while ( powerOfTwo <= arr [ i ] ) { count ++ ; powerOfTwo = 2 * powerOfTwo ; } cout << count << " ▁ " ; } return ; }
int minOperations ( long long int n ) { long long int count = 0 ; long long int d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = max ( d , n - 1 ) ; count += abs ( d ) ; return count - 1 ; }
int minimumSets ( int arr [ ] , int n , int key ) { int i , j ; sort ( arr , arr + n ) ; for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; }
int FindColumn ( int mat [ N ] [ M ] ) { int row = 0 , col = M - 1 ; int flag = 0 ; while ( row < N && col >= 0 ) { if ( mat [ row ] [ col ] == 1 ) { col -- ; flag = 1 ; } else { row ++ ; } } col ++ ; if ( flag ) return col + 1 ; else return -1 ; }
string minLexRotation ( string str ) { int n = str . length ( ) ; string arr [ n ] ; string concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = concat . substr ( i , n ) ; sort ( arr , arr + n ) ; return arr [ 0 ] ; }
int majorityNumber ( int arr [ ] , int n ) { int ans = -1 ; unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; if ( freq [ arr [ i ] ] > n / 2 ) ans = arr [ i ] ; } return ans ; }
int totalDigits ( int n ) { int number_of_digits = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
void findLargestIndex ( int arr [ ] , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == i ) { cout << i << endl ; return ; } } cout << -1 << endl ; }
int sumOfSeries ( int n ) { return 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ; }
float pairProductMean ( int arr [ ] , int N ) { vector < int > pairArray ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . push_back ( pairProduct ) ; } } int length = pairArray . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; }
void printSumSeries ( int N ) { float sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 1.0 / ( 2 * i - 1 ) ; } cout << sum << endl ; }
int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; }
void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { cout << " a ▁ = ▁ " << a << " , ▁ b ▁ = ▁ " << b ; } else cout << -1 << endl ; }
int countSubSeq ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { count ++ ; } } return ( pow ( 2 , count ) - 1 ) ; }
int nonDecNums ( int n ) { int a [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; }
int findLongestRepeatingSubSeq ( string str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
int findPermutation ( int n ) { int len = ceil ( log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) ; continue ; } } return -1 ; }
void swap ( int a , int b , int c , int d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; cout << " values ▁ after ▁ swapping ▁ are ▁ : ▁ " << endl ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; cout << " c ▁ = ▁ " << c << endl ; cout << " d ▁ = ▁ " << d << endl ; }
float findRadiusOfcircumcircle ( float n , float a ) { if ( n < 0 a < 0 ) return -1 ; float radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) ; return radius ; }
int maxSum ( int arr [ ] , int n , int K ) { int maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ; for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = max ( maximum , sumk ) ; } return maximum ; }
int slopeOfNum ( string num , int n ) { int slope = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ; else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; } return slope ; }
bool isRepdigit ( int num , int b ) { int prev = -1 ; while ( num ) { int digit = num % b ; num /= b ; if ( prev != -1 && digit != prev ) return false ; prev = digit ; } return true ; }
int maxHamming ( int arr [ ] , int n ) { int brr [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
int countDigit ( long long n ) { return floor ( log10 ( n ) + 1 ) ; }
int FindMaxS ( int X , int Y , int Z , int n , vector < int > & A , vector < int > & B , vector < int > & C ) { if ( X < 0 or Y < 0 or Z < 0 ) return INT_MIN ; if ( n < 0 ) return 0 ; int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = max ( ch , max ( ca , max ( co , no ) ) ) ; return maximum ; }
string largestMerge ( string word1 , string word2 ) { string merge = " " ; while ( word1 . size ( ) != 0 || word2 . size ( ) != 0 ) { if ( word1 >= word2 ) { merge = merge + word1 [ 0 ] ; word1 . erase ( word1 . begin ( ) + 0 ) ; } else { merge = merge + word2 [ 0 ] ; word2 . erase ( word2 . begin ( ) + 0 ) ; } } return merge ; }
int NthComposite ( int N ) { bool IsPrime [ MAX_SIZE ] ; memset ( IsPrime , true , sizeof ( IsPrime ) ) ; for ( int p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( int i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } vector < int > Composites ; for ( int p = 4 ; p < MAX_SIZE ; p ++ ) if ( ! IsPrime [ p ] ) Composites . push_back ( p ) ; return Composites [ N - 1 ] ; }
bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
void zigzag ( string s , int rows ) { int interval = 2 * rows - 2 ; for ( int i = 0 ; i < rows ; i ++ ) { int step = interval - 2 * i ; for ( int j = i ; j < s . length ( ) ; j = j + interval ) { cout << s [ j ] ; if ( step > 0 && step < interval && step + j < s . length ( ) ) { for ( int k = 0 ; k < ( interval - rows - i ) ; k ++ ) cout << " ▁ " ; cout << s [ j + step ] ; for ( int k = 0 ; k < i - 1 ; k ++ ) cout << " ▁ " ; } else { for ( int k = 0 ; k < ( interval - rows ) ; k ++ ) cout << " ▁ " ; } } cout << endl ; } }
bool inProportion ( int arr [ ] ) { int n = 4 ; sort ( arr , arr + n ) ; long extremes = ( long ) arr [ 0 ] * ( long ) arr [ 3 ] ; long means = ( long ) arr [ 1 ] * ( long ) arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
string findString ( vector < string > & arr , int N ) { string ans = " " ; for ( int i = 0 ; i < N ; i ++ ) { ans += arr [ i ] [ i ] == '0' ? '1' : '0' ; } return ans ; }
int calc_distance ( int A [ ] , int B [ ] , int n ) { int distance_traveled_A = 0 ; int distance_traveled_B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
int segments ( int n , int p [ ] , int m ) { map < int , int > c ; c [ 0 ] = 1 ; bool has = false ; int sum = 0 ; long long ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) has = true ; if ( has ) ans += c [ sum ] + c [ sum - 1 ] ; else c [ sum ] ++ ; } return ans ; }
void generateLetters ( string S , int P , unordered_map < char , char > M ) { if ( P == S . size ( ) ) { cout << S << " STRNEWLINE " ; return ; } generateLetters ( S , P + 1 , M ) ; S [ P ] = M [ S [ P ] ] ; generateLetters ( S , P + 1 , M ) ; return ; }
void printOrder ( int arr [ ] , int n , int k ) { sort ( arr , arr + k ) ; sort ( arr + k , arr + n , greater < int > ( ) ) ; }
int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }
void maxPossibleSum ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } cout << sum ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = pow ( 2 , temp ) ; if ( ( N + M ) % 2 != 0 ) cout << ans ; else cout << 2 * ans ; cout << endl ; }
void LeftRightNode ( int preorder [ ] , int n ) { int min = INT_MAX , max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > preorder [ i ] ) min = preorder [ i ] ; if ( max < preorder [ i ] ) max = preorder [ i ] ; } cout << " Leftmost ▁ node ▁ is ▁ " << min << " STRNEWLINE " ; cout << " Rightmost ▁ node ▁ is ▁ " << max ; }
int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ; }
int factorialWithoutMul ( int N ) { int ans = N ; for ( int i = N - 1 ; i > 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; }
string sortString ( string str , int n ) { int i ; char arr [ 26 ] = { 0 } ; string new_str = " " ; for ( i = 0 ; i < n ; i ++ ) ++ arr [ str [ i ] - ' a ' ] ; for ( i = 0 ; i < 26 ; i ++ ) while ( arr [ i ] -- ) new_str += i + ' a ' ; return new_str ; }
void countPermutations ( int N , int B ) { int x = pow ( B , N ) ; int y = pow ( B , N - 1 ) ; cout << x - y << " STRNEWLINE " ; }
void maxProductSum ( string str , int m ) { int n = str . length ( ) ; int maxProd = INT_MIN , maxSum = INT_MIN ; for ( int i = 0 ; i <= n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str [ j ] - '0' ) ; sum = sum + ( str [ j ] - '0' ) ; } maxProd = max ( maxProd , product ) ; maxSum = max ( maxSum , sum ) ; } cout << " Maximum ▁ Product ▁ = ▁ " << maxProd ; cout << " Maximum Sum = " }
int minimumLectures ( int m , int n ) { int ans = 0 ; if ( n < ( int ) ceil ( 0.75 * m ) ) ans = ( int ) ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; }
int cost ( int a [ ] , int n ) { return ( n - 1 ) * ( * min_element ( a , a + n ) ) ; }
void precomputation ( int arr [ ] , int n ) { for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( int i = 0 ; i < n ; i ++ ) cout << sum3 [ arr [ i ] ] << " ▁ " ; }
void countPairs ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int xo = ( A [ i ] ^ A [ j ] ) ; int mx = max ( A [ i ] , A [ j ] ) ; if ( xo > mx ) { count ++ ; } } } cout << count ; }
string intToRoman ( int num ) { string m [ ] = { " " , " M " , " MM " , " MMM " } ; string c [ ] = { " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM " } ; string x [ ] = { " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " } ; string i [ ] = { " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " } ; string thousands = m [ num / 1000 ] ; string hundereds = c [ ( num % 1000 ) / 100 ] ; string tens = x [ ( num % 100 ) / 10 ] ; string ones = i [ num % 10 ] ; string ans = thousands + hundereds + tens + ones ; return ans ; }
int maxRemainingSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int i = 0 ; int j = n - 1 ; int result = 0 ; while ( i < j ) { if ( arr [ i ] < arr [ j ] ) { sum -= arr [ i ] ; i ++ ; } else { sum -= arr [ j ] ; j -- ; } result += sum ; } return result ; }
int lenOfLongZigZagArr ( int a [ ] , int n ) { int max = 1 , len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && ( a [ i ] < a [ i + 1 ] ) ) len ++ ; else if ( i % 2 == 1 && ( a [ i ] > a [ i + 1 ] ) ) len ++ ; else { if ( max < len ) max = len ; len = 1 ; } } if ( max < len ) max = len ; return max ; }
void sieve ( ) { position [ 0 ] = -1 , position [ 1 ] = -1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = -1 ; } } }
double averageRuns ( int runs , int matches , int notout ) { int out = matches - notout ; if ( out == 0 ) return -1 ; double avg = double ( runs ) / out ; return avg ; }
int Pentatope_number ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }
int getCount ( int rows , int columns , int A [ ] [ 2 ] ) { int res = 0 ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = i + 1 ; j < rows ; j ++ ) { if ( A [ i ] [ 0 ] * 1LL * A [ j ] [ 1 ] == A [ i ] [ 1 ] * 1LL * A [ j ] [ 0 ] ) { res ++ ; } } } return res ; }
void minMoves ( int arr [ ] , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; cout << moves ; }
double Probability ( double p [ ] , int n ) { double dp [ n + 1 ] [ n + 1 ] ; memset ( dp , 0.0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1.0 ; for ( int i = 1 ; i <= n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ; } } double ans = 0.0 ; for ( int i = ( n + 1 ) / 2 ; i <= n ; i += 1 ) ans += dp [ n ] [ i ] ; return ans ; }
bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; }
bool orthogonality ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; if ( dsquare == r1 * r1 + r2 * r2 ) return true ; else return false ; }
int find_Area ( int r ) { return ( 2 * r * r ) ; }
void waysToPaint ( int n ) { int same = 6 ; int diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } cout << ( same + diff ) ; }
int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 , fn = 5 ; while ( t < n ) { fn = round ( fn * PHI ) ; t ++ ; } return fn ; }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; cout << ith_term << " , ▁ " ; } }
void maxRightmostElement ( int N , int k , int p , int arr [ ] ) { while ( k ) { for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= p ) { arr [ i ] = arr [ i ] - p ; arr [ i + 1 ] = arr [ i + 1 ] + p ; break ; } } k -- ; } cout << arr [ N - 1 ] << endl ; }
int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; }
int findMinCost ( pair < int , int > arr [ ] , int X , int n , int i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return INT_MAX ; int inc = findMinCost ( arr , X - arr [ i ] . first , n , i + 1 ) ; if ( inc != INT_MAX ) inc += arr [ i ] . second ; int exc = findMinCost ( arr , X , n , i + 1 ) ; return min ( inc , exc ) ; }
void findEquation ( int S , int M ) { cout << "1 ▁ " << ( -1 ) * S << " ▁ " << M << endl ; }
void printDistinct ( char * str ) { int count [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; * ( str + i ) ; i ++ ) if ( * ( str + i ) != ' ▁ ' ) count [ * ( str + i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ * ( str + i ) ] == 1 ) cout << str [ i ] ; }
int number_of_tower ( int house [ ] , int range , int n ) { sort ( house , house + n ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; }
int findIndex ( int arr [ ] , int len ) { int maxIndex = 0 ; for ( int i = 0 ; i < len ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( int i = 0 ; i < len ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return -1 ; return maxIndex ; }
int MaximumPath ( int Mat [ ] [ N ] ) { int result = 0 ; int dp [ N ] [ N + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
int getMaxLength ( int arr [ ] , int N ) { int res = 2 ; int dist = 2 ; int curradj = ( arr [ 1 ] - arr [ 0 ] ) ; int prevadj = ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < N ; i ++ ) { curradj = arr [ i ] - arr [ i - 1 ] ; if ( curradj == prevadj ) { dist ++ ; } else { prevadj = curradj ; res = max ( res , dist ) ; dist = 2 ; } } res = max ( res , dist ) ; return res ; }
int countMaxChoco ( int money , int price , int wrap ) { if ( money < price ) return 0 ; int choc = money / price ; choc = choc + ( choc - 1 ) / ( wrap - 1 ) ; return choc ; }
string convert ( string str ) { string w = " " , z = " " ; transform ( str . begin ( ) , str . end ( ) , str . begin ( ) , :: toupper ) ; str += " ▁ " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ▁ ' ) { w = w + ch ; } else { z = z + char ( tolower ( w [ 0 ] ) ) + w . substr ( 1 ) + " ▁ " ; w = " " ; } } return z ; }
void solve ( int n ) { for ( int x = 1 ; x <= sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { int small = x ; int big = n / x ; if ( small % 2 == big % 2 ) { int a = ( small + big ) / 2 ; int b = ( big - small ) / 2 ; cout << a << " ▁ " << b << endl ; return ; } } } cout << -1 << endl ; }
int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }
int sumoflength ( int arr [ ] , int n ) { unordered_set < int > s ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && s . find ( arr [ j ] ) == s . end ( ) ) { s . insert ( arr [ j ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . erase ( arr [ i ] ) ; } return ans ; }
int findMaxNum ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int num = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { num = num * 10 + arr [ i ] ; } return num ; }
bool iszygodromeNum ( int N ) { string s = to_string ( N ) ; s = ' ▁ ' + s + ' ▁ ' ; for ( int i = 1 ; i < s . size ( ) - 1 ; i ++ ) { if ( s [ i ] != s [ i - 1 ] && s [ i ] != s [ i + 1 ] ) { return false ; } } return true ; }
int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = INT_MAX ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != INT_MAX && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
void splitString ( string S , int N ) { char c = S [ N - 1 ] ; int f = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] == c ) { f = 1 ; break ; } } if ( f ) cout << " Yes " ; else cout << " No " ; }
int floorMax ( int A , int B , int N ) { int x = min ( B - 1 , N ) ; return ( A * x ) / B ; }
void maxSum ( vector < vector < int > > arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = max ( r2 , temp + arr [ 1 ] [ i ] ) ; } cout << max ( r1 , r2 ) ; }
int countPalindromic ( int n ) { int count ; if ( n % 2 == 1 ) { count = pow ( 9 , ( n - 1 ) / 2 ) ; } else { count = pow ( 9 , ( n - 2 ) / 2 ) ; } return count ; }
float knapSack ( int W , float wt [ ] , float val [ ] , int n ) { float maxratio = INT_MIN ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
> smallestSumpair ( int arr [ ] , int n ) { vector < int > pair ; int min_sum = INT_MAX ; for ( int i = 1 ; i < n ; i ++ ) { if ( min_sum > ( arr [ i ] + arr [ i - 1 ] ) ) { min_sum = arr [ i ] + arr [ i - 1 ] ; if ( pair . empty ( ) ) { pair . push_back ( arr [ i - 1 ] ) ; pair . push_back ( arr [ i ] ) ; } else { pair [ 0 ] = arr [ i - 1 ] ; pair [ 1 ] = arr [ i ] ; } } } return pair ; }
int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return -1 ; }
bool isPossible ( int x , int y ) { if ( ( x - y ) == 1 ) return false ; return true ; }
int magicOfSequence ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
int sumOfFirstM ( int A [ ] , int N , int M ) { int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { sum = sum + A [ i % N ] ; } return sum ; }
void findNum ( int n , int k ) { int q = k / ( n - 1 ) ; int r = k % ( n - 1 ) ; int a ; if ( r != 0 ) a = ( n * q ) + r ; else a = ( n * q ) - 1 ; cout << a ; }
double hexagonArea ( double s ) { return ( ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
bool checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
int maxPathSum ( int tri [ ] [ N ] ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
int findMaxSoln ( int n , int x , int y ) { int ans = INT_MIN ; for ( int k = 0 ; k <= n ; k ++ ) { if ( k % x == y ) { ans = max ( ans , k ) ; } } return ( ( ans >= 0 && ans <= n ) ? ans : -1 ) ; }
void find_rectangle ( int area ) { for ( int i = ceil ( sqrt ( area ) ) ; i <= area ; i ++ ) { if ( area / i * i == area ) { printf ( " % d ▁ % d " , i , area / i ) ; return ; } } }
void makearrayequal ( int arr [ ] , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += arr [ i ] & 1 ; } cout << min ( x , n - x ) << endl ; }
int findDuplicate ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int i = 0 ; while ( i < n ) { int j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return -1 ; }
int MaxTraceSub ( int mat [ ] [ N ] ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = max ( trace , max_trace ) ; } } } return max_trace ; }
void printpenta ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 1 ; int curr = 0 ; if ( n == 0 n == 1 n == 2 n == 3 ) cout << first << " STRNEWLINE " ; else if ( n == 5 ) cout << fifth << " STRNEWLINE " ; else { for ( int i = 5 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = curr ; } cout << curr << " STRNEWLINE " ; } }
int maxArea ( float perimeter ) { int length = ( int ) ceil ( perimeter / 4 ) ; int breadth = ( int ) floor ( perimeter / 4 ) ; return length * breadth ; }
int getPosition ( int N , int M ) { if ( M > ( N / 2 ) ) { return ( M - ( N / 2 ) ) ; } return ( M + ( N / 2 ) ) ; }
int PentacontahenagonNum ( int N ) { return ( 49 * N * N - 47 * N ) / 2 ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int sum = 0 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += i ; if ( sum <= K ) res ++ ; else break ; } return res ; }
void min_visible_bottles ( int * arr , int n ) { map < int , int > m ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; ans = max ( ans , m [ arr [ i ] ] ) ; } cout << " Minimum ▁ number ▁ of ▁ " << " Visible ▁ Bottles ▁ are : ▁ " << ans << endl ; }
string perfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int p = sqrt ( arr [ i ] ) ; if ( p * p != arr [ i ] ) { return " No " ; } } return " Yes " ; }
int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
int getNthTerm ( long long int N ) { return 4 * pow ( N , 2 ) - 3 * N + 2 ; }
bool isPossible ( int a [ ] , int n ) { int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != i + 1 ) k ++ ; } if ( k <= 2 ) return true ; return false ; }
int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return -1 ; }
void perfectSquares ( float l , float r ) { int number = ceil ( sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { cout << n2 << " ▁ " ; n2 = n2 + number ; number += 2 ; } }
int firstRepeating ( string & str ) { bool visited [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) visited [ i ] = false ; int res = -1 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( visited [ str [ i ] ] == false ) visited [ str [ i ] ] = true ; else res = i ; } return res ; }
lli squareDigitSum ( string s ) { lli lengthN = s . length ( ) ; lli result = ( lengthN / 9 ) * 81 + pow ( ( lengthN % 9 ) , 2 ) ; return result ; }
void printRepeating ( int arr [ ] , int size ) { set < int > s ( arr , arr + size ) ; for ( auto x : s ) cout << x << " ▁ " ; }
int numberOfObjects ( int N , int M ) { int initial = min ( N , M ) ; int final = ( N + M ) / 3 ; return min ( initial , final ) ; }
int two_sets ( int a [ ] , int n ) { sort ( a , a + n ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; }
int findpos ( string n ) { int pos = 0 ; for ( int i = 0 ; n [ i ] != ' \0' ; i ++ ) { switch ( n [ i ] ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { unordered_set < int > s ; for ( int i = 0 ; i < m ; i ++ ) s . insert ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a [ i ] << " ▁ " ; }
int minimum_sum ( int A [ ] , int N ) { sort ( A , A + N ) ; int sum = INT_MAX ; for ( int i = 0 ; i <= N - 3 ; i ++ ) { sum = min ( sum , abs ( A [ i ] - A [ i + 1 ] ) + abs ( A [ i + 1 ] - A [ i + 2 ] ) ) ; } cout << sum ; }
int swapBits ( unsigned int n , unsigned int p1 , unsigned int p2 ) { unsigned int bit1 = ( n >> p1 ) & 1 ; unsigned int bit2 = ( n >> p2 ) & 1 ; unsigned int x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; unsigned int result = n ^ x ; }
void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) cout << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] << " , ▁ " << A [ l ] ; } } } }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
string fractionToDecimal ( int numr , int denr ) { map < int , int > mp ; mp . clear ( ) ; int rem = numr % denr ; while ( ( rem != 0 ) && ( mp . find ( rem ) == mp . end ( ) ) ) { mp [ rem ] = res . length ( ) ; rem = rem * 10 ; int res_part = rem / denr ; res += to_string ( res_part ) ; rem = rem % denr ; } return ( rem == 0 ) ? " " : res . substr ( mp [ rem ] ) ; }
long countPairs ( long L , long R ) { long firstNum = 2 * L ; long lastNum = 2 * R ; long Cntpairs = lastNum - firstNum + 1 ; cout << Cntpairs ; }
int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
float Area ( float r ) { if ( r < 0 ) return -1 ; float x = ( 2 * r ) / sqrt ( 5 ) ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }
float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; return ( l * b ) / 2 ; }
bool isPossible ( int a [ ] , int n ) { int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; }
int maximizeFinalElement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; }
void additiveCongruentialMethod ( int Xo , int m , int c , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m ; } }
int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans = -1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ans == -1 ) ans = ( A [ i ] & B [ j ] ) ; else ans ^= ( A [ i ] & B [ j ] ) ; } } return ans ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
bool isPrime ( int p ) { long long checkNumber = pow ( 2 , p ) - 1 ; long long nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
int minimumSteps ( int a , int b ) { int cnt = 0 ; a = abs ( a - b ) ; cnt = ( a / 5 ) + ( a % 5 ) / 2 + ( a % 5 ) % 2 ; return cnt ; }
bool isPowerOfFour ( unsigned int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; }
float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
void splitArray ( int arr [ ] , int n , int K ) { sort ( arr , arr + n ) ; int i = n - 1 ; int result = 0 ; while ( K -- ) { result += arr [ i - 1 ] ; i -= 2 ; } cout << result ; }
int count ( int a [ ] , int n ) { int countElements = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool flag = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; }
int minMaxDiff ( int arr [ ] , int n , int k ) { int max_adj_dif = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = max ( max_adj_dif , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; }
int icosikaienneagonalNum ( int n ) { return ( 27 * n * n - 25 * n ) / 2 ; }
void removeRecurringDigits ( char num [ ] ) { int len = strlen ( num ) ; for ( int i = 0 ; i < len ; i ++ ) { num [ j ++ ] = num [ i ] ; while ( i + 1 < len && num [ i ] == num [ i + 1 ] ) i ++ ; }
int makeZero ( int x , int y , int a , int b ) { if ( x > y ) x = y , y = x ; int tot_cost = ( y - x ) * a ; int cost1 = 2 * x * a ; int cost2 = x * b ; tot_cost += min ( cost1 , cost2 ) ; cout << tot_cost ; }
int Circumference ( int a ) { return 4 * a ; }
int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
bool isHexagonal ( int N ) { float val = 8 * N + 1 ; float x = 1 + sqrt ( val ) ; float n = ( x ) / 4 ; if ( ( n - ( int ) n ) == 0 ) return true ; else return false ; }
int items ( int n , int a [ ] ) { sort ( a , a + n ) ; int z = a [ n - 1 ] ; int x = 1 ; int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }
int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n , int t ) { int maxRev [ m + 1 ] ; memset ( maxRev , 0 , sizeof ( maxRev ) ) ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
void findX ( int targetValue ) { int start = 0 , end = targetValue ; int mid , result ; while ( start <= end ) { mid = start + ( end - start ) / 2 ; if ( mid * mid <= targetValue ) { result = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } cout << result << endl ; }
void findSetBits ( int n ) { int dp [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; cout << dp [ 0 ] << " ▁ " ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i / 2 ] ; } else { dp [ i ] = dp [ i / 2 ] + 1 ; } cout << dp [ i ] << " ▁ " ; } }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; }
int maxGameByWinner ( int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
int maxSum ( int a [ ] , int n ) { sort ( a , a + n ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; }
int countNum ( int arr [ ] , int n ) { unordered_set < int > s ; int count = 0 , maxm = INT_MIN , minm = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( s . find ( arr [ i ] ) == s . end ( ) ) count ++ ; return count ; }
void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; cout << first << " ▁ " ; if ( n > 1 ) cout << second << " ▁ " ; if ( n > 2 ) cout << second << " ▁ " ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; cout << curr << " ▁ " ; } }
void findGreater ( int a , int b , int n ) { if ( ! ( n & 1 ) ) { a = abs ( a ) ; b = abs ( b ) ; } if ( a == b ) cout << " a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n " ; else if ( a > b ) cout << " a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n " ; else cout << " b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n " ; }
float harmonicMean ( int arr [ ] , int freq [ ] , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return frequency_sum / sum ; }
void count ( int n , int k ) { long count = ( long ) ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; cout << ( count ) ; }
void printBinaryString ( int arr [ ] [ 3 ] , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 ) { cout << 0 ; } else { cout << 1 ; } } }
void swapTwoHalves ( string a , string b ) { int la = a . length ( ) ; int lb = b . length ( ) ; string c = a . substr ( 0 , la / 2 ) + b . substr ( lb / 2 , lb ) ; string d = b . substr ( 0 , lb / 2 ) + a . substr ( la / 2 , la ) ; cout << c << endl << d << endl ; }
int find ( int A , int B , int C , int N ) { int arr [ N ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; for ( int i = 3 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 3 ] ; } return arr [ N - 1 ] ; }
int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m , a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
double findAverage ( int N ) { double S = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { S += i * i * i * i ; } return S / N ; }
bool checkHankelMatrix ( int n , int m [ N ] [ N ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }
int maxSize ( vector < int > & v , int n ) { v . push_back ( 0 ) ; v . push_back ( 100001 ) ; n += 2 ; sort ( v . begin ( ) , v . end ( ) ) ; int mx = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int L = v [ i - 1 ] + 1 ; int R = v [ i + 1 ] - 1 ; int cnt = R - L + 1 ; mx = max ( mx , cnt ) ; } return mx ; }
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
void printAlter ( int arr [ ] , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex += 2 ) { cout << arr [ currIndex ] << " ▁ " ; } }
int maxCostToRemove ( int arr [ ] , int N , int K ) { int maxCost = 0 ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i += K ) { maxCost += arr [ i + 1 ] ; } return maxCost ; }
int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = INT_MAX ; int index = -1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) + n - 2 ; }
long sumOfSumSeries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = sqrt ( pow ( x , 2 ) + pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) cout << " Fits STRNEWLINE " ; else cout << " Doesn ' t ▁ Fit STRNEWLINE " ; }
void countNums ( int N ) { int l = ( int ) pow ( 10 , N - 1 ) ; int r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int xorr = 0 , temp = i ; while ( temp > 0 ) { xorr = xorr ^ ( temp % 10 ) ; temp /= 10 ; } if ( xorr <= 9 ) count ++ ; } cout << count ; }
void countSubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } cout << " ▁ " << count ; }
void removeLeadingZeros ( string str ) { const regex pattern ( " ^ 0 + ( ? ! $ ) " ) ; str = regex_replace ( str , pattern , " " ) ; cout << str ; }
int maxProfit ( int price [ ] , int n ) { int buy1 , profit1 , buy2 , profit2 ; buy1 = buy2 = INT_MAX ; profit1 = profit2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { buy1 = min ( buy1 , price [ i ] ) ; profit1 = max ( profit1 , price [ i ] - buy1 ) ; buy2 = min ( buy2 , price [ i ] - profit1 ) ; profit2 = max ( profit2 , price [ i ] - buy2 ) ; } return profit2 ; }
float distance ( int x1 , int y1 , int x2 , int y2 ) { return sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) * 1.0 ) ; }
int calculateSum ( int n ) { return pow ( n * ( n + 1 ) / 2 , 2 ) ; }
bool containsElement ( int arr [ ] , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; ++ i ) xorArr ^= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { int x = xorArr ^ arr [ i ] ; if ( arr [ i ] == x ) return true ; } return false ; }
int numSeq ( int n ) { return ( pow ( 3 , n ) + 3 * pow ( -1 , n ) ) / 4 ; }
void minOpsToTurnArrToZero ( int arr [ ] , int N ) { unordered_set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . find ( arr [ i ] ) != st . end ( ) arr [ i ] == 0 ) { continue ; } else { st . insert ( arr [ i ] ) ; } } cout << st . size ( ) << endl ; }
float Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / float ( N1 ) ; return rate ; }
void perfectCube ( int N ) { int cube_root ; cube_root = round ( cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { cout << " Yes " ; return ; } else { cout << " NO " ; return ; } }
void minBox ( int arr [ ] , int n ) { int box = n ; sort ( arr , arr + n ) ; int curr_box = 0 , next_box = 1 ; while ( curr_box < n && next_box < n ) { if ( arr [ curr_box ] < arr [ next_box ] ) { box -- ; curr_box ++ ; next_box ++ ; } else if ( arr [ curr_box ] == arr [ next_box ] ) next_box ++ ; } cout << box << endl ; }
int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
long fun ( int marks [ ] , int n ) { long long dp [ n ] , temp ; fill ( dp , dp + n , 1 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
int countsubarray ( int array [ ] , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
int count ( string S , int X ) { int count = 0 ; const int N = S . length ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] != '0' ) { for ( int len = 1 ; ( i + len ) <= N ; ++ len ) { if ( stoi ( S . substr ( i , len ) ) > X ) count ++ ; } } } return count ; }
int contiguousPerfectSquare ( int arr [ ] , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = sqrt ( arr [ i ] ) ; a = b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; }
void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; cout << max ( max ( left , right ) , max ( above , below ) ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * b ; b = solve ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << b [ i ] << " ▁ " ; }
void closestsAngle ( int N , int A ) { double mi = INT_MAX ; int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { double angle = 180.0 * i / N ; if ( fabs ( angle - A ) < fabs ( mi - A ) ) { mi = angle ; ans = i ; } } cout << 2 << ' ▁ ' << 1 << ' ▁ ' << 2 + ans ; }
void findMinimumTime ( string tasks , int K ) { unordered_map < char , int > map ; int curr_time = 0 ; for ( char c : tasks ) { if ( map . find ( c ) != map . end ( ) ) { if ( curr_time - map <= K ) { curr_time += K - ( curr_time - map ) + 1 ; } } map = curr_time ; curr_time ++ ; } cout << curr_time ; }
int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
float calTime ( float arr [ ] , int n ) { float work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; }
string removeDuplicates ( string str ) { int n = str . length ( ) ; string res = " " ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) break ; if ( j == n ) res = res + str [ i ] ; } return res ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
int evenPowerSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
int kthOdd ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return -1 ; }
void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) cout << arr [ k ] << " ▁ " ; cout << endl ; } } }
bool checkSolution ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { return ( a1 / a2 ) == ( b1 / b2 ) && ( b1 / b2 ) == ( c1 / c2 ) ; }
int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
int minOperations ( string S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . size ( ) ; j += K ) { if ( S [ j ] == '0' ) zero ++ ; else one ++ ; } ans += min ( zero , one ) ; } return ans ; }
double subfactorial ( int N ) { double res = 0 , fact = 1 ; int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - ( 1 / fact ) ; else res = res + ( 1 / fact ) ; count ++ ; } return fact * ( 1 + res ) ; }
void find_numbers ( int N ) { if ( N == 1 ) { cout << -1 ; } else { cout << N << " ▁ " << N + 1 << " ▁ " << N * ( N + 1 ) ; } }
int decimalToBinary ( int N ) { ull B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; ull c = pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
int maxSumPair ( int arr [ ] , int N , int k ) { int maxSum = 0 ; sort ( arr , arr + N ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; ( 1 << i ) < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
int findSum ( int * arr , int n , int k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
string findMaximumNum ( string str , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str [ i ] != '9' ) { str [ i ] = '9' ; k -- ; } } return str ; }
void productOfTwoPerfectCubes ( int N ) { int cube_root ; cube_root = round ( cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { cout << " Yes " ; return ; } else { cout << " No " ; return ; } }
bool isSubseqPossible ( int arr [ ] , int N , int K ) { int i ; int odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
int naive_find_x ( int N ) { int c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; }
void findNumbers ( int aXORb , int aANDb , int aXORc , int aANDc , int bXORc , int bANDc ) { int a , b , c ; int aSUMb ; int aSUMc ; int bSUMc ; aSUMb = aXORb + aANDb * 2 ; aSUMc = aXORc + aANDc * 2 ; bSUMc = bXORc + bANDc * 2 ; a = ( aSUMb - bSUMc + aSUMc ) / 2 ; b = aSUMb - a ; c = aSUMc - a ; cout << " a ▁ = ▁ " << a ; cout << " , ▁ b ▁ = ▁ " << b ; cout << " , ▁ c ▁ = ▁ " << c ; }
void createArray ( int n , int s ) { if ( 2 * n <= s ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << "2" << " ▁ " ; s -= 2 ; } cout << s << endl ; cout << "1" << endl ; } else cout << " - 1" << endl ; }
int countSquareMatrices ( int a [ ] [ m ] , int N , int M ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] == 0 ) continue ; a [ i ] [ j ] = min ( min ( a [ i - 1 ] [ j ] , a [ i ] [ j - 1 ] ) , a [ i - 1 ] [ j - 1 ] ) + 1 ; } } for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) count += a [ i ] [ j ] ; return count ; }
int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 0 ; i < arr_size ; i ++ ) { for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }
int getCount ( int N , int M ) { int total_count = 0 ; total_count += ( N / 10 ) ; int x = ( N / 10 ) * 10 ; if ( ( N - x ) >= M ) { total_count = total_count + 1 ; } return total_count ; }
void converthenumber ( int n ) { string s = to_string ( n ) ; string res ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' s [ i ] == '3' s [ i ] == '5' s [ i ] == '7' s [ i ] == '9' ) res += s [ i ] ; if ( res . size ( ) == 2 ) break ; } if ( res . size ( ) == 2 ) cout << res << endl ; else cout << " - 1" << endl ; }
int recaman ( int n ) { int arr [ n ] ; arr [ 0 ] = 0 ; printf ( " % d , ▁ " , arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; printf ( " % d , ▁ " , arr [ i ] ) ; } }
int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long long int ef1 = 0 , ef2 = 2 ; long long int sum = ef1 + ef2 ; while ( ef2 <= limit ) { long long int ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }
int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
int minLength ( string S ) { stack < char > st ; for ( auto ch : S ) { if ( st . empty ( ) ) st . push ( ch ) ; else { char top = st . top ( ) ; if ( abs ( ch - top ) == 1 ) st . pop ( ) ; else { st . push ( ch ) ; } } } return st . size ( ) ; }
int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
int sumOfSeries ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
void foot ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << " ▁ x2 ▁ = ▁ " << x2 ; cout << " ▁ y2 ▁ = ▁ " << y2 ; cout << " ▁ z2 ▁ = ▁ " << z2 ; }
void findNthNumber ( int N ) { long long arr [ N + 1 ] ; queue < long long > q ; for ( int i = 1 ; i <= 9 ; i ++ ) q . push ( i ) ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i ] = q . front ( ) ; q . pop ( ) ; if ( arr [ i ] % 10 != 0 ) q . push ( arr [ i ] * 10 + arr [ i ] % 10 - 1 ) ; q . push ( arr [ i ] * 10 + arr [ i ] % 10 ) ; if ( arr [ i ] % 10 != 9 ) q . push ( arr [ i ] * 10 + arr [ i ] % 10 + 1 ) ; } cout << arr [ N ] << endl ; }
void hasEqualBlockFrequency ( int N ) { string S = bitset < 3 > ( N ) . to_string ( ) ; set < int > p ; int c = 1 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S [ i ] == S [ i + 1 ] ) c += 1 ; else { p . insert ( c ) ; c = 1 ; } p . insert ( c ) ; } if ( p . size ( ) == 1 ) cout << " Yes " << endl ; else cout << " No " << endl ; }
bool isDudeney ( int n ) { int cube_rt = int ( round ( ( pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; int dig_sum = 0 ; int temp = n ; while ( temp > 0 ) { int rem = temp % 10 ; dig_sum += rem ; temp /= 10 ; } if ( cube_rt != dig_sum ) return false ; return true ; }
int gonNum120 ( int n ) { return ( 118 * n * n - 116 * n ) / 2 ; }
int largest_subarray ( int a [ ] , int n ) { unordered_map < int , int > index ; int ans = 0 ; for ( int i = 0 , j = 0 ; i < n ; i ++ ) { j = max ( index [ a [ i ] ] , j ) ; ans = max ( ans , i - j + 1 ) ; index [ a [ i ] ] = i + 1 ; } return ans ; }
int maxSumBitonicSubArr ( int arr [ ] , int n ) { int msis [ n ] , msds [ n ] ; int max_sum = INT_MIN ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
int NumberOfways ( int N , int K ) { vector < int > dp ( N + 1 , 0 ) ; dp [ 0 ] = 1 ; for ( int row = 1 ; row < K + 1 ; row ++ ) { for ( int col = 1 ; col < N + 1 ; col ++ ) { if ( col >= row ) dp [ col ] = dp [ col ] + dp [ col - row ] ; } } return ( dp [ N ] ) ; }
string removeSpaces ( string str ) { str . erase ( remove ( str . begin ( ) , str . end ( ) , ' ▁ ' ) , str . end ( ) ) ; return str ; }
bool areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( set1 [ i ] == set2 [ j ] ) return false ; return true ; }
bool isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
int totalPay ( int totalItems , int priceOfOneItem , int N , int M ) { int freeItems = 0 , actual = 0 ; freeItems = totalItems / ( N + M ) ; actual = totalItems - freeItems ; int amount = actual * priceOfOneItem ; return amount ; }
int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
void findMax ( int a [ ] , int n ) { int dp [ n ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } cout << max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) ; }
double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }
int minimum_deci_binary_number ( string s ) { int m = INT_MIN ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { int temp = s [ i ] - '0' ; if ( temp > m ) { m = temp ; } } return m ; }
int countDer ( int n ) { int der [ n + 1 ] = { 0 } ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
void printFreq ( vector < int > & arr , int N ) { int freq = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { freq ++ ; } else { cout << " Frequency ▁ of ▁ " << arr [ i - 1 ] << " ▁ is : ▁ " << freq << endl ; freq = 1 ; } } cout << " Frequency ▁ of ▁ " << arr [ N - 1 ] << " ▁ is : ▁ " << freq << endl ; }
int transformSubsequence ( int n , int m , vector < int > A , vector < int > B ) { if ( B . size ( ) == 0 ) return n ; vector < vector < int > > dp ( n + 1 , vector < int > ( m + 1 , 0 ) ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 or j == 0 ) dp [ i ] [ j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return n - dp [ n ] [ m ] ; }
double probability ( vector < int > arr1 , vector < int > arr2 ) { int N = arr1 . size ( ) ; int M = arr2 . size ( ) ; double res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int y = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr2 [ j ] > arr1 [ i ] ) y ++ ; } res += y ; } res = ( double ) res / ( double ) ( N * M ) ; return res ; }
string make_palindrome ( string S1 , string S2 , string S3 ) { int maskA = 0 , maskC = 0 ; for ( char i : S1 ) maskA |= ( 1 << ( i - ' a ' ) ) ; for ( char i : S3 ) maskC |= ( 1 << ( i - ' a ' ) ) ; if ( ( maskA & maskC ) > 0 ) return " YES " ; return " NO " ; }
void FindSub ( string str , string res , int i ) { if ( i == str . length ( ) ) { if ( res . length ( ) > 0 ) { cout << res << " ▁ " ; } return ; } char ch = str [ i ] ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + to_string ( int ( ch ) ) , i + 1 ) ; }
int findSubstrings ( string s , int k ) { int ans = 0 ; int cnt [ 26 ] ; int i , j , n = s . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( j = i ; j < n ; j ++ ) { cnt [ s [ j ] - ' a ' ] ++ ; if ( cnt [ s [ j ] - ' a ' ] <= k ) ans ++ ; else break ; } } return ans ; }
int substringConversions ( string str , int k , int b ) { for ( int i = 0 ; i + k <= str . size ( ) ; i ++ ) { string sub = str . substr ( i , k ) ; int sum = 0 , counter = 0 ; for ( int i = sub . size ( ) - 1 ; i >= 0 ; i -- ) { sum = sum + ( ( sub . at ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } cout << sum << " ▁ " ; } }
int nDigitPalindromes ( int n ) { return ( 9 * pow ( 10 , ( n - 1 ) / 2 ) ) ; }
void RearrangePosNeg ( int arr [ ] , int n ) { int i = 0 ; int j = n - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < n ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } }
void occurredOnce ( int arr [ ] , int n ) { int i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else cout << arr [ i - 1 ] << " ▁ " ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) cout << arr [ n - 1 ] ; }
int posOfRightMostSameBit ( int m , int n ) { int loopCounter = 1 ; while ( m > 0 n > 0 ) { bool a = m % 2 == 1 ; bool b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return -1 ; }
void printSinX ( int N ) { int Xi = 0 ; int num = 1 ; while ( N -- ) { cout << " X " << num << " ▁ = ▁ " << Xi ; cout << " ▁ sin ( X " << num << " ) ▁ = ▁ " << fixed ; cout << setprecision ( 6 ) << sin ( Xi ) << endl ; num += 1 ; Xi += 710 ; } }
void findCommon ( int ar1 [ ] , int ar2 [ ] , int ar3 [ ] , int n1 , int n2 , int n3 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 && k < n3 ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { cout << ar1 [ i ] << " ▁ " ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } }
int summation ( int n ) { int abs_sum = n * ( n + 1 ) / 2 ; int sign = n + 1 % 2 == 0 ? 1 : -1 ; int result_sum = sign * abs_sum ; return result_sum ; }
int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
void reverse ( string str , int x ) { int n = ( str . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) cout << str [ i ] ; for ( int i = n + x - 1 ; i >= n ; i -- ) cout << str [ i ] ; for ( int i = n + x ; i < str . length ( ) ; i ++ ) cout << str [ i ] ; }
int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; }
int count ( struct Node * head , int key ) { if ( head == NULL ) return 0 ; if ( head -> data == key ) return 1 + count ( head -> next , key ) ; return count ( head -> next , key ) ; }
int sumOfSubstrings ( string num ) { long long int mf = 1 ; for ( int i = num . size ( ) - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
int oddbitsetnumber ( int n ) { int count = 0 ; int res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; }
void SubarraysWithSumS ( int n , int k , int s ) { for ( int i = 0 ; i < k ; i ++ ) cout << s << " ▁ " ; for ( int i = k ; i < n ; i ++ ) cout << s + 1 << " ▁ " ; }
void count ( string str1 , string str2 ) { int c = 0 , j = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str2 . find ( str1 [ i ] ) >= 0 and j == str1 . find ( str1 [ i ] ) ) c += 1 ; j += 1 ; } cout << " No . ▁ of ▁ matching ▁ characters ▁ are : ▁ " << c / 2 ; }
void decodeStr ( string str , int len ) { char c [ len ] = " " ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len & 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) cout << c [ i ] ; }
void canBreakN ( long long n ) { for ( long long i = 2 ; ; i ++ ) { long long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long long k = n - m ; if ( k % i ) continue ; cout << i << endl ; return ; } cout << " - 1" ; }
long sumOddFibonacci ( int n ) { long long Sum [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }
float computeMaxValue ( float arr [ ] , int n ) { float ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { float val = max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = max ( ans , val ) ; } } return ans ; }
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; cout << edges_max_secondary + 3 ; } else cout << " Not ▁ Possible " ; }
int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
int FindSum ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = log2 ( arr [ i ] ) ; int LesserValue = pow ( 2 , power ) ; int LargerValue = pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; }
void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; cout << r ; }
int countSetBits ( int N ) { int count = 0 ; while ( N ) { N = N & ( N - 1 ) ; count ++ ; } return count ; }
int isSumDivides ( int N ) { int temp = N ; int sum = 0 ; while ( temp ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
void lengthOfTangent ( double r1 , double r2 , double d ) { cout << " The ▁ length ▁ of ▁ the ▁ transverse " << " ▁ common ▁ tangent ▁ is ▁ " << sqrt ( pow ( d , 2 ) - pow ( ( r1 + r2 ) , 2 ) ) << endl ; }
string multiply ( string num1 , string num2 ) { int n1 = num1 . size ( ) ; int n2 = num2 . size ( ) ; if ( n1 == 0 n2 == 0 ) return "0" ; vector < int > result ( n1 + n2 , 0 ) ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 [ i ] - '0' ; i_n2 = 0 ; for ( int j = n2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 [ j ] - '0' ; int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . size ( ) - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == -1 ) return "0" ; string s = " " ; while ( i >= 0 ) s += std :: to_string ( result [ i -- ] ) ; return s ; }
void make_sequence ( int N ) { int arr [ N + 1 ] , sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( int i = 1 ; i <= N ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; }
void AreaFactor ( int n ) { double pi = 3.14159265 ; double areaf = 1 / ( cos ( pi / n ) * cos ( pi / n ) ) ; cout << fixed << setprecision ( 6 ) << areaf << endl ; }
float exponential ( int n , float x ) { float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
void radius ( int n , int d ) { cout << " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " << d / ( n - 1 ) << endl ; }
void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = max ( x1 , x3 ) ; int y5 = max ( y1 , y3 ) ; int x6 = min ( x2 , x4 ) ; int y6 = min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { cout << " No ▁ intersection " ; return ; } cout << " ( " << x5 << " , ▁ " << y5 << " ) ▁ " ; cout << " ( " << x6 << " , ▁ " << y6 << " ) ▁ " ; int x7 = x5 ; int y7 = y6 ; cout << " ( " << x7 << " , ▁ " << y7 << " ) ▁ " ; int x8 = x6 ; int y8 = y5 ; cout << " ( " << x8 << " , ▁ " << y8 << " ) ▁ " ; }
int check ( string str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 9 == 0 ) ; }
int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; unsigned int Xor = ( set1 ^ set2 ) ; Xor = ( Xor << p1 ) | ( Xor << p2 ) ; unsigned int result = x ^ Xor ; return result ; }
bool isheptagonal ( int N ) { float n = ( 3 + sqrt ( 40 * N + 9 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
int areaSquare ( int side ) { int area = side * side ; return area ; }
bool ContinuousElements ( int a [ ] , int n ) { if ( n == 1 ) return false ; int curr = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { if ( curr == 1 ) return false ; else curr = 0 ; } curr ++ ; } if ( curr == 1 ) return false ; return true ; }
void print_triplet ( int arr [ ] , int n ) { for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { cout << i - 1 << " ▁ " << i << " ▁ " << i + 1 ; return ; } } cout << -1 ; }
int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
int maxOR ( int arr [ ] , int n ) { int max_value = * max_element ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; }
bool isMultipleof5 ( int n ) { char str [ MAX ] ; int len = strlen ( str ) ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; }
bool isInGivenBase ( string str , int base ) { if ( base > 16 ) return false ; else if ( base <= 10 ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( str [ i ] >= '0' and str [ i ] < ( '0' + base ) ) ) return false ; } else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( ( str [ i ] >= '0' && str [ i ] < ( '0' + base ) ) || ( str [ i ] >= ' A ' && str [ i ] < ( ' A ' + base - 10 ) ) ) ) return false ; } return true ; }
int findMaxCock ( int ar [ R ] [ C ] ) { if ( R < 3 C < 3 ) return -1 ; int max_sum = INT_MIN ; for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) { int sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = max ( max_sum , sum ) ; } } return max_sum ; }
int countUnsetBits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp ) { if ( temp % 2 == 0 ) cnt ++ ; temp = temp / 2 ; } } return cnt ; }
int calcSum ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i <= n - k ; i ++ ) { int sum = 0 ; for ( int j = i ; j < k + i ; j ++ ) sum += arr [ j ] ; cout << sum << " ▁ " ; } }
bool LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }
int minLength ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; }
int XorAscii ( string str , int len ) { int ans = int ( str [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( int ( str [ i ] ) ) ) ; } return ans ; }
double circumference ( double r ) { double cir = 2 * PI * r ; return cir ; }
int smallestNumber ( int N ) { return N * ceil ( pow ( 10 , ( N - 1 ) ) / N ) ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return -1 ; int max_product = INT_MIN ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
void countOfNumbers ( int N ) { int ans = 1 ; for ( int index = 1 ; index <= N ; ++ index ) { int choices = 0 ; for ( int digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * 1LL * choices ) % mod ; } cout << ans << endl ; }
int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
double e ( int x , int n ) { static double p = 1 , f = 1 ; double r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; }
int maxSum ( int a [ ] , int n , int k ) { if ( n <= 0 ) return 0 ; int option = maxSum ( a , n - 1 , k ) ; if ( k >= a [ n - 1 ] ) option = max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) ; return option ; }
void countNo ( int A , int N , int L , int R ) { int ans = L - 1 + N + floor ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } cout << ans << endl ; }
bool checkStar ( int mat [ ] [ size ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
int findSubarraySum ( int arr [ ] , int n , int sum ) { unordered_map < int , int > prevSum ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . find ( currsum - sum ) != prevSum . end ( ) ) res += ( prevSum [ currsum - sum ] ) ; prevSum [ currsum ] ++ ; } return res ; }
int CountCharacters ( string str , int k ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] < k ) cnt ++ ; } return cnt ; }
int subsequence ( int S [ ] , int T [ ] , int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j <= m ; j ++ ) dp [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; dp [ i ] [ j ] += mod ; dp [ i ] [ j ] %= mod ; } } return dp [ n ] [ m ] ; }
int minFlips ( string target ) { char curr = '1' ; int count = 0 ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { if ( target [ i ] == curr ) { count ++ ; curr = ( char ) ( 48 + ( curr + 1 ) % 2 ) ; } } return count ; }
int MinimumCost ( int A [ ] , int B [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = min ( mod_B , B [ i ] - mod_B ) ; totalCost += min ( totalCost_A , totalCost_B ) ; } return totalCost ; }
int fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
int Nth_of_AP ( int a , int d , int N ) { return ( a + ( N - 1 ) * d ) ; }
bool validate ( long long int n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long long int temp = n ; int count = 0 ; while ( temp ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }
void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; cout << " Perpendicular ▁ distance ▁ is ▁ " << ( d / e ) ; return ; }
void printSeriesSum ( int N ) { long long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += pow ( i , i - 1 ) ; } cout << sum << endl ; }
int getGreatestSum ( int a [ ] [ N ] ) { int prev_max = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ; int sum = prev_max ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int curr_max = INT_MIN ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ; if ( curr_max == INT_MIN ) return -1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; }
int findCount ( int d ) { return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 , d - 1 ) ) ; }
void Loss ( int SP , int P ) { float loss = 0 ; loss = ( 2 * P * P * SP ) / float ( 100 * 100 - P * P ) ; cout << " Loss ▁ = ▁ " << loss ; }
int swapBits ( unsigned int num , unsigned int p1 , unsigned int p2 , unsigned int n ) { int shift1 , shift2 , value1 , value2 ; while ( n -- ) { shift1 = 1 << p1 ; shift2 = 1 << p2 ; value1 = ( ( num & shift1 ) ) ; value2 = ( ( num & shift2 ) ) ; if ( ( ! value1 && value2 ) || ( ! value2 && value1 ) ) { if ( value1 ) { num = num & ( ~ shift1 ) ; num = num | shift2 ; } else { num = num & ( ~ shift2 ) ; num = num | shift1 ; } } p1 ++ ; p2 ++ ; } return num ; }
int lds ( int arr [ ] , int n ) { int lds [ n ] ; lds [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lds [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( lds [ j ] != 0 && arr [ i ] % arr [ j ] == 0 ) lds [ i ] = max ( lds [ i ] , lds [ j ] + 1 ) ; } return * max_element ( lds , lds + n ) ; }
double findEdges ( double s1 , double s2 , double s3 ) { double a = sqrt ( s1 * s2 / s3 ) ; double b = sqrt ( s3 * s1 / s2 ) ; double c = sqrt ( s3 * s2 / s1 ) ; double sum = a + b + c ; return 4 * sum ; }
void shortdis ( double r , double d ) { cout << " The ▁ shortest ▁ distance ▁ " << " from ▁ the ▁ chord ▁ to ▁ centre ▁ " << sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) << endl ; }
int getMaxOnes ( int n , int x ) { int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; int total = n * n ; int ans = total - zeroes ; return ans ; }
float octaside ( float a ) { if ( a < 0 ) return -1 ; float s = a / ( sqrt ( 2 ) + 1 ) ; return s ; }
int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
void sumFib ( int N ) { double num = ( 1 - sqrt ( 5 ) ) / 2 ; long val = round ( abs ( 1 / ( pow ( num , N + 2 ) + pow ( num , N + 1 ) + pow ( num , N ) + pow ( num , N - 1 ) ) ) - 1 ) ; cout << val ; }
int increment ( unsigned int i ) { i = - ( ~ i ) ; return i ; }
int percent ( int a , int b ) { float result = 0 ; result = ( ( b - a ) * 100 ) / a ; return result ; }
void bestApproximate ( int x [ ] , int y [ ] , int n ) { float m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; cout << " m ▁ = " << m ; cout << " c = " }
int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( l <= str [ i ] and str [ i ] <= r ) { cnt ++ ; cout << str [ i ] << " ▁ " ; } } return cnt ; }
int findMinimumK ( int a [ ] , int n , int S ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return ceil ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) ; }
int squaresum ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
float heightCalculate ( int H , int n , int m ) { float N = n * 1.0 ; float M = m * 1.0 ; float h = H * sqrt ( N / ( N + M ) ) ; return h ; }
void BeattySequence ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { double ans = floor ( i * sqrt ( 2 ) ) ; cout << ans << " , ▁ " ; } }
bool CheckForSequence ( int arr [ ] , int n , int k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; }
void findRemainders ( ll n ) { set < ll > vc ; for ( ll i = 1 ; i <= ceil ( sqrt ( n ) ) ; i ++ ) vc . insert ( n / i ) ; for ( ll i = n / ceil ( sqrt ( n ) ) - 1 ; i >= 0 ; i -- ) vc . insert ( i ) ; for ( auto it : vc ) cout << it << " ▁ " ; }
int findSum ( int arr [ ] , int n , int left , int right ) { int k = right - left + 1 ; int d = arr [ 1 ] / arr [ 0 ] ; int ans = arr [ left - 1 ] ; if ( d == 1 ) ans = ans * d * k ; else ans = ans * ( ( int ) pow ( d , k ) - 1 / ( d - 1 ) ) ; return ans ; }
bool isValid ( char s [ ] ) { char * p ; if ( ( p = strstr ( s , " geek " ) ) && ( strstr ( p + 4 , " keeg " ) ) ) return true ; return false ; }
int No_of_rectangles ( int L , int B , int l , int b ) { if ( ( l > L ) || ( b > B ) ) { return -1 ; } else { return ( L - l + 1 ) * ( B - b + 1 ) ; } }
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; int max_product = INT_MIN ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
int motzkin ( int n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; }
int ways ( int arr [ ] , int n ) { int dp [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; }
void printRLE ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count ++ ; i ++ ; } cout << str [ i ] << count ; } }
int getMax ( int arr [ ] , int N , int K ) { for ( int i = 1 ; i < N ; i ++ ) { int cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } cout << arr [ 0 ] ; }
int countIndices ( int arr [ ] , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; }
bool divisibleBy20 ( string num ) { int lastTwoDigits = stoi ( num . substr ( num . length ( ) - 2 , num . length ( ) - 1 ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
int findLeastDist ( int A [ ] , int N ) { sort ( A , A + N ) ; if ( N % 2 == 0 ) { return A [ ( N - 1 ) / 2 ] ; } else { return A [ N / 2 ] ; } }
void minLength ( string & S , string & T , int N , int M ) { string temp ; int subtract = 0 ; for ( int i = 0 ; i < N ; ++ i ) { temp . push_back ( S [ i ] ) ; if ( temp . size ( ) >= M ) { if ( temp . substr ( temp . size ( ) - M , M ) == T ) { subtract += M ; int cnt = 0 ; while ( cnt != M ) { temp . pop_back ( ) ; ++ cnt ; } } } } cout << ( N - subtract ) << " STRNEWLINE " ; }
bool ispowerof2 ( cpp_int num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }
int getSum ( int n ) { return ( ( n - 1 ) + pow ( n , 2 ) ) ; }
float sph ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = r ; return R ; }
float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ; return corr ; }
int printMinimumProduct ( int arr [ ] , int n ) { int first_min = min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
int findHours ( int a , int b , int k ) { if ( a >= b ) return -1 ; int time = k / ( b - a ) ; time = time + 1 ; return time ; }
int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = numeric_limits < int > :: min ( ) ; int prefix_sum [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
float strikerate ( int bowls , int runs ) { float z ; z = ( float ( runs ) / bowls ) * 100 ; return z ; }
void lowerWythoff ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2.0 ; for ( int i = 1 ; i <= n ; i ++ ) { double ans = floor ( i * phi ) ; cout << ans ; if ( i != n ) cout << " , ▁ " ; } }
int k_nonzero_numbers ( string s , int n , int k ) { int dp [ n + 1 ] [ 2 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) for ( int x = 0 ; x <= k ; x ++ ) dp [ i ] [ j ] [ x ] = 0 ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; ++ i ) { int sm = 0 ; while ( sm < 2 ) { for ( int j = 0 ; j < k + 1 ; ++ j ) { int x = 0 ; while ( x <= ( sm ? 9 : s [ i ] - '0' ) ) { dp [ i + 1 ] [ sm || x < ( s [ i ] - '0' ) ] [ j + ( x > 0 ) ] += dp [ i ] [ sm ] [ j ] ; ++ x ; } } ++ sm ; } } return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] ; }
void printRepeating ( int arr [ ] , int size ) { int i ; cout << " The ▁ repeating ▁ elements ▁ are " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else cout << " ▁ " << abs ( arr [ i ] ) << " ▁ " ; } }
void countSubstrings ( string s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; for ( auto & i : s ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } cout << ans << endl ; }
void find ( int n ) { cout << n / 2 << endl ; }
int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int countKCountdown ( int arr [ ] , int N , int K ) { int flag = -1 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) flag = K ; if ( arr [ i ] == flag ) flag -- ; else flag = -1 ; if ( flag == 0 ) count ++ ; } return count ; }
ll findMaxPairs ( ll a [ ] , ll b [ ] , ll n , ll k ) { sort ( a , a + n ) ; sort ( b , b + n ) ; bool flag [ n ] ; memset ( flag , false , sizeof ( flag ) ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - b [ j ] ) <= k && flag [ j ] == false ) { result ++ ; flag [ j ] = true ; break ; } } } return result ; }
int maxSum ( int grid [ 2 ] [ MAX ] , int n ) { int incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = max ( excl , incl ) ; incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return max ( excl , incl ) ; }
int pay ( int n ) { int cuts = int ( log ( n ) / log ( 2 ) ) ; return cuts ; }
float areaOfKite ( int a , int b , double angle ) { angle = angle * PI ; double area = a * b * sin ( angle ) ; return area ; }
bool CheckArray ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
void getSum ( int n ) { int sumOdd = 0 , sumEven = 0 ; string num = to_string ( n ) ; for ( int i = 0 ; i < num . size ( ) ; i ++ ) { if ( i % 2 == 0 ) sumOdd = sumOdd + ( int ( num [ i ] ) - 48 ) ; else sumEven = sumEven + ( int ( num [ i ] ) - 48 ) ; } cout << " Sum ▁ odd ▁ = ▁ " << sumOdd << " STRNEWLINE " ; cout << " Sum ▁ even ▁ = ▁ " << sumEven << " STRNEWLINE " ; }
int nthTermOfTheSeries ( int n ) { int nthTerm ; if ( n % 2 == 0 ) nthTerm = pow ( n - 1 , 2 ) + n ; else nthTerm = pow ( n + 1 , 2 ) + n ; return nthTerm ; }
int longestSubsequence ( string s ) { int n = s . length ( ) ; int answer = 0 ; char prev = ' - ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( prev != s [ i ] ) { prev = s [ i ] ; answer ++ ; } } return answer ; }
int getLargestSum ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = max ( max_sum , a + b ) ; } } return max_sum ; }
void expectedValue ( int P , int a , int b , int N ) { double expValue = P + ( N * 0.5 * ( a + b ) ) ; cout << expValue ; }
bool sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }
void sequence ( int n ) { int f [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; cout << f [ 1 ] << " ▁ " << f [ 2 ] << " ▁ " ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; cout << f [ i ] << " ▁ " ; } }
int rhombusAreaPeri ( int d1 , int d2 ) { long long int area , perimeter ; area = ( d1 * d2 ) / 2 ; perimeter = 2 * sqrt ( pow ( d1 , 2 ) + pow ( d2 , 2 ) ) ; cout << " The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " << d1 << " ▁ and ▁ " << d2 << " ▁ is ▁ " << area << " . " << endl ; cout << " The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " << d1 << " ▁ and ▁ " << d2 << " ▁ is ▁ " << perimeter << " . " << endl ; }
int kthdigit ( int a , int b , int k ) { int p = pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
int countUnique ( int mat [ ] [ MAX ] , int n , int m ) { int rowsum [ n ] , colsum [ m ] ; memset ( colsum , 0 , sizeof ( colsum ) ) ; memset ( rowsum , 0 , sizeof ( rowsum ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
int countWords ( string str ) { int count = 1 ; for ( int i = 1 ; i < str . length ( ) - 1 ; i ++ ) { if ( isupper ( str [ i ] ) ) count ++ ; } return count ; }
bool checkDivisbility ( int num ) { int digit ; int N = num ; while ( num != 0 ) { digit = num % 10 ; num = num / 10 ; if ( digit == 0 N % digit != 0 ) return false ; } return true ; }
bool solve ( int n , int k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; }
long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
int countStrings ( int N ) { if ( N == 1 ) return 0 ; if ( dp . find ( N ) != dp . end ( ) ) return dp [ N ] ; int ret = 0 ; for ( int div = 1 ; div <= sqrt ( N ) ; div ++ ) { if ( N % div == 0 ) { ret += ( 1 << div ) - countStrings ( div ) ; int div2 = N / div ; if ( div2 != div and div != 1 ) ret += ( 1 << div2 ) - countStrings ( div2 ) ; } } dp [ N ] = ret ; return ret ; }
> solve ( int n , int arr [ ] ) { string s = string ( n , ' a ' ) ; vector < string > ans ; ans . push_back ( s ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = s [ arr [ i ] ] ; if ( ch == ' b ' ) ch = ' a ' ; else ch = ' b ' ; s [ arr [ i ] ] = ch ; ans . push_back ( s ) ; } return ans ; }
int minSum ( int arr [ ] , int n ) { int dp [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
int closetAND ( int arr [ ] , int n , int k ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = min ( ans , abs ( k - X ) ) ; } } return ans ; }
void findNthTerm ( int n ) { cout << n * ( 5 * n + 3 ) / 2 << endl ; }
int maxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = max ( res , curr_sum ) ; } return res ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int sizeSubSet ( int a [ ] , int k , int n ) { sort ( a , a + n ) ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . count ( a [ i ] / k ) == 0 ) s . insert ( a [ i ] ) ; } return s . size ( ) ; }
int countXORSetBitsAdjElemRange1_N ( int N ) { int total_set_bits = 0 ; int bit_Position = 1 ; while ( N ) { total_set_bits += ( ( N + 1 ) / 2 * bit_Position ) ; N -= ( N + 1 ) / 2 ; bit_Position ++ ; } return total_set_bits ; }
void line ( double x0 , double y0 ) { double c = 2 * y0 * x0 ; cout << y0 << " x " << " ▁ + ▁ " << x0 << " y ▁ = ▁ " << c ; }
float normal ( float m , float n ) { float N = ( fabsf ( m ) * fabsf ( n ) ) / sqrt ( ( fabsf ( m ) * fabsf ( m ) ) + ( fabsf ( n ) * fabsf ( n ) ) ) ; return N ; }
void countDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i <= sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) cout << " Even " << endl ; else cout << " Odd " << endl ; }
int changeEvenBits ( int n ) { int to_subtract = 0 ; int m = 0 ; for ( int x = n ; x ; x >>= 2 ) { if ( x & 1 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
void KthCharacter ( string S , int N , int K ) { char strarray [ N + 1 ] ; strcpy ( strarray , S . c_str ( ) ) ; sort ( strarray , strarray + N ) ; char ch = strarray [ K - 1 ] ; int count = 0 ; for ( auto c : strarray ) { if ( c == ch ) count ++ ; } cout << count ; }
double Avgdifference ( double arr [ ] , int N , int K ) { double min = 1000000 , max = -1 ; for ( int i = 0 ; i <= N - K ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < K ; j ++ ) { sum += arr [ i + j ] ; } if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
void printDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << " ▁ " << i ; cout << " ▁ " << i << " ▁ " << n / i ; } } }
int countOfSubarray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] -- ; int pref [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + arr [ i ] ; map < int , int > mp ; int answer = 0 ; mp [ 0 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { answer += mp [ pref [ i ] ] ; mp [ pref [ i ] ] ++ ; } return answer ; }
long findNum ( unsigned long x ) { for ( int i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } }
void removeRepeating ( string s1 , string s2 ) { string s3 = s1 + " ▁ " + s2 + " ▁ " ; string words = " " ; int i = 0 ; for ( auto x : s3 ) { if ( x == ' ▁ ' ) { if ( s1 . find ( words ) == string :: npos || s2 . find ( words ) == string :: npos ) cout << words ; words = " " ; } else { words = words + x ; } } }
int maxDiffSum ( int arr [ ] , int n ) { int dp [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int maxVal = arr [ i ] , minVal = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { minVal = min ( minVal , arr [ j ] ) ; maxVal = max ( maxVal , arr [ j ] ) ; if ( j - 1 >= 0 ) dp [ i ] = max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) ; else dp [ i ] = max ( dp [ i ] , maxVal - minVal ) ; } } return dp [ n - 1 ] ; }
void findFreq ( string str , int N ) { int freq [ 256 ] ; memset ( freq , 0 , sizeof ( freq ) ) ; int max = 0 ; char charMax = '0' ; for ( int i = 0 ; i < N ; i ++ ) { char ch = str [ i ] ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; charMax = ch ; } cout << charMax << " - > " << max << endl ; } }
long maximumNum ( long long X , long long Y , long long N ) { long long num = 0 ; if ( N - N % X + Y <= N ) { num = N - N % X + Y ; } else { num = N - N % X - ( X - Y ) ; } return num ; }
string removeDuplicates ( string S ) { string ans = " " ; for ( auto it : S ) { if ( ans . empty ( ) or ans . back ( ) != it ) ans . push_back ( it ) ; else if ( ans . back ( ) == it ) ans . pop_back ( ) ; } return ans ; }
long countEvenSum ( int a [ ] , int n ) { long long res = 0 ; int s = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] % 2 == 1 ) { s = n - i - 1 - s ; } else { s = s + 1 ; } res = res + s ; } return res ; }
int maxConsecutiveCnt ( vector < int > arr ) { int X = 0 ; sort ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] <= ( X + 1 ) ) { X = X + arr [ i ] ; } else { break ; } } return X + 1 ; }
int findM ( string s , int x ) { int cnt = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] - '0' != x ) cnt ++ ; } return cnt ; }
void kth_string ( int n , int k ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( k <= ( n - i - 1 ) ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == i or j == n - k ) cout << ' Y ' ; else cout << ' X ' ; } break ; } k -= ( n - i - 1 ) ; } }
int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }
int numberOfElements ( int height [ ] , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
void findDistinctOddSum ( ll n , ll k ) { if ( ( k * k ) <= n && ( n + k ) % 2 == 0 ) { int val = 1 ; int sum = 0 ; for ( int i = 1 ; i < k ; i ++ ) { cout << val << " ▁ " ; sum += val ; val += 2 ; } cout << n - sum << endl ; } else cout << " NO ▁ STRNEWLINE " ; }
void countPairs ( int arr [ ] , int N ) { int count = 0 ; unordered_map < double , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { double val = 1.0 * arr [ i ] ; double idx = 1.0 * ( i + 1 ) ; count += mp [ val / idx ] ; mp [ val / idx ] ++ ; } cout << count ; }
int max_element ( int a [ ] , int n ) { int pre [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; int suf [ n ] ; suf [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) cout << suf [ i + 1 ] << " ▁ " ; else if ( i == n - 1 ) cout << pre [ i - 1 ] << " ▁ " ; else cout << max ( pre [ i - 1 ] , suf [ i + 1 ] ) << " ▁ " ; } }
int countDigits ( int n ) { return ( n * log10 ( 2 ) + 1 ) ; }
bool isequal ( string str ) { int n = str . length ( ) ; int num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( '0' <= str [ i ] && str [ i ] <= '9' ) { num = ( str [ i ] - '0' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; }
int countWays ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
int find ( vector < int > arr , int N , int key ) { int l = 0 ; int h = N - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] >= arr [ mid ] ) { if ( arr [ l ] >= key && key >= arr [ mid ] ) h = mid - 1 ; else l = mid + 1 ; } else { if ( arr [ mid ] >= key && key >= arr [ h ] ) l = mid + 1 ; else h = mid - 1 ; } } return -1 ; }
int get_max_splits ( string num_string ) { int count = 0 , current_num ; int running_sum = 0 ; for ( int i = 0 ; i < num_string . length ( ) ; i ++ ) { current_num = num_string [ i ] - '0' ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; }
bool is_Chiliagon ( int N ) { float n = ( 996 + sqrt ( 7984 * N + 992016 ) ) / 1996 ; return ( n - ( int ) n ) == 0 ; }
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
string reverse ( string str , int len , int l , int r ) { if ( l < 0 r > = len l > r ) return str ; while ( l < r ) { char c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } return str ; }
bool SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }
int maxScore ( string s , vector < int > a ) { if ( dp . find ( s ) != dp . end ( ) ) return dp [ s ] ; int n = s . size ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int head = 0 ; int mx = -1 ; while ( head < n ) { int tail = head ; while ( tail < n ) { if ( s [ tail ] != s [ head ] ) { head = tail ; break ; } string sub = s . substr ( head , tail + 1 ) ; mx = max ( mx , a [ sub . size ( ) - 1 ] + maxScore ( s . substr ( 0 , head ) + s . substr ( tail + 1 , s . size ( ) ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp [ s ] = mx ; return mx ; }
string divisibleBy36 ( string num ) { int l = num . length ( ) ; if ( l == 0 ) return " No " ; if ( l == 1 && num [ 0 ] != '0' ) return " No " ; int two_digit_num = ( num [ l - 2 ] - '0' ) * 10 + ( num [ l - 1 ] - '0' ) ; if ( two_digit_num % 4 != 0 ) return " No " ; int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - '0' ) ; if ( sum % 9 != 0 ) return " No " ; return " Yes " ; }
void lcmpair ( int l , int r ) { int x , y ; x = l ; y = 2 * l ; if ( y > r ) { cout << " - 1 STRNEWLINE " ; } else { cout << " X ▁ = ▁ " << x << " ▁ Y ▁ = ▁ " << y << " STRNEWLINE " ; } }
int power ( int x , unsigned int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
int Next_greater ( int a [ ] , int n , int x ) { sort ( a , a + n ) ; int low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
string generateNumber ( string number ) { int temp = 0 , adding_number = 0 ; string result = " " ; int len = number . size ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { int digit = number [ i ] - '0' ; if ( temp % 2 == 0 ) { adding_number += 1 ; digit += adding_number ; if ( digit >= 10 ) { digit %= 9 ; if ( digit == 0 ) digit = 9 ; } } result = to_string ( digit ) + result ; temp += 1 ; } return result ; }
void maxFrequency ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int start = 0 , end = 0 ; int sum = 0 , res = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum += arr [ end ] ; while ( ( end - start + 1 ) * arr [ end ] - sum > K ) { sum -= arr [ start ] ; start ++ ; } res = max ( res , end - start + 1 ) ; } cout << res << endl ; }
int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
bool isDivisibleBy25 ( string str ) { int n = str . length ( ) ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - '0' == 0 && str [ n - 2 ] - '0' == 0 ) || ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 25 == 0 ) ; }
bool isPerfectSquare ( long double x ) { if ( x >= 0 ) { long long sr = sqrt ( x ) ; return ( sr * sr == x ) ; } return false ; }
int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; }
int NumberOfSolutions ( int x , int y , int z , int n ) { int ans = 0 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { int temp = n - i - j ; if ( temp >= 0 ) { temp = min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
void mul_table ( int N , int i ) { if ( i > 10 ) return ; cout << N << " ▁ * ▁ " << i << " ▁ = ▁ " << N * i << endl ; return mul_table ( N , i + 1 ) ; }
bool isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; }
int count ( int n ) { map < int , int > dp ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; if ( ( dp . find ( n ) == dp . end ( ) ) ) dp [ n ] = 1 + min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ; return dp [ n ] ; }
void generateArray ( int n , int k ) { vector < int > array ( k , 0 ) ; int remaining = n - int ( k * ( k + 1 ) / 2 ) ; if ( remaining < 0 ) cout << ( " NO " ) ; int right_most = remaining % k ; int high = ceil ( remaining / ( k * 1.0 ) ) ; int low = floor ( remaining / ( k * 1.0 ) ) ; for ( int i = k - right_most ; i < k ; i ++ ) array [ i ] = high ; for ( int i = 0 ; i < ( k - right_most ) ; i ++ ) array [ i ] = low ; for ( int i = 0 ; i < k ; i ++ ) array [ i ] += i + 1 ; if ( k - 1 != remaining or k == 1 ) { for ( int u : array ) cout << u << " ▁ " ; } else if ( k == 2 or k == 3 ) printf ( " - 1 STRNEWLINE " ) ; else { array [ 1 ] -= 1 ; array [ k - 1 ] += 1 ; for ( int u : array ) cout << u << " ▁ " ; } }
bool makeAndCheckString ( vector < string > words , string str ) { int n = words . size ( ) ; bool first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; }
bool findNoIsDivisibleOrNot ( int a [ ] , int n , int l ) { for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; }
int longestsubarray ( int arr [ ] , int n , int k ) { int current_count = 0 ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = max ( current_count , max_count ) ; } return max_count ; }
bool Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return true ; else return false ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) - n - 1 ; }
int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- ) { result = pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
int findCost ( string s1 , string s2 , int a , int b , int c , int d , int n ) { int cost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; else { if ( ( s1 [ i ] == '1' && s2 [ i ] == '2' ) || ( s2 [ i ] == '1' && s1 [ i ] == '2' ) ) cost += min ( d , min ( a , b + c ) ) ; else if ( ( s1 [ i ] == '2' && s2 [ i ] == '3' ) || ( s2 [ i ] == '2' && s1 [ i ] == '3' ) ) cost += min ( d , min ( b , a + c ) ) ; else if ( ( s1 [ i ] == '1' && s2 [ i ] == '3' ) || ( s2 [ i ] == '1' && s1 [ i ] == '3' ) ) cost += min ( d , min ( c , a + b ) ) ; } } return cost ; }
ll boost_hyperfactorial ( ll num ) { ll val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * pow ( i , i ) ; } return val ; }
void generatestring ( int n ) { for ( int i = 0 ; i < n ; i ++ ) putchar ( i & 2 ? ' b ' : ' a ' ) ; puts ( " " ) ; }
int sum ( int n ) { int ans = ( n * ( n - 1 ) ) / 2 ; return ans ; }
int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = max ( maximum , ( i & j ) ) ; return maximum ; }
int cntSplits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) c_zero += ( s [ i ] == '0' ) ; return ( int ) pow ( 2 , c_zero - 1 ) ; }
bool isIdoneal ( int n ) { for ( int a = 1 ; a <= n ; a ++ ) { for ( int b = a + 1 ; b <= n ; b ++ ) { for ( int c = b + 1 ; c <= n ; c ++ ) { if ( a * b + b * c + c * a == n ) return false ; } } } return true ; }
int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return abs ( sumSet1 - sumSet2 ) ; }
bool isPossible ( int r , int b , int g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } }
void mergeTwoHalf ( int A [ ] , int n ) { sort ( A , A + n ) ; }
long countStrings ( long long A , long long B , long long K ) { long long X = ( A + B ) / ( K + 1 ) ; return ( min ( A , min ( B , X ) ) * ( K + 1 ) ) ; }
void constructXORArray ( int A [ ] , int n , int K ) { int B [ n ] ; for ( int i = 0 ; i < n ; i ++ ) B [ i ] = A [ i ] ^ K ; for ( int i = 0 ; i < n ; i ++ ) cout << B [ i ] << " ▁ " ; cout << endl ; }
int findMaxValByRearrArr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; }
int totEdge ( int n ) { int result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / pow ( i , i ) ; sums += ser ; } return sums ; }
int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; }
string areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " No " ; n = n >> 1 ; } return " Yes " ; }
char increment ( unsigned char i ) { i = - ( ~ i ) ; return i ; }
void gouldSequence ( int n ) { for ( int row_num = 1 ; row_num <= n ; row_num ++ ) { int count = 1 ; int c = 1 ; for ( int i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } cout << count << " ▁ " ; } }
void PrintReverseOrder ( int N ) { if ( N <= 0 ) { return ; } else { cout << N << " ▁ " ; PrintReverseOrder ( N - 1 ) ; } }
void getIndex ( int n , int shuffle [ ] [ N ] ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i ] [ 0 ] == n ) n = shuffle [ i ] [ 1 ] ; else if ( shuffle [ i ] [ 1 ] == n ) n = shuffle [ i ] [ 0 ] ; } cout << n ; }
int countZeros ( unsigned int x ) { int total_bits = sizeof ( x ) * 8 ; int res = 0 ; while ( ! ( x & ( 1 << ( total_bits - 1 ) ) ) ) { x = ( x << 1 ) ; res ++ ; } return res ; }
void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq = sumSq + ( pow ( arr [ i ] , 2 ) ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; cout << " A ▁ = ▁ " ; cout << A << endl ; cout << " B ▁ = ▁ " ; cout << B << endl ; }
int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; }
void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { cout << ( 10 * rem ) / n ; rem = ( 10 * rem ) % n ; } }
void totalInversions ( int arr [ ] , int K , int N ) { int inv = 0 ; int X = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] and i < j ) inv ++ ; if ( arr [ i ] > arr [ j ] ) X ++ ; } } int totalInv = X * K * ( K - 1 ) / 2 + inv * K ; cout << totalInv << endl ; }
int breakSum ( int n ) { if ( n == 0 n == 1 ) return n ; return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }
int greyConverter ( int n ) { return n ^ ( n >> 1 ) ; }
int calcCount ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 ) count ++ ; } return count ; }
void findSubarrays ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int i = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cout << " YES " << endl ; return ; } } cout << " NO " << endl ; }
int TotalBitwiseORPair ( int arr [ ] , int N ) { int totalOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalOR |= arr [ i ] ; } return totalOR ; }
void preprocess ( int list [ ] ) { ways [ 0 ] [ 8 ] [ 8 ] = 1 ; for ( int N = 1 ; N <= 14 ; N ++ ) { for ( int i = 1 ; i <= depth ; i ++ ) { for ( int j = 1 ; j <= depth ; j ++ ) { ways [ N ] [ i ] [ j ] = ways [ N - 1 ] [ i ] [ j + 1 ] + ways [ N - 1 ] [ i ] [ j - 1 ] + ways [ N - 1 ] [ i + 1 ] [ j ] + ways [ N - 1 ] [ i - 1 ] [ j ] + ways [ N - 1 ] [ i + 1 ] [ j - 1 ] + ways [ N - 1 ] [ i - 1 ] [ j + 1 ] ; } } list [ N ] = ways [ N ] [ 8 ] [ 8 ] ; } }
int minTrees ( int n ) { int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
void maxksum ( int L , int R , int K ) { int N = ( R / 10 - L / 10 ) + 1 ; if ( K > N ) { cout << -1 ; return ; } R = R / 10 ; int X = R - K ; int sum = 10 * ( ( R * ( R + 1 ) ) / 2 - ( X * ( X + 1 ) ) / 2 ) ; cout << sum ; }
int numBoxes ( int A [ ] , int n , int K ) { sort ( A , A + n ) ; int i = 0 , j = n - 1 ; int ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; }
void segregate0and1 ( int arr [ ] , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else { type0 ++ ; } } }
int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }
int maxDiff ( int arr [ ] , int n ) { int result = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += abs ( arr [ n - 1 ] ) ; return result ; }
int minOperations ( int A [ ] , int B [ ] , int N ) { int cnt = 0 ; int i = 0 ; while ( i < N ) { int j = 0 ; while ( j < N && i < N ) { if ( B [ i ] == A [ j ] ) { i ++ ; } j ++ ; } cnt ++ ; } return cnt ; }
bool isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
bool Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return true ; return false ; }
int Vertices ( int x , int y ) { int val = abs ( x ) + abs ( y ) ; cout << val * ( x < 0 ? -1 : 1 ) << " ▁ 0 ▁ " ; cout << "0 ▁ " << val * ( y < 0 ? -1 : 1 ) ; }
double findsolution ( double d , double h , double m , double n ) { double k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return -1 ; double ans = ( h / ( k - n ) ) ; return ans ; }
bool isPowerOfFour ( unsigned int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
int evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; }
int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
void findNums ( int n ) { if ( n <= 11 ) { if ( n == 8 ) cout << "4 ▁ 4" ; if ( n == 10 ) cout << "4 ▁ 6" ; else cout << " - 1" ; return ; } if ( n % 2 == 0 ) cout << "4 ▁ " << ( n - 4 ) ; else cout << "9 ▁ " << ( n - 9 ) ; }
int findMaxRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
int setRightmostUnsetBit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
int countEvenSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
bool isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; }
int computeLastDigit ( long long int A , long long int B ) { int variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long long int i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) ; return variable % 10 ; } }
bool checkIfAllTogether ( string s , char c ) { bool oneSeen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }
void printPalindrome ( int n ) { if ( n == 1 ) { cout << " Smallest ▁ Palindrome : ▁ 0" << endl ; cout << " Largest ▁ Palindrome : ▁ 9" ; } else { cout << " Smallest ▁ Palindrome : ▁ " << pow ( 10 , n - 1 ) + 1 ; cout << " Largest Palindrome : " } }
int setleftmostunsetbit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
int calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }
int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ceil ( log2 ( N ) ) ; }
void check ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) cout << " Yes " ; else cout << " No " ; }
int count ( int S [ ] , int m , int n ) { int table [ n + 1 ] ; memset ( table , 0 , sizeof ( table ) ) ; table [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }
int minDiffSubArray ( int arr [ ] , int n ) { int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) total_sum += arr [ i ] ; int prefix_sum = 0 ; int minDiff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix_sum += arr [ i ] ; int diff = abs ( ( total_sum - prefix_sum ) - prefix_sum ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= cbrt ( N ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = cbrt ( diff ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
string FirstAndLast ( string str ) { string ch = str ; for ( int i = 0 ; i < ch . length ( ) ; i ++ ) { int k = i ; while ( i < ch . length ( ) && ch [ i ] != ' ▁ ' ) i ++ ; ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return ch ; }
int calculate ( string s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s [ 0 ] - '0' ) c ++ ; if ( j != s [ 1 ] - '0' ) c ++ ; if ( k != s [ 2 ] - '0' ) c ++ ; if ( l != s [ 3 ] - '0' ) c ++ ; if ( m != s [ 4 ] - '0' ) c ++ ; if ( n != s [ 5 ] - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; }
bool isMyriagon ( int N ) { float n = ( 9996 + sqrt ( 79984 * N + 99920016 ) ) / 19996 ; return ( n - ( int ) n ) == 0 ; }
int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
int minimunMoves ( string arr [ ] , int n ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int curr_count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { string tmp = arr [ j ] + arr [ j ] ; int index = tmp . find ( arr [ i ] ) ; if ( index == string :: npos ) return -1 ; curr_count += index ; } ans = min ( curr_count , ans ) ; } return ans ; }
void countNums ( int N ) { int dp [ N ] [ 16 ] ; memset ( dp , 0 , sizeof ( dp [ 0 ] [ 0 ] ) * N * 16 ) ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 16 ; k ++ ) { int xo = j ^ k ; dp [ i ] [ xo ] += dp [ i - 1 ] [ k ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 ] [ i ] ; cout << ( count ) << endl ; }
bool checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
long findAnswer ( int n , vector < int > & arr ) { sort ( arr . begin ( ) , arr . end ( ) ) ; unsigned long long sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = floor ( a [ i ] / mul ) ; cout << x << " ▁ " ; } }
int findSDSFunc ( int n ) { int DP [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
int count ( int a [ ] , int M , int N ) { int cnt = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; }
int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
int countCon ( int ar [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { cout << j * j * j << " ▁ " ; break ; } } } }
void maximumSubsequenceSum ( int A [ ] , int N ) { int ans = 0 ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ A [ i ] - i ] += A [ i ] ; ans = max ( ans , mp [ A [ i ] - i ] ) ; } cout << ans << endl ; }
int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 , curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int countSubStr ( string str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
int minRemove ( int arr [ ] , int n ) { int LIS [ n ] , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) { LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } len = max ( len , LIS [ i ] ) ; } return n - len ; }
void find ( vector < int > arr , int n , int k ) { sort ( arr . begin ( ) , arr . end ( ) ) ; int b = ceil ( n / k * 1.0 ) ; int min_sum = 0 , max_sum = 0 ; for ( int i = 0 ; i < b ; i ++ ) min_sum += arr [ i ] ; for ( int i = 2 ; i < arr . size ( ) ; i ++ ) max_sum += arr [ i ] ; cout << " minimum ▁ " << min_sum << endl ; cout << " maximum ▁ " << max_sum << endl ; }
string getResult ( long long int n ) { string st = std :: to_string ( n ) ; int sum = 0 ; for ( char i : st ) { sum = sum + ( int ) i ; } if ( n % sum == 0 ) return " Yes " ; else return " No " ; }
int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int middleOfThree ( int a , int b , int c ) { int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
void sentinelSearch ( int arr [ ] , int n , int key ) { int last = arr [ n - 1 ] ; arr [ n - 1 ] = key ; int i = 0 ; while ( arr [ i ] != key ) i ++ ; arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) cout << key << " ▁ is ▁ present ▁ at ▁ index ▁ " << i ; else cout << " Element ▁ Not ▁ found " ; }
float circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; }
bool checkEvenPower ( int n ) { int x = 0 ; while ( x < n ) { int value = pow ( 2 , x ) ; if ( value == n ) { if ( x % 2 == 0 ) return true ; else return false ; } x ++ ; } return false ; }
string findPrefix ( string str1 , string str2 ) { int pos = -1 ; while ( ! str1 . empty ( ) ) { if ( str2 . find ( str1 ) == string :: npos ) str1 . pop_back ( ) ; else { pos = str2 . find ( str1 ) ; break ; } } if ( pos == -1 ) return " - 1" ; return str1 ; }
void findLargestRotation ( int num ) { int ans = num ; int len = floor ( log10 ( num ) + 1 ) ; int x = pow ( 10 , len - 1 ) ; for ( int i = 1 ; i < len ; i ++ ) { int lastDigit = num % 10 ; num = num / 10 ; num += ( lastDigit * x ) ; if ( num > ans ) { ans = num ; } } cout << ans ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
int maxSubarray ( int a [ ] , int k , int n ) { int answer = 0 ; int start = 0 ; long int s = 0 ; deque < int > dq ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; while ( ! dq . empty ( ) && a [ dq . front ( ) ] <= x ) dq . pop_front ( ) ; dq . push_back ( i ) ; s += x ; long int cost = ( long int ) a [ dq . front ( ) ] * ( answer + 1 ) - s ; if ( cost <= ( long int ) k ) answer ++ ; else { if ( dq . front ( ) == start ) dq . pop_front ( ) ; s -= a [ start ++ ] ; } } return answer ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int solve ( int a [ ] , int n ) { int max1 = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }
void findNthNum ( long long int N ) { long long int bit_L = 1 , last_num = 0 ; while ( bit_L * ( bit_L + 1 ) / 2 < N ) { last_num = last_num + bit_L ; bit_L ++ ; } int bit_R = N - last_num - 1 ; cout << ( 1 << bit_L ) + ( 1 << bit_R ) << endl ; }
int smallest_pair ( int a [ ] , int n ) { int min = INT_MAX , secondMin = INT_MAX ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
void printMiddleCharacter ( string str ) { int len = str . size ( ) ; int middle = len / 2 ; cout << str [ middle ] ; }
int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
void evenXorSubarray ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int XOR = 0 ; for ( int j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } cout << ans ; }
int countPaths ( int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }
void minumumOperation ( int N , int arr [ ] ) { int sum_arr = 0 ; sum_arr = accumulate ( arr , arr + N , sum_arr ) ; if ( sum_arr >= N ) cout << sum_arr - N << endl ; else cout << 1 << endl ; }
float Time ( float arr [ ] , int n , int Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; }
void printLastChar ( string str ) { str = str + " ▁ " ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' ▁ ' ) cout << str [ i - 1 ] << " ▁ " ; } }
int minInsertion ( string str ) { int n = str . length ( ) ; int res = 0 ; int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( count [ i ] % 2 == 1 ) res ++ ; return ( res == 0 ) ? 0 : res - 1 ; }
int count_triangles ( int a , int b , int c , int d ) { int ans = 0 ; for ( int x = a ; x <= b ; ++ x ) { int num_greater_than_d = max ( d , c + x ) - max ( d , b + x - 1 ) ; ans += num_greater_than_d * ( d - c + 1 ) ; int r = min ( max ( c , c + x ) , d ) - c ; int l = min ( max ( c , b + x - 1 ) , d ) - c ; int x1 = ( r * ( r + 1 ) ) / 2 ; int x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; }
int countRotation ( int n ) { int count = 0 ; do { int digit = n % 10 ; if ( digit == 0 ) count ++ ; n = n / 10 ; } while ( n != 0 ) ; return count ; }
void minimumMEX ( int arr [ ] , int N , int K ) { set < int > s ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s . insert ( i ) ; for ( int i = 0 ; i < K ; i ++ ) s . erase ( arr [ i ] ) ; int mex = * ( s . begin ( ) ) ; for ( int i = K ; i < N ; i ++ ) { s . erase ( arr [ i ] ) ; s . insert ( arr [ i - K ] ) ; int firstElem = * ( s . begin ( ) ) ; mex = min ( mex , firstElem ) ; } cout << mex << ' ▁ ' ; }
int countWays ( int A , int B , int C ) { int minAddA = max ( 0 , ( C + B - A + 2 ) / 2 ) ; int count_ways = max ( C - minAddA + 1 , 0 ) ; return count_ways ; }
int EnneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; }
int countStrings ( string s ) { long sum = 1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i % 2 == 0 && s [ i ] == ' $ ' ) sum *= 21 ; else if ( s [ i ] == ' $ ' ) sum *= 5 ; } return sum ; }
void possibleOrNot ( long long a1 , long long a2 , long long b1 , long long b2 , long long c1 , long long c2 ) { long long dis1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ; long long dis2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) cout << " No " ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) cout << " No " ; else cout << " Yes " ; }
int minFallingPathSum ( int ( & A ) [ n ] [ n ] ) { for ( int R = n - 2 ; R >= 0 ; -- R ) { for ( int C = 0 ; C < n ; ++ C ) { int best = A [ R + 1 ] [ C ] ; if ( C > 0 ) best = min ( best , A [ R + 1 ] [ C - 1 ] ) ; if ( C + 1 < n ) best = min ( best , A [ R + 1 ] [ C + 1 ] ) ; A [ R ] [ C ] = A [ R ] [ C ] + best ; } } int ans = INT_MAX ; for ( int i = 0 ; i < n ; ++ i ) ans = min ( ans , A [ 0 ] [ i ] ) ; return ans ; }
int countSquares ( int m , int n ) { if ( n < m ) swap ( m , n ) ; return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
int getHCF ( int x , int y ) { int minimum = min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
int Total_Ways ( int n ) { int fac = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) { fac = fac * i ; } return ( fac * 2 ) ; }
int findLargestd ( int S [ ] , int n ) { bool found = false ; sort ( S , S + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return INT_MIN ; }
void findMinimumCost ( string s , int N ) { int count_1 = 0 , count_0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) count_1 ++ ; else count_0 ++ ; } int k = abs ( count_0 - count_1 ) ; if ( count_1 == N count_0 == N ) cout << -1 << endl ; else cout << k / 2 << endl ; }
void printSeries ( int n ) { int k = 2 ; for ( int i = 0 ; i < n ; i ++ ) { cout << ( k * ( 2 * k - 1 ) ) << " ▁ " ; k += 2 ; } cout << endl ; }
int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) return 0 ; return 1 ; }
string replacingConsonants ( string s ) { char nVowel [ ] = " aaaeeeeiiiiioooooouuuuuuuu " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) s [ i ] = nVowel [ s [ i ] - ' a ' ] ; return s ; }
int noOfWays ( int N , int K ) { string S = to_string ( N ) ; int ans = 1 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { int count = 1 ; while ( i < S . length ( ) && S [ i ] - '0' + S [ i - 1 ] - '0' == K ) { count ++ ; i ++ ; } if ( count % 2 ) ans *= ( count + 1 ) / 2 ; } return ans ; }
int minCost ( int arr [ ] , int n , int circumference ) { sort ( arr , arr + n ) ; int arr2 [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; arr2 [ i + n ] = arr [ i ] + circumference ; } int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) res = min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; return res ; }
bool ishexadecagonal ( int N ) { float n = ( 12 + sqrt ( 112 * N + 144 ) ) / 28 ; return ( n - ( int ) n ) == 0 ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return abs ( min1 - max1 ) ; }
int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
int countDe ( int arr [ ] , int n ) { vector < int > v ( arr , arr + n ) ; sort ( arr , arr + n ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; reverse ( arr , arr + n ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( min ( count1 , count2 ) ) ; }
void isKthBitSet ( int n , int k ) { if ( ( n >> ( k - 1 ) ) & 1 ) cout << " SET " ; else cout << " NOT ▁ SET " ; }
int centeredTetrahedralNumber ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
bool canBeSumofConsec ( unsigned int n ) { return ( ( n & ( n - 1 ) ) && n ) ; }
bool isSumCube ( int N ) { int a = cbrt ( N ) ; int b = a - 1 ; return ( ( a * a * a + b * b * b ) == N ) ; }
int MinimumMoves ( int A [ ] , int B [ ] , int N ) { int totalOperations = 0 ; int carry = 0 ; int K = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int nearestMultiple = ceil ( ( double ) ( A [ i ] + carry ) / ( double ) ( B [ i ] ) ) * B [ i ] ; K = nearestMultiple - ( A [ i ] + carry ) ; totalOperations += K ; carry += K ; } return totalOperations ; }
int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
bool checkWord ( vector < vector < char > > & board , string & word , int index , int row , int col ) { if ( row < 0 || col < 0 || row >= board . size ( ) || col >= board [ 0 ] . size ( ) ) return false ; if ( board [ row ] [ col ] != word [ index ] ) return false ; else if ( index == word . size ( ) - 1 ) return true ; char temp = board [ row ] [ col ] ; board [ row ] [ col ] = ' * ' ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row ] [ col ] = temp ; return true ; } board [ row ] [ col ] = temp ; return false ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
bool areSumSame ( int a [ ] [ MAX ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 , sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
int findOccurrences ( string str , string substr ) { int counter = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) { for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) { if ( str [ j ] == substr [ 1 ] ) { for ( int k = j + 1 ; k < str . length ( ) ; k ++ ) { if ( str [ k ] == substr [ 2 ] ) counter ++ ; } } } } } return counter ; }
bool isStar ( int N ) { float n = ( 6 + sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
int FindElement ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { int m = sum / n ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return -1 ; }
int calculateProduct ( int A [ ] , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans = 1 ; for ( int i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = max ( l , a ) ; int R = min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += pow ( i , i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int solution ( vector < int > & arr , int x ) { int closestSum = INT_MAX ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < arr . size ( ) ; j ++ ) { for ( int k = j + 1 ; k < arr . size ( ) ; k ++ ) { if ( abs ( x - closestSum ) > abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) ; } } } return closestSum ; }
int CntcontSubs ( int a [ ] , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; }
int PointInKSquares ( int n , int a [ ] , int k ) { sort ( a , a + n ) ; return a [ n - k ] ; }
int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = " " ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; }
int countSubstrs ( string str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
int maxArea ( int A [ ] , int len ) { int l = 0 ; int r = len - 1 ; int area = 0 ; while ( l < r ) { area = max ( area , min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int minLength ( int A [ ] , int N ) { int elem = A [ 0 ] , count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; }
bool prefixDivisble ( int n ) { int i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = n / 10 ; i ++ ; } return true ; }
int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * pow ( r , i - 1 ) ) ) ; return sum ; }
int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * pow ( 2 , r - 2 ) ; int d = pow ( 2 , r - 1 ) ; c = c - r ; int element = a + d * c ; return element ; }
int solve ( int p [ ] , int n ) { int G = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] & 1 ) G ^= ( p [ i ] + 1 ) ; G ^= ( p [ i ] - 1 ) ; } return G ; }
int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ N + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] = insert ; for ( int i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
void findSum ( int A [ ] , int N , int K ) { sort ( A , A + N ) ; int sum = 0 ; for ( int i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } cout << sum ; }
int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; }
int minSteps ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) - 2 ; i ++ ) { if ( str [ i ] == '0' ) { if ( str [ i + 1 ] == '1' ) { if ( str [ i + 2 ] == '0' ) { count ++ ; i += 2 ; } } } } return count ; }
int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; int index = ( K + M - 1 ) % N ; int result = a [ index ] ; return result ; }
void moveAtEnd ( string s , int i , int l ) { if ( i >= l ) return ; char curr = s [ i ] ; if ( curr != ' x ' ) cout << curr ; moveAtEnd ( s , i + 1 , l ) ; if ( curr == ' x ' ) cout << curr ; return ; }
void nearestPerfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = sqrt ( arr [ i ] ) ; if ( ( sr & 1 ) == ( arr [ i ] & 1 ) ) cout << sr * sr << " ▁ " ; else { sr ++ ; cout << sr * sr << " ▁ " ; } } }
bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }
int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; int sum = 5 ; while ( n > 2 ) { sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
bool isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
int minChanges ( int A [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
int FindNoOfFullVessels ( int n , int t ) { double Matrix [ n ] [ n ] ; Matrix [ 0 ] [ 0 ] = t * 1.0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { double exceededwater = Matrix [ i ] [ j ] - 1.0 ; if ( exceededwater < 0 ) continue ; ans ++ ; if ( i + 1 < n ) Matrix [ i + 1 ] [ j ] += exceededwater / 2 ; if ( i + 1 < n && j + 1 < n ) Matrix [ i + 1 ] [ j + 1 ] += exceededwater / 2 ; } } return ans ; }
string allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return " Yes " ; return " No " ; }
int xorK ( int n , int k ) { if ( k % 2 == 1 ) return n ; return 0 ; }
void isSubsetAndZero ( int array [ ] , int length , int N ) { int arrAnd = array [ 0 ] ; for ( int i = 1 ; i < length ; i ++ ) { arrAnd = arrAnd & array [ i ] ; } if ( ( arrAnd & N ) == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; }
uint_t snoob ( uint_t x ) { uint_t rightOne ; uint_t nextHigherOneBit ; uint_t rightOnesPattern ; uint_t next = 0 ; if ( x ) { rightOne = x & - ( signed ) x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
bool isPal ( int a [ 3 ] [ 3 ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; }
int firstFactorialDivisibleNumber ( int x ) { int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
bool areSame ( vector < int > & a , vector < int > & b ) { sort ( a . begin ( ) , a . end ( ) ) ; sort ( b . begin ( ) , b . end ( ) ) ; return ( a == b ) ; }
int HexacontatetragonNum ( int n ) { return ( 62 * n * n - 60 * n ) / 2 ; }
void transpose ( int A [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; }
int numberOfWays ( int n , int k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= pow ( 2 , k ) ) { int curr_val = pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; }
int avg_of_even_num ( int n ) { return n + 1 ; }
int Solve ( int arr [ ] , int n ) { int temp = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; }
int findLastIndex ( string & str , char x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return -1 ; }
double averageSetBits ( int N , int K , int arr [ ] ) { double p = N ; double q = 0 ; for ( int i = 0 ; i < K ; i ++ ) { double _p = p , _q = q ; p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N ; q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N ; } return p ; }
void convert ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . at ( i ) == ' ▁ ' ) str . at ( i ) = ' _ ' ; else str . at ( i ) = tolower ( str . at ( i ) ) ; } cout << str ; }
int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; }
int maxLength ( string s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = INT_MIN ; s = s + '1' ; for ( int i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == ' o ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == ' x ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == ' x ' ) ) left = 1 ; coun = ceil ( ( double ) coun / ( right + left ) ) ; max_length = max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; }
string isTriangleExists ( int a , int b , int c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " YES " ; else return " NO " ; else return " NO " ; }
int findMissing ( int arr [ ] , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return -1 ; }
int getDivisors ( int min , int n ) { int total = 0 ; for ( int i = min ; i < n ; ++ i ) { if ( n % i == 0 && n / i >= i ) { ++ total ; if ( n / i > i ) total += getDivisors ( i , n / i ) ; } } return total ; }
int findSum ( int n ) { int arr [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = max ( res , next_val ) ; } return res ; }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; cout << num << " ▁ " ; } }
int distinctSubstring ( string & P , string & Q , int K , int N ) { unordered_set < string > S ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; string s ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; sum += Q [ pos ] - '0' ; s += P [ j ] ; if ( sum <= K ) { S . insert ( s ) ; } else { break ; } } } return S . size ( ) ; }
int calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
string sumBaseB ( string a , string b , int base ) { int len_a , len_b ; len_a = a . size ( ) ; len_b = b . size ( ) ; string sum , s ; s = " " ; sum = " " ; int diff ; diff = abs ( len_a - len_b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len_a < len_b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = max ( len_a , len_b ) - 1 ; i > -1 ; i -- ) { curr = carry + ( a [ i ] - '0' ) + ( b [ i ] - '0' ) ; carry = curr / base ; curr = curr % base ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; }
int maximum_toys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ; sort ( cost , cost + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
bool difSquare ( int n ) { if ( n % 4 != 2 ) { return true ; } return false ; }
int count ( int x , int y ) { unordered_map < int , int > m ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . find ( x ) != m . end ( ) ) return -1 ; m [ x ] = 1 ; x = x * 10 ; } return ans ; }
string checkSameDigits ( int N ) { int length = ( N ) + 1 ; int M = ( ( 10 , length ) - 1 ) / ( 10 - 1 ) ; M *= N % 10 ; if ( M = N ) return " Yes " ; return " No " ; }
string checkSameDigits ( int N ) { int digit = N % 10 ; while ( N != 0 ) { int current_digit = N % 10 ; N = N / 10 ; if ( current_digit != digit ) { return " No " ; } } return " Yes " ; }
void countOperations ( string X , string Y , int K ) { int count = 0 ; for ( int i = 0 ; i < X . length ( ) ; i ++ ) { int c = 0 ; if ( X [ i ] == Y [ i ] ) continue ; else if ( X [ i ] < Y [ i ] ) { if ( ( Y [ i ] - X [ i ] ) >= K ) { c = ( Y [ i ] - X [ i ] ) / K ; } c += ( Y [ i ] - X [ i ] ) % K ; } else { int t = 90 - X [ i ] ; t += Y [ i ] - 65 + 1 ; if ( t >= K ) c = t / K ; c += ( t % K ) ; } count += c ; } cout << count << endl ; }
float Mixture ( int X , int Y , int Z ) { float result = 0.0 , result1 = 0.0 ; result1 = ( ( X - Y ) / ( float ) X ) ; result = pow ( result1 , Z ) ; result = result * X ; return result ; }
int LCSubStr ( char * X , char * Y , int m , int n ) { int LCSuff [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; }
void findNums ( int arr [ ] , int n ) { int S = 0 , X = 0 ; for ( int i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } cout << X << " ▁ " << ( X + S ) ; }
bool isMultipleOf4 ( int n ) { if ( n == 1 ) return false ; int XOR = 0 ; for ( int i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; }
void reArrange ( string words [ ] , int n ) { map < string , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ words [ i ] ] = i + 1 ; sort ( words , words + n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << mp [ words [ i ] ] << " ▁ " ; }
int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( mat [ i ] [ j ] == x ) { cout << " Element ▁ found ▁ at ▁ ( " << i << " , ▁ " << j << " ) STRNEWLINE " ; return 1 ; } } cout << " n ▁ Element ▁ not ▁ found " ; return 0 ; }
int maxAlternatingSum ( int arr [ ] , int n ) { int max_sum = 0 ; int i = 0 ; while ( i < n ) { int current_max = arr [ i ] ; int k = i ; while ( k < n && ( ( arr [ i ] > 0 && arr [ k ] > 0 ) || ( arr [ i ] < 0 && arr [ k ] < 0 ) ) ) { current_max = max ( current_max , arr [ k ] ) ; k += 1 ; } max_sum += current_max ; i = k ; } return max_sum ; }
int MaxSubsetlength ( vector < string > arr , int A , int B ) { int dp [ A + 1 ] [ B + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( auto & str : arr ) { int zeros = count ( str . begin ( ) , str . end ( ) , '0' ) ; int ones = count ( str . begin ( ) , str . end ( ) , '1' ) ; for ( int i = A ; i >= zeros ; i -- ) for ( int j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } return dp [ A ] [ B ] ; }
int center_nonadecagon_num ( long int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
unsigned countBits ( unsigned int number ) { return ( int ) log2 ( number ) + 1 ; }
void findAngle ( int n ) { int interiorAngle , exteriorAngle ; interiorAngle = ( n - 2 ) * 180 / n ; exteriorAngle = 360 / n ; cout << " Interior ▁ angle : ▁ " << interiorAngle << endl ; cout << " Exterior ▁ angle : ▁ " << exteriorAngle ; }
char lastRemovedCharacter ( string str ) { int n = str . length ( ) ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == '0' ) { return ( '1' - str [ n - 1 ] + '0' ) ; } else return str [ n - 1 ] ; }
string balancedTernary ( int n ) { string output = " " ; while ( n > 0 ) { int rem = n % 3 ; n = n / 3 ; if ( rem == 2 ) { rem = -1 ; n ++ ; } output = ( rem == 0 ? '0' : ( rem == 1 ) ? '1' : ' Z ' ) + output ; } return output ; }
int totalMoney ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans += i / 7 ; ans += ( i % 7 + 1 ) ; } return ans ; }
bool isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; }
void ans ( int n ) { if ( n == 1 ) cout << "1" ; else cout << "0" ; }
void findSide ( float a , float B , float C ) { float A = 180 - C - B ; float radA = M_PI * ( A / 180 ) ; float radB = M_PI * ( B / 180 ) ; float radC = M_PI * ( C / 180 ) ; float b = a / sin ( radA ) * sin ( radB ) ; float c = a / sin ( radA ) * sin ( radC ) ; cout << fixed << setprecision ( 15 ) << b << " ▁ " ; cout << fixed << setprecision ( 15 ) << c ; }
void section ( double x1 , double x2 , double y1 , double y2 , double z1 , double z2 , double m , double n ) { double x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; double y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; double z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; cout << " ( " << x << " , ▁ " ; cout << y << " , ▁ " ; cout << z << " ) " << endl ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
int bellNumber ( int n ) { int bell [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int bellNumber ( int n ) { int bell [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
int cntSubSets ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( pow ( 2 , cnt ) - 1 ) ; }
int findkthElement ( vector < int > arr , int n , int K ) { int l = 0 ; int h = n - 1 , r ; while ( l + 1 < h ) { int mid = ( l + h ) / 2 ; if ( arr [ l ] >= arr [ mid ] ) l = mid ; else h = mid ; } if ( arr [ l ] < arr [ h ] ) r = l ; else r = h ; if ( K <= r + 1 ) return arr [ r + 1 - K ] ; else return arr [ n - ( K - ( r + 1 ) ) ] ; }
int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; for ( int k = max ( j - target , 0 ) ; k <= min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } int res = INT_MAX ; for ( int j = 0 ; j <= M ; j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
int maxAND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = max ( res , arr [ i ] & arr [ j ] ) ; return res ; }
int maxLen ( int * arr , int n ) { int c_sum = 0 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { c_sum += arr [ i ] ; if ( c_sum < 0 ) return i ; } return n ; }
float sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ; }
double area ( double d1 , double a ) { double d2 = sqrt ( 4 * ( a * a ) - d1 * d1 ) ; double area = 0.5 * d1 * d2 ; return area ; }
bool checkEquilibrium ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int resx = x1 + x2 + x3 ; int resy = y1 + y2 + y3 ; int resz = z1 + z2 + z3 ; if ( resx == 0 and resy == 0 and resz == 0 ) return true ; else return false ; }
void printNumHavingAltBitPatrn ( int n ) { int curr_num = 1 ; cout << curr_num << " ▁ " ; while ( 1 ) { curr_num <<= 1 ; if ( n < curr_num ) break ; cout << curr_num << " ▁ " ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; cout << curr_num << " ▁ " ; } }
int findCost ( vector < vector < int > > cost_mat , int N , int M ) { vector < vector < int > > dp ( N , vector < int > ( M , 0 ) ) ; for ( int i = 0 ; i < M ; i ++ ) dp [ 0 ] [ i ] = cost_mat [ 0 ] [ i ] ; for ( int row = 1 ; row < N ; row ++ ) { for ( int curr_col = 0 ; curr_col < M ; curr_col ++ ) { int val = 999999999 ; for ( int prev_col = 0 ; prev_col < M ; prev_col ++ ) { if ( curr_col != prev_col ) val = min ( val , dp [ row - 1 ] [ prev_col ] ) ; } dp [ row ] [ curr_col ] = val + cost_mat [ row ] [ curr_col ] ; } } int ans = INT_MAX ; for ( int i = 0 ; i < M ; i ++ ) ans = min ( ans , dp [ N - 1 ] [ i ] ) ; return ans ; }
int productSum ( int arr [ ] , int N ) { int cntOne = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) cntOne ++ ; } return cntOne * ( cntOne - 1 ) / 2 ; }
int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
int findXORS ( int arr1 [ ] , int arr2 [ ] , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int temp = arr1 [ i ] & arr2 [ j ] ; res ^= temp ; } } return res ; }
bool isEven ( int n ) { return ( n % 2 == 0 ) ; }
int getInteger ( int L , int R ) { int number = 0 ; for ( int i = L ; i <= R ; i ++ ) number += pow ( 2 , i ) ; return number ; }
int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; }
int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; }
int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
float findProb ( int l , int r ) { float countOfPS = floor ( sqrt ( r ) ) - ceil ( sqrt ( l ) ) + 1 ; float total = r - l + 1 ; float prob = ( float ) countOfPS / ( float ) total ; return prob ; }
int Preprocess ( string A , string B ) { int n = A . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { map < char , int > mp ; mp [ A [ i ] ] ++ ; mp [ A [ n - i - 1 ] ] ++ ; mp [ B [ i ] ] ++ ; mp [ B [ n - i - 1 ] ] ++ ; int sz = mp . size ( ) ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ) ; else if ( sz == 2 ) ans += mp [ A [ i ] ] != 2 ; } if ( n % 2 == 1 && A [ n / 2 ] != B [ n / 2 ] ) ans ++ ; return ans ; }
int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }
int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
bool judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
int getNumToAdd ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; int numToAdd = -1 ; bool numAdded = false ; for ( int i = 2 ; i < n ; i ++ ) { int diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return -1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return -1 ; } } if ( numToAdd == -1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; }
int solve ( int x ) { int ans = 0 , first , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; }
void countSubstring ( string s ) { int answer = 0 ; unordered_map < int , int > m ; m [ 0 ] = 1 ; int x = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { x ^= 1 << ( s [ j ] - ' a ' ) ; answer += m [ x ] ; for ( int i = 0 ; i < 26 ; ++ i ) { answer += m [ x ^ ( 1 << i ) ] ; } m [ x ] += 1 ; } cout << answer ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
float geometricMean ( int arr [ ] , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = pow ( product , ( float ) 1 / n ) ; return gm ; }
void findPairs ( vector < int > x , vector < int > y , int K ) { int n = x . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( K * abs ( x [ i ] - x [ j ] ) >= abs ( y [ i ] - y [ j ] ) ) { ++ ans ; } } } cout << ans ; }
int minLength ( string s ) { int i = 0 , j = s . length ( ) - 1 ; for ( ; i < j && s [ i ] == s [ j ] ; ) { char d = s [ i ] ; while ( i <= j && s [ i ] == d ) i ++ ; while ( i <= j && s [ j ] == d ) j -- ; } return j - i + 1 ; }
void solve ( long long n ) { long long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = n / floor ( n / l ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } cout << ( s + m ) % m ; }
int minOperations ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int maxFreq = INT_MIN ; for ( auto x : mp ) maxFreq = max ( maxFreq , x . second ) ; return ( n - maxFreq ) ; }
int MaximumHeight ( int a [ ] , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { long long y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
string updateString ( string S , string A , string B ) { int l = A . length ( ) ; for ( int i = 0 ; i + l <= S . length ( ) ; i ++ ) { string curr = S . substr ( i , i + l ) ; if ( curr == A ) { string new_string = " " ; new_string += S . substr ( 0 , i ) + B + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } else { string new_string = " " ; new_string += S . substr ( 0 , i ) + A + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } } return S ; }
void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) cout << " Yes " ; else cout << " No " ; }
int solve ( int i , int X , int Y , int a [ ] , int b [ ] , int n ) { if ( i == n ) return 0 ; if ( X <= 0 ) return b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ; if ( Y <= 0 ) return a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) ; else return max ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) , b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; vector < int > dp ( n + 1 , -1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; int sqr ; for ( int i = 4 ; i <= n ; i ++ ) { sqr = sqrt ( i ) ; int best = INT_MAX ; while ( sqr > 1 ) { if ( i % sqr == 0 ) { best = min ( best , 1 + dp [ sqr ] ) ; } sqr -- ; } best = min ( best , 1 + dp [ i - 1 ] ) ; dp [ i ] = best ; } return dp [ n ] ; }
int find ( int start , string adj , int n , int dp [ ] ) { if ( start == n ) return 0 ; if ( dp [ start ] != -1 ) return dp [ start ] ; dp [ start ] = 0 ; int one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj [ k ] == '1' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; }
int modInverse ( int a , int m ) { for ( int x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; }
float largestCube ( float r ) { if ( r < 0 ) return -1 ; float a = ( 2 * r ) / sqrt ( 3 ) ; return a ; }
int SubseqWidths ( int A [ ] , int n ) { sort ( A , A + n ) ; int pow2 [ n ] ; pow2 [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }
float findAreaShaded ( float a ) { float sqArea = a * a ; float semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ; float ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; }
int MaximumSides ( int n ) { if ( n < 4 ) return -1 ; return n % 2 == 0 ? n / 2 : -1 ; }
void countSubstrings ( string s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; for ( auto & i : s ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } cout << ans << endl ; }
int findFlips ( char str [ ] , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) res ++ ; last = str [ i ] ; } return res / 2 ; }
int breakSum ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 , dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
ll minSum ( int arr [ ] , int n , int x ) { ll sum = 0 ; int largestDivisible = -1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == -1 ) return sum ; ll sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return min ( sum , sumAfterOperation ) ; }
int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = -1 ; return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
void leftRotate ( int arr [ ] , int n , int k ) { int mod = k % n ; for ( int i = 0 ; i < n ; i ++ ) cout << ( arr [ ( mod + i ) % n ] ) << " ▁ " ; cout << " STRNEWLINE " ; }
int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
bool isicositetragonal ( int N ) { float n = ( 10 + sqrt ( 44 * N + 100 ) ) / 22 ; return ( n - ( int ) n ) == 0 ; }
void Selection_Sort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { int min_index = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( arr [ j ] < arr [ min_index ] ) min_index = j ; } swap ( arr [ i ] , arr [ min_index ] ) ; } }
int numOfCombinations ( int arr [ ] , int N ) { int C [ 3 ] = { 0 , 0 , 0 } ; for ( int i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
bool transformString ( string & s ) { char ch = ' a ' ; if ( s . size ( ) < 26 ) return false ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( int ( ch ) > int ( ' z ' ) ) break ; if ( s [ i ] <= ch ) { s [ i ] = ch ; ch = char ( int ( ch ) + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; }
void findNthTerm ( int n ) { cout << n * ( 2 * n + 1 ) << endl ; }
void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float d = sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) + pow ( z2 - z1 , 2 ) * 1.0 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " ▁ Distance ▁ is ▁ " << d ; return ; }
string printSequence ( string arr [ ] , string input ) { string output = " " ; int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input [ i ] == ' ▁ ' ) output = output + "0" ; else { int position = input [ i ] - ' A ' ; output = output + arr [ position ] ; } } return output ; }
int findMinDeletions ( vector < pair < int , int > > & v , int n ) { int minDel = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int L = v [ i ] . first ; int R = v [ i ] . second ; int Count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j ] . first >= L && v [ j ] . second <= R ) { Count += 1 ; } } minDel = min ( minDel , n - Count ) ; } return minDel ; }
void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { cout << ( 1 << x ) + ( 1 << y ) << " ▁ " ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
int findMin ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) int x = exp ( sum / n ) ; return x + 1 ; }
int calculateSum ( int n ) { long long int sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
void solve ( string a , string b ) { int l = a . length ( ) ; int min = 0 , max = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == ' + ' b [ i ] == ' + ' a [ i ] != b [ i ] ) max ++ ; if ( a [ i ] != ' + ' && b [ i ] != ' + ' && a [ i ] != b [ i ] ) min ++ ; } cout << min + max << endl ; }
int maxPlanes ( int A [ ] , int B [ ] , int N ) { set < int > St ; for ( int i = 0 ; i < N ; i ++ ) { int t = ( A [ i ] % B [ i ] > 0 ) ? 1 : 0 ; t += ( A [ i ] / B [ i ] ) + t ; St . insert ( t ) ; } return St . size ( ) ; }
int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }
void maxValue ( int a ) { string c = bitset < 3 > ( a ) . to_string ( ) ; string b = " " ; for ( int i = 0 ; i < c . length ( ) ; i ++ ) { if ( ( c [ i ] - '0' ) == 1 ) b += '0' ; else b += '1' ; } cout << bitset < 3 > ( b ) . to_ulong ( ) ; }
int is_rtol ( string s ) { int tmp = sqrt ( s . length ( ) ) - 1 ; char first = s [ tmp ] ; for ( int pos = tmp ; pos < s . length ( ) - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; }
float polyarea ( float n , float r ) { if ( r < 0 && n < 0 ) return -1 ; float A = ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
void findNumbers ( int n , int b ) { int largest = pow ( b , n ) - 1 ; cout << largest << endl ; }
int getCount ( int l , int r , int p ) { int cnt = 0 ; int val = p ; while ( 1 ) { int a = r / val ; int b = ( l - 1 ) / val ; val *= p ; if ( a - b ) { cnt += ( a - b ) ; } else break ; } return cnt ; }
int minInsertions ( int H [ ] , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += ceil ( diff / K ) - 1 ; } return inser ; }
string check ( int Arr [ ] , int n , int M , int K ) { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Arr [ i ] == 0 ) flag = 1 ; } if ( K % 2 != 0 && flag == 0 ) return " No " ; else return " Yes " ; }
int countPoints ( int n , int m , vector < int > a , vector < int > b , int x , int y ) { sort ( a . begin ( ) , a . end ( ) ) ; sort ( b . begin ( ) , b . end ( ) ) ; int j = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; }
int sumMax ( int i , int arr [ ] , int n ) { if ( i >= n - 1 ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) ; return dp [ i ] ; }
bool solve ( int a [ ] , int n ) { int mx = INT_MIN ; for ( int j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = max ( mx , a [ j - 1 ] ) ; } return true ; }
int bitwiseAndOdd ( int n ) { return 1 ; }
int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int sorted1 [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
double calculateArea ( int x , int y ) { double pi = 3.1415926536 ; double arx = pi * x * x ; double ary = pi * y * y ; return arx - ary ; }
int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int dp [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
int findSubsequenceCount ( string S , string T ) { int m = T . length ( ) , n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
bool function ( string str ) { int l = str . length ( ) ; int counter [ MAX ] ; memset ( counter , 0 , sizeof ( counter ) ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) counter [ str [ i ] - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter [ str [ i ] - ' a ' ] -- ; for ( int i = 0 ; i < MAX ; i ++ ) if ( counter [ i ] != 0 ) return true ; return false ; }
void findPair ( int A , int B , int N ) { int X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { cout << " - 1" ; } else { X = X / 2 ; Y = N - X ; cout << X << " ▁ " << Y ; } }
bool isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
void findsolution ( ll n , ll x , ll y ) { if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x y < n ) { cout << " No ▁ solution " ; return ; } cout << y - n + 1 ; while ( n -- > 1 ) cout << endl << 1 ; }
void CalculatePairs ( int a [ ] , int n ) { int cnt_zero = 0 ; int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } long int total_XOR_pairs = cnt_zero * cnt_one ; long int total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; long int total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; cout << " cntXOR ▁ = ▁ " << total_XOR_pairs << endl ; cout << " cntAND ▁ = ▁ " << total_AND_pairs << endl ; cout << " cntOR ▁ = ▁ " << total_OR_pairs << endl ; }
int findValue ( int R , int C ) { int k = ( R * ( R - 1 ) ) / 2 + 1 ; int diff = R + 1 ; for ( int i = 1 ; i < C ; i ++ ) { k = ( k + diff ) ; diff ++ ; } return k ; }
void pairwiseDifference ( int arr [ ] , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = abs ( arr [ i ] - arr [ i + 1 ] ) ; cout << diff << " ▁ " ; } }
int findMinimum ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int ans = 0 ; for ( int i = 1 ; i < 2 * ( N / K ) ; i += 2 ) { ans += arr [ i ] ; } cout << ans ; }
void perfectSquares ( float l , float r ) { for ( int i = l ; i <= r ; i ++ ) { if ( sqrt ( i ) == ( int ) sqrt ( i ) ) cout << i << " ▁ " ; } }
void printIntersection ( int A [ ] [ N ] , int B [ ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) cout << A [ i ] [ j ] << " ▁ " ; else cout << " * ▁ " ; } cout << " STRNEWLINE " ; } }
int min_changes ( int a [ ] , int n ) { int ans_a = 0 , ans_b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] == 0 ) ans_a ++ ; else ans_b ++ ; } else { if ( a [ i ] == 0 ) ans_b ++ ; else ans_a ++ ; } } return min ( ans_a , ans_b ) ; }
int minReplacement ( string s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s [ i ] == '1' ) ans ++ ; if ( i % 2 == 1 && s [ i ] == '0' ) ans ++ ; } return min ( ans , len - ans ) ; }
void numberofBoxes ( int W , int B , int O ) { int low = 0 , high = min ( W , B ) ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( ( ( W >= mid ) and ( B >= mid ) ) and ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } cout << ans ; }
int calculateSum ( int n ) { long long int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
float trianglearea ( float a ) { if ( a < 0 ) return -1 ; float area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / 4 ; return area ; }
float CubeVolume ( float d ) { float Volume ; Volume = ( sqrt ( 3 ) * pow ( d , 3 ) ) / 9 ; return Volume ; }
int results ( int n , int k ) { return round ( pow ( n , ( 1.0 / pow ( 2 , k ) ) ) ) ; }
int closetAND ( int arr [ ] , int n , int k ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = min ( ans , abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; }
int countGreater ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
void smallestGreater ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int diff = INT_MAX , closest = -1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } ( closest == -1 ) ? cout << " _ ▁ " : cout << arr [ closest ] << " ▁ " ; } }
int LongestOddEvenSubarray ( int A [ ] , int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) ans = max ( ans , dp [ i ] ) ; return ans ; }
int k_sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; }
int seriesSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; }
int countDigits ( int a , int b ) { if ( a == 0 b == 0 ) return 1 ; return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1 ; }
int nthTerm ( int N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
bool ifPossible ( int arr [ ] , int n ) { int cp [ n ] ; copy ( arr , arr + n , cp ) ; sort ( cp , cp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false ; } return true ; }
int findMaxPoints ( int A [ ] [ M ] ) { int P1S [ M + 1 ] [ N + 1 ] , P1E [ M + 1 ] [ N + 1 ] ; memset ( P1S , 0 , sizeof ( P1S ) ) ; memset ( P1E , 0 , sizeof ( P1E ) ) ; int P2S [ M + 1 ] [ N + 1 ] , P2E [ M + 1 ] [ N + 1 ] ; memset ( P2S , 0 , sizeof ( P2S ) ) ; memset ( P2E , 0 , sizeof ( P2E ) ) ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = M ; j >= 1 ; j -- ) P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ; int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ; ans = max ( ans , max ( op1 , op2 ) ) ; } } return ans ; }
int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
int countTrailingZeroes ( int N ) { int res = log2 ( N ^ ( N - 1 ) ) ; return res >= 0 ? res : 0 ; }
int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; }
int find_max ( int i , int sum , vector < int > & v , int k ) { if ( i == v . size ( ) ) return 0 ; if ( dp [ i ] [ sum ] != -1 ) return dp [ i ] [ sum ] ; int ans = 0 ; if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) ans = find_max ( i + 1 , sum , v , k ) ; if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) ans = max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) ; return dp [ i ] [ sum ] = ans ; }
bool isDivisible ( int arr [ ] , int n ) { int lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; }
void split ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { count = 2 ; break ; } } cout << count << endl ; }
float cone ( float a ) { if ( a < 0 ) return -1 ; float r = ( a * sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; }
int FindMaxSum ( vector < int > arr , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
int findTrailingZeros ( int n ) { if ( n & 1 ) return 0 ; else { int ans = 0 ; n /= 2 ; while ( n ) { ans += n / 5 ; n /= 5 ; } return ans ; } }
void finalPosition ( string move ) { int l = move . size ( ) ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( move [ i ] == ' U ' ) countUp ++ ; else if ( move [ i ] == ' D ' ) countDown ++ ; else if ( move [ i ] == ' L ' ) countLeft ++ ; else if ( move [ i ] == ' R ' ) countRight ++ ; } cout << " Final ▁ Position : ▁ ( " << ( countRight - countLeft ) << " , ▁ " << ( countUp - countDown ) << " ) " << endl ; }
int maxSum ( int arr [ ] , int i , int n , int k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = 1 ; int tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( int j = i ; j < i + k and j < n ; j ++ ) { tot += arr [ j ] ; dp [ i ] = max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; }
int main ( ) { char str [ ] = " CheRrY " ; cout << " Toggle ▁ case : ▁ " << toggleCase ( str ) << endl ; cout << " Original ▁ string : ▁ " << toggleCase ( str ) << endl ; return 0 ; }
void countString ( string S ) { long long count = 0 ; for ( auto it : S ) { if ( it == '0' and count > 0 ) { count -- ; } else { count ++ ; } } cout << ( ( 1 << count ) - 1 ) << " STRNEWLINE " ; }
int sum ( int a [ ] , int n ) { int maxSum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) maxSum = max ( maxSum , a [ i ] + a [ j ] ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; }
double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( -1 * b ) / a ; double rootProduct = ( double ) e / a ; return abs ( rootSum - rootProduct ) ; }
long count_triples ( int n , int k ) ; } ; long gfg :: count_triples ( int n , int k ) { int i = 0 , j = 0 , l = 0 ; int count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { for ( l = 1 ; l <= n ; l ++ ) { if ( ( i + j ) % k == 0 && ( i + l ) % k == 0 && ( j + l ) % k == 0 ) count ++ ; } } } return count ; }
int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
float trianglearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / ( 4 * b ) ; return area ; }
void printPair ( int g , int l ) { cout << g << " ▁ " << l ; }
float ReuleauxArea ( float a ) { if ( a < 0 ) return -1 ; float A = 0.70477 * pow ( a , 2 ) ; return A ; }
bool sentencePalindrome ( string str ) { int l = 0 , h = str . length ( ) - 1 ; for ( int i = 0 ; i <= h ; i ++ ) str [ i ] = tolower ( str [ i ] ) ; while ( l <= h ) { if ( ! ( str [ l ] >= ' a ' && str [ l ] <= ' z ' ) ) l ++ ; else if ( ! ( str [ h ] >= ' a ' && str [ h ] <= ' z ' ) ) h -- ; else if ( str [ l ] == str [ h ] ) l ++ , h -- ; else return false ; } return true ; }
int maximumSubarrays ( int arr [ ] , int N , int target ) { int ans = 0 ; int availIdx = -1 ; int cur_sum = 0 ; unordered_map < int , int > mp ; mp [ 0 ] = -1 ; for ( int i = 0 ; i < N ; i ++ ) { cur_sum += arr [ i ] ; if ( mp . find ( cur_sum - target ) != mp . end ( ) && mp [ cur_sum - target ] >= availIdx ) { ans ++ ; availIdx = i ; } mp [ cur_sum ] = i ; } return ans ; }
int maxSumArray ( int arr [ ] , int n ) { int sum = 0 ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; mp [ arr [ i ] ] ++ ; } int minimum = INT_MAX ; for ( auto x : mp ) minimum = min ( minimum , x . second * x . first ) ; return ( sum - minimum ) ; }
int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; }
int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; }
int findWater ( int arr [ ] , int n ) { int result = 0 ; int left_max = 0 , right_max = 0 ; int lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; }
ll getChicks ( int n ) { ll chicks = ( ll ) pow ( 3 , n - 1 ) ; return chicks ; }
int printTrib ( int n ) { int dp [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; }
int countDigits ( int a , int b ) { return floor ( log10 ( abs ( a ) ) - log10 ( abs ( b ) ) ) + 1 ; }
int maxLines ( int n , int x1 [ ] , int y1 [ ] , int x2 [ ] , int y2 [ ] ) { unordered_set < double > s ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = INT_MAX ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . insert ( slope ) ; } return s . size ( ) ; }
void product_subarrays ( long long int arr [ ] , int n ) { long long int res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { long long int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product = product * arr [ j ] ; res *= product ; } } cout << res << " STRNEWLINE " ; }
int maxScore ( vector < int > & arr ) { int N = arr . size ( ) ; N ++ ; vector < vector < int > > dp ( N + 1 , vector < int > ( 2 * N , -100000 ) ) ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int s = 1 ; s <= 2 * ( N - 1 ) ; s ++ ) { for ( int j = 1 ; j <= N - 1 and j <= s ; j ++ ) { dp [ i ] [ s ] = max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) ; } } } return dp [ N ] [ 2 * ( N - 1 ) ] ; }
int countNumber ( int N , int S ) { int countElements = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; }
int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
bool canBeBalanced ( string s , int n ) { if ( n % 2 == 1 ) return false ; string k = " ( " ; k += s + " ) " ; vector < string > d ; int cnt = 0 ; for ( int i = 0 ; i < k . length ( ) ; i ++ ) { if ( k [ i ] == ' ( ' ) d . push_back ( " ( " ) ; else { if ( d . size ( ) != 0 ) d . pop_back ( ) ; else return false ; } } if ( d . empty ( ) ) return true ; return false ; }
void findMidAlphabet ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int mid = ( s1 [ i ] + s2 [ i ] ) / 2 ; cout << ( char ) mid ; } }
int positionAfterKJumps ( int X , int Y , int K ) { int addY = Y * ( K / 2 ) ; int reduceX = -1 * X * ( K / 2 + K % 2 ) ; return addY + reduceX ; }
int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
int KvisibleFromLeft ( int N , int K ) { if ( dp [ N ] [ K ] != -1 ) return dp [ N ] [ K ] ; if ( N == K ) return dp [ N ] [ K ] = 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return dp [ N ] [ K ] = ans ; } return dp [ N ] [ K ] = KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { bool visited [ N + 1 ] ; int minimumSwaps = 0 ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }
int minCoins ( int coins [ ] , int m , int V ) { int table [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = INT_MAX ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != INT_MAX && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == INT_MAX ) return -1 ; return table [ V ] ; }
void bin ( unsigned n ) { if ( n > 1 ) bin ( n >> 1 ) ; printf ( " % d " , n & 1 ) ; }
int subarray ( int arr [ ] , int n ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = max ( ans , temp ) ; temp = 1 ; } } ans = max ( ans , temp ) ; return ans ; }
int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { long long int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
double findArea ( double d ) { return ( d * d ) / 2.0 ; }
int findMaxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = max ( res , prefix_sum ) ; } return res ; }
void maximumValue ( int arr [ ] , int n ) { int maxvalue = arr [ 0 ] ; int result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { result = max ( result , maxvalue + arr [ i ] - i ) ; maxvalue = max ( maxvalue , arr [ i ] + i ) ; } cout << result ; }
int countSteps ( int n ) { int steps = 0 ; while ( n ) { int largest = sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
