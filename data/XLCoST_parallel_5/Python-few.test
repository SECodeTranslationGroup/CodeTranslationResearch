def countWords ( str , l ) : NEW_LINE INDENT count = 1 ; NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , l - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minNum ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if ( odd % 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def MinOfCubed ( k ) : NEW_LINE INDENT if ( k < 8 ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT res = k ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ( i * i * i ) > k ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def findSum ( arr , n , k ) : NEW_LINE INDENT if ( k <= n - 2 ) : NEW_LINE INDENT return ( arr [ n - 1 ] - arr [ 0 ] ) ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT
def decodeStr ( str , len ) : NEW_LINE INDENT c = [ " " for i in range ( len ) ] NEW_LINE pos = 1 NEW_LINE if ( len % 2 == 1 ) : NEW_LINE INDENT med = int ( len / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT med = int ( len / 2 - 1 ) NEW_LINE DEDENT c [ med ] = str [ 0 ] NEW_LINE if ( len % 2 == 0 ) : NEW_LINE INDENT c [ med + 1 ] = str [ 1 ] NEW_LINE DEDENT if ( len & 1 ) : NEW_LINE INDENT k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 2 NEW_LINE DEDENT for i in range ( k , len , 2 ) : NEW_LINE INDENT c [ med - pos ] = str [ i ] NEW_LINE if ( len % 2 == 1 ) : NEW_LINE INDENT c [ med + pos ] = str [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT c [ med + pos + 1 ] = str [ i + 1 ] NEW_LINE DEDENT pos += 1 NEW_LINE DEDENT print ( * c , sep = " " ) NEW_LINE DEDENT
def countSubArrayWithOddProduct ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE last = - 1 NEW_LINE K = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT K = ( i - last - 1 ) NEW_LINE count += ( K * ( K + 1 ) / 2 ) NEW_LINE last = i NEW_LINE DEDENT DEDENT K = ( N - last - 1 ) NEW_LINE count += ( K * ( K + 1 ) / 2 ) NEW_LINE return count NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE y = N / K ; NEW_LINE x = N % K ; NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT
def solve ( arr , n , X , Y ) : NEW_LINE INDENT diff = Y - X NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT diff = diff % ( arr [ i ] - 1 ) NEW_LINE DEDENT DEDENT if ( diff == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def nthTerm ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) NEW_LINE DEDENT
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT
def smallestNum ( N ) : NEW_LINE INDENT x = pow ( 10.0 , ( N - 1 ) / 2.0 ) ; NEW_LINE return math . ceil ( x ) ; NEW_LINE DEDENT
def multiplyFactors ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE DEDENT else : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE prod = ( prod * n / i ) % M NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return prod NEW_LINE DEDENT
def deleteElement ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < n ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def findNumberOfTriangles ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] > arr [ k ] and arr [ i ] + arr [ k ] > arr [ j ] and arr [ k ] + arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def cntPairs ( a , n ) : NEW_LINE INDENT odd = 0 ; even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT elif ( ( a [ i ] / 2 ) % 2 == 1 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT DEDENT ans = odd * even + ( odd * ( odd - 1 ) ) // 2 ; NEW_LINE return ans ; NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return sum ( [ i * ( i + 1 ) / 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; NEW_LINE if ( N % 2 == 1 ) : NEW_LINE INDENT nth = ( N * N ) + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( N * N ) - 1 ; NEW_LINE DEDENT return nth ; NEW_LINE DEDENT
def setBitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT msb = 0 ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = int ( n / 2 ) ; NEW_LINE msb += 1 ; NEW_LINE DEDENT return ( 1 << msb ) ; NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT if n % 11 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def ellipsearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = ( 3.14 * r * r ) / 4 ; NEW_LINE return a ; NEW_LINE DEDENT
def findSetBits ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) ; NEW_LINE print ( dp [ 0 ] , end = " ▁ " ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i // 2 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i // 2 ] + 1 ; NEW_LINE DEDENT print ( dp [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def check ( n , marks ) : NEW_LINE INDENT x = max ( marks ) NEW_LINE bonus = 100 - x NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( marks [ i ] + bonus >= 50 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def octaside ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = a / ( sqrt ( 2 ) + 1 ) NEW_LINE return s NEW_LINE DEDENT
def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE tuples = { } ; NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT
def minDiff ( arr , n , k ) : NEW_LINE INDENT result = + 2147483647 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def isSubseqPossible ( arr , N , K ) : NEW_LINE INDENT i = 0 NEW_LINE odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd == 0 or ( even == 0 and K % 2 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base = 1 ; NEW_LINE temp = num ; NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE dec_value += last_digit * base ; NEW_LINE base = base * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def count_min_length ( s ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE ans = sys . maxsize ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT hash [ i ] = - 1 ; NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == i - 1 or hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == i - 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT ans = min ( ans , i - hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] - 1 ) ; NEW_LINE hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i ; NEW_LINE DEDENT DEDENT if ( ans == INT_MAX ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) / 3 NEW_LINE DEDENT
def solve_sum ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( n + 1 ) / 2 NEW_LINE DEDENT return - n / 2 NEW_LINE DEDENT
def results ( n , k ) : NEW_LINE INDENT return round ( pow ( n , ( 1.0 / pow ( 2 , k ) ) ) ) NEW_LINE DEDENT
def findCycles ( N ) : NEW_LINE INDENT res = 0 NEW_LINE finalResult = 0 NEW_LINE val = 2 * N - 1 ; NEW_LINE s = val NEW_LINE res = ( N - 1 ) * ( N - 2 ) NEW_LINE finalResult = res + s ; NEW_LINE return finalResult ; NEW_LINE DEDENT
def isPentagonal ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT M = ( 3 * i * i - i ) / 2 NEW_LINE i += 1 NEW_LINE if ( M >= N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( M == N ) NEW_LINE DEDENT N = 12 NEW_LINE if ( isPentagonal ( N ) ) : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE print ( " is ▁ pentagonal ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE print ( " is ▁ not ▁ pentagonal " ) NEW_LINE DEDENT
def SellingPrice ( CP , PP ) : NEW_LINE INDENT Pdecimal = 1 + ( PP / 100 ) NEW_LINE res = Pdecimal * CP NEW_LINE return res NEW_LINE DEDENT
def ways ( n ) : NEW_LINE INDENT first = 2 ; NEW_LINE second = 3 ; NEW_LINE res = 0 ; NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res = first + second ; NEW_LINE first = second ; NEW_LINE second = res ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr . sort ( ) NEW_LINE left = 0 NEW_LINE right = 1 ; NEW_LINE while ( right < n ) : NEW_LINE INDENT if ( arr [ left ] == arr [ right ] ) : NEW_LINE INDENT ans += right - left ; NEW_LINE DEDENT else : NEW_LINE INDENT left = right ; NEW_LINE DEDENT right += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def distance ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT d = ( a1 * a2 + b1 * b2 + c1 * c2 ) NEW_LINE e1 = math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) NEW_LINE e2 = math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) NEW_LINE d = d / ( e1 * e2 ) NEW_LINE A = math . degrees ( math . acos ( d ) ) NEW_LINE print ( " Angle ▁ is " ) , A , ( " degree " ) NEW_LINE DEDENT
def get_concentration ( mass , volume ) : NEW_LINE INDENT if ( volume == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( mass / volume ) * 1000 ; NEW_LINE DEDENT DEDENT
def findSum ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ) NEW_LINE DEDENT
def find ( n ) : NEW_LINE INDENT print ( n // 2 ) NEW_LINE DEDENT
def CntcontSubs ( a , n ) : NEW_LINE INDENT c = 0 NEW_LINE d = 0 NEW_LINE sum = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 != 0 or a [ i ] % 4 == 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT sum = a [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum * a [ j ] NEW_LINE if ( sum % 2 != 0 or sum % 4 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT sum = 1 NEW_LINE DEDENT return c + d NEW_LINE DEDENT
def zigzag ( s , rows ) : NEW_LINE INDENT interval = 2 * rows - 2 NEW_LINE for i in range ( rows ) : NEW_LINE INDENT step = interval - 2 * i NEW_LINE for j in range ( i , len ( s ) , interval ) : NEW_LINE INDENT print ( s [ j ] , end = " " ) NEW_LINE if ( step > 0 and step < interval and step + j < len ( s ) ) : NEW_LINE INDENT for k in range ( ( interval - rows - i ) ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT print ( s [ j + step ] , end = " " ) NEW_LINE for k in range ( i - 1 ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for k in range ( interval - rows ) : NEW_LINE INDENT print ( end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def bitPos ( n1 , n2 ) : NEW_LINE INDENT if n1 == n2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT bitCount1 = floor ( log2 ( n1 ) ) + 1 NEW_LINE bitCount2 = floor ( log2 ( n2 ) ) + 1 NEW_LINE bitDiff = abs ( bitCount1 - bitCount2 ) NEW_LINE maxBitCount = max ( bitCount1 , bitCount2 ) NEW_LINE if ( bitCount1 > bitCount2 ) : NEW_LINE INDENT n2 *= pow ( 2 , bitDiff ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 *= pow ( 2 , bitDiff ) NEW_LINE DEDENT xorValue = n1 ^ n2 NEW_LINE bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 NEW_LINE disSimilarBitPosition = ( maxBitCount - bitCountXorValue + 1 ) NEW_LINE return disSimilarBitPosition NEW_LINE DEDENT
def perfectPowerOf2 ( n ) : NEW_LINE INDENT per_pow = 1 NEW_LINE while n > 0 : NEW_LINE INDENT per_pow = per_pow << 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return per_pow NEW_LINE DEDENT
def longestCommonSum ( arr1 , arr2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum1 += arr1 [ j ] NEW_LINE sum2 += arr2 [ j ] NEW_LINE if ( sum1 == sum2 ) : NEW_LINE INDENT len = j - i + 1 NEW_LINE if ( len > maxLen ) : NEW_LINE INDENT maxLen = len NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def arraySum ( arr , n ) : NEW_LINE INDENT x = ( n + 1 ) / 2 NEW_LINE return ( arr [ 0 ] - 1 ) * n + x * x NEW_LINE DEDENT
def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - sqrt ( val ) ) / 2.0 NEW_LINE print ( " a ▁ = " , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( " b ▁ = " , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 1 ] = 1 NEW_LINE sm = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sm = sm + fibo [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 4 < 2 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT
def charactersCount ( str , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT cur = str [ 0 ] ; NEW_LINE ind = 0 ; NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( str [ j ] < cur ) : NEW_LINE INDENT cur = str [ j ] ; NEW_LINE ind = j ; NEW_LINE DEDENT DEDENT str = str [ 0 : ind ] + str [ ind + 1 : ] ; NEW_LINE n -= 1 ; NEW_LINE count += ind + 1 ; NEW_LINE DEDENT print ( count ) ; NEW_LINE DEDENT
def pairORSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] | arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def NimGame ( N , A , B ) : NEW_LINE INDENT sum = A + B NEW_LINE if ( N % sum <= A - 1 ) : NEW_LINE INDENT return " Bob " NEW_LINE DEDENT else : NEW_LINE INDENT return " Alice " NEW_LINE DEDENT DEDENT
def overflow ( H , r , h , N , R ) : NEW_LINE INDENT tank_cap = 3.14 * r * r * H NEW_LINE water_vol = 3.14 * r * r * h NEW_LINE balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R NEW_LINE vol = water_vol + balls_vol NEW_LINE if vol > tank_cap : NEW_LINE INDENT print ( " Overflow " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ in ▁ overflow ▁ state " ) NEW_LINE DEDENT DEDENT
def maxDiffSubsets ( arr ) : NEW_LINE INDENT totalSum = 0 NEW_LINE pos = False NEW_LINE neg = False NEW_LINE min = sys . maxsize NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT totalSum += abs ( arr [ i ] ) NEW_LINE if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos = True NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg = True NEW_LINE DEDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT if ( pos and neg ) : NEW_LINE INDENT return totalSum NEW_LINE DEDENT else : NEW_LINE INDENT return totalSum - 2 * min NEW_LINE DEDENT DEDENT
def minCost ( arr , n , circumference ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE arr2 = [ 0 ] * ( 2 * n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr2 [ i ] = arr [ i ] NEW_LINE arr2 [ i + n ] = arr [ i ] + circumference NEW_LINE DEDENT res = 9999999999999999999 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
def findCost ( A , N ) : NEW_LINE INDENT totalCost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE totalCost += i NEW_LINE DEDENT DEDENT return totalCost NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT f0 = 0 NEW_LINE f1 = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = n % 60 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 2 , rem + 3 ) : NEW_LINE INDENT f = ( f0 + f1 ) % 60 NEW_LINE f0 = f1 NEW_LINE f1 = f NEW_LINE DEDENT s = f1 - 1 NEW_LINE return ( s ) NEW_LINE DEDENT DEDENT
def countMaxChoco ( money , price , wrap ) : NEW_LINE INDENT if ( money < price ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT choc = int ( money / price ) NEW_LINE choc = choc + ( choc - 1 ) / ( wrap - 1 ) NEW_LINE return int ( choc ) NEW_LINE DEDENT
def substrDeletion ( string , length ) : NEW_LINE INDENT count0 = 0 ; NEW_LINE count1 = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 ; NEW_LINE DEDENT DEDENT return min ( count0 , count1 ) ; NEW_LINE DEDENT
def minPower ( n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( n % x ) NEW_LINE n //= x NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countOccurrences ( arr , n , x ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x == arr [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def CountPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findpair ( l , r ) : NEW_LINE INDENT ans1 = l NEW_LINE ans2 = 2 * l NEW_LINE print ( ans1 , " , ▁ " , ans2 ) NEW_LINE DEDENT
def isPossible ( Str ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT freq [ Str [ j ] ] = freq . get ( Str [ j ] , 0 ) + 1 NEW_LINE if ( freq [ Str [ j ] ] > max_freq ) : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Str = " geeksforgeeks " NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printMiddleCharacter ( str ) : NEW_LINE INDENT length = len ( str ) ; NEW_LINE middle = length // 2 ; NEW_LINE print ( str [ middle ] ) ; NEW_LINE DEDENT
def exponentMod ( A , B , C ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponentMod ( A , B / 2 , C ) NEW_LINE y = ( y * y ) % C NEW_LINE DEDENT else : NEW_LINE INDENT y = A % C NEW_LINE y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C NEW_LINE DEDENT return ( ( y + C ) % C ) NEW_LINE DEDENT
def findLength ( s , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE cnt_zero = 0 NEW_LINE cnt_one = 0 NEW_LINE while ( l < len ( s ) and r <= len ( s ) ) : NEW_LINE INDENT if ( cnt_zero >= k and cnt_one >= 1 ) : NEW_LINE INDENT ans = min ( ans , r - l ) NEW_LINE l += 1 NEW_LINE if ( s [ l - 1 ] == '0' ) : NEW_LINE INDENT cnt_zero -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( r == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( s [ r ] == '0' ) : NEW_LINE INDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 NEW_LINE DEDENT r += 1 NEW_LINE DEDENT DEDENT if ( ans == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printMatrix ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( k , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT DEDENT
def remainingArea ( N , M , K ) : NEW_LINE INDENT while ( K > 0 and N > 0 and M > 0 ) : NEW_LINE INDENT if ( N > M ) : NEW_LINE INDENT N = N - M ; NEW_LINE DEDENT else : NEW_LINE INDENT M = M - N ; NEW_LINE DEDENT K = K - 1 ; NEW_LINE DEDENT if ( N > 0 and M > 0 ) : NEW_LINE INDENT return N * M ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT ans = ( N - odd + odd // 2 - 1 ) + odd // 2 NEW_LINE return ans NEW_LINE DEDENT
def countSol ( coeff , n , rhs ) : NEW_LINE INDENT dp = [ 0 for i in range ( rhs + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( coeff [ i ] , rhs + 1 ) : NEW_LINE INDENT dp [ j ] += dp [ j - coeff [ i ] ] NEW_LINE DEDENT DEDENT return dp [ rhs ] NEW_LINE DEDENT
def find_longest_subarray ( A , N , K ) : NEW_LINE INDENT MaxLen = 0 NEW_LINE Len = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( K % A [ i ] == 0 ) : NEW_LINE INDENT Len += 1 NEW_LINE MaxLen = max ( MaxLen , Len ) NEW_LINE DEDENT else : NEW_LINE INDENT Len = 0 NEW_LINE DEDENT DEDENT return MaxLen NEW_LINE DEDENT
def Polite ( n ) : NEW_LINE INDENT n = n + 1 NEW_LINE return ( int ) ( n + ( math . log ( ( n + math . log ( n , 2 ) ) , 2 ) ) ) NEW_LINE DEDENT
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( not curr ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT
def maxBalancedStr ( s ) : NEW_LINE INDENT open1 = 0 NEW_LINE close1 = 0 NEW_LINE open2 = 0 NEW_LINE close2 = 0 NEW_LINE open3 = 0 NEW_LINE close3 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : open1 += 1 continue if s [ i ] == ' ) ' : NEW_LINE INDENT close1 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' { ' : NEW_LINE INDENT open2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' } ' : NEW_LINE INDENT close2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' [ ' : NEW_LINE INDENT open3 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' ] ' : NEW_LINE INDENT close3 += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT maxLen = ( 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) ) NEW_LINE return maxLen NEW_LINE DEDENT
def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) / 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT
def findNums ( arr , n ) : NEW_LINE INDENT S = 0 ; X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] ; NEW_LINE X ^= arr [ i ] ; NEW_LINE DEDENT print ( X , X + S ) ; NEW_LINE DEDENT
def maxSubsequences ( arr , n ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE maxCount = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT count = m [ arr [ i ] ] NEW_LINE if count > 1 : NEW_LINE INDENT m [ arr [ i ] ] = count - 1 NEW_LINE DEDENT else : NEW_LINE INDENT m . pop ( arr [ i ] ) NEW_LINE DEDENT if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxCount += 1 NEW_LINE DEDENT maxCount += 1 NEW_LINE INDENT if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT return maxCount NEW_LINE DEDENT
def minumumOperation ( N , arr ) : NEW_LINE INDENT sum_arr = sum ( arr ) NEW_LINE if sum_arr >= N : NEW_LINE INDENT print ( sum_arr - N ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT
def segregate0and1 ( arr , size ) : NEW_LINE INDENT left , right = 0 , size - 1 NEW_LINE while left < right : NEW_LINE INDENT while arr [ left ] == 0 and left < right : NEW_LINE INDENT left += 1 NEW_LINE DEDENT while arr [ right ] == 1 and left < right : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT if left < right : NEW_LINE INDENT arr [ left ] = 0 NEW_LINE arr [ right ] = 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) // 2 NEW_LINE c = ( n * n + 1 ) // 2 NEW_LINE print ( " b ▁ = " , b , " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n // 4 - 1 NEW_LINE c = n * n // 4 + 1 NEW_LINE print ( " b ▁ = " , b " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT DEDENT
def highestPowerof2 ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( ( i & ( i - 1 ) ) == 0 ) : NEW_LINE INDENT res = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
def xorK ( n , k ) : NEW_LINE INDENT res = n NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT res = ( res ^ n ) NEW_LINE DEDENT return n NEW_LINE DEDENT
def CountDigits ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum += ma . log ( i , 10 ) NEW_LINE DEDENT sum *= n NEW_LINE return ma . ceil ( sum ) NEW_LINE DEDENT
def minOperation ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return ( N / 2 ) * ( N / 2 ) NEW_LINE DEDENT k = ( N - 1 ) / 2 NEW_LINE return ( k * ( k + 1 ) ) NEW_LINE DEDENT
def ksmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE if ( k < arr [ 0 ] ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT if ( k == arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] + 1 ; NEW_LINE DEDENT if ( k > arr [ n - 1 ] ) : NEW_LINE INDENT return k + n ; NEW_LINE DEDENT if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= ( arr [ 0 ] - 1 ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT c = arr [ i ] - arr [ i - 1 ] - 1 ; NEW_LINE if ( k <= c ) : NEW_LINE INDENT return arr [ i - 1 ] + k ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= c ; NEW_LINE DEDENT DEDENT return arr [ n - 1 ] + k ; NEW_LINE DEDENT
def findM ( s , x ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) != x ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def specialSieve ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE prime = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE for j in range ( i , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = cnt ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( prime [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def nambiarNumber ( Str , i ) : NEW_LINE INDENT if ( i >= len ( Str ) ) : NEW_LINE INDENT return " " NEW_LINE DEDENT firstDigit = ord ( Str [ i ] ) - ord ( '0' ) NEW_LINE digitParity = firstDigit % 2 NEW_LINE sumDigits = 0 NEW_LINE while ( i < len ( Str ) ) : NEW_LINE INDENT sumDigits += ( ord ( Str [ i ] ) - ord ( '0' ) ) NEW_LINE sumParity = sumDigits % 2 NEW_LINE if ( digitParity != sumParity ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( " " + str ( sumDigits ) + nambiarNumber ( Str , i + 1 ) ) NEW_LINE DEDENT
def unique ( s ) : NEW_LINE INDENT st = " " NEW_LINE length = len ( s ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT c = s [ i ] NEW_LINE if c not in st : NEW_LINE INDENT st += c NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT res = [ 0 ] * ( n + 2 ) NEW_LINE res [ 0 ] = 1 NEW_LINE res [ 1 ] = 1 NEW_LINE res [ 2 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT
def totEdge ( n ) : NEW_LINE INDENT result = ( n * ( n - 1 ) ) // 2 NEW_LINE return result NEW_LINE DEDENT
def minInsertion ( tr1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE count = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] % 2 == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( res == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return res - 1 NEW_LINE DEDENT DEDENT
