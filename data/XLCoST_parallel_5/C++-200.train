bool checkPowerof8 ( int n ) { double i = log ( n ) / log ( 8 ) ; return ( i - trunc ( i ) < 0.000001 ) ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
void sumFib ( int N ) { long num = ( long ) round ( pow ( ( sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / sqrt ( 5 ) ) ; cout << ( num - 1 ) ; }
void findEquation ( int a , int b ) { int sum = ( a + b ) ; int product = ( a * b ) ; cout << " x ^ 2 ▁ - ▁ ( " << sum << " x ) ▁ + ▁ ( " << product << " ) ▁ = ▁ 0" ; }
int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
int maxPeople ( int p ) { int tmp = 0 , count = 0 ; for ( int i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
int maxDistance ( int arr [ ] , int n ) { unordered_map < int , int > mp ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ i ] ] = i ; else max_dist = max ( max_dist , i - mp [ arr [ i ] ] ) ; } return max_dist ; }
int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
int PositionRightmostSetbit ( int n ) { int p = 1 ; while ( n > 0 ) { if ( n & 1 ) { return p ; } p ++ ; n = n >> 1 ; } return -1 ; }
int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
int sumofsquare ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
int maxEvenIntegers ( int arr [ ] , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = max ( ans , cnt ) ; } return ans ; }
void poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { cout << ceil ( log ( buckets ) / log ( ( minutesToTest / minutesToDie ) + 1 ) ) ; }
int find ( vector < int > arr , int N ) { int Sum = 0 ; for ( auto i : arr ) Sum += i ; if ( Sum % N ) return -1 ; int k = Sum / N ; int ans = 0 ; int i = 0 ; while ( i < N ) { ans = ans + abs ( k - arr [ i ] ) ; i += 1 ; } return ans / 2 ; }
int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { cout << " The ▁ shortest ▁ distance ▁ " << " between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " << sqrt ( ( pow ( ( x2 - x1 ) , 2 ) ) + ( pow ( ( y2 - y1 ) , 2 ) ) ) - r << endl ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
void checkSolution ( int a , int b , int c ) { if ( a == c ) cout << " Yes " ; else cout << " No " ; }
bool areVowelsInOrder ( string s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }
void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) cout << " odd " << endl ; else cout << " even " << endl ; }
int countways ( long long n ) { long long A [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
int largestNum ( int a , int b ) { return a * ( bool ) ( a / b ) + b * ( bool ) ( b / a ) ; }
int MaxRearrngeSum ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N , greater < int > ( ) ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxSum += abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
long product ( vector < vector < int > > & mat , int n ) { long long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1LL * d1 * d2 ; }
void checkVantieghemsTheorem ( int limit ) { long long unsigned prod = 1 ; for ( long long unsigned n = 2 ; n < limit ; n ++ ) { if ( ( ( prod - n ) % ( ( 1LL << n ) - 1 ) ) == 0 ) cout << n << " ▁ is ▁ prime STRNEWLINE " ; prod *= ( ( 1LL << n ) - 1 ) ; } }
int findMean ( int arr [ ] , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = floor ( sum / count ) ; return mean ; }
int countSubset ( int arr [ ] , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int t [ n + 1 ] [ sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; }
int fun ( unsigned int n ) { return n & ( n - 1 ) ; }
int hIndex ( vector < int > citations , int n ) { int hindex = 0 ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } cout << hindex << endl ; return hindex ; }
void allCharactersSame ( string s ) { set < char > s1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) s1 . insert ( s [ i ] ) ; if ( s1 . size ( ) == 1 ) cout << " YES " ; else cout << " NO " ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int no_of_ways ( int a [ ] , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; }
void countTotalFrequencies ( string S1 , string S2 ) { set < char > bset ; for ( auto x : S1 ) bset . insert ( x ) ; int count = 0 ; for ( auto x : S2 ) { if ( bset . find ( x ) != bset . end ( ) ) count += 1 ; } cout << count << endl ; }
bool checkIsFibonacci ( int arr [ ] , int n ) { if ( n == 1 n == 2 ) return true ; sort ( arr , arr + n ) ; for ( int i = 2 ; i < n ; i ++ ) if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; return true ; }
long numbers ( int n ) { return ( long long ) ( pow ( 2 , n + 1 ) ) - 2 ; }
int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = max ( a , max ( b , c ) ) ; int smallest = min ( a , min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } }
int findSmallestNumK ( int n ) { int cummAnd = n ; int i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return -1 ; }
bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
bool isEven ( int n ) { if ( n ^ 1 == n + 1 ) return true ; else return false ; }
int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int term ( int n ) { return n * ( n + 1 ) / 2 ; }
void check ( int n , int m ) { if ( n == 2 m == 2 n % m == 0 ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } }
int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
int EqualNumbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; }
void minimumTime ( int * arr , int n ) { int sum = 0 ; int T = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } cout << max ( 2 * T , sum ) ; }
bool findWinner ( int x , int y , int n ) { int dp [ n + 1 ] ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 and ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 and ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 and ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
bool isConvertible ( string str1 , string str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
void printMissingElements ( int arr [ ] , int N ) { int diff = arr [ 0 ] - 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { cout << i + diff << " ▁ " ; diff ++ ; } } } }
int countNums ( int n , int x , int y ) { vector < bool > arr ( n + 1 , false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
void odd_even ( int arr [ ] , int n ) { vector < int > odd_indexes ; vector < int > even_indexes ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . push_back ( arr [ i ] ) ; else even_indexes . push_back ( arr [ i ] ) ; } sort ( odd_indexes . begin ( ) , odd_indexes . end ( ) ) ; sort ( even_indexes . begin ( ) , even_indexes . end ( ) ) ; for ( int i = 0 ; i < odd_indexes . size ( ) ; i ++ ) cout << odd_indexes [ i ] << " ▁ " ; for ( int i = 0 ; i < even_indexes . size ( ) ; i ++ ) cout << even_indexes [ i ] << " ▁ " ; }
float Area ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }
void possibleNumbers ( set < int > & numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . insert ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; }
int clearLastBit ( int N , int K ) { int mask = ( -1 << K + 1 ) ; return N = N & mask ; }
void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( n ) { int r = n % 10 ; largest = max ( r , largest ) ; smallest = min ( r , smallest ) ; n = n / 10 ; } cout << largest << " ▁ " << smallest ; }
int smallest ( string s ) { vector < int > a ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) a [ i ] = s [ i ] - '0' ; vector < int > b ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( ( a [ i ] ) % 2 != 0 ) b . push_back ( a [ i ] ) ; } sort ( b . begin ( ) , b . end ( ) ) ; if ( b . size ( ) > 1 ) return ( b [ 0 ] ) * 10 + ( b [ 1 ] ) ; return -1 ; }
int rankLessThanK ( int * arr , int k , int n ) { int rank = 1 ; int position = 1 ; sort ( arr , arr + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
bool search ( int arr [ ] , int n , int x ) { int res = -1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == -1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
void printDuplicates ( int arr [ ] , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { cout << arr [ i ] % n << " ▁ " ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) cout << " - 1" ; }
void linearCongruentialMethod ( int Xo , int m , int a , int c , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } }
int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } cout << " Sum ▁ = ▁ " << sum ; cout << " Product = " }
int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
int binarySearch ( string arr [ ] , string x , int n ) { int l = 0 ; int r = n - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( x == ( arr [ m ] ) ) res = 0 ; if ( res == 0 ) return m ; if ( x > ( arr [ m ] ) ) l = m + 1 ; else r = m - 1 ; } return -1 ; }
int findKCF ( int x , int y , int k ) { int small = min ( x , y ) ; int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return -1 ; }
int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return pow ( 2 , E - 1 ) ; }
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != -1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
void contain ( int L , int U , int M ) { int count = 0 ; for ( int j = L ; j < U ; j ++ ) { set < string > num ; string str = to_string ( j ) ; num . insert ( str ) ; if ( j % M == 0 and num . find ( to_string ( M ) ) == num . end ( ) ) { count += 1 ; } } cout << count - 2 ; }
LLI totalTriangles ( LLI h , LLI v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; LLI Total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return Total ; }
int getM ( int n ) { if ( n == 1 ) return -1 ; else return n - 2 ; }
int countStrings ( int n , int m , string s [ ] ) { unordered_set < int > ind ; for ( int j = 0 ; j < m ; j ++ ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = max ( mx , ( int ) s [ i ] [ j ] - '0' ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] - '0' == mx ) ind . insert ( i ) ; } return ind . size ( ) ; }
bool isPowerOfK ( unsigned int n , unsigned int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
void completeSuquence ( string s ) { int n = s . length ( ) ; int open = 0 , close = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) open ++ ; else close ++ ; if ( close > open ) { cout << " Impossible " << endl ; return ; } } cout << s ; for ( int i = 0 ; i < open - close ; i ++ ) cout << ' ) ' ; cout << endl ; }
long countRhombi ( int h , int w ) { long long ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
int center_hexadecagonal_num ( long int n ) { return 8 * n * n - 8 * n + 1 ; }
void prevGreater ( int arr [ ] , int n ) { cout << " - 1 , ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { cout << arr [ j ] << " , ▁ " ; break ; } } if ( j == -1 ) cout << " - 1 , ▁ " ; } }
void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) cout << i << " ▁ " ; }
double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
float harmonicMean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }
void findNthTerm ( int n ) { cout << pow ( 2 , n ) - 2 * n << endl ; }
int minOperation ( int N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } int k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ; t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
int findCountOfSolutions ( int n , int p ) { ll ans = 0 ; for ( ll x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { ll last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
int perfectPowerOf2 ( unsigned int n ) { unsigned int per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
bool isSumEqual ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = 0 ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
void cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; cout << cosx ; }
void findPoint ( int n , int h ) { for ( int i = 1 ; i < n ; i ++ ) printf ( " % .2f ▁ " , sqrt ( i / ( n * 1.0 ) ) * h ) ; }
int find ( int index , int openbrk , int n , int adj [ ] [ 2 ] ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != -1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
int countSubarrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { ll product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
void canMakeEqual ( string S ) { int N = S . size ( ) ; int weightOfString = 0 ; for ( int i = 0 ; i < N ; i ++ ) { weightOfString += S [ i ] - ' a ' + 1 ; } if ( weightOfString % N == 0 ) cout << " Yes " ; else cout << " No " ; }
int minSumDifference ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; int rem = sum % n ; return rem * ( n - rem ) ; }
int singleNumber ( int nums [ ] , int n ) { map < int , int > m ; long sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( m [ nums [ i ] ] == 0 ) { sum1 += nums [ i ] ; m [ nums [ i ] ] ++ ; } sum2 += nums [ i ] ; } return 2 * ( sum1 ) - sum2 ; }
int areaSquare ( int L , int B ) { int large = max ( L , B ) ; int small = min ( L , B ) ; if ( large >= 2 * small ) return large * large ; else return ( 2 * small ) * ( 2 * small ) ; }
int LIS ( int a [ ] , int n ) { int dp [ N ] , d [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
int findMinDiff ( int arr [ ] , int n ) { int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] ) ; return diff ; }
bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
unsigned countOfMultiples ( unsigned n ) { return ( n / 3 + n / 5 - n / 15 ) ; }
int minSteps ( string str , int n , int k ) { if ( str [ n - 1 ] == '0' ) return -1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; int dp [ n ] ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( int i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) continue ; int steps = INT_MAX ; if ( i + k < n && str [ i + k ] == '1' ) steps = min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == '1' ) steps = min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == '1' ) steps = min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == INT_MAX ) ? steps : 1 + steps ; } if ( dp [ 0 ] == INT_MAX ) return -1 ; return dp [ 0 ] ; }
int totalSubSets ( ll n , ll l , ll r ) { ll zero = floor ( ( double ) r / 3 ) - ceil ( ( double ) l / 3 ) + 1 ; ll one = floor ( ( double ) ( r - 1 ) / 3 ) - ceil ( ( double ) ( l - 1 ) / 3 ) + 1 ; ll two = floor ( ( double ) ( r - 2 ) / 3 ) - ceil ( ( double ) ( l - 2 ) / 3 ) + 1 ; ll dp [ n ] [ 3 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( ll i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
int matrixSum ( int arr [ ] [ n ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
bool isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
string compute ( string str , int n ) { string reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " ; int l = str . length ( ) ; for ( int i = n ; i < l ; i ++ ) str [ i ] = reverseAlphabet [ str [ i ] - ' a ' ] ; return str ; }
int CountTriplets ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int first = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
int cntSubsets ( int * arr , int n ) { int a [ n ] , b [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } int result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
int findOddPair ( int A [ ] , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
int minimumAdjacentDifference ( vector < int > a , int n , int k ) { int minDiff = INT_MAX ; for ( int i = 0 ; i <= k ; i ++ ) { int maxDiff = INT_MIN ; for ( int j = 0 ; j < n - k - 1 ; j ++ ) { for ( int p = i ; p <= i + j ; p ++ ) { maxDiff = max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; } } minDiff = min ( minDiff , maxDiff ) ; } return minDiff ; }
int divisible ( string num ) { int n = num . length ( ) ; int sum = accumulate ( begin ( num ) , end ( num ) , 0 ) - '0' * 1 ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return -1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ; if ( n == 2 ) return -1 ; return 2 ; }
int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { cout << i << " ▁ " << j << " ▁ " << k ; return ; } } } } } } }
int MinOperation ( int a [ ] , int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result = result + abs ( a [ i ] - b [ i ] ) ; } return result ; }
int ceilDifference ( int arr [ ] , int n , int x ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += ceil ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int totalCeilSum = ceil ( ( double ) ( totalSum ) / ( double ) ( x ) ) ; return abs ( perElementSum - totalCeilSum ) ; }
void checkArrangement ( int A1 [ ] , int A2 [ ] , int n , int k ) { sort ( A1 , A1 + n ) ; sort ( A2 , A2 + n , greater < int > ( ) ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) cout << " No " ; else cout << " Yes " ; }
int findEletobeInserted ( int A [ ] , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) return ans ; }
int deleteElement ( int A [ ] , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
void compareVal ( int x , int y ) { long double a = y * log ( x ) ; long double b = x * log ( y ) ; if ( a > b ) cout << x << " ^ " << y << " ▁ > ▁ " << y << " ^ " << x ; else if ( a < b ) cout << x << " ^ " << y << " ▁ < ▁ " << y << " ^ " << x ; else if ( a == b ) cout << x << " ^ " << y << " ▁ = ▁ " << y << " ^ " << x ; }
int countStrings ( int n ) { int a [ n ] , b [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
void countSubstring ( string s ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int x = 0 ; for ( int j = i ; j < s . length ( ) ; j ++ ) { int temp = 1 << s [ j ] - ' a ' ; x ^= temp ; if ( ( x & ( x - 1 ) ) == 0 ) res ++ ; } } cout << res ; }
int noOfTriangles ( int n ) { return floor ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
void findAandB ( int N ) { int K = log2 ( N ) ; int B = ( 1 << K ) ; int A = B ^ N ; cout << A << ' ▁ ' << B ; }
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
int minServerLoads ( int n , vector < int > & servers ) { int totalLoad = 0 ; for ( int i : servers ) totalLoad += i ; int requiredLoad = totalLoad / 2 ; vector < vector < int > > dp ( n + 1 , vector < int > ( requiredLoad + 1 , 0 ) ) ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n ] [ requiredLoad ] ; }
void minimumOperations ( int arr [ ] , int N ) { int mx = 0 , pos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } cout << ( mx - 1 ) * N + pos + 1 ; }
int day_of_the_week ( int y , int m , int d ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ) ; }
long countPairsBruteForce ( long long X [ ] , long long Y [ ] , long long m , long long n ) { long long ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( pow ( X [ i ] , Y [ j ] ) > pow ( Y [ j ] , X [ i ] ) ) ans ++ ; return ans ; }
bool sumSquare ( int n ) { for ( long i = 1 ; i * i <= n ; i ++ ) for ( long j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { cout << i << " ^ 2 ▁ + ▁ " << j << " ^ 2" << endl ; return true ; } return false ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
int term ( int n ) { int x = ( ( ( 1 ) + ( double ) sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
int findCnt ( string & s , int i , int r ) { if ( i == s . size ( ) ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i ] [ r ] ; }
int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; }
void insertNames ( string arr [ ] , int n ) { unordered_set < string > set ; for ( int i = 0 ; i < n ; i ++ ) { if ( set . find ( arr [ i ] ) == set . end ( ) ) { cout << " No STRNEWLINE " ; set . insert ( arr [ i ] ) ; } else { cout << " Yes STRNEWLINE " ; } } }
void solve ( int a [ ] , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos ) a [ ind ++ ] = 2 ; bool evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; }
int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
int countStrings ( string s ) { int cnt = 0 ; for ( int i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
bool isReversible ( string str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
void longestAlternating ( int arr [ ] , int n ) { int count [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count [ i ] << " ▁ " ; }
void constructArray ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << i << " ▁ " ; } }
int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
char findExtraCharcter ( string strA , string strB ) { unordered_map < char , int > m1 ; for ( int i = 0 ; i < strB . length ( ) ; i ++ ) m1 [ strB [ i ] ] ++ ; for ( int i = 0 ; i < strA . length ( ) ; i ++ ) m1 [ strA [ i ] ] -- ; for ( auto h1 = m1 . begin ( ) ; h1 != m1 . end ( ) ; h1 ++ ) { if ( h1 -> second == 1 ) return h1 -> first ; } }
void generatepermutation ( int N ) { vector < int > answer ; answer . push_back ( N ) ; for ( int i = 1 ; i < N ; i ++ ) { answer . push_back ( i ) ; } for ( int i : answer ) cout << i << " ▁ " ; }
void EditDistDP ( string str1 , string str2 ) { int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; int DP [ 2 ] [ len1 + 1 ] ; memset ( DP , 0 , sizeof DP ) ; for ( int i = 0 ; i <= len1 ; i ++ ) DP [ 0 ] [ i ] = i ; for ( int i = 1 ; i <= len2 ; i ++ ) { for ( int j = 0 ; j <= len1 ; j ++ ) { if ( j == 0 ) DP [ i % 2 ] [ j ] = i ; else if ( str1 [ j - 1 ] == str2 [ i - 1 ] ) { DP [ i % 2 ] [ j ] = DP [ ( i - 1 ) % 2 ] [ j - 1 ] ; } else { DP [ i % 2 ] [ j ] = 1 + min ( DP [ ( i - 1 ) % 2 ] [ j ] , min ( DP [ i % 2 ] [ j - 1 ] , DP [ ( i - 1 ) % 2 ] [ j - 1 ] ) ) ; } } } cout << DP [ len2 % 2 ] [ len1 ] << endl ; }
int printPairs ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << endl ; }
int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
int largest ( int arr [ ] , int n ) { return * max_element ( arr , arr + n ) ; }
bool pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
int centeredDodecagonal ( long int n ) { return 6 * n * ( n - 1 ) + 1 ; }
void printString ( string str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; bool used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = 1 ; for ( int j = 0 ; j < ones ; j ++ ) cout << "1" ; } if ( str [ i ] != '1' ) cout << str [ i ] ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) cout << "1" ; }
int countTriangles ( int a [ ] , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; }
int mod ( string num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; }
bool isKPartitionPossible ( int arr [ ] , int N , int K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; int target = sum / K ; int dp [ ( 1 << 15 ) ] ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = -1 ; dp [ 0 ] = 0 ; for ( int mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == -1 ) continue ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! ( mask & ( 1 << i ) ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; }
void maxSum ( int a [ ] , int n ) { int maxAnd = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxAnd = max ( maxAnd , a [ i ] ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR = maxOR | a [ i ] ; } cout << maxAnd + maxOR ; }
int deleteElement ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; int prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { int curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
bool isNumber ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ; return true ; }
string check ( int current_row , int current_col , int destination_row , int destination_col ) { if ( current_row == destination_row ) return " POSSIBLE " ; else if ( current_col == destination_col ) return " POSSIBLE " ; else return " NOT ▁ POSSIBLE " ; }
void minimumOperations ( int arr [ ] , int N ) { int oddCnt = 0 , evenCnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } cout << min ( oddCnt , evenCnt ) ; }
void highestPowerOfTwo ( int num ) { string s = to_string ( num ) ; for ( int i = 0 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == '0' ) { cout << "0" ; continue ; } int lg = log2 ( int ( s [ i ] ) - 48 ) ; int p = pow ( 2 , lg ) ; cout << char ( p + 48 ) ; } }
int countPairs ( int arr [ ] , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } int ans = ( N - odd + odd / 2 - 1 ) + odd / 2 ; return ans ; }
double minAnglRot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; }
bool pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
string isAnBn ( string str ) { int n = str . length ( ) ; if ( n & 1 ) return " No " ; int i ; for ( i = 0 ; i < n / 2 ; i ++ ) if ( str [ i ] != ' a ' str [ n - i - 1 ] != ' b ' ) return " No " ; return " Yes " ; }
int reduceZero ( int N ) { vector < int > dp ( N + 1 , 1e9 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( char c : to_string ( i ) ) { dp [ i ] = min ( dp [ i ] , dp [ i - ( c - '0' ) ] + 1 ) ; } } return dp [ N ] ; }
void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; cout << res ; }
float angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; float den = sqrt ( pow ( ( x2 - x1 ) , 2 ) + pow ( ( y2 - y1 ) , 2 ) + pow ( ( z2 - z1 ) , 2 ) ) * sqrt ( pow ( ( x3 - x1 ) , 2 ) + pow ( ( y3 - y1 ) , 2 ) + pow ( ( z3 - z1 ) , 2 ) ) ; float angle = acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
bool areChractersUnique ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
int absSumDidd ( int a [ ] , int n ) { sort ( a , a + n ) ; int midValue = a [ ( int ) ( n / 2 ) ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + abs ( a [ i ] - midValue ) ; } return sum ; }
int possibleTriplets ( int arr [ ] , int N ) { int freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( freq * 1LL * ( freq - 1 ) * ( freq - 2 ) ) / 6 ; }
void checkSolveable ( int n , int m ) { if ( n == 1 or m == 1 ) cout << " YES " ; else if ( m == 2 and n == 2 ) cout << " YES " ; else cout << " NO " ; }
int lastRemaining ( int n , map < int , int > & dp ) { if ( dp . find ( n ) != dp . end ( ) ) return dp [ n ] ; if ( n == 1 ) return 1 ; else dp [ n ] = 2 * ( 1 + n / 2 - lastRemaining ( n / 2 , dp ) ) ; return dp [ n ] ; }
int findSteps ( int n , int m , int a [ ] ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
void checksum ( int n ) { if ( n % 3 == 0 ) cout << n / 3 - 1 << " ▁ " << n / 3 << " ▁ " << n / 3 + 1 ; else cout << " - 1" ; }
void minOpsToEmptyString ( string S , int N ) { int one = 0 , zero = 0 ; int x0 = 0 , x1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '0' ) { x0 ++ ; x1 = 0 ; } else { x1 ++ ; x0 = 0 ; } zero = max ( x0 , zero ) ; one = max ( x1 , one ) ; } cout << max ( one , zero ) << endl ; }
int smallestOdd ( int n ) { if ( n == 1 ) return 1 ; return pow ( 10 , n - 1 ) + 1 ; }
string largestSubStr ( string s ) { while ( s . size ( ) and s [ s . size ( ) - 1 ] == '1' ) s . pop_back ( ) ; if ( s . size ( ) == 0 ) return " - 1" ; else return s ; }
float areacircumscribed ( float a ) { return ( a * a * ( PI / 2 ) ) ; }
int minimumLength ( int x , int y , int z ) { return 1 + abs ( x - y ) + abs ( y - z ) ; }
int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { sort ( arr1 , arr1 + n1 ) ; sort ( arr2 , arr2 + n2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }
int countPairs ( int * P , int * Q , int N , int M ) { int A [ 2 ] = { 0 } , B [ 2 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
int distinctCount ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( abs ( arr [ i ] ) ) ; return s . size ( ) ; }
int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ; } else { return pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ; } }
int checkArray ( int arr [ ] , int N , int k ) { if ( N < 3 ) return -1 ; int i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; int R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; int Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
int solve ( int A [ ] , int N ) { int i = 0 ; int k = 0 ; for ( int j = 1 ; j < N ; j ++ ) { int tempK = min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
int longestSubsequenceCommonSegment ( int k , string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int lcs [ n + 1 ] [ m + 1 ] ; int cnt [ n + 1 ] [ m + 1 ] ; memset ( lcs , 0 , sizeof ( lcs ) ) ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
int cntPairs ( int a [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
int icosikaipentagonNum ( int N ) { return ( 23 * N * N - 21 * N ) / 2 ; }
int smallestNth ( int A , int B , int N ) { int res = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { int D = ( B - A ) / ( j - i ) ; int FirstTerm = A - ( i - 1 ) * D ; int NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = min ( res , NthTerm ) ; } } } return res ; }
