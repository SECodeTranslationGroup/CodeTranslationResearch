function changeEvenBits ( n ) { let to_subtract = 0 ; let m = 0 ; for ( x = n ; x ; x >>= 2 ) { if ( x & 1 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
function checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
function FindPairs ( n , k ) { document . write ( 1 + " " + n + " " ) ; k -- ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { document . write ( 1 + " " + i + " " ) ; k -- ; if ( k == 0 ) break ; if ( i != n / i ) { document . write ( 1 + " " + n / i + " " ) ; k -- ; } if ( k == 0 ) break ; } } }
function decrypt ( Str , Start , End ) { if ( Start > End ) { return ; } let mid = ( Start + End ) >> 1 ; document . write ( Str [ mid ] ) ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
function prefixDivisble ( n ) { let i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = parseInt ( n / 10 ) ; i ++ ; } return true ; }
function minimum_required_operations ( arr , n , k ) { let answer = 0 ; let mod = 1000000007 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
function transpose ( A ) { for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) { var temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; transpose ( A ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( A [ i ] [ j ] + " " ) ; document . write ( " \< " ) ; }
function checkFactors ( N ) { let ev_count = 0 , od_count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == Math . floor ( N / i ) ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( Math . floor ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function findevenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; let oddCount = parseInt ( ( count * ( count - 1 ) ) / 2 ) ; return parseInt ( ( N * ( N - 1 ) ) / 2 ) - oddCount ; }
function countIntegralSolutions ( n ) { let result = 0 ; for ( let i = 0 ; i <= n ; i ++ ) for ( let j = 0 ; j <= n - i ; j ++ ) for ( let k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
function EnneacontahexagonNum ( n ) { return ( 94 * n * n - 92 * n ) / 2 ; }
function CountPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
function Findpermutation ( n ) { let a = new Array ( n + 1 ) ; a [ 1 ] = n ; for ( let i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }
function countSetBits ( n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
function minTime ( arr , n ) { if ( n <= 0 ) return 0 ; let incl = arr [ 0 ] ; let excl = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let incl_new = arr [ i ] + Math . min ( excl , incl ) ; let excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
function countValues ( x ) { var count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x = parseInt ( x / 2 ) ; } return count ; }
function countPairs ( arr , n ) { let ans = 0 ; let count = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( count . has ( arr [ i ] ) ) { ans += count . get ( arr [ i ] ) ; count . set ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; } else { count . set ( arr [ i ] , 1 ) ; } } return ans ; }
function findRadius ( r1 , r2 ) { let a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . sqrt ( a3 / 3.14 ) ; return r3 ; }
function BeattySequence ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { let ans = parseInt ( Math . floor ( i * Math . sqrt ( 2 ) ) ) ; document . write ( ans + " " ) ; } }
function testSomeNumbers ( limit , n ) { if ( n < 3 ) return ; for ( let a = 1 ; a <= limit ; a ++ ) for ( let b = a ; b <= limit ; b ++ ) { let pow_sum = ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; let c = Math . pow ( pow_sum , 1.0 / n ) ; let c_pow = Math . pow ( Math . round ( c ) , n ) ; if ( c_pow == pow_sum ) { document . write ( " " ) ; return ; } } document . write ( " " + " " ) ; }
function freq ( ar , m , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < m ; ++ i ) { for ( let j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } document . write ( " " + odd + " " ) ; document . write ( " " + even + " " ) ; }
function findSum ( arr , n , k ) { var ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( var i = 1 ; i <= k ; i ++ ) { ans = Math . min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
function countSubStr ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) m ++ ; } return m * Math . floor ( ( m - 1 ) / 2 ) ; }
function search ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
function findPairs ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; arr . sort ( ( a , b ) => a - b ) ; let left = 0 ; let ans = 0 ; for ( let right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } document . write ( ans ) ; }
function possibleStrings ( n , r , b , g ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; let left = n - ( r + g + b ) ; let sum = 0 ; for ( let i = 0 ; i <= left ; i ++ ) { for ( let j = 0 ; j <= left - i ; j ++ ) { let k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
function pairStar ( input , i ) { output = output + input [ i ] ; if ( i == input . length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' ' ; pairStar ( input , i + 1 ) ; }
function findLCMPrime ( a , b ) { if ( a == b ) { return a ; } return a * b ; }
function getFinalElement ( n ) { let finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
function get ( x , y , z ) { if ( x > z ) return - 1 ; let val = z - x ; let div = Math . floor ( ( z - x ) / y ) ; let ans = div * y + x ; return ans ; }
function checkForSorting ( arr , n ) { let temp = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
function printModulus ( X , Y ) { var n = Math . max ( X , Y ) ; for ( var i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) document . write ( i + " " ) ; } }
function findMinLength ( arr ) { let index = parseInt ( arr . length ) - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }
function countCon ( ar , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; }
function factorial ( n ) { let M = 1000000007 ; let f = 1 ; for ( let i = 1 ; i <= n ; i ++ ) return f ; }
function possibleToReach ( x , y , z ) { if ( z < Math . abs ( x ) + Math . abs ( y ) || ( z - Math . abs ( x ) - Math . abs ( y ) ) % 2 == 1 ) { document . write ( " " + " " ) ; } else document . write ( " " + " " ) ; }
function sum ( x , y , n ) { sum1 = ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ; sum2 = ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }
function flipBitsOfAandB ( A , B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; document . write ( A + " " + B ) ; }
function countStrings ( s ) { let cnt = 0 ; for ( let i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
function findLargestString ( s , i , r ) { if ( i == s . length ) { if ( r == 0 ) return 0 ; else return - 1000000000 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = Math . max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
function productPairs ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 2 ; i ++ ) for ( let j = i + 1 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
function getCount ( arr , n , num1 , num2 ) { let i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; let j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = parseInt ( n / i , 10 ) ; let num1 = fir * k + sec ; let res = parseInt ( ( num1 / k ) , 10 ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = parseInt ( ( num2 / k ) , 10 ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }
function NumberofTimes ( str ) { var temporary_sum = 0 , count = 0 ; while ( str . length > 1 ) { temporary_sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) temporary_sum += ( str . charAt ( i ) - ' ' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
function ReuleauxArea ( r ) { if ( r < 0 ) return - 1 ; var A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }
function findMinRooms ( slots , n , m ) { let counts = Array ( m ) . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == ' ' ) counts [ j ] ++ ; let max = - 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
function thirdLargest ( arr , arr_size ) { if ( arr_size < 3 ) { document . write ( " " ) ; return ; } let first = arr [ 0 ] ; for ( let i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; let second = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; let third = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; document . write ( " " + " " , third ) ; }
function isMember ( a , d , x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
function printSeriesSum ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += Math . pow ( i , i - 1 ) ; } document . write ( sum ) ; }
function validQuadruple ( arr , n ) { if ( n >= MAX ) return true ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
function hexadecagonalNum ( n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
function isDivisibleBy5 ( str ) { n = str . length ; return ( ( ( str [ n - 1 ] - ' ' ) == 0 ) || ( ( str [ n - 1 ] - ' ' ) == 5 ) ) ; }
function minTimeForWritingChars ( N , insert , remove , copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = 0 ; dp [ 1 ] = insert ; for ( let i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ parseInt ( i / 2 , 10 ) ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + copy + remove ) ; } return dp [ N ] ; }
function getTotalNumberOfSequences ( m , n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
function numberSequence ( n ) { let num = Math . pow ( 4 , n ) - Math . pow ( 2 , n ) - 1 ; return num ; }
function findSubarrays ( arr , N , K ) { return N - K + 1 ; }
function FindTrip ( arr , N ) { for ( let i = 1 ; i < N - 1 ; i ++ ) { let p = arr [ i - 1 ] ; let q = arr [ i ] ; let r = arr [ i + 1 ] ; if ( p < q && q > r ) { document . write ( ( i - 1 ) + " " + ( i ) + " " + ( i + 1 ) ) ; return ; } } document . write ( - 1 ) ; }
function polyapothem ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
function reverse ( str , len , l , r ) { if ( l < 0 r >= len l > r ) return " " ; while ( l < r ) { let c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } return str . join ( " " ) ; }
function divide ( dividend , divisor ) { var sign = ( ( dividend < 0 ) ? 1 : 0 ^ ( divisor < 0 ) ? 1 : 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; var quotient = 0 , temp = 0 ; while ( dividend >= divisor ) { dividend -= divisor ; ++ quotient ; } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
function MinimumMoves ( a , n , x ) { var ans = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { var p = parseInt ( ( a [ i - 1 ] - a [ i ] ) / x + 1 ) ; ans += p ; a [ i ] += p * x ; } } return ans ; }
function power ( n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
function subsequence ( S , T , n , m ) { let dp = new Array ( ) for ( let i = 0 ; i < n + 1 ; i ++ ) { let temp = [ ] ; for ( let j = 0 ; j < m + 1 ; j ++ ) { temp . push ( [ ] ) } dp . push ( temp ) } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( let j = 0 ; j <= m ; j ++ ) dp [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j <= m ; ++ j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; dp [ i ] [ j ] += mod ; dp [ i ] [ j ] %= mod ; } } return dp [ n ] [ m ] ; }
function findMaxSum ( arr , n ) { let preSum = new Array ( n ) ; preSum . fill ( 0 ) ; let suffSum = new Array ( n ) ; suffSum . fill ( 0 ) ; let ans = Number . MIN_VALUE ; preSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }
function minMoves ( arr ) { let N = arr . length ; if ( N <= 2 ) return 0 ; let ans = Number . MAX_VALUE ; for ( let i = - 1 ; i <= 1 ; i ++ ) { for ( let j = - 1 ; j <= 1 ; j ++ ) { let num1 = arr [ 0 ] + i ; let num2 = arr [ 1 ] + j ; let flag = 1 ; let moves = Math . abs ( i ) + Math . abs ( j ) ; for ( let idx = 2 ; idx < N ; idx ++ ) { let num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Number . MAX_VALUE ) return - 1 ; return ans ; }
function length_of_chord ( r , x ) { document . write ( " " + " " + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) + " " ) ; }
function max_min ( a , n ) { a . sort ( ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
function Permutation ( n , k ) { let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( let i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( let i = 1 ; i <= n ; i ++ ) document . write ( p [ i ] + " " ) ; }
function countElement ( A , N , B , M , K ) { let cnt = 0 ; for ( let i = 0 ; i < M ; i ++ ) { let currentElement = B [ i ] ; for ( let j = 0 ; j < N ; j ++ ) { let diff = Math . abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } document . write ( cnt ) ; }
function findFreq ( str , N ) { let freq = new Array ( 256 ) . fill ( 0 ) ; let max = 0 ; let charMax = ' ' ; for ( let i = 0 ; i < N ; i ++ ) { let ch = str [ i ] . charCodeAt ( 0 ) ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; charMax = ch ; } document . write ( String . fromCharCode ( charMax ) + " " + max + " " ) ; } }
function maxvolume ( s ) { let maxvalue = 0 ; for ( let i = 1 ; i <= s - 2 ; i ++ ) { for ( let j = 1 ; j <= s - 1 ; j ++ ) { let k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
function minLettersNeeded ( n ) { if ( n % 26 == 0 ) return parseInt ( n / 26 ) ; else return ( parseInt ( n / 26 ) + 1 ) ; }
function evenXorSubarray ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let XOR = 0 ; for ( let j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } document . write ( ans ) ; }
function equilibrium ( arr , n ) { sum = 0 ; leftsum = 0 ; for ( let i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
function countSubStr ( str , n , x ) { let res = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
function PrletBothArrays ( a , n ) { let v1 = [ ] , v2 = [ ] ; let mpp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { mpp . set ( a [ i ] , ( mpp . get ( a [ i ] ) == null ? 0 : mpp . get ( a [ i ] ) ) + 1 ) ; if ( mpp . get ( a [ i ] ) == 1 ) v1 . push ( a [ i ] ) ; else if ( mpp . get ( a [ i ] ) == 2 ) v2 . push ( a [ i ] ) ; else { document . write ( " " ) ; return ; } } v1 . sort ( ) ; document . write ( " " + " " ) ; for ( let i = 0 ; i < v1 . length ; i ++ ) document . write ( v1 [ i ] + " " ) ; v2 . sort ( ) ; v2 . reverse ( ) ; document . write ( " " + " " + " " ) ; for ( let i = 0 ; i < v2 . length ; i ++ ) document . write ( v2 [ i ] + " " ) ; }
function findTrailingZeros ( n ) { if ( n & 1 ) return 0 ; else { let ans = 0 ; n = parseInt ( n / 2 ) ; while ( n ) { ans += parseInt ( n / 5 ) ; n = parseInt ( n / 5 ) ; } return ans ; } }
function checkWord ( board , word , index , row , col ) { if ( row < 0 col < 0 row >= board . length col >= board [ 0 ] . length ) return false ; if ( board [ row ] [ col ] !== word [ index ] ) return false ; else if ( index === word . length - 1 ) return true ; var temp = board [ row ] [ col ] ; board [ row ] [ col ] = " " ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row ] [ col ] = temp ; return true ; } board [ row ] [ col ] = temp ; return false ; } var board = [ [ " " , " " , " " , " " ] , [ " " , " " , " " , " " ] , [ " " , " " , " " , " " ] , ] ; var word = " " ; var f = 0 ; for ( var i = 0 ; i < board . length ; i ++ ) { for ( var j = 0 ; j < board [ 0 ] . length ; j ++ ) { if ( board [ i ] [ j ] === word [ 0 ] && checkWord ( board , word , 0 , i , j ) ) { document . write ( " " ) ; f = 1 ; } } if ( f === 1 ) { i = board . length + 1 ; } } if ( f === 0 ) { document . write ( " " ) ; }
function printRoots ( a , b , c ) { document . write ( 1 + " " + c / ( a * 1.0 ) ) ; }
function findStarNum ( n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
function hexDiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.73 * a ; return d ; }
function countDigit ( n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( parseInt ( n / 10 ) ) ; }
function printLastElement ( arr , N ) { var leftTurn = true ; var remainElements = N ; var step = 1 ; var head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } document . write ( arr [ head - 1 ] ) ; }
function countDer ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
function countFreq ( arr , n ) { let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; let count = 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } document . write ( arr [ i ] + " " + count + " " ) ; } }
function calc_distance ( A , B , n ) { var distance_traveled_A = 0 ; var distance_traveled_B = 0 ; var answer = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
function pairs ( n ) { let c = new Array ( 10 ) ; for ( var i = 0 ; i < c . length ; i ++ ) { c [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < c . length ; i ++ ) { for ( var j = 0 ; j < c . length ; j ++ ) { c [ i ] [ j ] = 0 ; } } let tmp = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ Math . floor ( i / tmp ) ] [ i % 10 ] ++ ; } let ans = 0 ; for ( let i = 1 ; i < 10 ; i ++ ) for ( let j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
function linearSearch ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
function minOperations ( str , n ) { var count = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; }
function minOperation ( arr ) { let minOp = Number . MIN_VALUE ; let minNeg = 0 , maxPos = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return Math . abs ( minNeg ) + maxPos ; }
function maxHamming ( arr , n ) { let brr = new Array ( 2 * n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; let maxHam = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let currHam = 0 ; for ( let j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
function mod ( a , m ) { return ( a % m + m ) % m ; }
function check ( arr , N ) { let even = 0 ; let odd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) document . write ( " " ) ; else document . write ( " " ) ; }
function count ( n , k ) { let count = Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ; document . write ( count ) ; }
function sumOfInternalAngles ( n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; }
function countNumbers ( N ) { return parseInt ( ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 , 10 ) ; }
function countToMake0lternate ( s ) { let result = 0 ; for ( let i = 0 ; i < ( s . length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
function check ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) { var hm = new Map ( ) ; var count = 0 ; for ( var j = i ; j < n ; j ++ ) { if ( hm . has ( arr [ j ] ) ) hm . set ( arr [ j ] , hm . get ( arr [ j ] ) + 1 ) else hm . set ( arr [ j ] , 1 ) if ( hm . get ( arr [ j ] ) == 1 ) count ++ ; if ( hm . get ( arr [ j ] ) == 2 ) count -- ; if ( count == 0 ) return " " ; } } return " " ; }
